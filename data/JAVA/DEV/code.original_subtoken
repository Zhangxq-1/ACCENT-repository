public int hash Code ( ) { return value . hash Code ( ) ; }
public void on Start ( ) { }
@ Override protected void property Change ( Property Change Event evt ) { if ( Sea Glass Look And Feel . should Update Style ( evt ) ) { update Style ( ( J Text Component ) evt . get Source ( ) ) ; } super . property Change ( evt ) ; }
@ Not Null public Psi Query filter ( @ Not Null final Class < ? extends Psi Named Element > clazz , @ Not Null final String name ) { final Set < Psi Element > result = new Hash Set < Psi Element > ( Arrays . as List ( my Psi Elements ) ) ; for ( final Psi Element element : my Psi Elements ) { final Psi Named Element named Element = Py Util . as ( element , clazz ) ; if ( ( named Element == null ) || ( ! name . equals ( named Element . get Name ( ) ) ) ) { result . remove ( element ) ; } } return new Psi Query ( result . to Array ( new Psi Element [ result . size ( ) ] ) ) ; }
protected void write Qualified Name ( String ns Alias , String name ) throws IO Exception { if ( ns Alias != null && ns Alias . length ( ) > NUM ) { writer . write ( ns Alias ) ; writer . write ( STRING ) ; } writer . write ( name ) ; }
public Text Editor delete All ( String pattern ) { return replace All ( pattern , STRING ) ; }
public synchronized Gcm Helper add Registration Callback ( @ Non Null Context context , @ Non Null Gcm Registration Listener registration Listener , boolean sticky ) { if ( null == registration Callbacks ) { registration Callbacks = new Concurrent Linked Queue < > ( ) ; } registration Callbacks . add ( registration Listener ) ; if ( sticky && ! Text Utils . is Empty ( this . push Token ) ) { registration Listener . on Token Available ( context , push Token , BOOL ) ; } return this ; }
@ Override public void accept Training Set ( Training Set Event e ) { Instances training Set = e . get Training Set ( ) ; Data Set Event dse = new Data Set Event ( this , training Set ) ; accept Data Set ( dse ) ; }
< T > List < T > on Find ( Class < T > model Class , String [ ] columns , String [ ] conditions , String order By , String limit , boolean is Eager ) { Base Utility . check Conditions Correct ( conditions ) ; List < T > data List = query ( model Class , columns , get Where Clause ( conditions ) , get Where Args ( conditions ) , null , null , order By , limit , get Foreign Key Associations ( model Class . get Name ( ) , is Eager ) ) ; return data List ; }
private boolean is Agent Empty ( Agent agent ) { if ( agent != null ) { String first = agent . get First Name ( ) ; String last = agent . get Last Name ( ) ; String email = agent . get Email ( ) ; String home = agent . get Homepage ( ) ; String org = agent . get Organisation ( ) ; String phone = agent . get Phone ( ) ; String position = agent . get Position ( ) ; String city = null ; String street = null ; String country = null ; String code = null ; String province = null ; Address address = agent . get Address ( ) ; if ( address != null ) { city = address . get City ( ) ; street = address . get Address ( ) ; country = address . get Country ( ) ; code = address . get Postal Code ( ) ; province = address . get Province ( ) ; } String directory = null ; String identifier = null ; List < User Id > user Ids = agent . get User Ids ( ) ; if ( ! user Ids . is Empty ( ) ) { User Id user Id = user Ids . get ( NUM ) ; directory = user Id . get Directory ( ) ; identifier = user Id . get Identifier ( ) ; } return ( Strings . is Null Or Empty ( city ) && Strings . is Null Or Empty ( street ) && Strings . is Null Or Empty ( country ) && Strings . is Null Or Empty ( code ) && Strings . is Null Or Empty ( province ) && Strings . is Null Or Empty ( first ) && Strings . is Null Or Empty ( last ) && Strings . is Null Or Empty ( email ) && Strings . is Null Or Empty ( home ) && Strings . is Null Or Empty ( org ) && Strings . is Null Or Empty ( phone ) && Strings . is Null Or Empty ( position ) && Strings . is Null Or Empty ( directory ) && Strings . is Null Or Empty ( identifier ) ) ; } return BOOL ; }
public static byte [ ] calendar To Raw Bytes ( Calendar timestamp , boolean honor Device Time Offset ) { if ( honor Device Time Offset ) { int offset In Hours = Mi Band Coordinator . get Device Time Offset Hours ( ) ; if ( offset In Hours != NUM ) { timestamp . add ( Calendar . HOUR OF DAY , offset In Hours ) ; } } byte [ ] year = from Uint 16 ( timestamp . get ( Calendar . YEAR ) ) ; return new byte [ ] { year [ NUM ] , year [ NUM ] , from Uint 8 ( timestamp . get ( Calendar . MONTH ) + NUM ) , from Uint 8 ( timestamp . get ( Calendar . DATE ) ) , from Uint 8 ( timestamp . get ( Calendar . HOUR OF DAY ) ) , from Uint 8 ( timestamp . get ( Calendar . MINUTE ) ) , from Uint 8 ( timestamp . get ( Calendar . SECOND ) ) , day Of Week To Raw Bytes ( timestamp ) , NUM } ; }
private static void decode Base 256 Segment ( Bit Source bits , String Builder result , Collection < byte [ ] > byte Segments ) throws Format Exception { int codeword Position = NUM + bits . get Byte Offset ( ) ; int d1 = unrandomize 255 State ( bits . read Bits ( NUM ) , codeword Position ++ ) ; int count ; if ( d1 == NUM ) { count = bits . available ( ) / NUM ; } else if ( d1 < NUM ) { count = d1 ; } else { count = NUM * ( d1 - NUM ) + unrandomize 255 State ( bits . read Bits ( NUM ) , codeword Position ++ ) ; } if ( count < NUM ) { throw Format Exception . get Format Instance ( ) ; } byte [ ] bytes = new byte [ count ] ; for ( int i = NUM ; i < count ; i ++ ) { if ( bits . available ( ) < NUM ) { throw Format Exception . get Format Instance ( ) ; } bytes [ i ] = ( byte ) unrandomize 255 State ( bits . read Bits ( NUM ) , codeword Position ++ ) ; } byte Segments . add ( bytes ) ; try { result . append ( new String ( bytes , STRING ) ) ; } catch ( Unsupported Encoding Exception uee ) { throw new Illegal State Exception ( STRING + uee ) ; } }
protected void init BP Order Details ( int C B Partner ID , boolean for Invoice ) { log . config ( STRING + C B Partner ID ) ; Key Name Pair pp = new Key Name Pair ( NUM , STRING ) ; order Field . remove Action Listener ( this ) ; order Field . remove All Items ( ) ; order Field . add Item ( pp ) ; Array List < Key Name Pair > list = load Order Data ( C B Partner ID , for Invoice , same Warehouse Cb . is Selected ( ) ) ; for ( Key Name Pair knp : list ) order Field . add Item ( knp ) ; order Field . set Selected Index ( NUM ) ; order Field . add Action Listener ( this ) ; init BP Details ( C B Partner ID ) ; }
public Modpack Initialization Panel ( Wizard Controller controller , Map wizard Data , Vector < String > versions , String sel Version ) { init Components ( ) ; this . controller = controller ; this . wizard Data = wizard Data ; wizard Data . put ( KEY GAME VERSION , versions ) ; wizard Data . put ( STRING , sel Version ) ; wizard Data . put ( KEY INCLUDING LAUNCHER , BOOL ) ; configure Combo Contents ( ) ; check Problem ( ) ; }
public synchronized void remove ( int index ) { super . remove ( index ) ; double removed Value = m Value . remove ( index ) ; if ( removed Value == m Min Value || removed Value == m Max Value ) { init Range ( ) ; } }
private boolean coord Is Calendar Cell ( float y ) { return y > cell Height ; }
protected void sprint ( double double Field ) { sprint ( String . value Of ( double Field ) ) ; }
private int attribute Map ( String name ) { Integer num = map . get ( name ) ; if ( num == null ) { return NUM ; } return num . int Value ( ) ; }
private void group Player Standing CSV ( ) { for ( Player QB p : team Q Bs ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } for ( Player RB p : team R Bs ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } for ( Player WR p : team W Rs ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } for ( Player K p : team Ks ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } for ( Player OL p : team O Ls ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } for ( Player S p : team Ss ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } for ( Player CB p : team C Bs ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } for ( Player F 7 p : team F 7 s ) { if ( p . year == NUM ) team R Ss . add ( p ) ; else if ( p . year == NUM ) team F Rs . add ( p ) ; else if ( p . year == NUM ) team S Os . add ( p ) ; else if ( p . year == NUM ) team J Rs . add ( p ) ; else if ( p . year == NUM ) team S Rs . add ( p ) ; } }
public String list ( ) throws IO Exception , Tomcat Manager Exception { return invoke ( STRING , null , null ) ; }
public Attribute Filler ( Attributes Impl attributes , PO po To Auto Fill ) { attributes . clear ( ) ; atts = attributes ; po = po To Auto Fill ; }
public static final void to Byte Array ( Byte Array Output Stream output , String str ) { if ( str == null ) { return ; } output . write ( NUM ) ; int max = str . length ( ) ; for ( int i = NUM ; i < max ; i ++ ) { int b = str . char At ( i ) ; if ( ( b >= NUM ) && ( b <= NUM ) ) { switch ( b ) { case NUM : case NUM : output . write ( NUM ) ; break ; } output . write ( b ) ; } else { output . write ( NUM ) ; switch ( b ) { case NUM : output . write ( NUM ) ; break ; case NUM : output . write ( NUM ) ; break ; case NUM : output . write ( NUM ) ; break ; case NUM : output . write ( NUM ) ; break ; case NUM : output . write ( NUM ) ; break ; default : output . write ( NUM ) ; int b3 = b > > NUM ; int b4 = b & NUM ; if ( b4 < NUM ) b4 += NUM ; else b4 += NUM ; int b2 = b3 > > NUM ; b3 &= NUM ; if ( b3 < NUM ) b3 += NUM ; else b3 += NUM ; int b1 = b2 > > NUM ; b2 &= NUM ; if ( b2 < NUM ) b2 += NUM ; else b2 += NUM ; if ( b1 < NUM ) b1 += NUM ; else b1 += NUM ; output . write ( b1 ) ; output . write ( b2 ) ; output . write ( b3 ) ; output . write ( b4 ) ; break ; } } } output . write ( NUM ) ; }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . PUT ) @ Response Body public Rest Wrapper insert ( @ Model Attribute ( STRING ) @ Valid File file , Binding Result binding Result , Principal principal ) { Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { file . set Creation TS ( Date Converter . string To Date ( file . get Table Creation TS ( ) ) ) ; file DAO . insert ( file ) ; rest Wrapper = new Rest Wrapper ( file , Rest Wrapper . OK ) ; LOGGER . info ( STRING + file . get Batch Id ( ) + STRING + principal . get Name ( ) + file ) ; } catch ( Metadata Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
private void enable Updates ( ) { if ( lmgr != null ) { try { lmgr . add Gps Status Listener ( this ) ; lmgr . request Location Updates ( Location Manager . GPS PROVIDER , gps Logging Interval , NUM , this ) ; } catch ( Security Exception e ) { Log . e ( TAG , STRING ) ; } } }
private void add Integer ( ) { int old Pos = pos - NUM ; String literal = scan Integer ( ) ; final String substring ; final int radix ; if ( literal . starts With ( STRING ) || literal . starts With ( STRING ) ) { radix = NUM ; substring = literal . substring ( NUM ) ; } else if ( literal . starts With ( STRING ) && literal . length ( ) > NUM ) { radix = NUM ; substring = literal . substring ( NUM ) ; } else { radix = NUM ; substring = literal ; } int value = NUM ; try { value = Integer . parse Int ( substring , radix ) ; } catch ( Number Format Exception e ) { error ( STRING + radix + STRING + literal ) ; } add Token ( Token Kind . INT , old Pos , pos , value ) ; }
public void remove Mouse Listener ( Global Mouse Listener listener ) { listeners . remove ( listener ) ; }
public XML Document ( double version , boolean standalone ) { prolog = new Vector < Object > ( NUM ) ; String Buffer version Str = new String Buffer ( ) ; version Str . append ( STRING ) ; version Str . append ( version ) ; version Str . append ( STRING ) ; if ( standalone ) version Str . append ( STRING ) ; else version Str . append ( STRING ) ; this . version Decl = version Str . to String ( ) ; }
public Object Name create Distribution Locator ( String host , int port , String working Directory , String product Directory , String remote Command ) throws Malformed Object Name Exception { try { Distribution Locator Jmx Impl locator = ( Distribution Locator Jmx Impl ) add Distribution Locator ( ) ; Distribution Locator Config config = locator . get Config ( ) ; config . set Host ( host ) ; config . set Port ( port ) ; config . set Working Directory ( working Directory ) ; config . set Product Directory ( product Directory ) ; config . set Remote Command ( remote Command ) ; return new Object Name ( locator . get M Bean Name ( ) ) ; } catch ( Runtime Exception e ) { logger . warn ( e . get Message ( ) , e ) ; throw e ; } catch ( Virtual Machine Error err ) { System Failure . initiate Failure ( err ) ; throw err ; } catch ( Error e ) { System Failure . check Failure ( ) ; logger . error ( e . get Message ( ) , e ) ; throw e ; } }
void apply Center Panel ( Grass Marlin ui ) { if ( tree View Component != null ) { center Panel Component . add ( tree View Component , Split Pane . Position . CENTER ) ; } center Panel Component . add ( graph Component , Split Pane . Position . RIGHT ) ; center Panel Component . add ( log Component , Split Pane . Position . LEFT BOTTOM ) ; Border b = Border Factory . create Matte Border ( NUM , NUM , NUM , NUM , Color . GRAY ) ; Border b2 = Border Factory . create Matte Border ( NUM , NUM , NUM , NUM , Color . GRAY ) ; tree View Component . set Border ( b2 ) ; graph Component . set Border ( b ) ; log Component . set Border ( b2 ) ; center Panel Component . set Initial Size ( x , y ) ; Dimension d = new Dimension ( NUM , NUM ) ; ui . add ( new Filler ( d , d , d ) , Border Layout . WEST ) ; ui . add ( new Filler ( d , d , d ) , Border Layout . EAST ) ; ui . add ( center Panel Component , Border Layout . CENTER ) ; }
private boolean is Abstract ( String source ) { int nonterminal Count = NUM ; for ( String t : source . split ( STRING ) ) { if ( ! t . matches ( NT REGEX ) ) return BOOL ; nonterminal Count ++ ; } return nonterminal Count != NUM ; }
public static String UR Ifor Portable Path ( String path ) { if ( path . starts With ( File Util . PREFERENCES ) ) { return path . replace First ( File Util . PREFERENCES , STRING ) ; } else if ( path . starts With ( File Util . PROGRAM ) ) { return path . replace First ( File Util . PROGRAM , STRING ) ; } else { return null ; } }
public int hash Code ( ) { return Float . float To Int Bits ( value ) ; }
public static void log ( Throwable error , String message , Object ... args ) { if ( logging Enabled ) { Log . d ( TAG , args . length == NUM ? message : String . format ( message , args ) , error ) ; } }
public void add Extension Namespace ( String uri , Extension Handler ext NS ) { m extension Function Namespaces . put ( uri , ext NS ) ; }
private void generate Type Parameter Infos ( Binary Member parent , char [ ] signature , Hash Map new Elements , Array List type Parameter Handles ) { if ( signature == null ) return ; char [ ] [ ] type Parameter Signatures = Signature . get Type Parameters ( signature ) ; for ( int i = NUM , type Parameter Count = type Parameter Signatures . length ; i < type Parameter Count ; i ++ ) { char [ ] type Parameter Signature = type Parameter Signatures [ i ] ; char [ ] type Parameter Name = Signature . get Type Variable ( type Parameter Signature ) ; Char Operation . replace ( type Parameter Signature , STRING , STRING ) ; char [ ] [ ] type Parameter Bound Signatures = Signature . get Type Parameter Bounds ( type Parameter Signature ) ; int bound Length = type Parameter Bound Signatures . length ; char [ ] [ ] type Parameter Bounds = new char [ bound Length ] [ ] ; for ( int j = NUM ; j < bound Length ; j ++ ) { type Parameter Bounds [ j ] = Signature . to Char Array ( type Parameter Bound Signatures [ j ] ) ; } Type Parameter type Parameter = new Type Parameter ( parent , parent . manager , new String ( type Parameter Name ) ) ; Type Parameter Element Info info = new Type Parameter Element Info ( ) ; info . bounds = type Parameter Bounds ; info . bounds Signatures = type Parameter Bound Signatures ; type Parameter Handles . add ( type Parameter ) ; while ( new Elements . contains Key ( type Parameter ) ) type Parameter . occurrence Count ++ ; new Elements . put ( type Parameter , info ) ; } }
public final void test Next Bytesbyte Array 02 ( ) { byte [ ] my Bytes ; byte [ ] my Bytes 1 ; byte [ ] my Bytes 2 ; for ( int i = NUM ; i < LENGTH ; i += INCR ) { my Bytes = new byte [ i ] ; for ( int j = NUM ; j < i ; j ++ ) { my Bytes [ j ] = ( byte ) ( j & NUM ) ; } sr . set Seed ( my Bytes ) ; sr 2 . set Seed ( my Bytes ) ; for ( int k = NUM ; k < LENGTH ; k += INCR ) { my Bytes 1 = new byte [ k ] ; my Bytes 2 = new byte [ k ] ; sr . next Bytes ( my Bytes 1 ) ; sr 2 . next Bytes ( my Bytes 2 ) ; for ( int l = NUM ; l < k ; l ++ ) { assert False ( STRING + l + STRING + k + STRING + i + STRING + my Bytes 1 [ l ] + STRING + my Bytes 2 [ l ] , my Bytes 1 [ l ] != my Bytes 2 [ l ] ) ; } } } for ( int n = NUM ; n < LENGTH ; n += INCR ) { int n1 = NUM ; int n2 = NUM ; int n3 = NUM ; byte [ ] [ ] bytes 1 = new byte [ NUM ] [ n1 ] ; byte [ ] [ ] bytes 2 = new byte [ NUM ] [ n2 ] ; for ( int k = NUM ; k < bytes 1 . length ; k ++ ) { sr . next Bytes ( bytes 1 [ k ] ) ; } for ( int k = NUM ; k < bytes 2 . length ; k ++ ) { sr 2 . next Bytes ( bytes 2 [ k ] ) ; } for ( int k = NUM ; k < n3 ; k ++ ) { int i1 = k / n1 ; int i2 = k % n1 ; int i3 = k / n2 ; int i4 = k % n2 ; assert True ( STRING + i1 + STRING + i2 + STRING + i3 + STRING + i4 , bytes 1 [ i1 ] [ i2 ] == bytes 2 [ i3 ] [ i4 ] ) ; } } }
private void signal Not Empty ( ) { final Reentrant Lock take Lock = this . take Lock ; take Lock . lock ( ) ; try { not Empty . signal ( ) ; } finally { take Lock . unlock ( ) ; } }
public Routing Info ( Object o ) { this . text = o . to String ( ) ; }
private List < View > add View ( View view , List < View > cache ) { if ( cache == null ) { cache = new Linked List < View > ( ) ; } cache . add ( view ) ; return cache ; }
public static Cert Chain Key Pair generate Signed ( String fqdn , X509 Certificate issuer Certificate , Private Key issuer Private Key ) { try { return generate Certificate And Sign ( fqdn , issuer Certificate , issuer Private Key , get Server Extensions ( issuer Certificate ) ) ; } catch ( Certificate Exception | Operator Creation Exception | No Such Algorithm Exception | IO Exception e ) { throw new Runtime Exception ( String . format ( STRING , e . get Message ( ) ) , e ) ; } }
private void start Animation ( ) { Value Animator animator = Value Animator . of Float ( NUM ) ; Array List < Name Values Holder > name Value List = ( Array List < Name Values Holder > ) m Pending Animations . clone ( ) ; m Pending Animations . clear ( ) ; int property Mask = NUM ; int property Count = name Value List . size ( ) ; for ( int i = NUM ; i < property Count ; ++ i ) { Name Values Holder name Values Holder = name Value List . get ( i ) ; property Mask |= name Values Holder . m Name Constant ; } m Animator Map . put ( animator , new Property Bundle ( property Mask , name Value List ) ) ; animator . add Update Listener ( m Animator Event Listener ) ; animator . add Listener ( m Animator Event Listener ) ; if ( m Start Delay Set ) { animator . set Start Delay ( m Start Delay ) ; } if ( m Duration Set ) { animator . set Duration ( m Duration ) ; } if ( m Interpolator Set ) { animator . set Interpolator ( m Interpolator ) ; } animator . start ( ) ; }
public void add Request ( Request request ) { request Set . add ( request ) ; }
public static double logpmf ( double x , int n , double p ) { if ( x < NUM || x > n ) { return Double . NEGATIVE INFINITY ; } if ( p <= NUM ) { return x == NUM ? NUM : Double . NEGATIVE INFINITY ; } if ( p >= NUM ) { return x == n ? NUM : Double . NEGATIVE INFINITY ; } final double q = NUM - p ; if ( x == NUM ) { if ( p < NUM ) { return - deviance Term ( n , n * q ) - n * p ; } else { return n * Math . log ( q ) ; } } if ( x == n ) { if ( p > NUM ) { return - deviance Term ( n , n * p ) - n * q ; } else { return n * Math . log ( p ) ; } } final double lc = stirling Error ( n ) - stirling Error ( x ) - stirling Error ( n - x ) - deviance Term ( x , n * p ) - deviance Term ( n - x , n * q ) ; final double f = ( Math Util . TWOPI * x * ( n - x ) ) / n ; return lc - NUM * Math . log ( f ) ; }
private void byte 2 hex ( byte b , String Buffer buf ) { char [ ] hex Chars = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; int high = ( ( b & NUM ) > > NUM ) ; int low = ( b & NUM ) ; buf . append ( hex Chars [ high ] ) ; buf . append ( hex Chars [ low ] ) ; }
public static List < Geo Time Serie > timesplit ( Geo Time Serie gts , long quietperiod , int minvalues , String labelname ) { List < Geo Time Serie > series = new Array List < Geo Time Serie > ( ) ; if ( NUM == gts . values || gts . has Label ( labelname ) ) { series . add ( gts . clone ( ) ) ; return series ; } sort ( gts , BOOL ) ; long lasttick = gts . ticks [ NUM ] ; int idx = NUM ; int gtsid = NUM ; Geo Time Serie serie = new Geo Time Serie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , NUM ) ; serie . set Name ( gts . get Name ( ) ) ; Map < String , String > labels = new Hash Map < String , String > ( ) ; labels . put All ( gts . get Labels ( ) ) ; labels . put ( labelname , Integer . to String ( gtsid ) ) ; serie . set Labels ( labels ) ; while ( idx < gts . values ) { if ( gts . ticks [ idx ] - lasttick >= quietperiod ) { if ( serie . values > NUM && serie . values >= minvalues ) { series . add ( serie ) ; } serie = new Geo Time Serie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , NUM ) ; serie . set Name ( gts . get Name ( ) ) ; labels = new Hash Map < String , String > ( ) ; labels . put All ( gts . get Labels ( ) ) ; gtsid ++ ; labels . put ( labelname , Integer . to String ( gtsid ) ) ; serie . set Labels ( labels ) ; } Object value = GTS Helper . value At Index ( gts , idx ) ; GTS Helper . set Value ( serie , gts . ticks [ idx ] , null != gts . locations ? gts . locations [ idx ] : Geo Time Serie . NO LOCATION , null != gts . elevations ? gts . elevations [ idx ] : Geo Time Serie . NO ELEVATION , value , BOOL ) ; lasttick = gts . ticks [ idx ] ; idx ++ ; } if ( serie . values > NUM && serie . values >= minvalues ) { series . add ( serie ) ; } return series ; }
protected void check Signature ( byte [ ] buf ) { if ( ! Arrays . equals ( buf , Png Helper Internal . get Png Id Signature ( ) ) ) throw new Pngj Input Exception ( STRING ) ; }
private void two Way Merge Internal ( final Reservoir Longs Sketch sketch In , final boolean is Modifiable ) { if ( sketch In . get N ( ) <= sketch In . get K ( ) ) { two Way Merge Internal Standard ( sketch In ) ; } else if ( gadget . get N ( ) < gadget . get K ( ) ) { final Reservoir Longs Sketch tmp Sketch = gadget ; gadget = ( is Modifiable ? sketch In : sketch In . copy ( ) ) ; two Way Merge Internal Standard ( tmp Sketch ) ; } else if ( sketch In . get Implicit Sample Weight ( ) < gadget . get N ( ) / ( ( double ) ( gadget . get K ( ) - NUM ) ) ) { two Way Merge Internal Weighted ( sketch In ) ; } else { final Reservoir Longs Sketch tmp Sketch = gadget ; gadget = ( is Modifiable ? sketch In : sketch In . copy ( ) ) ; two Way Merge Internal Weighted ( tmp Sketch ) ; } }
final public void print ( Object v ) { Writer out = this . out ; if ( out == null ) return ; try { if ( v == null ) out . write ( null Chars , NUM , null Chars . length ) ; else { String s = v . to String ( ) ; out . write ( s , NUM , s . length ( ) ) ; } } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } }
public void subscribe To ( final K key , final Subscriber < V > subscriber , final Executor subscribe On ) { Completable Future . run Async ( null , subscribe On ) ; }
public static boolean copy Stream ( Input Stream is , Output Stream os , Copy Listener listener , int buffer Size ) throws IO Exception { int current = NUM ; int total = is . available ( ) ; if ( total <= NUM ) { total = DEFAULT IMAGE TOTAL SIZE ; } final byte [ ] bytes = new byte [ buffer Size ] ; int count ; if ( should Stop Loading ( listener , current , total ) ) return BOOL ; while ( ( count = is . read ( bytes , NUM , buffer Size ) ) != - NUM ) { os . write ( bytes , NUM , count ) ; current += count ; if ( should Stop Loading ( listener , current , total ) ) return BOOL ; } os . flush ( ) ; return BOOL ; }
private void refresh Buffer ( ) throws IO Exception { if ( output == null ) { throw new Out Of Space Exception ( ) ; } output . write ( buffer , NUM , position ) ; position = NUM ; }
public String damage Bay Door ( ) { String bay Type = STRING ; Vector < Bay > potential ; potential = new Vector < Bay > ( ) ; Enumeration < Transporter > iter = transports . elements ( ) ; while ( iter . has More Elements ( ) ) { Transporter next = iter . next Element ( ) ; if ( next instanceof Bay ) { Bay next Bay = ( Bay ) next ; if ( next Bay . get Doors ( ) > NUM ) { potential . add ( next Bay ) ; } } } if ( potential . size ( ) > NUM ) { Bay chosen Bay = potential . element At ( Compute . random Int ( potential . size ( ) ) ) ; chosen Bay . destroy Door ( ) ; chosen Bay . reset Doors ( ) ; chosen Bay . set Doors ( chosen Bay . get Doors ( ) - NUM ) ; bay Type = chosen Bay . get Type ( ) ; } return bay Type ; }
public void update Enabled State ( ) { boolean b = ( get Simulation Thread ( ) == null ) ; boolean prep = b && controller != null && controller . is Prepared ( ) ; clear Button . set Enabled ( b ) ; prepare Button . set Enabled ( b ) ; run Button . set Enabled ( prep ) ; if ( b ) pause Button . set Selected ( BOOL ) ; pause Button . set Enabled ( ! b ) ; step Button . set Enabled ( prep ) ; cancel Button . set Enabled ( ! b ) ; for ( J Combo Box < Object > combo : selectors . combos ) combo . set Enabled ( b ) ; }
private void prepare Volume Data ( ) throws Exception { prepare V Plex Volume Data ( ) ; prepare RP Volume Data ( ) ; }
private static int determine Icon Id By Mime Type List ( List < String > mimetypes ) { if ( mimetypes == null || mimetypes . size ( ) < NUM ) { return R . drawable . file ; } else { for ( String mimetype : mimetypes ) { Integer icon Id = MIMETYPE TO ICON MAPPING . get ( mimetype ) ; if ( icon Id != null ) { return icon Id ; } } for ( String mimetype : mimetypes ) { String main Mimetype Part = mimetype . split ( STRING ) [ NUM ] ; Integer icon Id = MAINMIMETYPE TO ICON MAPPING . get ( main Mimetype Part ) ; if ( icon Id != null ) { return icon Id ; } } } return R . drawable . file ; }
public Sms Mms Message ( Context context , long message Id , long thread Id , long timestamp , String message Body , int unread Count , int message Type ) { context = context ; message Id = message Id ; thread Id = thread Id ; timestamp = timestamp ; message Body = message Body ; unread Count = unread Count ; message Type = message Type ; from Address = Sms Popup Utils . get Mms Address ( context , message Id ) ; from Email Gateway = BOOL ; contact Name = Phone Number Utils . format Number ( from Address ) ; Contact Identification contact Identify = Sms Popup Utils . get Person Id From Phone Number ( context , from Address ) ; if ( contact Identify == null ) { contact Identify = Sms Popup Utils . get Person Id From Email ( context , from Address ) ; if ( contact Identify != null ) { from Email Gateway = BOOL ; } } if ( contact Identify != null ) { contact Id = contact Identify . contact Id ; contact Lookup Key = contact Identify . contact Lookup ; contact Name = contact Identify . contact Name ; } }
public void attribute As Class ( ) { Data Sorted Table Model model ; if ( m Current Col == - NUM ) { return ; } model = ( Data Sorted Table Model ) m Table Data . get Model ( ) ; if ( model . get Attribute At ( m Current Col ) == null ) { return ; } set Cursor ( Cursor . get Predefined Cursor ( Cursor . WAIT CURSOR ) ) ; model . attribute As Class At ( m Current Col ) ; set Cursor ( Cursor . get Predefined Cursor ( Cursor . DEFAULT CURSOR ) ) ; }
public void add Listener ( Refresh Listener listener ) { if ( listener == null ) { throw new Null Pointer Exception ( STRING ) ; } refresh Listeners . add ( listener ) ; }
public final void do Export ( final String track Name , final File target , int verbosity ) throws IO Exception { Log . i ( TAG , STRING + target . get Absolute Path ( ) ) ; m Db Helper = new Database Helper ( m Context . get Application Context ( ) ) ; final Buffered Writer bw = new Buffered Writer ( new File Writer ( target ) ) ; bw . write ( XML HEADER ) ; bw . write ( TAG GPX ) ; if ( verbosity == VERBOSITY TRACK AND WAYPOINTS || verbosity == VERBOSITY WAYPOINTS ONLY || verbosity == VERBOSITY ALL ) { write Waypoints ( bw ) ; } if ( verbosity == VERBOSITY TRACK AND WAYPOINTS || verbosity == VERBOSITY ALL ) { write Trackpoints ( track Name , bw ) ; } bw . flush ( ) ; if ( verbosity == VERBOSITY ALL ) { write Wifis ( bw ) ; bw . flush ( ) ; write Cells ( bw ) ; bw . flush ( ) ; } bw . write ( TAG GPX CLOSE ) ; bw . close ( ) ; m Db Helper . close ( ) ; Log . i ( TAG , STRING ) ; }
public List < V > values In Selection ( Rich Edit Text editor , int span Type ) { List < V > result = new Array List < V > ( ) ; Selection expanded Selection = get Expanded Selection ( editor , span Type ) ; if ( expanded Selection != null ) { for ( Span < V > span : get Spans ( editor . get Text ( ) , expanded Selection ) ) { result . add ( span . get Value ( ) ) ; } } return result ; }
private boolean is GTE Delta ( double value ) { return Math . abs ( value ) - Math . abs ( m Delta ) > - NUM ; }
public static String row To String ( JSON Array ja ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < ja . length ( ) ; i += NUM ) { if ( i > NUM ) { sb . append ( STRING ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . to String ( ) ; if ( string . length ( ) > NUM && ( string . index Of ( STRING ) >= NUM || string . index Of ( STRING ) >= NUM || string . index Of ( STRING ) >= NUM || string . index Of ( NUM ) >= NUM || string . char At ( NUM ) == STRING ) ) { sb . append ( STRING ) ; int length = string . length ( ) ; for ( int j = NUM ; j < length ; j += NUM ) { char c = string . char At ( j ) ; if ( c >= STRING && c != STRING ) { sb . append ( c ) ; } } sb . append ( STRING ) ; } else { sb . append ( string ) ; } } } sb . append ( STRING ) ; return sb . to String ( ) ; }
private void maybe Sample Sync Params ( ) { long playback Position Us = audio Track Util . get Playback Head Position Us ( ) ; if ( playback Position Us == NUM ) { return ; } if ( log . allow Verbose ( ) ) { log . v ( STRING + playback Position Us ) ; } long system Clock Us = System . nano Time ( ) / NUM ; if ( system Clock Us - last Playhead Sample Time Us >= MIN PLAYHEAD OFFSET SAMPLE INTERVAL US ) { playhead Offsets [ next Playhead Offset Index ] = playback Position Us - system Clock Us ; next Playhead Offset Index = ( next Playhead Offset Index + NUM ) % MAX PLAYHEAD OFFSET COUNT ; if ( playhead Offset Count < MAX PLAYHEAD OFFSET COUNT ) { playhead Offset Count ++ ; } last Playhead Sample Time Us = system Clock Us ; smoothed Playhead Offset Us = NUM ; for ( int i = NUM ; i < playhead Offset Count ; i ++ ) { smoothed Playhead Offset Us += playhead Offsets [ i ] / playhead Offset Count ; } } if ( needs Passthrough Workarounds ( ) ) { return ; } if ( system Clock Us - last Timestamp Sample Time Us >= MIN TIMESTAMP SAMPLE INTERVAL US ) { audio Timestamp Set = audio Track Util . update Timestamp ( ) ; if ( audio Timestamp Set ) { long audio Timestamp Us = audio Track Util . get Timestamp Nano Time ( ) / NUM ; if ( log . allow Verbose ( ) ) { log . v ( STRING + audio Timestamp Us ) ; } long audio Timestamp Frame Position = audio Track Util . get Timestamp Frame Position ( ) ; if ( audio Timestamp Us < resume System Time Us ) { audio Timestamp Set = BOOL ; log . w ( STRING + audio Timestamp Us + STRING + resume System Time Us ) ; } else if ( Math . abs ( audio Timestamp Us - system Clock Us ) > MAX AUDIO TIMESTAMP OFFSET US ) { String message = STRING + audio Timestamp Frame Position + STRING + audio Timestamp Us + STRING + system Clock Us + STRING + playback Position Us ; if ( fail On Spurious Audio Timestamp ) { throw new Invalid Audio Track Timestamp Exception ( message ) ; } log . w ( message ) ; audio Timestamp Set = BOOL ; } else if ( Math . abs ( frames To Duration Us ( audio Timestamp Frame Position ) - playback Position Us ) > MAX AUDIO TIMESTAMP OFFSET US ) { String message = STRING + audio Timestamp Frame Position + STRING + audio Timestamp Us + STRING + system Clock Us + STRING + playback Position Us ; if ( fail On Spurious Audio Timestamp ) { throw new Invalid Audio Track Timestamp Exception ( message ) ; } log . w ( message ) ; audio Timestamp Set = BOOL ; } } if ( is Latency Quirk Enabled ) { latency Us = Amazon Quirks . get Audio HW Latency ( ) ; } else if ( get Latency Method != null && ! passthrough ) { try { latency Us = ( Integer ) get Latency Method . invoke ( audio Track , ( Object [ ] ) null ) * NUM - buffer Size Us ; latency Us = Math . max ( latency Us , NUM ) ; if ( latency Us > MAX LATENCY US ) { log . w ( STRING + latency Us ) ; latency Us = NUM ; } } catch ( Exception e ) { get Latency Method = null ; } } last Timestamp Sample Time Us = system Clock Us ; } }
@ Override public boolean contains ( Object object ) { if ( object == null ) { return BOOL ; } for ( int i = NUM ; i < size ; i ++ ) { if ( object . equals ( elements [ i ] ) ) { return BOOL ; } } return BOOL ; }
public void close ( ) throws IO Exception { writer . close ( ) ; }
public static void substitute Properties ( Node node , Properties properties ) { Node child ; Node next = node . get First Child ( ) ; while ( ( child = next ) != null ) { next = child . get Next Sibling ( ) ; if ( child . get Node Type ( ) == Node . TEXT NODE ) { child . set Node Value ( Properties Util . substitute Property ( child . get Node Value ( ) , properties ) ) ; } else if ( child . get Node Type ( ) == Node . ELEMENT NODE ) { Named Node Map attributes = child . get Attributes ( ) ; for ( int i = NUM ; i < attributes . get Length ( ) ; i ++ ) { Node attribute = attributes . item ( i ) ; attribute . set Node Value ( Properties Util . substitute Property ( attribute . get Node Value ( ) , properties ) ) ; } substitute Properties ( child , properties ) ; } } }
@ Suppress Warnings ( STRING ) public Pseudo Function Selector ( String function Name , String expression ) { super ( Type . PSEUDO FUNCTION ) ; this . pseudo Function = ( Pseudo Function < E > ) lookup Pseudo Function ( function Name . trim ( ) ) ; this . expression = expression ; this . parsed Expression = pseudo Function . parse Expression ( expression ) ; }
public static String fix Query Mistakes ( String q ) { q = q . replace All ( STRING , STRING ) ; q = q . replace All ( STRING , STRING ) ; return q ; }
public byte [ ] read Bytes ( ) throws IO Exception { if ( ! parse Tag ( ) ) throw new Burlap Protocol Exception ( STRING ) ; String tag = sbuf . to String ( ) ; if ( tag . equals ( STRING ) ) { expect End Tag ( STRING ) ; return null ; } else if ( tag . equals ( STRING ) ) { sbuf . set Length ( NUM ) ; byte [ ] value = parse Bytes ( ) ; expect End Tag ( STRING ) ; return value ; } else throw expect Begin Tag ( STRING , tag ) ; }
public synchronized Utterance pend ( ) { Utterance utterance = null ; while ( list . size ( ) == NUM ) { try { wait ( ) ; } catch ( Interrupted Exception ie ) { return null ; } } utterance = ( Utterance ) list . remove First ( ) ; notify ( ) ; return utterance ; }
public void test Long Value Pos ( ) { String a = STRING ; Big Decimal a Number = new Big Decimal ( a ) ; long result = NUM ; assert True ( STRING , a Number . long Value ( ) == result ) ; }
public static Evaluation Result find Or Create ( Result Hierarchy hierarchy , Result parent , String name , String shortname ) { Array List < Evaluation Result > ers = Result Util . filter Results ( hierarchy , parent , Evaluation Result . class ) ; Evaluation Result ev = null ; for ( Evaluation Result e : ers ) { if ( shortname . equals ( e . get Short Name ( ) ) ) { ev = e ; break ; } } if ( ev == null ) { ev = new Evaluation Result ( name , shortname ) ; hierarchy . add ( parent , ev ) ; } return ev ; }
public static boolean is Running Java Web Start ( ) { boolean has JNLP = BOOL ; try { Class . for Name ( STRING ) ; has JNLP = BOOL ; } catch ( Class Not Found Exception ex ) { has JNLP = BOOL ; } return has JNLP ; }
public boolean is Connected ( ) { return connected . get ( ) ; }
private void try Schedule Action ( Runnable action ) { try { scheduler . submit ( action ) ; } catch ( Rejected Execution Exception e ) { } }
private static double score Sequence ( List < Lat Long > pts ) { Lat Long prev = pts . get ( pts . size ( ) - NUM ) ; Lat Long prevprev = pts . get ( pts . size ( ) - NUM ) ; double prev Angle = Math . atan 2 ( prev . lat - prevprev . lat , prev . lng - prevprev . lng ) ; double score = NUM ; for ( Lat Long pt : pts ) { double angle = Math . atan 2 ( pt . lat - prev . lat , pt . lng - prev . lng ) ; double diff = prev Angle - angle ; if ( diff > Math . PI ) diff -= Math . PI * NUM ; else if ( diff < - Math . PI ) diff += Math . PI * NUM ; if ( diff < NUM ) score += NUM ; else score += diff ; prev = pt ; prev Angle = angle ; } return score ; }
public void add Web App Debug Model Listener ( I Web App Debug Model Listener listener ) { synchronized ( private Instance Lock ) { web App Debug Model Listeners . add ( listener ) ; } }
public void reset Policy ( ) { m Preferences . put String ( PREF LAST RESPONSE , Integer . to String ( Policy . RETRY ) ) ; set Retry Until ( DEFAULT RETRY UNTIL ) ; set Max Retries ( DEFAULT MAX RETRIES ) ; set Retry Count ( Long . parse Long ( DEFAULT RETRY COUNT ) ) ; set Validity Timestamp ( DEFAULT VALIDITY TIMESTAMP ) ; m Preferences . commit ( ) ; }
public void simulate Method ( Soot Method method , Reference Variable this Var , Reference Variable return Var , Reference Variable params [ ] ) { String sub Signature = method . get Sub Signature ( ) ; if ( sub Signature . equals ( STRING ) ) { java lang Security Manager get Class Context ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java lang Security Manager current Class Loader 0 ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java lang Security Manager current Loaded Class 0 ( method , this Var , return Var , params ) ; return ; } else { default Method ( method , this Var , return Var , params ) ; return ; } }
public static boolean is File Exists ( final String path ) { if ( Text Utils . is Empty ( path ) ) { Log . e ( File Utils . class , STRING ) ; return BOOL ; } final File file To Check = new File ( path ) ; return file To Check . exists ( ) && ! file To Check . is Directory ( ) ; }
private List < Reference > create Signature References ( XML Signature Factory xml Sig Factory , List < String > reference Id List ) throws No Such Algorithm Exception , Invalid Algorithm Parameter Exception { List < Reference > result = new Array List < Reference > ( ) ; for ( String ref Id : reference Id List ) { if ( ref Id == null ) { continue ; } Reference ref = xml Sig Factory . new Reference ( STRING + ref Id , xml Sig Factory . new Digest Method ( Digest Method . SHA 512 , null ) , Collections . singleton List ( xml Sig Factory . new Canonicalization Method ( Canonicalization Method . EXCLUSIVE , ( C14 N Method Parameter Spec ) null ) ) , null , null ) ; result . add ( ref ) ; } return Collections . unmodifiable List ( result ) ; }
public boolean remove Network Connection ( Network Connection network Connection ) { return network Connections . remove ( network Connection ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
protected Object convert Array ( Object value ) { return value ; }
public static String encode String ( String s ) { return new String ( encode ( s . get Bytes ( ) ) ) ; }
Grid Lucene File ( Grid Lucene Directory dir ) { this . dir = dir ; files Cnt . increment And Get ( ) ; }
public void add Attributes ( Attributes atts ) throws SAX Exception { int n Atts = atts . get Length ( ) ; for ( int i = NUM ; i < n Atts ; i ++ ) { String uri = atts . get URI ( i ) ; if ( null == uri ) uri = STRING ; add Attribute Always ( uri , atts . get Local Name ( i ) , atts . get Q Name ( i ) , atts . get Type ( i ) , atts . get Value ( i ) , BOOL ) ; } }
public synchronized void add Pan Listener ( Pan Listener listener ) { m Pan Listeners . add ( listener ) ; }
public synchronized long last Online Ago ( ) { return ( System . current Time Millis ( ) - last Online ) / NUM ; }
public double distance weighted ( Pla Point Float p other , double p horizontal weight , double p vertical weight ) { double delta x = v x - p other . v x ; double delta y = v y - p other . v y ; delta x *= p horizontal weight ; delta y *= p vertical weight ; double result = Math . sqrt ( delta x * delta x + delta y * delta y ) ; return result ; }
public Name Space swap ( Name Space new Top ) { Name Space old Top = ( Name Space ) ( stack . element At ( NUM ) ) ; stack . set Element At ( new Top , NUM ) ; return old Top ; }
public static List < String > classes Path ( ) throws File Not Found Exception , Loading File Exception { List < File > files = get Java Files ( ) ; List < String > paths = new Array List < String > ( ) ; for ( File file : files ) paths . add ( file . get Path ( ) ) ; return paths ; }
public static Number sub ( Number a , Number b ) { if ( is Floating Point ( a ) || is Floating Point ( b ) ) { return a . double Value ( ) - b . double Value ( ) ; } else { return a . long Value ( ) - b . long Value ( ) ; } }
public static Stream < String > words Of ( String text ) { require Non Null ( text ) ; return WORDS . split As Stream ( text ) ; }
public static Delete Participant [ ] load Delete Participants ( Refactoring Status status , Refactoring Processor processor , Object element , Delete Arguments arguments , I Participant Descriptor Filter filter , String [ ] affected Natures , Sharable Participants shared ) { Refactoring Participant [ ] participants = fg Delete Instance . get Participants ( status , processor , element , arguments , filter , affected Natures , shared ) ; Delete Participant [ ] result = new Delete Participant [ participants . length ] ; System . arraycopy ( participants , NUM , result , NUM , participants . length ) ; return result ; }
public Put Result ( String success Count , String fail Count , List < String > error Messages ) { success Count = success Count ; fail Count = fail Count ; error Messages = new Array List < > ( ) ; if ( error Messages != null ) { error Messages . add All ( error Messages ) ; } }
@ Override public int hash Code ( ) { int my Position = position ; int hash = NUM ; while ( my Position < limit ) { hash = hash + get ( my Position ++ ) ; } return hash ; }
public void print ( Char Sequence text ) throws IO Exception { int size = text . length ( ) ; int pos = NUM ; for ( int i = NUM ; i < size ; i ++ ) { if ( text . char At ( i ) == STRING ) { write ( text . sub Sequence ( pos , size ) , i - pos + NUM ) ; pos = i + NUM ; at Start Of Line = BOOL ; } } write ( text . sub Sequence ( pos , size ) , size - pos ) ; }
public void close Running App ( String device ID , String app package ) throws Interrupted Exception , IO Exception { cmd . run Command ( STRING + device ID + STRING + app package ) ; }
@ Android Only ( STRING ) public void test unwrap 05 ( ) { String host = STRING ; int port = NUM ; Byte Buffer [ ] bb A = { Byte Buffer . allocate ( NUM ) , Byte Buffer . allocate ( NUM ) , Byte Buffer . allocate ( NUM ) } ; Byte Buffer bb = Byte Buffer . allocate ( NUM ) ; SSL Engine sse = get Engine ( host , port ) ; try { sse . unwrap ( bb , bb A , NUM , bb A . length ) ; fail ( STRING ) ; } catch ( Illegal State Exception iobe ) { } catch ( Exception e ) { fail ( e + STRING ) ; } }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String child Data ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; child . replace Data ( NUM , NUM , STRING ) ; child Data = child . get Data ( ) ; assert Equals ( STRING , STRING , child Data ) ; }
public boolean filterout Invalidation ( T tag , Tag Quality Status status To Add , String status Description , Timestamp timestamp ) { return filterout ( tag , tag . get Value ( ) , tag . get Value Description ( ) , status To Add , status Description , timestamp ) ; }
public void bind Y ( Double Property y Property ) { min Y World . bind ( y Property . add ( get Min Y ( ) ) ) ; max Y World . bind ( min Y World . add ( get Height ( ) ) ) ; }
private void copy Field Attributes ( ) { if ( ( load Fields == null ) || fields == null ) { return ; } for ( int i = NUM ; i < load Fields . length ; i ++ ) { Object Stream Field load Field = load Fields [ i ] ; String name = load Field . get Name ( ) ; for ( int j = NUM ; j < fields . length ; j ++ ) { Object Stream Field field = fields [ j ] ; if ( name . equals ( field . get Name ( ) ) ) { load Field . set Unshared ( field . is Unshared ( ) ) ; load Field . set Offset ( field . get Offset ( ) ) ; break ; } } } }
public static Uri . Builder append Id ( Uri . Builder builder , long id ) { return builder . append Encoded Path ( String . value Of ( id ) ) ; }
private static void begin Starting Service ( Context context , Intent intent ) { synchronized ( s Starting Service Sync ) { if ( s Starting Service == null ) { Power Manager pm = ( Power Manager ) context . get System Service ( Context . POWER SERVICE ) ; s Starting Service = pm . new Wake Lock ( Power Manager . PARTIAL WAKE LOCK , STRING ) ; } s Starting Service . acquire ( ) ; if ( context . start Service ( intent ) == null ) { Log . e ( TAG , STRING ) ; } } }
private Rect calc Bounds ( int index , Paint paint ) { Rect bounds = new Rect ( ) ; Char Sequence title = get Title ( index ) ; bounds . right = ( int ) paint . measure Text ( title , NUM , title . length ( ) ) ; bounds . bottom = ( int ) ( paint . descent ( ) - paint . ascent ( ) ) ; return bounds ; }
public static double stddev ( double [ ] a ) { return Math . sqrt ( var ( a ) ) ; }
public Simple Arguments Bundle ( @ Non Null Map < String , String > arguments , @ Non Null Display Metrics metrics ) { m Arguments = arguments ; m Metrics = metrics ; }
public static String collapse Whitespace ( String str ) { return collapse ( str , WHITE SPACES , STRING ) ; }
private void adjust ASI And Collect Follow Elements ( Custom Internal N 4 JS Parser previous Parser , boolean strict , Set < Follow Element > result ) { Observable Xtext Token Stream tokens = ( Observable Xtext Token Stream ) previous Parser . get Token Stream ( ) ; int last Token Index = tokens . size ( ) - NUM ; if ( last Token Index >= NUM ) { Common Token last Token = ( Common Token ) tokens . LT ( - NUM ) ; @ Suppress Warnings ( STRING ) List < Token > token List = tokens . get Tokens ( ) ; if ( last Token == null ) { return ; } if ( should Skip ASI ( last Token ) ) { if ( may Skip ASI ( last Token , tokens ) ) { token List . remove ( last Token Index ) ; result . add All ( reset And Get Follow Elements ( tokens , strict ) ) ; remove Postfix Operator ( result ) ; } } else if ( should Add Synthetic Semicolon ( previous Parser , last Token Index , last Token ) ) { Common Token token = new Common Token ( semi ) ; token List . add ( token ) ; result . add All ( reset And Get Follow Elements ( tokens , strict ) ) ; remove Postfix Operator ( result ) ; } } }
public Linked List < Patch > patch make ( String text 1 , String text 2 ) { if ( text 1 == null || text 2 == null ) { throw new Illegal Argument Exception ( STRING ) ; } Linked List < Diff > diffs = diff main ( text 1 , text 2 , BOOL ) ; if ( diffs . size ( ) > NUM ) { diff cleanup Semantic ( diffs ) ; diff cleanup Efficiency ( diffs ) ; } return patch make ( text 1 , diffs ) ; }
public void test Basics V 6 ( ) throws Exception { Directory dir = new Directory ( ) ; Random Index Writer writer = new Random Index Writer ( random ( ) , dir ) ; Document document = new Document ( ) ; Inet Address address = Inet Address . get By Name ( STRING ) ; document . add ( new Inet Address Point ( STRING , address ) ) ; writer . add Document ( document ) ; Index Reader reader = writer . get Reader ( ) ; Index Searcher searcher = new Searcher ( reader ) ; assert Equals ( NUM , searcher . count ( Inet Address Point . new Exact Query ( STRING , address ) ) ) ; assert Equals ( NUM , searcher . count ( Inet Address Point . new Prefix Query ( STRING , address , NUM ) ) ) ; assert Equals ( NUM , searcher . count ( Inet Address Point . new Range Query ( STRING , Inet Address . get By Name ( STRING ) , Inet Address . get By Name ( STRING ) ) ) ) ; reader . close ( ) ; writer . close ( ) ; dir . close ( ) ; }
private boolean is Minor Version Upgrade ( String current Version , String target Version ) { String current Db Schema Version = Vdc Util . get Db Schema Version ( current Version ) ; if ( current Db Schema Version == null ) { return BOOL ; } return current Db Schema Version . equals ( Vdc Util . get Db Schema Version ( target Version ) ) ; }
public static final void exception ( Throwable e ) { log Expensive ( Level . SEVERE , e . get Message ( ) , e ) ; }
private static Default Alignment value Of ( String str , boolean is Horizontal ) { if ( str . equals ( STRING ) || str . equals ( STRING ) ) { return FILL ALIGN ; } else if ( str . equals ( STRING ) || str . equals ( STRING ) ) { return CENTER ALIGN ; } else if ( is Horizontal ) { if ( str . equals ( STRING ) || str . equals ( STRING ) ) { return RIGHT ALIGN ; } else if ( str . equals ( STRING ) || str . equals ( STRING ) ) { return LEFT ALIGN ; } else { return null ; } } else if ( str . equals ( STRING ) || str . equals ( STRING ) ) { return TOP ALIGN ; } else if ( str . equals ( STRING ) || str . equals ( STRING ) ) { return BOTTOM ALIGN ; } else { return null ; } }
public void combine Sets ( Hash Map < String , Set < String > > container Affinities , Operator Pair pair ) { Set < String > set 1 = container Affinities . get ( pair . first ) ; Set < String > set 2 = container Affinities . get ( pair . second ) ; set 1 . add All ( set 2 ) ; container Affinities . put ( pair . first , set 1 ) ; container Affinities . put ( pair . second , set 1 ) ; }
protected void fire Property Change ( String property Name , Object old Value , Object new Value ) { property Change Support . fire Property Change ( property Name , old Value , new Value ) ; }
@ Override public boolean is Busy ( ) { return ( m split Thread != null ) ; }
public static < E > boolean is Not Empty ( Char Sequence c ) { return ( ( c != null ) && ( c . length ( ) > NUM ) ) ; }
@ Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case Eip Package . COMPOSITE PROCESSOR NAME : return NAME EDEFAULT == null ? name != null : ! NAME EDEFAULT . equals ( name ) ; case Eip Package . COMPOSITE PROCESSOR TO CHANNELS : return to Channels != null && ! to Channels . is Empty ( ) ; case Eip Package . COMPOSITE PROCESSOR FROM CHANNELS : return from Channels != null && ! from Channels . is Empty ( ) ; case Eip Package . COMPOSITE PROCESSOR OWNED ENDPOINTS : return owned Endpoints != null && ! owned Endpoints . is Empty ( ) ; } return super . e Is Set ( feature ID ) ; }
private void add Info Button ( J Panel panel , Object o , String client Prop ) { J Button h Button ; h Button = new J Button ( o . to String ( ) ) ; h Button . put Client Property ( client Prop , o ) ; h Button . add Action Listener ( this ) ; h Button . set Font ( font ) ; h Button . set Margin ( new Insets ( NUM , NUM , NUM , NUM ) ) ; h Button . set Background ( LOG BUTTON BG ) ; panel . add ( h Button ) ; }
public void remove Network Listener ( Network Listener network Listener ) { network Listeners . remove ( network Listener ) ; }
public static String chomp ( String s ) { if ( s . ends With ( STRING ) ) return s . substring ( NUM , s . length ( ) - NUM ) ; if ( s . ends With ( STRING ) || s . ends With ( STRING ) ) return s . substring ( NUM , s . length ( ) - NUM ) ; return s ; }
private void validate Surrogate Settings ( ) { faulty Surrogates Radio Button . set Enabled ( BOOL ) ; discard Surrogates Article Radio Button . set Enabled ( BOOL ) ; replace Surrogates Radio Button . set Enabled ( BOOL ) ; discard Surrogates Revision Radio Button . set Selected ( BOOL ) ; }
static Disk Id create Disk Id ( long max Oplog Size , boolean is Persistence Type , boolean needs Linked List ) { long bytes = max Oplog Size * NUM * NUM ; if ( bytes > Integer . MAX VALUE ) { if ( is Persistence Type ) { if ( needs Linked List ) { return new Persistence With Long Offset ( ) ; } else { return new Persistence With Long Offset No LL ( ) ; } } else { if ( needs Linked List ) { return new Overflow Only With Long Offset ( ) ; } else { return new Overflow Only With Long Offset No LL ( ) ; } } } else { if ( is Persistence Type ) { if ( needs Linked List ) { return new Persistence With Int Offset ( ) ; } else { return new Persistence With Int Offset No LL ( ) ; } } else { if ( needs Linked List ) { return new Overflow Only With Int Offset ( ) ; } else { return new Overflow Only With Int Offset No LL ( ) ; } } } }
public void start Element ( String namespace URI , String local Name , String name , Attributes atts ) throws org . xml . sax . SAX Exception { Elem Context elem Context = m elem Context ; if ( elem Context . m start Tag Open ) { close Start Tag ( ) ; elem Context . m start Tag Open = BOOL ; } else if ( m cdata Tag Open ) { close CDATA ( ) ; m cdata Tag Open = BOOL ; } else if ( m need To Call Start Document ) { start Document Internal ( ) ; m need To Call Start Document = BOOL ; } if ( m need To Output Doc Type Decl ) { String n = name ; if ( n == null || n . length ( ) == NUM ) { n = local Name ; } output Doc Type Decl ( n ) ; } if ( null != namespace URI && namespace URI . length ( ) > NUM ) { super . start Element ( namespace URI , local Name , name , atts ) ; return ; } try { Elem Desc elem Desc = get Elem Desc 2 ( name ) ; int elem Flags = elem Desc . get Flags ( ) ; if ( m do Indent ) { boolean is Block Element = ( elem Flags & Elem Desc . BLOCK ) != NUM ; if ( m ispreserve ) m ispreserve = BOOL ; else if ( ( null != elem Context . m element Name ) && ( ! m in Block Elem || is Block Element ) ) { m start New Line = BOOL ; indent ( ) ; } m in Block Elem = ! is Block Element ; } if ( atts != null ) add Attributes ( atts ) ; m isprevtext = BOOL ; final java . io . Writer writer = m writer ; writer . write ( STRING ) ; writer . write ( name ) ; if ( m tracer != null ) fire Pseudo Attributes ( ) ; if ( ( elem Flags & Elem Desc . EMPTY ) != NUM ) { m elem Context = elem Context . push ( ) ; m elem Context . m element Name = name ; m elem Context . m element Desc = elem Desc ; return ; } else { elem Context = elem Context . push ( namespace URI , local Name , name ) ; m elem Context = elem Context ; elem Context . m element Desc = elem Desc ; elem Context . m is Raw = ( elem Flags & Elem Desc . RAW ) != NUM ; } if ( ( elem Flags & Elem Desc . HEADELEM ) != NUM ) { close Start Tag ( ) ; elem Context . m start Tag Open = BOOL ; if ( ! m omit Meta Tag ) { if ( m do Indent ) indent ( ) ; writer . write ( STRING ) ; String encoding = get Encoding ( ) ; String encode = Encodings . get Mime Encoding ( encoding ) ; writer . write ( encode ) ; writer . write ( STRING ) ; } } } catch ( IO Exception e ) { throw new SAX Exception ( e ) ; } }
public static long size Of ( Class clazz ) { long max Size = header Size ( clazz ) ; while ( clazz != Object . class ) { for ( Field f : clazz . get Declared Fields ( ) ) { if ( ( f . get Modifiers ( ) & Modifier . STATIC ) == NUM ) { long offset = unsafe . object Field Offset ( f ) ; if ( offset > max Size ) { max Size = offset + NUM ; } } } clazz = clazz . get Superclass ( ) ; } return round Up To 8 ( max Size ) ; }
public void add Handler ( String column Name , SQL Data Handler handler ) { if ( m overrides == null ) m overrides = new Hash Map ( NUM ) ; m overrides . put ( column Name , handler ) ; }
public void add Near Evicted ( Key Cache Object key ) { if ( near Evicted == null ) near Evicted = new Array List < > ( ) ; near Evicted . add ( key ) ; }
public Word ( String word , String display As , String ... sounds Like ) { this ( ) ; this . word = word ; this . display As = display As ; this . sounds Like = Arrays . as List ( sounds Like ) ; }
public Enumerated Distribution ( final List < Pair < T , Double > > pmf ) throws Math Illegal Argument Exception { singletons = new Array List < > ( pmf . size ( ) ) ; final double [ ] probs = new double [ pmf . size ( ) ] ; for ( int i = NUM ; i < pmf . size ( ) ; i ++ ) { final Pair < T , Double > sample = pmf . get ( i ) ; singletons . add ( sample . get Key ( ) ) ; final double p = sample . get Value ( ) ; probs [ i ] = p ; } probabilities = check And Normalize ( probs ) ; cumulative Probabilities = new double [ probabilities . length ] ; double sum = NUM ; for ( int i = NUM ; i < probabilities . length ; i ++ ) { sum += probabilities [ i ] ; cumulative Probabilities [ i ] = sum ; } }
@ Override public Calendar next ( ) { if ( spot . equals ( end Final ) ) { throw new No Such Element Exception ( ) ; } spot . add ( Calendar . DATE , NUM ) ; return ( Calendar ) spot . clone ( ) ; }
public void pause Work ( ) { m Exit Tasks Early = BOOL ; set Pause ( BOOL ) ; if ( DEBUG ) { Log . d ( Log TAG , String . format ( STRING , this ) ) ; } }
public static List < Error Logger . Error Object > is Virtual Track In CPL Conformed ( Payload Record cpl Payload Record , Virtual Track virtual Track , List < Payload Record > essences Header Partition Payloads ) throws IO Exception { List < Virtual Track > virtual Tracks = new Array List < > ( ) ; IMF Error Logger imf Error Logger = new IMF Error Logger Impl ( ) ; virtual Tracks . add ( virtual Track ) ; imf Error Logger . add All Errors ( check Virtual Track And Essences Header Partition Payload Records ( virtual Tracks , essences Header Partition Payloads ) ) ; if ( imf Error Logger . has Fatal Errors ( ) ) { return imf Error Logger . get Errors ( ) ; } imf Error Logger . add All Errors ( conform Virtual Tracks In CPL ( cpl Payload Record , essences Header Partition Payloads , BOOL ) ) ; return imf Error Logger . get Errors ( ) ; }
public byte receive One Byte ( ) { Log . d ( TAG , STRING ) ; try { acquire Lock ( ) ; m Server Socket . receive ( m Receive Packet ) ; Log . d ( TAG , STRING + ( NUM + m Receive Packet . get Data ( ) [ NUM ] ) ) ; return m Receive Packet . get Data ( ) [ NUM ] ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } return Byte . MIN VALUE ; }
public static String encode ( byte [ ] input ) { if ( input . length == NUM ) { return STRING ; } int zeros = NUM ; while ( zeros < input . length && input [ zeros ] == NUM ) { ++ zeros ; } input = Arrays . copy Of ( input , input . length ) ; char [ ] encoded = new char [ input . length * NUM ] ; int output Start = encoded . length ; for ( int input Start = zeros ; input Start < input . length ; ) { encoded [ -- output Start ] = ALPHABET [ divmod ( input , input Start , NUM , NUM ) ] ; if ( input [ input Start ] == NUM ) { ++ input Start ; } } while ( output Start < encoded . length && encoded [ output Start ] == ENCODED ZERO ) { ++ output Start ; } while ( -- zeros >= NUM ) { encoded [ -- output Start ] = ENCODED ZERO ; } return new String ( encoded , output Start , encoded . length - output Start ) ; }
public static int [ ] cells ( int [ ] start , int [ ] end ) { Arrays . sort ( start ) ; Arrays . sort ( end ) ; int overlap = NUM ; int gaps = NUM ; for ( int i = NUM , j = NUM ; j < end . length ; ) { if ( i < start . length && start [ i ] < end [ j ] ) { overlap ++ ; i ++ ; } else { j ++ ; overlap -- ; } if ( overlap == NUM ) { gaps ++ ; } } int [ ] cells = new int [ gaps * NUM ] ; overlap = NUM ; gaps = NUM ; int previous Overlap = NUM ; for ( int i = NUM , j = NUM ; j < end . length ; ) { if ( i < start . length && start [ i ] < end [ j ] ) { overlap ++ ; if ( previous Overlap == NUM ) { cells [ gaps ++ ] = start [ i ] ; } i ++ ; } else { overlap -- ; if ( overlap == NUM ) { cells [ gaps ++ ] = end [ j ] ; } j ++ ; } previous Overlap = overlap ; } return cells ; }
@ Override public In Store open Read ( long address , int size ) { if ( file Size ( ) < address + size ) { throw new Illegal State Exception ( L . l ( STRING , this , address , size , file Size ( ) ) ) ; } if ( is Closed . get ( ) ) { throw new Illegal State Exception ( L . l ( STRING , this ) ) ; } if ( file Size < address + size ) { throw new Illegal State Exception ( L . l ( STRING , Long . to Hex String ( address ) , size ) ) ; } try { stream Open ( address , size ) ; return open Read Impl ( address , size ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
List < Address > geo Decode ( String searched Location ) { try { Geocoder geo = new Geocoder ( s Context , Locale . get Default ( ) ) ; List < Address > addresses = geo . get From Location Name ( searched Location , NUM ) ; if ( addresses != null && addresses . size ( ) > NUM ) { return addresses ; } } catch ( Exception ex ) { } return null ; }
private boolean is Identifier Start Char ( int position ) { if ( len >= NUM && position >= len ) { return BOOL ; } char ch = working [ position ] ; return Character . is Unicode Identifier Start ( ch ) ; }
public void destroy ( ) { fallback Storage . clear ( ) ; File Utils . delete Quietly ( fallback Storage File ) ; }
public static Select Clause create ( String ... property Names ) { List < Select Clause Element > select List = new Array List < Select Clause Element > ( ) ; for ( String name : property Names ) { select List . add ( new Select Clause Expression ( new Property Value Expression ( name ) ) ) ; } return new Select Clause ( Stream Selector . ISTREAM ONLY , select List ) ; }
Configuration Error ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
public static String make Margin Transform ( double owidth , double oheight , double iwidth , double iheight , double lmargin , double tmargin , double rmargin , double bmargin ) { double swidth = iwidth + lmargin + rmargin ; double sheight = iheight + tmargin + bmargin ; double scale = Math . max ( swidth / owidth , sheight / oheight ) ; double offx = ( scale * owidth - swidth ) * NUM + lmargin ; double offy = ( scale * oheight - sheight ) * NUM + tmargin ; return STRING + fmt ( NUM / scale ) + STRING + fmt ( offx ) + STRING + fmt ( offy ) + STRING ; }
public static boolean is Attachment ( String content Disposition ) { return content Disposition != null && content Disposition . region Matches ( BOOL , NUM , STRING , NUM , NUM ) ; }
private J Menu create Insert Menu ( ) { J Menu insert Menu = new J Menu ( STRING ) ; insert Menu . add ( action Manager . get New Network Action ( ) ) ; J Menu new Gauge Sub Menu = new J Menu ( STRING ) ; for ( Action action : action Manager . get Plot Actions ( ) ) { new Gauge Sub Menu . add ( action ) ; } insert Menu . add ( new Gauge Sub Menu ) ; J Menu new World Sub Menu = new J Menu ( STRING ) ; for ( Action action : action Manager . get New World Actions ( ) ) { new World Sub Menu . add ( action ) ; } insert Menu . add ( new World Sub Menu ) ; insert Menu . add Separator ( ) ; insert Menu . add ( action Manager . get New Doc Viewer Action ( ) ) ; insert Menu . add ( action Manager . get New Console Action ( ) ) ; return insert Menu ; }
public static Vector < String > find Packages ( ) { Vector < String > result ; Enumeration < String > packages ; init Cache ( ) ; result = new Vector < String > ( ) ; packages = m Class Cache . packages ( ) ; while ( packages . has More Elements ( ) ) { result . add ( packages . next Element ( ) ) ; } Collections . sort ( result , new String Compare ( ) ) ; return result ; }
public static String convert System Name To Alternate ( String system Name ) { if ( ! valid System Name Format ( system Name , system Name . char At ( NUM ) , STRING ) ) { return STRING ; } String alt Name = STRING ; alt Name = system Name ; return alt Name ; }
private void initialize User Directives ( ) { user Directives = new Array List < > ( ) ; I Eclipse Preferences preferences = Velocity Core Plugin . get Preferences ( ) ; String directives = preferences . get ( I Preferences Constants . VELOCITY USER DIRECTIVES , STRING ) ; String Tokenizer st = new String Tokenizer ( directives , STRING ) ; while ( st . has More Elements ( ) ) { String directive = ( String ) st . next Element ( ) ; String name = directive . substring ( NUM , directive . index Of ( STRING ) ) ; int type = ( directive . ends With ( STRING ) ? Directive . BLOCK : Directive . LINE ) ; user Directives . add ( STRING + name ) ; add Directive ( new Velocity Directive ( name , type ) ) ; } }
private synchronized void store Timestamp And Set Status ( Timestamper . Timestamp Succeeded message , Timestamp Record timestamp Record ) throws Exception { try { persist Timestamp Record ( message , timestamp Record ) ; set Timestamp Succeeded ( ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; set Timestamp Failed Regardless Of Queue ( new Date Time ( ) ) ; throw e ; } }
public static Character [ ] values Of ( char [ ] array ) { Character [ ] dest = new Character [ array . length ] ; for ( int i = NUM ; i < array . length ; i ++ ) { dest [ i ] = Character . value Of ( array [ i ] ) ; } return dest ; }
public void mark ( int readlimit ) { stream . mark ( readlimit ) ; if ( mark Supported ( ) ) { markpos = frame Pos ; mark Push Back Len = push Back Len ; if ( mark Push Back Len > NUM ) { if ( mark Push Back Buffer == null ) { mark Push Back Buffer = new byte [ frame Size ] ; } System . arraycopy ( push Back Buffer , NUM , mark Push Back Buffer , NUM , mark Push Back Len ) ; } } }
public void test Creating Launcher With Jetty 1 ( ) { Swt Bot Project Creation . create Maven Gwt Project Is Created 1 ( bot , PROJECT NAME , PACKAGE NAME ) ; Swt Bot Project Debug . launch GWT Dev Mode With Jetty Then Terminate It ( bot , PROJECT NAME ) ; String persisted Args = Swt Bot Project Debug . get The Program Args Text Box ( bot ) ; assert True ( persisted Args . contains ( STRING ) ) ; }
@ Known Failure ( STRING ) public void test get Tables Ljava lang String Ljava lang String Ljava lang String$ Ljava lang String ( ) throws SQL Exception { String [ ] tables Name = { VIEW NAME , Database Creator . TEST TABLE 1 , Database Creator . TEST TABLE 3 } ; String [ ] tables Type = { STRING , STRING } ; Arrays . sort ( tables Name ) ; Arrays . sort ( tables Type ) ; Result Set rs = meta . get Tables ( null , null , null , null ) ; while ( rs . next ( ) ) { assert True ( STRING , Arrays . binary Search ( tables Name , rs . get String ( STRING ) ) > - NUM ) ; assert Null ( STRING + rs . get String ( STRING ) , rs . get String ( STRING ) ) ; assert True ( STRING , Arrays . binary Search ( tables Type , rs . get String ( STRING ) ) > - NUM ) ; assert Equals ( STRING , STRING , rs . get String ( STRING ) ) ; } rs . close ( ) ; rs = meta . get Tables ( conn . get Catalog ( ) , null , null , new String [ ] { STRING , STRING } ) ; assert False ( STRING , rs . next ( ) ) ; rs . close ( ) ; rs = meta . get Tables ( conn . get Catalog ( ) , null , null , new String [ ] { STRING , STRING } ) ; assert True ( STRING , rs . next ( ) ) ; assert Equals ( STRING , VIEW NAME , rs . get String ( STRING ) ) ; assert Null ( STRING + rs . get String ( STRING ) , rs . get String ( STRING ) ) ; assert Equals ( STRING , STRING , rs . get String ( STRING ) ) ; assert Equals ( STRING , STRING , rs . get String ( STRING ) ) ; assert False ( STRING , rs . next ( ) ) ; assert False ( STRING , rs . next ( ) ) ; rs . close ( ) ; rs = meta . get Tables ( null , null , STRING , null ) ; while ( rs . next ( ) ) { assert True ( STRING , Arrays . binary Search ( tables Name , rs . get String ( STRING ) ) > - NUM ) ; assert Null ( STRING , rs . get String ( STRING ) ) ; assert True ( STRING , Arrays . binary Search ( tables Type , rs . get String ( STRING ) ) > - NUM ) ; assert Equals ( STRING , STRING , rs . get String ( STRING ) ) ; } rs . close ( ) ; conn . close ( ) ; try { meta . get Tables ( null , null , null , null ) ; fail ( STRING ) ; } catch ( SQL Exception e ) { } }
public static boolean needs Default Formatter ( Value Formatter formatter ) { if ( formatter == null ) return BOOL ; if ( formatter instanceof Default Value Formatter ) return BOOL ; return BOOL ; }
public boolean put Grammar ( Schema Grammar grammar , boolean deep , boolean ignore Conflict ) { if ( ! ignore Conflict ) { return put Grammar ( grammar , deep ) ; } Schema Grammar sg = get Grammar ( grammar . f Target Namespace ) ; if ( sg == null ) { put Grammar ( grammar ) ; } if ( ! deep ) { return BOOL ; } Vector curr Grammars = grammar . get Imported Grammars ( ) ; if ( curr Grammars == null ) { return BOOL ; } Vector grammars = ( ( Vector ) curr Grammars . clone ( ) ) ; Schema Grammar sg 1 , sg 2 ; Vector gs ; for ( int i = NUM ; i < grammars . size ( ) ; i ++ ) { sg 1 = ( Schema Grammar ) grammars . element At ( i ) ; sg 2 = get Grammar ( sg 1 . f Target Namespace ) ; if ( sg 2 == null ) { gs = sg 1 . get Imported Grammars ( ) ; if ( gs == null ) continue ; for ( int j = gs . size ( ) - NUM ; j >= NUM ; j -- ) { sg 2 = ( Schema Grammar ) gs . element At ( j ) ; if ( ! grammars . contains ( sg 2 ) ) grammars . add Element ( sg 2 ) ; } } else { grammars . remove ( sg 1 ) ; } } for ( int i = grammars . size ( ) - NUM ; i >= NUM ; i -- ) { put Grammar ( ( Schema Grammar ) grammars . element At ( i ) ) ; } return BOOL ; }
public List < N > nodes ( @ Nullable Object key , int cnt ) { return nodes ( key , cnt , null , null ) ; }
public boolean is Exists Key ( Connection connection , Object [ ] keys ) { String Builder builder = new String Builder ( ) ; builder . append ( STRING ) ; builder . append ( table Name ) ; builder . append ( STRING ) ; String delimiter = STRING ; for ( String key Field : key Field Names ) { builder . append ( delimiter ) ; builder . append ( key Field ) ; builder . append ( STRING ) ; delimiter = STRING ; } String query = builder . to String ( ) ; Prepared Statement statement = null ; try { if ( ( Execution Path Debug Log . is Debug Enabled ) && ( log . is Debug Enabled ( ) ) ) { log . debug ( STRING + query + STRING + print ( keys ) + STRING ) ; } statement = connection . prepare Statement ( query ) ; for ( int i = NUM ; i < keys . length ; i ++ ) { statement . set Object ( i + NUM , keys [ i ] ) ; } Result Set rs = statement . execute Query ( ) ; if ( ! rs . next ( ) ) { return BOOL ; } return BOOL ; } catch ( SQL Exception ex ) { String message = STRING + query + STRING + ex . get Message ( ) ; log . error ( message , ex ) ; store Exception Handler . handle ( message , ex ) ; throw new Store Exception DB Rel ( message , ex ) ; } finally { try { if ( statement != null ) statement . close ( ) ; } catch ( SQL Exception e ) { } } }
public static < T > T implement ( Class < T > type , Object object ) { if ( type . is Instance ( object ) ) { return type . cast ( object ) ; } return type . cast ( Proxy . new Proxy Instance ( type . get Class Loader ( ) , new Class [ ] { type } , new Duck Type ( object ) ) ) ; }
public boolean is Ivr Vsan ( int vsan Id ) { boolean in Range = vsans . contains ( vsan Id ) ; if ( ! in Range ) { for ( Int Range range : get Vsans Ranges ( ) ) { in Range = range . contains Integer ( vsan Id ) ; if ( in Range ) { break ; } } } return in Range ; }
private void add BOM Lines ( M Product product , Big Decimal qty ) { MPP Product BOM bom = MPP Product BOM . get Default ( product , null ) ; MPP Product BOM Line [ ] bom Lines = bom . get Lines ( BOOL ) ; for ( int i = NUM ; i < bom Lines . length ; i ++ ) add BOM Line ( bom Lines [ i ] , qty ) ; log . fine ( STRING + bom Lines . length ) ; }
private Query Exp build Optional Query Exp ( final String [ ] attributes , final Object [ ] values ) { Query Exp query Exp = null ; for ( int i = NUM ; i < attributes . length ; i ++ ) { if ( values [ i ] instanceof Boolean ) { if ( query Exp == null ) { query Exp = Query . eq ( Query . attr ( attributes [ i ] ) , Query . value ( ( ( Boolean ) values [ i ] ) ) ) ; } else { query Exp = Query . and ( query Exp , Query . eq ( Query . attr ( attributes [ i ] ) , Query . value ( ( ( Boolean ) values [ i ] ) ) ) ) ; } } else if ( values [ i ] instanceof Number ) { if ( query Exp == null ) { query Exp = Query . eq ( Query . attr ( attributes [ i ] ) , Query . value ( ( Number ) values [ i ] ) ) ; } else { query Exp = Query . and ( query Exp , Query . eq ( Query . attr ( attributes [ i ] ) , Query . value ( ( Number ) values [ i ] ) ) ) ; } } else if ( values [ i ] instanceof String ) { if ( query Exp == null ) { query Exp = Query . eq ( Query . attr ( attributes [ i ] ) , Query . value ( ( String ) values [ i ] ) ) ; } else { query Exp = Query . and ( query Exp , Query . eq ( Query . attr ( attributes [ i ] ) , Query . value ( ( String ) values [ i ] ) ) ) ; } } } return query Exp ; }
@ Override public Foo fetch By Uuid C Last ( String uuid , long company Id , Order By Comparator < Foo > order By Comparator ) { int count = count By Uuid C ( uuid , company Id ) ; if ( count == NUM ) { return null ; } List < Foo > list = find By Uuid C ( uuid , company Id , count - NUM , count , order By Comparator ) ; if ( ! list . is Empty ( ) ) { return list . get ( NUM ) ; } return null ; }
public final boolean at ( String str , Char Sequence csq ) { int i = index ; int length = csq . length ( ) ; for ( int j = NUM ; j < str . length ( ) ; ) { if ( ( i >= length ) || ( str . char At ( j ++ ) != csq . char At ( i ++ ) ) ) return BOOL ; } return BOOL ; }
public static int find Last Of ( String container , String char Seq , int begin ) { for ( int i = begin ; i < container . length ( ) && i >= NUM ; -- i ) { if ( char Seq . contains ( STRING + container . char At ( i ) ) ) return i ; } return - NUM ; }
private static Cookie Origin adjust Effective Host ( final Cookie Origin origin ) { String host = origin . get Host ( ) ; boolean is Local Host = BOOL ; for ( int i = NUM ; i < host . length ( ) ; i ++ ) { char ch = host . char At ( i ) ; if ( ch == STRING || ch == STRING ) { is Local Host = BOOL ; break ; } } if ( is Local Host ) { host += STRING ; return new Cookie Origin ( host , origin . get Port ( ) , origin . get Path ( ) , origin . is Secure ( ) ) ; } else { return origin ; } }
protected final void finalize ( ) { }
public boolean add Bound ( Type Bound bound ) { if ( bound . is Trivial ( ) ) { return BOOL ; } final boolean was Added = internal add Bound ( bound ) ; if ( DEBUG ) { final String suffix = was Added ? STRING : STRING ; log ( STRING + bound + suffix ) ; } return was Added ; }
public boolean remove ( Sim Event event ) { return sorted Set . remove ( event ) ; }
public static final void print Thread Cpu Time ( final Thread thread ) { if ( tbe . is Thread Cpu Time Enabled ( ) ) { log . info ( STRING + thread . get Name ( ) + STRING + get Thread Cpu Time ( thread ) + STRING ) ; } }
public static Version from Bits ( int major , int minor , int bugfix ) { return new Version ( major , minor , bugfix ) ; }
private static I Multi Point [ ] random Points ( int n , int d , int scale ) { I Multi Point points [ ] = new I Multi Point [ n ] ; for ( int i = NUM ; i < n ; i ++ ) { String Builder sb = new String Builder ( ) ; for ( int j = NUM ; j < d ; j ++ ) { sb . append ( r Gen . next Double ( ) * scale ) ; if ( j < d - NUM ) { sb . append ( STRING ) ; } } points [ i ] = new Hyperpoint ( sb . to String ( ) ) ; } return points ; }
public static String bytes To String ( int [ ] b ) { if ( b . length < NUM ) { return STRING ; } return String . format ( STRING , b [ NUM ] , b [ NUM ] , b [ NUM ] , b [ NUM ] ) ; }
private String convert To Iso Date Time ( String human Readable Date Time ) throws Parse Exception { Date Format df Initial = new Simple Date Format ( STRING ) ; Date initial Date Time = df Initial . parse ( human Readable Date Time ) ; Date Format df = new Simple Date Format ( STRING ) ; return df . format ( initial Date Time ) ; }
private static boolean class Names Equal ( String name 1 , String name 2 ) { name 1 = name 1 . substring ( name 1 . last Index Of ( STRING ) + NUM ) ; name 2 = name 2 . substring ( name 2 . last Index Of ( STRING ) + NUM ) ; return name 1 . equals ( name 2 ) ; }
public boolean opt Boolean ( int index ) { return opt Boolean ( index , BOOL ) ; }
public Command Builder with Long Switch If Present ( Map < String , Object > properties , String ... keys ) { with Long Switch If Present ( properties , Unary Operator . identity ( ) , keys ) ; return this ; }
private static boolean has Specialized Handler Intents ( Context context , Intent intent ) { try { Package Manager pm = context . get Package Manager ( ) ; List < Resolve Info > handlers = pm . query Intent Activities ( intent , Package Manager . GET RESOLVED FILTER ) ; if ( handlers == null || handlers . size ( ) == NUM ) { return BOOL ; } for ( Resolve Info resolve Info : handlers ) { Intent Filter filter = resolve Info . filter ; if ( filter == null ) continue ; if ( filter . count Data Authorities ( ) == NUM || filter . count Data Paths ( ) == NUM ) continue ; if ( resolve Info . activity Info == null ) continue ; return BOOL ; } } catch ( Runtime Exception e ) { Log . e ( TAG , STRING ) ; } return BOOL ; }
private void on Collection Clicked ( Long collection Id ) { Intent intent = new Intent ( this , Product List Activity . class ) ; if ( collection Id != null ) { intent . put Extra ( Product List Activity . EXTRA COLLECTION ID , collection Id ) ; } start Activity ( intent ) ; }
public void add Frequency ( Frequency frequency ) { frequencies . add ( frequency ) ; }
public boolean is Item Stack Registered For Name ( Item Stack stack , String ore Name ) { final int [ ] ore I Ds = Ore Dictionary . get Ore I Ds ( stack ) ; for ( final int ore ID : ore I Ds ) { if ( ore Name . equals ( Ore Dictionary . get Ore Name ( ore ID ) ) ) { return BOOL ; } } return BOOL ; }
private static @ Nonnull URL [ ] create Classloader Urls ( @ Nonnull URL url ) throws Plugin Exception { List < URL > urls = new Array List < URL > ( ) ; urls . add ( url ) ; Manifest mf = null ; File f = new File ( url . get Path ( ) ) ; if ( ! f . is Directory ( ) ) { Jar Input Stream jis = null ; try { jis = new Jar Input Stream ( url . open Stream ( ) ) ; mf = jis . get Manifest ( ) ; } catch ( IO Exception ioe ) { throw new Plugin Exception ( STRING + url , ioe ) ; } finally { IO . close ( jis ) ; } } else { File manifest = guess Manifest ( f ) ; if ( manifest != null ) { File Input Stream is = null ; try { is = new File Input Stream ( manifest ) ; mf = new Manifest ( is ) ; } catch ( IO Exception e ) { throw new Plugin Exception ( STRING + url , e ) ; } finally { IO . close ( is ) ; } } } if ( mf != null ) { try { add Class Path From Manifest ( url , urls , mf ) ; } catch ( Malformed URL Exception e ) { throw new Plugin Exception ( STRING + url , e ) ; } } return urls . to Array ( new URL [ urls . size ( ) ] ) ; }
@ Override public void write ( String str , int st , int end ) throws IO Exception { out . write ( str , st , end ) ; }
public boolean is Awake ( ) { return is Awake ; }
private static void transfer Streams ( Input Stream source , Output Stream destination ) { byte [ ] buffer = new byte [ NUM ] ; try { while ( BOOL ) { int bytes Read = - NUM ; try { bytes Read = source . read ( buffer ) ; } catch ( IO Exception e ) { return ; } if ( bytes Read == - NUM ) break ; try { destination . write ( buffer , NUM , bytes Read ) ; } catch ( IO Exception e ) { return ; } } } finally { try { source . close ( ) ; } catch ( IO Exception e ) { } finally { try { destination . close ( ) ; } catch ( IO Exception e ) { } } } }
public static void gc ( ) { if ( started Gc ) { force Gc = BOOL ; gc Should Loop = BOOL ; } start GC Thread ( ) ; synchronized ( LOCK ) { LOCK . notify ( ) ; } try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception er ) { } }
private Array List < E > to Array List ( ) { Array List < E > list = new Array List < E > ( ) ; for ( Node < E > p = first ( ) ; p != null ; p = succ ( p ) ) { E item = p . item ; if ( item != null ) list . add ( item ) ; } return list ; }
public static Blob Entry is Blob Entry For Storing ( String repository Location , String mime Type ) { Repository Location location ; try { location = new Repository Location ( repository Location ) ; Entry entry = location . locate Entry ( ) ; if ( entry instanceof Blob Entry ) { Blob Entry blob Entry = ( Blob Entry ) entry ; if ( mime Type . equals ( blob Entry . get Mime Type ( ) ) ) { return blob Entry ; } else { Swing Tools . show Simple Error Message ( STRING , blob Entry . get Name ( ) ) ; return null ; } } else if ( entry == null ) { return create Blob Entry ( repository Location ) ; } else { Swing Tools . show Simple Error Message ( STRING , entry . get Name ( ) ) ; } } catch ( Repository Exception e ) { Swing Tools . show Simple Error Message ( STRING , e ) ; } catch ( Malformed Repository Location Exception e ) { Swing Tools . show Simple Error Message ( STRING , e ) ; } return null ; }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . PUT ) @ Response Body public Rest Wrapper insert ( @ Model Attribute ( STRING ) @ Valid Batch batch , Binding Result binding Result , Principal principal ) { Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { com . wipro . ats . bdre . md . dao . jpa . Batch jpa Batch = new com . wipro . ats . bdre . md . dao . jpa . Batch ( ) ; jpa Batch . set Batch Type ( batch . get Batch Type ( ) ) ; Instance Exec instance Exec = new Instance Exec ( ) ; if ( batch . get Source Instance Exec Id ( ) != null ) { instance Exec . set Instance Exec Id ( batch . get Source Instance Exec Id ( ) ) ; jpa Batch . set Instance Exec ( instance Exec ) ; } Long auto Gen Batch Id = batch DAO . insert ( jpa Batch ) ; batch . set Batch Id ( auto Gen Batch Id ) ; rest Wrapper = new Rest Wrapper ( batch , Rest Wrapper . OK ) ; LOGGER . info ( RECORDWITHID + batch . get Batch Id ( ) + STRING + principal . get Name ( ) + batch ) ; } catch ( Metadata Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
private void on Click Gallery Image ( final Recent Media a Media Item ) { if ( null != m Camera ) { m Camera . stop Preview ( ) ; } m Selected Gallery Items List . add ( a Media Item ) ; if ( ( null != a Media Item . m Thumbnail ) && ! m Is Avatar Mode ) { update Ui Configuration ( UI SHOW TAKEN IMAGE , IMAGE ORIGIN GALLERY ) ; m Image Preview Image View . set Image Bitmap ( a Media Item . m Thumbnail ) ; Vector App . set Saved Camera Image Preview ( a Media Item . m Thumbnail ) ; } else if ( null != a Media Item . m File Uri ) { display Image Preview ( null , null , a Media Item . m File Uri , IMAGE ORIGIN GALLERY ) ; } else { Log . e ( LOG TAG , STRING ) ; } m Image Preview Image View . set Tag ( a Media Item . m File Uri ) ; }
public static double pareto ( double alpha ) { if ( ! ( alpha > NUM ) ) throw new Illegal Argument Exception ( STRING ) ; return Math . pow ( NUM - uniform ( ) , - NUM / alpha ) - NUM ; }
public void disconnect From Broker ( final Mqtt Async Connection connection ) { try { connection . disconnect ( new Mqtt Disconnection Result Handler ( ) ) ; } catch ( Spy Exception e ) { Platform . run Later ( new Mqtt Event Handler ( new Mqtt Disconnection Attempt Failure Event ( connection , e ) ) ) ; logger . error ( e . get Message ( ) , e ) ; } }
public Object [ ] copy All ( ) { return Arrays . copy Of ( args , args . length ) ; }
public void start ( ) { LOG . info ( STRING , port , log Level ) ; try { component . start ( ) ; } catch ( Exception e ) { throw new Illegal State Exception ( STRING , e ) ; } LOG . info ( STRING , port ) ; running = BOOL ; started = System . current Time Millis ( ) ; }
public FS Account Fed Info read Account Fed Info ( String user ID , String provider ID ) throws FS Account Mgmt Exception { return read Account Fed Info ( user ID , provider ID , null ) ; }
public Response ( String status , String mime Type , String txt ) { this . status = status ; this . mime Type = mime Type ; try { this . data = new Byte Array Input Stream ( txt . get Bytes ( STRING ) ) ; } catch ( java . io . Unsupported Encoding Exception uee ) { uee . print Stack Trace ( ) ; } }
@ Parallel @ Realtime ( limit = LINEAR ) public E reduce ( Binary Operator < E > operator ) { Iterator < E > itr = iterator ( ) ; if ( ! itr . has Next ( ) ) return null ; E accumulator = itr . next ( ) ; while ( itr . has Next ( ) ) accumulator = operator . apply ( accumulator , itr . next ( ) ) ; return accumulator ; }
public void save History ( String filename ) throws Exception { File Output Stream fos = new File Output Stream ( filename ) ; Object Output Stream oos = new Object Output Stream ( fos ) ; oos . write Object ( get History ( ) ) ; oos . close ( ) ; }
private void check Size ( final int i ) { if ( i >= max size ) { final int old size = max size ; max size += increment size ; if ( max size <= i ) { max size = i + increment size + NUM ; } final double [ ] temp = items ; items = new double [ max size ] ; System . arraycopy ( temp , NUM , items , NUM , old size ) ; increment size = increment Size ( increment size ) ; } }
public double next Gaussian ( ) { return random . next Gaussian ( ) ; }
private void read From Properties ( final Properties props , final boolean default Minimized , final int default X , final int default Y , final boolean default Visible ) { minimized = Boolean . parse Boolean ( props . get Property ( STRING + name + STRING , Boolean . to String ( default Minimized ) ) ) ; visible = Boolean . parse Boolean ( props . get Property ( STRING + name + STRING , Boolean . to String ( default Visible ) ) ) ; x = Integer . parse Int ( props . get Property ( STRING + name + STRING , Integer . to String ( default X ) ) ) ; y = Integer . parse Int ( props . get Property ( STRING + name + STRING , Integer . to String ( default Y ) ) ) ; }
public boolean send E Mail Attachments ( int AD User ID , String subject , String message , Collection < File > attachments , boolean html ) { M User to = M User . get ( get Ctx ( ) , AD User ID ) ; String to E Mail = to . get E Mail ( ) ; if ( to E Mail == null || to E Mail . length ( ) == NUM ) { log . warning ( STRING + to ) ; return BOOL ; } E Mail email = create E Mail ( null , to , subject , message , html ) ; if ( email == null ) return BOOL ; email . add Attachments ( attachments ) ; try { return send Email Now ( null , to , email ) ; } catch ( Exception ex ) { log . severe ( get Name ( ) + STRING + ex . get Localized Message ( ) ) ; return BOOL ; } }
private void add Unit Tax Calculation Info Clone ( final Tax Calculation Info tax Cal Info , final Tax Calculation Info clone ) { final List < Unit Tax Calculation Info > units = new Array List < Unit Tax Calculation Info > ( ) ; final List < Unit Tax Calculation Info > units By Date = new Array List < Unit Tax Calculation Info > ( ) ; for ( final Unit Tax Calculation Info unit Info : tax Cal Info . get Unit Tax Calculation Infos ( ) ) { final Unit Tax Calculation Info new Unit Info = get Unit Tax Calculation Info Clone ( unit Info ) ; units By Date . add ( new Unit Info ) ; } clone . set Unit Tax Calculation Info ( units ) ; }
public Socket Wrapper accept ( ) throws IO Exception { for ( ; ; ) { try { Socket sock = server Socket . accept ( ) ; return new Socket Wrapper ( sock ) ; } catch ( Socket Timeout Exception e ) { } catch ( IO Exception e ) { if ( done ) { throw new Socket Termination Exception ( STRING , e ) ; } else { throw e ; } } } }
private String replace Dot In Mustache Keys ( final List < String > mustache Keys , final String plugin Call ) { String fixed Plugin Call = plugin Call ; for ( String mustache Key : mustache Keys ) { if ( mustache Key . contains ( STRING ) ) { fixed Plugin Call = fixed Plugin Call . replace ( STRING + mustache Key + STRING , STRING + mustache Key . replace ( STRING , STRING ) + STRING ) ; } } return fixed Plugin Call ; }
protected synchronized Instance process Buffers ( ) { if ( m first Buffer != null && m second Buffer != null && m first Buffer . size ( ) > NUM && m second Buffer . size ( ) > NUM ) { if ( m stop Requested . get ( ) ) { return null ; } Instance Holder first H = m first Buffer . peek ( ) ; Instance Holder second H = m second Buffer . peek ( ) ; Instance first = first H . m instance ; Instance second = second H . m instance ; int cmp = compare ( first , second , first H , second H ) ; if ( cmp == NUM ) { Instance new Inst = generate Merged Instance ( m first Buffer . remove ( ) , m second Buffer . remove ( ) ) ; return new Inst ; } else if ( cmp < NUM ) { do { m first Buffer . remove ( ) ; if ( m first Buffer . size ( ) > NUM ) { first H = m first Buffer . peek ( ) ; first = first H . m instance ; cmp = compare ( first , second , first H , second H ) ; } } while ( cmp < NUM && m first Buffer . size ( ) > NUM ) ; } else { do { m second Buffer . remove ( ) ; if ( m second Buffer . size ( ) > NUM ) { second H = m second Buffer . peek ( ) ; second = second H . m instance ; cmp = compare ( first , second , first H , second H ) ; } } while ( cmp > NUM && m second Buffer . size ( ) > NUM ) ; } } return null ; }
public boolean is Theme Constant ( String constant Name , boolean def ) { String c = get Theme Constant ( constant Name , null ) ; if ( c == null ) { return def ; } return c . equals Ignore Case ( STRING ) || c . equals ( STRING ) ; }
public void test Delete 4 ( ) throws SQL Exception { Database Creator . fill FK Cascade Table ( conn ) ; statement . execute ( STRING + Database Creator . PARENT TABLE + STRING ) ; }
public void unmap ( int addr , int len ) { for ( int i = NUM ; i < len ; i += PAGE SIZE ) { int pte = get PTE ( addr + i ) ; if ( get Page ( pte ) != null ) { readable Memory [ pte ] = null ; writable Memory [ pte ] = null ; executable Memory [ pte ] = null ; } else { throw new Error ( STRING + Integer . to Hex String ( addr ) + STRING + len ) ; } } }
private synchronized void save To Settings ( ) { List < List > entries To Save = new Array List < > ( ) ; for ( Status History Entry entry : entries . values ( ) ) { entries To Save . add ( entry To List ( entry ) ) ; } settings . put List ( STRING , entries To Save ) ; }
protected void init Finished ( ) { }
protected void add To Maintenance Queue ( Node Port Tuple npt ) { if ( maintenance Queue . contains ( npt ) == BOOL ) maintenance Queue . add ( npt ) ; }
public Movie Scraper Metadata Panel ( Movie Scraper Metadata Config config ) { this . config = config ; init Components ( ) ; }
public int size ( ) { return seq . size ( ) ; }
public static void assert Props Per Row ( Iterator < Event Bean > iterator , Safe Iterator < Event Bean > safe Iterator , String [ ] property Names , Object [ ] [ ] expected ) { assert Props Per Row ( EP Assertion Util . iterator To Array ( iterator ) , property Names , expected ) ; assert Props Per Row ( EP Assertion Util . iterator To Array ( safe Iterator ) , property Names , expected ) ; safe Iterator . close ( ) ; }
public boolean is Leaf ( ) { return children == null || children . is Empty ( ) ; }
public void test Get ( ) throws Exception { Ignite Cache < Long , Long > cache = populate ( ) ; for ( long i = from ; i < to ; i ++ ) { Long val = cache . get ( i ) ; assert Not Null ( val ) ; assert Equals ( i , val . long Value ( ) ) ; } assert Equals ( NUM , swapped Cnt . get ( ) ) ; assert Equals ( NUM , offheaped Cnt . get ( ) ) ; assert Equals ( to - from , unswaped Cnt . get ( ) + onheaped Cnt . get ( ) ) ; check Entries ( cache ) ; assert Equals ( to - from , unswaped Cnt . get ( ) + onheaped Cnt . get ( ) ) ; }
public int read ( ) throws IO Exception { if ( has Next Char ) { has Next Char = BOOL ; write ( next Char ) ; return next Char ; } if ( previous Line != lexer . get Line ( ) ) { num Unicode Escapes Found On Current Line = NUM ; previous Line = lexer . get Line ( ) ; } int c = reader . read ( ) ; if ( c != STRING ) { write ( c ) ; return c ; } c = reader . read ( ) ; if ( c != STRING ) { has Next Char = BOOL ; next Char = c ; write ( STRING ) ; return STRING ; } int number Of U Chars = NUM ; do { number Of U Chars ++ ; c = reader . read ( ) ; } while ( c == STRING ) ; check Hex Digit ( c ) ; String Builder char Num = new String Builder ( ) ; char Num . append ( ( char ) c ) ; for ( int i = NUM ; i < NUM ; i ++ ) { c = reader . read ( ) ; check Hex Digit ( c ) ; char Num . append ( ( char ) c ) ; } int rv = Integer . parse Int ( char Num . to String ( ) , NUM ) ; write ( rv ) ; num Unicode Escapes Found += NUM + number Of U Chars ; num Unicode Escapes Found On Current Line += NUM + number Of U Chars ; return rv ; }
public boolean is Empty ( ) { if ( ! built ) return item Boundables . is Empty ( ) ; return root . is Empty ( ) ; }
protected Abstract Writer ( Writer w , Document doc , int pos , int len ) { this . doc = doc ; it = new Element Iterator ( doc . get Default Root Element ( ) ) ; out = w ; start Offset = pos ; end Offset = pos + len ; Object doc Newline = doc . get Property ( Default Editor Kit . End Of Line String Property ) ; if ( doc Newline instanceof String ) { set Line Separator ( ( String ) doc Newline ) ; } else { String newline = null ; try { newline = System . get Property ( STRING ) ; } catch ( Security Exception se ) { } if ( newline == null ) { newline = STRING ; } set Line Separator ( newline ) ; } can Wrap Lines = BOOL ; }
protected void adjust Position Y ( int velocity Y ) { if ( reverse Layout ) velocity Y *= - NUM ; int child Count = get Child Count ( ) ; if ( child Count > NUM ) { int cur Position = View Utils . get Center Y Child Position ( this ) ; int child Height = get Height ( ) - get Padding Top ( ) - get Padding Bottom ( ) ; int fling Count = get Fling Count ( velocity Y , child Height ) ; int target Position = cur Position + fling Count ; if ( m Single Page Fling ) { fling Count = Math . max ( - NUM , Math . min ( NUM , fling Count ) ) ; target Position = fling Count == NUM ? cur Position : m Position On Touch Down + fling Count ; } target Position = Math . max ( target Position , NUM ) ; target Position = Math . min ( target Position , get Item Count ( ) - NUM ) ; if ( target Position == cur Position && ( ! m Single Page Fling || m Position On Touch Down == cur Position ) ) { View center Y Child = View Utils . get Center Y Child ( this ) ; if ( center Y Child != null ) { if ( m Touch Span > center Y Child . get Height ( ) * m Trigger Offset && target Position != NUM ) { if ( ! reverse Layout ) target Position -- ; else target Position ++ ; } else if ( m Touch Span < center Y Child . get Height ( ) * - m Trigger Offset && target Position != get Item Count ( ) - NUM ) { if ( ! reverse Layout ) target Position ++ ; else target Position -- ; } } } if ( DEBUG ) { Log . d ( STRING , STRING + m Touch Span ) ; Log . d ( STRING , STRING + target Position ) ; } smooth Scroll To Position ( safe Target Position ( target Position , get Item Count ( ) ) ) ; } }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
@ Override public Node import To ( Document host Document ) { Validate Util . validate Not Null ( host Document , STRING ) ; Element cloned Token Element = ( Element ) host Document . import Node ( parsed Token . get Document Element ( ) , BOOL ) ; mark Assertion Id Attribute ( cloned Token Element ) ; return cloned Token Element ; }
public static Matrix random ( int m , int n ) { Matrix A = new Matrix ( m , n ) ; double [ ] [ ] X = A . get Array ( ) ; for ( int i = NUM ; i < m ; i ++ ) { for ( int j = NUM ; j < n ; j ++ ) { X [ i ] [ j ] = Math . random ( ) ; } } return A ; }
public void add Priority Unit ( String id ) { if ( ! String Util . is Positive Integer ( id ) ) { return ; } add Priority Unit ( Integer . parse Int ( id ) ) ; }
private void calc Interval Dis ( ) { if ( m Mark Text Paint == null ) { return ; } String default Text = STRING ; Rect temp = new Rect ( ) ; int max = NUM ; if ( m Items != null && m Items . size ( ) > NUM ) { for ( String i : m Items ) { m Mark Text Paint . get Text Bounds ( i , NUM , i . length ( ) , temp ) ; if ( temp . width ( ) > max ) { max = temp . width ( ) ; } } } else { m Mark Text Paint . get Text Bounds ( default Text , NUM , default Text . length ( ) , temp ) ; max = temp . width ( ) ; } if ( ! Text Utils . is Empty ( m Addition Center Mark ) ) { m Mark Text Paint . set Text Size ( m Normal Text Size ) ; m Mark Text Paint . get Text Bounds ( m Addition Center Mark , NUM , m Addition Center Mark . length ( ) , temp ) ; m Addition Center Mark Width = temp . width ( ) ; max += temp . width ( ) ; } m Interval Dis = max * m Interval Factor ; }
public boolean is Use Softkeys ( ) { return use Softkeys ; }
public void test Division Knuth First Digits Equal ( ) { byte a Bytes [ ] = { NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM } ; int a Sign = - NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . divide ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public void connection Closed ( Connection Event event ) { if ( is Active ) { Managed Connection conn = ( Managed Connection ) event . get Source ( ) ; Transaction Manager Impl trans Manager = Transaction Manager Impl . get Transaction Manager ( ) ; try { Transaction txn = trans Manager . get Transaction ( ) ; if ( txn == null ) { mann Pool Cache . return Pooled Connection To Pool ( conn ) ; } } catch ( Exception se ) { String exception = STRING + se . get Message ( ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( exception , se ) ; } } } }
public Metadata Block Header ( boolean is Last Block , Block Type block Type , int data Length ) { Byte Buffer rawdata = Byte Buffer . allocate ( HEADER LENGTH ) ; this . block Type = block Type ; this . is Last Block = is Last Block ; this . data Length = data Length ; byte type ; if ( is Last Block ) { type = ( byte ) ( NUM | block Type . get Id ( ) ) ; } else { type = ( byte ) block Type . get Id ( ) ; } rawdata . put ( type ) ; rawdata . put ( ( byte ) ( ( data Length & NUM ) > > > NUM ) ) ; rawdata . put ( ( byte ) ( ( data Length & NUM ) > > > NUM ) ) ; rawdata . put ( ( byte ) ( data Length & NUM ) ) ; bytes = new byte [ HEADER LENGTH ] ; for ( int i = NUM ; i < HEADER LENGTH ; i ++ ) { bytes [ i ] = rawdata . get ( i ) ; } }
private void check File To Run ( ) throws Exit Code Exception { if ( run This File == null || ! run This File . exists ( ) ) { throw new Exit Code Exception ( EXITCODE MODULE TO RUN NOT FOUND ) ; } }
public void add Last Item ( M model ) { add Item ( m Datas . size ( ) , model ) ; }
@ Managed Operation ( description = STRING ) public void notify All Tag Cache Listeners ( ) { LOGGER . info ( STRING ) ; for ( Long key : control Tag Cache . get Keys ( ) ) { control Tag Cache . acquire Write Lock On Key ( key ) ; try { Control Tag control Tag = control Tag Cache . get Copy ( key ) ; long event Time = System . current Time Millis ( ) ; control Tag Cache . notify Listener Status Confirmation ( control Tag , event Time ) ; } finally { control Tag Cache . release Write Lock On Key ( key ) ; } } for ( Long key : data Tag Cache . get Keys ( ) ) { data Tag Cache . acquire Write Lock On Key ( key ) ; try { Data Tag data Tag = data Tag Cache . get Copy ( key ) ; long event Time = System . current Time Millis ( ) ; data Tag Cache . notify Listener Status Confirmation ( data Tag , event Time ) ; } finally { data Tag Cache . release Write Lock On Key ( key ) ; } } LOGGER . info ( STRING ) ; }
public static long [ ] breakdown ( long t , @ Non Null Time Unit unit , boolean round Millis ) { long days = unit . to Days ( t ) ; long hours = unit . to Hours ( t ) % NUM ; long minutes = unit . to Minutes ( t ) % NUM ; long seconds = unit . to Seconds ( t ) % NUM ; long msecs = unit . to Millis ( t ) % NUM ; if ( round Millis ) { if ( msecs >= NUM ) { seconds ++ ; msecs = NUM ; if ( seconds == NUM ) { minutes ++ ; seconds = NUM ; if ( minutes == NUM ) { hours ++ ; minutes = NUM ; if ( hours == NUM ) { days ++ ; hours = NUM ; } } } } } return new long [ ] { days , hours , minutes , seconds , msecs } ; }
private int socks Get Server Port ( ) { Inet Socket Address addr = ( Inet Socket Address ) proxy . address ( ) ; return addr . get Port ( ) ; }
public static < T > Reactive Seq < T > from List ( final List < T > list ) { Objects . require Non Null ( list ) ; final Reversing List Spliterator array = new Reversing List Spliterator < T > ( list , BOOL ) ; return Stream Utils . reactive Seq ( Stream Support . stream ( array , BOOL ) , Optional . of Nullable ( array ) ) ; }
private boolean process Key Up ( int key Code ) { if ( key Code == Key Event . KEYCODE DEL ) { if ( m In Kb Mode ) { if ( ! m Typed Times . is Empty ( ) ) { int deleted = delete Last Typed Key ( ) ; String deleted Key Str ; if ( deleted == get Am Or Pm Key Code ( AM ) ) { deleted Key Str = m Am Text ; } else if ( deleted == get Am Or Pm Key Code ( PM ) ) { deleted Key Str = m Pm Text ; } else { deleted Key Str = String . format ( STRING , get Val From Key Code ( deleted ) ) ; } View Compat Utils . announce For Accessibility ( m Delegator , String . format ( m Deleted Key Format , deleted Key Str ) ) ; update Display ( BOOL ) ; } } } else if ( key Code == Key Event . KEYCODE 0 || key Code == Key Event . KEYCODE 1 || key Code == Key Event . KEYCODE 2 || key Code == Key Event . KEYCODE 3 || key Code == Key Event . KEYCODE 4 || key Code == Key Event . KEYCODE 5 || key Code == Key Event . KEYCODE 6 || key Code == Key Event . KEYCODE 7 || key Code == Key Event . KEYCODE 8 || key Code == Key Event . KEYCODE 9 || ( ! m Is 24 Hour View && ( key Code == get Am Or Pm Key Code ( AM ) || key Code == get Am Or Pm Key Code ( PM ) ) ) ) { if ( ! m In Kb Mode ) { if ( m Radial Time Picker View == null ) { Log . e ( TAG , STRING ) ; return BOOL ; } m Typed Times . clear ( ) ; try Starting Kb Mode ( key Code ) ; return BOOL ; } if ( add Key If Legal ( key Code ) ) { update Display ( BOOL ) ; } return BOOL ; } return BOOL ; }
public synchronized OM Graphic List prepare ( ) { OM Graphic List list = new OM Graphic List ( ) ; Projection proj = get Projection ( ) ; if ( proj == null ) { return list ; } Point 2 D upper Left = proj . get Upper Left ( ) ; Point 2 D lower Right = proj . get Lower Right ( ) ; if ( upper Left . get X ( ) > lower Right . get X ( ) ) { get Points ( new Data Bounds ( upper Left , new Point 2 D . Double ( NUM , lower Right . get Y ( ) ) ) , list , proj ) ; get Points ( new Data Bounds ( new Point 2 D . Double ( - NUM , upper Left . get Y ( ) ) , lower Right ) , list , proj ) ; } else { get Points ( new Data Bounds ( upper Left , lower Right ) , list , proj ) ; } OM Text statement = new OM Text ( NUM , proj . get Height ( ) - NUM , get Name ( ) + STRING + list . size ( ) + STRING + data Source . size ( ) + STRING , OM Text . JUSTIFY LEFT ) ; statement . set Fill Paint ( Color . gray ) ; statement . generate ( proj ) ; list . add ( NUM , statement ) ; return list ; }
public X509 Name ( Vector oids , Vector values ) { this ( oids , values , new X509 Default Entry Converter ( ) ) ; }
void next Line ( ) { try { next Line = current Episode . read Line ( ) ; while ( next Line . equals ( STRING ) ) next Line = current Episode . read Line ( ) ; } catch ( IO Exception | Null Pointer Exception e ) { next Line = null ; } }
public Jobs subset ( String [ ] job Ids ) { final List < Job > subset Result = new Array List < Job > ( ) ; for ( String job Id : job Ids ) { Job job = job Map . get ( job Id ) ; if ( job . is Analysis ( ) ) { subset Result . add ( job ) ; } } return new Jobs ( subset Result ) ; }
public void add Property Change Listener ( Property Change Listener listener ) { List < Property Change Listener > l = Arrays . as List ( listener List . get Listeners ( Property Change Listener . class ) ) ; if ( ! l . contains ( listener ) ) { listener List . add ( Property Change Listener . class , listener ) ; } }
public static byte [ ] from Hex String ( String text ) { text = text . trim ( ) ; if ( text . length ( ) % NUM != NUM ) text = STRING + text ; int res Len = text . length ( ) / NUM ; int lo Nibble , hi Nibble ; byte [ ] res = new byte [ res Len ] ; for ( int i = NUM ; i < res Len ; i ++ ) { int j = i << NUM ; hi Nibble = char To Nibble ( text . char At ( j ) ) ; lo Nibble = char To Nibble ( text . char At ( j + NUM ) ) ; if ( lo Nibble == - NUM || hi Nibble == - NUM ) return null ; res [ i ] = ( byte ) ( hi Nibble << NUM | lo Nibble ) ; } return res ; }
protected static double variance ( double [ ] s , double [ ] sS , double [ ] sum Of Weights ) { double var = NUM ; for ( int i = NUM ; i < s . length ; i ++ ) { if ( sum Of Weights [ i ] > NUM ) { var += single Variance ( s [ i ] , sS [ i ] , sum Of Weights [ i ] ) ; } } return var ; }
public void write ( Char Sequence csq ) throws IO Exception { final int length = csq . length ( ) ; for ( int i = NUM ; i < length ; ) { char c = csq . char At ( i ++ ) ; if ( c < NUM ) { bytes [ index ] = ( byte ) c ; if ( ++ index >= bytes . length ) { flush Buffer ( ) ; } } else { write ( c ) ; } } }
public static boolean can Resize ( List constraints ) { for ( Iterator iter = constraints . iterator ( ) ; iter . has Next ( ) ; ) { Dock Constraint dc = ( Dock Constraint ) iter . next ( ) ; if ( ! dc . can Resize ( ) ) return BOOL ; } return BOOL ; }
@ Override public boolean connection Allowed ( Event Set Descriptor esd ) { return connection Allowed ( esd . get Name ( ) ) ; }
String read Number ( String source , int ofs , String token , boolean adjacent ) { if ( adjacent ) { return source . substring ( ofs , ofs + token . length ( ) ) ; } int len = source . length ( ) ; for ( int i = ofs ; i < len ; i ++ ) { char ch = source . char At ( i ) ; if ( is Numeric ( ch ) == BOOL ) { if ( i == NUM ) { return null ; } return source . substring ( ofs , i ) ; } } return source . substring ( ofs ) ; }
private Vec feed Forward ( Vec input ) { Vec x = input ; for ( int i = NUM ; i < Ws . size ( ) ; i ++ ) { Matrix W i = Ws . get ( i ) ; Vec b i = bs . get ( i ) ; Vec a i = W i . multiply ( x ) ; a i . mutable Add ( b i ) ; a i . apply Function ( f ) ; x = a i ; } return x ; }
private boolean split wtrace other ( Brd Tracep found trace , Collection < Brd Tracep > split pieces , Array List < Pla Line Int > intersecting lines , Awtree Find Entry found entry ) { if ( found trace == this ) return BOOL ; boolean have trace split = BOOL ; for ( Pla Line Int inter line : intersecting lines ) { if ( have trace split ) break ; int line no = found entry . shape index in object + NUM ; Array List < Brd Tracep > curr split pieces = found trace . split with end line ( line no , inter line ) ; if ( curr split pieces . size ( ) < NUM ) continue ; have trace split = BOOL ; split pieces . add All ( curr split pieces ) ; } if ( ! have trace split ) split pieces . add ( found trace ) ; return have trace split ; }
private void print Solution ( Solution solution ) { if ( include Variables ) { for ( int i = NUM ; i < solution . get Number Of Variables ( ) ; i ++ ) { if ( i > NUM ) { writer . print ( STRING ) ; } writer . print ( encode ( solution . get Variable ( i ) ) ) ; } } for ( int i = NUM ; i < solution . get Number Of Objectives ( ) ; i ++ ) { if ( ( i > NUM ) || ( include Variables && ( solution . get Number Of Variables ( ) > NUM ) ) ) { writer . print ( STRING ) ; } writer . print ( solution . get Objective ( i ) ) ; } writer . println ( ) ; }
public void read NBT ( NBT Tag Compound nbt ) { if ( nbt . has Key ( STRING , NUM ) ) { this . decay Level = nbt . get Integer ( STRING ) ; this . decay Saturation Level = nbt . get Float ( STRING ) ; this . decay Acceleration Level = nbt . get Float ( STRING ) ; } }
public void copy To ( Position Texture Vertex [ ] verts , Textured Quad [ ] quad ) { Textured Polygon [ ] poly = new Textured Polygon [ quad . length ] ; for ( int idx = NUM ; idx < quad . length ; idx ++ ) { poly [ idx ] = new Textured Polygon ( ( Position Texture Vertex [ ] ) quad [ idx ] . vertex Positions ) ; } copy To ( verts , poly ) ; }
public synchronized void delete Observer ( Observer observer ) { observers . remove ( observer ) ; }
public Account Attribute as Account Attribute ( Account account ) { if ( account == null ) { return null ; } Account Attribute who = new Account Attribute ( ) ; who . name = account . get Full Name ( ) ; who . email = account . get Preferred Email ( ) ; who . username = account . get User Name ( ) ; return who ; }
public void delete ( Template Persistence Data data ) { if ( data . is User Added ( ) ) f Templates . remove ( data ) ; else data . set Deleted ( BOOL ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public String consume Word ( ) { int start = pos ; while ( matches Word ( ) ) pos ++ ; return queue . substring ( start , pos ) ; }
public static void print Inlining ( final Resolved Java Method method , final int bci , final int inlining Depth , final boolean success , final String msg , final Object ... args ) { if ( Hot Spot Print Inlining . get Value ( ) ) { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; sb . append ( String . format ( STRING , STRING , method . is Synchronized ( ) ? STRING : STRING , STRING , STRING , method . is Native ( ) ? STRING : STRING ) ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; for ( int i = NUM ; i < inlining Depth ; i ++ ) { sb . append ( STRING ) ; } sb . append ( String . format ( STRING , bci , method Name ( method ) , success ? STRING : STRING , String . format ( msg , args ) ) ) ; TTY . println ( sb . to String ( ) ) ; } }
public static double calculate P Value ( double t , int v ) { return NUM * ( NUM - Students T Distribution . cdf ( Math . abs ( t ) , v ) ) ; }
public static void append Child ( Node parent , Node child ) { Document owner Doc = get Owner Document ( parent ) ; if ( child . get Owner Document ( ) != owner Doc ) { parent . append Child ( owner Doc . import Node ( child , BOOL ) ) ; } else { parent . append Child ( child ) ; } }
protected void delete Session Variables ( String session Id , String ... var Names ) { if ( session Id . equals ( STRING ) ) { return ; } Key key = key Factory . new Key ( session Id ) ; Transaction transaction = datastore . new Transaction ( ) ; try { Entity state Entity = transaction . get ( key ) ; Entity . Builder builder = Entity . builder ( state Entity ) ; String Builder del Names = new String Builder ( ) ; for ( String var Name : var Names ) { del Names . append ( var Name + STRING ) ; builder = builder . remove ( var Name ) ; } datastore . update ( builder . build ( ) ) ; } catch ( Null Pointer Exception e ) { } finally { if ( transaction . active ( ) ) { transaction . rollback ( ) ; } } }
@ Suppress Lint ( STRING ) private void prune Scrap Views ( ) { final int max Views = m Active Views . length ; final int view Type Count = m View Type Count ; final Array List < View > [ ] scrap Views = m Scrap Views ; for ( int i = NUM ; i < view Type Count ; ++ i ) { final Array List < View > scrap Pile = scrap Views [ i ] ; int size = scrap Pile . size ( ) ; final int extras = size - max Views ; size -- ; for ( int j = NUM ; j < extras ; j ++ ) { remove Detached View ( scrap Pile . remove ( size -- ) , BOOL ) ; } } if ( m Transient State Views != null ) { for ( int i = NUM ; i < m Transient State Views . size ( ) ; i ++ ) { final View v = m Transient State Views . value At ( i ) ; if ( ! v . has Transient State ( ) ) { m Transient State Views . remove At ( i ) ; i -- ; } } } }
private void update Work Amount ( double work Time ) { if ( work Time <= NUM ) { current Work Amount *= NUM ; } else { total Time Taken += work Time ; completed Work Amount += current Work Amount ; current Work Amount = ( int ) Math . ceil ( target Execution Ms * completed Work Amount / total Time Taken ) ; } }
public static boolean is Laf Aqua ( ) { ensure Valid Cache ( ) ; if ( cached Is Laf Aqua == null ) { cached Is Laf Aqua = Boolean . value Of ( compute Is Laf Aqua ( ) ) ; } return cached Is Laf Aqua . boolean Value ( ) ; }
public void move Randomly ( ) { set Random Path From ( get X ( ) , get Y ( ) , get Movement Range ( ) / NUM ) ; }
public void pln I ( Object o ) throws IO Exception { p ( o . to String ( ) ) ; pln ( ) ; pI ( ) ; }
@ Override public void write Entity To NBT ( NBT Tag Compound par 1 NBT Tag Compound ) { par 1 NBT Tag Compound . set Short ( STRING , ( short ) this . x Tile ) ; par 1 NBT Tag Compound . set Short ( STRING , ( short ) this . y Tile ) ; par 1 NBT Tag Compound . set Short ( STRING , ( short ) this . z Tile ) ; par 1 NBT Tag Compound . set Integer ( STRING , Block . get Id From Block ( this . in Tile ) ) ; par 1 NBT Tag Compound . set Byte ( STRING , ( byte ) this . in Data ) ; par 1 NBT Tag Compound . set Byte ( STRING , ( byte ) this . arrow Shake ) ; par 1 NBT Tag Compound . set Byte ( STRING , ( byte ) ( this . in Ground ? NUM : NUM ) ) ; par 1 NBT Tag Compound . set Boolean ( STRING , this . is Explosive ) ; }
@ Override public String Buffer format ( final double value , final String Buffer buffer , final Field Position position ) { return format ( Double . value Of ( value ) , buffer , position ) ; }
private Object translate Stream To Input Stream ( Input Stream str , Data Flavor flavor , long format , Transferable locale Transferable ) throws IO Exception { if ( is Flavor Charset Text Type ( flavor ) && is Text Format ( format ) ) { str = new Reencoding Input Stream ( str , format , Data Transferer . get Text Charset ( flavor ) , locale Transferable ) ; } return construct Flavored Object ( str , flavor , Input Stream . class ) ; }
public void dispose ( ) throws Iab Async In Progress Exception { synchronized ( m Async In Progress Lock ) { if ( m Async In Progress ) { throw new Iab Async In Progress Exception ( STRING + STRING + m Async Operation + STRING ) ; } } log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null ) m Context . unbind Service ( m Service Conn ) ; } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
private boolean is IPT Resource Folder ( File dir ) { if ( dir . exists ( ) && dir . is Directory ( ) ) { File persistence File = new File ( dir , PERSISTENCE FILE ) ; File eml File = new File ( dir , Data Dir . EML XML FILENAME ) ; return persistence File . is File ( ) && eml File . is File ( ) ; } return BOOL ; }
public Set < String > add Sprite Frames ( String plist , CC Texture 2 D texture ) { Hash Map < String , Object > dict = Plist Parser . parse ( plist ) ; return add Sprite Frames ( dict , texture ) ; }
public void add Annotation ( final Annotation annotation ) { annotation List . add ( annotation ) ; annotation . setxy Graph ( xy Graph ) ; add ( annotation ) ; revalidate ( ) ; change Support . fire Property Change ( STRING , null , annotation ) ; }
public static void create Overviews ( AS Doc Configuration config ) throws Compiler Exception { String templates Path = config . get Templates Path ( ) ; String dita Path = config . get Output ( ) + STRING + File . separator ; Buffered Writer writer = null ; Reader reader = null ; try { writer = new Buffered Writer ( new File Writer ( dita Path + STRING ) ) ; if ( config . get Package Description File ( ) != null ) { reader = new Buffered Reader ( new File Reader ( config . get Package Description File ( ) ) ) ; } else { reader = new Buffered Reader ( new File Reader ( templates Path + STRING ) ) ; } Overviews Handler h = new Overviews Handler ( writer , config ) ; Input Source source = new Input Source ( reader ) ; SAX Parser Factory factory = SAX Parser Factory . new Instance ( ) ; SAX Parser parser = factory . new SAX Parser ( ) ; parser . parse ( source , h ) ; } catch ( Exception e ) { if ( Trace . error ) e . print Stack Trace ( ) ; Compiler Message c = new Could Not Create ( STRING , e . get Message ( ) ) ; Thread Local Toolkit . log ( c ) ; throw c ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( IO Exception ioe ) { } } if ( reader != null ) { try { reader . close ( ) ; } catch ( IO Exception ioe ) { } } } }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
public Create New Note Intent Builder add Tags ( @ Nullable Array List < String > tags ) { Array List < String > list = m Args . get String Array List ( Evernote Intent . EXTRA TAG NAME LIST ) ; if ( list == null ) { list = tags ; } else if ( tags != null ) { list . add All ( tags ) ; } return set Tags ( list ) ; }
private Remote Operation Result refresh Shares For Folder ( Own Cloud Client client ) { Remote Operation Result result = null ; Get Remote Shares For File Operation operation = new Get Remote Shares For File Operation ( m Local Folder . get Remote Path ( ) , BOOL , BOOL ) ; result = operation . execute ( client ) ; if ( result . is Success ( ) ) { Array List < OC Share > shares = new Array List < OC Share > ( ) ; for ( Object obj : result . get Data ( ) ) { shares . add ( ( OC Share ) obj ) ; } m Storage Manager . save Shares In Folder ( shares , m Local Folder ) ; } return result ; }
public double dist ( Math Vector other ) { double dist X = this . x - other . x ; double dist Y = this . y - other . y ; return Math . sqrt ( dist X * dist X + dist Y * dist Y ) ; }
public static String parse String ( String value ) { if ( ( value . starts With ( STRING ) ) && ( value . ends With ( STRING ) ) || ( value . starts With ( STRING ) ) && ( value . ends With ( STRING ) ) ) { if ( value . length ( ) > NUM ) { if ( value . index Of ( STRING ) != - NUM ) { return unescape ( value . substring ( NUM , value . length ( ) - NUM ) ) ; } return value . substring ( NUM , value . length ( ) - NUM ) ; } } throw new Illegal Argument Exception ( STRING + value + STRING ) ; }
private void define Desktop Panes ( UI Defaults d ) { d . put ( STRING , new Color UI Resource ( NUM ) ) ; String c = PAINTER PREFIX + STRING ; String p = STRING ; d . put ( p + STRING , new Lazy Painter ( c , Desktop Pane Painter . Which . BACKGROUND ENABLED ) ) ; p = STRING ; c = PAINTER PREFIX + STRING ; d . put ( p + STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Desktop Icon Painter . Which . BACKGROUND ENABLED ) ) ; }
private void fit Image To View ( ) { Drawable drawable = get Drawable ( ) ; if ( drawable == null || drawable . get Intrinsic Width ( ) == NUM || drawable . get Intrinsic Height ( ) == NUM ) { return ; } if ( matrix == null || prev Matrix == null ) { return ; } int drawable Width = drawable . get Intrinsic Width ( ) ; int drawable Height = drawable . get Intrinsic Height ( ) ; float scale X = ( float ) view Width / drawable Width ; float scale Y = ( float ) view Height / drawable Height ; switch ( m Scale Type ) { case CENTER : scale X = scale Y = NUM ; break ; case CENTER CROP : scale X = scale Y = Math . max ( scale X , scale Y ) ; break ; case CENTER INSIDE : scale X = scale Y = Math . min ( NUM , Math . min ( scale X , scale Y ) ) ; case FIT CENTER : scale X = scale Y = Math . min ( scale X , scale Y ) ; break ; case FIT XY : break ; default : throw new Unsupported Operation Exception ( STRING ) ; } float redundant X Space = view Width - ( scale X * drawable Width ) ; float redundant Y Space = view Height - ( scale Y * drawable Height ) ; match View Width = view Width - redundant X Space ; match View Height = view Height - redundant Y Space ; if ( ! is Zoomed ( ) && ! image Rendered At Least Once ) { matrix . set Scale ( scale X , scale Y ) ; matrix . post Translate ( redundant X Space / NUM , redundant Y Space / NUM ) ; normalized Scale = NUM ; } else { if ( prev Match View Width == NUM || prev Match View Height == NUM ) { save Previous Image Values ( ) ; } prev Matrix . get Values ( m ) ; m [ Matrix . MSCALE X ] = match View Width / drawable Width * normalized Scale ; m [ Matrix . MSCALE Y ] = match View Height / drawable Height * normalized Scale ; float trans X = m [ Matrix . MTRANS X ] ; float trans Y = m [ Matrix . MTRANS Y ] ; float prev Actual Width = prev Match View Width * normalized Scale ; float actual Width = get Image Width ( ) ; translate Matrix After Rotate ( Matrix . MTRANS X , trans X , prev Actual Width , actual Width , prev View Width , view Width , drawable Width ) ; float prev Actual Height = prev Match View Height * normalized Scale ; float actual Height = get Image Height ( ) ; translate Matrix After Rotate ( Matrix . MTRANS Y , trans Y , prev Actual Height , actual Height , prev View Height , view Height , drawable Height ) ; matrix . set Values ( m ) ; } fix Trans ( ) ; set Image Matrix ( matrix ) ; }
Object Animator animate Bound Scroll ( ) { float cur Scroll = get Stack Scroll ( ) ; float new Scroll = get Bounded Stack Scroll ( cur Scroll ) ; if ( Float . compare ( new Scroll , cur Scroll ) != NUM ) { animate Scroll ( cur Scroll , new Scroll , null ) ; } return m Scroll Animator ; }
public Int Array resize ( Int Array array , long size ) { if ( array instanceof Big Int Array ) { return resize In Place ( ( Big Int Array ) array , size ) ; } else { Abstract Array arr = ( Abstract Array ) array ; final Int Array new Array = new Int Array ( size , arr . clear On Resize ) ; for ( long i = NUM , end = Math . min ( size , array . size ( ) ) ; i < end ; ++ i ) { new Array . set ( i , array . get ( i ) ) ; } array . close ( ) ; return new Array ; } }
public DERUTC Time ( Date time ) { Simple Date Format date F = new Simple Date Format ( STRING ) ; date F . set Time Zone ( new Simple Time Zone ( NUM , STRING ) ) ; this . time = Strings . to Byte Array ( date F . format ( time ) ) ; }
public static double pdf ( double x , double mu , double beta ) { final double z = ( x - mu ) / beta ; if ( x == Double . NEGATIVE INFINITY ) { return NUM ; } return Math . exp ( - z - Math . exp ( - z ) ) / beta ; }
private static byte [ ] copy buffer ( byte [ ] buffer , int s Offset , int len ) { byte [ ] new Data = new byte [ len ] ; System . arraycopy ( buffer , s Offset , new Data , NUM , len ) ; return new Data ; }
public Shared Fs Checkpoint Spi ( ) { dir Paths . offer ( DFLT DIR PATH ) ; }
private void configure ( ) throws Null Location Exception , Formatter Init Exception { String Interval = lmanager . get Property ( Log Constants . LOGSIGN PERIODINSECONDS ) ; if ( ( Interval == null ) || ( Interval . length ( ) == NUM ) ) { sign Interval = Log Constants . LOGSIGN PERIODINSECONDS DEFAULT * NUM ; } else { sign Interval = Long . parse Long ( Interval ) * NUM ; } String str Max File Size = lmanager . get Property ( Log Constants . MAX FILE SIZE ) ; if ( ( str Max File Size == null ) || ( str Max File Size . length ( ) == NUM ) ) { max File Size = NUM ; } else { max File Size = Integer . parse Int ( str Max File Size ) ; } location = lmanager . get Property ( Log Constants . LOG PROP PREFIX + STRING + log Name + STRING ) ; if ( location == null ) { location = lmanager . get Property ( Log Constants . LOG LOCATION ) ; } if ( ( location == null ) || ( location . length ( ) == NUM ) ) { throw new Null Location Exception ( STRING ) ; } if ( ! location . ends With ( File . separator ) ) { location += File . separator ; } String files Per Key Store String = lmanager . get Property ( Log Constants . FILES PER KEYSTORE ) ; if ( ( files Per Key Store String == null ) || ( files Per Key Store String . length ( ) == NUM ) ) { if ( Debug . warning Enabled ( ) ) { Debug . warning ( log Name + STRING + STRING ) ; } files Per Key Store String = STRING ; } files Per Key Store = Integer . parse Int ( files Per Key Store String ) ; if ( Debug . message Enabled ( ) ) { Debug . message ( log Name + STRING + files Per Key Store String ) ; } String archiver Class String = lmanager . get Property ( Log Constants . ARCHIVER ) ; if ( ( archiver Class String == null ) || ( archiver Class String . length ( ) == NUM ) ) { throw new Null Location Exception ( STRING ) ; } archiver Class = archiver Class String ; }
public void pull ( final Pull Params params , final Progress Monitor progress Monitor ) throws IO Exception { pull ( params , progress Monitor , docker Daemon Uri ) ; }
public static Input Stream stream From String ( String location ) throws IO Exception { Input Stream is = null ; URL url = url From String ( location , null , BOOL ) ; if ( url != null ) { is = url . open Stream ( ) ; } else { File f = new File ( location ) ; if ( f . exists ( ) ) is = new File Input Stream ( f ) ; } if ( is == null ) { return null ; } else if ( is G Zip File ( location ) ) { return new GZIP Input Stream ( is ) ; } else { return is ; } }
public void add Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners == null ) { m Update Listeners = new Array List < Animator Update Listener > ( ) ; } m Update Listeners . add ( listener ) ; }
public void handle Request ( Request Context rc ) throws CLI Exception { super . handle Request ( rc ) ; SSO Token admin SSO Token = get Admin SSO Token ( ) ; I Output output Writer = get Output Writer ( ) ; String realm = get String Option Value ( I Argument . REALM NAME ) ; String id Name = get String Option Value ( ARGUMENT ID NAME ) ; String type = get String Option Value ( ARGUMENT ID TYPE ) ; Id Type id Type = convert 2 Id Type ( type ) ; String [ ] params = { realm , type , id Name } ; try { AM Identity Repository amir = new AM Identity Repository ( admin SSO Token , realm ) ; Set set = amir . get Allowed Id Operations ( id Type ) ; if ( ! set . contains ( Id Operation . SERVICE ) ) { throw new CLI Exception ( Message Format . format ( get Resource String ( STRING ) , ( Object [ ] ) params ) , Exit Codes . REQUEST CANNOT BE PROCESSED ) ; } write Log ( Log Writer . LOG ACCESS , Level . INFO , STRING , params ) ; AM Identity amid = new AM Identity ( admin SSO Token , id Name , id Type , realm , null ) ; Set services = amid . get Assignable Services ( ) ; if ( id Type . equals ( Id Type . USER ) ) { services . remove ( Constants . SVC NAME USER ) ; services . remove ( Constants . SVC NAME AUTH CONFIG ) ; services . remove ( Constants . SVC NAME SAML ) ; } if ( ( services != null ) && ! services . is Empty ( ) ) { String msg = get Resource String ( STRING ) ; String [ ] arg = { STRING } ; for ( Iterator i = services . iterator ( ) ; i . has Next ( ) ; ) { arg [ NUM ] = ( String ) i . next ( ) ; output Writer . println Message ( Message Format . format ( msg , ( Object [ ] ) arg ) ) ; } } else { output Writer . println Message ( get Resource String ( STRING ) ) ; } write Log ( Log Writer . LOG ACCESS , Level . INFO , STRING , params ) ; } catch ( Id Repo Exception e ) { String [ ] args = { realm , type , id Name , e . get Message ( ) } ; debug Error ( STRING , e ) ; write Log ( Log Writer . LOG ERROR , Level . INFO , STRING , args ) ; throw new CLI Exception ( e , Exit Codes . REQUEST CANNOT BE PROCESSED ) ; } catch ( SSO Exception e ) { String [ ] args = { realm , type , id Name , e . get Message ( ) } ; debug Error ( STRING , e ) ; write Log ( Log Writer . LOG ERROR , Level . INFO , STRING , args ) ; throw new CLI Exception ( e , Exit Codes . REQUEST CANNOT BE PROCESSED ) ; } }
public boolean is Alive ( ) { if ( has Sent Data ) { if ( System . current Time Millis ( ) - last Send Time < TIMEOUT ) return BOOL ; return has Received Data && last Receive Time > last Send Time ; } return BOOL ; }
private void remove Selected Items ( List items ) { for ( Iterator iter = items . iterator ( ) ; iter . has Next ( ) ; ) { Object item = iter . next ( ) ; remove History Item ( item ) ; } refresh With Last Selection = BOOL ; content Provider . refresh ( ) ; }
public static < K , V > Map < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 ) { Map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; map . put ( k4 , v4 ) ; return map ; }
public static void disable Connection Reuse If Necessary ( ) { if ( Build . VERSION . SDK INT < Build . VERSION CODES . FROYO ) { System . set Property ( STRING , STRING ) ; } }
public static long size Of ( Struct sct ) { Iterator < Entry < Key , Object > > it = sct . entry Iterator ( ) ; Entry < Key , Object > e ; long size = NUM ; while ( it . has Next ( ) ) { e = it . next ( ) ; size += Size Of . size ( e . get Key ( ) ) ; size += Size Of . size ( e . get Value ( ) ) ; } return size ; }
@ Override public boolean is Enabled ( ) { if ( ( attribute Selection Panel != null ) && ! is Value Only ( ) ) { return attribute Selection Panel . is Enabled ( ) ; } else { if ( table != null ) { return table . is Enabled ( ) ; } } return BOOL ; }
public static Header [ ] parse Headers ( final Session Input Buffer inbuffer , int max Header Count , int max Line Len , Line Parser parser ) throws Http Exception , IO Exception { if ( inbuffer == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( parser == null ) parser = Basic Line Parser . DEFAULT ; Array List header Lines = new Array List ( ) ; Char Array Buffer current = null ; Char Array Buffer previous = null ; for ( ; ; ) { if ( current == null ) { current = new Char Array Buffer ( NUM ) ; } else { current . clear ( ) ; } int l = inbuffer . read Line ( current ) ; if ( l == - NUM || current . length ( ) < NUM ) { break ; } if ( ( current . char At ( NUM ) == STRING || current . char At ( NUM ) == STRING ) && previous != null ) { int i = NUM ; while ( i < current . length ( ) ) { char ch = current . char At ( i ) ; if ( ch != STRING && ch != STRING ) { break ; } i ++ ; } if ( max Line Len > NUM && previous . length ( ) + NUM + current . length ( ) - i > max Line Len ) { throw new IO Exception ( STRING ) ; } previous . append ( STRING ) ; previous . append ( current , i , current . length ( ) - i ) ; } else { header Lines . add ( current ) ; previous = current ; current = null ; } if ( max Header Count > NUM && header Lines . size ( ) >= max Header Count ) { throw new IO Exception ( STRING ) ; } } Header [ ] headers = new Header [ header Lines . size ( ) ] ; for ( int i = NUM ; i < header Lines . size ( ) ; i ++ ) { Char Array Buffer buffer = ( Char Array Buffer ) header Lines . get ( i ) ; try { headers [ i ] = parser . parse Header ( buffer ) ; } catch ( Parse Exception ex ) { throw new Protocol Exception ( ex . get Message ( ) ) ; } } return headers ; }
@ Override public boolean is Factory For Type ( Object type ) { return supported Types . contains ( type ) || super . is Factory For Type ( type ) ; }
public void read Content ( byte [ ] dst , int offset , int length ) { System . arraycopy ( content , NUM , dst , offset , length ) ; }
public static void put Object Field ( Object obj , long field Off , Object val ) { UNSAFE . put Object ( obj , field Off , val ) ; }
public void on Configuration Changed ( ) { int cur First = pager . get Current Screen ( ) * PAGE SIZE ; cal Page Size ( ) ; int new Page = cur First / PAGE SIZE ; remove View At ( NUM ) ; after Platform List Got ( ) ; pager . set Current Screen ( new Page ) ; }
public List < Function Desc > list All Functions ( ) { List < Function Desc > functions = new Array List < Function Desc > ( ) ; for ( Measure Desc m : measures ) { functions . add ( m . get Function ( ) ) ; } return functions ; }
public boolean has Explicit Field ( String field Name ) { if ( fields . contains Key ( field Name ) ) { return BOOL ; } for ( Dynamic Field df : dynamic Fields ) { if ( field Name . equals ( df . get Regex ( ) ) ) return BOOL ; } return BOOL ; }
private static boolean instance Of Any ( Object o , Collection < Class > classes ) { for ( Class c : classes ) { if ( c . is Instance ( o ) ) return BOOL ; } return BOOL ; }
public static I Proposal Computer new Setter Attribute Proposal Computer ( Content Assist Request content Assist Request , I Java Project java Project ) { IDOM Node node = ( IDOM Node ) content Assist Request . get Node ( ) ; if ( node . get Node Type ( ) != IDOM Node . ELEMENT NODE ) { return null ; } String widget Type Name = Ui Binder Xml Model Utilities . compute Qualified Widget Type Name ( node ) ; if ( widget Type Name == null ) { return null ; } String match String = content Assist Request . get Match String ( ) ; return new Setter Attribute Proposal Computer ( node , widget Type Name , java Project , match String , content Assist Request . get Replacement Begin Position ( ) , match String . length ( ) ) ; }
public void omit All ( ) { if ( write Chunk != null ) bytes Written += write Chunk . position ( ) ; bytes Read = bytes Written ; list . clear ( ) ; write Chunk = null ; read Chunk = null ; }
Job load Preview ( Future Callback < Pair < Omni Build Environment , Omni Gradle Build > > result Handler , List < Progress Listener > listeners ) ;
private void refresh ( I Launch Configuration configuration ) { set Launch Configuration ( configuration ) ; try { f Model = create Classpath Model ( configuration ) ; } catch ( Exception e ) { message = e . get Message ( ) ; set Error Message ( e . get Message ( ) ) ; } f Classpath Viewer . set Launch Configuration ( configuration ) ; f Classpath Viewer . set Input ( f Model ) ; set Dirty ( BOOL ) ; }
public void compute Package Fragment Roots ( I Classpath Entry [ ] resolved Classpath , Object Vector accumulated Roots , Hash Set root I Ds , I Classpath Entry referring Entry , boolean retrieve Exported Roots , Map root To Resolved Entries ) throws Java Model Exception { if ( referring Entry == null ) { root I Ds . add ( root ID ( ) ) ; } for ( int i = NUM , length = resolved Classpath . length ; i < length ; i ++ ) { compute Package Fragment Roots ( resolved Classpath [ i ] , accumulated Roots , root I Ds , referring Entry , retrieve Exported Roots , root To Resolved Entries ) ; } }
private void init ( ) { set Title ( STRING ) ; som Panel = new SOM Properties Panel ( network Panel , SOM Props Panel Type . CREATE GROUP ) ; tab Logic . add ( som Panel ) ; layout Panel = new Main Layout Panel ( BOOL , this ) ; layout Panel . set Current Layout ( SOM Group . DEFAULT LAYOUT ) ; tab Layout . add ( layout Panel ) ; tabbed Pane . add Tab ( STRING , tab Logic ) ; tabbed Pane . add Tab ( STRING , layout Panel ) ; set Content Pane ( tabbed Pane ) ; Action help Action = new Show Help Action ( som Panel . get Help Path ( ) ) ; add Button ( new J Button ( help Action ) ) ; }
private String diff lines To Chars Munge ( String text , List < String > line Array , Map < String , Integer > line Hash ) { int line Start = NUM ; int line End = - NUM ; String line ; String Builder chars = new String Builder ( ) ; while ( line End < text . length ( ) - NUM ) { line End = text . index Of ( STRING , line Start ) ; if ( line End == - NUM ) { line End = text . length ( ) - NUM ; } line = text . substring ( line Start , line End + NUM ) ; line Start = line End + NUM ; if ( line Hash . contains Key ( line ) ) { chars . append ( String . value Of ( ( char ) ( int ) line Hash . get ( line ) ) ) ; } else { line Array . add ( line ) ; line Hash . put ( line , line Array . size ( ) - NUM ) ; chars . append ( String . value Of ( ( char ) ( line Array . size ( ) - NUM ) ) ) ; } } return chars . to String ( ) ; }
public void remove ( Video video ) { video List . remove ( video ) ; notify Data Set Changed ( ) ; }
public boolean can Invert ( ) { return BOOL ; }
public void add All Searchables ( Array List < ? extends Search Result > searchable ) { searchables . add All ( searchable ) ; }
public static String to String ( final Iterable < ? > iterable ) { if ( iterable instanceof Collection ) { return iterable . to String ( ) ; } else { final String Builder builder = new String Builder ( ) ; boolean first Value = BOOL ; builder . append ( STRING ) ; for ( final Object value : iterable ) { if ( ! first Value ) { builder . append ( STRING ) ; } builder . append ( value ) ; first Value = BOOL ; } builder . append ( STRING ) ; return builder . to String ( ) ; } }
public static int parse Int ( String text ) { return parse Int ( text , NUM ) ; }
@ Override public void end Document ( Augmentations augs ) throws XNI Exception { try { if ( f Document Handler != null ) { f Document Handler . end Document ( ) ; } if ( f Content Handler != null ) { f Content Handler . end Document ( ) ; } } catch ( SAX Exception e ) { throw new XNI Exception ( e ) ; } }
public String exec Command ( String command ) { String Builder buf = new String Builder ( ) ; send Wait For ( command , default Timeout , prompts , buf ) ; log . debug ( buf . to String ( ) ) ; return clean Output ( buf ) ; }
private void Client Thread Run ( ) throws IO Exception { Socket Channel channel = null ; try { log . debug ( STRING , hostname , port , pending . size ( ) ) ; channel = Socket Channel . open ( new Inet Socket Address ( hostname , port ) ) ; channel . configure Blocking ( BOOL ) ; Client Thread Main Loop ( channel ) ; } finally { if ( channel != null ) { channel . close ( ) ; } if ( current != null ) { pending . offer First ( current ) ; current = null ; } } }
@ Override public Path Impl scheme Walk ( String user Path , Map < String , Object > new Attributes , String uri , int offset ) { int length = uri . length ( ) ; if ( length < NUM + offset || uri . char At ( offset ) != STRING || uri . char At ( NUM + offset ) != STRING ) throw new Runtime Exception ( STRING ) ; Char Buffer buf = new Char Buffer ( ) ; int i = NUM + offset ; int ch = NUM ; boolean is Ipv 6 = BOOL ; for ( ; ( i < length && ( ch = uri . char At ( i ) ) != STRING && ch != STRING && ! ( ch == STRING && ! is Ipv 6 ) ) ; i ++ ) { if ( ch == STRING ) is Ipv 6 = BOOL ; else if ( ch == STRING ) is Ipv 6 = BOOL ; buf . append ( ( char ) ch ) ; } String host = buf . to String ( ) ; if ( host . length ( ) == NUM ) throw new Runtime Exception ( STRING ) ; int port = NUM ; if ( ch == STRING ) { for ( i ++ ; i < length && ( ch = uri . char At ( i ) ) >= STRING && ch <= STRING ; i ++ ) { port = NUM * port + uri . char At ( i ) - STRING ; } } return create ( this , user Path , new Attributes , host , port ) ; }
@ Request Mapping ( value = STRING ) public void sso Default Tenant Binding Error ( Locale locale , Http Servlet Response response ) throws IO Exception { logger . info ( STRING + locale . to String ( ) + STRING ) ; send Error ( locale , response , STRING ) ; }
@ After public void tear Down ( ) { web Client . close All Windows ( ) ; }
@ Override public void on Can Start Video Service Changed ( boolean can Start Video Service ) { Log . i ( STRING , STRING + String . value Of ( can Start Video Service ) ) ; if ( can Start Video Service == BOOL ) { m Conversation Helper . start Outgoing Video ( ) ; m Conversation Helper . start Incoming Video ( ) ; } }
public Manifest ( Input Stream is ) throws IO Exception { while ( is . available ( ) != NUM ) { Message Header m = new Message Header ( is ) ; entries . add Element ( m ) ; } }
@ Override public Object read Reply ( Class expected Class ) throws Throwable { int tag = read ( ) ; if ( tag == STRING ) return read Object ( expected Class ) ; else if ( tag == STRING ) { Hash Map map = ( Hash Map ) read Object ( Hash Map . class ) ; throw prepare Fault ( map ) ; } else { String Builder sb = new String Builder ( ) ; sb . append ( ( char ) tag ) ; try { int ch ; while ( ( ch = read ( ) ) >= NUM ) { sb . append ( ( char ) ch ) ; } } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } throw error ( STRING + code Name ( tag ) + STRING + sb ) ; } }
public void remove Clicking Listener ( On Wheel Clicked Listener listener ) { clicking Listeners . remove ( listener ) ; }
public static String unexpand Line ( Char Sequence self , int tab Stop ) { String Builder builder = new String Builder ( self . to String ( ) ) ; int index = NUM ; while ( index + tab Stop < builder . length ( ) ) { String piece = builder . substring ( index , index + tab Stop ) ; int count = NUM ; while ( ( count < tab Stop ) && ( Character . is Whitespace ( piece . char At ( tab Stop - ( count + NUM ) ) ) ) ) count ++ ; if ( count > NUM ) { piece = piece . substring ( NUM , tab Stop - count ) + STRING ; builder . replace ( index , index + tab Stop , piece ) ; index = index + tab Stop - ( count - NUM ) ; } else index = index + tab Stop ; } return builder . to String ( ) ; }
private void uninstall ( String row Type ) { if ( extensions By Rowtype . contains Key ( row Type ) ) { extensions By Rowtype . remove ( row Type ) ; File f = get Extension File ( row Type ) ; if ( f . exists ( ) ) { File Utils . delete Quietly ( f ) ; } else { log . warn ( STRING + row Type ) ; } } else { log . warn ( STRING + row Type ) ; } }
public void add Property Change Listener ( String property Name , Property Change Listener in pcl ) { pc Support . add Property Change Listener ( property Name , in pcl ) ; }
static final int table Size For ( int cap ) { int n = cap - NUM ; n |= n > > > NUM ; n |= n > > > NUM ; n |= n > > > NUM ; n |= n > > > NUM ; n |= n > > > NUM ; return ( n < NUM ) ? NUM : ( n >= MAXIMUM CAPACITY ) ? MAXIMUM CAPACITY : n + NUM ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) ) { return BOOL ; } if ( m listenee != null ) { return BOOL ; } return BOOL ; }
protected void generate OM Graphic ( OM Graphic g ) { if ( g != null && g . get Need To Regenerate ( ) ) { Projection proj = get Projection ( ) ; if ( proj != null ) { g . generate ( proj ) ; } else if ( DEBUG ) { Debug . output ( STRING + g . get Need To Regenerate ( ) ) ; } } }
public void insert Variable ( ) { Script Step variable Step = Script Step Factory . create Variable ( get Variable Key ( ) , get Variable Value ( ) ) ; steps . add ( get Insert Index ( ) , variable Step ) ; variable Key = STRING ; variable Value = STRING ; reindex Script Steps ( ) ; }
protected boolean [ ] can Handle Zero Training ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type ) { print ( STRING ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( STRING ) ; Array List < String > accepts = new Array List < String > ( ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; int num Train = NUM , num Test = get Num Instances ( ) , num Classes = NUM , missing Level = NUM ; boolean predictor Missing = BOOL , class Missing = BOOL ; return run Basic Test ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type , missing Level , predictor Missing , class Missing , num Train , num Test , num Classes , accepts ) ; }
public static byte [ ] long 2 buff ( long n ) { byte [ ] bs ; bs = new byte [ NUM ] ; bs [ NUM ] = ( byte ) ( ( n > > NUM ) & NUM ) ; bs [ NUM ] = ( byte ) ( ( n > > NUM ) & NUM ) ; bs [ NUM ] = ( byte ) ( ( n > > NUM ) & NUM ) ; bs [ NUM ] = ( byte ) ( ( n > > NUM ) & NUM ) ; bs [ NUM ] = ( byte ) ( ( n > > NUM ) & NUM ) ; bs [ NUM ] = ( byte ) ( ( n > > NUM ) & NUM ) ; bs [ NUM ] = ( byte ) ( ( n > > NUM ) & NUM ) ; bs [ NUM ] = ( byte ) ( n & NUM ) ; return bs ; }
final boolean try Write Lock ( ) { Thread current = Thread . current Thread ( ) ; int c = get State ( ) ; if ( c != NUM ) { int w = exclusive Count ( c ) ; if ( w == NUM || current != get Exclusive Owner Thread ( ) ) return BOOL ; if ( w == MAX COUNT ) throw new Error ( STRING ) ; } if ( ! compare And Set State ( c , c + NUM ) ) return BOOL ; set Exclusive Owner Thread ( current ) ; return BOOL ; }
public Io Service Listener Support ( Io Service service ) { if ( service == null ) { throw new Illegal Argument Exception ( STRING ) ; } this . service = service ; }
private void cancel Event Lease Do ( long event ID , Uuid lease ID ) throws Unknown Lease Exception { long now = System . current Time Millis ( ) ; Event Reg reg = ( Event Reg ) event By ID . get ( new Long ( event ID ) ) ; if ( reg == null || reg . lease Expiration <= now ) throw new Unknown Lease Exception ( ) ; delete Event ( reg ) ; if ( reg . lease Expiration == min Event Expiration ) concurrent Obj . waiter Notify ( event Notifier ) ; }
public static boolean is Valid G Day ( String value ) { String regex = STRING ; if ( value . matches ( regex ) ) { return is Valid Calendar Value ( value ) ; } else { return BOOL ; } }
protected void paint 3 D Rect Lighting ( Graphics 2 D g2 , int x , int y , int width , int height ) { g2 . set Color ( Color . white ) ; g2 . draw Line ( x + NUM , y + NUM , x + NUM , y + height - NUM ) ; g2 . draw Line ( x + NUM , y + NUM , x + width - NUM , y + NUM ) ; g2 . set Color ( Color . gray ) ; g2 . draw Line ( x + NUM , y + height - NUM , x + width - NUM , y + height - NUM ) ; g2 . draw Line ( x + width - NUM , y + NUM , x + width - NUM , y + height - NUM ) ; g2 . set Color ( Color . dark Gray ) ; g2 . draw Line ( x , y + height , x + width , y + height ) ; g2 . draw Line ( x + width , y , x + width , y + height ) ; }
private void parse Attributes ( Typed Array a ) { bar Width = ( int ) a . get Dimension ( R . styleable . Progress Wheel pw Bar Width , bar Width ) ; rim Width = ( int ) a . get Dimension ( R . styleable . Progress Wheel pw Rim Width , rim Width ) ; spin Speed = ( int ) a . get Dimension ( R . styleable . Progress Wheel pw Spin Speed , spin Speed ) ; bar Length = ( int ) a . get Dimension ( R . styleable . Progress Wheel pw Bar Length , bar Length ) ; delay Millis = a . get Integer ( R . styleable . Progress Wheel pw Delay Millis , delay Millis ) ; if ( delay Millis < NUM ) { delay Millis = NUM ; } if ( a . has Value ( R . styleable . Progress Wheel pw Text ) ) { set Text ( a . get String ( R . styleable . Progress Wheel pw Text ) ) ; } bar Color = a . get Color ( R . styleable . Progress Wheel pw Bar Color , bar Color ) ; text Color = a . get Color ( R . styleable . Progress Wheel pw Text Color , text Color ) ; rim Color = a . get Color ( R . styleable . Progress Wheel pw Rim Color , rim Color ) ; circle Color = a . get Color ( R . styleable . Progress Wheel pw Circle Color , circle Color ) ; contour Color = a . get Color ( R . styleable . Progress Wheel pw Contour Color , contour Color ) ; text Size = ( int ) a . get Dimension ( R . styleable . Progress Wheel pw Text Size , text Size ) ; contour Size = a . get Dimension ( R . styleable . Progress Wheel pw Contour Size , contour Size ) ; a . recycle ( ) ; }
@ Deprecated public Media File ( File f , Media File Type type ) { this ( f . to Path ( ) , type ) ; }
public Command Line clear ( ) { line . clear ( ) ; return this ; }
public static String grep Minus V ( String val , String pattern ) { return grep Inner ( val , pattern , BOOL ) ; }
public Drop Down Popup Button Builder add ( Action action ) { popup Menu . add ( action ) ; return this ; }
@ Suppress Lint ( STRING ) private void attach Image Fromm Gallery ( ) { Bundle con Data = new Bundle ( ) ; Intent intent = new Intent ( ) ; if ( ( m Selected Gallery Items List . size ( ) == NUM ) || ( Build . VERSION . SDK INT < Build . VERSION CODES . JELLY BEAN MR 2 ) ) { intent . set Data ( m Selected Gallery Items List . get ( NUM ) . m File Uri ) ; } else if ( m Selected Gallery Items List . size ( ) > NUM ) { Clip Data . Item first Uri = new Clip Data . Item ( null , null , null , m Selected Gallery Items List . get ( NUM ) . m File Uri ) ; String [ ] mime Type = { STRING } ; Clip Data clip Data = new Clip Data ( STRING , mime Type , first Uri ) ; for ( int index = NUM ; index < m Selected Gallery Items List . size ( ) ; index ++ ) { Clip Data . Item item = new Clip Data . Item ( null , null , null , m Selected Gallery Items List . get ( index ) . m File Uri ) ; clip Data . add Item ( item ) ; } intent . set Clip Data ( clip Data ) ; } else { Uri uri Saved From Life Cycle = ( Uri ) m Image Preview Image View . get Tag ( ) ; if ( null != uri Saved From Life Cycle ) { intent . set Data ( uri Saved From Life Cycle ) ; } } intent . put Extras ( con Data ) ; set Result ( RESULT OK , intent ) ; Vector App . set Saved Camera Image Preview ( null ) ; finish ( ) ; }
public static void mkdirs ( File directory ) throws Create Directory Exception { if ( directory . exists ( ) ) { if ( directory . is Directory ( ) ) { return ; } if ( ! directory . delete ( ) ) { throw new Create Directory Exception ( directory . get Absolute Path ( ) , new File Delete Exception ( directory . get Absolute Path ( ) ) ) ; } } if ( ! directory . mkdirs ( ) && ! directory . is Directory ( ) ) { throw new Create Directory Exception ( directory . get Absolute Path ( ) ) ; } }
public boolean has Dependency ( Capability c ) { if ( do Not Check Capabilities ( ) ) { return BOOL ; } return m Dependencies . contains ( c ) ; }
private static int prefix Len ( String o1 , String o2 ) { final int l1 = o1 . length ( ) , l2 = o2 . length ( ) , l = l1 < l2 ? l1 : l2 ; int prefix = NUM ; while ( prefix < l && ( o1 . char At ( prefix ) == o2 . char At ( prefix ) ) ) { prefix ++ ; } return prefix ; }
@ Override public void write External ( Object Output out ) throws IO Exception { super . write External ( out ) ; out . write Double ( parent Distance ) ; }
static int should Natively Focus Heavyweight ( Component heavyweight , Component descendant , boolean temporary , boolean focused Window Change Allowed , long time , Caused Focus Event . Cause cause ) { if ( log . is Loggable ( Platform Logger . Level . FINE ) ) { if ( heavyweight == null ) { log . fine ( STRING ) ; } if ( time == NUM ) { log . fine ( STRING ) ; } } if ( descendant == null ) { descendant = heavyweight ; } Keyboard Focus Manager manager = get Current Keyboard Focus Manager ( Sun Toolkit . target To App Context ( descendant ) ) ; Keyboard Focus Manager this Manager = get Current Keyboard Focus Manager ( ) ; Component current Focus Owner = this Manager . get Global Focus Owner ( ) ; Component native Focus Owner = this Manager . get Native Focus Owner ( ) ; Window native Focused Window = this Manager . get Native Focused Window ( ) ; if ( focus Log . is Loggable ( Platform Logger . Level . FINER ) ) { focus Log . finer ( STRING , String . value Of ( descendant ) , String . value Of ( heavyweight ) ) ; } if ( focus Log . is Loggable ( Platform Logger . Level . FINEST ) ) { focus Log . finest ( STRING , String . value Of ( current Focus Owner ) ) ; focus Log . finest ( STRING , String . value Of ( native Focus Owner ) ) ; focus Log . finest ( STRING , String . value Of ( native Focused Window ) ) ; } synchronized ( heavyweight Requests ) { Heavyweight Focus Request hw Focus Request = get Last HW Request ( ) ; if ( focus Log . is Loggable ( Platform Logger . Level . FINEST ) ) { focus Log . finest ( STRING , String . value Of ( hw Focus Request ) ) ; } if ( hw Focus Request == null && heavyweight == native Focus Owner && heavyweight . get Containing Window ( ) == native Focused Window ) { if ( descendant == current Focus Owner ) { if ( focus Log . is Loggable ( Platform Logger . Level . FINEST ) ) focus Log . finest ( STRING , String . value Of ( descendant ) ) ; return SNFH FAILURE ; } manager . enqueue Key Events ( time , descendant ) ; hw Focus Request = new Heavyweight Focus Request ( heavyweight , descendant , temporary , cause ) ; heavyweight Requests . add ( hw Focus Request ) ; if ( current Focus Owner != null ) { Focus Event current Focus Owner Event = new Caused Focus Event ( current Focus Owner , Focus Event . FOCUS LOST , temporary , descendant , cause ) ; Sun Toolkit . post Event ( current Focus Owner . app Context , current Focus Owner Event ) ; } Focus Event new Focus Owner Event = new Caused Focus Event ( descendant , Focus Event . FOCUS GAINED , temporary , current Focus Owner , cause ) ; Sun Toolkit . post Event ( descendant . app Context , new Focus Owner Event ) ; if ( focus Log . is Loggable ( Platform Logger . Level . FINEST ) ) focus Log . finest ( STRING , String . value Of ( descendant ) ) ; return SNFH SUCCESS HANDLED ; } else if ( hw Focus Request != null && hw Focus Request . heavyweight == heavyweight ) { if ( hw Focus Request . add Lightweight Request ( descendant , temporary , cause ) ) { manager . enqueue Key Events ( time , descendant ) ; } if ( focus Log . is Loggable ( Platform Logger . Level . FINEST ) ) { focus Log . finest ( STRING + descendant + STRING + heavyweight ) ; } return SNFH SUCCESS HANDLED ; } else { if ( ! focused Window Change Allowed ) { if ( hw Focus Request == Heavyweight Focus Request . CLEAR GLOBAL FOCUS OWNER ) { int size = heavyweight Requests . size ( ) ; hw Focus Request = ( Heavyweight Focus Request ) ( ( size >= NUM ) ? heavyweight Requests . get ( size - NUM ) : null ) ; } if ( focused Window Changed ( heavyweight , ( hw Focus Request != null ) ? hw Focus Request . heavyweight : native Focused Window ) ) { if ( focus Log . is Loggable ( Platform Logger . Level . FINEST ) ) { focus Log . finest ( STRING + descendant ) ; } return SNFH FAILURE ; } } manager . enqueue Key Events ( time , descendant ) ; heavyweight Requests . add ( new Heavyweight Focus Request ( heavyweight , descendant , temporary , cause ) ) ; if ( focus Log . is Loggable ( Platform Logger . Level . FINEST ) ) { focus Log . finest ( STRING + descendant ) ; } return SNFH SUCCESS PROCEED ; } } }
public Named Thread Factory ( final String pool ID ) { id = pool ID ; }
public void move Location Up ( Route Location rl ) { int sequence Id = rl . get Sequence Id ( ) ; if ( sequence Id - NUM <= NUM ) { rl . set Sequence Id ( sequence Num + NUM ) ; resequence Ids ( ) ; } else { Route Location replace Rl = get Item By Sequence Id ( sequence Id - NUM ) ; if ( replace Rl != null ) { replace Rl . set Sequence Id ( sequence Id ) ; rl . set Sequence Id ( sequence Id - NUM ) ; } else { resequence Ids ( ) ; } } set Dirty And Fire Property Change ( LISTCHANGE CHANGED PROPERTY , null , Integer . to String ( sequence Id ) ) ; }
protected Attribute generate Attribute ( int index , int att Type , String name Prefix ) throws Exception { Attribute result ; String name ; int val Index ; int nom Count ; String prefix ; result = null ; if ( index == CLASS IS LAST ) { val Index = NUM ; name = STRING ; prefix = STRING ; nom Count = get Num Classes ( ) ; } else { val Index = index ; nom Count = get Num Nominal Values ( ) ; prefix = STRING + ( val Index + NUM ) + STRING ; switch ( att Type ) { case Attribute . NOMINAL : name = STRING + ( val Index + NUM ) ; break ; case Attribute . NUMERIC : name = STRING + ( val Index + NUM ) ; break ; case Attribute . STRING : name = STRING + ( val Index + NUM ) ; break ; case Attribute . DATE : name = STRING + ( val Index + NUM ) ; break ; case Attribute . RELATIONAL : name = STRING + ( val Index + NUM ) ; break ; default : throw new Illegal Argument Exception ( STRING + att Type + STRING ) ; } } switch ( att Type ) { case Attribute . NOMINAL : Array List < String > nom Strings = new Array List < String > ( val Index + NUM ) ; for ( int j = NUM ; j < nom Count ; j ++ ) { nom Strings . add ( prefix + ( j + NUM ) ) ; } result = new Attribute ( name Prefix + name , nom Strings ) ; break ; case Attribute . NUMERIC : result = new Attribute ( name Prefix + name ) ; break ; case Attribute . STRING : result = new Attribute ( name Prefix + name , ( Array List < String > ) null ) ; break ; case Attribute . DATE : result = new Attribute ( name Prefix + name , STRING ) ; break ; case Attribute . RELATIONAL : Instances rel ; if ( index == CLASS IS LAST ) { rel = get Relational Class Format ( ) ; } else { rel = get Relational Format ( index ) ; } if ( rel == null ) { Test Instances dataset = new Test Instances ( ) ; dataset . set Num Nominal ( get Num Relational Nominal ( ) ) ; dataset . set Num Nominal Values ( get Num Relational Nominal Values ( ) ) ; dataset . set Num Numeric ( get Num Relational Numeric ( ) ) ; dataset . set Num String ( get Num Relational String ( ) ) ; dataset . set Num Date ( get Num Relational Date ( ) ) ; dataset . set Num Instances ( NUM ) ; dataset . set Class Type ( Attribute . NOMINAL ) ; rel = new Instances ( dataset . generate ( ) ) ; if ( ! get No Class ( ) ) { int cls Index = rel . class Index ( ) ; rel . set Class Index ( - NUM ) ; rel . delete Attribute At ( cls Index ) ; } } result = new Attribute ( name Prefix + name , rel ) ; break ; default : throw new Illegal Argument Exception ( STRING + att Type + STRING ) ; } return result ; }
public static String print Canopy Assignments ( Instances data Points , List < long [ ] > canopy Assignments ) { String Builder temp = new String Builder ( ) ; for ( int i = NUM ; i < data Points . size ( ) ; i ++ ) { temp . append ( STRING + i + STRING ) ; temp . append ( data Points . instance ( i ) ) ; if ( canopy Assignments != null && canopy Assignments . size ( ) == data Points . size ( ) ) { long [ ] assignments = canopy Assignments . get ( i ) ; temp . append ( print Single Assignment ( assignments ) ) ; } temp . append ( STRING ) ; } return temp . to String ( ) ; }
public static void register Default Prefixes ( ) throws XML Security Exception { set Default Prefix ( STRING , STRING ) ; set Default Prefix ( STRING , STRING ) ; set Default Prefix ( STRING , STRING ) ; set Default Prefix ( STRING , STRING ) ; set Default Prefix ( STRING , STRING ) ; set Default Prefix ( STRING , STRING ) ; set Default Prefix ( STRING , STRING ) ; set Default Prefix ( STRING , STRING ) ; }
protected void init BP Order Details ( int C B Partner ID , boolean for Invoice ) { log . config ( STRING + C B Partner ID ) ; Key Name Pair pp = new Key Name Pair ( NUM , STRING ) ; order Field . remove Action Listener ( this ) ; order Field . remove All Items ( ) ; order Field . add Item ( pp ) ; Array List < Key Name Pair > list = load Order Data ( C B Partner ID , for Invoice , BOOL ) ; for ( Key Name Pair knp : list ) order Field . add Item ( knp ) ; order Field . set Selected Index ( NUM ) ; order Field . add Action Listener ( this ) ; dialog . pack ( ) ; init BP Details ( C B Partner ID ) ; }
private void write Toc ( Byte Buffer data File Buffer , Toc Type toc Type , int entry Count , int first Entry Offset ) { data File Buffer . put Int ( toc Type . identifier ) ; data File Buffer . put Int ( entry Count ) ; data File Buffer . put Long ( first Entry Offset ) ; }
public void start Part ( String content Type , String [ ] headers ) throws IO Exception { write Current Boundary ( ) ; if ( content Type != null ) { write String ( Mime Utils . HEADER CONTENT TYPE + STRING + content Type ) ; out . write ( CRLF ) ; } for ( int i = NUM ; headers != null && i < headers . length ; i ++ ) { write String ( headers [ i ] ) ; out . write ( CRLF ) ; } out . write ( CRLF ) ; }
public Embedded Meta Service ( ) throws IO Exception , Execution Exception { this ( System . getenv ( JOLIE HOME ENV ) ) ; }
public int show Dialog ( ) { m Result = CANCEL OPTION ; int [ ] orig Selected = m List . get Selected Indices ( ) ; set Visible ( BOOL ) ; if ( m Result == CANCEL OPTION ) { m List . set Selected Indices ( orig Selected ) ; } return m Result ; }
public final void add Alarm Values ( final List < Alarm Value Impl > alarm Values ) { if ( alarm Values != null ) { for ( Alarm Value Impl alarm Value : alarm Values ) { if ( alarm Value != null ) { add Alarm Value ( alarm Value ) ; } } } }
public String product ( Properties ctx , int Window No , Grid Tab m Tab , Grid Field m Field , Object value ) { Integer M Product ID = ( Integer ) value ; if ( M Product ID == null || M Product ID . int Value ( ) == NUM ) return STRING ; if ( Env . get Context As Int ( ctx , Window No , Env . TAB INFO , STRING ) == M Product ID . int Value ( ) && Env . get Context As Int ( ctx , Window No , Env . TAB INFO , STRING ) != NUM ) m Tab . set Value ( STRING , Env . get Context As Int ( ctx , Window No , Env . TAB INFO , STRING ) ) ; else m Tab . set Value ( STRING , null ) ; check Qty Available ( ctx , m Tab , Window No , M Product ID , null ) ; return STRING ; }
protected void processpacket ( Sim Event ev ) { Cloud Sim . cancel All ( get Id ( ) , new Predicate Type ( Cloud Sim Tags . Network Event UP ) ) ; schedule ( get Id ( ) , switching delay , Cloud Sim Tags . Network Event UP ) ; pktlist . add ( ( Network Packet ) ev . get Data ( ) ) ; }
public void add Child ( Controller controller ) { if ( children == null ) children = new Array List < Controller > ( ) ; children . add ( controller ) ; controller . parent = this ; }
protected boolean check Turnouts In Section ( Section s , int seq Num , Section next Section , Active Train at , Layout Editor le , Section prev Section ) { return turnout Util ( s , seq Num , next Section , at , le , BOOL , BOOL , prev Section ) ; }
private Point 2 D calculate Label Anchor Point ( Item Label Anchor anchor , Rectangle 2 D bar , Plot Orientation orientation ) { Point 2 D result = null ; double offset = get Item Label Anchor Offset ( ) ; double x0 = bar . get X ( ) - offset ; double x1 = bar . get X ( ) ; double x2 = bar . get X ( ) + offset ; double x3 = bar . get Center X ( ) ; double x4 = bar . get Max X ( ) - offset ; double x5 = bar . get Max X ( ) ; double x6 = bar . get Max X ( ) + offset ; double y0 = bar . get Max Y ( ) + offset ; double y1 = bar . get Max Y ( ) ; double y2 = bar . get Max Y ( ) - offset ; double y3 = bar . get Center Y ( ) ; double y4 = bar . get Min Y ( ) + offset ; double y5 = bar . get Min Y ( ) ; double y6 = bar . get Min Y ( ) - offset ; if ( anchor == Item Label Anchor . CENTER ) { result = new Point 2 D . Double ( x3 , y3 ) ; } else if ( anchor == Item Label Anchor . INSIDE 1 ) { result = new Point 2 D . Double ( x4 , y4 ) ; } else if ( anchor == Item Label Anchor . INSIDE 2 ) { result = new Point 2 D . Double ( x4 , y4 ) ; } else if ( anchor == Item Label Anchor . INSIDE 3 ) { result = new Point 2 D . Double ( x4 , y3 ) ; } else if ( anchor == Item Label Anchor . INSIDE 4 ) { result = new Point 2 D . Double ( x4 , y2 ) ; } else if ( anchor == Item Label Anchor . INSIDE 5 ) { result = new Point 2 D . Double ( x4 , y2 ) ; } else if ( anchor == Item Label Anchor . INSIDE 6 ) { result = new Point 2 D . Double ( x3 , y2 ) ; } else if ( anchor == Item Label Anchor . INSIDE 7 ) { result = new Point 2 D . Double ( x2 , y2 ) ; } else if ( anchor == Item Label Anchor . INSIDE 8 ) { result = new Point 2 D . Double ( x2 , y2 ) ; } else if ( anchor == Item Label Anchor . INSIDE 9 ) { result = new Point 2 D . Double ( x2 , y3 ) ; } else if ( anchor == Item Label Anchor . INSIDE 10 ) { result = new Point 2 D . Double ( x2 , y4 ) ; } else if ( anchor == Item Label Anchor . INSIDE 11 ) { result = new Point 2 D . Double ( x2 , y4 ) ; } else if ( anchor == Item Label Anchor . INSIDE 12 ) { result = new Point 2 D . Double ( x3 , y4 ) ; } else if ( anchor == Item Label Anchor . OUTSIDE 1 ) { result = new Point 2 D . Double ( x5 , y6 ) ; } else if ( anchor == Item Label Anchor . OUTSIDE 2 ) { result = new Point 2 D . Double ( x6 , y5 ) ; } else if ( anchor == Item Label Anchor . OUTSIDE 3 ) { result = new Point 2 D . Double ( x6 , y3 ) ; } else if ( anchor == Item Label Anchor . OUTSIDE 4 ) { result = new Point 2 D . Double ( x6 , y1 ) ; } else if ( anchor == Item Label Anchor . OUTSIDE 5 ) { result = new Point 2 D . Double ( x5 , y0 ) ; } else if ( anchor == Item Label Anchor . OUTSIDE 6 ) { result = new Point 2 D . Double ( x3 , y0 ) ; } else if ( anchor == Item Label Anchor . OUTSIDE 7 ) { result = new Point 2 D . Double ( x1 , y0 ) ; } else if ( anchor == Item Label Anchor . OUTSIDE 8 ) { result = new Point 2 D . Double ( x0 , y1 ) ; } else if ( anchor == Item Label Anchor . OUTSIDE 9 ) { result = new Point 2 D . Double ( x0 , y3 ) ; } else if ( anchor == Item Label Anchor . OUTSIDE 10 ) { result = new Point 2 D . Double ( x0 , y5 ) ; } else if ( anchor == Item Label Anchor . OUTSIDE 11 ) { result = new Point 2 D . Double ( x1 , y6 ) ; } else if ( anchor == Item Label Anchor . OUTSIDE 12 ) { result = new Point 2 D . Double ( x3 , y6 ) ; } return result ; }
public static String read Fully ( Reader reader ) throws IO Exception { try { String Writer writer = new String Writer ( ) ; char [ ] buffer = new char [ NUM ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM ) { writer . write ( buffer , NUM , count ) ; } return writer . to String ( ) ; } finally { reader . close ( ) ; } }
protected String instance To Matlab ( Instance inst ) { String Buffer result ; int i ; result = new String Buffer ( ) ; for ( i = NUM ; i < inst . num Attributes ( ) ; i ++ ) { if ( i > NUM ) { result . append ( ( m Use Tabs ? STRING : STRING ) ) ; } result . append ( m Format . format ( inst . value ( i ) ) ) ; } return result . to String ( ) ; }
private static double distance ( Problem problem , Solution a , Solution b , double power ) { double distance = NUM ; for ( int i = NUM ; i < problem . get Number Of Objectives ( ) ; i ++ ) { distance += Math . pow ( Math . abs ( a . get Objective ( i ) - b . get Objective ( i ) ) , power ) ; } return Math . pow ( distance , NUM / power ) ; }
private List < Token Type > extract String Literal Delimiting Tokens ( String [ ] tokens ) { List < Token Type > delimiting Tokens = new Array List < Token Type > ( ) ; for ( String token : tokens ) { String clean Token = clean Token ( token ) ; boolean handled = BOOL ; if ( alternate Quote == null ) { String alternate Quote From Token = extract Alternate Open Quote ( clean Token ) ; if ( alternate Quote From Token != null ) { String close Quote = compute Alternate Close Quote ( alternate Quote From Token ) ; if ( clean Token . length ( ) >= ( alternate Quote From Token . length ( ) + close Quote . length ( ) ) && clean Token . starts With ( alternate Quote From Token ) && clean Token . ends With ( close Quote ) ) { continue ; } alternate Quote = close Quote ; delimiting Tokens . add ( Token Type . ALTERNATE QUOTE ) ; continue ; } } if ( ( alternate Quote != null ) && clean Token . ends With ( alternate Quote ) ) { alternate Quote = null ; delimiting Tokens . add ( Token Type . ALTERNATE QUOTE ) ; continue ; } if ( ( clean Token . length ( ) >= NUM ) && clean Token . starts With ( STRING ) && clean Token . ends With ( STRING ) ) { continue ; } if ( ( clean Token . length ( ) >= NUM ) && clean Token . starts With ( STRING ) && clean Token . ends With ( STRING ) ) { continue ; } if ( is Single Line Comment ( clean Token ) ) { delimiting Tokens . add ( Token Type . SINGLE LINE COMMENT ) ; handled = BOOL ; } if ( clean Token . starts With ( STRING ) ) { delimiting Tokens . add ( Token Type . MULTI LINE COMMENT ) ; handled = BOOL ; } else if ( clean Token . starts With ( STRING ) ) { delimiting Tokens . add ( Token Type . QUOTE ) ; handled = BOOL ; } if ( ! clean Token . starts With ( STRING ) && clean Token . ends With ( STRING ) ) { delimiting Tokens . add ( Token Type . MULTI LINE COMMENT ) ; handled = BOOL ; } else if ( ! clean Token . starts With ( STRING ) && clean Token . ends With ( STRING ) ) { delimiting Tokens . add ( Token Type . QUOTE ) ; handled = BOOL ; } if ( ! handled ) { delimiting Tokens . add ( Token Type . OTHER ) ; } } return delimiting Tokens ; }
private void print Rainbow User ( User user , String user Name , boolean action , Special Color type , String id ) { Simple Attribute Set user Style = new Simple Attribute Set ( styles . nick ( ) ) ; user Style . add Attribute ( Attribute . IS USER MESSAGE , BOOL ) ; user Style . add Attribute ( Attribute . USER , user ) ; if ( id != null ) { user Style . add Attribute ( Attribute . ID , id ) ; } int length = user Name . length ( ) ; if ( action ) { print ( STRING , styles . nick ( ) ) ; } for ( int i = NUM ; i < length ; i ++ ) { Color c ; if ( type == Special Color . RAINBOW ) { c = make Rainbow Color ( i , length ) ; } else { c = make Gold Color ( i , length ) ; } Style Constants . set Foreground ( user Style , c ) ; print ( user Name . substring ( i , i + NUM ) , user Style ) ; } }
public void notify Address Throttle Found ( Dcc Throttle t ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } m Throttle = t ; set Enabled ( BOOL ) ; m Throttle . add Property Change Listener ( this ) ; set Fn Buttons ( ) ; }
public static void matrix Mult W Div MM ( Matrix Block mW , Matrix Block mU , Matrix Block mV , Matrix Block mX , Matrix Block ret , W Div MM Type wt , int k ) throws DML Runtime Exception { if ( mW . is Empty Block ( BOOL ) || ( wt . is Left ( ) && mU . is Empty Block ( BOOL ) ) || ( wt . is Right ( ) && mV . is Empty Block ( BOOL ) ) || ( wt . is Basic ( ) && mW . is Empty Block ( BOOL ) ) ) { ret . exam Sparsity ( ) ; return ; } ret . sparse = wt . is Basic ( ) ? mW . sparse : BOOL ; ret . allocate Dense Or Sparse Block ( ) ; if ( ! ret . is Thread Safe ( ) ) { matrix Mult W Div MM ( mW , mU , mV , mX , ret , wt ) ; return ; } try { Executor Service pool = Executors . new Fixed Thread Pool ( k ) ; Array List < Matrix Mult W Div Task > tasks = new Array List < Matrix Mult W Div Task > ( ) ; if ( wt . is Left ( ) ) { int blklen = ( int ) ( Math . ceil ( ( double ) mW . clen / k ) ) ; for ( int j = NUM ; j < k & j * blklen < mW . clen ; j ++ ) tasks . add ( new Matrix Mult W Div Task ( mW , mU , mV , mX , ret , wt , NUM , mW . rlen , j * blklen , Math . min ( ( j + NUM ) * blklen , mW . clen ) ) ) ; } else { int blklen = ( int ) ( Math . ceil ( ( double ) mW . rlen / k ) ) ; for ( int i = NUM ; i < k & i * blklen < mW . rlen ; i ++ ) tasks . add ( new Matrix Mult W Div Task ( mW , mU , mV , mX , ret , wt , i * blklen , Math . min ( ( i + NUM ) * blklen , mW . rlen ) , NUM , mW . clen ) ) ; } List < Future < Long > > taskret = pool . invoke All ( tasks ) ; pool . shutdown ( ) ; ret . non Zeros = NUM ; for ( Future < Long > task : taskret ) ret . non Zeros += task . get ( ) ; } catch ( Exception e ) { throw new DML Runtime Exception ( e ) ; } ret . exam Sparsity ( ) ; }
public boolean verify ( ) throws Missing Resource Failure Exception , XML Security Exception { return super . verify References ( BOOL ) ; }
public Open Id Prompt ( String prompt ) { original Value = prompt ; if ( is Empty ( prompt ) ) { prompts = Collections . empty Set ( ) ; } else { prompts = string To Set ( prompt . to Lower Case ( ) ) ; } }
private static boolean calculate Is Failure ( ) { int random Value = random . next Int ( NUM ) + NUM ; return random Value <= ERROR PCT ; }
private int check User Link ( Spannable String Builder out , String in , int start ) { int pos = start + NUM ; String Builder temp = new String Builder ( ) ; String target String = in . substring ( pos , Math . min ( in . length ( ) , pos + NUM ) ) ; for ( int i = NUM ; i < target String . length ( ) ; i ++ ) { char c = target String . char At ( i ) ; if ( ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || c == STRING ) { temp . append ( c ) ; } else { break ; } } String username = temp . to String ( ) ; if ( username . length ( ) < NUM || username . equals Ignore Case ( STRING ) ) { return - NUM ; } out . append ( username ) ; return pos + username . length ( ) - NUM ; }
public void clear ( ) { m Array List . clear ( ) ; }
public void test common Test 01 ( ) { SSL Context Spi Impl ssl = new SSL Context Spi Impl ( ) ; try { SSL Session Context slsc = ssl . engine Get Client Session Context ( ) ; fail ( STRING ) ; } catch ( Runtime Exception re ) { String str = re . get Message ( ) ; if ( ! str . equals ( STRING ) ) fail ( STRING + str ) ; } catch ( Exception e ) { fail ( STRING + e + STRING ) ; } try { SSL Session Context slsc = ssl . engine Get Server Session Context ( ) ; fail ( STRING ) ; } catch ( Runtime Exception re ) { String str = re . get Message ( ) ; if ( ! str . equals ( STRING ) ) fail ( STRING + str ) ; } catch ( Exception e ) { fail ( STRING + e + STRING ) ; } try { SSL Server Socket Factory sssf = ssl . engine Get Server Socket Factory ( ) ; fail ( STRING ) ; } catch ( Runtime Exception re ) { String str = re . get Message ( ) ; if ( ! str . equals ( STRING ) ) fail ( STRING + str ) ; } catch ( Exception e ) { fail ( STRING + e + STRING ) ; } try { SSL Socket Factory ssf = ssl . engine Get Socket Factory ( ) ; fail ( STRING ) ; } catch ( Runtime Exception re ) { String str = re . get Message ( ) ; if ( ! str . equals ( STRING ) ) fail ( STRING + str ) ; } catch ( Exception e ) { fail ( STRING + e + STRING ) ; } }
public static Class Descriptor create Class Descriptor From Resource Name ( String resource Name ) { if ( ! is Class Resource ( resource Name ) ) { throw new Illegal Argument Exception ( STRING + resource Name + STRING ) ; } return create Class Descriptor ( resource Name . substring ( NUM , resource Name . length ( ) - NUM ) ) ; }
public static void show ( final Window parent , final String content ) { final C Log File Dialog dialog = new C Log File Dialog ( parent , content ) ; Gui Helper . center Child To Parent ( parent , dialog , BOOL ) ; dialog . set Visible ( BOOL ) ; }
protected void end Node ( Node node ) throws org . xml . sax . SAX Exception { switch ( node . get Node Type ( ) ) { case Node . DOCUMENT NODE : break ; case Node . DOCUMENT TYPE NODE : serialize Doc Type ( ( Document Type ) node , BOOL ) ; break ; case Node . ELEMENT NODE : serialize Element ( ( Element ) node , BOOL ) ; break ; case Node . CDATA SECTION NODE : break ; case Node . ENTITY REFERENCE NODE : serialize Entity Reference ( ( Entity Reference ) node , BOOL ) ; break ; default : } }
public Create Window Clause add View ( String namespace , String name ) { views . add ( View . create ( namespace , name ) ) ; return this ; }
public int size ( ) { return set . size ( ) ; }
public void associate Connection ( Object connection ) throws Resource Exception { if ( ! connection Sharing ) disassociate Connections ( ) ; try { final FB Connection abstract Connection = ( FB Connection ) connection ; abstract Connection . set Managed Connection ( this ) ; connection Handles . add ( abstract Connection ) ; } catch ( Class Cast Exception cce ) { throw new FB Resource Exception ( STRING , cce ) ; } }
Chrono Local Date Time < D > to Local Date Time ( ) ;
private void save ( ) { try { File Utils . write ( new File ( jar Name + STRING ) , text ) ; } catch ( IO Exception e ) { J Option Pane . show Message Dialog ( null , e . get Message ( ) , STRING , J Option Pane . ERROR MESSAGE ) ; } }
private static void assert Not Empty ( String message , String string ) { assert Not Null ( message , string ) ; assert False ( message , string . equals ( STRING ) ) ; }
private void generate Entity Config ( Managed Entity Config config ) throws SAX Exception { String host = config . get Host ( ) ; if ( host != null ) { handler . start Element ( STRING , HOST , HOST , EMPTY ) ; handler . characters ( host . to Char Array ( ) , NUM , host . length ( ) ) ; handler . end Element ( STRING , HOST , HOST ) ; } String remote Command = config . get Remote Command ( ) ; if ( remote Command != null ) { handler . start Element ( STRING , REMOTE COMMAND , REMOTE COMMAND , EMPTY ) ; handler . characters ( remote Command . to Char Array ( ) , NUM , remote Command . length ( ) ) ; handler . end Element ( STRING , REMOTE COMMAND , REMOTE COMMAND ) ; } String working Directory = config . get Working Directory ( ) ; if ( working Directory != null ) { handler . start Element ( STRING , WORKING DIRECTORY , WORKING DIRECTORY , EMPTY ) ; handler . characters ( working Directory . to Char Array ( ) , NUM , working Directory . length ( ) ) ; handler . end Element ( STRING , WORKING DIRECTORY , WORKING DIRECTORY ) ; } String product Directory = config . get Product Directory ( ) ; if ( product Directory != null ) { handler . start Element ( STRING , PRODUCT DIRECTORY , PRODUCT DIRECTORY , EMPTY ) ; handler . characters ( product Directory . to Char Array ( ) , NUM , product Directory . length ( ) ) ; handler . end Element ( STRING , PRODUCT DIRECTORY , PRODUCT DIRECTORY ) ; } }
public void hilite Label ( Node v , Node Data data ) { Node View nv = viewer . get NV ( v ) ; if ( nv . get Location ( ) == null ) return ; Point apt = nv . get Label Position ( viewer . trans ) ; if ( apt == null ) return ; gc . set Color ( Program Properties . SELECTION COLOR ADDITIONAL TEXT ) ; if ( ! nv . get Label Visible ( ) && nv . get Label ( ) != null ) { gc . set Font ( nv . get Font ( ) ) ; gc . draw String ( nv . get Label ( ) , apt . x , apt . y ) ; } if ( data . get Summarized ( ) . length > NUM || ( data . get Summarized ( ) . length == NUM && data . get Summarized ( ) [ NUM ] > NUM ) ) { gc . set Font ( selection Font ) ; String Builder buf = new String Builder ( ) ; if ( data . get Count Assigned ( ) > NUM ) { buf . append ( STRING ) ; for ( int value : data . get Assigned ( ) ) { buf . append ( String . format ( STRING , value ) ) ; } gc . draw String ( buf . to String ( ) , apt . x , apt . y += NUM ) ; } buf = new String Builder ( ) ; buf . append ( STRING ) ; for ( int value : data . get Summarized ( ) ) { buf . append ( String . format ( STRING , value ) ) ; } gc . draw String ( buf . to String ( ) , apt . x , apt . y += NUM ) ; } if ( data . get Up P Value ( ) != - NUM ) { gc . draw String ( STRING + ( float ) data . get Up P Value ( ) , apt . x , apt . y += NUM ) ; } if ( data . get Down P Value ( ) != - NUM ) { gc . draw String ( STRING + ( float ) data . get Down P Value ( ) , apt . x , apt . y += NUM ) ; } }
public void append Line ( Char Sequence line ) { lines . add ( line ) ; }
public void flag Action Items ( ) { if ( ! m Is Action Items Stale ) { return ; } boolean flagged = BOOL ; for ( Weak Reference < Menu Presenter > ref : m Presenters ) { final Menu Presenter presenter = ref . get ( ) ; if ( presenter == null ) { m Presenters . remove ( ref ) ; } else { flagged |= presenter . flag Action Items ( ) ; } } if ( flagged ) { m Action Items . clear ( ) ; m Non Action Items . clear ( ) ; Array List < Menu Item Impl > visible Items = get Visible Items ( ) ; final int items Size = visible Items . size ( ) ; for ( int i = NUM ; i < items Size ; i ++ ) { Menu Item Impl item = visible Items . get ( i ) ; if ( item . is Action Button ( ) ) { m Action Items . add ( item ) ; } else { m Non Action Items . add ( item ) ; } } } else { m Action Items . clear ( ) ; m Non Action Items . clear ( ) ; m Non Action Items . add All ( get Visible Items ( ) ) ; } m Is Action Items Stale = BOOL ; }
public static void register New Aggregation Function ( String name , Class < ? extends Aggregation Function > clazz , Aggregation Function Meta Data Provider meta Data Provider ) { AGGREATION FUNCTIONS . put ( name , clazz ) ; AGGREGATION FUNCTIONS META DATA PROVIDER . put ( name , meta Data Provider ) ; }
private byte [ ] build File Auth Tag ( ) throws File Encryption Exception { Secret Key key = back Enc Random Access File . share Key ; if ( key == null || key . get Encoded ( ) . length == NUM ) { throw new File Encryption Exception ( STRING ) ; } else { auth Tag H Mac . reset ( ) ; Key Parameter key Parameter = new Key Parameter ( key . get Encoded ( ) ) ; auth Tag H Mac . init ( key Parameter ) ; } if ( atag List . size ( ) == NUM ) { throw new File Encryption Exception ( STRING ) ; } else { for ( int i = NUM ; i < atag List . size ( ) ; i ++ ) { byte [ ] cur Chunk Tag = atag List . get ( i ) ; if ( ( cur Chunk Tag == null ) || ( cur Chunk Tag . length != CHUNK AUTH TAG LENGTH ) ) { throw new File Encryption Exception ( STRING + i ) ; } else { auth Tag H Mac . update ( cur Chunk Tag , NUM , CHUNK AUTH TAG LENGTH ) ; } } byte [ ] tmp = new byte [ AUTH TAG SIZE ] ; auth Tag H Mac . do Final ( tmp , NUM ) ; return tmp ; } }
public int hash Code ( ) { return name . hash Code ( ) ; }
public void update Data ( Map Element map Element ) { name Label . set Text ( map Element . get Name ( ) ) ; pinned Check Box . set Selected ( map Element . is Pinned ( ) ) ; }
public int do Final ( byte [ ] out , int out Off ) throws Data Length Exception , Illegal State Exception , Invalid Cipher Text Exception { try { int result Len = NUM ; if ( out Off + buf Off > out . length ) { throw new Output Length Exception ( STRING ) ; } if ( buf Off != NUM ) { if ( ! partial Block Okay ) { throw new Data Length Exception ( STRING ) ; } cipher . process Block ( buf , NUM , buf , NUM ) ; result Len = buf Off ; buf Off = NUM ; System . arraycopy ( buf , NUM , out , out Off , result Len ) ; } return result Len ; } finally { reset ( ) ; } }
public Priority Queue ( int initial Capacity , Comparator < ? super E > comparator ) { if ( initial Capacity < NUM ) { throw new Illegal Argument Exception ( ) ; } elements = new Element Array ( initial Capacity ) ; this . comparator = comparator ; }
public void read Data ( Data Input input ) throws IO Exception { read Reference = input . read Unsigned Short ( ) ; read Count = input . read Unsigned Short ( ) ; write Reference = input . read Unsigned Short ( ) ; write Count = input . read Unsigned Short ( ) ; int byte Count = input . read Unsigned Byte ( ) ; if ( non Word Data Handler == null ) { byte buffer [ ] = new byte [ byte Count ] ; input . read Fully ( buffer , NUM , byte Count ) ; int offset = NUM ; registers = new Register [ write Count ] ; for ( int register = NUM ; register < write Count ; register ++ ) { registers [ register ] = new Simple Register ( buffer [ offset ] , buffer [ offset + NUM ] ) ; offset += NUM ; } } else { non Word Data Handler . read Data ( input , write Reference , write Count ) ; } }
private boolean is Touch Inside List ( Motion Event ev ) { float x = ev . get X ( ) - m List View . get X ( ) ; float y = ev . get Y ( ) - m List View . get Y ( ) ; if ( x < NUM || x > m List View . get Width ( ) || y < NUM || y > m List View . get Height ( ) ) { return BOOL ; } return BOOL ; }
public static final void center Child To Parent ( final Component parent , final Component child , final boolean b Stay On Screen ) { int x = ( parent . get X ( ) + ( parent . get Width ( ) / NUM ) ) - ( child . get Width ( ) / NUM ) ; int y = ( parent . get Y ( ) + ( parent . get Height ( ) / NUM ) ) - ( child . get Height ( ) / NUM ) ; if ( b Stay On Screen ) { final Toolkit tk = Toolkit . get Default Toolkit ( ) ; final Dimension ss = new Dimension ( tk . get Screen Size ( ) ) ; if ( ( x + child . get Width ( ) ) > ss . get Width ( ) ) { x = ( int ) ( ss . get Width ( ) - child . get Width ( ) ) ; } if ( ( y + child . get Height ( ) ) > ss . get Height ( ) ) { y = ( int ) ( ss . get Height ( ) - child . get Height ( ) ) ; } if ( x < NUM ) { x = NUM ; } if ( y < NUM ) { y = NUM ; } } child . set Location ( x , y ) ; }
public boolean is Connecting ( ) { return start != null && preview != null && preview . is Visible ( ) ; }
public Protected Properties ( Properties props ) { Enumeration < ? > prop Enum = props . property Names ( ) ; while ( prop Enum . has More Elements ( ) ) { String prop Name = ( String ) prop Enum . next Element ( ) ; String prop Value = props . get Property ( prop Name ) ; super . set Property ( prop Name , prop Value ) ; } closed = BOOL ; }
public boolean is Empty ( ) { return item List . is Empty ( ) ; }
private static void fix Numeric Byte Order ( byte [ ] bytes ) { for ( int i = NUM ; i < bytes . length ; i += NUM ) { Byte Util . swap 4 Bytes ( bytes , i ) ; } }
public synchronized boolean has Scope ( ) { return ! scope Stack . is Empty ( ) ; }
private boolean check Attribute Changed ( String existing , String current ) { if ( existing == null && current == null ) { return BOOL ; } if ( ( existing == null ) ^ ( current == null ) ) { return BOOL ; } return ( ! existing . equals Ignore Case ( current ) ) ; }
public boolean is Empty ( ) { return count ( ) == NUM ; }
@ Override public void add Table Model Listener ( Table Model Listener l ) { m Listeners . add ( l ) ; }
private static URL [ ] path To UR Ls ( String path ) throws Malformed URL Exception { synchronized ( path To UR Ls Cache ) { Object [ ] v = path To UR Ls Cache . get ( path ) ; if ( v != null ) { return ( ( URL [ ] ) v [ NUM ] ) ; } } String Tokenizer st = new String Tokenizer ( path ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; for ( int i = NUM ; st . has More Tokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . next Token ( ) ) ; } synchronized ( path To UR Ls Cache ) { path To UR Ls Cache . put ( path , new Object [ ] { urls , new Soft Reference < String > ( path ) } ) ; } return urls ; }
boolean perform Work ( Task Manager . Task who , Object param ) throws Job Exception { Integer tmp = null ; synchronized ( tasks ) { tmp = ( Integer ) tasks . get ( who ) ; } if ( tmp == null ) throw new Unknown Task Exception ( ) ; int rank = tmp . int Value ( ) ; synchronized ( attempts ) { attempts [ rank ] ++ ; } Object result = do Work ( who , param ) ; if ( result == null ) return BOOL ; try { report Done ( who , result ) ; } catch ( Unknown Task Exception e ) { } catch ( Partial Result Exception e ) { } catch ( Job Exception e ) { } return BOOL ; }
public List < Order > load All Deep From Cursor ( Cursor cursor ) { int count = cursor . get Count ( ) ; List < Order > list = new Array List < Order > ( count ) ; if ( cursor . move To First ( ) ) { if ( identity Scope != null ) { identity Scope . lock ( ) ; identity Scope . reserve Room ( count ) ; } try { do { list . add ( load Current Deep ( cursor , BOOL ) ) ; } while ( cursor . move To Next ( ) ) ; } finally { if ( identity Scope != null ) { identity Scope . unlock ( ) ; } } } return list ; }
public static boolean is Valid Auth Type ( String auth Type ) { log . debug ( STRING ) ; if ( auth Type != null ) { if ( ! auth Type . is Empty ( ) ) { if ( auth Type . equals Ignore Case ( Ldap Auth Base . LDAP AUTH TYPE SIMPLE ) ) return BOOL ; if ( auth Type . equals Ignore Case ( Ldap Auth Base . LDAP AUTH TYPE NONE ) ) return BOOL ; } } return BOOL ; }
public int size ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } }
@ After public void tear Down ( ) { web Client . close All Windows ( ) ; }
public Annotation Member ( String name , Object val , Class type , Method m ) { this ( name , val ) ; defining Method = m ; if ( type == int . class ) { element Type = Integer . class ; } else if ( type == boolean . class ) { element Type = Boolean . class ; } else if ( type == char . class ) { element Type = Character . class ; } else if ( type == float . class ) { element Type = Float . class ; } else if ( type == double . class ) { element Type = Double . class ; } else if ( type == long . class ) { element Type = Long . class ; } else if ( type == short . class ) { element Type = Short . class ; } else if ( type == byte . class ) { element Type = Byte . class ; } else { element Type = type ; } }
public void unregister Preference Change Listener ( Preference Change Listener preference Change Listener ) { m Listeners . remove ( preference Change Listener ) ; }
public static String join ( String separator , List < ? > elements ) { if ( elements == null || elements . size ( ) == NUM ) { return STRING ; } String Buffer sb = new String Buffer ( elements . size ( ) * NUM ) ; int i = NUM ; for ( Object elem : elements ) { if ( i ++ > NUM ) { sb . append ( separator ) ; } sb . append ( format ( elem ) ) ; } return sb . to String ( ) ; }
public boolean remove Trace ( final Trace trace ) { boolean result = trace List . remove ( trace ) ; if ( result ) { remove ( trace ) ; revalidate ( ) ; } return result ; }
private void update Random Values ( ) { for ( int i = NUM ; i < m Block Number ; i ++ ) { for ( int j = NUM ; j < DEFAULT NUMBER RANDOM VALUES ; j ++ ) { m Block Values [ i ] [ j ] = m Random . next Float ( ) ; if ( m Block Values [ i ] [ j ] < NUM ) { m Block Values [ i ] [ j ] = NUM ; } } } }
protected ASN 1 Set ( ASN 1 Encodable obj ) { set . add Element ( obj ) ; }
static private String BYTE Min Minus ( ) { long temp Value = Byte . MIN VALUE - NUM ; return String . value Of ( temp Value ) ; }
public Double Accumulator ( Double Binary Operator accumulator Function , double identity ) { this . function = accumulator Function ; base = this . identity = Double . double To Raw Long Bits ( identity ) ; }
public static void bitmap To Mat ( Bitmap bmp , Mat mat , boolean un Premultiply Alpha ) { if ( bmp == null ) throw new java . lang . Illegal Argument Exception ( STRING ) ; if ( mat == null ) throw new java . lang . Illegal Argument Exception ( STRING ) ; n Bitmap To Mat 2 ( bmp , mat . native Obj , un Premultiply Alpha ) ; }
public static void send Mail ( Context m Context , String mail ID ) { Uri uri = Uri . parse ( STRING + mail ID ) ; Intent intent = new Intent ( Intent . ACTION SENDTO , uri ) ; m Context . start Activity ( intent ) ; }
public void push ( @ Not Null Status Notification notification ) { stack . push ( notification ) ; }
public void on Paint Actions ( View Transform transform , Graphics 2 D g ) { if ( ! m Is Selected ) { return ; } if ( m Color Set == null ) { return ; } if ( m Widget . get Visibility ( ) == Constraint Widget . GONE ) { return ; } if ( ! m Show Resize Handles ) { return ; } if ( ! m Show Actions ) { return ; } if ( m Widget Actions . size ( ) == NUM ) { return ; } int l = transform . get Swing FX ( m Widget . get Draw X ( ) ) ; int t = transform . get Swing FY ( m Widget . get Draw Y ( ) ) ; int h = transform . get Swing Dimension ( m Widget . get Height ( ) ) ; int x = l ; int y = t + h + Connection Draw . CONNECTION ANCHOR SIZE + NUM ; g . set Color ( m Color Set . get Selected Frames ( ) ) ; for ( Widget Action action : m Widget Actions ) { action . update ( ) ; if ( ! action . is Visible ( ) ) { continue ; } action . on Paint ( transform , g , x , y ) ; x += ACTION SIZE + Connection Draw . CONNECTION ANCHOR SIZE ; } }
@ Override public Lookup create Global Context ( ) { if ( proxy Lookup == null ) { logger . config ( STRING ) ; project Lookup = new Abstract Lookup ( content ) ; proxy Lookup = new Proxy Lookup ( global Context Lookup , project Lookup ) ; } return proxy Lookup ; }
public void write ( byte [ ] bytes ) throws IO Exception { flush Bits ( ) ; if ( bytes != null && bytes . length > NUM ) { out . write ( bytes ) ; bytes Written += bytes . length ; } }
public static Mutable List < String > chunk ( String string , int size ) { if ( size <= NUM ) { throw new Illegal Argument Exception ( STRING + size ) ; } int length = string . length ( ) ; if ( length == NUM ) { return Fast List . new List ( ) ; } Mutable List < String > result = Fast List . new List ( ( length + size - NUM ) / size ) ; int start Offset = NUM ; while ( start Offset < length ) { result . add ( string . substring ( start Offset , Math . min ( start Offset + size , length ) ) ) ; start Offset += size ; } return result ; }
public void remove Im ( Im Entity im ) { ims . remove ( im ) ; }
public Language Setting ( Option opt ) { elem = null ; name = opt . get Language ( ) ; String [ ] suffix Array = opt . get Suffixes ( ) ; String Buffer strbuf = new String Buffer ( ) ; for ( int i = NUM ; i < suffix Array . length ; i ++ ) { strbuf . append ( suffix Array [ i ] ) ; if ( i != suffix Array . length - NUM ) strbuf . append ( STRING ) ; } this . suffixes = strbuf . to String ( ) ; min Match Len = opt . get Minimum Match Length ( ) ; cluster Type = opt . get Clustertype ( ) ; read Subdirs = opt . is Read Subdirs ( ) ; store Matches = opt . get Store Matches ( ) ; }
private double calc Util 4 Performing ( final double typ Duration , final double actual Duration ) { return NUM * marginal Util Performing Sec + marginal Util Performing Sec * typ Duration * Math . log ( actual Duration / typ Duration ) ; }
public void clear All Cache ( ) { clear Memory Cache ( ) ; clear Storage Cache ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public void add Notify ( ) { super . add Notify ( ) ; if ( text Area != null ) { l . install ( text Area ) ; } update Cell Widths ( ) ; update Cell Heights ( ) ; }
@ Description ( summary = STRING ) public void maven Install Local ( ) { jar MV Store ( ) ; String pom = new String ( read File ( new File ( STRING ) ) ) ; pom = replace All ( pom , STRING , STRING ) ; write File ( new File ( STRING ) , pom . get Bytes ( ) ) ; exec Script ( STRING , args ( STRING , STRING , STRING + get Jar Suffix ( ) , STRING , STRING , STRING , STRING ) ) ; jar ( ) ; pom = new String ( read File ( new File ( STRING ) ) ) ; pom = replace All ( pom , STRING , STRING ) ; write File ( new File ( STRING ) , pom . get Bytes ( ) ) ; exec Script ( STRING , args ( STRING , STRING , STRING + get Jar Suffix ( ) , STRING , STRING , STRING , STRING ) ) ; }
public static boolean is Dto Getter ( Method method ) { if ( method . is Annotation Present ( Delegate To . class ) ) { return BOOL ; } if ( method . get Parameter Types ( ) . length > NUM ) { return BOOL ; } String method Name = method . get Name ( ) ; return method Name . starts With ( STRING ) || ( method Name . starts With ( STRING ) && ( ( method . get Return Type ( ) == Boolean . class || method . get Return Type ( ) == boolean . class ) ) ) ; }
protected List < Video DTO > extract Videos From Cursor ( Cursor cursor , int offset , int limit ) { List < Video DTO > videos = new Array List < > ( ) ; int count = NUM ; int begin = offset > NUM ? offset : NUM ; if ( cursor . move To Position ( begin ) ) { do { Video DTO video = extract One Video From Cursor ( cursor ) ; videos . add ( video ) ; count ++ ; if ( limit > NUM && count > limit ) { break ; } } while ( cursor . move To Next ( ) ) ; } cursor . close ( ) ; return videos ; }
private static void compute Next CCW Edges ( Node node , long label ) { Directed Edge Star de Star = node . get Out Edges ( ) ; Polygonize Directed Edge first Out DE = null ; Polygonize Directed Edge prev In DE = null ; List edges = de Star . get Edges ( ) ; for ( int i = edges . size ( ) - NUM ; i >= NUM ; i -- ) { Polygonize Directed Edge de = ( Polygonize Directed Edge ) edges . get ( i ) ; Polygonize Directed Edge sym = ( Polygonize Directed Edge ) de . get Sym ( ) ; Polygonize Directed Edge out DE = null ; if ( de . get Label ( ) == label ) out DE = de ; Polygonize Directed Edge in DE = null ; if ( sym . get Label ( ) == label ) in DE = sym ; if ( out DE == null && in DE == null ) continue ; if ( in DE != null ) { prev In DE = in DE ; } if ( out DE != null ) { if ( prev In DE != null ) { prev In DE . set Next ( out DE ) ; prev In DE = null ; } if ( first Out DE == null ) first Out DE = out DE ; } } if ( prev In DE != null ) { Assert . is True ( first Out DE != null ) ; prev In DE . set Next ( first Out DE ) ; } }
@ Override public boolean equals ( Object other ) { if ( other instanceof Int Array Wrapper ) { return Arrays . equals ( data , ( ( Int Array Wrapper ) other ) . data ) ; } return BOOL ; }
public static Date Time to Date Simple ( String str , Time Zone time Zone ) throws Page Exception { Date Time dt = to Date Simple ( str , CONVERTING TYPE OFFSET , BOOL , time Zone , null ) ; if ( dt == null ) throw new Expression Exception ( STRING + str + STRING ) ; return dt ; }
public boolean contains ( Song s ) { return m Songs . contains ( s ) ; }
private float clamp Mag ( float value , float abs Min , float abs Max ) { final float abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }
private boolean zz Refill ( ) throws java . io . IO Exception { if ( zz Start Read > NUM ) { zz End Read += zz Final High Surrogate ; zz Final High Surrogate = NUM ; System . arraycopy ( zz Buffer , zz Start Read , zz Buffer , NUM , zz End Read - zz Start Read ) ; zz End Read -= zz Start Read ; zz Current Pos -= zz Start Read ; zz Marked Pos -= zz Start Read ; zz Start Read = NUM ; } if ( zz Current Pos >= zz Buffer . length - zz Final High Surrogate ) { char new Buffer [ ] = new char [ zz Buffer . length * NUM ] ; System . arraycopy ( zz Buffer , NUM , new Buffer , NUM , zz Buffer . length ) ; zz Buffer = new Buffer ; zz End Read += zz Final High Surrogate ; zz Final High Surrogate = NUM ; } int requested = zz Buffer . length - zz End Read ; int num Read = zz Reader . read ( zz Buffer , zz End Read , requested ) ; if ( num Read == NUM ) { throw new java . io . IO Exception ( STRING ) ; } if ( num Read > NUM ) { zz End Read += num Read ; if ( num Read == requested ) { if ( Character . is High Surrogate ( zz Buffer [ zz End Read - NUM ] ) ) { -- zz End Read ; zz Final High Surrogate = NUM ; } } return BOOL ; } return BOOL ; }
public int add Padding ( byte [ ] in , int in Off ) { byte code = ( byte ) ( in . length - in Off ) ; while ( in Off < in . length - NUM ) { if ( random == null ) { in [ in Off ] = NUM ; } else { in [ in Off ] = ( byte ) random . next Int ( ) ; } in Off ++ ; } in [ in Off ] = code ; return code ; }
public static Long make Long ( String s ) { if ( WW Util . is Empty ( s ) ) { return null ; } try { return Long . value Of ( s ) ; } catch ( Number Format Exception e ) { return null ; } }
private void verify Block Snapshot Migration ( ) throws Exception { log . info ( STRING ) ; Iterator < Block Snapshot > block Snapshot Itr = db Client . query Iterative Objects ( Block Snapshot . class , block Snapshot UR Is ) ; List < Block Object > block Objects = new Array List < Block Object > ( ) ; while ( block Snapshot Itr . has Next ( ) ) { block Objects . add ( block Snapshot Itr . next ( ) ) ; } verify Block Objects ( block Objects ) ; }
public static String edge Type To String ( @ Type int edge Type ) { switch ( edge Type ) { case FALL THROUGH EDGE : return STRING ; case IFCMP EDGE : return STRING ; case SWITCH EDGE : return STRING ; case SWITCH DEFAULT EDGE : return STRING ; case JSR EDGE : return STRING ; case RET EDGE : return STRING ; case GOTO EDGE : return STRING ; case RETURN EDGE : return STRING ; case UNHANDLED EXCEPTION EDGE : return STRING ; case HANDLED EXCEPTION EDGE : return STRING ; case START EDGE : return STRING ; case BACKEDGE TARGET EDGE : return STRING ; case BACKEDGE SOURCE EDGE : return STRING ; case EXIT EDGE : return STRING ; } throw new Illegal State Exception ( STRING + edge Type ) ; }
boolean check Groups ( Phone Number Util util , Phone Number number , String Builder normalized Candidate , String [ ] expected Number Groups ) ;
private int insert Unassigned Group ( ) throws SQL Exception { Prepared Statement group Statement ; final int ruleid = insert Unassigned Rule ( ) ; final int evaluation Order = get Num Of Groups ( ) + NUM ; String unassigned Group Sql Statement = STRING + GROUPS TABLE + STRING + STRING + STRING ; unassigned Group Sql Statement = String . format ( unassigned Group Sql Statement , UNASSIGNED GROUP , UNASSIGNED GROUP TYPE , UNASSIGNED DATA TYPE , ruleid , evaluation Order ) ; group Statement = prepare Statement ( unassigned Group Sql Statement , new String [ ] { STRING } ) ; group Statement . execute ( ) ; return get Internal Id ( group Statement ) ; }
public Builder delete Extension Field ( String urn , String field Name ) { delete Fields . add ( urn + STRING + field Name ) ; return this ; }
public void send Direct ( byte [ ] sql Bytes , int offset , int sql Length , byte command Type ) throws IO Exception , Query Exception { if ( is Closed ( ) ) throw new IO Exception ( STRING ) ; int seq No = NUM ; set Compress Seq No ( NUM ) ; if ( sql Length + ( use Compression ? NUM : NUM ) > get Max Allowed Packet ( ) ) { throw new Query Exception ( STRING + ( sql Length + ( use Compression ? NUM : NUM ) ) + STRING + max Allowed Packet + STRING , - NUM , INTERRUPTED EXCEPTION ) ; } if ( ! is Use Compression ( ) ) { if ( sql Length + NUM <= max Packet Size ) { byte [ ] packet Buffer = new byte [ sql Length + NUM ] ; packet Buffer [ NUM ] = ( byte ) ( ( sql Length + NUM ) & NUM ) ; packet Buffer [ NUM ] = ( byte ) ( ( sql Length + NUM ) > > > NUM ) ; packet Buffer [ NUM ] = ( byte ) ( ( sql Length + NUM ) > > > NUM ) ; packet Buffer [ NUM ] = ( byte ) seq No ++ ; packet Buffer [ NUM ] = command Type ; System . arraycopy ( sql Bytes , offset , packet Buffer , NUM , sql Length ) ; if ( logger . is Trace Enabled ( ) ) { logger . trace ( STRING + seq No + STRING + ( sql Length + NUM ) + STRING + Utils . hexdump ( packet Buffer , max Query Size To Log , NUM , sql Length + NUM ) ) ; } output Stream . write ( packet Buffer ) ; } else { byte [ ] packet Buffer = new byte [ max Packet Size + NUM ] ; packet Buffer [ NUM ] = ( byte ) ( max Packet Size & NUM ) ; packet Buffer [ NUM ] = ( byte ) ( max Packet Size > > > NUM ) ; packet Buffer [ NUM ] = ( byte ) ( max Packet Size > > > NUM ) ; packet Buffer [ NUM ] = ( byte ) seq No ++ ; packet Buffer [ NUM ] = command Type ; System . arraycopy ( sql Bytes , offset , packet Buffer , NUM , max Packet Size - NUM ) ; int length Already Send = max Packet Size - NUM ; if ( logger . is Trace Enabled ( ) ) { logger . trace ( STRING + seq No + STRING + max Packet Size + STRING + Utils . hexdump ( packet Buffer , max Query Size To Log , NUM , max Packet Size ) ) ; } output Stream . write ( packet Buffer ) ; int length ; while ( ( length = sql Length - length Already Send ) > NUM ) { if ( length > max Packet Size ) { packet Buffer [ NUM ] = ( byte ) ( max Packet Size & NUM ) ; packet Buffer [ NUM ] = ( byte ) ( max Packet Size > > > NUM ) ; packet Buffer [ NUM ] = ( byte ) ( max Packet Size > > > NUM ) ; packet Buffer [ NUM ] = ( byte ) seq No ++ ; System . arraycopy ( sql Bytes , offset + length Already Send , packet Buffer , NUM , max Packet Size ) ; if ( logger . is Trace Enabled ( ) ) { logger . trace ( STRING + seq No + STRING + max Packet Size + STRING + Utils . hexdump ( packet Buffer , max Query Size To Log , NUM , max Packet Size ) ) ; } output Stream . write ( packet Buffer ) ; length Already Send += max Packet Size ; } else { packet Buffer [ NUM ] = ( byte ) ( length & NUM ) ; packet Buffer [ NUM ] = ( byte ) ( length > > > NUM ) ; packet Buffer [ NUM ] = ( byte ) ( length > > > NUM ) ; packet Buffer [ NUM ] = ( byte ) seq No ++ ; System . arraycopy ( sql Bytes , offset + length Already Send , packet Buffer , NUM , length ) ; if ( logger . is Trace Enabled ( ) ) { logger . trace ( STRING + seq No + STRING + length + STRING + Utils . hexdump ( packet Buffer , max Query Size To Log , NUM , length ) ) ; } output Stream . write ( packet Buffer , NUM , length + NUM ) ; break ; } } } } else { if ( sql Length < max Packet Size ) { byte [ ] packet Buffer = new byte [ sql Length + NUM ] ; packet Buffer [ NUM ] = ( byte ) ( ( sql Length + NUM ) & NUM ) ; packet Buffer [ NUM ] = ( byte ) ( ( sql Length + NUM ) > > > NUM ) ; packet Buffer [ NUM ] = ( byte ) ( ( sql Length + NUM ) > > > NUM ) ; packet Buffer [ NUM ] = ( byte ) NUM ; packet Buffer [ NUM ] = command Type ; System . arraycopy ( sql Bytes , offset , packet Buffer , NUM , sql Length ) ; compressed And Send ( sql Length + NUM , packet Buffer , BOOL ) ; } else { final int expected Packet Size = sql Length + NUM + NUM * ( ( ( sql Length + NUM ) / max Packet Size ) + NUM ) ; byte [ ] packet Buffer = new byte [ expected Packet Size ] ; packet Buffer [ NUM ] = ( byte ) ( max Packet Size & NUM ) ; packet Buffer [ NUM ] = ( byte ) ( max Packet Size > > > NUM ) ; packet Buffer [ NUM ] = ( byte ) ( max Packet Size > > > NUM ) ; packet Buffer [ NUM ] = ( byte ) seq No ++ ; packet Buffer [ NUM ] = command Type ; System . arraycopy ( sql Bytes , offset , packet Buffer , NUM , max Packet Size - NUM ) ; int sql Bytes Position = max Packet Size - NUM ; int position Dest = max Packet Size + NUM ; int length ; while ( ( length = sql Length - sql Bytes Position ) > NUM ) { if ( length > max Packet Size ) { packet Buffer [ position Dest ++ ] = ( byte ) ( max Packet Size & NUM ) ; packet Buffer [ position Dest ++ ] = ( byte ) ( max Packet Size > > > NUM ) ; packet Buffer [ position Dest ++ ] = ( byte ) ( max Packet Size > > > NUM ) ; packet Buffer [ position Dest ++ ] = ( byte ) seq No ++ ; System . arraycopy ( sql Bytes , offset + sql Bytes Position , packet Buffer , position Dest , max Packet Size ) ; sql Bytes Position += max Packet Size ; position Dest += max Packet Size ; } else { packet Buffer [ position Dest ++ ] = ( byte ) ( length & NUM ) ; packet Buffer [ position Dest ++ ] = ( byte ) ( length > > > NUM ) ; packet Buffer [ position Dest ++ ] = ( byte ) ( length > > > NUM ) ; packet Buffer [ position Dest ++ ] = ( byte ) seq No ++ ; System . arraycopy ( sql Bytes , offset + sql Bytes Position , packet Buffer , position Dest , length ) ; break ; } } compressed And Send ( expected Packet Size , packet Buffer , BOOL ) ; } } }
@ Suppress Warnings ( STRING ) private List < List < Group Attribute > > search Auth Provider ( Filter query Builder , String [ ] return Attributes , final long count Limit , Attributes Mapper mapper , Validation Failure Reason [ ] failure Reason ) throws Size Limit Exceeded Exception { Search Controls group Search Controls = new Search Controls ( Search Controls . SUBTREE SCOPE , count Limit , search Controls . get Time Limit ( ) , return Attributes , search Controls . get Returning Obj Flag ( ) , search Controls . get Deref Link Flag ( ) ) ; List < List < Group Attribute > > query Group Results = null ; query Group Results = safe Ldap Search ( base DN , query Builder . encode ( ) , group Search Controls , mapper , failure Reason ) ; return query Group Results ; }
protected void export ( OM Graphic List list , List < Object > master Record , boolean write Files ) { bad Graphics = NUM ; if ( list == null ) { return ; } else if ( list instanceof Esri Graphic List ) { export ( ( Esri Graphic List ) list ) ; return ; } int dbf Index = NUM ; for ( OM Graphic dtl Graphic : list ) { List < Object > record = master Record ; Integer rec Index = ( Integer ) dtl Graphic . get Attribute ( SHAPE INDEX ATTRIBUTE ) ; if ( rec Index == null ) { rec Index = dbf Index ; } if ( record == null ) { record = get Master DBF Record ( rec Index ) ; } dbf Index ++ ; if ( dtl Graphic instanceof OM Graphic List ) { if ( DEBUG ) logger . fine ( STRING ) ; export ( ( OM Graphic List ) dtl Graphic , record , BOOL ) ; continue ; } if ( dtl Graphic . get Render Type ( ) != RENDERTYPE LATLON ) { bad Graphics ++ ; continue ; } if ( dtl Graphic instanceof OM Area List ) { if ( DEBUG ) { logger . fine ( STRING ) ; } add Area List ( ( OM Area List ) dtl Graphic , record ) ; } if ( dtl Graphic instanceof OM Poly ) { OM Poly om Poly = ( OM Poly ) dtl Graphic ; if ( is Polygon ( om Poly ) ) { if ( DEBUG ) logger . fine ( STRING ) ; add Polygon ( dtl Graphic , record ) ; } else { if ( DEBUG ) logger . fine ( STRING ) ; add Line ( dtl Graphic , record ) ; } } else if ( dtl Graphic instanceof OM Rect ) { if ( DEBUG ) logger . fine ( STRING ) ; add Polygon ( ( OM Graphic ) Esri Polygon List . convert ( ( OM Rect ) dtl Graphic ) , record ) ; } else if ( dtl Graphic instanceof OM Circle ) { if ( DEBUG ) logger . fine ( STRING ) ; add Polygon ( ( OM Graphic ) Esri Polygon List . convert ( ( OM Circle ) dtl Graphic , projection ) , record ) ; } else if ( dtl Graphic instanceof OM Range Rings ) { if ( DEBUG ) logger . fine ( STRING ) ; export ( Esri Polygon List . convert ( ( OM Range Rings ) dtl Graphic , projection ) , record , BOOL ) ; } else if ( dtl Graphic instanceof OM Line ) { if ( DEBUG ) logger . fine ( STRING ) ; add Line ( ( OM Graphic ) Esri Polyline List . convert ( ( OM Line ) dtl Graphic ) , record ) ; } else if ( dtl Graphic instanceof OM Point ) { if ( DEBUG ) logger . fine ( STRING ) ; add Point ( dtl Graphic , record ) ; } } if ( bad Graphics > NUM ) { Drawing Tool Render Exception . notify User Of Non Lat Lon Graphics ( bad Graphics ) ; } if ( ! write Files ) { return ; } boolean need Confirmation = BOOL ; if ( file Path == null ) { file Path = get File Path From User ( ) ; if ( file Path == null ) { return ; } need Confirmation = BOOL ; } if ( DEBUG ) logger . fine ( STRING ) ; boolean need Type Suffix = BOOL ; if ( poly List != null ) { ese Interfaces . add ( new ESE Interface ( poly List , file Path , null ) ) ; need Type Suffix = BOOL ; } if ( line List != null ) { ese Interfaces . add ( new ESE Interface ( line List , file Path , ( need Type Suffix ? Line Suffix : null ) ) ) ; need Type Suffix = BOOL ; } if ( point List != null ) { ese Interfaces . add ( new ESE Interface ( point List , file Path , ( need Type Suffix ? Point Suffix : null ) ) ) ; } if ( need Confirmation ) { show GUI ( ) ; } else { write Files ( ) ; } }
public Depend ( Path Impl source , long last Modified , long length ) { source = source ; last Modified = last Modified ; length = length ; }
public boolean has Task Of Type In Progress ( @ Not Null External System Task Type type , @ Not Null Project project ) { String project Id = External System Task Id . get Project Id ( project ) ; for ( External System Task Id id : my Tasks In Progress . key Set ( ) ) { if ( type . equals ( id . get Type ( ) ) && project Id . equals ( id . get Ide Project Id ( ) ) ) { return BOOL ; } } return BOOL ; }
public final void remove Change Listener ( Change Listener listener ) { listeners . remove ( listener ) ; }
public static boolean contains Ignore Case ( String str , String query ) { if ( str != null && query != null ) { int limit = str . length ( ) - query . length ( ) + NUM ; for ( int i = NUM ; i < limit ; i ++ ) { if ( matches Ignore Case ( str , query , i ) ) { return BOOL ; } } } return BOOL ; }
public String to Matrix String ( ) throws Exception { return to Matrix String ( STRING ) ; }
public Quad Edge connect ( Quad Edge a , Quad Edge b ) { Quad Edge q = Quad Edge . connect ( a , b ) ; quad Edges . add ( q ) ; return q ; }
public Test find Test ( List < String > suite Names , String test Class Name , String test Name , boolean insert If Missing ) { if ( suite Names . size ( ) <= NUM ) { Test Case test Case = get Test Case ( test Class Name ) ; return test Case . find Test ( test Name , insert If Missing ) ; } else { String root Name = suite Names . remove ( NUM ) ; Test Suite suite = get Test Suite ( root Name ) ; return suite . find Test ( suite Names , test Class Name , test Name , insert If Missing ) ; } }
public Job configure ( boolean is Secured , String meta Store Uris , String principal , String redis Host , int redis Port , String password , int redis Db , String input Database , String input Table , String input Filter , String key Name , String value Name , String key Prefix , int num Reducer , boolean replace , boolean pipeline , boolean flush , int commit Size , String [ ] anon Fields , String export Salt ) throws Exception { this . is Secured = is Secured ; this . meta Store Uris = meta Store Uris ; this . principal = principal ; this . redis Host = redis Host ; this . redis Port = redis Port ; this . password = password ; this . redis Db = redis Db ; this . input Database = input Database ; this . input Table = input Table ; this . input Filter = input Filter ; this . key Name = key Name ; this . key Prefix = key Prefix ; this . value Name = value Name ; this . num Reducer = num Reducer ; this . replace = replace ; this . pipeline = pipeline ; this . flush = flush ; this . commit Size = commit Size ; this . anon Fields = anon Fields . clone ( ) ; this . export Salt = export Salt ; return configure ( ) ; }
public static double log 2 ( double a ) { return Math . log ( a ) / log 2 ; }
public void add Suggestions ( final @ Non Null Suggestions Result result , final @ Non Null String bucket , final @ Non Null Token Source source ) { Query Token query = result . get Query Token ( ) ; synchronized ( m Lock ) { m Result Map . put ( bucket , result ) ; Set < String > waiting For Buckets = m Waiting For Results . get ( query ) ; if ( waiting For Buckets != null ) { waiting For Buckets . remove ( bucket ) ; if ( waiting For Buckets . size ( ) == NUM ) { m Waiting For Results . remove ( query ) ; } } } String current Token String = source . get Current Token String ( ) ; synchronized ( m Lock ) { m Suggestions . clear ( ) ; List < Suggestible > suggestions = m Suggestions List Builder . build Suggestions ( m Result Map , current Token String ) ; if ( suggestions . size ( ) > NUM ) { m Suggestions . add All ( suggestions ) ; m Suggestions Visibility Manager . display Suggestions ( BOOL ) ; } else { hide Suggestions If Necessary ( result . get Query Token ( ) , source ) ; } } notify Data Set Changed ( ) ; }
public static < ET extends Enum < ET > > Enum Resolver < ET > construct For ( Class < ET > enum Cls , Annotation Introspector ai ) { ET [ ] enum Values = enum Cls . get Enum Constants ( ) ; if ( enum Values == null ) { throw new Illegal Argument Exception ( STRING + enum Cls . get Name ( ) ) ; } Hash Map < String , ET > map = new Hash Map < String , ET > ( ) ; for ( ET e : enum Values ) { map . put ( ai . find Enum Value ( e ) , e ) ; } return new Enum Resolver < ET > ( enum Cls , enum Values , map ) ; }
protected void encode Line Suffix ( Output Stream a Stream ) throws IO Exception { p Stream . println ( ) ; }
public static boolean replace ( R Text Area text Area , String to Find , String replace With , boolean forward , boolean match Case , boolean whole Word , boolean regex ) throws Pattern Syntax Exception { text Area . begin Atomic Edit ( ) ; try { if ( regex ) { return regex Replace ( text Area , to Find , replace With , forward , match Case , whole Word ) ; } make Mark And Dot Equal ( text Area , forward ) ; if ( find ( text Area , to Find , forward , match Case , whole Word , BOOL ) ) { text Area . replace Selection ( replace With ) ; return BOOL ; } } finally { text Area . end Atomic Edit ( ) ; } return BOOL ; }
public void pre Single Sign On Request ( String hosted Entity ID , String idp Entity ID , String realm , Http Servlet Request request , Http Servlet Response response , Authn Request authn Request ) throws SAML 2 Exception { return ; }
void submit ( Process And Display Image Task task ) { init Executors If Need ( ) ; task Executor For Cached Images . execute ( task ) ; }
public static Image Icon create Icon ( Basic Stroke stroke , int width , int height , boolean horizontal Orientation ) { Buffered Image big Image = new Buffered Image ( width , height , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D g = ( Graphics 2 D ) big Image . get Graphics ( ) ; g . set Background ( OM Color . clear ) ; g . set Paint ( OM Color . clear ) ; g . fill Rect ( NUM , NUM , width , height ) ; g . set Paint ( Color . black ) ; g . set Stroke ( stroke ) ; if ( horizontal Orientation ) { g . draw Line ( NUM , height / NUM , width , height / NUM ) ; } else { g . draw Line ( width / NUM , NUM , width / NUM , height ) ; } return new Image Icon ( big Image ) ; }
public static final < T extends E Object > List < T > collect Nodes Within Same This Environment ( E Object root , Class < T > cls ) { final List < T > result = new Array List < > ( ) ; final Tree Iterator < E Object > iter = root . e All Contents ( ) ; while ( iter . has Next ( ) ) { final E Object obj = iter . next ( ) ; if ( cls . is Assignable From ( obj . get Class ( ) ) ) { @ Suppress Warnings ( STRING ) final T obj Casted = ( T ) obj ; result . add ( obj Casted ) ; } if ( obj instanceof This Arg Provider ) { iter . prune ( ) ; } } return result ; }
protected abstract List < Single Variable Declaration > adjust Dst Params ( Method Declaration method ) ;
public String full Source ( ) { if ( full Source == null ) { full Source = add Sentence Markers ( source ( ) ) ; } return full Source ; }
private void update Detail Data ( ) { final long start = m Left Position ; final long end = m Right Position ; final long now = m Current Time ; final Context context = get Context ( ) ; Network Stats History . Entry original Entry = m Original Network Stats History . get Values ( start , end , now , null ) ; final long original Total Bytes = original Entry . rx Bytes ; m Original Total Phrase = Formatter . format File Size ( context , original Total Bytes ) ; Network Stats History . Entry compressed Entry = m Received Network Stats History . get Values ( start , end , now , null ) ; final long compressed Total Bytes = compressed Entry . rx Bytes ; m Received Total Phrase = Formatter . format File Size ( context , compressed Total Bytes ) ; float percentage = NUM ; if ( original Total Bytes > NUM && original Total Bytes > compressed Total Bytes ) { percentage = ( original Total Bytes - compressed Total Bytes ) / ( float ) original Total Bytes ; } m Percent Reduction Phrase = String . format ( STRING , NUM * percentage ) ; m Start Date Phrase = format Date ( context , start ) ; m End Date Phrase = format Date ( context , end ) ; }
public Punctuation Trie < T > lookup ( Char Sequence s ) { Punctuation Trie < T > t = this ; for ( int i = NUM , n = s . length ( ) ; i < n ; ++ i ) { t = t . lookup ( s . char At ( i ) ) ; if ( null == t ) { break ; } } return t ; }
private static File construct File Paths ( String file 1 , String file 2 ) { File new Path ; if ( file 2 . starts With ( file 1 ) ) { new Path = new File ( file 2 ) ; } else { new Path = new File ( file 1 + STRING + file 2 ) ; } return new Path ; }
public String resolve Template ( I Template Type template Type , Map < String , String > replacements ) throws IO Exception { Path path = get Template Path ( template Type ) ; String template = new String ( Files . read All Bytes ( path ) , Standard Charsets . UTF 8 ) ; return insert Properties ( template , replacements ) ; }
public void execute ( ) { try { prep . execute ( ) ; } catch ( SQL Exception e ) { throw convert ( e ) ; } }
public void clear ( ) { ored Criteria . clear ( ) ; order By Clause = null ; distinct = BOOL ; }
private static byte [ ] unwrap Calculated Value ( byte [ ] data ) { if ( data . length < CALC DATA OFFSET ) { return data ; } Byte Buffer buffer = Page Channel . wrap ( data ) ; buffer . position ( CALC DATA LEN OFFSET ) ; int data Len = buffer . get Int ( ) ; byte [ ] new Data = new byte [ Math . min ( buffer . remaining ( ) , data Len ) ] ; buffer . get ( new Data ) ; return new Data ; }
public synchronized Type Instance create Instance ( final String name , final String comment , final Base Type base Type , final Section section , final long section Offset ) throws Couldnt Save Data Exception , Couldnt Load Data Exception { Preconditions . check Not Null ( name , STRING ) ; Preconditions . check Argument ( comment == null || ! comment . is Empty ( ) , STRING ) ; Preconditions . check Not Null ( base Type , STRING ) ; Preconditions . check Not Null ( section , STRING ) ; Preconditions . check Argument ( section Offset >= NUM , STRING ) ; Preconditions . check Argument ( ! instances By Address . contains Key ( new Type Instance Address ( section . get Start Address ( ) , section Offset ) ) ) ; final Type Instance instance = backend . create Type Instance ( name , comment , base Type , section , section Offset ) ; instances By Address . put ( instance . get Address ( ) , instance ) ; instances . add ( instance ) ; notify Instance Added ( instance ) ; return instance ; }
void show Input Box ( String message , Consumer < String > result Callback ) { show Input Box ( message , null , result Callback ) ; }
public void add ( Field field ) { m Fields . add ( field ) ; }
public static long measure Time ( Callable < Object > c , int thread Cnt ) throws Exception { A . ensure ( thread Cnt >= NUM , STRING ) ; long start = System . current Time Millis ( ) ; if ( thread Cnt == NUM ) c . call ( ) ; else Grid Test Utils . run Multi Threaded ( c , thread Cnt , STRING ) ; return System . current Time Millis ( ) - start ; }
@ Override public boolean is Closed ( ) { return is Closed . get ( ) ; }
protected Statement List Node generate Destructor Body ( Context context , Statement List Node statement List ) { Model model = ( Model ) value ; Set < String > ids = new Linked Hash Set < String > ( ) ; if ( model . is Declared ( ) ) ids . add ( model . get Id ( ) ) ; collect Declarations ( model . get Sub Initializer Iterator ( ) , ids ) ; Node Factory node Factory = context . get Node Factory ( ) ; Statement List Node result = statement List ; Statement List Node function Statement List = null ; for ( String id : ids ) { Literal Null Node literal Null = node Factory . literal Null ( ) ; Identifier Node identifier = node Factory . identifier ( id ) ; Node expression Statement = node Factory . assignment Expression ( identifier , ASSIGN TOKEN , literal Null ) ; function Statement List = node Factory . statement List ( function Statement List , expression Statement ) ; } Function Signature Node function Signature = node Factory . function Signature ( null , null ) ; function Signature . void anno = BOOL ; Identifier Node function Identifier = node Factory . identifier ( model . get Definition Name ( ) + STRING ) ; Function Common Node function Common = node Factory . function Common ( context , function Identifier , function Signature , function Statement List ) ; function Common . set User Defined Body ( BOOL ) ; Attribute List Node attribute List = Abstract Syntax Tree Util . generate Private Attribute ( node Factory ) ; Function Name Node function Name = node Factory . function Name ( Tokens . EMPTY TOKEN , function Identifier ) ; Function Definition Node function Definition = node Factory . function Definition ( context , attribute List , function Name , function Common ) ; result = node Factory . statement List ( result , function Definition ) ; return result ; }
protected synchronized void expire ( ) throws Illegal Monitor State Exception { if ( owner == Thread . current Thread ( ) ) { expired = BOOL ; } else { throw new Illegal Monitor State Exception ( STRING ) ; } }
private String Buffer prepare Optimized Insert Statement ( One Row Change one Row Change ) { String Buffer stmt ; stmt = new String Buffer ( ) ; stmt . append ( STRING ) ; stmt . append ( conn . get Database Object Name ( one Row Change . get Schema Name ( ) ) + STRING + conn . get Database Object Name ( one Row Change . get Table Name ( ) ) ) ; stmt . append ( STRING ) ; print Column Spec ( stmt , one Row Change . get Column Spec ( ) , null , null , Print Mode . NAMES ONLY , STRING ) ; stmt . append ( STRING ) ; boolean first Row = BOOL ; for ( Array List < Column Val > one Row Values : one Row Change . get Column Values ( ) ) { if ( first Row ) { first Row = BOOL ; } else stmt . append ( STRING ) ; print Column Spec ( stmt , one Row Change . get Column Spec ( ) , null , one Row Values , Print Mode . PLACE HOLDER , STRING ) ; stmt . append ( STRING ) ; } return stmt ; }
private boolean extractor Queue Empty ( ) throws Interrupted Exception { if ( extractor . has More Events ( ) ) return BOOL ; else if ( block Commit Interval Millis <= NUM ) return BOOL ; else { long next Commit Millis = last Commit Millis + block Commit Interval Millis ; long sleep Millis = next Commit Millis - System . current Time Millis ( ) ; while ( sleep Millis > NUM ) { Thread . sleep ( NUM ) ; if ( extractor . has More Events ( ) ) return BOOL ; sleep Millis = next Commit Millis - System . current Time Millis ( ) ; } return BOOL ; } }
public static void verify ( final Class Reader cr , final boolean dump , final Print Writer pw ) { verify ( cr , null , dump , pw ) ; }
public File Async Http Response Handler ( Context context ) { super ( ) ; this . file = get Temporary File ( context ) ; this . append = BOOL ; this . rename If Exists = BOOL ; }
public static boolean is Window Opaque ( Window window ) { if ( window == null ) { throw new Null Pointer Exception ( STRING ) ; } return window . is Opaque ( ) ; }
public static byte [ ] encode ( byte [ ] data , int off , int length ) { int len = ( length + NUM ) / NUM * NUM ; Byte Array Output Stream b Out = new Byte Array Output Stream ( len ) ; try { encoder . encode ( data , off , length , b Out ) ; } catch ( Exception e ) { throw new Encoder Exception ( STRING + e . get Message ( ) , e ) ; } return b Out . to Byte Array ( ) ; }
public double entropy NMI Min ( ) { return ( entropy Mutual Information ( ) / Math . min ( entropy First ( ) , entropy Second ( ) ) ) ; }
public static void unregister ( Close Watcher w ) { w . closeable = null ; refs . remove ( w ) ; }
protected final void refresh Loading Views Size ( ) { final int maximum Pull Scroll = ( int ) ( get Maximum Pull Scroll ( ) * NUM ) ; int p Left = get Padding Left ( ) ; int p Top = get Padding Top ( ) ; int p Right = get Padding Right ( ) ; int p Bottom = get Padding Bottom ( ) ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Width ( maximum Pull Scroll ) ; p Left = - maximum Pull Scroll ; } else { p Left = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Width ( maximum Pull Scroll ) ; p Right = - maximum Pull Scroll ; } else { p Right = NUM ; } break ; case VERTICAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Height ( maximum Pull Scroll ) ; p Top = - maximum Pull Scroll ; } else { p Top = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Height ( maximum Pull Scroll ) ; p Bottom = - maximum Pull Scroll ; } else { p Bottom = NUM ; } break ; } if ( DEBUG ) { Log . d ( LOG TAG , String . format ( STRING , p Left , p Top , p Right , p Bottom ) ) ; } set Padding ( p Left , p Top , p Right , p Bottom ) ; }
static Label Node [ ] clone ( final List < Label Node > labels , final Map < Label Node , Label Node > map ) { Label Node [ ] clones = new Label Node [ labels . size ( ) ] ; for ( int i = NUM ; i < clones . length ; ++ i ) { clones [ i ] = map . get ( labels . get ( i ) ) ; } return clones ; }
@ Override public Jetty Solr Runner create Jetty ( File solr Home , String data Dir , String shard List , String solr Config Override , String schema Override ) throws Exception { return create Proxied Jetty ( solr Home , data Dir , shard List , solr Config Override , schema Override ) ; }
public synchronized void add Batch Classifier Listener ( Batch Classifier Listener cl ) { m batch Classifier Listeners . add Element ( cl ) ; }
private boolean match Andwrite One Audit Log ( Buffered Writer writer , Audit Log auditlog , String keyword ) throws Marshalling Excetion { try { Audit Log Utils . reset Desc ( auditlog , resb ) ; if ( Audit Log Utils . is Keyword Contained ( auditlog , keyword ) ) { if ( count . get And Increment ( ) > NUM ) { while ( ! first Written . get ( ) ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { logger . warn ( STRING ) ; } } writer . write ( STRING + mapper . write Value As String ( auditlog ) ) ; } else { writer . write ( mapper . write Value As String ( auditlog ) ) ; first Written . set ( BOOL ) ; } return BOOL ; } logger . debug ( STRING , auditlog . get Description ( ) , keyword ) ; return BOOL ; } catch ( Json Generation Exception e ) { throw new Marshalling Excetion ( STRING , e ) ; } catch ( Json Mapping Exception e ) { throw new Marshalling Excetion ( STRING , e ) ; } catch ( IO Exception e ) { throw new Marshalling Excetion ( STRING , e ) ; } }
String to String ( boolean include Private Credentials ) { String s = Resources Mgr . get String ( STRING ) ; String suffix = STRING ; synchronized ( principals ) { Iterator < Principal > pI = principals . iterator ( ) ; while ( pI . has Next ( ) ) { Principal p = pI . next ( ) ; suffix = suffix + Resources Mgr . get String ( STRING ) + p . to String ( ) + Resources Mgr . get String ( STRING ) ; } } synchronized ( pub Credentials ) { Iterator < Object > pI = pub Credentials . iterator ( ) ; while ( pI . has Next ( ) ) { Object o = pI . next ( ) ; suffix = suffix + Resources Mgr . get String ( STRING ) + o . to String ( ) + Resources Mgr . get String ( STRING ) ; } } if ( include Private Credentials ) { synchronized ( priv Credentials ) { Iterator < Object > pI = priv Credentials . iterator ( ) ; while ( pI . has Next ( ) ) { try { Object o = pI . next ( ) ; suffix += Resources Mgr . get String ( STRING ) + o . to String ( ) + Resources Mgr . get String ( STRING ) ; } catch ( Security Exception se ) { suffix += Resources Mgr . get String ( STRING ) ; break ; } } } } return s + suffix ; }
private void decode Tones Phase ( int ch Num , boolean band Has Tones [ ] ) { Waves Data dst [ ] = ctx . channels [ ch Num ] . tones Info ; for ( int sb = NUM ; sb < ctx . waves Info . num Tone Bands ; sb ++ ) { if ( ! band Has Tones [ sb ] ) { continue ; } int wparam = dst [ sb ] . start Index ; for ( int i = NUM ; i < dst [ sb ] . num Wavs ; i ++ ) { ctx . waves Info . waves [ wparam + i ] . phase Index = br . read ( NUM ) ; } } }
public int encode ( byte [ ] data , int off , int length , Output Stream out ) throws IO Exception { for ( int i = off ; i < ( off + length ) ; i ++ ) { int v = data [ i ] & NUM ; out . write ( encoding Table [ ( v > > > NUM ) ] ) ; out . write ( encoding Table [ v & NUM ] ) ; } return length * NUM ; }
public void clear ( ) { synchronized ( m Lock ) { m Graphics . clear ( ) ; } post Invalidate ( ) ; }
public static String remove All ( String str , String [ ] patterns ) { for ( String pattern : patterns ) str = str . replace ( pattern , STRING ) ; return str ; }
public void add Series Renderer ( Simple Series Renderer renderer ) { m Renderers . add ( renderer ) ; }
public static void cc Draw Circle ( GL 10 gl , CG Point center , float r , float a , int segments , boolean draw Line To Center ) { Float Buffer vertices = get Vertices ( NUM * ( segments + NUM ) ) ; int additional Segment = NUM ; if ( draw Line To Center ) additional Segment ++ ; final float coef = NUM * ( float ) Math . PI / segments ; for ( int i = NUM ; i <= segments ; i ++ ) { float rads = i * coef ; float j = ( float ) ( r * Math . cos ( rads + a ) + center . x ) ; float k = ( float ) ( r * Math . sin ( rads + a ) + center . y ) ; vertices . put ( j ) ; vertices . put ( k ) ; } vertices . put ( center . x ) ; vertices . put ( center . y ) ; vertices . position ( NUM ) ; gl . gl Disable ( GL TEXTURE 2D ) ; gl . gl Disable Client State ( GL TEXTURE COORD ARRAY ) ; gl . gl Disable Client State ( GL COLOR ARRAY ) ; gl . gl Vertex Pointer ( NUM , GL FLOAT , NUM , vertices ) ; gl . gl Draw Arrays ( GL LINE STRIP , NUM , segments + additional Segment ) ; gl . gl Enable Client State ( GL COLOR ARRAY ) ; gl . gl Enable Client State ( GL TEXTURE COORD ARRAY ) ; gl . gl Enable ( GL TEXTURE 2D ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
@ Override public boolean is Parent ( File folder , File file ) { return folder . equals ( file . get Parent File ( ) ) ; }
@ Override public void print ( char c ) throws IO Exception { boolean is WS = Character . is Whitespace ( c ) ; if ( is WS ) { if ( is First Char ) return ; if ( c == CHAR RETURN ) return ; if ( sb . length ( ) > NUM ) { print Buffer ( ) ; last Char = ( c == CHAR NL ) ? CHAR NL : c ; super . print ( last Char ) ; return ; } } is First Char = BOOL ; if ( c == CHAR GT && sb . length ( ) > NUM ) print Buffer ( ) ; if ( is WS || ! add To Buffer ( c ) ) { if ( depth Sum == NUM ) { if ( is WS ) { if ( last Char == CHAR NL ) return ; if ( c != CHAR NL ) { if ( Character . is Whitespace ( last Char ) ) return ; } } } last Char = c ; super . print ( c ) ; } }
public static Token Endpoint Auth Method from String ( String type ) { if ( type != null ) { for ( Token Endpoint Auth Method auth Method : Token Endpoint Auth Method . values ( ) ) { if ( type . equals Ignore Case ( auth Method . type ) ) { return auth Method ; } } } return null ; }
public void put ( E e ) throws Interrupted Exception { if ( e == null ) throw new Null Pointer Exception ( ) ; int c = - NUM ; final Reentrant Lock put Lock = this . put Lock ; final Atomic Integer count = this . count ; put Lock . lock Interruptibly ( ) ; try { while ( count . get ( ) >= capacity ) { not Full . await ( ) ; } enqueue ( e ) ; c = count . get And Increment ( ) ; if ( c + NUM < capacity ) not Full . signal ( ) ; } finally { put Lock . unlock ( ) ; } if ( c == NUM ) signal Not Empty ( ) ; }
private boolean compare ( List < String > remote Modules , List < String > expected Modules ) { Collections . sort ( remote Modules ) ; Collections . sort ( expected Modules ) ; return remote Modules . equals ( expected Modules ) ; }
private void encode Size ( Byte Buffer header Buffer , int size ) { header Buffer . put ( ( byte ) ( ( size & NUM ) > > NUM ) ) ; header Buffer . put ( ( byte ) ( ( size & NUM ) > > NUM ) ) ; header Buffer . put ( ( byte ) ( size & NUM ) ) ; logger . fine ( STRING + size + STRING + Integer . to Binary String ( size ) + STRING + Integer . to Hex String ( size ) ) ; }
protected Linked List < Diff > diff bisect ( String text 1 , String text 2 , long deadline ) { int text 1 length = text 1 . length ( ) ; int text 2 length = text 2 . length ( ) ; int max d = ( text 1 length + text 2 length + NUM ) / NUM ; int v offset = max d ; int v length = NUM * max d ; int [ ] v1 = new int [ v length ] ; int [ ] v2 = new int [ v length ] ; for ( int x = NUM ; x < v length ; x ++ ) { v1 [ x ] = - NUM ; v2 [ x ] = - NUM ; } v1 [ v offset + NUM ] = NUM ; v2 [ v offset + NUM ] = NUM ; int delta = text 1 length - text 2 length ; boolean front = ( delta % NUM != NUM ) ; int k1 start = NUM ; int k1 end = NUM ; int k2 start = NUM ; int k2 end = NUM ; for ( int d = NUM ; d < max d ; d ++ ) { if ( System . current Time Millis ( ) > deadline ) { break ; } for ( int k1 = - d + k1 start ; k1 <= d - k1 end ; k1 += NUM ) { int k1 offset = v offset + k1 ; int x1 ; if ( k1 == - d || ( k1 != d && v1 [ k1 offset - NUM ] < v1 [ k1 offset + NUM ] ) ) { x1 = v1 [ k1 offset + NUM ] ; } else { x1 = v1 [ k1 offset - NUM ] + NUM ; } int y1 = x1 - k1 ; while ( x1 < text 1 length && y1 < text 2 length && text 1 . char At ( x1 ) == text 2 . char At ( y1 ) ) { x1 ++ ; y1 ++ ; } v1 [ k1 offset ] = x1 ; if ( x1 > text 1 length ) { k1 end += NUM ; } else if ( y1 > text 2 length ) { k1 start += NUM ; } else if ( front ) { int k2 offset = v offset + delta - k1 ; if ( k2 offset >= NUM && k2 offset < v length && v2 [ k2 offset ] != - NUM ) { int x2 = text 1 length - v2 [ k2 offset ] ; if ( x1 >= x2 ) { return diff bisect Split ( text 1 , text 2 , x1 , y1 , deadline ) ; } } } } for ( int k2 = - d + k2 start ; k2 <= d - k2 end ; k2 += NUM ) { int k2 offset = v offset + k2 ; int x2 ; if ( k2 == - d || ( k2 != d && v2 [ k2 offset - NUM ] < v2 [ k2 offset + NUM ] ) ) { x2 = v2 [ k2 offset + NUM ] ; } else { x2 = v2 [ k2 offset - NUM ] + NUM ; } int y2 = x2 - k2 ; while ( x2 < text 1 length && y2 < text 2 length && text 1 . char At ( text 1 length - x2 - NUM ) == text 2 . char At ( text 2 length - y2 - NUM ) ) { x2 ++ ; y2 ++ ; } v2 [ k2 offset ] = x2 ; if ( x2 > text 1 length ) { k2 end += NUM ; } else if ( y2 > text 2 length ) { k2 start += NUM ; } else if ( ! front ) { int k1 offset = v offset + delta - k2 ; if ( k1 offset >= NUM && k1 offset < v length && v1 [ k1 offset ] != - NUM ) { int x1 = v1 [ k1 offset ] ; int y1 = v offset + x1 - k1 offset ; x2 = text 1 length - x2 ; if ( x1 >= x2 ) { return diff bisect Split ( text 1 , text 2 , x1 , y1 , deadline ) ; } } } } } Linked List < Diff > diffs = new Linked List < Diff > ( ) ; diffs . add ( new Diff ( Operation . DELETE , text 1 ) ) ; diffs . add ( new Diff ( Operation . INSERT , text 2 ) ) ; return diffs ; }
public boolean this Is You ( Object n ) { return id . equals ( n ) ; }
private int sync Contact Names ( Context context ) { final Content Resolver content Resolver = context . get Content Resolver ( ) ; final Cursor cursor = content Resolver . query ( Contact Notifications . CONTENT URI , null , null , null , null ) ; if ( cursor == null ) { return NUM ; } if ( cursor . get Count ( ) == NUM ) { return NUM ; } int count = NUM ; int updated Count = NUM ; String id ; String contact Name ; String contact Lookup ; String contact Id ; while ( cursor . move To Next ( ) ) { count ++ ; id = cursor . get String ( cursor . get Column Index Or Throw ( Contact Notifications . ID ) ) ; contact Name = cursor . get String ( cursor . get Column Index Or Throw ( Contact Notifications . CONTACT NAME ) ) ; contact Id = cursor . get String ( cursor . get Column Index Or Throw ( Contact Notifications . CONTACT ID ) ) ; contact Lookup = cursor . get String ( cursor . get Column Index Or Throw ( Contact Notifications . CONTACT LOOKUPKEY ) ) ; Contact Identification contact Info = Sms Popup Utils . get Person Name By Lookup ( context , contact Lookup , contact Id ) ; if ( contact Info != null ) { boolean run Update = BOOL ; Content Values vals = new Content Values ( ) ; if ( contact Name == null || ! contact Name . equals ( contact Info . contact Name ) ) { vals . put ( Contact Notifications . CONTACT NAME , contact Info . contact Name ) ; run Update = BOOL ; } if ( contact Id == null || ! contact Id . equals ( contact Info . contact Id ) ) { vals . put ( Contact Notifications . CONTACT ID , contact Info . contact Id ) ; run Update = BOOL ; } if ( contact Lookup == null || ! contact Lookup . equals ( contact Info . contact Lookup ) ) { vals . put ( Contact Notifications . CONTACT LOOKUPKEY , contact Info . contact Lookup ) ; run Update = BOOL ; } if ( run Update && NUM == content Resolver . update ( Contact Notifications . build Contact Uri ( id ) , vals , null , null ) ) { updated Count ++ ; } } } if ( cursor != null ) { cursor . close ( ) ; } if ( Build Config . DEBUG ) Log . v ( STRING + updated Count + STRING + count ) ; return updated Count ; }
@ Override public synchronized void clear ( ) { File [ ] files = m Root Directory . list Files ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } m Entries . clear ( ) ; m Total Size = NUM ; Volley Log . d ( STRING ) ; }
@ Override protected void device Frame Rect ( int x , int y , int width , int height , Color color ) { Affine Transform device Transform = get Transform ( ) ; int transform Type = device Transform . get Type ( ) ; boolean use Path = ( ( transform Type & ( Affine Transform . TYPE GENERAL ROTATION | Affine Transform . TYPE GENERAL TRANSFORM ) ) != NUM ) ; if ( use Path ) { draw ( new Rectangle 2 D . Float ( x , y , width , height ) ) ; return ; } Stroke stroke = get Stroke ( ) ; if ( stroke instanceof Basic Stroke ) { Basic Stroke line Stroke = ( Basic Stroke ) stroke ; int end Cap = line Stroke . get End Cap ( ) ; int line Join = line Stroke . get Line Join ( ) ; if ( ( end Cap == Basic Stroke . CAP SQUARE ) && ( line Join == Basic Stroke . JOIN MITER ) && ( line Stroke . get Miter Limit ( ) == NUM ) ) { float line Width = line Stroke . get Line Width ( ) ; Point 2 D . Float pen Size = new Point 2 D . Float ( line Width , line Width ) ; device Transform . delta Transform ( pen Size , pen Size ) ; float device Line Width = Math . min ( Math . abs ( pen Size . x ) , Math . abs ( pen Size . y ) ) ; Point 2 D . Float ul pos = new Point 2 D . Float ( x , y ) ; device Transform . transform ( ul pos , ul pos ) ; Point 2 D . Float lr pos = new Point 2 D . Float ( x + width , y + height ) ; device Transform . transform ( lr pos , lr pos ) ; float w = ( float ) ( lr pos . get X ( ) - ul pos . get X ( ) ) ; float h = ( float ) ( lr pos . get Y ( ) - ul pos . get Y ( ) ) ; W Printer Job w Printer Job = ( W Printer Job ) get Printer Job ( ) ; if ( w Printer Job . select Style Pen ( end Cap , line Join , device Line Width , color ) == BOOL ) { w Printer Job . frame Rect ( ( float ) ul pos . get X ( ) , ( float ) ul pos . get Y ( ) , w , h ) ; } else { double lower Res = Math . min ( w Printer Job . get X Res ( ) , w Printer Job . get Y Res ( ) ) ; if ( ( device Line Width / lower Res ) < MAX THINLINE INCHES ) { w Printer Job . select Pen ( device Line Width , color ) ; w Printer Job . frame Rect ( ( float ) ul pos . get X ( ) , ( float ) ul pos . get Y ( ) , w , h ) ; } else { draw ( new Rectangle 2 D . Float ( x , y , width , height ) ) ; } } } else { draw ( new Rectangle 2 D . Float ( x , y , width , height ) ) ; } } }
public void reset Workspace ( ) { m Block Factory . clear Prior Block References ( ) ; m Root Blocks . clear ( ) ; m Stats . clear ( ) ; m Deleted Blocks . clear ( ) ; }
private void parse Element ( Element element ) throws SAML 2 Exception { Assertion Factory assertion Factory = Assertion Factory . get Instance ( ) ; Protocol Factory proto Factory = Protocol Factory . get Instance ( ) ; request Id = element . get Attribute ( SAML 2 Constants . ID ) ; validate ID ( request Id ) ; version = element . get Attribute ( SAML 2 Constants . VERSION ) ; validate Version ( version ) ; String issue Instant Str = element . get Attribute ( SAML 2 Constants . ISSUE INSTANT ) ; validate Issue Instant ( issue Instant Str ) ; destination URI = element . get Attribute ( SAML 2 Constants . DESTINATION ) ; consent = element . get Attribute ( SAML 2 Constants . CONSENT ) ; String not On Or After Str = element . get Attribute ( SAML 2 Constants . NOTONORAFTER ) ; validate Not On Or After Str ( not On Or After Str ) ; reason = element . get Attribute ( SAML 2 Constants . REASON ) ; String session Index Str = null ; Node List n List = element . get Child Nodes ( ) ; if ( ( n List != null ) && ( n List . get Length ( ) > NUM ) ) { for ( int i = NUM ; i < n List . get Length ( ) ; i ++ ) { Node child Node = n List . item ( i ) ; String c Name = child Node . get Local Name ( ) ; if ( c Name != null ) { if ( c Name . equals ( SAML 2 Constants . ISSUER ) ) { name ID = assertion Factory . create Issuer ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . SIGNATURE ) ) { signature String = XML Utils . print ( ( Element ) child Node ) ; is Signed = BOOL ; } else if ( c Name . equals ( SAML 2 Constants . EXTENSIONS ) ) { extensions = proto Factory . create Extensions ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . BASEID ) ) { base Id = assertion Factory . create Base ID ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . NAMEID ) ) { name Id = assertion Factory . create Name ID ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . ENCRYPTEDID ) ) { encrypted Id = assertion Factory . create Encrypted ID ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . SESSION INDEX ) ) { if ( ( session Index List == null ) || ( session Index List . is Empty ( ) ) ) { session Index List = new Array List ( ) ; } session Index Str = XML Utils . get Element String ( ( Element ) child Node ) ; session Index List . add ( session Index Str ) ; } } } validate Base I Dor Name I Dor Encrypted ID ( ) ; if ( ( session Index List != null ) && ( ! session Index List . is Empty ( ) ) ) { session Index List = Collections . unmodifiable List ( session Index List ) ; } } }
protected void on Complete ( ) { }
public static Big Decimal paid To Date ( int p C Invoice ID , int p C Currency ID , int p Multiplier AP , Timestamp Date Acct ) throws SQL Exception { if ( p C Invoice ID == NUM || p C Currency ID == NUM ) return null ; Big Decimal Multiplier AP = new Big Decimal ( ( double ) p Multiplier AP ) ; if ( p Multiplier AP == NUM ) Multiplier AP = Adempiere . ONE ; int C Conversion Type ID = NUM ; Big Decimal payment Amt = allocated Amt To Date ( p C Invoice ID , p C Currency ID , C Conversion Type ID , Multiplier AP , Date Acct ) ; return Currency . round ( payment Amt , p C Currency ID , null ) ; }
private int [ ] to Int Array ( ) { int length = encoding . length ; int [ ] result = new int [ NUM ] ; int which = NUM ; int from Pos = NUM ; for ( int i = NUM ; i < length ; i ++ ) { if ( ( encoding [ i ] & NUM ) == NUM ) { if ( i - from Pos + NUM > NUM ) { Big Integer big = new Big Integer ( pack ( encoding , from Pos , i - from Pos + NUM , NUM , NUM ) ) ; if ( from Pos == NUM ) { result [ which ++ ] = NUM ; Big Integer second = big . subtract ( Big Integer . value Of ( NUM ) ) ; if ( second . compare To ( Big Integer . value Of ( Integer . MAX VALUE ) ) == NUM ) { return null ; } else { result [ which ++ ] = second . int Value ( ) ; } } else { if ( big . compare To ( Big Integer . value Of ( Integer . MAX VALUE ) ) == NUM ) { return null ; } else { result [ which ++ ] = big . int Value ( ) ; } } } else { int retval = NUM ; for ( int j = from Pos ; j <= i ; j ++ ) { retval <<= NUM ; byte tmp = encoding [ j ] ; retval |= ( tmp & NUM ) ; } if ( from Pos == NUM ) { if ( retval < NUM ) { result [ which ++ ] = retval / NUM ; result [ which ++ ] = retval % NUM ; } else { result [ which ++ ] = NUM ; result [ which ++ ] = retval - NUM ; } } else { result [ which ++ ] = retval ; } } from Pos = i + NUM ; } if ( which >= result . length ) { result = Arrays . copy Of ( result , which + NUM ) ; } } return Arrays . copy Of ( result , which ) ; }
public static List < Window > windows ( Input Stream words , Tokenizer Factory tokenizer Factory , int window Size ) { Tokenizer tokenizer = tokenizer Factory . create ( words ) ; List < String > list = new Array List < > ( ) ; while ( tokenizer . has More Tokens ( ) ) list . add ( tokenizer . next Token ( ) ) ; if ( list . is Empty ( ) ) throw new Illegal State Exception ( STRING ) ; return windows ( list , window Size ) ; }
public static double [ ] page Rank ( Matrix Interface prepared Matrix , int max Iteration ) { double [ ] init = new double [ prepared Matrix . get Rows Count ( ) ] ; for ( int i = NUM ; i != init . length ; i ++ ) init [ i ] = NUM ; return page Rank ( prepared Matrix , max Iteration , DEFAULT D , init ) ; }
public boolean has MIME Type ( String mime Type ) { if ( mime Type == null ) return BOOL ; String type = mime Type ; if ( mime Type . index Of ( STRING ) > NUM ) { type = mime Type . substring ( NUM , mime Type . index Of ( STRING ) ) ; } for ( String mt : this . mime Types ) { if ( mt . equals Ignore Case ( mime Type ) ) { return BOOL ; } if ( mime Type != type && mt . equals Ignore Case ( type ) ) { return BOOL ; } } return BOOL ; }
private int measure Short ( int measure Spec ) { int result ; int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; if ( spec Mode == Measure Spec . EXACTLY ) { result = spec Size ; } else { result = ( int ) ( NUM * m Radius + get Padding Top ( ) + get Padding Bottom ( ) + NUM ) ; if ( spec Mode == Measure Spec . AT MOST ) { result = Math . min ( result , spec Size ) ; } } return result ; }
private void read Object ( java . io . Object Input Stream s ) throws java . io . IO Exception , Class Not Found Exception { s . default Read Object ( ) ; key = key . clone ( ) ; }
void unexecute NS Decls ( Transformer Impl transformer ) throws Transformer Exception { unexecute NS Decls ( transformer , null ) ; }
public boolean add ( Protocol Message pm ) { return protocol Messages . add ( pm ) ; }
public void random Init ( ) { do { m bits = new boolean [ m n Nodes * m n Nodes ] ; for ( int i = NUM ; i < m n Nodes ; i ++ ) { int i Pos ; do { i Pos = m random . next Int ( m n Nodes * m n Nodes ) ; } while ( is Square ( i Pos ) ) ; m bits [ i Pos ] = BOOL ; } } while ( has Cycles ( ) ) ; calc Global Score ( ) ; }
public static int safe Parse Int ( String s ) { return safe Parse Int ( s , - NUM ) ; }
protected boolean has Receivers For ( Distributed Member end Point ) { synchronized ( this . receivers ) { for ( Iterator it = receivers . iterator ( ) ; it . has Next ( ) ; ) { Connection con = ( Connection ) it . next ( ) ; if ( end Point . equals ( con . get Remote Address ( ) ) ) { return BOOL ; } } } return BOOL ; }
protected void decode Bitmap Data ( final Gif Frame frame , byte [ ] dst Pixels ) { if ( frame != null ) { raw Data . position ( frame . buffer Frame Start ) ; } final int null Code = - NUM ; final int npix = ( frame == null ) ? width * height : frame . iw * frame . ih ; int available , clear , code mask , code size , end of information , in code , old code , bits , code , count , i , datum , data size , first , top , bi , pi ; if ( dst Pixels == null || dst Pixels . length < npix ) { dst Pixels = new byte [ npix ] ; } if ( prefix == null ) { prefix = new short [ MAX STACK SIZE ] ; } if ( suffix == null ) { suffix = new byte [ MAX STACK SIZE ] ; } if ( pixel Stack == null ) { pixel Stack = new byte [ MAX STACK SIZE + NUM ] ; } data size = read ( ) ; clear = NUM << data size ; end of information = clear + NUM ; available = clear + NUM ; old code = null Code ; code size = data size + NUM ; code mask = ( NUM << code size ) - NUM ; for ( code = NUM ; code < clear ; code ++ ) { prefix [ code ] = NUM ; suffix [ code ] = ( byte ) code ; } datum = bits = count = first = top = pi = bi = NUM ; for ( i = NUM ; i < npix ; ) { if ( top == NUM ) { if ( bits < code size ) { if ( count == NUM ) { count = read Block ( ) ; if ( count <= NUM ) { break ; } bi = NUM ; } datum += ( ( block [ bi ] ) & NUM ) << bits ; bits += NUM ; bi ++ ; count -- ; continue ; } code = datum & code mask ; datum >>= code size ; bits -= code size ; if ( ( code > available ) || ( code == end of information ) ) { break ; } if ( code == clear ) { code size = data size + NUM ; code mask = ( NUM << code size ) - NUM ; available = clear + NUM ; old code = null Code ; continue ; } if ( old code == null Code ) { pixel Stack [ top ++ ] = suffix [ code ] ; old code = code ; first = code ; continue ; } in code = code ; if ( code == available ) { pixel Stack [ top ++ ] = ( byte ) first ; code = old code ; } while ( code > clear ) { pixel Stack [ top ++ ] = suffix [ code ] ; code = prefix [ code ] ; } first = ( suffix [ code ] ) & NUM ; if ( available >= MAX STACK SIZE ) { break ; } pixel Stack [ top ++ ] = ( byte ) first ; prefix [ available ] = ( short ) old code ; suffix [ available ] = ( byte ) first ; available ++ ; if ( ( ( available & code mask ) == NUM ) && ( available < MAX STACK SIZE ) ) { code size ++ ; code mask += available ; } old code = in code ; } top -- ; dst Pixels [ pi ++ ] = pixel Stack [ top ] ; i ++ ; } for ( i = pi ; i < npix ; i ++ ) { dst Pixels [ i ] = NUM ; } }
public void add Range Restriction ( String Column Name , Object Code , Object Code to , String Info Name , String Info Display , String Info Display to ) { Restriction r = new Restriction ( Column Name , Code , Code to , Info Name , Info Display , Info Display to , BOOL , NUM ) ; m list . add ( r ) ; }
@ Suppress Warnings ( STRING ) E transfer ( E e , boolean timed , long nanos ) { Q Node s = null ; boolean is Data = ( e != null ) ; for ( ; ; ) { Q Node t = tail ; Q Node h = head ; if ( t == null || h == null ) continue ; if ( h == t || t . is Data == is Data ) { Q Node tn = t . next ; if ( t != tail ) continue ; if ( tn != null ) { advance Tail ( t , tn ) ; continue ; } if ( timed && nanos <= NUM ) return null ; if ( s == null ) s = new Q Node ( e , is Data ) ; if ( ! t . cas Next ( null , s ) ) continue ; advance Tail ( t , s ) ; Object x = await Fulfill ( s , e , timed , nanos ) ; if ( x == s ) { clean ( t , s ) ; return null ; } if ( ! s . is Off List ( ) ) { advance Head ( t , s ) ; if ( x != null ) s . item = s ; s . waiter = null ; } return ( x != null ) ? ( E ) x : e ; } else { Q Node m = h . next ; if ( t != tail || m == null || h != head ) continue ; Object x = m . item ; if ( is Data == ( x != null ) || x == m || ! m . cas Item ( x , e ) ) { advance Head ( h , m ) ; continue ; } advance Head ( h , m ) ; Lock Support . unpark ( m . waiter ) ; return ( x != null ) ? ( E ) x : e ; } } }
protected void index Points ( Input Stream is , long ptr , Output Stream os ) { boolean more Records = BOOL ; byte r Hdr [ ] = new byte [ SHAPE RECORD HEADER LENGTH ] ; byte out Buf [ ] = new byte [ SPATIAL INDEX RECORD LENGTH ] ; int result ; int n Records = NUM ; int rec Length Words , rec Length Bytes ; long rec Offset ; int shape Type ; int rec Buf Size = NUM ; byte rec Buf [ ] = new byte [ rec Buf Size ] ; double x = NUM ; double y = NUM ; try { while ( more Records ) { result = is . read ( r Hdr , NUM , SHAPE RECORD HEADER LENGTH ) ; if ( result < NUM ) { more Records = BOOL ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + n Records + STRING ) ; logger . fine ( STRING + rec Buf Size ) ; } } else { n Records ++ ; rec Offset = ptr ; read BE Int ( r Hdr , NUM ) ; rec Length Words = read BE Int ( r Hdr , NUM ) ; rec Length Bytes = rec Length Words * NUM ; if ( rec Length Bytes > rec Buf Size ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + rec Length Bytes ) ; } rec Buf Size = rec Length Bytes ; rec Buf = new byte [ rec Buf Size ] ; } result = is . read ( rec Buf , NUM , rec Length Bytes ) ; shape Type = read LE Int ( rec Buf , NUM ) ; if ( shape Type != SHAPE TYPE NULL ) { x = read LE Double ( rec Buf , NUM ) ; y = read LE Double ( rec Buf , NUM ) ; } ptr += rec Length Bytes + NUM ; write BE Int ( out Buf , NUM , ( int ) ( rec Offset / NUM ) ) ; write BE Int ( out Buf , NUM , rec Length Words ) ; write LE Double ( out Buf , NUM , x ) ; write LE Double ( out Buf , NUM , y ) ; write LE Double ( out Buf , NUM , x ) ; write LE Double ( out Buf , NUM , y ) ; os . write ( out Buf , NUM , SPATIAL INDEX RECORD LENGTH ) ; } } } catch ( java . io . IO Exception e ) { e . print Stack Trace ( ) ; } finally { try { is . close ( ) ; } catch ( java . io . IO Exception e ) { } } }
public static String unsigned To String ( final int value ) { if ( value >= NUM ) { return Integer . to String ( value ) ; } else { return Long . to String ( value & NUM ) ; } }
public static List < File > find All ( File base File , String regex ) { Array List < File > found = new Array List < File > ( ) ; find All ( base File , regex , found ) ; return found ; }
public void append CSS Definition ( String Builder buf ) { buf . append ( STRING ) ; buf . append ( name ) ; buf . append ( STRING ) ; for ( Pair < String , String > pair : statements ) { buf . append ( pair . get First ( ) ) ; buf . append ( STRING ) ; buf . append ( pair . get Second ( ) ) ; buf . append ( STRING ) ; } buf . append ( STRING ) ; }
@ Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case Datatype Package . CONSTRAINT TYPE : return type != TYPE EDEFAULT ; case Datatype Package . CONSTRAINT CONSTRAINT VALUES : return CONSTRAINT VALUES EDEFAULT == null ? constraint Values != null : ! CONSTRAINT VALUES EDEFAULT . equals ( constraint Values ) ; } return super . e Is Set ( feature ID ) ; }
protected Object clone Object ( Object obj ) { if ( obj == null ) { return null ; } if ( obj instanceof String || obj instanceof Boolean || obj instanceof Byte || obj instanceof Short || obj instanceof Character || obj instanceof Integer || obj instanceof Long || obj instanceof Float || obj instanceof Double ) { return obj ; } if ( obj instanceof byte [ ] ) { byte [ ] body = ( byte [ ] ) obj ; byte [ ] data = new byte [ body . length ] ; System . arraycopy ( body , NUM , data , NUM , body . length ) ; return data ; } return Serialization Helper . deep Clone ( obj ) ; }
private void assert Write Varint ( byte [ ] data , long value ) throws Exception { if ( ( value > > > NUM ) == NUM ) { Byte Array Output Stream raw Output = new Byte Array Output Stream ( ) ; Coded Output Stream output = Coded Output Stream . new Instance ( raw Output ) ; output . write Raw Varint 32 ( ( int ) value ) ; output . flush ( ) ; assert Equal Bytes ( data , raw Output . to Byte Array ( ) ) ; assert Equals ( data . length , Coded Output Stream . compute Raw Varint 32 Size ( ( int ) value ) ) ; } { Byte Array Output Stream raw Output = new Byte Array Output Stream ( ) ; Coded Output Stream output = Coded Output Stream . new Instance ( raw Output ) ; output . write Raw Varint 64 ( value ) ; output . flush ( ) ; assert Equal Bytes ( data , raw Output . to Byte Array ( ) ) ; assert Equals ( data . length , Coded Output Stream . compute Raw Varint 64 Size ( value ) ) ; } for ( int block Size = NUM ; block Size <= NUM ; block Size *= NUM ) { if ( ( value > > > NUM ) == NUM ) { Byte Array Output Stream raw Output = new Byte Array Output Stream ( ) ; Coded Output Stream output = Coded Output Stream . new Instance ( raw Output , block Size ) ; output . write Raw Varint 32 ( ( int ) value ) ; output . flush ( ) ; assert Equal Bytes ( data , raw Output . to Byte Array ( ) ) ; } { Byte Array Output Stream raw Output = new Byte Array Output Stream ( ) ; Coded Output Stream output = Coded Output Stream . new Instance ( raw Output , block Size ) ; output . write Raw Varint 64 ( value ) ; output . flush ( ) ; assert Equal Bytes ( data , raw Output . to Byte Array ( ) ) ; } } }
public void attach ( Action Observer observer ) { observer . make One Time Use ( ) ; lock . lock ( ) ; try { once Used Observers . add ( observer ) ; } finally { lock . unlock ( ) ; } }
private void sign Certificate Chain ( ) { List < Certificate > cc = new Array List < > ( ) ; cc . add ( sign Cert ) ; List < Certificate > oc = new Array List < > ( certs ) ; for ( int k = NUM ; k < oc . size ( ) ; ++ k ) { if ( sign Cert . equals ( oc . get ( k ) ) ) { oc . remove ( k ) ; -- k ; } } boolean found = BOOL ; while ( found ) { X509 Certificate v = ( X509 Certificate ) cc . get ( cc . size ( ) - NUM ) ; found = BOOL ; for ( int k = NUM ; k < oc . size ( ) ; ++ k ) { X509 Certificate issuer = ( X509 Certificate ) oc . get ( k ) ; try { v . verify ( issuer . get Public Key ( ) , provider ) ; found = BOOL ; cc . add ( oc . get ( k ) ) ; oc . remove ( k ) ; break ; } catch ( Exception ignored ) { } } } sign Certs = cc ; }
public static String meter To String ( OF Instruction Meter inst , Logger log ) { return Long . to String ( inst . get Meter Id ( ) ) ; }
public String charset ( ) { return parameter ( HEADER CONTENT TYPE , PARAM CHARSET ) ; }
public Dimension minimum Layout Size ( Container parent ) { Dimension rd , mbd ; Insets i = get Insets ( ) ; if ( content Pane != null ) { rd = content Pane . get Minimum Size ( ) ; } else { rd = parent . get Size ( ) ; } if ( menu Bar != null && menu Bar . is Visible ( ) ) { mbd = menu Bar . get Minimum Size ( ) ; } else { mbd = new Dimension ( NUM , NUM ) ; } return new Dimension ( Math . max ( rd . width , mbd . width ) + i . left + i . right , rd . height + mbd . height + i . top + i . bottom ) ; }
@ Override public void add ( int location , E object ) { insert Element At ( object , location ) ; }
public static boolean check If Can Use ( String class Name ) { if ( Mock List . should Be Mocked ( class Name ) ) { return BOOL ; } for ( String s : class Exceptions ) { if ( class Name . starts With ( s ) ) { return BOOL ; } } return BOOL ; }
private static void apply Overrides ( ) { Input Stream stream = get Content Types Properties Stream ( ) ; if ( stream == null ) { return ; } try { try { Properties overrides = new Properties ( ) ; overrides . load ( stream ) ; for ( Map . Entry < Object , Object > entry : overrides . entry Set ( ) ) { String extension = ( String ) entry . get Key ( ) ; String mime Type = ( String ) entry . get Value ( ) ; add ( mime Type , extension ) ; } } finally { stream . close ( ) ; } } catch ( IO Exception ignored ) { } }
@ Override public void run ( ) { am I Active = BOOL ; String input Header = null ; String output Header = null ; int row , col ; float progress = NUM ; double max Patch Value = NUM ; int x , y ; boolean bln Found Neighbour ; boolean bln Include Diag Neighbour = BOOL ; boolean bln Treat Zeros As Background = BOOL ; int i ; if ( args . length <= NUM ) { show Feedback ( STRING ) ; return ; } for ( i = NUM ; i < args . length ; i ++ ) { if ( i == NUM ) { input Header = args [ i ] ; } else if ( i == NUM ) { output Header = args [ i ] ; } else if ( i == NUM ) { bln Include Diag Neighbour = Boolean . parse Boolean ( args [ i ] ) ; if ( ! bln Include Diag Neighbour ) { dX = new int [ ] { NUM , NUM , NUM , - NUM } ; dY = new int [ ] { - NUM , NUM , NUM , NUM } ; } } else if ( i == NUM ) { bln Treat Zeros As Background = Boolean . parse Boolean ( args [ i ] ) ; } } if ( ( input Header == null ) || ( output Header == null ) ) { show Feedback ( STRING ) ; return ; } try { num Scan Cells = dY . length ; image = new Whitebox Raster ( input Header , STRING ) ; int rows = image . get Number Rows ( ) ; int cols = image . get Number Columns ( ) ; no Data = image . get No Data Value ( ) ; double initial Value = - NUM ; output = new Whitebox Raster ( output Header , STRING , input Header , Whitebox Raster . Data Type . FLOAT , initial Value ) ; output . set Data Scale ( Whitebox Raster . Data Scale . CATEGORICAL ) ; output . set Preferred Palette ( STRING ) ; if ( bln Treat Zeros As Background ) { for ( row = NUM ; row < rows ; row ++ ) { for ( col = NUM ; col < cols ; col ++ ) { if ( image . get Value ( row , col ) == NUM ) { output . set Value ( row , col , NUM ) ; } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM * row / ( rows - NUM ) ) ; update Progress ( ( int ) progress ) ; } if ( output . get Value ( NUM , NUM ) == - NUM ) { output . set Value ( NUM , NUM , NUM ) ; } } else { output . set Value ( NUM , NUM , NUM ) ; } double patch Value = NUM ; double neighbour Patch Value = NUM ; double new Patch Value = NUM ; double image Value = NUM ; int loop Num = NUM ; update Progress ( STRING + loop Num + STRING , NUM ) ; for ( row = NUM ; row < rows ; row ++ ) { for ( col = NUM ; col < cols ; col ++ ) { image Value = image . get Value ( row , col ) ; if ( image Value != no Data ) { patch Value = output . get Value ( row , col ) ; if ( patch Value == initial Value ) { bln Found Neighbour = BOOL ; for ( i = NUM ; i < num Scan Cells ; i ++ ) { x = col + dX [ i ] ; y = row + dY [ i ] ; neighbour Patch Value = output . get Value ( y , x ) ; if ( neighbour Patch Value != initial Value && image . get Value ( y , x ) == image Value ) { output . set Value ( row , col , neighbour Patch Value ) ; new Patch Value = neighbour Patch Value ; bln Found Neighbour = BOOL ; break ; } } if ( ! bln Found Neighbour ) { max Patch Value ++ ; new Patch Value = max Patch Value ; output . set Value ( row , col , new Patch Value ) ; } depth = NUM ; Scan Connected Cells ( row , col , image Value , initial Value , new Patch Value ) ; } } else { output . set Value ( row , col , no Data ) ; } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM * row / ( rows - NUM ) ) ; update Progress ( ( int ) progress ) ; } boolean something Done ; double [ ] reclass = new double [ ( int ) max Patch Value + NUM ] ; do { loop Num ++ ; update Progress ( STRING + loop Num + STRING , NUM ) ; something Done = BOOL ; for ( row = NUM ; row < rows ; row ++ ) { for ( col = NUM ; col < cols ; col ++ ) { image Value = image . get Value ( row , col ) ; if ( image Value != no Data ) { patch Value = output . get Value ( row , col ) ; for ( i = NUM ; i < num Scan Cells ; i ++ ) { x = col + dX [ i ] ; y = row + dY [ i ] ; neighbour Patch Value = output . get Value ( y , x ) ; if ( neighbour Patch Value != patch Value && image . get Value ( y , x ) == image Value ) { something Done = BOOL ; if ( patch Value < neighbour Patch Value ) { reclass [ ( int ) neighbour Patch Value ] = - NUM ; output . set Value ( y , x , patch Value ) ; Scan Connected Cells ( y , x , image Value , neighbour Patch Value , patch Value ) ; } else { reclass [ ( int ) patch Value ] = - NUM ; output . set Value ( row , col , neighbour Patch Value ) ; Scan Connected Cells ( row , col , image Value , patch Value , neighbour Patch Value ) ; patch Value = neighbour Patch Value ; } } } } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM * row / ( rows - NUM ) ) ; update Progress ( ( int ) progress ) ; } } while ( something Done ) ; i = NUM ; for ( int a = NUM ; a < max Patch Value + NUM ; a ++ ) { if ( reclass [ a ] != - NUM ) { reclass [ a ] = i ; i ++ ; } } loop Num ++ ; update Progress ( STRING + loop Num + STRING , NUM ) ; for ( row = NUM ; row < rows ; row ++ ) { for ( col = NUM ; col < cols ; col ++ ) { patch Value = output . get Value ( row , col ) ; if ( patch Value != no Data ) { output . set Value ( row , col , reclass [ ( int ) patch Value ] ) ; } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM * row / ( rows - NUM ) ) ; update Progress ( ( int ) progress ) ; } output . add Metadata Entry ( STRING + get Descriptive Name ( ) + STRING ) ; output . add Metadata Entry ( STRING + new Date ( ) ) ; image . close ( ) ; output . close ( ) ; return Data ( output Header ) ; } catch ( Out Of Memory Error oe ) { my Host . show Feedback ( STRING ) ; } catch ( Exception e ) { my Host . show Feedback ( STRING ) ; my Host . log Exception ( STRING + get Descriptive Name ( ) , e ) ; } finally { update Progress ( STRING , NUM ) ; am I Active = BOOL ; my Host . plugin Complete ( ) ; } }
public static int read All ( Input Stream i , byte b [ ] ) throws IO Exception { int len = b . length ; int n = NUM ; while ( n < len ) { int count = i . read ( b , n , len - n ) ; if ( count < NUM ) { return n ; } n += count ; } return n ; }
public void switch To Simple ( Experiment exp ) { if ( exp == null ) { exp = m advanced Panel . get Experiment ( ) ; } if ( exp != null && ! m simple Panel . set Experiment ( exp ) ) { m Advanced Setup R But . set Selected ( BOOL ) ; switch To Advanced ( exp ) ; } else { remove ( m advanced Panel ) ; m advanced Panel . remove Notes Frame ( ) ; add ( m simple Panel , Border Layout . CENTER ) ; validate ( ) ; repaint ( ) ; } }
public static Cache Span create Cache Entry ( File file ) { Matcher matcher = CACHE FILE PATTERN V2 . matcher ( file . get Name ( ) ) ; if ( ! matcher . matches ( ) ) { return null ; } String key = Util . unescape File Name ( matcher . group ( NUM ) ) ; return key == null ? null : create Cache Entry ( key , Long . parse Long ( matcher . group ( NUM ) ) , Long . parse Long ( matcher . group ( NUM ) ) , file ) ; }
public boolean is Component Part Of Current Menu ( Component c ) { if ( selection . size ( ) > NUM ) { Menu Element me = selection . element At ( NUM ) ; return is Component Part Of Current Menu ( me , c ) ; } else return BOOL ; }
public static int hsba ( float h , float s , float b , float a ) { return set Alpha ( Color . HS Bto RGB ( h , s , b ) , ( int ) ( a * NUM + NUM ) & NUM ) ; }
Lambda Form Buffer replace Functions ( Named Function [ ] old Fns , Named Function [ ] new Fns , Object ... for Arguments ) { assert ( in Trans ( ) ) ; if ( old Fns . length == NUM ) return this ; for ( int i = arity ; i < length ; i ++ ) { Name n = names [ i ] ; int nfi = index Of ( n . function , old Fns ) ; if ( nfi >= NUM && Arrays . equals ( n . arguments , for Arguments ) ) { change Name ( i , new Name ( new Fns [ nfi ] , n . arguments ) ) ; } } return this ; }
@ Override public Client Socket open If Live ( ) { if ( state . is Closed ( ) ) { return null ; } Client Socket stream = open Recycle ( ) ; if ( stream != null ) return stream ; long now = Current Time . current Time ( ) ; if ( is Failed ( now ) ) return null ; else if ( state == State . FAIL && starting Count . get ( ) > NUM ) { return null ; } return connect ( ) ; }
public void commit ( ) { info ( STRING + solr Url + STRING ) ; do Get ( append Param ( solr Url . to String ( ) , STRING ) ) ; }
public abstract void files Dropped ( java . io . File [ ] files ) ;
protected void wait For Thread To Enter Wait State ( Thread thread , long timeout Millis ) { long start Time = NUM ; for ( ; ; ) { Thread . State s = thread . get State ( ) ; if ( s == Thread . State . BLOCKED || s == Thread . State . WAITING || s == Thread . State . TIMED WAITING ) return ; else if ( s == Thread . State . TERMINATED ) fail ( STRING ) ; else if ( start Time == NUM ) start Time = System . nano Time ( ) ; else if ( millis Elapsed Since ( start Time ) > timeout Millis ) { thread Assert True ( thread . is Alive ( ) ) ; return ; } Thread . yield ( ) ; } }
public void force Rewrite Exif ( String filename , Collection < Exif Tag > tags ) throws File Not Found Exception , IO Exception { if ( ! rewrite Exif ( filename , tags ) ) { Exif Data temp Data = m Data ; m Data = new Exif Data ( DEFAULT BYTE ORDER ) ; File Input Stream is = null ; Byte Array Output Stream bytes = null ; try { is = new File Input Stream ( filename ) ; bytes = new Byte Array Output Stream ( ) ; do Exif Stream IO ( is , bytes ) ; byte [ ] image Bytes = bytes . to Byte Array ( ) ; read Exif ( image Bytes ) ; set Tags ( tags ) ; write Exif ( image Bytes , filename ) ; } catch ( IO Exception e ) { close Silently ( is ) ; throw e ; } finally { is . close ( ) ; m Data = temp Data ; } } }
public static Lat Lng translate Point ( Lat Lng point , double distance , double bearing ) { distance = distance / NUM ; double lat = Math . to Radians ( point . latitude ) ; double lng = Math . to Radians ( point . longitude ) ; bearing = Math . to Radians ( bearing ) ; double Lat 2 = Math . asin ( ( Math . sin ( lat ) * Math . cos ( distance / EARTH ) ) + ( Math . cos ( lat ) * Math . sin ( distance / EARTH ) * Math . cos ( bearing ) ) ) ; double Long 2 = lng + Math . atan 2 ( Math . sin ( bearing ) * Math . sin ( distance / EARTH ) * Math . cos ( lat ) , Math . cos ( distance / EARTH ) - ( Math . sin ( lat ) * Math . sin ( Lat 2 ) ) ) ; Lat 2 = Math . to Degrees ( Lat 2 ) ; Long 2 = Math . to Degrees ( Long 2 ) ; return new Lat Lng ( Lat 2 , Long 2 ) ; }
public boolean init ( ) { log . config ( STRING ) ; M Client client = M Client . get ( Env . get Ctx ( ) ) ; String ASP Filter = STRING ; if ( client . is Use ASP ( ) ) ASP Filter = STRING + STRING + STRING + STRING + STRING + client . get AD Client ID ( ) + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + client . get AD Client ID ( ) + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + client . get AD Client ID ( ) + STRING + STRING + STRING + STRING + STRING ; String sql = null ; if ( Env . is Base Language ( Env . get Ctx ( ) , STRING ) ) sql = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + ASP Filter + STRING ; else sql = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + Env . get AD Language ( Env . get Ctx ( ) ) + STRING + STRING + ASP Filter + STRING ; boolean has Fields = BOOL ; Rows rows = new Rows ( ) ; try { Prepared Statement pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM , m process Info . get AD Process ID ( ) ) ; Result Set rs = pstmt . execute Query ( ) ; int field = NUM ; Row row = null ; while ( rs . next ( ) ) { has Fields = BOOL ; field ++ ; if ( field % NUM == NUM && mode == BROWSER MODE ) { row = create Field ( rs , rows , row ) ; } else { row = create Field ( rs , rows , null ) ; } } rs . close ( ) ; pstmt . close ( ) ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } if ( m m Fields . size ( ) != m m Fields 2 . size ( ) || m m Fields . size ( ) != m w Editors . size ( ) || m m Fields 2 . size ( ) != m w Editors 2 . size ( ) ) log . log ( Level . SEVERE , STRING ) ; if ( has Fields ) { center Panel . append Child ( rows ) ; dynamic Display ( ) ; } else dispose ( ) ; return has Fields ; }
public static String detect Properties Path ( ) { String override = System . get Property ( STRING ) ; if ( override != null ) { return override ; } String jar Path = detect Jar Path ( ) ; String prop File = Constants . PROPS FILE + STRING ; return fix Whitespaces ( get Parent Directory ( jar Path ) + File . separator + prop File ) ; }
static int format Float ( final char [ ] out , float val , int digits ) { boolean negative = BOOL ; if ( val == NUM ) { out [ NUM ] = STRING ; return NUM ; } if ( val < NUM ) { negative = BOOL ; val = - val ; } if ( digits >= POW 10 . length ) { digits = POW 10 . length - NUM ; } val *= POW 10 [ digits ] ; long lval = Math . round ( val ) ; int index = out . length - NUM ; int char Count = NUM ; while ( lval != NUM || char Count < ( digits + NUM ) ) { int digit = ( int ) ( lval % NUM ) ; lval = lval / NUM ; out [ index -- ] = ( char ) ( digit + STRING ) ; char Count ++ ; if ( char Count == digits ) { out [ index -- ] = STRING ; char Count ++ ; } } if ( negative ) { out [ index ] = STRING ; char Count ++ ; } return char Count ; }
public void accept Package ( char [ ] package Name ) { }
public void resume ( ) { m Paused = BOOL ; m Last Frame Time = System . current Time Millis ( ) ; invalidate ( ) ; }
public Gaussian Density Function ( Double mean , Double variance ) { this . mean = new double [ ] { mean } ; this . variance = new double [ ] { variance } ; std Dev = new double [ ] { Math . sqrt ( variance ) } ; if ( variance < NUM ) { log . warning ( STRING + variance ) ; } }
int encrypt Final ( byte [ ] in , int in Ofs , int len , byte [ ] out , int out Ofs ) throws Illegal Block Size Exception , Short Buffer Exception { if ( out . length - out Ofs < ( len + tag Len Bytes ) ) { throw new Short Buffer Exception ( STRING ) ; } process AAD ( ) ; if ( len > NUM ) { do Last Block ( in , in Ofs , len , out , out Ofs , BOOL ) ; } byte [ ] length Block = get Length Block ( size Of AAD * NUM , processed * NUM ) ; ghash All To S . update ( length Block ) ; byte [ ] s = ghash All To S . digest ( ) ; byte [ ] s Out = new byte [ s . length ] ; GCTR gctr For S To Tag = new GCTR ( embedded Cipher , this . pre Counter Block ) ; gctr For S To Tag . do Final ( s , NUM , s . length , s Out , NUM ) ; System . arraycopy ( s Out , NUM , out , ( out Ofs + len ) , tag Len Bytes ) ; return ( len + tag Len Bytes ) ; }
private float interpolate ( ) { long curr Time = System . current Time Millis ( ) ; float elapsed = ( curr Time - start Time ) / ZOOM TIME ; elapsed = Math . min ( NUM , elapsed ) ; return interpolator . get Interpolation ( elapsed ) ; }
public static String component To Image Col Name ( String component ) { if ( component . equals ( Mixn Match Columns . KEY HOMESCREEN ) ) { return Themes Columns . HOMESCREEN URI ; } else if ( component . equals ( Mixn Match Columns . KEY LOCKSCREEN ) ) { return Themes Columns . LOCKSCREEN URI ; } else if ( component . equals ( Mixn Match Columns . KEY BOOT ANIM ) ) { return Themes Columns . BOOT ANIM URI ; } else if ( component . equals ( Mixn Match Columns . KEY FONT ) ) { return Themes Columns . FONT URI ; } else if ( component . equals ( Mixn Match Columns . KEY ICONS ) ) { return Themes Columns . ICON URI ; } else if ( component . equals ( Mixn Match Columns . KEY STATUS BAR ) ) { return Themes Columns . STATUSBAR URI ; } else if ( component . equals ( Mixn Match Columns . KEY NOTIFICATIONS ) ) { throw new Illegal Argument Exception ( STRING ) ; } else if ( component . equals ( Mixn Match Columns . KEY RINGTONE ) ) { throw new Illegal Argument Exception ( STRING ) ; } else if ( component . equals ( Mixn Match Columns . KEY OVERLAYS ) ) { return Themes Columns . OVERLAYS URI ; } else if ( component . equals ( Mixn Match Columns . KEY ALARM ) ) { throw new Illegal Argument Exception ( STRING ) ; } else if ( component . equals ( Mixn Match Columns . KEY NAVIGATION BAR ) ) { throw new Illegal Argument Exception ( STRING ) ; } else if ( component . equals ( Mixn Match Columns . KEY LIVE LOCK SCREEN ) ) { throw new Illegal Argument Exception ( STRING ) ; } return null ; }
public boolean is Abstract ( ) { return Modifier . is Abstract ( method . get Modifiers ( ) ) ; }
public void node Clicked ( Request Invocation Event event , int node ID ) { boolean forward To = BOOL ; String str Node Id = Integer . to String ( node ID ) ; if ( str Node Id . length ( ) > NUM ) { String prefix = str Node Id . substring ( NUM , NUM ) ; if ( prefix . equals ( AM Admin Constants . TAB AGENT PREFIX ) ) { set Page Session Attribute ( get Tracking Tab ID Name ( ) , Integer . to String ( node ID ) ) ; AM View Config amconfig = AM View Config . get Instance ( ) ; List list = amconfig . get Supported Agent Types ( get Model ( ) ) ; str Node Id = str Node Id . substring ( NUM ) ; int idx = Integer . parse Int ( str Node Id ) ; if ( idx < list . size ( ) ) { set Page Session Attribute ( PG SESSION AGENT TYPE , ( String ) list . get ( idx ) ) ; AM Post View Bean vb = ( AM Post View Bean ) get View Bean ( AM Post View Bean . class ) ; pass Pg Session Map ( vb ) ; vb . set Target View Bean URL ( STRING ) ; vb . forward To ( get Request Context ( ) ) ; forward To = BOOL ; } } } if ( ! forward To ) { try { AM View Bean Base vb = get Tab Node Associated View Bean ( STRING , node ID ) ; String tmp = ( String ) get Page Session Attribute ( AM Admin Constants . PREVIOUS REALM ) ; vb . set Page Session Attribute ( AM Admin Constants . PREVIOUS REALM , tmp ) ; tmp = ( String ) get Page Session Attribute ( AM Admin Constants . CURRENT REALM ) ; vb . set Page Session Attribute ( AM Admin Constants . CURRENT REALM , tmp ) ; tmp = ( String ) get Page Session Attribute ( AM Admin Constants . PREVIOUS TAB ID ) ; vb . set Page Session Attribute ( AM Admin Constants . PREVIOUS TAB ID , tmp ) ; unlock Page Trail For Swapping ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { debug . error ( STRING , e ) ; forward To ( ) ; } } }
private static void parse Copy Fields ( Parse Context context , Field Mapper field Mapper , List < String > copy To Fields ) throws IO Exception { if ( ! context . is Within Copy To ( ) && copy To Fields . is Empty ( ) == BOOL ) { context = context . create Copy To Context ( ) ; for ( String field : copy To Fields ) { Parse Context . Document target Doc = null ; for ( Parse Context . Document doc = context . doc ( ) ; doc != null ; doc = doc . get Parent ( ) ) { if ( field . starts With ( doc . get Prefix ( ) ) ) { target Doc = doc ; break ; } } assert target Doc != null ; final Parse Context copy To Context ; if ( target Doc == context . doc ( ) ) { copy To Context = context ; } else { copy To Context = context . switch Doc ( target Doc ) ; } parse Copy ( field , copy To Context ) ; } } }
protected File create Obb File ( String name , int raw Res Id ) { File out File = null ; try { final File files Dir = m Context . get Files Dir ( ) ; out File = new File ( files Dir , name ) ; copy Raw To File ( raw Res Id , out File ) ; } catch ( Not Found Exception e ) { if ( out File != null ) { out File . delete ( ) ; } } return out File ; }
public Play Sound Entity ( String sound , int radius , int volume ) { this . sounds = sound . split ( STRING ) ; this . radius = radius ; this . volume = volume ; }
public Repository ( String domain ) { this ( domain , BOOL ) ; }
private void update View ( int view Position ) { notify Item Changed ( view Position ) ; }
public static String optimize ( String ... args ) { return simple Tag ( STRING , args ) ; }
protected boolean is Valid Server ( final String server ) { boolean is Valid = check Server Prefixes ( server ) ; if ( is Valid ) { if ( server . starts With ( STRING ) ) { is Valid = can Connect ( server ) ; } else if ( server . starts With ( STRING ) ) { is Valid = is Directory ( server ) ; } } return is Valid ; }
public Concurrent Hash Map ( Map < ? extends K , ? extends V > m ) { this ( Math . max ( ( int ) ( m . size ( ) / DEFAULT LOAD FACTOR ) + NUM , DEFAULT INITIAL CAPACITY ) , DEFAULT LOAD FACTOR , DEFAULT CONCURRENCY LEVEL ) ; put All ( m ) ; }
public Map Maker expiration ( long duration , Time Unit unit ) { if ( expiration Nanos != NUM ) { throw new Illegal State Exception ( STRING + expiration Nanos + STRING ) ; } if ( duration <= NUM ) { throw new Illegal Argument Exception ( STRING + duration ) ; } this . expiration Nanos = unit . to Nanos ( duration ) ; use Custom Map = BOOL ; return this ; }
void init From Node ( final Node from Node , final double start Time , final Pseudo Remove Priority Queue < Node > pending Nodes ) { Dijkstra Node Data data = get Data ( from Node ) ; visit Node ( from Node , data , pending Nodes , start Time , NUM , null ) ; }
public Collection < HTML Token > tokenize HTML ( ) { List < HTML Token > tokens = new Array List < HTML Token > ( ) ; String nested Tags = nested Tags Regex ( NUM ) ; Pattern p = Pattern . compile ( STRING + STRING + STRING + STRING + STRING + nested Tags + STRING , Pattern . CASE INSENSITIVE ) ; Matcher m = p . matcher ( text ) ; int last Pos = NUM ; while ( m . find ( ) ) { if ( last Pos < m . start ( ) ) { tokens . add ( HTML Token . text ( text . substring ( last Pos , m . start ( ) ) ) ) ; } tokens . add ( HTML Token . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; last Pos = m . end ( ) ; } if ( last Pos < text . length ( ) ) { tokens . add ( HTML Token . text ( text . substring ( last Pos , text . length ( ) ) ) ) ; } return tokens ; }
public int decrypt Block ( byte [ ] in , int in Off , byte [ ] out , int out Off ) throws Data Length Exception , Illegal State Exception { if ( ( in Off + block Size ) > in . length ) { throw new Data Length Exception ( STRING ) ; } if ( ( out Off + block Size ) > out . length ) { throw new Data Length Exception ( STRING ) ; } cipher . process Block ( cfb V , NUM , cfb Out V , NUM ) ; System . arraycopy ( cfb V , block Size , cfb V , NUM , cfb V . length - block Size ) ; System . arraycopy ( in , in Off , cfb V , cfb V . length - block Size , block Size ) ; for ( int i = NUM ; i < block Size ; i ++ ) { out [ out Off + i ] = ( byte ) ( cfb Out V [ i ] ^ in [ in Off + i ] ) ; } return block Size ; }
private String compute Md 5 Hash ( String buffer ) { Message Digest md ; try { md = Message Digest . get Instance ( STRING ) ; return bytes To Hex ( md . digest ( buffer . get Bytes ( STRING ) ) ) ; } catch ( No Such Algorithm Exception ignore ) { } catch ( Unsupported Encoding Exception e ) { } return STRING ; }
public static void check Argument ( boolean expression , @ Nullable Object error Message ) { if ( ! expression ) { throw new Illegal Argument Exception ( String . value Of ( error Message ) ) ; } }
public void run ( ) throws IO Exception , Interrupted Exception { for ( int i = NUM ; i < conn Cnt ; i ++ ) exec . submit ( new Client Thread ( ) ) ; Thread . sleep ( NUM * NUM * NUM ) ; exec . shutdown Now ( ) ; }
public static String pluralize ( String word ) { if ( word == null ) { throw new Illegal Argument Exception ( ) ; } final String lower Case Word = word . to Lower Case ( ) ; if ( ends With Any ( lower Case Word , STRING , STRING , STRING ) ) { return word + STRING ; } if ( lower Case Word . ends With ( STRING ) && ! lower Case Word . ends With ( STRING ) || ends With Any ( lower Case Word , STRING , STRING , STRING ) ) { return word . substring ( NUM , word . length ( ) - NUM ) + STRING ; } else { return word + STRING ; } }
protected void on Network Type Change ( Network Info old Network , Network Info new Network ) throws Router Exception { log . info ( String . format ( STRING , old Network == null ? STRING : old Network . get Type Name ( ) , new Network == null ? STRING : new Network . get Type Name ( ) ) ) ; if ( disable ( ) ) { log . info ( String . format ( STRING , old Network == null ? STRING : old Network . get Type Name ( ) ) ) ; } network Info = new Network ; if ( enable ( ) ) { log . info ( String . format ( STRING , new Network == null ? STRING : new Network . get Type Name ( ) ) ) ; } }
private Linked Hash Map < Term , Integer > repeating Terms ( ) { Linked Hash Map < Term , Integer > tord = new Linked Hash Map < > ( ) ; Hash Map < Term , Integer > tcnt = new Hash Map < > ( ) ; for ( Phrase Positions pp : phrase Positions ) { for ( Term t : pp . terms ) { Integer cnt 0 = tcnt . get ( t ) ; Integer cnt = cnt 0 == null ? new Integer ( NUM ) : new Integer ( NUM + cnt 0 . int Value ( ) ) ; tcnt . put ( t , cnt ) ; if ( cnt == NUM ) { tord . put ( t , tord . size ( ) ) ; } } } return tord ; }
public List < Inet Address > discover Hosts ( int udp Port , int timeout Millis ) { List < Inet Address > hosts = new Array List < Inet Address > ( ) ; Datagram Socket socket = null ; try { socket = new Datagram Socket ( ) ; broadcast ( udp Port , socket ) ; socket . set So Timeout ( timeout Millis ) ; while ( BOOL ) { Datagram Packet packet = new Datagram Packet ( new byte [ NUM ] , NUM ) ; try { socket . receive ( packet ) ; } catch ( Socket Timeout Exception ex ) { if ( INFO ) info ( STRING , STRING ) ; return hosts ; } if ( INFO ) info ( STRING , STRING + packet . get Address ( ) ) ; hosts . add ( packet . get Address ( ) ) ; } } catch ( IO Exception ex ) { if ( ERROR ) error ( STRING , STRING , ex ) ; return hosts ; } finally { if ( socket != null ) socket . close ( ) ; } }
protected void reload Cluster Configuration ( ) { synchronized ( this . cluster ) { load Cluster Configuration ( ) ; } }
public double expected Utility ( Nondominated Population population ) { double sum = NUM ; for ( int i = NUM ; i < weights . length ; i ++ ) { double max = Double . NEGATIVE INFINITY ; for ( Solution solution : population ) { max = Math . max ( max , utility Function . compute Utility ( solution , weights [ i ] ) ) ; } sum += max ; } return sum / weights . length ; }
public void count ( Hash Map < String , Tree Map < String , Integer > > table , String suffix , String tag ) { Tree Map < String , Integer > counts = table . get ( suffix ) ; if ( counts == null ) { counts = new Tree Map < String , Integer > ( ) ; table . put ( suffix , counts ) ; } Integer count = counts . get ( tag ) ; if ( count == null ) count = NUM ; counts . put ( tag , count + NUM ) ; }
public void add Input Mode ( String mode , String [ ] [ ] input Chars ) { modes Map . put ( mode , input Chars ) ; }
public static void sleep ( int msec ) throws Interrupted Exception { Thread . sleep ( msec ) ; }
public static java . util . Date to Date ( String month Str , String day Str , String year Str , String hour Str , String minute Str , String second Str ) { int month , day , year , hour , minute , second ; try { month = Integer . parse Int ( month Str ) ; day = Integer . parse Int ( day Str ) ; year = Integer . parse Int ( year Str ) ; hour = Integer . parse Int ( hour Str ) ; minute = Integer . parse Int ( minute Str ) ; second = Integer . parse Int ( second Str ) ; } catch ( Exception e ) { return null ; } return to Date ( month , day , year , hour , minute , second ) ; }
public void property Change ( Property Change Event pce ) { if ( pce . get Property Name ( ) == OM Drawing Tool . Loaders Property ) { Object obj = pce . get New Value ( ) ; if ( obj instanceof Vector ) { Vector < Edit Tool Loader > loaders = ( Vector < Edit Tool Loader > ) obj ; set Loaders ( loaders . iterator ( ) ) ; reset GUI ( ) ; } } }
public void remove App Offer ( Offer offer ) { int index To Remove = get Index ( offer ) ; if ( index To Remove != - NUM ) { app Offers . remove ( index To Remove ) ; notify Data Set Changed ( ) ; } }
public Data transform ( Data data , XML Crypto Context xc ) throws Transform Exception { return spi . transform ( data , xc ) ; }
public static int compare ( Comparable c1 , Comparable c2 , boolean null Greater ) { if ( c1 == c2 ) { return NUM ; } else if ( c1 == null ) { return ( null Greater ? NUM : - NUM ) ; } else if ( c2 == null ) { return ( null Greater ? - NUM : NUM ) ; } return c1 . compare To ( c2 ) ; }
public static double quantile ( double val , double mu , double sigma , double xi ) { if ( val < NUM || val > NUM ) { return Double . Na N ; } if ( xi == NUM ) { return mu - sigma * Math . log ( NUM - val ) ; } return mu - sigma / xi * ( NUM - Math . pow ( NUM - val , - xi ) ) ; }
Oath Device Settings create Device Profile ( int min Shared Secret Length ) { Reject . if False ( min Shared Secret Length >= NUM , STRING ) ; int shared Secret Byte Length = Math . max ( MIN SHARED SECRET BYTE LENGTH , ( int ) Math . ceil ( min Shared Secret Length / NUM ) ) ; byte [ ] secret Bytes = new byte [ shared Secret Byte Length ] ; secure Random . next Bytes ( secret Bytes ) ; String shared Secret = Datatype Converter . print Hex Binary ( secret Bytes ) ; return new Oath Device Settings ( shared Secret , DEVICE NAME , INITIAL LAST LOGIN TIME , INITIAL COUNTER VALUE ) ; }
public final void delete Selected Objects ( ) { Component [ ] components = get Components ( ) ; List < Display Node > graph Nodes = new Array List < > ( ) ; List < I Display Edge > graph Edges = new Array List < > ( ) ; for ( Component comp : components ) { if ( comp instanceof Display Node ) { if ( ! is Delete Variables Allowed ( ) ) { continue ; } Display Node node = ( Display Node ) comp ; if ( node . is Selected ( ) ) { graph Nodes . add ( node ) ; } } else if ( comp instanceof I Display Edge ) { I Display Edge edge = ( I Display Edge ) comp ; if ( edge . is Selected ( ) ) { graph Edges . add ( edge ) ; } } } for ( Display Node graph Node : graph Nodes ) { remove Node ( graph Node ) ; } for ( I Display Edge display Edge : graph Edges ) { try { remove Edge ( display Edge ) ; reset Edge Offsets ( display Edge ) ; } catch ( Exception e ) { if ( is Node Edge Errors Reported ( ) ) { J Option Pane . show Message Dialog ( J Option Utils . centering Comp ( ) , e . get Message ( ) ) ; } } } }
protected final void init Statistics ( String who , String [ ] header Lines ) throws Ade Exception { set Stats File Path ( ) ; if ( stats File Path == null ) { throw new Ade Internal Exception ( STRING ) ; } append Stat String ( SPACER ) ; append Stat String ( String . format ( STRING , current Time Stamp ( ) , who ) ) ; append Stat String ( SPACER ) ; for ( int i = NUM ; i < header Lines . length ; i ++ ) { append Stat String ( header Lines [ i ] ) ; } append Stat String ( SPACER ) ; }
public static Map < String , Object > day End Capacity Available ( Generic Value tech Data Calendar Week , int day End ) { Map < String , Object > result = Fast Map . new Instance ( ) ; int move Day = NUM ; Double capacity = null ; Time start Time = null ; while ( capacity == null || capacity . double Value ( ) == NUM ) { switch ( day End ) { case Calendar . MONDAY : capacity = tech Data Calendar Week . get Double ( STRING ) ; start Time = tech Data Calendar Week . get Time ( STRING ) ; break ; case Calendar . TUESDAY : capacity = tech Data Calendar Week . get Double ( STRING ) ; start Time = tech Data Calendar Week . get Time ( STRING ) ; break ; case Calendar . WEDNESDAY : capacity = tech Data Calendar Week . get Double ( STRING ) ; start Time = tech Data Calendar Week . get Time ( STRING ) ; break ; case Calendar . THURSDAY : capacity = tech Data Calendar Week . get Double ( STRING ) ; start Time = tech Data Calendar Week . get Time ( STRING ) ; break ; case Calendar . FRIDAY : capacity = tech Data Calendar Week . get Double ( STRING ) ; start Time = tech Data Calendar Week . get Time ( STRING ) ; break ; case Calendar . SATURDAY : capacity = tech Data Calendar Week . get Double ( STRING ) ; start Time = tech Data Calendar Week . get Time ( STRING ) ; break ; case Calendar . SUNDAY : capacity = tech Data Calendar Week . get Double ( STRING ) ; start Time = tech Data Calendar Week . get Time ( STRING ) ; break ; } if ( capacity == null || capacity . double Value ( ) == NUM ) { move Day -= NUM ; day End = ( day End == NUM ) ? NUM : day End - NUM ; } } result . put ( STRING , capacity ) ; result . put ( STRING , start Time ) ; result . put ( STRING , Integer . value Of ( move Day ) ) ; return result ; }
protected void add Class Path ( String classpath ) { if ( classpath == null ) return ; String sep = classpath . index Of ( STRING ) == - NUM ? STRING : STRING ; String [ ] parse Cp = classpath . split ( sep ) ; for ( String cp Entry : parse Cp ) { add Entry ( cp Entry ) ; } }
@ Inject Entry Uploader Impl ( Entry Inserter entry Inserter , Entry Provider entry Provider , Entry Updater entry Updater ) { this . entry Inserter = check Not Null ( entry Inserter ) ; this . entry Provider = check Not Null ( entry Provider ) ; this . entry Updater = check Not Null ( entry Updater ) ; }
protected void add ( long bytes In , long bytes Out ) { total Bytes In . add And Get ( bytes In ) ; total Bytes Out . add And Get ( bytes Out ) ; }
public static double vector Distance ( double [ ] vec 1 , double [ ] vec 2 , double power , double one Over Power ) { double result = NUM ; if ( power == NUM ) { for ( int i = NUM ; i < vec 1 . length ; i ++ ) { result += vec 1 [ i ] - vec 2 [ i ] == NUM ? NUM : NUM ; } } else if ( power == NUM ) { for ( int i = NUM ; i < vec 1 . length ; i ++ ) { result += Math . abs ( vec 1 [ i ] - vec 2 [ i ] ) ; } } else if ( power == NUM ) { result = Math . sqrt ( dist Squared Cartesian ( vec 1 , vec 2 ) ) ; } else if ( power == Integer . MAX VALUE || Double . is Infinite ( power ) ) { for ( int i = NUM ; i < vec 1 . length ; i ++ ) { result = Math . max ( result , Math . max ( vec 1 [ i ] , vec 2 [ i ] ) ) ; } } else { for ( int i = NUM ; i < vec 1 . length ; i ++ ) { result += Math . pow ( vec 1 [ i ] - vec 2 [ i ] , power ) ; } result = Math . pow ( result , one Over Power ) ; } return result ; }
public static float [ ] random Vector ( int a Size , long seed ) { Random rand = new Random ( seed ) ; float [ ] unk = new float [ a Size ] ; for ( int i = NUM ; i < unk . length ; i ++ ) { unk [ i ] = ( rand . next Float ( ) - NUM ) / a Size ; } return unk ; }
public boolean was Raw ( ) { return was Raw ; }
public Table find Table ( String catalog Name , String schema Name , String table Name , boolean case Sensitive ) { String cache Key = catalog Name + STRING + schema Name + STRING + table Name + STRING + case Sensitive ; Integer table Index = table Index Cache . get ( cache Key ) ; if ( table Index != null ) { if ( table Index < get Table Count ( ) ) { Table table = get Table ( table Index ) ; if ( does Match ( table , catalog Name , schema Name , table Name , case Sensitive ) ) { return table ; } } } Table [ ] tables = get Tables ( ) ; for ( int i = NUM ; i < tables . length ; i ++ ) { Table table = tables [ i ] ; if ( does Match ( table , catalog Name , schema Name , table Name , case Sensitive ) ) { table Index Cache . put ( cache Key , i ) ; return table ; } } return null ; }
public void test Domain Matches On Local Addresses ( ) { assert False ( Http Cookie . domain Matches ( STRING , STRING ) ) ; assert False ( Http Cookie . domain Matches ( STRING , STRING ) ) ; }
public void flush ( ) { write Data Block ( ) ; }
protected CRFP Coverage Box [ ] vector To CRFP Coverage Boxes ( Vector vector ) { int size = vector . size ( ) ; CRFP Coverage Box [ ] rets = new CRFP Coverage Box [ size ] ; for ( int i = NUM ; i < size ; i ++ ) { Rpf Coverage Box box = ( Rpf Coverage Box ) vector . element At ( i ) ; if ( box != null ) { rets [ i ] = new CRFP Coverage Box ( ( float ) box . nw lat , ( float ) box . nw lon , ( float ) box . se lat , ( float ) box . se lon , box . subframe Lat Interval , box . subframe Lon Interval , box . chart Code , ( short ) box . zone , new XY Point ( ( short ) box . start Indexes . x , ( short ) box . start Indexes . y ) , new XY Point ( ( short ) box . end Indexes . x , ( short ) box . end Indexes . y ) , ( short ) box . toc Number , ( short ) box . entry Number , box . scale , box . percent Coverage ) ; } } return rets ; }
public void notify Listeners Of Initialization ( ) { if ( initialized ) { for ( Action Listener l : listeners ) { l . action Performed ( new Action Event ( this , Action Event . ACTION PERFORMED , STRING ) ) ; } } }
public void check Password ( String password ) throws Bad Request Exception { if ( password == null ) { throw new Bad Request Exception ( STRING ) ; } if ( password . length ( ) < NUM ) { throw new Bad Request Exception ( STRING ) ; } int num Of Letters = NUM ; int num Of Digits = NUM ; for ( char password Char : password . to Char Array ( ) ) { if ( Character . is Digit ( password Char ) ) { num Of Digits ++ ; } else if ( Character . is Letter ( password Char ) ) { num Of Letters ++ ; } } if ( num Of Digits == NUM || num Of Letters == NUM ) { throw new Bad Request Exception ( STRING ) ; } }
final Node < K , V > find ( int h , Object k ) { if ( k != null ) { for ( Node < K , V > e = first ; e != null ; ) { int s ; K ek ; if ( ( ( s = lock State ) & ( WAITER | WRITER ) ) != NUM ) { if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; e = e . next ; } else if ( U . compare And Swap Int ( this , LOCKSTATE , s , s + READER ) ) { Tree Node < K , V > r , p ; try { p = ( ( r = root ) == null ? null : r . find Tree Node ( h , k , null ) ) ; } finally { Thread w ; if ( U . get And Add Int ( this , LOCKSTATE , - READER ) == ( READER | WAITER ) && ( w = waiter ) != null ) Lock Support . unpark ( w ) ; } return p ; } } } return null ; }
@ Suppress Warnings ( STRING ) private void collect All Regions Details ( System Member Cache Jmx Impl cache , Region Sub Region Snapshot region Snapshot , Map < String , Map < String , ? > > regions Info , Map < String , Object Name > existing Region Mbeans ) throws Admin Exception , Operations Exception , M Bean Exception , Reflection Exception { String full Path = region Snapshot . get Full Path ( ) ; if ( ! full Path . equals ( PLACE HOLDER ROOT REGION ) ) { full Path = full Path . substring ( PLACE HOLDER ROOT REGION . length ( ) - NUM ) ; String name = region Snapshot . get Name ( ) ; Integer entry Count = Integer . value Of ( region Snapshot . get Entry Count ( ) ) ; Map < String , Object > details = new Tree Map < String , Object > ( ) ; details . put ( REGION NAME , name ) ; details . put ( REGION PATH , full Path ) ; details . put ( REGION ENTRYCOUNT , entry Count ) ; Object Name region Object Name = existing Region Mbeans . get ( full Path ) ; if ( region Object Name == null ) { region Object Name = cache . manage Region ( full Path ) ; } Object attribute = get Attribute ( region Object Name , STRING , NOT AVAILABLE ) ; attribute = attribute != null ? attribute . to String ( ) : attribute ; details . put ( REGION SCOPE , attribute ) ; attribute = get Attribute ( region Object Name , STRING , NOT AVAILABLE ) ; attribute = attribute != null ? attribute . to String ( ) : attribute ; details . put ( REGION DATAPOLICY , attribute ) ; Subscription Attributes interest Policy Attr = ( Subscription Attributes ) get Attribute ( region Object Name , STRING , null ) ; String interest Policy Str = NOT AVAILABLE ; if ( interest Policy Attr != null ) { Interest Policy interest Policy = interest Policy Attr . get Interest Policy ( ) ; if ( interest Policy != null ) { interest Policy Str = interest Policy . to String ( ) ; } } details . put ( REGION INTERESTPOLICY , interest Policy Str ) ; attribute = get Attribute ( region Object Name , STRING , NOT AVAILABLE ) ; attribute = attribute != null ? attribute . to String ( ) : attribute ; details . put ( REGION DISKATTRS , attribute ) ; regions Info . put ( full Path , details ) ; } Set sub Region Snapshots = region Snapshot . get Sub Region Snapshots ( ) ; for ( Iterator iterator = sub Region Snapshots . iterator ( ) ; iterator . has Next ( ) ; ) { Region Sub Region Snapshot sub Region = ( Region Sub Region Snapshot ) iterator . next ( ) ; collect All Regions Details ( cache , sub Region , regions Info , existing Region Mbeans ) ; } }
public synchronized boolean remove Suspended Response ( Worker Category category , Response response ) { Deque < Response > deque = workers By Category . get ( category ) ; if ( deque == null ) { return BOOL ; } if ( deque . remove ( response ) ) { n Waiting Consumers -= NUM ; LOG . debug ( STRING ) ; return BOOL ; } return BOOL ; }
public static Number sin ( Number a ) { return Math . sin ( a . double Value ( ) ) ; }
private Typed Class Operation instantiate Operation Types ( Typed Class Operation operation ) { List < Type Variable > type Parameters = operation . get Type Parameters ( ) ; if ( type Parameters . is Empty ( ) ) { return operation ; } Substitution < Reference Type > substitution = select Substitution ( type Parameters ) ; if ( substitution == null ) { return null ; } return operation . apply ( substitution ) ; }
default T fold ( final T identity , final Binary Operator < T > accumulator ) { final Optional < T > opt = to Optional ( ) ; if ( opt . is Present ( ) ) return accumulator . apply ( identity , get ( ) ) ; return identity ; }
protected void load ( String filename , Properties p ) throws File Not Found Exception { File file = new File ( filename ) ; if ( ! file . exists ( ) ) throw new File Not Found Exception ( filename ) ; classifier = new CRF Classifier < Core Label > ( p ) ; try { classifier . load Classifier ( file , p ) ; } catch ( Class Cast Exception e ) { e . print Stack Trace ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } catch ( Class Not Found Exception e ) { e . print Stack Trace ( ) ; } }
public String resolve Font ( java . awt . Font font ) { String ret = STRING ; ret = ret . concat ( STRING + font . get Name ( ) ) ; if ( font . is Bold ( ) ) ret = ret . concat ( STRING ) ; else ret = ret . concat ( STRING ) ; if ( font . is Italic ( ) ) ret = ret . concat ( STRING ) ; else ret = ret . concat ( STRING ) ; ret = ret . concat ( STRING ) ; ret = ret . concat ( STRING + font . get Size ( ) ) ; ret = ret . concat ( STRING ) ; ret = ret . concat ( STRING ) ; ret = ret . concat ( STRING ) ; ret = ret . concat ( STRING ) ; ret = ret . concat ( STRING ) ; ret = ret . concat ( STRING ) ; return ret ; }
public void add Line Content ( final Zy Line Content line ) { Preconditions . check Not Null ( line , STRING ) ; m content . add ( line ) ; }
public static boolean exclude By Package ( String pkg , List < String > exclude Pkg ) { for ( String ep : exclude Pkg ) { if ( pkg . matches ( ep ) ) { return BOOL ; } } return BOOL ; }
public Region Version Holder ( long ver ) { this . version = ver ; }
public static void write Fully ( File Channel file , long pos , Byte Buffer src ) { try { int off = NUM ; do { int len = file . write ( src , pos + off ) ; off += len ; } while ( src . remaining ( ) > NUM ) ; } catch ( IO Exception e ) { throw new Illegal State Exception ( ERROR WRITING FAILED , STRING , file , src . remaining ( ) , pos , e ) ; } }
public void update Request Timeout ( Time Span span ) throws Security Exception , Application Exception { check Write Access ( ) ; boolean has Access = Config Web Util . has Access ( config , Security Manager . TYPE SETTING ) ; if ( ! has Access ) throw new Security Exception ( STRING ) ; Element scope = get Root Element ( STRING ) ; Element application = get Root Element ( STRING ) ; if ( span != null ) { if ( span . get Millis ( ) <= NUM ) throw new Application Exception ( STRING ) ; application . set Attribute ( STRING , span . get Day ( ) + STRING + span . get Hour ( ) + STRING + span . get Minute ( ) + STRING + span . get Second ( ) ) ; } else application . remove Attribute ( STRING ) ; if ( scope . has Attribute ( STRING ) ) scope . remove Attribute ( STRING ) ; }
@ Override protected boolean calc Problem ( ) { String type = get Tag With Key ( Tags . KEY TYPE ) ; if ( type == null || type . equals ( STRING ) ) { return BOOL ; } return super . calc Problem ( ) ; }
public int read Byte ( ) throws IO Exception { ++ length ; return in . read ( ) & NUM ; }
public void update Shape Shadows To Current Time ( boolean update Minutes , boolean update Hours , int current Minute , int current Hour ) { if ( update Minutes ) { int tens = ( int ) Math . floor ( current Minute / NUM ) ; int units = ( int ) Math . floor ( current Minute % NUM ) ; if ( minutes Tens . get Current Value ( ) != tens ) { String mt = String . format ( STRING , tens ) ; mt = mt . concat ( STRING ) ; Log . d ( TAG , STRING + mt ) ; minutes Tens . parse JSON ( mt ) ; } if ( minutes Units . get Current Value ( ) != units ) { String mu = String . format ( STRING , units ) ; mu = mu . concat ( STRING ) ; Log . d ( TAG , STRING + mu ) ; minutes Units . parse JSON ( mu ) ; } } if ( update Hours ) { int tens = ( int ) Math . floor ( current Hour / NUM ) ; int units = ( int ) Math . floor ( current Hour % NUM ) ; if ( hours Tens . get Current Value ( ) != tens ) { String ht = String . format ( STRING , tens ) ; ht = ht . concat ( STRING ) ; Log . d ( TAG , STRING + ht ) ; hours Tens . parse JSON ( ht ) ; } if ( hours Units . get Current Value ( ) != units ) { String hu = String . format ( STRING , units ) ; hu = hu . concat ( STRING ) ; Log . d ( TAG , STRING + hu ) ; hours Units . parse JSON ( hu ) ; } } }
public Set < Raw Protein < Super Family Hmmer 3 Raw Match > > parse ( Input Stream is ) throws IO Exception { Map < String , Raw Protein < Super Family Hmmer 3 Raw Match > > data = new Hash Map < String , Raw Protein < Super Family Hmmer 3 Raw Match > > ( ) ; Buffered Reader reader = null ; try { reader = new Buffered Reader ( new Input Stream Reader ( is ) ) ; String line ; while ( ( line = reader . read Line ( ) ) != null ) { Set < Super Family Hmmer 3 Raw Match > raw Matches = parse Line ( line ) ; Super Family Hmmer 3 Raw Match raw Match ; for ( Super Family Hmmer 3 Raw Match raw Matche : raw Matches ) { raw Match = raw Matche ; String sequence Id = raw Match . get Sequence Identifier ( ) ; if ( data . contains Key ( sequence Id ) ) { Raw Protein < Super Family Hmmer 3 Raw Match > raw Protein = data . get ( sequence Id ) ; raw Protein . add Match ( raw Match ) ; } else { Raw Protein < Super Family Hmmer 3 Raw Match > raw Protein = new Raw Protein < Super Family Hmmer 3 Raw Match > ( sequence Id ) ; raw Protein . add Match ( raw Match ) ; data . put ( sequence Id , raw Protein ) ; } } } } finally { if ( reader != null ) { reader . close ( ) ; } } return new Hash Set < Raw Protein < Super Family Hmmer 3 Raw Match > > ( data . values ( ) ) ; }
public Union Path Iterator ( Compiler compiler , int op Pos ) throws javax . xml . transform . Transformer Exception { super ( ) ; op Pos = Op Map . get First Child Pos ( op Pos ) ; load Location Paths ( compiler , op Pos , NUM ) ; }
public String relation Name ( ) { return m Relation Name ; }
private void write Attribute ( java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( namespace . equals ( STRING ) ) { xml Writer . write Attribute ( att Name , att Value ) ; } else { register Prefix ( xml Writer , namespace ) ; xml Writer . write Attribute ( namespace , att Name , att Value ) ; } }
@ Request Mapping ( value = STRING , method = Request Method . POST , produces = Media Type . TEXT PLAIN VALUE ) @ Timed public Response Entity < ? > change Password ( @ Request Body String password ) { if ( ! check Password Length ( password ) ) { return new Response Entity < > ( STRING , Http Status . BAD REQUEST ) ; } user Service . change Password ( password ) ; return new Response Entity < > ( Http Status . OK ) ; }
public void test Bad Segment ( ) throws IO Exception { Directory dir = new Directory ( ) ; Index Writer iw = new Index Writer ( dir , new Index Writer Config ( new Mock Analyzer ( random ( ) ) ) ) ; Document document = new Document ( ) ; Field Type custom Type = new Field Type ( Text Field . TYPE NOT STORED ) ; custom Type . set Store Term Vectors ( BOOL ) ; document . add ( new Field ( STRING , STRING , custom Type ) ) ; iw . add Document ( document ) ; iw . close ( ) ; dir . close ( ) ; }
public static int size ( String str ) { if ( str == null ) return NUM ; int length = str . length ( ) ; int size = length ; try { size = str . get Bytes ( STRING ) . length ; } catch ( Unsupported Encoding Exception e ) { log . log ( Level . SEVERE , str , e ) ; } return size ; }
protected void synch With Target ( ) throws Monitor Exception { long time Limit = System . current Time Millis ( ) + sync Wait Ms ; log ( STRING + lvmid + STRING ) ; while ( ! prologue . is Accessible ( ) ) { log ( STRING ) ; try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { } if ( System . current Time Millis ( ) > time Limit ) { logln ( STRING + lvmid ) ; throw new Monitor Exception ( STRING ) ; } } logln ( STRING + lvmid ) ; }
public static Char Sequence time ( Context context , Easy Cursor c ) { long now = System . current Time Millis ( ) ; long when = c . get Long ( Reviews . WRITTEN ON ) ; return now - when > MINUTE IN MILLIS ? Date Utils . get Relative Time Span String ( when , now , NUM , FORMAT ABBREV ALL ) : context . get String ( R . string . recent time ) ; }
private double screen To Normalized ( float screen Coord ) { int width = get Width ( ) ; if ( width <= NUM * padding ) { return NUM ; } else { double result = ( screen Coord - padding ) / ( width - NUM * padding ) ; return Math . min ( NUM , Math . max ( NUM , result ) ) ; } }
public long round Trip Time ( ) throws Interrupted Exception { latch . await ( ) ; return received - sent ; }
static private String user Id From Range ( String [ ] values , boolean include ) { int min Id = Integer . parse Int ( values [ NUM ] ) ; int max Id = Integer . parse Int ( values [ NUM ] ) ; String exclusions = values . length > NUM ? values [ NUM ] : null ; Stack < Integer > stack = get Stack ( min Id , max Id , exclusions , include ) ; if ( stack . size ( ) > NUM ) { return Integer . to String ( stack . pop ( ) ) ; } throw new Illegal Argument Exception ( STRING ) ; }
public void test Case 4 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM } ; int a Sign = - NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
public static String string Default Value ( String bytes ) { try { return new String ( bytes . get Bytes ( STRING ) , STRING ) ; } catch ( Unsupported Encoding Exception e ) { throw new Illegal State Exception ( STRING , e ) ; } }
public void actualiza Campo ( int tipo Ficha , Valor Campo Generico VO campo ) { Valor Campo Generico VO campo Anterior = retrieve ( tipo Ficha , campo . get Tipo ( ) , campo . get Id Objeto ( ) , campo . get Id Campo ( ) , campo . get Orden ( ) , campo . get Tipo Elemento ( ) ) ; if ( campo Anterior == null ) insert ( tipo Ficha , campo ) ; else update ( tipo Ficha , campo , campo Anterior . get Valor Info ( ) ) ; }
public static int length ( Reg Exp re ) { Reg Exp 2 r ; switch ( re . type ) { case sym . BAR : { r = ( Reg Exp 2 ) re ; int l1 = length ( r . r1 ) ; if ( l1 < NUM ) return - NUM ; int l2 = length ( r . r2 ) ; if ( l1 == l2 ) return l1 ; else return - NUM ; } case sym . CONCAT : { r = ( Reg Exp 2 ) re ; int l1 = length ( r . r1 ) ; if ( l1 < NUM ) return - NUM ; int l2 = length ( r . r2 ) ; if ( l2 < NUM ) return - NUM ; return l1 + l2 ; } case sym . STAR : case sym . PLUS : case sym . QUESTION : return - NUM ; case sym . CCLASS : case sym . CCLASSNOT : case sym . CHAR : case sym . CHAR I : return NUM ; case sym . STRING : case sym . STRING I : { String content = ( String ) ( ( Reg Exp 1 ) re ) . content ; return content . length ( ) ; } case sym . TILDE : case sym . BANG : return - NUM ; case sym . MACROUSE : return length ( macros . get Definition ( ( String ) ( ( Reg Exp 1 ) re ) . content ) ) ; } throw new Error ( STRING + re . type + STRING + re ) ; }
public static Time Zone random Time Zone ( Random random ) { String tz Ids [ ] = Time Zone . get Available I Ds ( ) ; return Time Zone . get Time Zone ( tz Ids [ random . next Int ( tz Ids . length ) ] ) ; }
public static String array To List ( String [ ] array , String delimiter ) { if ( Array Util . is Empty ( array ) ) return STRING ; String Builder sb = new String Builder ( array [ NUM ] ) ; if ( delimiter . length ( ) == NUM ) { char c = delimiter . char At ( NUM ) ; for ( int i = NUM ; i < array . length ; i ++ ) { sb . append ( c ) ; sb . append ( array [ i ] ) ; } } else { for ( int i = NUM ; i < array . length ; i ++ ) { sb . append ( delimiter ) ; sb . append ( array [ i ] ) ; } } return sb . to String ( ) ; }
@ Override public boolean add All ( Collection < ? extends E > c ) { Iterator < ? extends E > i = c . iterator ( ) ; boolean changed = BOOL ; while ( i . has Next ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; }
public void reset ( ) { m Codes . clear ( ) ; m Is First Char Capitalized = BOOL ; m Preferred Word = null ; m Typed Word . set Length ( NUM ) ; m Caps Count = NUM ; }
private String extract Path ( final String uri ) { return Default Wildcard Stream Locator . strip Query Path ( uri . replace ( PREFIX , String Utils . EMPTY ) ) ; }
public void add Classes To Check ( File basedir , String ... relative Names ) throws IO Exception { add Classes To Check ( basedir , Arrays . as List ( relative Names ) ) ; }
public static Short to Short ( String str ) throws Page Exception { return Short . value Of ( to Short Value ( str ) ) ; }
public void test Read Xml Lang New Style ( ) throws Exception { Properties result = xml To Properties ( STRING ) ; assert Not Null ( result ) ; assert True ( ! result . is Empty ( ) ) ; assert Equals ( NUM , result . size ( ) ) ; assert Equals ( STRING , result . get Property ( STRING ) ) ; }
public boolean has Permission ( Security security , Generic Value user Login ) { return Order Read Helper . has Permission ( security , user Login , order Header ) ; }
protected boolean filter Files ( List < File > files ) { if ( task . get No Mtime Check ( ) || is Output Repository URL ( ) ) { return BOOL ; } Iterator < File > iter = files . iterator ( ) ; while ( iter . has Next ( ) ) { File file = iter . next ( ) ; Module module = infer Module ( file ) ; if ( module == null ) { task . log ( STRING + file , Project . MSG VERBOSE ) ; continue ; } if ( module . get Version ( ) == null ) { task . log ( STRING + module . get Name ( ) , Project . MSG VERBOSE ) ; continue ; } long oldest = get Artifact File Time ( module , file ) ; if ( oldest == Long . MAX VALUE ) { File out Module Dir = get Artifact Dir ( module ) ; oldest = oldest Output Artifact ( Long . MAX VALUE , out Module Dir ) ; task . log ( STRING + module + STRING + new Date ( oldest ) , Project . MSG DEBUG ) ; } else { task . log ( STRING + file + STRING + module + STRING + new Date ( oldest ) , Project . MSG DEBUG ) ; } long newest File = file . last Modified ( ) ; task . log ( STRING + file + STRING + new Date ( newest File ) , Project . MSG DEBUG ) ; if ( newest File != Long . MIN VALUE && oldest != Long . MAX VALUE && newest File < oldest ) { task . log ( STRING + file + STRING ) ; iter . remove ( ) ; } } return files . size ( ) == NUM ; }
public void flush ( ) { output Stream . flush ( ) ; }
public int create Measures ( MSLA Goal goal ) { String sql = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + M In Out . Table ID + STRING ; int counter = NUM ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM , goal . get C B Partner ID ( ) ) ; pstmt . set Int ( NUM , goal . get PA SLA Goal ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { int M In Out ID = rs . get Int ( NUM ) ; Big Decimal Measure Actual = rs . get Big Decimal ( NUM ) ; Timestamp Movement Date = rs . get Timestamp ( NUM ) ; String Description = rs . get String ( NUM ) + STRING + rs . get Timestamp ( NUM ) ; if ( goal . is Date Valid ( Movement Date ) ) { MSLA Measure measure = new MSLA Measure ( goal , Movement Date , Measure Actual , Description ) ; measure . set Link ( M In Out . Table ID , M In Out ID ) ; if ( measure . save ( ) ) counter ++ ; } } } catch ( Exception e ) { log . log ( Level . SEVERE , STRING , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return counter ; }
public E remove At ( int index ) { final Object old = m Array [ index ] ; if ( m Size <= NUM ) { if ( DEBUG ) Log . d ( TAG , STRING + m Hashes . length + STRING ) ; free Arrays ( m Hashes , m Array , m Size ) ; m Hashes = Support Container Internals . EMPTY INTS ; m Array = Support Container Internals . EMPTY OBJECTS ; m Size = NUM ; } else { if ( m Hashes . length > ( BASE SIZE * NUM ) && m Size < m Hashes . length / NUM ) { final int n = m Size > ( BASE SIZE * NUM ) ? ( m Size + ( m Size > > NUM ) ) : ( BASE SIZE * NUM ) ; if ( DEBUG ) Log . d ( TAG , STRING + m Hashes . length + STRING + n ) ; final int [ ] ohashes = m Hashes ; final Object [ ] oarray = m Array ; alloc Arrays ( n ) ; m Size -- ; if ( index > NUM ) { if ( DEBUG ) Log . d ( TAG , STRING + index + STRING ) ; System . arraycopy ( ohashes , NUM , m Hashes , NUM , index ) ; System . arraycopy ( oarray , NUM , m Array , NUM , index ) ; } if ( index < m Size ) { if ( DEBUG ) Log . d ( TAG , STRING + ( index + NUM ) + STRING + m Size + STRING + index ) ; System . arraycopy ( ohashes , index + NUM , m Hashes , index , m Size - index ) ; System . arraycopy ( oarray , index + NUM , m Array , index , m Size - index ) ; } } else { m Size -- ; if ( index < m Size ) { if ( DEBUG ) Log . d ( TAG , STRING + ( index + NUM ) + STRING + m Size + STRING + index ) ; System . arraycopy ( m Hashes , index + NUM , m Hashes , index , m Size - index ) ; System . arraycopy ( m Array , index + NUM , m Array , index , m Size - index ) ; } m Array [ m Size ] = null ; } } return ( E ) old ; }
@ Override public String resolve Video Url ( @ Nullable final Video video , Step step ) { if ( video == null ) return null ; String local Path = database Facade . get Path To Video If Exist ( video ) ; if ( local Path != null && check Existing On Disk ( local Path , step ) ) { return local Path ; } else { List < Video Url > url List = video . get Urls ( ) ; if ( url List == null || url List . size ( ) == NUM ) return null ; return resolve From Web ( url List ) ; } }
protected Object lookup Service ( ) throws Exception { Object service = null ; Service Template templ ; if ( template == null ) { Class < ? > [ ] types = ( service Class == null ? null : new Class [ ] { service Class } ) ; Entry [ ] entry = ( service Name == null ? null : new Entry [ ] { new Name ( service Name ) } ) ; templ = new Service Template ( null , types , entry ) ; } else { templ = template ; } Lookup Locator [ ] lookup Locators = null ; if ( locators != null ) { lookup Locators = new Lookup Locator [ locators . length ] ; for ( int i = NUM ; i < locators . length ; i ++ ) { String locator = locators [ i ] ; if ( ! locator . starts With ( STRING ) ) { locator = STRING + locator ; } lookup Locators [ i ] = new Lookup Locator ( locator ) ; } } Service Discovery Manager service Discovery = null ; try { service Discovery = Shared Discovery Management . get Backwards Service Discovery Manager ( groups , lookup Locators , null ) ; Service Item return Object = service Discovery . lookup ( templ , null , timeout ) ; if ( return Object != null ) { service = return Object . service ; } } finally { if ( service Discovery != null ) { try { service Discovery . terminate ( ) ; } catch ( Exception e ) { logger . warn ( STRING , e ) ; } } } return service ; }
public static boolean equals ( final Object obj 1 , final Object obj 2 ) { return ( obj 1 != null && obj 1 . equals ( obj 2 ) ) ; }
public void test Merge Same Filter With Init Param In Two Documents ( ) throws Exception { String src Xml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge Filters ( merge Web Xml ) ; assert True ( Web Xml Utils . has Filter ( src Web Xml , STRING ) ) ; List < String > filter Init Param Names = Web Xml Utils . get Filter Init Param Names ( src Web Xml , STRING ) ; assert True ( filter Init Param Names . size ( ) == NUM ) ; assert Equals ( STRING , filter Init Param Names . get ( NUM ) ) ; List < String > filter Mappings = Web Xml Utils . get Filter Mappings ( src Web Xml , STRING ) ; assert Equals ( NUM , filter Mappings . size ( ) ) ; assert Equals ( STRING , filter Mappings . get ( NUM ) ) ; }
public Webapp Template Loader ( Servlet Context servlet Context , String subdir Path ) { if ( servlet Context == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( subdir Path == null ) { throw new Illegal Argument Exception ( STRING ) ; } subdir Path = subdir Path . replace ( STRING , STRING ) ; if ( ! subdir Path . ends With ( STRING ) ) { subdir Path += STRING ; } if ( ! subdir Path . starts With ( STRING ) ) { subdir Path = STRING + subdir Path ; } this . subdir Path = subdir Path ; this . servlet Context = servlet Context ; }
@ Suppress Warnings ( { STRING } ) public static < T > T [ ] insert ( T [ ] dest , T src , int offset , Class component Type ) { T [ ] temp = ( T [ ] ) Array . new Instance ( component Type , dest . length + NUM ) ; System . arraycopy ( dest , NUM , temp , NUM , offset ) ; temp [ offset ] = src ; System . arraycopy ( dest , offset , temp , offset + NUM , dest . length - offset ) ; return temp ; }
@ Override public void flush ( ) throws IO Exception { writer . write ( buffer , NUM , fill ) ; fill = NUM ; }
public Metric Instance with Dependency Metric Names ( List < String > dependency Metric Names ) { return new Metric Instance ( metric Name , maker , dependency Metric Names . to Array ( new String [ dependency Metric Names . size ( ) ] ) ) ; }
public static I Status validate Method Name ( String name ) { return validate Method Name ( name , Compiler Options . VERSION 1 3 , Compiler Options . VERSION 1 3 ) ; }
@ Suppress Warnings ( STRING ) void notify Alarm Clock ( Timer Alarm Clock Notification notification ) { Timer Notification timer Notification = null ; Date timer Date = null ; Timer Alarm Clock alarm Clock = ( Timer Alarm Clock ) notification . get Source ( ) ; synchronized ( Timer . this ) { for ( Object [ ] obj : timer Table . values ( ) ) { if ( obj [ ALARM CLOCK INDEX ] == alarm Clock ) { timer Notification = ( Timer Notification ) obj [ TIMER NOTIF INDEX ] ; timer Date = ( Date ) obj [ TIMER DATE INDEX ] ; break ; } } } send Notification ( timer Date , timer Notification ) ; update Timer Table ( timer Notification . get Notification ID ( ) ) ; }
public Profiler Entity start ( ) { start time = System . nano Time ( ) ; return this ; }
public static < E extends Enum < E > > Enum Set < E > of ( E e1 , E e2 , E e3 ) { Enum Set < E > set = of ( e1 , e2 ) ; set . add ( e3 ) ; return set ; }
public Pick Request with Camera Pics Directory ( @ Nullable final File p Dir File ) { this . m Custom Camera Pics Dir Path = p Dir File == null ? null : p Dir File . get Absolute Path ( ) ; return this ; }
public void prepare For Next Run ( ) { for ( int i = NUM ; i < NUM ; i ++ ) { System . gc ( ) ; try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } } }
public boolean write Header ( Output Stream os ) { try { write Int ( os , CACHE MAGIC ) ; write String ( os , key ) ; write String ( os , etag == null ? STRING : etag ) ; write Long ( os , server Date ) ; write Long ( os , last Modified ) ; write Long ( os , ttl ) ; write Long ( os , soft Ttl ) ; write String String Map ( response Headers , os ) ; os . flush ( ) ; return BOOL ; } catch ( IO Exception e ) { Volley Log . d ( STRING , e . to String ( ) ) ; return BOOL ; } }
public void add ( Chip chip ) { if ( ! m Chip List . contains ( chip ) || m Tolerating Duplicate ) { m Chip List . add ( chip ) ; notify Update ( ) ; } }
private boolean check Trip Zone Consistency ( ) { log . info ( STRING ) ; Hash Set < String > missing Zones = new Hash Set < String > ( ) ; for ( Trip T : trips . values ( ) ) { Basic Location zo = zones . get Location ( Id . create ( T . zone o , Zone . class ) ) ; Basic Location zd = zones . get Location ( Id . create ( T . zone d , Zone . class ) ) ; if ( zo == null ) { missing Zones . add ( T . zone o ) ; } if ( zd == null ) { missing Zones . add ( T . zone d ) ; } } if ( missing Zones . size ( ) > NUM ) { String msg = missing Zones . size ( ) + STRING ; for ( String s : missing Zones ) msg += STRING + s . to String ( ) + STRING ; log . error ( msg ) ; return BOOL ; } else log . info ( STRING ) ; return BOOL ; }
private int insert Index For Layer ( Component comp , int layer , int position ) { int i , count , cur Layer ; int layer Start = - NUM ; int layer End = - NUM ; int component Count = get Component Count ( ) ; Array List < Component > comp List = new Array List < Component > ( component Count ) ; for ( int index = NUM ; index < component Count ; index ++ ) { if ( get Component ( index ) != comp ) { comp List . add ( get Component ( index ) ) ; } } count = comp List . size ( ) ; for ( i = NUM ; i < count ; i ++ ) { cur Layer = get Layer ( comp List . get ( i ) ) ; if ( layer Start == - NUM && cur Layer == layer ) { layer Start = i ; } if ( cur Layer < layer ) { if ( i == NUM ) { layer Start = NUM ; layer End = NUM ; } else { layer End = i ; } break ; } } if ( layer Start == - NUM && layer End == - NUM ) return count ; if ( layer Start != - NUM && layer End == - NUM ) layer End = count ; if ( layer End != - NUM && layer Start == - NUM ) layer Start = layer End ; if ( position == - NUM ) return layer End ; if ( position > - NUM && layer Start + position <= layer End ) return layer Start + position ; return layer End ; }
public void test Timed Invoke All 2 ( ) throws Interrupted Exception { Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Future < String > > r = e . invoke All ( new Array List < Callable < String > > ( ) , MEDIUM DELAY MS , MILLISECONDS ) ; assert True ( r . is Empty ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public static Wait Dialog show Dialog ( Wait Dialog . Runnable runnable , String message , Container container , int width , int height ) { Wait Dialog new Dialog = null ; if ( container instanceof J Dialog ) { new Dialog = new Wait Dialog ( ( J Dialog ) container ) ; } else if ( container instanceof J Frame ) { new Dialog = new Wait Dialog ( ( J Frame ) container ) ; } else { new Dialog = new Wait Dialog ( ( J Dialog ) null ) ; new Dialog . set Location Relative To ( container ) ; } new Dialog . build Dialog ( width , height ) ; runnable . set Dialog ( new Dialog ) ; new Dialog . container = container ; new Dialog . runnable = runnable ; new Dialog . set Message ( message ) ; Thread process Thread = new Process Thread ( new Dialog ) ; process Thread . start ( ) ; while ( ! new Dialog . is Visible ( ) ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception ie ) { } } return new Dialog ; }
public void test Flip Bit Positive Outside 2 ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = NUM ; int number = NUM ; byte r Bytes [ ] = { NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . flip Bit ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public synchronized void write ( byte b [ ] , int off , int len ) throws IO Exception { if ( len <= NUM ) return ; int free Space = buffer . length - pos ; if ( len <= free Space ) { System . arraycopy ( b , off , buffer , pos , len ) ; pos += len ; return ; } flush ( ) ; int local requested ; while ( BOOL ) { synchronized ( lock ) { while ( ( local requested = requested ) < NUM && ! disconnected ) { try { lock . wait ( ) ; } catch ( Interrupted Exception e ) { } } if ( disconnected ) throw new IO Exception ( STRING ) ; } if ( local requested < len ) { manager . send Transmit ( info , b , off , local requested ) ; off += local requested ; len -= local requested ; synchronized ( lock ) { requested -= local requested ; } } else { manager . send Transmit ( info , b , off , len ) ; synchronized ( lock ) { requested -= len ; } break ; } } }
protected Alarm ( ) { this ( STRING ) ; }
public void remove Mouse Mode ( Map Mouse Mode med ) { boolean need To Adjust Active Mode = BOOL ; if ( med == null ) { return ; } if ( med . equals ( active Mouse Mode ) ) { need To Adjust Active Mode = BOOL ; set Inactive ( med ) ; } for ( Map Mouse Mode check MM : mouse Modes ) { if ( med . equals ( check MM ) ) { med . remove All Map Mouse Listeners ( ) ; } else if ( need To Adjust Active Mode ) { set Active ( check MM ) ; need To Adjust Active Mode = BOOL ; } } mouse Modes . remove ( med ) ; fire Property Change ( Mouse Modes Property , null , mouse Modes ) ; }
@ Override public boolean has Dispatch Function ( ) { return BOOL ; }
public void add Map ( Map < K , V > map , K min , K max ) { if ( min != null && max != null && key Type . compare ( min , max ) > NUM ) { Data Utils . new Illegal Argument Exception ( STRING , min , max ) ; } int len = shards . length + NUM ; Shard < K , V > [ ] new Shards = Arrays . copy Of ( shards , len ) ; Shard < K , V > new Shard = new Shard < K , V > ( ) ; new Shard . map = map ; new Shard . min Including = min ; new Shard . max Excluding = max ; new Shards [ len - NUM ] = new Shard ; shards = new Shards ; }
private void retry Failed Interfaces ( ) { for ( Iterator i = failed Interfaces . iterator ( ) ; i . has Next ( ) ; ) { Network Interface nic = ( Network Interface ) i . next ( ) ; try { if ( nic != null ) { socket . set Network Interface ( nic ) ; } socket . join Group ( request Addr ) ; i . remove ( ) ; Level l = multicast Interfaces Specified ? Level . INFO : Level . FINE ; if ( logger . is Loggable ( l ) ) { if ( nic != null ) { logger . log ( l , STRING , new Object [ ] { nic } ) ; } else { logger . log ( l , STRING ) ; } } } catch ( IO Exception e ) { } } }
public void write Header ( ) throws IO Exception { FLV Header flv Header = new FLV Header ( ) ; flv Header . set Flag Audio ( BOOL ) ; flv Header . set Flag Video ( BOOL ) ; Byte Buffer header = Byte Buffer . allocate ( HEADER LENGTH + NUM ) ; flv Header . write ( header ) ; file . set Length ( HEADER LENGTH + NUM ) ; if ( header . has Array ( ) ) { log . debug ( STRING ) ; file . write ( header . array ( ) ) ; } else { log . debug ( STRING ) ; byte [ ] tmp = new byte [ HEADER LENGTH + NUM ] ; header . get ( tmp ) ; file . write ( tmp ) ; } bytes Written = file . length ( ) ; header . clear ( ) ; }
public static Future < ? > submit ( Runnable task ) { return THREAD POOL . submit ( task ) ; }
public boolean add Overlay ( Overlay overlay , Kml Document kml Doc ) { if ( overlay == null ) return BOOL ; Kml Feature kml Item ; if ( overlay instanceof Ground Overlay ) { kml Item = new Kml Ground Overlay ( ( Ground Overlay ) overlay ) ; } else if ( overlay instanceof Folder Overlay ) { kml Item = new Kml Folder ( ( Folder Overlay ) overlay , kml Doc ) ; } else if ( overlay instanceof Marker Clusterer ) { kml Item = new Kml Folder ( ( Marker Clusterer ) overlay , kml Doc ) ; } else if ( overlay instanceof Marker ) { Marker marker = ( Marker ) overlay ; kml Item = new Kml Placemark ( marker ) ; } else if ( overlay instanceof Polygon ) { Polygon polygon = ( Polygon ) overlay ; kml Item = new Kml Placemark ( polygon , kml Doc ) ; } else if ( overlay instanceof Polyline ) { Polyline polyline = ( Polyline ) overlay ; kml Item = new Kml Placemark ( polyline , kml Doc ) ; } else { return BOOL ; } m Items . add ( kml Item ) ; return BOOL ; }
private < T extends SB Resource > T look For Resource ( SB Resource Type type , Class < T > clazz ) { List < T > resources = look For Resources ( type , clazz ) ; return resources != null && resources . size ( ) > NUM ? resources . get ( NUM ) : null ; }
private Object produce Event ( ) throws Invocation Target Exception { if ( ! valid ) { throw new Illegal State Exception ( to String ( ) + STRING ) ; } try { return method . invoke ( target ) ; } catch ( Illegal Access Exception e ) { throw new Assertion Error ( e ) ; } catch ( Invocation Target Exception e ) { if ( e . get Cause ( ) instanceof Error ) { throw ( Error ) e . get Cause ( ) ; } throw e ; } }
private List < Float > create Dash Array ( String dash String ) { String [ ] dashes = dash String . split ( STRING ) ; List < Float > float Dash Array = new Array List < Float > ( ) ; for ( String dash Value : dashes ) { try { float Dash Array . add ( Float . parse Float ( dash Value ) ) ; } catch ( Number Format Exception e ) { return null ; } } return float Dash Array ; }
public void clean Patch By Version ( String version Name ) { if ( patch Directory == null || version Name == null ) { return ; } String path = patch Directory . get Absolute Path ( ) + STRING + version Name ; Share Patch File Util . delete Dir ( path ) ; }
public static boolean is Valid Java Class Name ( String input ) { if ( ! String Utils . has Text ( input ) ) { return BOOL ; } if ( ! Character . is Java Identifier Start ( input . char At ( NUM ) ) ) { return BOOL ; } if ( input . length ( ) > NUM ) { for ( int i = NUM ; i < input . length ( ) ; i ++ ) { if ( ! Character . is Java Identifier Part ( input . char At ( i ) ) ) { return BOOL ; } } } return BOOL ; }
public void test create empty ( ) { final String id = STRING ; final Map < String , Object > metadata = new Hash Map < String , Object > ( ) ; metadata . put ( File Metadata Schema . ID , id ) ; metadata . put ( STRING , STRING ) ; final int version = repo . create ( metadata ) ; metadata . put ( File Metadata Schema . VERSION , Integer . value Of ( version ) ) ; assert Equals ( STRING , NUM , version ) ; Repository Document Impl doc = ( Repository Document Impl ) repo . read ( id ) ; assert True ( STRING , doc . exists ( ) ) ; assert Equals ( STRING , version , doc . get Version ( ) ) ; assert Not Same ( STRING , NUM , doc . get Version Create Time ( ) ) ; assert Equals ( STRING , doc . get Version Create Time ( ) , doc . get Earliest Version Create Time ( ) ) ; assert Equals ( STRING , doc . get Version Create Time ( ) , doc . get Metadata Update Time ( ) ) ; Map < String , Object > actual = doc . as Map ( ) ; assert Equals ( STRING , id , actual . get ( File Metadata Schema . ID ) ) ; assert Equals ( STRING , version , actual . get ( File Metadata Schema . VERSION ) ) ; assert Equals ( STRING , STRING , actual . get ( STRING ) ) ; assert Equals ( STRING , metadata . size ( ) , actual . size ( ) ) ; }
public static String rename ( String desc , String oldname , String newname ) { if ( desc . index Of ( oldname ) < NUM ) return desc ; String Buffer newdesc = new String Buffer ( ) ; int head = NUM ; int i = NUM ; for ( ; ; ) { int j = desc . index Of ( STRING , i ) ; if ( j < NUM ) break ; else if ( desc . starts With ( oldname , j + NUM ) && desc . char At ( j + oldname . length ( ) + NUM ) == STRING ) { newdesc . append ( desc . substring ( head , j ) ) ; newdesc . append ( STRING ) ; newdesc . append ( newname ) ; newdesc . append ( STRING ) ; head = i = j + oldname . length ( ) + NUM ; } else { i = desc . index Of ( STRING , j ) + NUM ; if ( i < NUM ) break ; } } if ( head == NUM ) return desc ; else { int len = desc . length ( ) ; if ( head < len ) newdesc . append ( desc . substring ( head , len ) ) ; return newdesc . to String ( ) ; } }
public void sort ( int att Index ) { double [ ] vals = new double [ num Instances ( ) ] ; Instance [ ] backup = new Instance [ vals . length ] ; for ( int i = NUM ; i < vals . length ; i ++ ) { Instance inst = instance ( i ) ; backup [ i ] = inst ; double val = inst . value ( att Index ) ; if ( Utils . is Missing Value ( val ) ) { vals [ i ] = Double . MAX VALUE ; } else { vals [ i ] = val ; } } int [ ] sort Order = Utils . sort With No Missing Values ( vals ) ; for ( int i = NUM ; i < vals . length ; i ++ ) { m Instances . set ( i , backup [ sort Order [ i ] ] ) ; } }
private static byte Call Byte Method V ( JNI Environment env , int obj JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object obj = env . get JNI Ref ( obj JREF ) ; Object return Obj = JNI Helpers . invoke With Var Arg ( obj , method ID , arg Address , Type Reference . Byte , BOOL ) ; return Reflection . unwrap Byte ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
public boolean adjust Entry ( E entry ) { final Spatial Directory Entry se = ( Spatial Directory Entry ) entry ; final Modifiable Hyper Bounding Box mbr = compute MBR ( ) ; boolean changed = BOOL ; if ( se . has MBR ( ) ) { final int dim = se . get Dimensionality ( ) ; for ( int i = NUM ; i < dim ; i ++ ) { if ( Math . abs ( se . get Min ( i ) - mbr . get Min ( i ) ) > Float . MIN NORMAL ) { changed = BOOL ; break ; } if ( Math . abs ( se . get Max ( i ) - mbr . get Max ( i ) ) > Float . MIN NORMAL ) { changed = BOOL ; break ; } } } else { changed = BOOL ; } if ( changed ) { se . set MBR ( mbr ) ; } return changed ; }
private void trace Object ( Object Reference object , boolean root ) { if ( VERBOSE ) { Trace . trace ( Item . SANITY , STRING , Object Model . get String ( object ) ) ; } if ( object . is Null ( ) ) return ; boolean marked = black Set . contains ( object ) ; if ( ! marked ) { black Set . add ( object ) ; mark Stack . add ( object ) ; } visitor . visit Object ( object , root , marked ) ; }
private static int compare ( int from Index , Char Sequence left , Char Sequence right ) { if ( left == null ) return - NUM ; if ( right == null ) return NUM ; for ( int i = from Index , n = Math Lib . min ( left . length ( ) , right . length ( ) ) ; i < n ; i ++ ) { char c1 = Character . to Upper Case ( left . char At ( i ) ) ; char c2 = Character . to Upper Case ( right . char At ( i ) ) ; if ( c1 != c2 ) return c1 - c2 ; } return left . length ( ) - right . length ( ) ; }
public boolean restore Accessibility Focus ( Calendar Day day ) { if ( ( day . year != m Year ) || ( day . month != m Month ) || ( day . day > m Num Cells ) ) { return BOOL ; } m Touch Helper . set Focused Virtual View ( day . day ) ; return BOOL ; }
public Driver Task create Volume Clone ( List < Volume Clone > clones ) { LOG . info ( STRING ) ; Dell SC Driver Task task = new Dell SC Driver Task ( STRING ) ; String Builder err Buffer = new String Builder ( ) ; int create Count = NUM ; for ( Volume Clone clone : clones ) { try { Storage Center API api = connection Manager . get Connection ( clone . get Storage System Id ( ) ) ; Sc Replay replay = null ; api . check And Init Volume ( clone . get Parent Id ( ) ) ; if ( clone . get Source Type ( ) == Source Type . SNAPSHOT ) { replay = api . get Replay ( clone . get Parent Id ( ) ) ; } else { replay = api . create Replay ( clone . get Parent Id ( ) , NUM ) ; } Sc Volume sc Vol = api . create View Volume ( clone . get Display Name ( ) , replay . instance Id ) ; clone . set Provisioned Capacity ( Size Util . size Str To Bytes ( sc Vol . configured Size ) ) ; clone . set Allocated Capacity ( NUM ) ; clone . set Wwn ( sc Vol . device Id ) ; clone . set Native Id ( sc Vol . instance Id ) ; clone . set Device Label ( sc Vol . name ) ; clone . set Access Status ( Access Status . READ WRITE ) ; clone . set Replication State ( Replication State . SYNCHRONIZED ) ; create Count ++ ; } catch ( Dell SC Driver Exception | Storage Center API Exception dex ) { String error = String . format ( STRING , clone . get Parent Id ( ) , dex ) ; err Buffer . append ( String . format ( STRING , error ) ) ; } } task . set Message ( err Buffer . to String ( ) ) ; if ( create Count == clones . size ( ) ) { task . set Status ( Task Status . READY ) ; } else if ( create Count == NUM ) { task . set Status ( Task Status . FAILED ) ; } else { task . set Status ( Task Status . PARTIALLY FAILED ) ; } return task ; }
@ Override public int hash Code ( ) { if ( hash == NUM ) { int result = NUM ; result = NUM * result + range . hash Code ( ) ; long bits Weight = Double . double To Long Bits ( weight ) ; result = NUM * result + ( int ) ( bits Weight ^ ( bits Weight > > > NUM ) ) ; hash = result ; } return hash ; }
@ Override public void on Click ( View v ) { int position = Math . min ( ( Integer ) v . get Tag ( ) , m Item List . size ( ) - NUM ) ; m Selected Tracker = m Item List . get ( position ) ; m Toggle Config Handler . show For Selected Toggle ( ) ; m Toggle Config Handler . show At Location ( v ) ; m Toggle Config Handler . set Arrow Position ( v ) ; }
private int read From Data Source ( byte [ ] target , int offset , int length , int bytes Already Read , boolean allow End Of Input ) throws Interrupted Exception , IO Exception { if ( Thread . interrupted ( ) ) { throw new Interrupted Exception ( ) ; } int bytes Read = data Source . read ( target , offset + bytes Already Read , length - bytes Already Read ) ; if ( bytes Read == C . RESULT END OF INPUT ) { if ( bytes Already Read == NUM && allow End Of Input ) { return C . RESULT END OF INPUT ; } throw new EOF Exception ( ) ; } return bytes Already Read + bytes Read ; }
public Explanation explain ( int doc , Explanation freq ) throws IO Exception { return Explanation . match ( score ( doc , freq . get Value ( ) ) , STRING + doc + STRING + freq . get Value ( ) + STRING , Collections . singleton ( freq ) ) ; }
public static Stack < String > split Parts ( String name ) { while ( name . starts With ( STRING ) ) name = name . substring ( NUM ) ; Stack < String > parts = new Stack < > ( ) ; int last = NUM ; int pos = NUM ; String part ; while ( BOOL ) { pos = last ; while ( BOOL ) { pos = name . index Of ( STRING , pos ) ; if ( pos < NUM ) break ; if ( name . char At ( pos - NUM ) == STRING ) ++ pos ; else break ; } if ( pos < NUM ) break ; part = name . substring ( last , pos ) ; if ( ! part . ends With ( STRING ) ) part += STRING ; parts . add ( part ) ; last = pos + NUM ; } part = name . substring ( last ) ; if ( ! part . ends With ( STRING ) ) part += STRING ; parts . add ( part ) ; return parts ; }
public Set < Soot Method > collect Source Methods ( ) { Set < Soot Method > result = new Hash Set < Soot Method > ( ) ; for ( Source Call Chain Info cci : entry points ) { collect Source Methods ( cci , result ) ; } return result ; }
public void test Precision And Scale ( ) throws Exception { test Precision For Type ( STRING , NUM , - NUM , BOOL ) ; test Precision For Type ( STRING , NUM , - NUM , BOOL ) ; test Precision For Type ( STRING , NUM , - NUM , BOOL ) ; test Precision For Type ( STRING , NUM , - NUM , BOOL ) ; test Precision For Type ( STRING , NUM , - NUM , BOOL ) ; test Precision For Type ( STRING , NUM , - NUM , BOOL ) ; test Precision For Type ( STRING , NUM , - NUM , BOOL ) ; test Precision For Type ( STRING , NUM , - NUM , BOOL ) ; test Precision For Type ( STRING , NUM , - NUM , BOOL ) ; test Precision For Type ( STRING , NUM , - NUM , BOOL ) ; test Precision For Type ( STRING , NUM , NUM , BOOL ) ; test Precision For Type ( STRING , NUM , NUM , BOOL ) ; test Precision For Type ( STRING , NUM , NUM , BOOL ) ; test Precision For Type ( STRING , NUM , NUM , BOOL ) ; test Precision For Type ( STRING , NUM , NUM , BOOL ) ; test Precision For Type ( STRING , NUM , NUM , BOOL ) ; test Precision For Type ( STRING , NUM , NUM , BOOL ) ; test Precision For Type ( STRING , NUM , NUM , BOOL ) ; }
public void register ( Named Bean s ) { String system Name = s . get System Name ( ) ; tsys . put ( system Name , s ) ; String user Name = s . get User Name ( ) ; if ( user Name != null ) { tuser . put ( user Name , s ) ; } fire Property Change ( STRING , null , Integer . value Of ( tsys . size ( ) ) ) ; s . add Property Change Listener ( this , STRING , STRING ) ; }
protected void expand For ( int i1 , int i2 , double d ) { if ( i1 >= sizes . size ( ) ) { int old Size = sizes . size ( ) , capacity = vector . length ; sizes . set ( i1 , NUM ) ; if ( capacity < sizes . size ( ) ) { while ( capacity < sizes . size ( ) ) capacity *= NUM ; double [ ] [ ] t = new double [ capacity ] [ ] ; System . arraycopy ( vector , NUM , t , NUM , old Size ) ; vector = t ; } for ( int i = old Size ; i < sizes . size ( ) ; ++ i ) vector [ i ] = new double [ default Capacity 2 ] ; } if ( i2 < sizes . get ( i1 ) ) return ; int old Size = sizes . get ( i1 ) , capacity = vector [ i1 ] . length ; sizes . set ( i1 , i2 + NUM ) ; if ( capacity >= sizes . get ( i1 ) ) return ; while ( capacity < sizes . get ( i1 ) ) capacity *= NUM ; double [ ] t = new double [ capacity ] ; System . arraycopy ( vector [ i1 ] , NUM , t , NUM , old Size ) ; if ( d != NUM ) Arrays . fill ( t , old Size , sizes . get ( i1 ) , d ) ; vector [ i1 ] = t ; }
public V put ( final K k , final V v ) { final Weak Reference < V > ref = new Weak Ref ( k , v , reference Queue ) ; final Weak Reference < V > old Ref = map . put ( k , ref ) ; final V old Val = old Ref == null ? null : old Ref . get ( ) ; if ( queue . add ( v ) && DEBUG ) { log . debug ( STRING + k + STRING + v ) ; } did Update ( k , ref , old Ref ) ; return old Val ; }
static void delay ( long millis ) throws Interrupted Exception { long nanos = millis * ( NUM * NUM ) ; final long wakeup Time = System . nano Time ( ) + nanos ; do { if ( millis > NUM ) Thread . sleep ( millis ) ; else Thread . yield ( ) ; nanos = wakeup Time - System . nano Time ( ) ; millis = nanos / ( NUM * NUM ) ; } while ( nanos >= NUM ) ; }
public static < V > boolean add List Not Null Value ( List < V > source List , V value ) { return ( source List != null && value != null ) ? source List . add ( value ) : BOOL ; }
public void delete ( int key ) { int i = Container Helpers . binary Search ( m Keys , m Size , key ) ; if ( i >= NUM ) { System . arraycopy ( m Keys , i + NUM , m Keys , i , m Size - ( i + NUM ) ) ; System . arraycopy ( m Values , i + NUM , m Values , i , m Size - ( i + NUM ) ) ; m Size -- ; } }
public static void keep Alive ( final boolean keep Alive ) { set Property ( STRING , Boolean . to String ( keep Alive ) ) ; }
public Page Object Context peek ( ) { return deque . peek ( ) ; }
protected void write Namespace ( String prefix , String uri ) throws IO Exception { if ( ( prefix != null ) && ( prefix . length ( ) > NUM ) ) { writer . write ( STRING ) ; writer . write ( prefix ) ; writer . write ( STRING ) ; } else { writer . write ( STRING ) ; } writer . write ( uri ) ; writer . write ( STRING ) ; }
public static void wait Some Time ( int seconds ) { try { Thread . sleep ( seconds * NUM ) ; } catch ( Interrupted Exception e ) { } }
public void encode ( String value , Byte Buffer buffer ) throws Buffer Overflow Exception { if ( value == null ) { buffer . put ( ( byte ) ( NUM ) ) ; return ; } int char Count = value . length ( ) ; if ( char Count == NUM ) { buffer . put ( ( byte ) ( NUM | NUM ) ) ; return ; } int position = buffer . position ( ) ; boolean ascii = BOOL ; if ( char Count > NUM ) { for ( int i = NUM ; i < char Count ; i ++ ) { int c = value . char At ( i ) ; if ( c > NUM ) { ascii = BOOL ; break ; } buffer . put ( ( byte ) c ) ; } } else { ascii = BOOL ; } if ( ascii ) { position = buffer . position ( ) ; buffer . put ( position - NUM , ( byte ) ( buffer . get ( position - NUM ) | NUM ) ) ; } else { buffer . position ( position ) ; write Length ( char Count + NUM , buffer ) ; int char Index = NUM ; for ( ; char Index < char Count ; char Index ++ ) { int c = value . char At ( char Index ) ; if ( c > NUM ) break ; buffer . put ( ( byte ) c ) ; } write UTF 8 String ( value , char Count , char Index , buffer ) ; } }
public void test Bug 71672 Statement ( int test Step , Connection test Conn , String query , int expected Update Count , int [ ] expected Keys ) throws SQL Exception { Statement test Stmt = test Conn . create Statement ( ) ; if ( expected Update Count < NUM ) { assert False ( test Step + STRING , test Stmt . execute ( query , Statement . RETURN GENERATED KEYS ) ) ; } else { assert Equals ( test Step + STRING , expected Update Count , test Stmt . execute Update ( query , Statement . RETURN GENERATED KEYS ) ) ; } Result Set test RS = test Stmt . get Generated Keys ( ) ; for ( int k : expected Keys ) { assert True ( test Step + STRING , test RS . next ( ) ) ; assert Equals ( test Step + STRING , k , test RS . get Int ( NUM ) ) ; } assert False ( test Step + STRING , test RS . next ( ) ) ; test RS . close ( ) ; test Stmt . close ( ) ; }
public static Path Impl lookup ( String url ) { Path Impl pwd = get Pwd ( ) ; if ( ! url . starts With ( STRING ) ) { return pwd . lookup ( url , null ) ; } else { return PWD . lookup ( url , null ) ; } }
public static XML Gregorian Calendar now ( ) { return get XML Gregorian Calendar Value ( null ) ; }
protected void add Scalar Dimension ( int i ) { for ( Dimension dimension : dimension List ) { if ( dimension . get Dimension ( ) == i ) { return ; } } dimension List . add ( new Dimension ( i ) ) ; }
public void initialize ( ) { Texture State ts = new Texture State ( ) ; ts . set Enabled ( BOOL ) ; set Render State ( ts ) ; for ( int i = NUM ; i < line Set List . size ( ) ; ++ i ) { Line Set State state = line Set List . get ( i ) ; add Line Set ( state , BOOL ) ; } z Buffer State = new Z Buffer State ( ) ; z Buffer State . set Function ( Z Buffer State . Test Function . Less Than Or Equal To ) ; z Buffer State . set Enabled ( BOOL ) ; set Render State ( z Buffer State ) ; }
protected boolean reg Exp Region Matches ( String text , int t Start , String p , int p Start , int plen ) { while ( plen -- > NUM ) { char tchar = text . char At ( t Start ++ ) ; char pchar = p . char At ( p Start ++ ) ; if ( ! this . f Ignore Wild Cards ) { if ( pchar == f Single Wild Card ) { continue ; } } if ( pchar == tchar ) { continue ; } if ( this . f Ignore Case ) { if ( Character . to Upper Case ( tchar ) == Character . to Upper Case ( pchar ) ) { continue ; } if ( Character . to Lower Case ( tchar ) == Character . to Lower Case ( pchar ) ) { continue ; } } return BOOL ; } return BOOL ; }
public static void init Keys ( Key Store keystore , Properties props ) { if ( props . contains Key ( Configuration . WEBCALL KAFKA AES ) ) { byte [ ] key = keystore . decode Key ( props . get Property ( Configuration . WEBCALL KAFKA AES ) ) ; Preconditions . check Argument ( ( NUM == key . length || NUM == key . length || NUM == key . length ) , Configuration . WEBCALL KAFKA AES + STRING ) ; keystore . set Key ( Key Store . AES KAFKA WEBCALL , key ) ; aes Key = key ; } if ( props . contains Key ( Configuration . WEBCALL KAFKA MAC ) ) { byte [ ] key = keystore . decode Key ( props . get Property ( Configuration . WEBCALL KAFKA MAC ) ) ; Preconditions . check Argument ( ( NUM == key . length ) , Configuration . WEBCALL KAFKA MAC + STRING ) ; keystore . set Key ( Key Store . SIPHASH KAFKA WEBCALL , key ) ; siphash Key = key ; } }
public static boolean is Empty ( String Builder str ) { return is Null ( str ) || str . length ( ) <= NUM ; }
public static Gas register ( Gas gas ) { if ( gas == null ) { return null ; } registered Gasses . add ( gas ) ; return get Gas ( gas . get Name ( ) ) ; }
@ Override public boolean lock ( ) { try { lock Path = zk . create ( this . lock Type Folder + Carbon Common Constants . FILE SEPARATOR + lock Name , null , Ids . OPEN ACL UNSAFE , Create Mode . EPHEMERAL SEQUENTIAL ) ; List < String > nodes = zk . get Children ( this . lock Type Folder , null ) ; Collections . sort ( nodes ) ; if ( lock Path . ends With ( nodes . get ( NUM ) ) ) { return BOOL ; } else { zk . delete ( lock Path , - NUM ) ; return BOOL ; } } catch ( Keeper Exception | Interrupted Exception e ) { LOGGER . error ( e , e . get Message ( ) ) ; return BOOL ; } }
@ Override protected void key Typed ( char par 1 , int par 2 ) { token Box . textbox Key Typed ( par 1 , par 2 ) ; if ( par 2 == NUM || par 2 == NUM ) action Performed ( ( Gui Button ) button List . get ( NUM ) ) ; }
private static Boolean is Alphanumeric ( final String label ) { boolean status = BOOL ; if ( String Utils . is Not Empty ( label ) ) { Matcher matcher = pattern Alphanumeric . matcher ( label ) ; status = matcher . matches ( ) ; } return status ; }
final static String trim URI Substring ( URL src , String sub ) { final String s = src . to External Form ( ) ; final int end Index = s . last Index Of ( sub ) ; final String t = s . substring ( NUM , end Index ) ; return t ; }
@ Override public String global Info ( ) { return STRING + STRING + STRING ; }
public static void silent Close Input Stream ( Input Stream is ) { try { if ( is != null ) { is . close ( ) ; } } catch ( IO Exception e ) { Log . w ( LOG TAG , STRING , e ) ; } }
public boolean remove Row ( int row ) { if ( m rows . is Valid Row ( row ) ) { fire Table Event ( row , row , Table Model Event . ALL COLUMNS , Table Model Event . DELETE ) ; m tuples . invalidate ( row ) ; m rows . release Row ( row ) ; for ( Iterator cols = get Columns ( ) ; cols . has Next ( ) ; ) { Column c = ( Column ) cols . next ( ) ; c . revert To Default ( row ) ; } return BOOL ; } return BOOL ; }
void add Fill Components ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM , NUM ) ; boolean filled cell 11 = BOOL ; Cell Constraints cc = new Cell Constraints ( ) ; if ( cols . length > NUM && rows . length > NUM ) { if ( cols [ NUM ] == NUM && rows [ NUM ] == NUM ) { panel . add ( Box . create Rigid Area ( filler ) , cc . xy ( NUM , NUM ) ) ; filled cell 11 = BOOL ; } } for ( int index = NUM ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM && filled cell 11 ) { continue ; } panel . add ( Box . create Rigid Area ( filler ) , cc . xy ( cols [ index ] , NUM ) ) ; } for ( int index = NUM ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM && filled cell 11 ) { continue ; } panel . add ( Box . create Rigid Area ( filler ) , cc . xy ( NUM , rows [ index ] ) ) ; } }
private boolean is Parsable To Double ( String i ) { return i . matches ( STRING ) ; }
protected String [ ] init Paths From Properties ( String raw Paths ) { String [ ] ret Paths = null ; if ( raw Paths != null ) { try { String Tokenizer token = new String Tokenizer ( raw Paths , File . path Separator ) ; int num Paths = token . count Tokens ( ) ; ret Paths = new String [ num Paths ] ; for ( int i = NUM ; i < num Paths ; i ++ ) { ret Paths [ i ] = token . next Token ( ) ; } return ret Paths ; } catch ( java . util . No Such Element Exception e ) { e . print Stack Trace ( ) ; } } return ret Paths ; }
private float color To Angle ( int color ) { float [ ] colors = new float [ NUM ] ; Color . color To HSV ( color , colors ) ; return ( float ) Math . to Radians ( - colors [ NUM ] ) ; }
private void register Default Validator Ids ( Application application , Linked Hash Set < String > default Validator Ids ) { if ( default Validator Ids == null ) { default Validator Ids = new Linked Hash Set < > ( ) ; if ( is Bean Validator Available ( ) ) { Web Configuration web Config = Web Configuration . get Instance ( ) ; if ( ! web Config . is Option Enabled ( Web Configuration . Boolean Web Context Init Parameter . Disable Default Bean Validator ) ) { default Validator Ids . add ( Bean Validator . VALIDATOR ID ) ; } } } for ( String validator Id : default Validator Ids ) { if ( LOGGER . is Loggable ( Level . FINE ) ) { LOGGER . log ( Level . FINE , Message Format . format ( STRING , validator Id ) ) ; } application . add Default Validator Id ( validator Id ) ; } }
protected void initialize Location ( V v , Point 2 D coord ) { Point point = locations . get ( v ) ; coord . set Location ( point . x , point . y ) ; }
public static Date parse Date ( String date Str ) { String format String = STRING ; if ( date Str . length ( ) == NUM ) date Str = date Str . substring ( NUM , NUM ) ; if ( date Str . length ( ) == NUM ) format String = STRING ; if ( date Str . length ( ) == NUM ) format String = STRING ; Simple Date Format formatter = new Simple Date Format ( format String ) ; Parse Position pos = new Parse Position ( NUM ) ; return formatter . parse ( date Str , pos ) ; }
@ Suppress Warnings ( STRING ) private void do Unload ( Marked Project marked Project , N4 Progress State Recorder rec ) throws N4 JS Compile Error Exception { if ( create Debug Output ) { println ( STRING + marked Project . project ) ; } rec . mark Start Unloading ( marked Project ) ; for ( Resource res : marked Project . resources ) { rec . mark Unloading Of ( res ) ; res . unload ( ) ; } rec . mark Finished Unloading ( marked Project ) ; }
public void parse Lib ( Map < String , Object > data Model , String full Text ) throws Parse Exception { Matcher m ; full Text = tmpl Helper . normalize Text ( full Text ) ; m = comment Pat . matcher ( full Text ) ; if ( ! m . find ( ) ) { throw new Parse Exception ( STRING ) ; } String intro Text = tmpl Helper . strip Comment Leading Asterix ( tmpl Helper . clean Text Value ( m . group ( NUM ) ) ) ; data Model . put ( STRING , intro Text ) ; Matcher introm = tmpl Helper . get First Line Matcher ( intro Text ) ; if ( introm . matches ( ) ) { data Model . put ( STRING , tmpl Helper . clean Text Value ( introm . group ( NUM ) ) ) ; data Model . put ( STRING , tmpl Helper . clean Text Value ( introm . group ( NUM ) ) ) ; } String current Section Name = STRING ; Map < String , Object > section Info = make Object Map ( ) ; section Info . put ( STRING , current Section Name ) ; section Info . put ( STRING , null ) ; section Info . put ( STRING , STRING ) ; section Info . put ( STRING , STRING ) ; Map < String , Map < String , Object > > section Entry Map = make Data Map ( ) ; section Info . put ( STRING , section Entry Map ) ; Map < String , Map < String , Object > > entry Map = make Data Map ( ) ; Map < String , Map < String , Object > > section Map = make Data Map ( ) ; section Map . put ( STRING , section Info ) ; while ( m . find ( ) ) { String comment = tmpl Helper . clean Text Value ( m . group ( NUM ) ) ; Matcher subm ; subm = section Pat . matcher ( comment ) ; if ( subm . matches ( ) ) { current Section Name = tmpl Helper . clean Text Value ( subm . group ( NUM ) ) ; section Info = make Object Map ( ) ; section Info . put ( STRING , current Section Name ) ; section Info . put ( STRING , current Section Name ) ; section Info . put ( STRING , STRING ) ; section Info . put ( STRING , tmpl Helper . clean Text Value ( tmpl Helper . strip Comment Leading Asterix ( subm . group ( NUM ) ) ) ) ; section Entry Map = make Data Map ( ) ; section Info . put ( STRING , section Entry Map ) ; section Map . put ( current Section Name , section Info ) ; } else { subm = entry Pat . matcher ( comment ) ; if ( subm . matches ( ) ) { String entry Title = tmpl Helper . clean Text Value ( subm . group ( NUM ) ) ; String entry Body = tmpl Helper . clean Text Value ( subm . group ( NUM ) ) ; String post Entry Text = full Text . substring ( m . end ( ) ) ; try { Map < String , Object > entry Info = parse Entry ( entry Title , entry Body , post Entry Text ) ; entry Info . put ( STRING , current Section Name ) ; String entry Name = ( String ) entry Info . get ( STRING ) ; if ( entry Name == null || entry Name . is Empty ( ) ) { throw new Parse Exception ( STRING ) ; } if ( entry Map . contains Key ( entry Name ) ) { throw new Parse Exception ( STRING + entry Name ) ; } entry Map . put ( entry Name , entry Info ) ; section Entry Map . put ( entry Name , entry Info ) ; } catch ( Parse Exception e ) { throw new Parse Exception ( STRING + entry Title + STRING + e . get Message ( ) , e ) ; } } else { ; } } } msg Handler . log Info ( STRING + entry Map . size ( ) + STRING + section Map . size ( ) ) ; data Model . put ( STRING , section Map ) ; data Model . put ( STRING , entry Map ) ; }
public void write File ( Array List < Dcc Loco Address > consist List , String file Name ) throws IO Exception { Element root = new Element ( STRING ) ; Document doc = new Document ( root , dtd Location + STRING ) ; Map < String , String > m = new Hash Map < String , String > ( ) ; m . put ( STRING , STRING ) ; m . put ( STRING , xslt Location + STRING ) ; Processing Instruction p = new Processing Instruction ( STRING , m ) ; doc . add Content ( NUM , p ) ; Element roster = new Element ( STRING ) ; for ( int i = NUM ; i < consist List . size ( ) ; i ++ ) { Consist new Consist = consist Man . get Consist ( consist List . get ( i ) ) ; roster . add Content ( consist To Xml ( new Consist ) ) ; } root . add Content ( roster ) ; try { if ( ! check File ( file Name ) ) { File file = new File ( file Name ) ; File parent Dir = file . get Parent File ( ) ; if ( ! parent Dir . exists ( ) ) { if ( ! parent Dir . mkdir ( ) ) { throw ( new IO Exception ( ) ) ; } } if ( ! file . create New File ( ) ) { throw ( new IO Exception ( ) ) ; } } write XML ( find File ( file Name ) , doc ) ; } catch ( IO Exception ioe ) { log . error ( STRING + ioe ) ; throw ( ioe ) ; } }
public void train ( Reader a Reader ) throws IO Exception { Buffered Reader in = new Buffered Reader ( a Reader ) ; String line = in . read Line ( ) ; while ( line != null ) { Matcher m = WORD PATTERN . matcher ( line . to Lower Case ( ) ) ; while ( m . find ( ) ) { String word = m . group ( ) ; Atomic Integer count = n Words . get ( word ) ; if ( count == null ) { count = new Atomic Integer ( NUM ) ; n Words . put ( word , count ) ; } count . increment And Get ( ) ; } line = in . read Line ( ) ; } }
private void start Client ( ) { if ( flume Client != null && ! flume Client . is Active ( ) ) { flume Client . close ( ) ; flume Client = null ; } if ( flume Client == null ) { try { flume Client = Rpc Client Factory . get Default Instance ( flume Host Name , flume Port , max Span Batch Size ) ; } catch ( Flume Exception e ) { LOG . warn ( STRING + e . get Message ( ) ) ; } } }
public void vspan ( long start , long end , Paint color , String legend ) { Legend Text legend Text = new Legend Text ( color , legend ) ; comments . add ( legend Text ) ; plot Elements . add ( new V Span ( start , end , color , legend Text ) ) ; }
public void on Draw ( Canvas canvas , int center X , int center Y ) { if ( ! m Visible ) { return ; } m Arc Bounds = new Rect F ( center X - m Progress Radius , center Y - m Progress Radius , center X + m Progress Radius , center Y + m Progress Radius ) ; canvas . draw Circle ( center X , center Y , m Progress Radius , m Progress Base Paint ) ; canvas . draw Arc ( m Arc Bounds , - NUM , m Progress Angle Degrees , BOOL , m Progress Paint ) ; if ( m Progress Angle Degrees == NUM && System . current Time Millis ( ) > m Time To Hide ) { m Visible = BOOL ; if ( m Visibility Listener != null ) { m Visibility Listener . on Hidden ( ) ; } } }
private void remove Item At Int ( int index , boolean update Children On Menu Views ) { if ( ( index < NUM ) || ( index >= m Items . size ( ) ) ) return ; m Items . remove ( index ) ; if ( update Children On Menu Views ) on Items Changed ( BOOL ) ; }
public static byte [ ] decode ( String s ) { return decode ( s . to Char Array ( ) ) ; }
public boolean check ( ) { return ( m File != null ) && ( m Handler != null ) && m File . exists ( ) ; }
public static List < Long > z Score Test ( Geo Time Serie gts , boolean use Median , double d ) throws Warp Script Exception { double Check ( gts ) ; List < Long > anomalous ticks = new Array List < Long > ( ) ; double [ ] musigma = madsigma ( gts , use Median ) ; double m = musigma [ NUM ] ; double std = musigma [ NUM ] ; if ( NUM == std ) { return anomalous ticks ; } for ( int i = NUM ; i < gts . values ; i ++ ) { double z = ( gts . double Values [ i ] - m ) / std ; if ( Math . abs ( z ) >= d ) { anomalous ticks . add ( gts . ticks [ i ] ) ; } } return anomalous ticks ; }
private void append ( Print Writer pw , final String k , final String v ) { if ( v != null ) { pw . println ( k + STRING + v ) ; } }
default B with Default ( String key , Object value ) { return with Default ( key , value != null ? value . to String ( ) : null ) ; }
public void test Multiply Diff Scale Pos Neg ( ) { String a = STRING ; int a Scale = NUM ; String b = STRING ; int b Scale = - NUM ; String c = STRING ; int c Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; Big Decimal result = a Number . multiply ( b Number ) ; assert Equals ( STRING , c , result . to String ( ) ) ; assert Equals ( STRING , c Scale , result . scale ( ) ) ; }
private void skip Whitespace ( ) { matcher . use Pattern ( WHITESPACE ) ; if ( matcher . looking At ( ) ) { matcher . region ( matcher . end ( ) , matcher . region End ( ) ) ; } }
protected void create Dynamic Style For Components ( final Text Field tag Name , final Text Area tag Desc , final String taregt Tag Color ) { tag Name . remove Style Name ( SPUI Definitions . TAG NAME ) ; tag Desc . remove Style Name ( SPUI Definitions . TAG DESC ) ; get Target Dynamic Styles ( taregt Tag Color ) ; tag Name . add Style Name ( TAG NAME DYNAMIC STYLE ) ; tag Desc . add Style Name ( TAG DESC DYNAMIC STYLE ) ; }
public void calculate scores ( ) { score = NUM ; if ( contents . length == NUM ) { API api = API . v ( ) ; Set < Info Kind > source = api . get Source Info Kinds ( method ) ; Set < Info Kind > sink = api . get Sink Info Kinds ( method ) ; if ( is system ( method ) ) { if ( api . is Safe Method ( method ) ) score = NUM ; else if ( api . is Spec Method ( method ) ) score = NUM ; else if ( api . is Banned Method ( method ) ) score = NUM ; if ( ! source . is Empty ( ) ) score += NUM ; else if ( ! sink . is Empty ( ) ) score += NUM ; } return ; } for ( Call Chain Info cci : contents ) { cci . calculate scores ( ) ; calls += cci . calls ; syscalls += cci . syscalls ; if ( cci . score > score ) score = cci . score ; } }
public < T > Json Array < T > create List Dto From Json ( String json , Class < T > dto Interface ) { final Dto Provider < T > dto Provider = get Dto Provider ( dto Interface ) ; final List < Json Element > list = gson . from Json ( json , list Type Cache . get Unchecked ( Json Element . class ) ) ; final List < T > result = new Array List < > ( list . size ( ) ) ; for ( Json Element e : list ) { result . add ( dto Provider . from Json ( e ) ) ; } return new Json Array Impl < > ( result ) ; }
public void start Consumption ( Multi Threaded Batch Processor < T , TL > processor ) ;
public static long long For Query ( SQ Lite Database db , String query , String [ ] selection Args ) { SQ Lite Statement prog = db . compile Statement ( query ) ; try { return long For Query ( prog , selection Args ) ; } finally { prog . close ( ) ; } }
public void test One One ( ) { String num A = STRING ; String num B = STRING ; String res = STRING ; Big Integer a Number = new Big Integer ( num A ) ; Big Integer b Number = new Big Integer ( num B ) ; Big Integer result = a Number . xor ( b Number ) ; assert True ( res . equals ( result . to String ( ) ) ) ; }
public String to String ( ) { String s = STRING + ids . to String ( ) + STRING ; return ( s ) ; }
@ Override public void remove ( String ... identifiers ) { whitelist . remove All ( Arrays . as List ( identifiers ) ) ; }
public static byte [ ] check Tls Pre Master Secret Key ( int client Version , int server Version , Secure Random random , byte [ ] encoded , boolean is Fail Over ) { if ( random == null ) { random = JCA Util . get Secure Random ( ) ; } byte [ ] replacer = new byte [ NUM ] ; random . next Bytes ( replacer ) ; if ( ! is Fail Over && ( encoded != null ) ) { if ( encoded . length != NUM ) { return replacer ; } int encoded Version = ( ( encoded [ NUM ] & NUM ) << NUM ) | ( encoded [ NUM ] & NUM ) ; if ( client Version != encoded Version ) { if ( client Version > NUM || server Version != encoded Version ) { encoded = replacer ; } } return encoded ; } return replacer ; }
public Commafier ( final String initial ) { m separator = DEFAULT SEPARATOR ; sb . append ( initial ) ; }
public void write ( File file ) throws IO Exception { Print Writer pw = new Print Writer ( new Output Stream Writer ( new File Output Stream ( file ) , STRING ) , BOOL ) ; if ( from Dir != null ) { pw . println ( STRING + from Dir + STRING + from Ext ) ; } String str = null ; for ( int i = NUM ; i < b List . size ( ) ; i ++ ) { str = ( String ) ( b List . element At ( i ) ) ; pw . println ( str ) ; } }
private void log ( I Status status ) { Resources Plugin . log ( status ) ; }
static private String Builder replace ( String Builder input , java . util . regex . Pattern pattern , String replacement ) { java . util . regex . Matcher m = pattern . matcher ( input ) ; while ( m . find ( ) ) { if ( is Escaped Char ( input . to String ( ) , m . start ( ) ) ) { continue ; } input . replace ( m . start ( ) , m . end ( ) , replacement ) ; m . reset ( input ) ; } return input ; }
public static Multisig Aggregate Modification Transaction create Multisig Modification ( ) { return new Multisig Aggregate Modification Transaction ( Time Instant . ZERO , Utils . generate Random Account ( ) , Collections . singleton List ( new Multisig Cosignatory Modification ( Multisig Modification Type . Add Cosignatory , Utils . generate Random Account ( ) ) ) ) ; }
public static boolean is Jar Cache Enabled Default ( ) { return is Jar Cache Enabled ; }
public void test write flush update ( ) { final Journal store = ( Journal ) get Store ( ) ; try { RW Strategy buffer Strategy = ( RW Strategy ) store . get Buffer Strategy ( ) ; final int nbytes = NUM ; byte [ ] a = new byte [ nbytes ] ; r . next Bytes ( a ) ; final long addr = buffer Strategy . write ( Byte Buffer . wrap ( a ) ) ; assert Equals ( nbytes , store . get Byte Count ( addr ) ) ; store . commit ( ) ; { final Byte Buffer b = buffer Strategy . read ( addr ) ; assert Not Null ( b ) ; for ( int i = NUM ; i < NUM ; i ++ ) { assert Equals ( STRING + i , a [ i ] , b . get ( i ) ) ; } } } finally { store . destroy ( ) ; } }
public static void copy ( long [ ] src , int src Offset , long [ ] dst , int dst Offset , int len ) { int src Limit = src Offset + len ; while ( src Offset < src Limit ) { int src Idx = src Offset & NUM ; int dst Idx = dst Offset & NUM ; int src Remainder = NUM - src Idx ; int dst Remainder = NUM - dst Idx ; int chunk Len = Math . min ( src Remainder , dst Remainder ) ; long mask = mask Below ( chunk Len ) << src Idx ; dst [ dst Offset > > NUM ] |= ( ( src [ src Offset > > NUM ] & mask ) > > > src Idx ) << dst Offset ; src Offset += chunk Len ; dst Offset += chunk Len ; } }
public static int SAVED XERROR HANDLER ( long display , X Error Event error ) { if ( saved error handler != NUM ) { } if ( log . is Loggable ( Platform Logger . Level . FINE ) ) { log . fine ( STRING + STRING + error . get resourceid ( ) + STRING + STRING + error . get serial ( ) + STRING + STRING + error . get error code ( ) + STRING + STRING + error . get request code ( ) + STRING + STRING + error . get minor code ( ) ) ; } return NUM ; }
protected int in Border ( int x , int y ) { Border b = get Border ( ) ; if ( b == null ) { return UNDEF ; } Insets i = b . get Border Insets ( this ) ; if ( x <= i . left ) { return DOCK WEST ; } if ( x >= get Width ( ) - i . right ) { return DOCK EAST ; } if ( y <= i . top ) { return DOCK NORTH ; } if ( y >= get Height ( ) - i . bottom ) { return DOCK SOUTH ; } return UNDEF ; }
public Wall Force ( float grav Const , float x1 , float y1 , float x2 , float y2 ) { params = new float [ ] { grav Const } ; min Values = new float [ ] { DEFAULT MIN GRAV CONSTANT } ; max Values = new float [ ] { DEFAULT MAX GRAV CONSTANT } ; this . x1 = x1 ; this . y1 = y1 ; this . x2 = x2 ; this . y2 = y2 ; dx = x2 - x1 ; dy = y2 - y1 ; float r = ( float ) Math . sqrt ( dx * dx + dy * dy ) ; if ( dx != NUM ) dx /= r ; if ( dy != NUM ) dy /= r ; }
public static void write Ln ( final Output Stream out ) throws IO Exception { out . write ( LS BYTES ) ; }
public static boolean is System Application ( Context context ) { if ( context == null ) { return BOOL ; } return is System Application ( context , context . get Package Name ( ) ) ; }
public void test Pos Zero ( ) { String num A = STRING ; String num B = STRING ; String res = STRING ; Big Integer a Number = new Big Integer ( num A ) ; Big Integer b Number = new Big Integer ( num B ) ; Big Integer result = a Number . xor ( b Number ) ; assert True ( res . equals ( result . to String ( ) ) ) ; }
private static void initialize Release Platform ( ) { String platform Property = read Config Property ( PLATFORM PROPERTIES , PLATFORM PROPERTY KEY ) ; if ( platform Property == null ) { log Info ( STRING ) ; } else { current Platform = Platform . value Of ( platform Property . to Upper Case ( Locale . UK ) ) ; log Info ( STRING + current Platform ) ; } }
public static boolean is Empty ( Char Sequence str ) { if ( str == null || str . length ( ) == NUM ) { return BOOL ; } else { return BOOL ; } }
@ Override public FS Data Input Stream open ( Path path , int buffer Size ) throws IO Exception { String table = get Table Name ( root Path , path ) ; String split = get Split Name ( root Path , path ) ; split = split Name Without Gzip Extension ( split ) ; return new FS Data Input Stream ( new Emo Split Input Stream ( table , split ) ) ; }
public void simulate Method ( Soot Method method , Reference Variable this Var , Reference Variable return Var , Reference Variable params [ ] ) { String sub Signature = method . get Sub Signature ( ) ; if ( sub Signature . equals ( STRING ) ) { java lang Class Loader define Class 0 ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java lang Class Loader find Bootstrap Class ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java lang Class Loader find Loaded Class ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java lang Class Loader get Caller Class Loader ( method , this Var , return Var , params ) ; return ; } else { default Method ( method , this Var , return Var , params ) ; return ; } }
public static final String extract Ipl Identity Host Frimware Rev ( Loco Net Message m ) { String Builder s = new String Builder ( ) ; s . append ( Integer . to String ( ( m . get Element ( NUM ) & NUM ) > > NUM ) ) ; s . append ( STRING ) ; s . append ( Integer . to String ( ( m . get Element ( NUM ) & NUM ) ) ) ; return s . to String ( ) ; }
private void grow ( ) { if ( keys == null || nkeys >= keys . length ) { String [ ] nk = new String [ nkeys + NUM ] ; String [ ] nv = new String [ nkeys + NUM ] ; if ( keys != null ) System . arraycopy ( keys , NUM , nk , NUM , nkeys ) ; if ( values != null ) System . arraycopy ( values , NUM , nv , NUM , nkeys ) ; keys = nk ; values = nv ; } }
private List < T > filter ( final Collection < T > collection ) { final List < T > null Free List = new Array List < T > ( ) ; if ( collection != null ) { for ( final T item : collection ) { if ( item != null ) { null Free List . add ( item ) ; } } } return null Free List ; }
public boolean is System Class ( Soot Class clz ) { return all System Classes . contains ( clz ) ; }
private byte [ ] try Decode Host To Ip ( String host ) { if ( host . starts With ( STRING ) && host . ends With ( STRING ) ) { return try Decode Host To I Pv 6 ( host ) ; } return try Decode Host To I Pv 4 ( host ) ; }
private void update Base Matrix ( Drawable d ) { Image View image View = get Image View ( ) ; if ( null == image View || null == d ) { return ; } final float view Width = get Image View Width ( image View ) ; final float view Height = get Image View Height ( image View ) ; final int drawable Width = d . get Intrinsic Width ( ) ; final int drawable Height = d . get Intrinsic Height ( ) ; m Base Matrix . reset ( ) ; final float width Scale = view Width / drawable Width ; final float height Scale = view Height / drawable Height ; if ( m Scale Type == Scale Type . CENTER ) { m Base Matrix . post Translate ( ( view Width - drawable Width ) / NUM , ( view Height - drawable Height ) / NUM ) ; } else if ( m Scale Type == Scale Type . CENTER CROP ) { float scale = Math . max ( width Scale , height Scale ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM , ( view Height - drawable Height * scale ) / NUM ) ; } else if ( m Scale Type == Scale Type . CENTER INSIDE ) { float scale = Math . min ( NUM , Math . min ( width Scale , height Scale ) ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM , ( view Height - drawable Height * scale ) / NUM ) ; } else { Rect F m Temp Src = new Rect F ( NUM , NUM , drawable Width , drawable Height ) ; Rect F m Temp Dst = new Rect F ( NUM , NUM , view Width , view Height ) ; switch ( m Scale Type ) { case FIT CENTER : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . CENTER ) ; break ; case FIT START : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . START ) ; break ; case FIT END : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . END ) ; break ; case FIT XY : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . FILL ) ; break ; default : break ; } } reset Matrix ( ) ; }
public List < Node > list Available Nodes ( Class < ? > type ) { List < Node > result = new Array List < Node > ( ) ; for ( Node node : available Nodes ) { if ( type . is Assignable From ( node . get Return Type ( ) ) ) { result . add ( node ) ; } } return result ; }
private < T extends Draft 3 Resource > T look For Resource ( Draft 3 Resource Type type , Class < T > clazz ) { List < T > resources = look For Resources ( type , clazz ) ; return resources != null && resources . size ( ) > NUM ? resources . get ( NUM ) : null ; }
public static String read File To String ( File file ) throws IO Exception { return read File To String ( file , Charset . default Charset ( ) ) ; }
private boolean is Locked ( Order order ) { lock . lock ( ) ; try { return active Orders . contains ( order . get Id ( ) ) ; } finally { lock . unlock ( ) ; } }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
private static byte [ ] long To Byte Array ( long l ) { byte [ ] ret Val = new byte [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { ret Val [ i ] = ( byte ) l ; l >>= NUM ; } return ret Val ; }
public Encoder Test Suite Builder encode ( final String expected , final String input ) { return encode ( STRING + input , expected , input ) ; }
public static boolean is File Type Supported ( int file Type ) { List providers = get Midi File Writers ( ) ; for ( int i = NUM ; i < providers . size ( ) ; i ++ ) { Midi File Writer writer = ( Midi File Writer ) providers . get ( i ) ; if ( writer . is File Type Supported ( file Type ) ) { return BOOL ; } } return BOOL ; }
public void add Muted Username ( final String username ) { add Muted Username ( username , null ) ; }
public void override Current Time ( long time ) { start Time = System . current Time Millis ( ) ; current Time = NUM ; stored Time = time ; }
public static String sc ( Double score ) { String score str = String . format ( STRING , score ) ; return score str ; }
public static boolean validate Bind Address ( String bind Address ) { if ( bind Address == null || bind Address . length ( ) == NUM ) return BOOL ; if ( Inet Address Util . validate Host ( bind Address ) == null ) return BOOL ; return BOOL ; }
protected void fail ( String string ) { last Print = NUM ; if ( string . length ( ) > NUM ) { char [ ] data = string . to Char Array ( ) ; for ( int i = NUM ; i < data . length ; i ++ ) { char c = data [ i ] ; if ( c >= NUM || c < NUM ) { data [ i ] = ( char ) ( STRING + ( c & NUM ) ) ; string = null ; } } if ( string == null ) { string = new String ( data ) ; } } println ( string ) ; throw new Assertion Error ( string ) ; }
public Typecheck Result interpret Results ( Test Configuration config , Compilation Result compilation Result ) { List < Test Diagnostic > expected Diagnostics = read Diagnostics ( config , compilation Result ) ; return Typecheck Result . from Compilation Results ( config , compilation Result , expected Diagnostics ) ; }
public boolean is Trusted XACML Provider ( String realm , String entity Id , String trusted Entity Id , String role ) throws SAML 2 Meta Exception { boolean result = BOOL ; if ( role != null ) { if ( role . equals ( SAML 2 Constants . PDP ROLE ) ) { XACMLPDP Config Element pdp Config = get Policy Decision Point Config ( realm , entity Id ) ; if ( pdp Config != null ) { result = is Same Circle Of Trust ( pdp Config , realm , trusted Entity Id ) ; } } else if ( role . equals ( SAML 2 Constants . PEP ROLE ) ) { XACML Authz Decision Query Config Element pep Config = get Policy Enforcement Point Config ( realm , entity Id ) ; result = is Same Circle Of Trust ( pep Config , realm , trusted Entity Id ) ; } } return result ; }
private Property Editor load Property Editor ( Class clz ) { Property Editor editor = null ; try { editor = ( Property Editor ) clz . new Instance ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } return editor ; }
public Distribution ( Instances source , Classifier Split Model model To Use ) throws Exception { int index ; Instance instance ; double [ ] weights ; m per Class Per Bag = new double [ model To Use . num Subsets ( ) ] [ NUM ] ; m per Bag = new double [ model To Use . num Subsets ( ) ] ; tota L = NUM ; m per Class = new double [ source . num Classes ( ) ] ; for ( int i = NUM ; i < model To Use . num Subsets ( ) ; i ++ ) { m per Class Per Bag [ i ] = new double [ source . num Classes ( ) ] ; } Enumeration < Instance > enu = source . enumerate Instances ( ) ; while ( enu . has More Elements ( ) ) { instance = enu . next Element ( ) ; index = model To Use . which Subset ( instance ) ; if ( index != - NUM ) { add ( index , instance ) ; } else { weights = model To Use . weights ( instance ) ; add Weights ( instance , weights ) ; } } }
public void writing Request Headers ( ) { if ( sent Request Millis != - NUM ) throw new Illegal State Exception ( ) ; sent Request Millis = System . current Time Millis ( ) ; }
public List < Dexlib Abstract Instruction > instructions After ( Dexlib Abstract Instruction instruction ) { int i = instructions . index Of ( instruction ) ; if ( i == - NUM ) throw new Illegal Argument Exception ( STRING + instruction + STRING ) ; return instructions . sub List ( i + NUM , instructions . size ( ) ) ; }
private Alignment fine Tune Alignment ( final Alignment first Compute , final int xframe , final int yframe , final Point frame Location , final Point component Location , final int comp Width , final int comp Height ) { switch ( first Compute ) { case TOPLEFT : case TOPRIGHT : if ( component Location . x - frame Location . x + comp Width / NUM > xframe / NUM ) { return Alignment . TOPRIGHT ; } else { return Alignment . TOPLEFT ; } case LEFTBOTTOM : case LEFTTOP : if ( component Location . y - frame Location . y + comp Height / NUM > yframe / NUM ) { return Alignment . LEFTBOTTOM ; } else { return Alignment . LEFTTOP ; } case RIGHTBOTTOM : case RIGHTTOP : if ( component Location . y - frame Location . y + comp Height / NUM > yframe / NUM ) { return Alignment . RIGHTBOTTOM ; } else { return Alignment . RIGHTTOP ; } case BOTTOMLEFT : case BOTTOMRIGHT : if ( component Location . x - frame Location . x + comp Width / NUM > xframe / NUM ) { return Alignment . BOTTOMRIGHT ; } else { return Alignment . BOTTOMLEFT ; } default : if ( real Alignment == Alignment . INNERLEFT || real Alignment == Alignment . INNERRIGHT ) { return real Alignment ; } if ( component Location . x - frame Location . x > xframe + frame Location . x - ( comp Width + component Location . x ) ) { return Alignment . INNERRIGHT ; } else { return Alignment . INNERLEFT ; } } }
public boolean is Empty ( ) { return shapes == null ? BOOL : shapes . is Empty ( ) ; }
public static boolean is Network Available ( Context context ) { Connectivity Manager cm = ( Connectivity Manager ) context . get System Service ( Context . CONNECTIVITY SERVICE ) ; Network Info net Info = cm . get Active Network Info ( ) ; return net Info != null && net Info . is Connected Or Connecting ( ) ; }
public void reset Data ( ) { data . clear ( ) ; data Names . clear ( ) ; data Set . reset Data ( data Names , data , bins ) ; }
@ Override public URI upload Package ( ) { boolean file Exists = new File ( topology Package Location ) . is File ( ) ; if ( ! file Exists ) { LOG . info ( STRING + topology Package Location + STRING ) ; return null ; } Path file Path = Paths . get ( dest Topology File ) ; File parent Directory = file Path . get Parent ( ) . to File ( ) ; assert parent Directory != null ; if ( ! parent Directory . exists ( ) ) { LOG . fine ( STRING ) ; if ( ! parent Directory . mkdirs ( ) ) { LOG . severe ( STRING + parent Directory . get Path ( ) ) ; return null ; } } file Exists = new File ( file Path . to String ( ) ) . is File ( ) ; if ( file Exists ) { LOG . fine ( STRING + file Path . to String ( ) + STRING ) ; } LOG . fine ( STRING + topology Package Location + STRING + file Path . to String ( ) ) ; Path source = Paths . get ( topology Package Location ) ; try { Copy Option [ ] options = new Copy Option [ ] { Standard Copy Option . REPLACE EXISTING } ; Files . copy ( source , file Path , options ) ; } catch ( IO Exception ex ) { LOG . info ( STRING + source . to String ( ) + STRING + ex ) ; return null ; } return get Uri ( dest Topology File ) ; }
public static String strip Escape ( String pattern ) { if ( pattern == null ) return null ; String Builder stripped = new String Builder ( pattern . length ( ) ) ; for ( int pos = NUM ; pos < pattern . length ( ) ; pos ++ ) { char ch = pattern . char At ( pos ) ; if ( ch != STRING ) { stripped . append ( ch ) ; } else if ( pos < pattern . length ( ) - NUM && pattern . char At ( pos + NUM ) == STRING ) { stripped . append ( STRING ) ; pos += NUM ; } } return stripped . to String ( ) ; }
public long guest time ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
public void audit Operation ( String operation , List < ? extends Tagged Log API Entity > entities , List < String > encoded Row Keys , Entity Definition entity Definition ) { if ( is Auditing Required ( entity Definition . get Service ( ) ) ) { List < Generic Audit Entity > audit Entities = build Audit Entities ( operation , entities , encoded Row Keys , entity Definition ) ; if ( null != audit Entities && NUM != audit Entities . size ( ) ) { audit Support . fire Audit ( entity Definition . get Service ( ) , audit Entities ) ; } } }
public Collection < HTML Token > tokenize HTML ( ) { List < HTML Token > tokens = new Array List < HTML Token > ( ) ; String nested Tags = nested Tags Regex ( NUM ) ; Pattern p = Pattern . compile ( STRING + STRING + STRING + STRING + STRING + nested Tags + STRING , Pattern . CASE INSENSITIVE ) ; Matcher m = p . matcher ( text ) ; int last Pos = NUM ; while ( m . find ( ) ) { if ( last Pos < m . start ( ) ) { tokens . add ( HTML Token . text ( text . substring ( last Pos , m . start ( ) ) ) ) ; } tokens . add ( HTML Token . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; last Pos = m . end ( ) ; } if ( last Pos < text . length ( ) ) { tokens . add ( HTML Token . text ( text . substring ( last Pos , text . length ( ) ) ) ) ; } return tokens ; }
public void register ( String pattern , String result ) { Assert . is True ( matchers . size ( ) == results . size ( ) ) ; pattern = pattern . trim ( ) ; if ( pattern . length ( ) == NUM ) { return ; } matchers . add ( new String Matcher ( pattern , BOOL , BOOL ) ) ; results . add ( result ) ; }
@ Override public boolean on Item Use ( Item Stack par 1 Item Stack , Entity Player par 2 Entity Player , World par 3 World , int x , int y , int z , int par 7 , float par 8 , float par 9 , float par 10 ) { if ( ! par 3 World . is Remote ) { Tile Entity tile Entity = par 3 World . get Tile Entity ( x , y , z ) ; if ( tile Entity != null ) { if ( tile Entity instanceof Tile Launcher Prefab ) { Tile Launcher Prefab missile Launcher = ( Tile Launcher Prefab ) tile Entity ; if ( missile Launcher . get Frequency ( ) > NUM ) { set Frequency ( missile Launcher . get Frequency ( ) , par 1 Item Stack ) ; par 2 Entity Player . add Chat Message ( new Chat Component Text ( Reference . CHAT DESC + Enum Color . GREY + STRING + Lang Utils . localize ( STRING ) + STRING + Enum Color . DARK GREY + get Frequency ( par 1 Item Stack ) ) ) ; } else { par 2 Entity Player . add Chat Message ( new Chat Component Text ( Reference . CHAT DESC + Enum Color . GREY + STRING + Lang Utils . localize ( STRING ) ) ) ; } } } } return BOOL ; }
public static Public Key generate Public Key ( String encoded Public Key ) { try { byte [ ] decoded Key = Base 64 . decode ( encoded Public Key ) ; Key Factory key Factory = Key Factory . get Instance ( KEY FACTORY ALGORITHM ) ; return key Factory . generate Public ( new X509 Encoded Key Spec ( decoded Key ) ) ; } catch ( No Such Algorithm Exception e ) { throw new Runtime Exception ( e ) ; } catch ( Invalid Key Spec Exception e ) { Log . e ( TAG , STRING ) ; throw new Illegal Argument Exception ( e ) ; } catch ( Base 64 Decoder Exception e ) { Log . e ( TAG , STRING ) ; throw new Illegal Argument Exception ( e ) ; } }
SSL Session to Session ( byte [ ] data , String host , int port ) { Byte Array Input Stream bais = new Byte Array Input Stream ( data ) ; Data Input Stream dais = new Data Input Stream ( bais ) ; try { int type = dais . read Int ( ) ; if ( type != OPEN SSL ) { log ( new Assertion Error ( STRING + type ) ) ; return null ; } int length = dais . read Int ( ) ; byte [ ] session Data = new byte [ length ] ; dais . read Fully ( session Data ) ; int count = dais . read Int ( ) ; X509 Certificate [ ] certs = new X509 Certificate [ count ] ; for ( int i = NUM ; i < count ; i ++ ) { length = dais . read Int ( ) ; byte [ ] cert Data = new byte [ length ] ; dais . read Fully ( cert Data ) ; certs [ i ] = Open SSLX 509 Certificate . from X 509 Der ( cert Data ) ; } return new Open SSL Session Impl ( session Data , host , port , certs , this ) ; } catch ( IO Exception e ) { log ( e ) ; return null ; } }
private static String parse DER String ( byte [ ] alter Name Value ) throws Throwable { try { ASN 1 Stream Parser p = new ASN 1 Stream Parser ( alter Name Value ) ; ASN 1 Encodable d = p . read Object ( ) ; ASN 1 Primitive der = d . to ASN 1 Primitive ( ) ; return get String From Object ( der ) ; } catch ( Throwable e ) { logger . error ( STRING + e . get Message ( ) ) ; throw e ; } }
public Atlas Messages Adapter add Cell Factories ( Atlas Cell Factory ... cell Factories ) { for ( Atlas Cell Factory Cell Factory : cell Factories ) { Cell Factory . set Style ( m Message Style ) ; m Cell Factories . add ( Cell Factory ) ; m View Type Count ++ ; Cell Type me = new Cell Type ( BOOL , Cell Factory ) ; m Cell Types By View Type . put ( m View Type Count , me ) ; m My View Types By Cell . put ( Cell Factory , m View Type Count ) ; m View Type Count ++ ; Cell Type not Me = new Cell Type ( BOOL , Cell Factory ) ; m Cell Types By View Type . put ( m View Type Count , not Me ) ; m Their View Types By Cell . put ( Cell Factory , m View Type Count ) ; } return this ; }
protected String consume BOM ( Input Stream stream , String encoding ) throws IO Exception { byte [ ] b = new byte [ NUM ] ; int count = NUM ; stream . mark ( NUM ) ; if ( encoding . equals ( STRING ) ) { count = stream . read ( b , NUM , NUM ) ; if ( count == NUM ) { final int b0 = b [ NUM ] & NUM ; final int b1 = b [ NUM ] & NUM ; final int b2 = b [ NUM ] & NUM ; if ( b0 != NUM || b1 != NUM || b2 != NUM ) { stream . reset ( ) ; } } else { stream . reset ( ) ; } } else if ( encoding . starts With ( STRING ) ) { count = stream . read ( b , NUM , NUM ) ; if ( count == NUM ) { final int b0 = b [ NUM ] & NUM ; final int b1 = b [ NUM ] & NUM ; if ( b0 == NUM && b1 == NUM ) { return STRING ; } else if ( b0 == NUM && b1 == NUM ) { return STRING ; } } stream . reset ( ) ; } return encoding ; }
public static int create With Id Generation ( Connection connection , String raw Sql Query , Object ... parameters ) throws SQL Exception { Prepared Statement stmt = null ; Result Set rs = null ; try { stmt = connection . prepare Statement ( raw Sql Query , Statement . RETURN GENERATED KEYS ) ; for ( int index = NUM ; index < parameters . length ; index ++ ) { Jdbc Utils . bind Parameter ( stmt , index + NUM , parameters [ index ] ) ; } stmt . execute Update ( ) ; rs = stmt . get Generated Keys ( ) ; rs . next ( ) ; return rs . get Int ( NUM ) ; } finally { Jdbc Utils . close Result Set ( rs ) ; Jdbc Utils . close Statement ( stmt ) ; } }
public boolean write Header ( Output Stream os ) { try { write Int ( os , CACHE MAGIC ) ; write String ( os , key ) ; write String ( os , etag == null ? STRING : etag ) ; write Long ( os , server Date ) ; write Long ( os , last Modified ) ; write Long ( os , ttl ) ; write Long ( os , soft Ttl ) ; write String String Map ( response Headers , os ) ; os . flush ( ) ; return BOOL ; } catch ( IO Exception e ) { Volley Log . d ( STRING , e . to String ( ) ) ; return BOOL ; } }
public static int and Not ( int a [ ] , int lena , int b [ ] , int lenb , int [ ] target ) { if ( lena == NUM ) return NUM ; if ( lenb == NUM ) { System . arraycopy ( a , NUM , target , NUM , lena ) ; return lena ; } if ( ( lenb > > NUM ) >= lena ) { return and Not Binary Search ( a , lena , b , lenb , target ) ; } int count = NUM ; int i = NUM , j = NUM ; int doca = a [ i ] , docb = b [ j ] ; for ( ; ; ) { if ( doca > docb ) { if ( ++ j >= lenb ) break ; docb = b [ j ] ; } else if ( doca < docb ) { target [ count ++ ] = doca ; if ( ++ i >= lena ) break ; doca = a [ i ] ; } else { if ( ++ i >= lena ) break ; doca = a [ i ] ; if ( ++ j >= lenb ) break ; docb = b [ j ] ; } } int leftover = lena - i ; if ( leftover > NUM ) { System . arraycopy ( a , i , target , count , leftover ) ; count += leftover ; } return count ; }
public boolean remove ( Http Connection connection ) { Time Values times = connection To Times . remove ( connection ) ; if ( times == null ) { log . warn ( STRING ) ; return BOOL ; } else { return System . current Time Millis ( ) <= times . time Expires ; } }
void create Buttons ( ) { if ( scroll Forward Button != null ) { tab Pane . remove ( scroll Forward Button ) ; scroll Forward Button . remove Action Listener ( this ) ; tab Pane . remove ( scroll Backward Button ) ; scroll Backward Button . remove Action Listener ( this ) ; } int tab Placement = tab Pane . get Tab Placement ( ) ; int width = UI Manager . get Int ( STRING ) ; if ( tab Placement == TOP || tab Placement == BOTTOM ) { scroll Forward Button = new Arrow Button ( EAST , width ) ; scroll Backward Button = new Arrow Button ( WEST , width ) ; } else { scroll Forward Button = new Arrow Button ( SOUTH , width ) ; scroll Backward Button = new Arrow Button ( NORTH , width ) ; } scroll Forward Button . add Action Listener ( this ) ; scroll Backward Button . add Action Listener ( this ) ; tab Pane . add ( scroll Forward Button ) ; tab Pane . add ( scroll Backward Button ) ; }
public void or ( Criteria criteria ) { ored Criteria . add ( criteria ) ; }
private boolean check Touch Slop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL ; } final boolean check Horizontal = m Callback . get View Horizontal Drag Range ( child ) > NUM ; final boolean check Vertical = m Callback . get View Vertical Drag Range ( child ) > NUM ; if ( check Horizontal && check Vertical ) { return dx * dx + dy * dy > m Touch Slop * m Touch Slop ; } else if ( check Horizontal ) { return Math . abs ( dx ) > m Touch Slop ; } else if ( check Vertical ) { return Math . abs ( dy ) > m Touch Slop ; } return BOOL ; }
public static String rm Slash From Url ( final String url ) { return url . ends With ( STRING ) ? url . substring ( NUM , url . length ( ) - NUM ) : url ; }
protected void update Chart Layout ( ) { chart Container . remove All ( ) ; List < String > selected Metrics = get Selected Metrics ( ) ; if ( selected Metrics . size ( ) > NUM ) { if ( selected Metrics . size ( ) <= NUM ) { chart Container . set Layout ( new Grid Layout ( NUM , NUM ) ) ; } else if ( selected Metrics . size ( ) <= NUM ) { chart Container . set Layout ( new Grid Layout ( NUM , NUM ) ) ; } else if ( selected Metrics . size ( ) <= NUM ) { chart Container . set Layout ( new Grid Layout ( NUM , NUM ) ) ; } else if ( selected Metrics . size ( ) <= NUM ) { chart Container . set Layout ( new Grid Layout ( NUM , NUM ) ) ; } else { chart Container . set Layout ( new Grid Layout ( ( int ) Math . ceil ( selected Metrics . size ( ) / NUM ) , NUM ) ) ; } Grid Layout layout = ( Grid Layout ) chart Container . get Layout ( ) ; int spaces = layout . get Rows ( ) * layout . get Columns ( ) ; for ( int i = NUM ; i < Math . max ( spaces , selected Metrics . size ( ) ) ; i ++ ) { if ( i < selected Metrics . size ( ) ) { chart Container . add ( create Chart ( selected Metrics . get ( i ) ) ) ; } else { chart Container . add ( new Empty Plot ( this ) ) ; } } } chart Container . revalidate ( ) ; }
public String host ( Properties props ) { return props . get Property ( HOST PROPERTY KEY , STRING ) ; }
void cancel ( ) { set Visible ( BOOL ) ; }
@ Override public Mem Chunk Holder < Volatile Mem Allocator > create Chunk ( long size , boolean autoreclaim ) { Mem Chunk Holder < Volatile Mem Allocator > ret = null ; Long addr = m vmasvc . allocate ( m nid , size , BOOL ) ; if ( NUM == addr && m activegc ) { m chunkcollector . wait Reclaim Cool Down ( m gctimeout ) ; addr = m vmasvc . allocate ( m nid , size , BOOL ) ; } if ( NUM != addr ) { ret = new Mem Chunk Holder < Volatile Mem Allocator > ( this , addr , size ) ; ret . set Collector ( m chunkcollector ) ; if ( autoreclaim ) { m chunkcollector . register ( ret ) ; } } return ret ; }
public void wait For Invocation ( long msec Wait , int number Of New Events ) { long start Time = System . current Time Millis ( ) ; while ( BOOL ) { if ( ( System . current Time Millis ( ) - start Time ) > msec Wait ) { throw new Runtime Exception ( STRING + number Of New Events + STRING + get New Data List Flattened ( ) . length ) ; } Event Bean [ ] events = get New Data List Flattened ( ) ; if ( events . length >= number Of New Events ) { return ; } try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { return ; } } }
private String version Name ( String prefix , int ver ) { return f Name ( prefix ) + String . value Of ( ver ) ; }
private void request Permission If Needed ( ) { if ( Build . VERSION . SDK INT >= Build . VERSION CODES . M ) { int has Enable Coarse Location Perm = check Self Permission ( Manifest . permission . ACCESS COARSE LOCATION ) ; int has Enable Fine Location Perm = check Self Permission ( Manifest . permission . ACCESS FINE LOCATION ) ; int has Enable External Write Perm = check Self Permission ( Manifest . permission . WRITE EXTERNAL STORAGE ) ; List < String > permission To Request = new Array List < > ( ) ; if ( has Enable Coarse Location Perm == Package Manager . PERMISSION DENIED ) { permission To Request . add ( Manifest . permission . ACCESS COARSE LOCATION ) ; } if ( has Enable Fine Location Perm == Package Manager . PERMISSION DENIED ) { permission To Request . add ( Manifest . permission . ACCESS FINE LOCATION ) ; } if ( has Enable External Write Perm == Package Manager . PERMISSION DENIED ) { permission To Request . add ( Manifest . permission . WRITE EXTERNAL STORAGE ) ; } if ( ! permission To Request . is Empty ( ) ) { request Permissions ( permission To Request . to Array ( new String [ permission To Request . size ( ) ] ) , ALLOW PERMISSIONS ) ; } else { init Event ( ) ; } } }
public Extract Method Refactoring ( I Compilation Unit unit , int selection Start , int selection Length ) { fC Unit = unit ; f Root = null ; f Method Name = STRING ; f Selection Start = selection Start ; f Selection Length = selection Length ; f Visibility = - NUM ; }
@ Override public boolean done ( ) { if ( stopping Increments && increments Left == NUM ) return BOOL ; else return BOOL ; }
public void parse ( ) throws java . lang . Exception { int act ; symbol lhs sym ; short handle size , lhs sym num ; production tab = production table ( ) ; action tab = action table ( ) ; reduce tab = reduce table ( ) ; init actions ( ) ; user init ( ) ; cur token = scan ( ) ; stack . push ( new symbol ( NUM , start state ( ) ) ) ; tos = NUM ; for ( done parsing = BOOL ; ! done parsing ; ) { act = get action ( ( ( symbol ) stack . peek ( ) ) . parse state , cur token . sym ) ; if ( act > NUM ) { cur token . parse state = act - NUM ; stack . push ( cur token ) ; tos ++ ; cur token = scan ( ) ; } else if ( act < NUM ) { lhs sym = do action ( ( - act ) - NUM , this , stack , tos ) ; lhs sym num = production tab [ ( - act ) - NUM ] [ NUM ] ; handle size = production tab [ ( - act ) - NUM ] [ NUM ] ; for ( int i = NUM ; i < handle size ; i ++ ) { stack . pop ( ) ; tos -- ; } act = get reduce ( ( ( symbol ) stack . peek ( ) ) . parse state , lhs sym num ) ; lhs sym . parse state = act ; stack . push ( lhs sym ) ; tos ++ ; } else if ( act == NUM ) { syntax error ( cur token ) ; if ( ! error recovery ( BOOL ) ) { unrecovered syntax error ( cur token ) ; done parsing ( ) ; } } } }
private static void write Set 1 ( final B Tree btree ) { log . info ( STRING ) ; for ( int i = NUM ; i < NUM ; i ++ ) { btree . insert ( i , i ) ; } }
private byte [ ] create Segment Table ( int setup Header Length , List < Ogg Page Header . Packet Start And Length > extra Packets ) { Byte Array Output Stream result Baos = new Byte Array Output Stream ( ) ; byte [ ] rest Should Be ; byte [ ] next Packet ; rest Should Be = create Segments ( setup Header Length , BOOL ) ; try { result Baos . write ( rest Should Be ) ; if ( extra Packets . size ( ) > NUM ) { for ( Ogg Page Header . Packet Start And Length packet : extra Packets ) { next Packet = create Segments ( packet . get Length ( ) , BOOL ) ; result Baos . write ( next Packet ) ; } } } catch ( IO Exception ioe ) { throw new Runtime Exception ( STRING + ioe . get Message ( ) ) ; } return result Baos . to Byte Array ( ) ; }
public static int index Of Ignore Case ( String src , String sub , int start Index , int end Index ) { if ( start Index < NUM ) { start Index = NUM ; } int srclen = src . length ( ) ; if ( end Index > srclen ) { end Index = srclen ; } int sublen = sub . length ( ) ; if ( sublen == NUM ) { return start Index > srclen ? srclen : start Index ; } sub = sub . to Lower Case ( ) ; int total = end Index - sublen + NUM ; char c = sub . char At ( NUM ) ; mainloop : for ( int i = start Index ; i < total ; i ++ ) { if ( Character . to Lower Case ( src . char At ( i ) ) != c ) { continue ; } int j = NUM ; int k = i + NUM ; while ( j < sublen ) { char source = Character . to Lower Case ( src . char At ( k ) ) ; if ( sub . char At ( j ) != source ) { continue mainloop ; } j ++ ; k ++ ; } return i ; } return - NUM ; }
private void add Polygon Ring ( Linear Ring lr , int cw Left , int cw Right ) { if ( lr . is Empty ( ) ) return ; Coordinate [ ] coord = Coordinate Arrays . remove Repeated Points ( lr . get Coordinates ( ) ) ; if ( coord . length < NUM ) { has Too Few Points = BOOL ; invalid Point = coord [ NUM ] ; return ; } int left = cw Left ; int right = cw Right ; if ( CG Algorithms . is CCW ( coord ) ) { left = cw Right ; right = cw Left ; } Edge e = new Edge ( coord , new Label ( arg Index , Location . BOUNDARY , left , right ) ) ; line Edge Map . put ( lr , e ) ; insert Edge ( e ) ; insert Point ( arg Index , coord [ NUM ] , Location . BOUNDARY ) ; }
public boolean accepts Load Name ( String load ) { if ( load Option . equals ( ALL LOADS ) ) { return BOOL ; } if ( load Option . equals ( INCLUDE LOADS ) ) { return load List . contains ( load ) ; } return ! load List . contains ( load ) ; }
public static void expand Letters ( String letters , Word Relation word Relation ) { letters = letters . to Lower Case ( ) ; char c ; for ( int i = NUM ; i < letters . length ( ) ; i ++ ) { c = letters . char At ( i ) ; if ( is Digit ( c ) ) { word Relation . add Word ( digit 2 num [ c - STRING ] ) ; } else if ( letters . equals ( STRING ) ) { word Relation . add Word ( STRING ) ; } else { word Relation . add Word ( String . value Of ( c ) ) ; } } }
public static void write String To File ( File file , String data , Charset encoding , boolean append ) throws IO Exception { Output Stream out = null ; try { out = open Output Stream ( file , append ) ; IO Utils . write ( data , out , encoding ) ; out . close ( ) ; } finally { IO Utils . close Quietly ( out ) ; } }
@ Deprecated public static void subtract ( String name , double amount ) throws User Does Not Exist Exception , No Loan Permitted Exception { try { substract ( name , Big Decimal . value Of ( amount ) ) ; } catch ( Arithmetic Exception e ) { logger . log ( Level . WARNING , STRING + amount + STRING + name + STRING + e . get Message ( ) , e ) ; } }
public Mnemonic Code ( Input Stream wordstream , String word List Digest ) throws IO Exception , Illegal Argument Exception { Buffered Reader br = new Buffered Reader ( new Input Stream Reader ( wordstream , STRING ) ) ; word List = new Array List < String > ( NUM ) ; String word ; while ( ( word = br . read Line ( ) ) != null ) word List . add ( word ) ; br . close ( ) ; initialize From Words ( word List , word List Digest ) ; }
public QK Dialog add Menu Item ( String title , long id ) { m Menu Items . add ( title ) ; m Menu Item Ids . add ( id ) ; return this ; }
public Anchor Pane create Finger Print Panel ( Array List < Fp Panel > fingerprint Panel List ) { return create Finger Print Panel ( fingerprint Panel List , null ) ; }
private static boolean is Memory Access ( final String value ) { return value . equals ( STRING ) ; }
public void add Attribute ( Attribute Info info ) { Attribute Info . remove ( attributes , info . get Name ( ) ) ; attributes . add ( info ) ; }
private static boolean verify String Param ( String str , int max Length , String acceptable Characters ) { return ! ( str == null || str . length ( ) == NUM || str . length ( ) > max Length || ! Pattern . matches ( acceptable Characters , str ) ) ; }
private int calculate Drag Sensitivity ( ) { int range = MAX DRAG SENSITIVITY - MIN DRAG SENSITIVITY ; return Math . round ( ( NUM - get Drag Sensitivity ( ) ) * range + MIN DRAG SENSITIVITY ) ; }
public static String lower First Char ( String string ) { if ( string == null ) return null ; if ( string . length ( ) <= NUM ) return string . to Lower Case ( ) ; String Builder sb = new String Builder ( string ) ; sb . set Char At ( NUM , Character . to Lower Case ( sb . char At ( NUM ) ) ) ; return sb . to String ( ) ; }
public void for Each Block Pos Mutable Top Down ( Predicate < Block Pos > func ) { Block Pos . Mutable Block Pos block Pos = new Block Pos . Mutable Block Pos ( ) ; int base X = get Min Block X ( ) ; int base Z = get Min Block Z ( ) ; int block Y Max = get Max Block Y ( ) ; for ( int x = NUM ; x < NUM ; x ++ ) { for ( int z = NUM ; z < NUM ; z ++ ) { block Pos . set Pos ( base X + x , block Y Max , base Z + z ) ; for ( int y = NUM ; y >= NUM ; y -- ) { boolean cont = func . test ( block Pos ) ; block Pos . move ( Enum Facing . DOWN ) ; if ( ! cont ) { break ; } } } } }
public String visit ( Type t , Locale locale ) { return t . accept ( this , locale ) ; }
public static final void write Map Xml ( Map val , Xml Serializer out , Write Map Callback callback ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { return ; } Set s = val . entry Set ( ) ; Iterator i = s . iterator ( ) ; while ( i . has Next ( ) ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; write Value Xml ( e . get Value ( ) , ( String ) e . get Key ( ) , out , callback ) ; } }
public static void drop Table ( String table , Connection connection ) { table = table . replace ( STRING , STRING ) ; String Builder drop Table Query = new String Builder ( ) ; drop Table Query . append ( STRING ) ; drop Table Query . append ( table ) ; LOG . info ( STRING ) ; LOG . info ( drop Table Query ) ; execute Statement If Exists ( drop Table Query . to String ( ) , connection ) ; }
private int free Space ( ) { return buffer . capacity ( ) - buffer . limit ( ) + buffer . position ( ) ; }
@ Override public List < Node > generate ( int pop Size ) { List < Node > population = new Array List < > ( ) ; for ( int i = NUM ; i < pop Size ; ) { Node candidate = grow ( NUM ) ; if ( candidate . is Valid ( ) ) { population . add ( candidate ) ; i ++ ; } } return population ; }
public synchronized void notify Before Use ( Composite Transaction ct ) throws Invalid Session Handle State Exception { if ( closed ) throw new Invalid Session Handle State Exception ( STRING ) ; try { Transaction Context suspended = null ; if ( ct != null ) { Iterator < Transaction Context > it = all Contexts . iterator ( ) ; while ( it . has Next ( ) && suspended == null ) { Transaction Context b = ( Transaction Context ) it . next ( ) ; if ( b . is Suspended In Transaction ( ct ) ) { suspended = b ; } } } if ( suspended != null ) { if ( LOGGER . is Debug Enabled ( ) ) LOGGER . log Debug ( this + STRING + ct . get Tid ( ) ) ; current Context = suspended ; current Context . transaction Resumed ( ) ; } else { try { if ( LOGGER . is Trace Enabled ( ) ) LOGGER . log Trace ( this + STRING + ct ) ; current Context . check Enlist Before Use ( ct ) ; } catch ( Unexpected Transaction Context Exception tx Boundary Passed ) { if ( LOGGER . is Debug Enabled ( ) ) LOGGER . log Debug ( this + STRING + ct ) ; current Context . transaction Suspended ( ) ; current Context = new Transaction Context ( resource , xa Resource ) ; all Contexts . add ( current Context ) ; try { current Context . check Enlist Before Use ( ct ) ; } catch ( Unexpected Transaction Context Exception e ) { String msg = STRING ; LOGGER . log Error ( msg , e ) ; throw new Invalid Session Handle State Exception ( msg ) ; } } } } catch ( Invalid Session Handle State Exception e ) { notify Session Error Occurred ( ) ; throw e ; } }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
public void on Activity Result ( int request Code , int result Code , Intent data ) { if ( m Initialization Complete ) { m Activity Delegate . on Activity Result With Native ( request Code , result Code , data ) ; } else { if ( m Pending Activity Results == null ) { m Pending Activity Results = new Array List < Activity Result > ( NUM ) ; } m Pending Activity Results . add ( new Activity Result ( request Code , result Code , data ) ) ; } }
public void delete Selection ( Array List < Integer > nodes ) { for ( int i = NUM ; i < nodes . size ( ) ; i ++ ) { for ( int j = i + NUM ; j < nodes . size ( ) ; j ++ ) { if ( nodes . get ( i ) > nodes . get ( j ) ) { int h = nodes . get ( i ) ; nodes . set ( i , nodes . get ( j ) ) ; nodes . set ( j , h ) ; } } } if ( m b Needs Undo Action ) { add Undo Action ( new Delete Selection Action ( nodes ) ) ; } boolean b Needs Undo Action = m b Needs Undo Action ; m b Needs Undo Action = BOOL ; try { for ( int i Node = nodes . size ( ) - NUM ; i Node >= NUM ; i Node -- ) { delete Node ( nodes . get ( i Node ) ) ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; } m b Needs Undo Action = b Needs Undo Action ; }
protected void on Cached ( ) { if ( Log Configuration . logging Is Enabled ( ) ) { logger . log ( Level . INFO , STRING ) ; } ui Handler . hide Message ( ) ; updating = BOOL ; fire Application Cache Event ( Cache Event . on Cached ) ; }
public static void show String ( String title , String content , Dimension dimension ) { J Text Area area = new J Text Area ( content ) ; area . set Editable ( BOOL ) ; J Scroll Pane scroll = new J Scroll Pane ( area ) ; scroll . set Preferred Size ( dimension ) ; J Option Pane . show Message Dialog ( null , scroll , title , J Option Pane . INFORMATION MESSAGE ) ; }
private void mark CG For Deletion ( Block Consistency Group consistency Group ) { if ( ! consistency Group . get Inactive ( ) ) { consistency Group . set Storage Controller ( null ) ; consistency Group . set Inactive ( BOOL ) ; db Client . update Object ( consistency Group ) ; } }
public Long Buffer put ( long [ ] src , int src Offset , int long Count ) { J Transc Arrays . check Offset And Count ( src . length , src Offset , long Count ) ; if ( long Count > remaining ( ) ) { throw new Buffer Overflow Exception ( ) ; } for ( int i = src Offset ; i < src Offset + long Count ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public void play Together ( Collection < Animator > items ) { if ( items != null && items . size ( ) > NUM ) { m Needs Sort = BOOL ; Builder builder = null ; for ( Animator anim : items ) { if ( builder == null ) { builder = play ( anim ) ; } else { builder . with ( anim ) ; } } } }
private Message Context create Message Context ( Axis Engine engine , Http Servlet Request req , Http Servlet Response res , Component component ) { Message Context msg Context = new Message Context ( engine ) ; String request Path = get Request Path ( req ) ; if ( is Debug ) { log . debug ( STRING + msg Context ) ; log . debug ( STRING + req . get Header ( HTTP Constants . HEADER CONTENT TYPE ) ) ; log . debug ( STRING + req . get Header ( HTTP Constants . HEADER CONTENT LOCATION ) ) ; log . debug ( STRING + String . value Of ( home Dir ) ) ; log . debug ( STRING + request Path ) ; log . debug ( STRING + String . value Of ( web Inf Path ) ) ; log . debug ( STRING + req . get Path Info ( ) ) ; log . debug ( STRING + req . get Header ( HTTP Constants . HEADER AUTHORIZATION ) ) ; log . debug ( STRING + req . get Remote Addr ( ) ) ; log . debug ( STRING + String . value Of ( web Inf Path ) ) ; } msg Context . set Transport Name ( STRING ) ; msg Context . set Property ( Constants . MC HOME DIR , home Dir ) ; msg Context . set Property ( Constants . MC RELATIVE PATH , request Path ) ; msg Context . set Property ( HTTP Constants . MC HTTP SERVLET , this ) ; msg Context . set Property ( HTTP Constants . MC HTTP SERVLETREQUEST , req ) ; msg Context . set Property ( HTTP Constants . MC HTTP SERVLETRESPONSE , res ) ; msg Context . set Property ( HTTP Constants . MC HTTP SERVLETLOCATION , web Inf Path ) ; msg Context . set Property ( HTTP Constants . MC HTTP SERVLETPATHINFO , req . get Path Info ( ) ) ; msg Context . set Property ( HTTP Constants . HEADER AUTHORIZATION , req . get Header ( HTTP Constants . HEADER AUTHORIZATION ) ) ; msg Context . set Property ( lucee . runtime . net . rpc . server . Constants . COMPONENT , component ) ; msg Context . set Property ( Constants . MC REMOTE ADDR , req . get Remote Addr ( ) ) ; Servlet Endpoint Context Impl sec = new Servlet Endpoint Context Impl ( ) ; msg Context . set Property ( Constants . MC SERVLET ENDPOINT CONTEXT , sec ) ; String realpath = context . get Real Path ( request Path ) ; if ( realpath != null ) { msg Context . set Property ( Constants . MC REALPATH , realpath ) ; } msg Context . set Property ( Constants . MC CONFIGPATH , web Inf Path ) ; return msg Context ; }
@ Override public void invoke Command ( int arg Length , String [ ] args , String command ) { Pattern regex = null ; if ( args . length == NUM ) { regex = Pattern . compile ( args [ NUM ] ) ; } else if ( args . length != NUM ) { throw new Usage Exception ( STRING ) ; } for ( Abstract Command cmd : Command Bus . commands ) try Regex ( regex , cmd ) ; for ( Fuzzy Command cmd : Command Bus . parsers ) try Regex ( regex , cmd ) ; }
public static Builder new Builder ( ) { return new Builder ( ) ; }
protected int parse And Add Node ( Xml Resource Parser parser , Hash Map < String , Tag Parser > tag Parser Map , Array List < Long > screen Ids ) throws Xml Pull Parser Exception , IO Exception { if ( TAG INCLUDE . equals ( parser . get Name ( ) ) ) { final int res Id = get Attribute Resource Value ( parser , ATTR WORKSPACE , NUM ) ; if ( res Id != NUM ) { return parse Layout ( res Id , screen Ids ) ; } else { return NUM ; } } m Values . clear ( ) ; parse Container And Screen ( parser , m Temp ) ; final long container = m Temp [ NUM ] ; final long screen Id = m Temp [ NUM ] ; m Values . put ( Launcher Settings . Favorites . CONTAINER , container ) ; m Values . put ( Launcher Settings . Favorites . SCREEN , screen Id ) ; m Values . put ( Launcher Settings . Favorites . CELLX , convert To Distance From End ( get Attribute Value ( parser , ATTR X ) , m Column Count ) ) ; m Values . put ( Launcher Settings . Favorites . CELLY , convert To Distance From End ( get Attribute Value ( parser , ATTR Y ) , m Row Count ) ) ; Tag Parser tag Parser = tag Parser Map . get ( parser . get Name ( ) ) ; if ( tag Parser == null ) { if ( LOGD ) Log . d ( TAG , STRING + parser . get Name ( ) ) ; return NUM ; } long new Element Id = tag Parser . parse And Add ( parser ) ; if ( new Element Id >= NUM ) { if ( ! screen Ids . contains ( screen Id ) && container == Launcher Settings . Favorites . CONTAINER DESKTOP ) { screen Ids . add ( screen Id ) ; } return NUM ; } return NUM ; }
public Word Entry add New Word ( final String str ) { final String key = trim Word ( str ) ; Word Entry entry = words . get ( key ) ; if ( entry == null ) { entry = new Word Entry ( ) ; entry . set Type ( new Expression Type ( STRING ) ) ; entry . set Normalized ( key ) ; words . put ( key , entry ) ; } else { logger . warn ( STRING + str + STRING + entry . get Normalized ( ) ) ; } return entry ; }
@ Override public int insert ( String elem ) { int first Index = ( int ) ( elem . char At ( NUM ) - STRING ) ; int middle Index = ( int ) ( elem . char At ( - NUM + elem . length ( ) / NUM ) - STRING ) ; int last Index = ( int ) ( elem . char At ( elem . length ( ) - NUM ) - STRING ) ; storage [ first Index * NUM + middle Index * NUM + last Index ] = elem ; return NUM ; }
@ Override protected void on Measure ( int width Measure Spec , int height Measure Spec ) { m Width = Measure Spec . get Size ( width Measure Spec ) ; m Height = Measure Spec . get Size ( height Measure Spec ) ; int min Side = Math . min ( m Width , m Height ) ; m Width = min Side ; m Height = min Side ; m Current Progress Position = calculate Current Position From Current Seconds ( m Current Seconds ) ; object Animator Progress . set Float Values ( m Current Progress Position / m Width , NUM ) ; object Animator Progress . set Duration ( ( m Max Seconds - m Current Seconds ) * NUM ) ; if ( m Bitmap Cover Image != null ) scale Cover Bitmap ( m Bitmap Cover Image ) ; rect F Empty Progress . set ( NUM , m Height - m Progress Height , m Width , m Height ) ; m Drawable Bottom Shadow . set Bounds ( NUM , ( NUM * m Height ) / NUM , m Width , m Height ) ; if ( start Requested ) { start Requested = BOOL ; start ( ) ; } super . on Measure ( width Measure Spec , height Measure Spec ) ; }
protected List < Command > handle Commands ( Server Connector server Connector , List < Command > commands ) { List < Command > results = new Array List < Command > ( ) ; for ( Command command : commands ) { if ( LOG . is Loggable ( Level . FINEST ) ) { LOG . finest ( STRING + command ) ; } results . add All ( server Connector . receive ( command ) ) ; } return results ; }
public static void UF 5 ( double [ ] x , double [ ] f , int nx ) { int count 1 = NUM ; int count 2 = NUM ; double sum 1 = NUM ; double sum 2 = NUM ; double yj ; double hj ; double N = NUM ; double E = NUM ; for ( int j = NUM ; j <= nx ; j ++ ) { yj = x [ j - NUM ] - Math . sin ( NUM * PI * x [ NUM ] + j * PI / nx ) ; hj = NUM * yj * yj - Math . cos ( NUM * PI * yj ) + NUM ; if ( j % NUM == NUM ) { sum 2 += hj ; count 2 ++ ; } else { sum 1 += hj ; count 1 ++ ; } } hj = ( NUM / N + E ) * Math . abs ( Math . sin ( NUM * N * PI * x [ NUM ] ) ) ; f [ NUM ] = x [ NUM ] + hj + NUM * sum 1 / ( double ) count 1 ; f [ NUM ] = NUM - x [ NUM ] + hj + NUM * sum 2 / ( double ) count 2 ; }
private View fill Up ( int pos , int next Bottom ) { if ( DEBUG ) Log . i ( TAG , STRING + pos + STRING + next Bottom + M FIRST POSITION + m First Position ) ; View selected View = null ; final int end = m List Padding . top ; while ( next Bottom > end && pos >= NUM ) { View temp = make Row ( pos , next Bottom , BOOL ) ; if ( temp != null ) { selected View = temp ; } next Bottom = m Reference View . get Top ( ) - m Vertical Spacing ; m First Position = pos ; pos -= m Num Columns ; } if ( m Stack From Bottom ) { m First Position = Math . max ( NUM , pos + NUM ) ; } return selected View ; }
private List < Validation Error > validate ( ) { List < Validation Error > errors = Lists . new Array List ( ) ; Module module = get Module ( ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Module ( module ) ) ; Android Facet facet = null ; if ( module != null ) { facet = Android Facet . get Instance ( module ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Facet ( facet , module ) ) ; } errors . add All ( config State . validate ( facet ) ) ; errors . add All ( Blaze Android Run Configuration Validation Util . validate Label ( get Label ( ) , configuration . get Project ( ) , Kind . ANDROID BINARY ) ) ; return errors ; }
public void remove Child Job ( Job child Job ) { if ( ! child Jobs . contains ( child Job ) ) { throw new Runtime Exception ( STRING + child Job + STRING ) ; } boolean removed = child Jobs . remove ( child Job ) ; if ( ! removed ) { throw new Runtime Exception ( STRING ) ; } }
private Point F is Flinging To Delete ( Drag Source source ) { if ( m Fling To Delete Drop Target == null ) return null ; if ( ! source . supports Fling To Delete ( ) ) return null ; View Configuration config = View Configuration . get ( m Launcher ) ; m Velocity Tracker . compute Current Velocity ( NUM , config . get Scaled Maximum Fling Velocity ( ) ) ; if ( m Velocity Tracker . get Y Velocity ( ) < m Fling To Delete Threshold Velocity ) { Point F vel = new Point F ( m Velocity Tracker . get X Velocity ( ) , m Velocity Tracker . get Y Velocity ( ) ) ; Point F up Vec = new Point F ( NUM , - NUM ) ; float theta = ( float ) Math . acos ( ( ( vel . x * up Vec . x ) + ( vel . y * up Vec . y ) ) / ( vel . length ( ) * up Vec . length ( ) ) ) ; if ( theta <= Math . to Radians ( MAX FLING DEGREES ) ) { return vel ; } } return null ; }
private int clamp Mag ( int value , int abs Min , int abs Max ) { final int abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; { boolean success = BOOL ; try { child . delete Data ( NUM , NUM ) ; } catch ( DOM Exception ex ) { success = ( ex . code == DOM Exception . INDEX SIZE ERR ) ; } assert True ( STRING , success ) ; } }
public static void run Script ( final File file , final List < Pair < String , Object > > bindings ) throws Script Exception , IO Exception { final Script Engine engine = manager . get Engine By Extension ( File Utils . get File Extension ( file ) ) ; Preconditions . check Not Null ( engine , STRING , file . get Absolute Path ( ) ) ; final String script = File Utils . read Textfile ( file ) ; run Script ( engine , script , bindings ) ; }
public void add U Graphic ( U Graphic ug ) { graphics . add Element ( ug ) ; }
public void apply ( ) throws Illegal State Exception { try { System . set Security Manager ( this ) ; } catch ( Security Exception e ) { logger . error ( STRING , e ) ; throw new Illegal State Exception ( e ) ; } }
public static Rule create A Get Post Rule ( String rule Name , String rule Url ) throws Policy Exception { Map < String , Set < String > > action Values = new Hash Map < String , Set < String > > ( ) ; Set < String > set = new Hash Set < String > ( ) ; set . add ( ALLOW DECISION ) ; action Values . put ( GET ACTION , set ) ; set = new Hash Set < String > ( ) ; set . add ( ALLOW DECISION ) ; action Values . put ( POST ACTION , set ) ; return new Rule ( rule Name , IPLANETAMWEBAGENTSERVICE , rule Url , action Values ) ; }
public Fast Array List ( Collection < ? extends E > c ) { element Data = c . to Array ( ) ; size = element Data . length ; if ( element Data . get Class ( ) != Object [ ] . class ) element Data = Arrays . copy Of ( element Data , size , Object [ ] . class ) ; }
void create Scene Vao ( ) { int vao = gl Gen Vertex Arrays ( ) ; int vbo = gl Gen Buffers ( ) ; gl Bind Vertex Array ( vao ) ; gl Bind Buffer ( GL ARRAY BUFFER , vbo ) ; long buffer Size = NUM * ( NUM + NUM ) * mesh . num Vertices ; long normals Offset = NUM * NUM * mesh . num Vertices ; gl Buffer Data ( GL ARRAY BUFFER , buffer Size , GL STATIC DRAW ) ; gl Buffer Sub Data ( GL ARRAY BUFFER , NUM , mesh . positions ) ; gl Buffer Sub Data ( GL ARRAY BUFFER , normals Offset , mesh . normals ) ; gl Enable Vertex Attrib Array ( NUM ) ; gl Vertex Attrib Pointer ( NUM , NUM , GL FLOAT , BOOL , NUM , NUM ) ; gl Enable Vertex Attrib Array ( NUM ) ; gl Vertex Attrib Pointer ( NUM , NUM , GL FLOAT , BOOL , NUM , normals Offset ) ; gl Bind Buffer ( GL ARRAY BUFFER , NUM ) ; gl Bind Vertex Array ( NUM ) ; this . vao Scene = vao ; }
public List < ? > end Batch ( ) { List < ? > result = null ; if ( operations Batch . size ( ) > NUM ) { result = do Flush ( ) ; } use Batch = BOOL ; operations Batch = null ; return result ; }
private int calculate Layout Width ( int width Size , int mode ) { init Resources If Necessary ( ) ; items Layout . set Layout Params ( new Layout Params ( Layout Params . WRAP CONTENT , Layout Params . WRAP CONTENT ) ) ; items Layout . measure ( Measure Spec . make Measure Spec ( width Size , Measure Spec . UNSPECIFIED ) , Measure Spec . make Measure Spec ( NUM , Measure Spec . UNSPECIFIED ) ) ; int width = items Layout . get Measured Width ( ) ; if ( mode == Measure Spec . EXACTLY ) { width = width Size ; } else { width += NUM * PADDING ; width = Math . max ( width , get Suggested Minimum Width ( ) ) ; if ( mode == Measure Spec . AT MOST && width Size < width ) { width = width Size ; } } items Layout . measure ( Measure Spec . make Measure Spec ( width - NUM * PADDING , Measure Spec . EXACTLY ) , Measure Spec . make Measure Spec ( NUM , Measure Spec . UNSPECIFIED ) ) ; return width ; }
public static Collection remove Inner Class Names ( Collection col ) { List list = new Array List ( ) ; list . add All ( col ) ; Iterator it = list . iterator ( ) ; while ( it . has Next ( ) ) { String name = ( String ) it . next ( ) ; if ( name . index Of ( STRING ) != - NUM ) it . remove ( ) ; } return list ; }
public Trie Node find ( String word ) { return ( word . length ( ) < NUM ? null : find ( word , root , NUM ) ) ; }
private void test Ordered Indexes ( ) throws SQL Exception { delete Db ( STRING ) ; Connection conn = get Connection ( STRING ) ; Statement stat = conn . create Statement ( ) ; stat . execute ( STRING + STRING ) ; stat . execute ( STRING ) ; Result Set rs = stat . execute Query ( STRING + STRING ) ; rs . next ( ) ; assert Contains ( rs . get String ( NUM ) , STRING ) ; stat . execute ( STRING ) ; stat . execute ( STRING ) ; stat . execute ( STRING ) ; stat . execute ( STRING ) ; rs = stat . execute Query ( STRING + STRING ) ; rs . next ( ) ; assert Contains ( rs . get String ( NUM ) , STRING ) ; conn . close ( ) ; }
public String encode ( Byte Buffer a Buffer ) { byte [ ] buf = get Bytes ( a Buffer ) ; return encode ( buf ) ; }
public static int clear List Info ( Delegator delegator , String shopping List Id ) throws Generic Entity Exception { delegator . remove By And ( STRING , Util Misc . to Map ( STRING , shopping List Id ) ) ; return delegator . remove By And ( STRING , Util Misc . to Map ( STRING , shopping List Id ) ) ; }
private synchronized void handle Watchdog ( ) { final int exit Code ; if ( watchdog == null ) return ; if ( watchdog Timeout == NUM ) return ; if ( ! is Running ( ) ) { exit Code = On Command Result Listener . SHELL DIED ; Debug . log ( String . format ( STRING , shell . to Upper Case ( Locale . ENGLISH ) ) ) ; } else if ( watchdog Count ++ < watchdog Timeout ) { return ; } else { exit Code = On Command Result Listener . WATCHDOG EXIT ; Debug . log ( String . format ( STRING , shell . to Upper Case ( Locale . ENGLISH ) ) ) ; } if ( handler != null ) { post Callback ( command , exit Code , buffer ) ; } command = null ; buffer = null ; idle = BOOL ; watchdog . shutdown ( ) ; watchdog = null ; kill ( ) ; }
public synchronized boolean has Service ( Class service Class ) { if ( service Class == null ) throw new Null Pointer Exception ( STRING ) ; synchronized ( Bean Context . global Hierarchy Lock ) { if ( services . contains Key ( service Class ) ) return BOOL ; Bean Context Services bcs = null ; try { bcs = ( Bean Context Services ) get Bean Context ( ) ; } catch ( Class Cast Exception cce ) { return BOOL ; } return bcs == null ? BOOL : bcs . has Service ( service Class ) ; } }
public boolean is Ping Disabled ( ) { return ( null != healthcheck && ! healthcheck . exists ( ) ) ; }
public static String format ( Integer i ) { if ( i == null ) return null ; return i . to String ( ) ; }
public Filename Utils ( ) { super ( ) ; }
public void dump Nodes ( Path web Graph Db , Dump Type type , long top N , Path output , boolean as Eff , Name Type name Type , Aggr Type aggr Type , boolean as Sequence File ) throws Exception { Simple Date Format sdf = new Simple Date Format ( STRING ) ; long start = System . current Time Millis ( ) ; LOG . info ( STRING + sdf . format ( start ) ) ; Path node Db = new Path ( web Graph Db , Web Graph . NODE DIR ) ; Configuration conf = get Conf ( ) ; Job Conf dumper = new Nutch Job ( conf ) ; dumper . set Job Name ( STRING + web Graph Db ) ; File Input Format . add Input Path ( dumper , node Db ) ; dumper . set Input Format ( Sequence File Input Format . class ) ; if ( name Type == null ) { dumper . set Mapper Class ( Sorter . class ) ; dumper . set Reducer Class ( Sorter . class ) ; dumper . set Map Output Key Class ( Float Writable . class ) ; dumper . set Map Output Value Class ( Text . class ) ; } else { dumper . set Mapper Class ( Dumper . class ) ; dumper . set Reducer Class ( Dumper . class ) ; dumper . set Map Output Key Class ( Text . class ) ; dumper . set Map Output Value Class ( Float Writable . class ) ; } dumper . set Output Key Class ( Text . class ) ; dumper . set Output Value Class ( Float Writable . class ) ; File Output Format . set Output Path ( dumper , output ) ; if ( as Sequence File ) { dumper . set Output Format ( Sequence File Output Format . class ) ; } else { dumper . set Output Format ( Text Output Format . class ) ; } dumper . set Num Reduce Tasks ( NUM ) ; dumper . set Boolean ( STRING , type == Dump Type . INLINKS ) ; dumper . set Boolean ( STRING , type == Dump Type . OUTLINKS ) ; dumper . set Boolean ( STRING , type == Dump Type . SCORES ) ; dumper . set Boolean ( STRING , name Type == Name Type . HOST ) ; dumper . set Boolean ( STRING , name Type == Name Type . DOMAIN ) ; dumper . set Boolean ( STRING , aggr Type == Aggr Type . SUM ) ; dumper . set Boolean ( STRING , aggr Type == Aggr Type . MAX ) ; dumper . set Long ( STRING , top N ) ; if ( as Eff ) { dumper . set ( STRING , STRING ) ; } try { LOG . info ( STRING ) ; Job Client . run Job ( dumper ) ; } catch ( IO Exception e ) { LOG . error ( String Utils . stringify Exception ( e ) ) ; throw e ; } long end = System . current Time Millis ( ) ; LOG . info ( STRING + sdf . format ( end ) + STRING + Timing Util . elapsed Time ( start , end ) ) ; }
public static String convert Method Signature ( String class Name , String method Name , String method Sig , String pkg Name ) { String Builder args = new String Builder ( ) ; Signature Converter converter = new Signature Converter ( method Sig ) ; converter . skip ( ) ; args . append ( STRING ) ; while ( converter . get First ( ) != STRING ) { if ( args . length ( ) > NUM ) { args . append ( STRING ) ; } args . append ( shorten ( pkg Name , converter . parse Next ( ) ) ) ; } converter . skip ( ) ; args . append ( STRING ) ; String Builder result = new String Builder ( ) ; result . append ( class Name ) ; result . append ( STRING ) ; result . append ( method Name ) ; result . append ( args . to String ( ) ) ; return result . to String ( ) ; }
protected void Predicate ( ) throws javax . xml . transform . Transformer Exception { if ( token Is ( STRING ) ) { next Token ( ) ; Predicate Expr ( ) ; consume Expected ( STRING ) ; } }
private void new Unit Received ( Grid Uri Deployment Unit Descriptor new Desc , Collection < Class < ? > > clss ) { assert new Desc != null ; assert new Desc . get Type ( ) == Grid Uri Deployment Unit Descriptor . Type . FILE ; if ( clss != null && ! clss . is Empty ( ) ) { try { add Resources ( new Desc . get Class Loader ( ) , new Desc , clss . to Array ( new Class < ? > [ clss . size ( ) ] ) ) ; } catch ( Ignite Spi Exception e ) { U . warn ( log , STRING + new Desc + STRING + e . get Message ( ) + STRING ) ; } } Collection < Class Loader > rmv Cls Ldrs = new Array List < > ( ) ; synchronized ( mux ) { if ( check Md 5 && unit Deployed ( new Desc . get Md 5 ( ) ) ) { if ( log . is Info Enabled ( ) ) LT . info ( log , STRING + STRING + U . hide Password ( new Desc . get Uri ( ) ) + STRING + ( new Desc . get File ( ) == null ? STRING : new Desc . get File ( ) ) + STRING ) ; return ; } boolean is Added = BOOL ; boolean ignore New Unit = BOOL ; for ( List Iterator < Grid Uri Deployment Unit Descriptor > iter = unit Loaders . list Iterator ( ) ; iter . has Next ( ) ; ) { Grid Uri Deployment Unit Descriptor desc = iter . next ( ) ; assert ! new Desc . get Class Loader ( ) . equals ( desc . get Class Loader ( ) ) : STRING + new Desc ; if ( desc . get Type ( ) == Grid Uri Deployment Unit Descriptor . Type . FILE && new Desc . get Uri ( ) . equals ( desc . get Uri ( ) ) && ! new Desc . get File ( ) . equals ( desc . get File ( ) ) ) { iter . remove ( ) ; rmv Cls Ldrs . add ( desc . get Class Loader ( ) ) ; if ( ! iter . has Next ( ) ) break ; continue ; } if ( ! is Added ) { if ( unit Comp . compare ( new Desc , desc ) <= NUM ) { if ( check Unit Collision ( desc , new Desc ) ) { iter . remove ( ) ; iter . add ( new Desc ) ; rmv Cls Ldrs . add ( desc . get Class Loader ( ) ) ; } else { iter . set ( new Desc ) ; iter . add ( desc ) ; } is Added = BOOL ; } else if ( check Unit Collision ( new Desc , desc ) ) { ignore New Unit = BOOL ; break ; } } else if ( check Unit Collision ( new Desc , desc ) ) { iter . remove ( ) ; rmv Cls Ldrs . add ( desc . get Class Loader ( ) ) ; } } if ( ! ignore New Unit ) { if ( ! is Added ) unit Loaders . add ( new Desc ) ; if ( log . is Debug Enabled ( ) ) LT . info ( log , STRING + new Desc . get Class Loader ( ) + STRING + new Desc . get Timestamp ( ) + STRING + U . hide Password ( new Desc . get Uri ( ) ) + STRING + ( new Desc . get File ( ) == null ? STRING : new Desc . get File ( ) ) + STRING ) ; } } for ( Class Loader cld Ldr : rmv Cls Ldrs ) on Unit Released ( cld Ldr ) ; }
public static String canonical ID ( String id ) { if ( id == null ) return STRING ; int st = NUM ; int len = id . length ( ) ; boolean substr = BOOL ; int c ; while ( st < len && ( ( c = id . char At ( st ) ) == STRING || c <= STRING ) ) { st ++ ; substr = BOOL ; } while ( st < len && ( ( c = id . char At ( len - NUM ) ) == STRING || c <= STRING ) ) { len -- ; substr = BOOL ; } return substr ? id . substring ( st , len ) : id ; }
private static void encode Binary ( byte [ ] bytes , int startpos , int count , int startmode , String Builder sb ) { if ( count == NUM && startmode == TEXT COMPACTION ) { sb . append ( ( char ) SHIFT TO BYTE ) ; } else { boolean sixpack = ( ( count % NUM ) == NUM ) ; if ( sixpack ) { sb . append ( ( char ) LATCH TO BYTE ) ; } else { sb . append ( ( char ) LATCH TO BYTE PADDED ) ; } } int idx = startpos ; if ( count >= NUM ) { char [ ] chars = new char [ NUM ] ; while ( ( startpos + count - idx ) >= NUM ) { long t = NUM ; for ( int i = NUM ; i < NUM ; i ++ ) { t <<= NUM ; t += bytes [ idx + i ] & NUM ; } for ( int i = NUM ; i < NUM ; i ++ ) { chars [ i ] = ( char ) ( t % NUM ) ; t /= NUM ; } for ( int i = chars . length - NUM ; i >= NUM ; i -- ) { sb . append ( chars [ i ] ) ; } idx += NUM ; } } for ( int i = idx ; i < startpos + count ; i ++ ) { int ch = bytes [ i ] & NUM ; sb . append ( ( char ) ch ) ; } }
@ Override public void step ( Message Logger logger ) { try { add Agent ( ) ; env . step ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
private static boolean is Non Left ( int i0 , int i1 , int i2 , int i3 , double [ ] pts ) { double l1 , l2 , l4 , l5 , l6 , angle 1 , angle 2 , angle ; l1 = Math . sqrt ( Math . pow ( pts [ i2 + NUM ] - pts [ i1 + NUM ] , NUM ) + Math . pow ( pts [ i2 ] - pts [ i1 ] , NUM ) ) ; l2 = Math . sqrt ( Math . pow ( pts [ i3 + NUM ] - pts [ i2 + NUM ] , NUM ) + Math . pow ( pts [ i3 ] - pts [ i2 ] , NUM ) ) ; l4 = Math . sqrt ( Math . pow ( pts [ i3 + NUM ] - pts [ i0 + NUM ] , NUM ) + Math . pow ( pts [ i3 ] - pts [ i0 ] , NUM ) ) ; l5 = Math . sqrt ( Math . pow ( pts [ i1 + NUM ] - pts [ i0 + NUM ] , NUM ) + Math . pow ( pts [ i1 ] - pts [ i0 ] , NUM ) ) ; l6 = Math . sqrt ( Math . pow ( pts [ i2 + NUM ] - pts [ i0 + NUM ] , NUM ) + Math . pow ( pts [ i2 ] - pts [ i0 ] , NUM ) ) ; angle 1 = Math . acos ( ( ( l2 * l2 ) + ( l6 * l6 ) - ( l4 * l4 ) ) / ( NUM * l2 * l6 ) ) ; angle 2 = Math . acos ( ( ( l6 * l6 ) + ( l1 * l1 ) - ( l5 * l5 ) ) / ( NUM * l6 * l1 ) ) ; angle = ( Math . PI - angle 1 ) - angle 2 ; if ( angle <= NUM ) { return ( BOOL ) ; } else { return ( BOOL ) ; } }
protected void copy 2 D Array ( int from [ ] [ ] , int to [ ] [ ] ) { for ( int i = NUM ; i < from . length ; i ++ ) { to [ i ] = new int [ from [ i ] . length ] ; System . arraycopy ( from [ i ] , NUM , to [ i ] , NUM , from [ i ] . length ) ; } }
public static < K , V > Map < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 ) { Map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; return map ; }
public boolean fill ( Reader reader , int pos ) throws IO Exception { int res = reader . read ( f Buf ) ; if ( res == - NUM ) { f Offset = pos ; f Length = NUM ; return BOOL ; } int chars Read = res ; while ( chars Read < BUFFER SIZE ) { res = reader . read ( f Buf , chars Read , BUFFER SIZE - chars Read ) ; if ( res == - NUM ) { f Offset = pos ; f Length = chars Read ; return BOOL ; } chars Read += res ; } f Offset = pos ; f Length = BUFFER SIZE ; return BOOL ; }
public void draw In Rect ( GL 10 gl , CG Rect rect ) { gl . gl Enable ( GL TEXTURE 2D ) ; load Texture ( gl ) ; float vertices [ ] = { rect . origin . x , rect . origin . y , rect . origin . x + rect . size . width , rect . origin . y , rect . origin . x , rect . origin . y + rect . size . height , rect . origin . x + rect . size . width , rect . origin . y + rect . size . height } ; m Vertices . put ( vertices ) ; m Vertices . position ( NUM ) ; float coordinates [ ] = { NUM , max T , max S , max T , NUM , NUM , max S , NUM } ; m Coordinates . put ( coordinates ) ; m Coordinates . position ( NUM ) ; gl . gl Enable Client State ( GL VERTEX ARRAY ) ; gl . gl Enable Client State ( GL TEXTURE COORD ARRAY ) ; gl . gl Bind Texture ( GL TEXTURE 2D , name ) ; gl . gl Tex Parameterx ( GL TEXTURE 2D , GL TEXTURE WRAP S , GL REPEAT ) ; gl . gl Tex Parameterx ( GL TEXTURE 2D , GL TEXTURE WRAP T , GL REPEAT ) ; gl . gl Vertex Pointer ( NUM , GL FLOAT , NUM , m Vertices ) ; gl . gl Tex Coord Pointer ( NUM , GL FLOAT , NUM , m Coordinates ) ; gl . gl Draw Arrays ( GL TRIANGLE STRIP , NUM , NUM ) ; gl . gl Disable Client State ( GL VERTEX ARRAY ) ; gl . gl Disable Client State ( GL TEXTURE COORD ARRAY ) ; gl . gl Disable ( GL TEXTURE 2D ) ; }
synchronized void executed ( RT Edit Text editor , Operation op ) { Stack < Operation > undo Stack = get Undo Stack ( editor ) ; Stack < Operation > redo Stack = get Redo Stack ( editor ) ; while ( ! undo Stack . empty ( ) && op . can Merge ( undo Stack . peek ( ) ) ) { Operation previous Op = undo Stack . pop ( ) ; op . merge ( previous Op ) ; } push ( op , undo Stack ) ; redo Stack . clear ( ) ; }
public void remove Swipe Listener ( Swipe Listener listener ) { if ( m Listeners == null ) { return ; } m Listeners . remove ( listener ) ; }
public static boolean is Oss Build ( ) { boolean is Oss Build = BOOL ; String build Type = System . get Property ( STRING ) ; if ( String Utils . is Not Blank ( build Type ) && build Type . equals Ignore Case ( STRING ) ) { is Oss Build = BOOL ; } return is Oss Build ; }
public void invoke Hook Bolt Execute ( Tuple tuple , long execute Latency Ns ) { if ( task Hooks . size ( ) != NUM ) { Bolt Execute Info execute Info = new Bolt Execute Info ( tuple , get This Task Id ( ) , execute Latency Ns / Constants . MILLISECONDS TO NANOSECONDS ) ; for ( I Task Hook task Hook : task Hooks ) { task Hook . bolt Execute ( execute Info ) ; } } }
private void validate Iam Roles ( List < Iam Role > iam Roles ) { Assert . not Null ( iam Roles , STRING ) ; Assert . is True ( iam Roles . size ( ) > NUM , STRING ) ; for ( Iam Role iam Role : iam Roles ) { Assert . not Null ( iam Role , STRING ) ; Assert . has Text ( iam Role . get Iam Role Name ( ) , STRING ) ; } }
public static Intent build Start In Background Intent ( File script ) { final Component Name component Name = Constants . SL 4 A SERVICE LAUNCHER COMPONENT NAME ; Intent intent = new Intent ( ) ; intent . set Component ( component Name ) ; intent . set Action ( Constants . ACTION LAUNCH BACKGROUND SCRIPT ) ; intent . put Extra ( Constants . EXTRA SCRIPT PATH , script . get Absolute Path ( ) ) ; return intent ; }
public static java . lang . String value Of ( java . lang . Object obj ) { return obj == null ? STRING : obj . to String ( ) ; }
@ Suppress Warnings ( { STRING , STRING } ) public Span Multi Term Query Wrapper ( Q query ) { this . query = Objects . require Non Null ( query ) ; this . rewrite Method = select Rewrite Method ( query ) ; }
public void write Map End ( ) throws IO Exception { os . write ( STRING ) ; }
public Shape create Arrow Up ( final double x , final double y , final double w , final double h ) { path . reset ( ) ; path . move To ( x , y + h ) ; path . line To ( x + w / NUM , y ) ; path . line To ( x + w , y + h ) ; path . close Path ( ) ; return path ; }
protected void fire Value Changed ( ) { Change Event evt = new Change Event ( this ) ; for ( Change Listener listener : listener List . get Listeners ( Change Listener . class ) ) { listener . state Changed ( evt ) ; } }
public static void stream Content To Browser ( Http Servlet Response response , Input Stream in , int length , String content Type , String file Name ) throws IO Exception { set Response Browser Proxy No Cache ( response ) ; response . set Content Length ( length ) ; if ( content Type != null ) { response . set Content Type ( content Type ) ; } if ( file Name != null ) { response . set Header ( STRING , STRING + file Name ) ; } Output Stream out = response . get Output Stream ( ) ; try { stream Content ( out , in , length ) ; } catch ( IO Exception e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }
public static Byte Buffer encode ( String string ) throws Character Coding Exception { return encode ( string , BOOL ) ; }
public void disable Realtime Steps Notify ( ) { check Connection ( ) ; final List < BLE Action > list = new Array List < > ( ) ; list . add ( new Write Action ( Profile . UUID CHAR CONTROL POINT , Protocol . DISABLE REALTIME STEPS NOTIFY ) ) ; queue ( list ) ; }
private static void stable String Sort ( String [ ] arr , String [ ] src , String [ ] dst , int start , int end , int ch Id ) { int length = end - start ; if ( length < SIMPLE LENGTH ) { if ( src == arr ) { for ( int i = start + NUM ; i < end ; i ++ ) { String current = arr [ i ] ; String prev = arr [ i - NUM ] ; if ( current . compare To ( prev ) < NUM ) { int j = i ; do { arr [ j -- ] = prev ; } while ( j > start && current . compare To ( prev = arr [ j - NUM ] ) < NUM ) ; arr [ j ] = current ; } } } else { int actual End = end - NUM ; dst [ start ] = src [ actual End -- ] ; for ( int i = start + NUM ; i < end ; i ++ , actual End -- ) { String current = src [ actual End ] ; String prev ; int j = i ; while ( j > start && current . compare To ( prev = dst [ j - NUM ] ) < NUM ) { dst [ j -- ] = prev ; } dst [ j ] = current ; } } return ; } int s ; int mid = start + length / NUM ; int lo = start ; int hi = end - NUM ; if ( length > NUM ) { s = length / NUM ; lo = med Char ( lo , lo + s , lo + s * NUM , src , ch Id ) ; mid = med Char ( mid - s , mid , mid + s , src , ch Id ) ; hi = med Char ( hi , hi - s , hi - s * NUM , src , ch Id ) ; } mid = med Char ( lo , mid , hi , src , ch Id ) ; int mid Val = char At ( src [ mid ] , ch Id ) ; int a , b , c ; a = b = start ; c = end - NUM ; int cmp ; for ( int i = start ; i < end ; i ++ ) { String el = src [ i ] ; cmp = char At ( el , ch Id ) - mid Val ; if ( cmp < NUM ) { src [ a ] = el ; a ++ ; } else if ( cmp > NUM ) { dst [ c ] = el ; c -- ; } else { dst [ b ] = el ; b ++ ; } } s = b - start ; if ( s > NUM ) { if ( arr == src ) { System . arraycopy ( dst , start , arr , a , s ) ; } else { copy Swap ( dst , start , arr , a , s ) ; } if ( b >= end && mid Val == - NUM ) { return ; } stable String Sort ( arr , arr , arr == dst ? src : dst , a , a + s , ch Id + NUM ) ; } s = a - start ; if ( s > NUM ) { stable String Sort ( arr , src , dst , start , a , ch Id ) ; } c ++ ; s = end - c ; if ( s > NUM ) { stable String Sort ( arr , dst , src , c , end , ch Id ) ; } }
private static Class < ? > [ ] types ( Object ... values ) { if ( values == null ) { return new Class [ NUM ] ; } Class < ? > [ ] result = new Class [ values . length ] ; for ( int i = NUM ; i < values . length ; i ++ ) { Object value = values [ i ] ; result [ i ] = value == null ? NULL . class : value . get Class ( ) ; } return result ; }
public static void un Register Tile Codec ( int comp ) { XTIFF Tile Codec cod = get Tile Codec ( comp ) ; tile Codecs . remove ( cod ) ; }
public static void escape ( Str Builder to Append , String text , boolean escape Quote , boolean escape Apos ) { if ( text == null ) { return ; } for ( int i = NUM ; i < text . length ( ) ; i ++ ) { char ch = text . char At ( i ) ; switch ( ch ) { case STRING : to Append . append ( STRING ) ; break ; case STRING : to Append . append ( STRING ) ; break ; case STRING : to Append . append ( STRING ) ; break ; case STRING : to Append . append ( escape Quote ? STRING : ch ) ; break ; case STRING : to Append . append ( escape Apos ? STRING : ch ) ; break ; default : to Append . append ( ch ) ; break ; } } }
public void destroy ( ) { m Listeners . clear ( ) ; m Spring System . deregister Spring ( this ) ; }
@ Override public synchronized void remove Instance Listener ( Instance Listener tsl ) { m instance Listeners . remove Element ( tsl ) ; }
private String read Until ( char [ ] delimiter , boolean return Text ) throws IO Exception , Xml Pull Parser Exception { int start = position ; String Builder result = null ; if ( return Text && text != null ) { result = new String Builder ( ) ; result . append ( text ) ; } search : while ( BOOL ) { if ( position + delimiter . length > limit ) { if ( start < position && return Text ) { if ( result == null ) { result = new String Builder ( ) ; } result . append ( buffer , start , position - start ) ; } if ( ! fill Buffer ( delimiter . length ) ) { check Relaxed ( UNEXPECTED EOF ) ; type = COMMENT ; return null ; } start = position ; } for ( int i = NUM ; i < delimiter . length ; i ++ ) { if ( buffer [ position + i ] != delimiter [ i ] ) { position ++ ; continue search ; } } break ; } int end = position ; position += delimiter . length ; if ( ! return Text ) { return null ; } else if ( result == null ) { return string Pool . get ( buffer , start , end - start ) ; } else { result . append ( buffer , start , end - start ) ; return result . to String ( ) ; } }
private void toggle Favorite ( ) { for ( String game : list . get Selected Values List ( ) ) { if ( favorites . contains ( game ) ) { favorites . remove ( game ) ; } else { favorites . add ( game ) ; } } save Favorites ( ) ; update ( ) ; }
private void create Partition Region ( List vm List , int start Index For Region , int end Index For Region , int local Max Memory , int redundancy , boolean first Creation Flag , boolean multiple VM Flag ) { Iterator node Iterator = vm List . iterator ( ) ; while ( node Iterator . has Next ( ) ) { VM vm = ( VM ) node Iterator . next ( ) ; vm . invoke ( create Multiple Partition Region ( pr Prefix , start Index For Region , end Index For Region , redundancy , local Max Memory , first Creation Flag , multiple VM Flag ) ) ; } }
public int write ( byte [ ] dest Mac , byte [ ] packet , int offset , int byte Count ) { if ( dest Mac == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( packet == null ) { throw new Null Pointer Exception ( STRING ) ; } Arrays . check Offset And Count ( packet . length , offset , byte Count ) ; if ( dest Mac . length != NUM ) { throw new Illegal Argument Exception ( STRING + dest Mac . length ) ; } return send Packet ( fd , m Interface Name , m Protocol Type , dest Mac , packet , offset , byte Count ) ; }
public boolean has Extensions With Deps ( ) { return ! extensions With Deps . is Empty ( ) ; }
public synchronized void add Series ( XY Series series ) { m Series . add ( series ) ; }
private int [ ] calculate Task Count Per Container ( int task Count , int prev Container Count , int current Container Count ) { int [ ] new Task Count Per Container = new int [ Math . max ( current Container Count , prev Container Count ) ] ; Arrays . fill ( new Task Count Per Container , NUM ) ; for ( int i = NUM ; i < current Container Count ; i ++ ) { new Task Count Per Container [ i ] = task Count / current Container Count ; if ( task Count % current Container Count > i ) { new Task Count Per Container [ i ] ++ ; } } return new Task Count Per Container ; }
@ Override public void action Perform ( Component component ) { if ( ! is Enabled ( ) ) { return ; } if ( before Action Performed Handler != null ) { if ( ! before Action Performed Handler . before Action Performed ( ) ) return ; } Set selected = target . get Selected ( ) ; if ( ! selected . is Empty ( ) ) { if ( confirm ) { confirm And Remove ( selected ) ; } else { remove ( selected ) ; } } }
public void test Compare To Pos Pos 2 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; assert Equals ( - NUM , a Number . compare To ( b Number ) ) ; }
static public void generate Seed ( byte [ ] result ) { instance . get Seed Bytes ( result ) ; }
private double hamming Distance Number Vector ( Number Vector o1 , Number Vector o2 ) { final int d1 = o1 . get Dimensionality ( ) , d2 = o2 . get Dimensionality ( ) ; int differences = NUM ; int d = NUM ; for ( ; d < d1 && d < d2 ; d ++ ) { double v1 = o1 . double Value ( d ) , v2 = o2 . double Value ( d ) ; if ( v1 != v1 || v2 != v2 ) { continue ; } if ( v1 != v2 ) { ++ differences ; } } for ( ; d < d1 ; d ++ ) { double v1 = o1 . double Value ( d ) ; if ( v1 != NUM && v1 == v1 ) { ++ differences ; } } for ( ; d < d2 ; d ++ ) { double v2 = o2 . double Value ( d ) ; if ( v2 != NUM && v2 == v2 ) { ++ differences ; } } return differences ; }
public static Kernel create Kernel ( int kernel Type ) { switch ( kernel Type ) { case KERNEL RADIAL : return new Kernel Radial ( ) ; case KERNEL POLYNOMIAL : return new Kernel Polynomial ( ) ; case KERNEL NEURAL : return new Kernel Neural ( ) ; default : return new Kernel Dot ( ) ; } }
protected void check For Pending Tasks ( Collection < URI > tenants , Collection < ? extends Data Object > data Objects ) { for ( URI tenant : tenants ) { check For Pending Tasks ( tenant , data Objects ) ; } }
@ org . junit . Test public void verify Get Float Response ( ) throws Exception { Map < String , String > query Params = new Hash Map < String , String > ( ) ; String str = client . invoke API ( STRING , STRING , query Params , null , new Hash Map < String , String > ( ) , null , STRING , null , new String [ NUM ] ) ; assert Equals ( str , String . value Of ( Example Builder . SAMPLE FLOAT PROPERTY VALUE ) ) ; }
public void write Operations Car File ( ) { make Backup File ( default Operations Filename ( ) ) ; try { if ( ! check File ( default Operations Filename ( ) ) ) { java . io . File file = new java . io . File ( default Operations Filename ( ) ) ; java . io . File parent Dir = file . get Parent File ( ) ; if ( ! parent Dir . exists ( ) ) { if ( ! parent Dir . mkdir ( ) ) { log . error ( STRING ) ; } } if ( file . create New File ( ) ) { log . debug ( STRING ) ; } } write File ( default Operations Filename ( ) ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; } }
private synchronized void rebuild Journal ( ) throws IO Exception { if ( journal Writer != null ) { journal Writer . close ( ) ; } Writer writer = new Buffered Writer ( new File Writer ( journal File Tmp ) , IO BUFFER SIZE ) ; writer . write ( MAGIC ) ; writer . write ( STRING ) ; writer . write ( VERSION 1 ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( app Version ) ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( value Count ) ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; for ( Entry entry : lru Entries . values ( ) ) { if ( entry . current Editor != null ) { writer . write ( DIRTY + STRING + entry . key + STRING ) ; } else { writer . write ( CLEAN + STRING + entry . key + entry . get Lengths ( ) + STRING ) ; } } writer . close ( ) ; journal File Tmp . rename To ( journal File ) ; journal Writer = new Buffered Writer ( new File Writer ( journal File , BOOL ) , IO BUFFER SIZE ) ; }
public static double median ( final double [ ] values ) { final int len = values . length ; final double [ ] sorted Values = Arrays . copy Of ( values , len ) ; Arrays . sort ( sorted Values ) ; if ( len % NUM == NUM ) { return ( ( double ) sorted Values [ len / NUM ] + ( double ) sorted Values [ len / NUM - NUM ] ) / NUM ; } else { return ( double ) sorted Values [ len / NUM ] ; } }
private List < Block Info > fill Segment Id To Table Info Map ( List < Table Block Info > table Block Infos , Absolute Table Identifier absolute Table Identifier ) { Map < String , List < Block Info > > map = segment Id To Block List Map . get ( absolute Table Identifier ) ; if ( null == map ) { map = new Concurrent Hash Map < String , List < Block Info > > ( ) ; segment Id To Block List Map . put ( absolute Table Identifier , map ) ; } Block Info temp = null ; List < Block Info > block Infos Need To Load = new Array List < > ( ) ; for ( Table Block Info info : table Block Infos ) { List < Block Info > temp Table Block Infos = map . get ( info . get Segment Id ( ) ) ; if ( null == temp Table Block Infos ) { temp Table Block Infos = new Array List < > ( ) ; map . put ( info . get Segment Id ( ) , temp Table Block Infos ) ; } temp = new Block Info ( info ) ; if ( ! temp Table Block Infos . contains ( temp ) ) { temp Table Block Infos . add ( temp ) ; } block Infos Need To Load . add ( temp ) ; } return block Infos Need To Load ; }
public Char Buffer put ( String str , int start , int end ) { if ( is Read Only ( ) ) { throw new Read Only Buffer Exception ( ) ; } if ( start < NUM || end < start || end > str . length ( ) ) { throw new Index Out Of Bounds Exception ( STRING + str . length ( ) + STRING + start + STRING + end ) ; } if ( end - start > remaining ( ) ) { throw new Buffer Overflow Exception ( ) ; } for ( int i = start ; i < end ; i ++ ) { put ( str . char At ( i ) ) ; } return this ; }
public List < Offer Recommendation > evaluate ( List < Offer > offers ) { List < Offer Recommendation > recommendations = new Array List < Offer Recommendation > ( ) ; int offer Resource Count = NUM ; for ( Offer offer : offers ) { offer Resource Count += offer . get Resources Count ( ) ; for ( Resource to Destroy : select Unexpected Resources ( expected Persistent Volume Ids , get Persistent Volumes By Id ( offer ) ) ) { recommendations . add ( new Destroy Offer Recommendation ( offer , to Destroy ) ) ; } } int destroy Recommendation Count = recommendations . size ( ) ; for ( Offer offer : offers ) { for ( Resource to Unreserve : select Unexpected Resources ( expected Reserved Resource Ids , get Reserved Resources By Id ( offer ) ) ) { recommendations . add ( new Unreserve Offer Recommendation ( offer , to Unreserve ) ) ; } } logger . info ( STRING , offers . size ( ) , offer Resource Count , destroy Recommendation Count , recommendations . size ( ) - destroy Recommendation Count ) ; return recommendations ; }
@ Override public int update ( Byte Buffer in Buffer , Byte Buffer out Buffer ) throws Short Buffer Exception { return cipher . update ( in Buffer , out Buffer ) ; }
boolean display Context Assump ( Node Representation rep , int i ) { return rep . is Created || ( ( ! state . split Chosen ( ) ) && show Context Value ) ; }
private void unregister M Beans ( ) { List < Object Name > unregistered = new Array List < Object Name > ( ) ; for ( Object Name name : mbeans ) { try { mbeanserver . unregister M Bean ( name ) ; unregistered . add ( name ) ; } catch ( JM Exception e ) { } } mbeans . remove All ( unregistered ) ; }
public static void main ( String [ ] argv ) throws IO Exception , SAX Exception { Scanner s = new HTML Scanner ( ) ; Reader r = new Input Stream Reader ( System . in , STRING ) ; Writer w = new Output Stream Writer ( System . out , STRING ) ; PYX Writer pw = new PYX Writer ( w ) ; s . scan ( r , pw ) ; w . close ( ) ; }
private void create Amp Result Stream Method ( Java Class j Class , Method method , int result Offset ) { String method Name = method . get Name ( ) ; Class < ? > [ ] parameter Types = method . get Parameter Types ( ) ; Annotation [ ] [ ] parameter Anns = method . get Parameter Annotations ( ) ; add Method ( method ) ; Code Writer Attribute code = create Method Header ( j Class , method ) ; code . set Max Locals ( NUM + NUM * parameter Types . length ) ; code . set Max Stack ( NUM + NUM * parameter Types . length ) ; code . push Object Var ( NUM ) ; code . get Field ( j Class . get This Class ( ) , STRING , Message Factory Amp . class ) ; int arg Len = parameter Types . length - NUM ; code . push Object Var ( get Length ( parameter Types , result Offset ) + NUM ) ; long timeout = default Timeout ; code . push Constant ( timeout ) ; code . push Object Var ( NUM ) ; code . get Field ( j Class . get This Class ( ) , STRING , Service Ref Amp . class ) ; code . push Object Var ( NUM ) ; code . get Field ( j Class . get This Class ( ) , field Name ( method ) , Method Amp . class ) ; partition Method ( code , parameter Types , parameter Anns ) ; push Parameters ( code , parameter Types , parameter Anns , NUM , NUM , arg Len + NUM , result Offset ) ; code . invoke Interface ( Message Factory Amp . class , STRING , void . class , Result Stream . class , long . class , Service Ref Amp . class , Method Amp . class , Object [ ] . class ) ; code . add Return ( ) ; code . close ( ) ; }
private static synchronized void end Transaction ( Connection C , boolean successful ) throws Ade Exception { logger . trace ( STRING ) ; try { if ( successful ) { C . commit ( ) ; } else { C . rollback ( ) ; } C . set Auto Commit ( BOOL ) ; } catch ( Throwable t ) { surface Throwable ( STRING , t ) ; throw ade Exception Of ( t ) ; } logger . trace ( STRING ) ; }
public double [ ] estimate L 2 Distance Squared ( Datum query Datum ) { Real Vector vector = query Datum . metrics ( ) ; double [ ] estimates = new double [ NUM ] ; for ( int i = NUM ; i < k ; i ++ ) { double delta Lo = vector . get Entry ( i ) - this . boundaries [ i ] [ NUM ] ; double delta Hi = this . boundaries [ i ] [ NUM ] - vector . get Entry ( i ) ; double sq Delta Lo = delta Lo * delta Lo ; double sq Delta Hi = delta Hi * delta Hi ; if ( delta Lo < NUM || delta Hi < NUM ) { if ( sq Delta Hi < sq Delta Lo ) { estimates [ NUM ] += sq Delta Hi ; estimates [ NUM ] += sq Delta Lo ; } else { estimates [ NUM ] += sq Delta Lo ; estimates [ NUM ] += sq Delta Hi ; } } else { estimates [ NUM ] += Math . max ( sq Delta Hi , sq Delta Lo ) ; } } return estimates ; }
private void deserialize Class ( File file ) throws Runtime Exception { try { File Input Stream in = new File Input Stream ( file ) ; Object Input Stream obj In = new Object Input Stream ( in ) ; Object o = obj In . read Object ( ) ; in . close ( ) ; } catch ( Class Not Found Exception e ) { throw new Runtime Exception ( STRING + STRING + file + STRING + STRING + STRING , e ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING + STRING + file + STRING , e ) ; } }
public boolean calculate Tax Total ( ) { log . fine ( STRING ) ; DB . execute Update Ex ( STRING + get C Invoice ID ( ) , get Trx Name ( ) ) ; m taxes = null ; Big Decimal total Lines = Env . ZERO ; Array List < Integer > tax List = new Array List < Integer > ( ) ; M Invoice Line [ ] lines = get Lines ( BOOL ) ; for ( int i = NUM ; i < lines . length ; i ++ ) { M Invoice Line line = lines [ i ] ; if ( ! tax List . contains ( line . get C Tax ID ( ) ) ) { M Invoice Tax i Tax = M Invoice Tax . get ( line , get Precision ( ) , BOOL , get Trx Name ( ) ) ; if ( i Tax != null ) { i Tax . set Is Tax Included ( is Tax Included ( ) ) ; if ( ! i Tax . calculate Tax From Lines ( ) ) return BOOL ; i Tax . save Ex ( ) ; tax List . add ( line . get C Tax ID ( ) ) ; } } total Lines = total Lines . add ( line . get Line Net Amt ( ) ) ; } Big Decimal grand Total = total Lines ; M Invoice Tax [ ] taxes = get Taxes ( BOOL ) ; for ( int i = NUM ; i < taxes . length ; i ++ ) { M Invoice Tax i Tax = taxes [ i ] ; M Tax tax = i Tax . get Tax ( ) ; if ( tax . is Summary ( ) ) { M Tax [ ] c Taxes = tax . get Child Taxes ( BOOL ) ; for ( int j = NUM ; j < c Taxes . length ; j ++ ) { M Tax c Tax = c Taxes [ j ] ; Big Decimal tax Amt = c Tax . calculate Tax ( i Tax . get Tax Base Amt ( ) , is Tax Included ( ) , get Precision ( ) ) ; M Invoice Tax new I Tax = new M Invoice Tax ( get Ctx ( ) , NUM , get Trx Name ( ) ) ; new I Tax . set Client Org ( this ) ; new I Tax . set C Invoice ID ( get C Invoice ID ( ) ) ; new I Tax . set C Tax ID ( c Tax . get C Tax ID ( ) ) ; new I Tax . set Precision ( get Precision ( ) ) ; new I Tax . set Is Tax Included ( is Tax Included ( ) ) ; new I Tax . set Tax Base Amt ( i Tax . get Tax Base Amt ( ) ) ; new I Tax . set Tax Amt ( tax Amt ) ; new I Tax . save Ex ( get Trx Name ( ) ) ; if ( ! is Tax Included ( ) ) grand Total = grand Total . add ( tax Amt ) ; } i Tax . delete Ex ( BOOL , get Trx Name ( ) ) ; } else { if ( ! is Tax Included ( ) ) grand Total = grand Total . add ( i Tax . get Tax Amt ( ) ) ; } } set Total Lines ( total Lines ) ; set Grand Total ( grand Total ) ; return BOOL ; }
private boolean can Open ( ) { for ( final I Navi Project project : m projects ) { if ( project . is Loaded ( ) ) { return BOOL ; } } return BOOL ; }
public static Array list With Quotes To Array ( String list , String delimiter , String quotes ) { if ( list . length ( ) == NUM ) return new Array Impl ( ) ; int len = list . length ( ) ; int last = NUM ; char [ ] del = delimiter . to Char Array ( ) ; char [ ] quo = quotes . to Char Array ( ) ; char c ; char inside = NUM ; Array Impl array = new Array Impl ( ) ; try { for ( int i = NUM ; i < len ; i ++ ) { c = list . char At ( i ) ; for ( int y = NUM ; y < quo . length ; y ++ ) { if ( c == quo [ y ] ) { if ( c == inside ) inside = NUM ; else if ( inside == NUM ) inside = c ; continue ; } } for ( int y = NUM ; y < del . length ; y ++ ) { if ( inside == NUM && c == del [ y ] ) { array . append ( list . substring ( last , i ) ) ; last = i + NUM ; break ; } } } if ( last <= len ) array . append ( list . substring ( last ) ) ; } catch ( Expression Exception e ) { } return array ; }
public ML Output execute ( String dml Script File Path , Array List < String > args Name , Array List < String > args Values , String config File Path ) throws IO Exception , DML Exception , Parse Exception { Hash Map < String , String > new Named Args = new Hash Map < String , String > ( ) ; if ( args Name . size ( ) != args Values . size ( ) ) { throw new DML Exception ( STRING + args Name . size ( ) + STRING + STRING ) ; } for ( int i = NUM ; i < args Name . size ( ) ; i ++ ) { String k = args Name . get ( i ) ; String v = args Values . get ( i ) ; new Named Args . put ( k , v ) ; } return execute ( dml Script File Path , new Named Args , config File Path ) ; }
public boolean is In Memory Db ( ) { return path . equals Ignore Case ( MEMORY DB PATH ) ; }
private static boolean test Specific Value ( double x , double y , double expected Value , double interp Value ) { logger . info ( STRING + x + STRING + y + STRING + expected Value + STRING + interp Value + STRING ) ; boolean specific Value Interp Useful = BOOL ; if ( interp Value > expected Value + NUM || interp Value < expected Value - NUM ) specific Value Interp Useful = BOOL ; return specific Value Interp Useful ; }
public Input Source resolve Entity ( String public Id , String system Id ) throws SAX Exception , IO Exception { has DTD = BOOL ; String dtd = Util Properties . get Split Property Value ( Util URL . from Resource ( STRING ) , public Id ) ; if ( Util Validate . is Not Empty ( dtd ) ) { if ( Debug . verbose On ( ) ) Debug . log Verbose ( STRING + public Id + STRING + system Id + STRING + dtd + STRING , module ) ; try { URL dtd URL = Util URL . from Resource ( dtd ) ; if ( dtd URL == null ) { throw new General Exception ( STRING + dtd ) ; } Input Stream dtd Stream = dtd URL . open Stream ( ) ; Input Source input Source = new Input Source ( dtd Stream ) ; input Source . set Public Id ( public Id ) ; has DTD = BOOL ; if ( Debug . verbose On ( ) ) Debug . log Verbose ( STRING + public Id + STRING + dtd + STRING , module ) ; return input Source ; } catch ( Exception e ) { Debug . log Warning ( e , module ) ; } } else { int last Slash = system Id . last Index Of ( STRING ) ; String filename = null ; if ( last Slash == - NUM ) { filename = system Id ; } else { filename = system Id . substring ( last Slash + NUM ) ; } URL resource Url = Util URL . from Resource ( filename ) ; if ( resource Url != null ) { Input Stream res Stream = resource Url . open Stream ( ) ; Input Source input Source = new Input Source ( res Stream ) ; if ( Util Validate . is Not Empty ( public Id ) ) { input Source . set Public Id ( public Id ) ; } has DTD = BOOL ; if ( Debug . verbose On ( ) ) Debug . log Verbose ( STRING + public Id + STRING + filename + STRING , module ) ; return input Source ; } else { Debug . log Warning ( STRING + public Id + STRING + filename + STRING , module ) ; return null ; } } return default Resolver . resolve Entity ( public Id , system Id ) ; }
@ Override public String leave DTD ( ) { if ( writer == dtd Writer ) { line . append ( text ) ; text = new String Buffer ( NUM ) ; flush Line ( BOOL ) ; writer = doc Writer ; return dtd Writer . to String ( ) ; } return null ; }
private static Class Node load Class ( String name , Config config ) throws Exception { String file Path = config . get Class Dump Path ( ) + name . replace ( STRING , STRING ) + STRING ; Class Reader reader = new Class Reader ( new File Input Stream ( file Path ) ) ; Class Node node = new Class Node ( ) ; reader . accept ( node , Class Reader . EXPAND FRAMES ) ; return node ; }
public void write ( char [ ] cbuf , int off , int len ) throws IO Exception { internal Out . write ( cbuf , off , len ) ; }
public void add ( final String clazz , final String subclazz , final boolean blocked ) { entries . add ( new Entry ( clazz , subclazz , blocked ) ) ; }
private synchronized void buffer Change ( ) throws Read Failed Exception { Byte Buffer current = super . get Byte Buffer ( ) ; if ( null != current ) { current . clear ( ) ; empty Buffers . add ( current ) ; } int tries = NUM ; while ( BOOL ) { try { Byte Buffer buffer = full Buffers . poll ( NUM , Time Unit . MILLISECONDS ) ; if ( null != buffer ) { super . set Byte Buffer ( buffer ) ; break ; } else { tries ++ ; if ( read Failed || ( tries > MAX BUFFER POOL TRIES ) ) { throw new Read Failed Exception ( STRING ) ; } } } catch ( Interrupted Exception e ) { Thread . interrupted ( ) ; } } }
protected synchronized Class load Class ( String name , boolean resolve ) throws Class Not Found Exception { Class c = find Loaded Class ( name ) ; if ( c == null ) c = find Class ( name ) ; if ( c == null ) throw new Class Not Found Exception ( name ) ; if ( resolve ) resolve Class ( c ) ; return c ; }
@ Suppress Warnings ( { STRING , STRING } ) public static Comparable < ? > max ( Comparable < ? > [ ] ar ) { Comparable ret = ar [ NUM ] ; for ( int i = NUM ; i < ar . length ; i ++ ) { if ( ret . compare To ( ar [ i ] ) < NUM ) { ret = ar [ i ] ; } } return ret ; }
private void init BPRMA Details ( int C B Partner ID ) { rma Field . remove Action Listener ( this ) ; rma Field . remove All Items ( ) ; Key Name Pair pp = new Key Name Pair ( NUM , STRING ) ; rma Field . add Item ( pp ) ; Array List < Key Name Pair > list = load RMA Data ( C B Partner ID ) ; for ( Key Name Pair knp : list ) rma Field . add Item ( knp ) ; rma Field . set Selected Index ( NUM ) ; rma Field . add Action Listener ( this ) ; }
protected void reset Options ( ) { m max Stale = NUM ; m search Direction = SELECTION FORWARD ; m starting = null ; m start Range = new Range ( ) ; m class Index = - NUM ; m total Evals = NUM ; m cache Size = NUM ; m debug = BOOL ; }
@ Override protected void tear Down ( ) throws Exception { try { take Screen Shot ( ) ; } catch ( Throwable throwable ) { throwable . print Stack Trace ( ) ; } super . tear Down ( ) ; }
public synchronized void clear ( ) { m Categories . clear ( ) ; m Values . clear ( ) ; }
private boolean itera connect ( Pla Point Int p from point , Pla Point Int p to point ) { Array List < Pla Point Int > corners = angled connection ( p from point , p to point ) ; boolean connection succeeded = BOOL ; for ( int index = NUM ; index < corners . size ( ) ; ++ index ) { Pla Point Int from corner = corners . get ( index - NUM ) ; Pla Point Int to corner = corners . get ( index ) ; Time Limit time limit = new Time Limit ( s CHECK FORCED TRACE TIME MAX ) ; while ( ! from corner . equals ( to corner ) ) { Pla Point Int curr ok point = r board . insert trace ( from corner , to corner , pen half width arr [ layer active no ] , layer active no , net nos , clearance class , max shove trace recursion depth , max shove via recursion depth , max spring over recursion depth , itera settings . trace pullt min move , ! is stitch mode , time limit ) ; if ( curr ok point == null ) { r board . undo ( null ) ; return BOOL ; } if ( curr ok point . equals ( from corner ) && itera settings . is automatic neckdown ( ) ) { curr ok point = try neckdown at end ( from corner , to corner ) ; } if ( curr ok point . equals ( from corner ) ) { prev corner = from corner ; connection succeeded = BOOL ; break ; } from corner = curr ok point ; } } return connection succeeded ; }
private Node < K , V > find Predecessor Of Last ( ) { for ( ; ; ) { Index < K , V > q = head ; for ( ; ; ) { Index < K , V > d , r ; if ( ( r = q . right ) != null ) { if ( r . indexes Deleted Node ( ) ) { q . unlink ( r ) ; break ; } if ( r . node . next != null ) { q = r ; continue ; } } if ( ( d = q . down ) != null ) q = d ; else return q . node ; } } }
public boolean query ( int object To Query , long [ ] [ ] hash Functions ) { for ( long [ ] h : hash Functions ) { int i = hash ( h , ( long ) object To Query ) ; if ( ! bit Set . get ( i ) ) return BOOL ; } return BOOL ; }
public void clear ( ) { synchronized ( m Lock ) { m Graphics . clear ( ) ; } post Invalidate ( ) ; }
@ Safe Varargs public static < V > Set < V > create Set ( V ... values ) { Set < V > set = new Linked Hash Set < V > ( ) ; for ( V v : values ) { set . add ( v ) ; } return set ; }
@ Override void do Constrained Outside Scores ( Grammar grammar , boolean viterbi , boolean log Scores ) { short [ ] num Sub States Array = grammar . num Sub States ; double init Val = ( log Scores ) ? Double . NEGATIVE INFINITY : NUM ; for ( int diff = length ; diff >= NUM ; diff -- ) { for ( int start = NUM ; start + diff <= length ; start ++ ) { int end = start + diff ; double [ ] [ ] scores After Unaries = new double [ num States ] [ ] ; boolean something Changed = BOOL ; for ( int c State = NUM ; c State < num States ; c State ++ ) { if ( diff > NUM && ! grammar . is Grammar Tag [ c State ] ) continue ; if ( ! allowed States [ start ] [ end ] [ c State ] ) { continue ; } Unary Rule [ ] rules = null ; if ( viterbi ) rules = grammar . get Closed Viterbi Unary Rules By Child ( c State ) ; else rules = grammar . get Closed Sum Unary Rules By Child ( c State ) ; final int n Child States = num Sub States Array [ c State ] ; final int num Rules = rules . length ; for ( int r = NUM ; r < num Rules ; r ++ ) { Unary Rule ur = rules [ r ] ; int p State = ur . parent State ; if ( ( p State == c State ) ) continue ; if ( ! allowed States [ start ] [ end ] [ p State ] ) { continue ; } double [ ] [ ] scores = ur . get Scores 2 ( ) ; final int n Parent States = num Sub States Array [ p State ] ; for ( int cp = NUM ; cp < n Child States ; cp ++ ) { if ( scores [ cp ] == null ) continue ; if ( ! allowed Sub States [ start ] [ end ] [ c State ] [ cp ] ) continue ; for ( int np = NUM ; np < n Parent States ; np ++ ) { double pS = scores [ cp ] [ np ] ; if ( pS == init Val ) continue ; double oS = o Score [ start ] [ end ] [ p State ] [ np ] ; if ( oS == init Val ) continue ; double this Round = ( log Scores ) ? oS + pS : oS * pS ; if ( scores After Unaries [ c State ] == null ) { scores After Unaries [ c State ] = new double [ num Sub States Array [ c State ] ] ; if ( viterbi ) Arrays . fill ( scores After Unaries [ c State ] , init Val ) ; } if ( viterbi ) scores After Unaries [ c State ] [ cp ] = Math . max ( this Round , scores After Unaries [ c State ] [ cp ] ) ; else scores After Unaries [ c State ] [ cp ] += this Round ; something Changed = BOOL ; } } } } if ( something Changed ) { for ( int c State = NUM ; c State < num States ; c State ++ ) { double [ ] this Cell = scores After Unaries [ c State ] ; if ( this Cell == null ) continue ; for ( int cp = NUM ; cp < num Sub States Array [ c State ] ; cp ++ ) { if ( this Cell [ cp ] > init Val ) { if ( viterbi ) o Score [ start ] [ end ] [ c State ] [ cp ] = Math . max ( o Score [ start ] [ end ] [ c State ] [ cp ] , this Cell [ cp ] ) ; else o Score [ start ] [ end ] [ c State ] [ cp ] += this Cell [ cp ] ; } } } } for ( int p State = NUM ; p State < num Sub States Array . length ; p State ++ ) { if ( ! allowed States [ start ] [ end ] [ p State ] ) { continue ; } final int n Parent Child States = num Sub States Array [ p State ] ; Binary Rule [ ] rules = grammar . split Rules With P ( p State ) ; final int num Rules = rules . length ; for ( int r = NUM ; r < num Rules ; r ++ ) { Binary Rule br = rules [ r ] ; int l State = br . left Child State ; int min 1 = narrow R Extent [ start ] [ l State ] ; if ( end < min 1 ) { continue ; } int r State = br . right Child State ; int max 1 = narrow L Extent [ end ] [ r State ] ; if ( max 1 < min 1 ) { continue ; } int min = min 1 ; int max = max 1 ; if ( max - min > NUM ) { int min 2 = wide L Extent [ end ] [ r State ] ; min = ( min 1 > min 2 ? min 1 : min 2 ) ; if ( max 1 < min ) { continue ; } int max 2 = wide R Extent [ start ] [ l State ] ; max = ( max 1 < max 2 ? max 1 : max 2 ) ; if ( max < min ) { continue ; } } double [ ] [ ] [ ] scores = br . get Scores 2 ( ) ; final int n Left Child States = num Sub States Array [ l State ] ; final int n Right Child States = num Sub States Array [ r State ] ; for ( int split = min ; split <= max ; split ++ ) { if ( ! allowed States [ start ] [ split ] [ l State ] ) continue ; if ( ! allowed States [ split ] [ end ] [ r State ] ) continue ; double [ ] right Scores = new double [ n Right Child States ] ; if ( viterbi ) Arrays . fill ( right Scores , init Val ) ; Arrays . fill ( scores To Add , init Val ) ; something Changed = BOOL ; for ( int lp = NUM ; lp < n Left Child States ; lp ++ ) { double lS = i Score [ start ] [ split ] [ l State ] [ lp ] ; if ( lS == init Val ) { continue ; } for ( int rp = NUM ; rp < n Right Child States ; rp ++ ) { if ( scores [ lp ] [ rp ] == null ) continue ; double rS = i Score [ split ] [ end ] [ r State ] [ rp ] ; if ( rS == init Val ) { continue ; } for ( int np = NUM ; np < n Parent Child States ; np ++ ) { double pS = scores [ lp ] [ rp ] [ np ] ; if ( pS == init Val ) continue ; double oS = o Score [ start ] [ end ] [ p State ] [ np ] ; if ( oS == init Val ) continue ; double this Round L = ( log Scores ) ? pS + rS + oS : pS * rS * oS ; double this Round R = ( log Scores ) ? pS + lS + oS : pS * lS * oS ; if ( viterbi ) { scores To Add [ lp ] = Math . max ( this Round L , scores To Add [ lp ] ) ; right Scores [ rp ] = Math . max ( this Round R , right Scores [ rp ] ) ; } else { scores To Add [ lp ] += this Round L ; right Scores [ rp ] += this Round R ; } something Changed = BOOL ; } } } if ( ! something Changed ) continue ; for ( int cp = NUM ; cp < n Left Child States ; cp ++ ) { if ( scores To Add [ cp ] > init Val ) { if ( viterbi ) o Score [ start ] [ split ] [ l State ] [ cp ] = Math . max ( o Score [ start ] [ split ] [ l State ] [ cp ] , scores To Add [ cp ] ) ; else o Score [ start ] [ split ] [ l State ] [ cp ] += scores To Add [ cp ] ; } } for ( int cp = NUM ; cp < n Right Child States ; cp ++ ) { if ( right Scores [ cp ] > init Val ) { if ( viterbi ) o Score [ split ] [ end ] [ r State ] [ cp ] = Math . max ( o Score [ split ] [ end ] [ r State ] [ cp ] , right Scores [ cp ] ) ; else o Score [ split ] [ end ] [ r State ] [ cp ] += right Scores [ cp ] ; } } } } } } } }
public void stop ( ) { time Mon Index = NUM ; set Exception ( ) ; Iterator iter = iter ( ) ; while ( iter . has Next ( ) ) { Http Mon Item mon Item = ( Http Mon Item ) iter . next ( ) ; mon Item . stop ( this ) ; } if ( stack Trace != null ) change Details ( ) ; }
public void calc Min Tick ( ) { if ( min Data == NUM ) min Tick = NUM ; else min Tick = Math . floor ( min Data / major Tick ) * major Tick ; }
public static void switch Timing ( String next Phase ) { stop Most Recent Timer ( ) ; start Timing ( next Phase ) ; }
public byte [ ] encode ( ) { char type = get Attribute Type ( ) ; if ( ! is Type Valid ( type ) ) throw new Illegal State Exception ( ( ( int ) type ) + STRING ) ; byte bin Value [ ] = new byte [ HEADER LENGTH + get Data Length ( ) ] ; bin Value [ NUM ] = ( byte ) ( type > > NUM ) ; bin Value [ NUM ] = ( byte ) ( type & NUM ) ; bin Value [ NUM ] = ( byte ) ( get Data Length ( ) > > NUM ) ; bin Value [ NUM ] = ( byte ) ( get Data Length ( ) & NUM ) ; bin Value [ NUM ] = NUM ; bin Value [ NUM ] = get Family ( ) ; bin Value [ NUM ] = ( byte ) ( get Port ( ) > > NUM ) ; bin Value [ NUM ] = ( byte ) ( get Port ( ) & NUM ) ; if ( get Family ( ) == ADDRESS FAMILY IPV 6 ) { System . arraycopy ( get Address Bytes ( ) , NUM , bin Value , NUM , NUM ) ; } else { System . arraycopy ( get Address Bytes ( ) , NUM , bin Value , NUM , NUM ) ; } return bin Value ; }
private void do Delete Entry ( String alias ) throws Exception { if ( key Store . contains Alias ( alias ) == BOOL ) { Message Format form = new Message Format ( rb . get String ( STRING ) ) ; Object [ ] source = { alias } ; throw new Exception ( form . format ( source ) ) ; } key Store . delete Entry ( alias ) ; }
protected Integer map Throwable Flat ( Throwable throwable ) { Class < ? extends Throwable > throwable Class = throwable . get Class ( ) ; Integer res Id = throwable To Msg Id Map . get ( throwable Class ) ; if ( res Id == null ) { Class < ? extends Throwable > closest Class = null ; Set < Entry < Class < ? extends Throwable > , Integer > > mappings = throwable To Msg Id Map . entry Set ( ) ; for ( Entry < Class < ? extends Throwable > , Integer > mapping : mappings ) { Class < ? extends Throwable > candidate = mapping . get Key ( ) ; if ( candidate . is Assignable From ( throwable Class ) ) { if ( closest Class == null || closest Class . is Assignable From ( candidate ) ) { closest Class = candidate ; res Id = mapping . get Value ( ) ; } } } } return res Id ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public void assert Column Type ( Result Set rs ) throws SQL Exception { Result Set Meta Data md = rs . get Meta Data ( ) ; int sql Type = md . get Column Type ( mdi . get Position ( ) ) ; assert True ( String . format ( STRING , sql Type , mdi ) , is Allowed Sql Type ( sql Type ) ) ; }
private void validate Dns Names ( Set dns Name Set ) throws Policy Exception { Iterator dns Names = dns Name Set . iterator ( ) ; while ( dns Names . has Next ( ) ) { String dns Name = ( String ) dns Names . next ( ) ; validate Dns Name ( dns Name ) ; dns List . add ( dns Name . to Lower Case ( ) ) ; } }
public static boolean is Mop Method ( String method Name ) { return ( method Name . starts With ( STRING ) || method Name . starts With ( STRING ) ) && ! method Name . contains ( STRING ) ; }
protected void init ( ) { Graphics Config Template 3 D template = new Graphics Config Template 3 D ( ) ; Graphics Environment env = Graphics Environment . get Local Graphics Environment ( ) ; Graphics Device device = env . get Default Screen Device ( ) ; Graphics Configuration config = device . get Best Configuration ( template ) ; canvas = new Canvas 3 D ( config ) ; canvas . set Size ( new Dimension ( DEFAULT DIMENSION , DEFAULT DIMENSION ) ) ; obj Root BG = new Branch Group ( ) ; obj Root BG . set Capability ( Group . ALLOW CHILDREN EXTEND ) ; construct World ( obj Root BG ) ; }
private < Delegated > Presenter Binder < ? super Delegated > find Presenter Binder For Class ( Class < Delegated > clazz ) throws Illegal Access Exception , Instantiation Exception { Presenter Binder < ? super Delegated > presenter Binder ; String cls Name = clazz . get Name ( ) ; String class Name = cls Name + PRESENTER BINDER SUFFIX ; try { Class < ? > presenter Binder Class = Class . for Name ( class Name ) ; presenter Binder = ( Presenter Binder < ? super Delegated > ) presenter Binder Class . new Instance ( ) ; } catch ( Class Not Found Exception e ) { return null ; } return presenter Binder ; }
@ Override final Node < K , V > find ( int h , Object k ) { if ( k != null ) { for ( Node < K , V > e = first ; e != null ; ) { int s ; if ( ( ( s = lock State ) & ( WAITER | WRITER ) ) != NUM ) { if ( e . hash == h && is Equal ( ( K ) k , e . key , my Hashing Strategy ) ) { return e ; } e = e . next ; } else if ( U . compare And Swap Int ( this , LOCKSTATE , s , s + READER ) ) { Tree Node < K , V > r , p ; try { p = ( ( r = root ) == null ? null : r . find Tree Node ( h , k , null ) ) ; } finally { int ls ; do { } while ( ! U . compare And Swap Int ( this , LOCKSTATE , ls = lock State , ls - READER ) ) ; Thread w ; if ( ls == ( READER | WAITER ) && ( w = waiter ) != null ) { Lock Support . unpark ( w ) ; } } return p ; } } } return null ; }
public void square ( double x , double y , double r ) { if ( r < NUM ) throw new Illegal Argument Exception ( STRING ) ; double xs = scale X ( x ) ; double ys = scale Y ( y ) ; double ws = factor X ( NUM * r ) ; double hs = factor Y ( NUM * r ) ; if ( ws <= NUM && hs <= NUM ) pixel ( x , y ) ; else offscreen . draw ( new Rectangle 2 D . Double ( xs - ws / NUM , ys - hs / NUM , ws , hs ) ) ; draw ( ) ; }
private float clamp Mag ( float value , float abs Min , float abs Max ) { final float abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }
private int lower Height Map ( int x , int y , int z ) { for ( -- y ; y >= NUM ; -- y ) { if ( get Type ( x , z , y ) != NUM ) { break ; } } return y + NUM ; }
public String to String ( ) { String Buffer result = new String Buffer ( STRING ) ; for ( int i = NUM ; i < intervalls . size ( ) ; i ++ ) result . append ( intervalls . element At ( i ) ) ; result . append ( STRING ) ; return result . to String ( ) ; }
public void remove ( @ Not Null Status Notification notification ) { stack . remove ( notification ) ; on Close ( notification ) ; }
private Job Definition Entity create Or Update Job Definition Entity ( Job Definition Entity job Definition Entity , Namespace Entity namespace Entity , String job Name , String description , String activiti Id , List < Parameter > parameters , S3 Properties Location s3 Properties Location ) { Job Definition Entity job Definition Entity Local = job Definition Entity ; if ( job Definition Entity Local == null ) { job Definition Entity Local = new Job Definition Entity ( ) ; } job Definition Entity Local . set Name ( job Name ) ; job Definition Entity Local . set Namespace ( namespace Entity ) ; job Definition Entity Local . set Description ( description ) ; job Definition Entity Local . set Activiti Id ( activiti Id ) ; String bucket Name = null ; String key = null ; if ( s3 Properties Location != null ) { bucket Name = s3 Properties Location . get Bucket Name ( ) ; key = s3 Properties Location . get Key ( ) ; } job Definition Entity Local . set S 3 Bucket Name ( bucket Name ) ; job Definition Entity Local . set S 3 Object Key ( key ) ; List < Job Definition Parameter Entity > parameter Entities = new Array List < > ( ) ; if ( ! Collection Utils . is Empty ( parameters ) ) { for ( Parameter parameter : parameters ) { Job Definition Parameter Entity parameter Entity = new Job Definition Parameter Entity ( ) ; parameter Entities . add ( parameter Entity ) ; parameter Entity . set Name ( parameter . get Name ( ) ) ; parameter Entity . set Value ( parameter . get Value ( ) ) ; } } job Definition Entity Local . set Parameters ( parameter Entities ) ; return job Definition Entity Local ; }
public void find ( int index , float weight Loss , float move Cost , Array List < Db Entry > items Placed ) { if ( ( weight Loss >= lowest Weight Loss ) || ( ( weight Loss == lowest Weight Loss ) && ( move Cost >= lowest Move Cost ) ) ) { return ; } else if ( index >= items To Place . size ( ) ) { lowest Weight Loss = weight Loss ; lowest Move Cost = move Cost ; final Placed Items = deep Copy ( items Placed ) ; return ; } Db Entry me = items To Place . get ( index ) ; int my X = me . cell X ; int my Y = me . cell Y ; Array List < Db Entry > items Including Me = new Array List < > ( items Placed . size ( ) + NUM ) ; items Including Me . add All ( items Placed ) ; items Including Me . add ( me ) ; if ( me . span X > NUM || me . span Y > NUM ) { int my W = me . span X ; int my H = me . span Y ; for ( int y = NUM ; y < m Trg Y ; y ++ ) { for ( int x = NUM ; x < m Trg X ; x ++ ) { float new Move Cost = move Cost ; if ( x != my X ) { me . cell X = x ; new Move Cost ++ ; } if ( y != my Y ) { me . cell Y = y ; new Move Cost ++ ; } if ( ignore Move ) { new Move Cost = move Cost ; } if ( is Vacant ( occupied , x , y , my W , my H ) ) { mark Cells ( occupied , me , BOOL ) ; find ( index + NUM , weight Loss , new Move Cost , items Including Me ) ; mark Cells ( occupied , me , BOOL ) ; } if ( my W > me . min Span X && is Vacant ( occupied , x , y , my W - NUM , my H ) ) { me . span X -- ; mark Cells ( occupied , me , BOOL ) ; find ( index + NUM , weight Loss , new Move Cost + NUM , items Including Me ) ; mark Cells ( occupied , me , BOOL ) ; me . span X ++ ; } if ( my H > me . min Span Y && is Vacant ( occupied , x , y , my W , my H - NUM ) ) { me . span Y -- ; mark Cells ( occupied , me , BOOL ) ; find ( index + NUM , weight Loss , new Move Cost + NUM , items Including Me ) ; mark Cells ( occupied , me , BOOL ) ; me . span Y ++ ; } if ( my H > me . min Span Y && my W > me . min Span X && is Vacant ( occupied , x , y , my W - NUM , my H - NUM ) ) { me . span X -- ; me . span Y -- ; mark Cells ( occupied , me , BOOL ) ; find ( index + NUM , weight Loss , new Move Cost + NUM , items Including Me ) ; mark Cells ( occupied , me , BOOL ) ; me . span X ++ ; me . span Y ++ ; } me . cell X = my X ; me . cell Y = my Y ; } } find ( index + NUM , weight Loss + me . weight , move Cost , items Placed ) ; } else { int new Distance = Integer . MAX VALUE ; int new X = Integer . MAX VALUE , new Y = Integer . MAX VALUE ; for ( int y = NUM ; y < m Trg Y ; y ++ ) { for ( int x = NUM ; x < m Trg X ; x ++ ) { if ( ! occupied [ x ] [ y ] ) { int dist = ignore Move ? NUM : ( ( me . cell X - x ) * ( me . cell X - x ) + ( me . cell Y - y ) * ( me . cell Y - y ) ) ; if ( dist < new Distance ) { new X = x ; new Y = y ; new Distance = dist ; } } } } if ( new X < m Trg X && new Y < m Trg Y ) { float new Move Cost = move Cost ; if ( new X != my X ) { me . cell X = new X ; new Move Cost ++ ; } if ( new Y != my Y ) { me . cell Y = new Y ; new Move Cost ++ ; } if ( ignore Move ) { new Move Cost = move Cost ; } mark Cells ( occupied , me , BOOL ) ; find ( index + NUM , weight Loss , new Move Cost , items Including Me ) ; mark Cells ( occupied , me , BOOL ) ; me . cell X = my X ; me . cell Y = my Y ; if ( index + NUM < items To Place . size ( ) && items To Place . get ( index + NUM ) . weight >= me . weight && ! ignore Move ) { find ( index + NUM , weight Loss + me . weight , move Cost , items Placed ) ; } } else { for ( int i = index + NUM ; i < items To Place . size ( ) ; i ++ ) { weight Loss += items To Place . get ( i ) . weight ; } find ( items To Place . size ( ) , weight Loss + me . weight , move Cost , items Placed ) ; } } }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . PUT ) @ Response Body public Rest Wrapper insert ( @ Model Attribute ( STRING ) @ Valid Users users , Binding Result binding Result , Principal principal ) { Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { String hashed Password = Digest Utils . sha 1 Hex ( users . get Password ( ) ) ; com . wipro . ats . bdre . md . dao . jpa . Users jpa Users = new com . wipro . ats . bdre . md . dao . jpa . Users ( ) ; jpa Users . set Password ( hashed Password ) ; jpa Users . set Username ( users . get Username ( ) ) ; jpa Users . set Enabled ( ( users . get Enabled ( ) == NUM ) ? BOOL : BOOL ) ; users DAO . insert ( jpa Users ) ; rest Wrapper = new Rest Wrapper ( users , Rest Wrapper . OK ) ; LOGGER . info ( STRING + users . get Username ( ) + STRING + principal . get Name ( ) + users ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
public static String capped Int ( final long val ) { if ( val >= Integer . MAX VALUE ) { return OVER ; } else if ( val <= Integer . MIN VALUE ) { return UNDER ; } return Long . to String ( val ) ; }
private void create From Assets ( String my DB Name , File dbfile , Input Stream asset File Input Stream ) { Output Stream out = null ; try { String db Path = dbfile . get Absolute Path ( ) ; db Path = db Path . substring ( NUM , db Path . last Index Of ( STRING ) + NUM ) ; File db Path File = new File ( db Path ) ; if ( ! db Path File . exists ( ) ) db Path File . mkdirs ( ) ; File new Db File = new File ( db Path + my DB Name ) ; out = new File Output Stream ( new Db File ) ; byte [ ] buf = new byte [ NUM ] ; int len ; while ( ( len = asset File Input Stream . read ( buf ) ) > NUM ) out . write ( buf , NUM , len ) ; Log . v ( STRING , STRING + new Db File . get Absolute Path ( ) ) ; } catch ( IO Exception ex ) { Log . v ( STRING , STRING + ex . get Message ( ) ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IO Exception ignored ) { } } } }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return PERSON PROPERTY ; case NUM : return PAGE PROPERTY ; case NUM : return EQUIV ; case NUM : return PAGE VIEW ; default : return null ; } }
protected String internal Put ( String key , String new Value ) { synchronized ( child And Property Lock ) { String old Value = properties . get ( key ) ; if ( old Value != null && old Value . equals ( new Value ) ) return old Value ; properties = properties . put ( key , new Value ) ; return old Value ; } }
public Polyline ( Pla Point Int p from corner , Pla Point Int p to corner ) { if ( p from corner . equals ( p to corner ) ) throw new Illegal Argument Exception ( classname + STRING ) ; lines list = new Array List < Pla Line Int > ( NUM ) ; Pla Direction dir = new Pla Direction ( p from corner , p to corner ) ; lines list . add ( new Pla Line Int ( p from corner , dir . rotate 45 deg ( NUM ) ) ) ; lines list . add ( new Pla Line Int ( p from corner , p to corner ) ) ; lines list . add ( new Pla Line Int ( p to corner , dir . rotate 45 deg ( NUM ) ) ) ; corners allocate ( corner count ( ) ) ; precalculated corners [ NUM ] = p from corner ; precalculated corners [ NUM ] = p to corner ; }
protected boolean is On Same Screen As Children ( ) { return BOOL ; }
public static String format Price ( Double price ) { if ( price == null ) return STRING ; return format Price ( price . double Value ( ) ) ; }
static void check Log Dir ( ) { if ( System . get Property ( STRING ) == null ) { log . error ( STRING ) ; } }
private static boolean is More Above ( String src , int index ) { int ch ; int cc ; int len = src . length ( ) ; for ( int i = index + Character . char Count ( src . code Point At ( index ) ) ; i < len ; i += Character . char Count ( ch ) ) { ch = src . code Point At ( i ) ; cc = Normalizer . get Combining Class ( ch ) ; if ( cc == COMBINING CLASS ABOVE ) { return BOOL ; } else if ( cc == NUM ) { return BOOL ; } } return BOOL ; }
public void restore Key ( String key ) { if ( ! key . equals Ignore Case ( STRING ) ) { String original Key = key . substring ( key Test Mode . length ( ) ) ; Object value = get ( key ) ; put ( original Key , value ) ; clear ( key ) ; } }
public boolean has Unsupported Critical Extension ( ) { Set extns = get Critical Extension OI Ds ( ) ; if ( extns == null ) { return BOOL ; } extns . remove ( RFC 3280 Cert Path Utilities . ISSUING DISTRIBUTION POINT ) ; extns . remove ( RFC 3280 Cert Path Utilities . DELTA CRL INDICATOR ) ; return ! extns . is Empty ( ) ; }
public static void write Int ( Data Output out , int v ) throws IO Exception { out . write Byte ( NUM & v ) ; out . write Byte ( NUM & ( v > > > NUM ) ) ; out . write Byte ( NUM & ( v > > > NUM ) ) ; out . write Byte ( NUM & ( v > > > NUM ) ) ; }
public static Comparable [ ] sort Copy ( Comparable [ ] objects ) { int len = objects . length ; Comparable [ ] copy = new Comparable [ len ] ; System . arraycopy ( objects , NUM , copy , NUM , len ) ; sort ( copy ) ; return copy ; }
private Utf 8 Constant parse Utf 8 Constant ( int index ) throws IO Exception { int length = read Short ( ) ; String Builder cb = new String Builder ( ) ; for ( int i = NUM ; i < length ; i ++ ) { int ch = read ( ) ; if ( ch < NUM ) { cb . append ( ( char ) ch ) ; } else if ( ( ch & NUM ) == NUM ) { int ch 2 = read ( ) ; i ++ ; cb . append ( ( char ) ( ( ( ch & NUM ) << NUM ) + ( ch 2 & NUM ) ) ) ; } else { int ch 2 = read ( ) ; int ch 3 = read ( ) ; i += NUM ; cb . append ( ( char ) ( ( ( ch & NUM ) << NUM ) + ( ( ch 2 & NUM ) << NUM ) + ( ( ch 3 & NUM ) ) ) ) ; } } return new Utf 8 Constant ( class . get Constant Pool ( ) , index , cb . to String ( ) ) ; }
@ Override public boolean mark Next Sequence ( ) throws IO Exception { if ( m Seq Size < m Limit && m Pointer Size + m Pointer Entry Size <= m Limit ) { m Pointers . write Byte ( ( int ) m Checksum Seq . get Value ( ) ) ; m Checksum Seq . reset ( ) ; if ( m Checksum Qual != null ) { m Pointers . write Byte ( ( int ) m Checksum Qual . get Value ( ) ) ; m Checksum Qual . reset ( ) ; } m Pointers . write Int ( ( int ) m Seq Size ) ; m Pointer Size += m Pointer Entry Size ; return BOOL ; } return BOOL ; }
public final double sample Active Count ( ) { return active Count . get ( ) ; }
private void preprocess Data ( Map < Integer , Map < Integer , List < Integer > > > knoten Von Spur Nach Spur Mapping , Map < Integer , Map < Integer , String > > knoten Spur Link Mapping ) { preprocess Knoten Spur Link Mapping ( knoten Spur Link Mapping ) ; clean Knoten Von Spur Nach Spur Mapping ( knoten Von Spur Nach Spur Mapping , knoten Spur Link Mapping ) ; merge Lanes On Same Link ( knoten Von Spur Nach Spur Mapping , knoten Spur Link Mapping ) ; }
@ Override public boolean mutate ( Test Case test , Test Factory factory ) { if ( Randomness . next Double ( ) >= Properties . P CHANGE PARAMETER ) return BOOL ; if ( ! is Static ( ) ) { Variable Reference source = get Source ( ) ; List < Variable Reference > objects = test . get Objects ( source . get Type ( ) , get Position ( ) ) ; objects . remove ( source ) ; if ( ! objects . is Empty ( ) ) { set Source ( Randomness . choice ( objects ) ) ; return BOOL ; } } return BOOL ; }
@ Override protected void draw X Labels ( List < Double > x Labels , Double [ ] x Text Label Locations , Canvas canvas , Paint paint , int left , int top , int bottom , double x Pixels Per Unit , double min X , double max X ) { int length = x Labels . size ( ) ; if ( length > NUM ) { boolean show Labels = m Renderer . is Show Labels ( ) ; boolean show Grid Y = m Renderer . is Show Grid Y ( ) ; boolean show Tick Marks = m Renderer . is Show Tick Marks ( ) ; Date Format format = get Date Format ( x Labels . get ( NUM ) , x Labels . get ( length - NUM ) ) ; for ( int i = NUM ; i < length ; i ++ ) { long label = Math . round ( x Labels . get ( i ) ) ; float x Label = ( float ) ( left + x Pixels Per Unit * ( label - min X ) ) ; if ( show Labels ) { paint . set Color ( m Renderer . get X Labels Color ( ) ) ; if ( show Tick Marks ) { canvas . draw Line ( x Label , bottom , x Label , bottom + m Renderer . get Labels Text Size ( ) / NUM , paint ) ; } draw Text ( canvas , format . format ( new Date ( label ) ) , x Label , bottom + m Renderer . get Labels Text Size ( ) * NUM / NUM + m Renderer . get X Labels Padding ( ) , paint , m Renderer . get X Labels Angle ( ) ) ; } if ( show Grid Y ) { paint . set Color ( m Renderer . get Grid Color ( NUM ) ) ; canvas . draw Line ( x Label , bottom , x Label , top , paint ) ; } } } draw X Text Labels ( x Text Label Locations , canvas , paint , BOOL , left , top , bottom , x Pixels Per Unit , min X , max X ) ; }
public X Path ( String expr String , Source Locator locator , Prefix Resolver prefix Resolver , int type ) throws javax . xml . transform . Transformer Exception { this ( expr String , locator , prefix Resolver , type , null ) ; }
private void add Menu Item ( J Popup Menu menu , String title , MWF Node node , int AD WF Node To ID ) { WF Popup Item item = new WF Popup Item ( title , node , AD WF Node To ID ) ; menu . add ( item ) ; item . add Action Listener ( this ) ; }
public synchronized long allocate ( int length ) { int blocks = get Block Count ( length ) ; Block Range x = null ; for ( Block Range b : free Space ) { if ( b . blocks >= blocks ) { x = b ; break ; } } long pos = get Pos ( x . start ) ; if ( x . blocks == blocks ) { free Space . remove ( x ) ; } else { x . start += blocks ; x . blocks -= blocks ; } return pos ; }
public Jenkins Http Client ( URI uri , String username , String password ) { this ( uri ) ; if ( is Not Blank ( username ) ) { Credentials Provider provider = client . get Credentials Provider ( ) ; Auth Scope scope = new Auth Scope ( uri . get Host ( ) , uri . get Port ( ) , Auth Scope . ANY REALM ) ; Username Password Credentials credentials = new Username Password Credentials ( username , password ) ; provider . set Credentials ( scope , credentials ) ; local Context = new Basic Http Context ( ) ; local Context . set Attribute ( STRING , new Basic Scheme ( ) ) ; client . add Request Interceptor ( new Preemptive Auth ( ) , NUM ) ; } }
public static Set combine O Cs ( Set one , Set two ) { if ( one == null || one . is Empty ( ) ) { return two ; } if ( two == null || two . is Empty ( ) ) { return one ; } Set result Set = new Hash Set ( ) ; Iterator itr 1 = one . iterator ( ) ; while ( itr 1 . has Next ( ) ) { String value 1 = ( String ) itr 1 . next ( ) ; result Set . add ( value 1 . to Lower Case ( ) ) ; } Iterator itr 2 = two . iterator ( ) ; while ( itr 2 . has Next ( ) ) { String value 2 = ( String ) itr 2 . next ( ) ; result Set . add ( value 2 . to Lower Case ( ) ) ; } return result Set ; }
private String wrap ( String str ) { String Builder buf = new String Builder ( str ) ; int len = line Length ; while ( len < buf . length ( ) ) { int idx = buf . last Index Of ( STRING , len ) ; if ( idx != - NUM ) { buf . replace ( idx , idx + NUM , breaker ) ; len = idx + breaker . length ( ) + line Length ; } else { buf . insert ( len , breaker ) ; len += breaker . length ( ) + line Length ; } } buf . insert ( NUM , STRING ) ; return buf . to String ( ) ; }
public Echo State Network commit Changes ( ) { Network net = network Panel . get Network ( ) ; Integer num Ins = Utils . parse Integer ( tf Input Layer Pop ) ; if ( num Ins == null ) { throw new Illegal Argument Exception ( STRING ) ; } Neuron Group input Layer = new Neuron Group ( net , num Ins ) ; if ( input Layer . size ( ) > input Layer . get Grid Threshold ( ) ) { input Layer . set Layout ( new org . simbrain . network . layouts . Grid Layout ( ) ) ; } input Layer . apply Layout ( ) ; Neuron Group reservoir Layer = reservoir Panel . create Layer From Data ( ) ; if ( reservoir Layer . size ( ) > reservoir Layer . get Grid Threshold ( ) ) { reservoir Layer . set Layout ( new org . simbrain . network . layouts . Grid Layout ( ) ) ; } reservoir Layer . apply Layout ( ) ; Synapse Group res Synapses = res To Res Panel . create Synapse Group ( reservoir Layer , reservoir Layer ) ; res Synapses . set Label ( STRING ) ; Neuron Group output Layer = output Panel . create Layer From Data ( ) ; output Layer . apply Layout ( ) ; if ( output Layer . size ( ) > output Layer . get Grid Threshold ( ) ) { output Layer . set Layout ( new org . simbrain . network . layouts . Grid Layout ( ) ) ; } Echo State Network esn = new Echo State Network ( net , network Panel . get Last Clicked Position ( ) ) ; esn . set Back Weights ( allow Out To Res . is Selected ( ) ) ; esn . set Direct In Out Weights ( direct Input To Output . is Selected ( ) ) ; esn . set Recurrent Out Weights ( allow Recurrent Outputs . is Selected ( ) ) ; esn . set Time Type ( ( Time Type ) cb Time Type . get Selected Item ( ) ) ; double max Eig = Utils . double Parsable ( spectral Radius ) ; if ( Double . is Na N ( max Eig ) ) { throw new Illegal Argument Exception ( STRING ) ; } esn . initialize Input Layer ( input Layer ) ; esn . initialize Reservoir ( reservoir Layer , res Synapses , max Eig ) ; esn . initialize Output ( output Layer ) ; Synapse Group itr = in To Res Panel . create Synapse Group ( input Layer , reservoir Layer ) ; itr . set Label ( STRING ) ; esn . add Synapse Group ( itr ) ; Synapse Group rto = Synapse Group . create Synapse Group ( reservoir Layer , output Layer , NUM ) ; rto . set Label ( STRING ) ; esn . add Synapse Group ( rto ) ; if ( allow Recurrent Outputs . is Selected ( ) ) { Synapse Group oto = Synapse Group . create Synapse Group ( output Layer , output Layer , NUM ) ; oto . set Label ( STRING ) ; esn . add Synapse Group ( oto ) ; } if ( allow Out To Res . is Selected ( ) ) { Synapse Group otr = out To Res Panel . create Synapse Group ( output Layer , reservoir Layer ) ; otr . set Label ( STRING ) ; esn . add Synapse Group ( otr ) ; } if ( direct Input To Output . is Selected ( ) ) { Synapse Group ito = Synapse Group . create Synapse Group ( input Layer , output Layer , NUM ) ; ito . set Label ( STRING ) ; esn . add Synapse Group ( ito ) ; } esn . position Layers ( ) ; return esn ; }
public static double pdf ( double x , double shape , double scale ) { if ( x < NUM ) return NUM ; if ( x == NUM ) { if ( shape == NUM ) return NUM / scale ; else return NUM ; } if ( shape == NUM ) return NUM / x ; if ( shape == - NUM ) { return Math . sqrt ( x ) ; } final double xs = x / scale ; if ( shape == NUM ) { return Math . exp ( - xs ) / scale ; } final double a = Math . exp ( ( shape - NUM ) * Math . log ( xs ) - xs - Gamma Function . ln Gamma ( shape ) ) ; return a / scale ; }
public void flush ( ) { synchronized ( list ) { int n = NUM ; long m = NUM ; for ( T b : list ) { if ( halt ) throw new Runtime Exception ( first Cause . get ( ) ) ; final int size = b . size ( ) ; final long counter = b . flush ( ) ; m += counter ; if ( DEBUG ) log . debug ( STRING + size + STRING + counter ) ; } if ( INFO ) log . info ( STRING + n + STRING + m + STRING ) ; } }
private void write Attribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( xml Writer . get Prefix ( namespace ) == null ) { xml Writer . write Namespace ( prefix , namespace ) ; xml Writer . set Prefix ( prefix , namespace ) ; } xml Writer . write Attribute ( namespace , att Name , att Value ) ; }
public void log Info ( String message ) { logger . info ( log Prefix + message ) ; }
private boolean match Address ( final byte [ ] remote Mask ) { if ( rule Type == Rule Type . ALLWILDCARD ) { return BOOL ; } if ( prefix Mask == null ) { return BOOL ; } if ( remote Mask . length != prefix Mask . length ) { return BOOL ; } for ( int i = NUM ; i < prefix Mask . length ; i ++ ) { if ( ! wild Card . get ( i ) && ( rule Mask [ i ] & prefix Mask [ i ] ) != ( remote Mask [ i ] & prefix Mask [ i ] ) ) { return BOOL ; } } return BOOL ; }
public static String sign ( String signing String , Private Key private Key ) throws Invalid Key Exception , Signature Exception { byte [ ] bytes = signing String . get Bytes ( Standard Charsets . UTF 8 ) ; Signature sig ; try { sig = Signature . get Instance ( SHA 256 WITH RSA ) ; } catch ( No Such Algorithm Exception e ) { throw new Illegal Argument Exception ( STRING , e ) ; } sig . init Sign ( private Key ) ; sig . update ( bytes ) ; return Hex . encode Hex String ( sig . sign ( ) ) ; }
public Object invoke ( Method method , Object target , Extension Context extension Context , Extension Registry extension Registry ) { @ Suppress Warnings ( STRING ) Optional < Object > optional Target = ( target instanceof Optional ? ( Optional < Object > ) target : Optional . of Nullable ( target ) ) ; return Reflection Utils . invoke Method ( method , target , resolve Parameters ( method , optional Target , extension Context , extension Registry ) ) ; }
private static native void init I Ds ( ) ;
Registered Project put Project ( Project Config config , Folder Entry folder , boolean updated , boolean detected ) throws Server Exception , Conflict Exception , Not Found Exception { final Registered Project project = new Registered Project ( folder , config , updated , detected , this . project Type Registry ) ; projects . put ( project . get Path ( ) , project ) ; return project ; }
protected void tear Down ( ) { try { ds . close ( ) ; sds . close ( ) ; } catch ( Exception e ) { } }
@ Override public void remove Listener ( final I Zy Node Realizer Listener < ? > listener ) { m listeners . remove Listener ( listener ) ; }
protected void assert Result Row Count ( int expected , Result Set rs ) throws SQL Exception { int i = NUM ; while ( rs . next ( ) ) { i ++ ; } assert Equals ( expected , i ) ; }
private boolean is Model Useful ( Contingency Matrix cm ) { for ( int row = NUM ; row < cm . get Number Of Predictions ( ) ; row ++ ) { for ( int col = NUM ; col < cm . get Number Of Classes ( ) ; col ++ ) { if ( Math . abs ( cm . get Lift ( row , col ) - NUM ) > MIN ADVANTAGE ) { return BOOL ; } } } return BOOL ; }
public void scan ( Class Node cn ) { List < Threat Result > threats = new Array List < Threat Result > ( ) ; for ( Class Handler class Handler : class Handlers ) { Threat Result result = class Handler . scan Class ( cn ) ; if ( result != null ) { threats . add ( result ) ; } } for ( Method Node mn : cn . methods ) { for ( Method Handler method Handler : method Handlers ) { Threat Result result = method Handler . scan Method ( mn ) ; if ( result != null ) { threats . add ( result ) ; } } } if ( threats . size ( ) > NUM ) { threats By Class . put ( cn . name , threats ) ; } }
private void pull Event ( ) { final int new Scroll Value ; final int item Dimension ; final float initial Motion Value , last Motion Value ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : initial Motion Value = m Initial Motion X ; last Motion Value = m Last Motion X ; break ; case VERTICAL : default : initial Motion Value = m Initial Motion Y ; last Motion Value = m Last Motion Y ; break ; } switch ( m Current Mode ) { case PULL FROM END : new Scroll Value = Math . round ( Math . max ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Footer Size ( ) ; break ; case PULL FROM START : default : new Scroll Value = Math . round ( Math . min ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Header Size ( ) ; break ; } set Header Scroll ( new Scroll Value ) ; if ( new Scroll Value != NUM && ! is Refreshing ( ) ) { float scale = Math . abs ( new Scroll Value ) / ( float ) item Dimension ; switch ( m Current Mode ) { case PULL FROM END : m Footer Layout . on Pull ( scale ) ; break ; case PULL FROM START : default : m Header Layout . on Pull ( scale ) ; break ; } if ( m State != State . PULL TO REFRESH && item Dimension >= Math . abs ( new Scroll Value ) ) { set State ( State . PULL TO REFRESH ) ; } else if ( m State == State . PULL TO REFRESH && item Dimension < Math . abs ( new Scroll Value ) ) { set State ( State . RELEASE TO REFRESH ) ; } } }
public void reset ( ) { m Channel Number = NUM ; m Active Calls . clear ( ) ; mES Ns . clear ( ) ; m Neighbor I Ds . clear ( ) ; m Receive Frequencies . clear ( ) ; m Site I Ds . clear ( ) ; m Talkgroups . clear ( ) ; m Transmit Frequencies . clear ( ) ; m Unique I Ds . clear ( ) ; reset State ( ) ; }
public static String newick No Lengths ( Tree tree ) { String Buffer buffer = new String Buffer ( ) ; newick ( tree , tree . get Root ( ) , BOOL , Branch Length Type . NO BRANCH LENGTHS , null , null , null , null , buffer ) ; buffer . append ( STRING ) ; return buffer . to String ( ) ; }
@ Override public String to String ( ) { return ( String . value Of ( get Type ( ) ) + STRING + get Key ( ) + STRING + get Value ( ) ) ; }
@ POST @ Path ( STRING ) @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Consumes ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Check Permission ( roles = { Role . SECURITY ADMIN , Role . RESTRICTED SECURITY ADMIN } , block Proxies = BOOL ) public String rotate I Psec Key ( ) { ipsec Mgr . verify I Psec Op Allowable ( ) ; String version = ipsec Mgr . rotate Key ( ) ; audit Mgr . record Audit Log ( null , null , IPSEC SERVICE TYPE , Operation Type Enum . UPDATE SYSTEM PROPERTY , System . current Time Millis ( ) , Audit Log Manager . AUDITLOG SUCCESS , null , STRING + version ) ; return version ; }
public int append ( char chunk [ ] ) throws Guacamole Exception { return append ( chunk , NUM , chunk . length ) ; }
public byte [ ] reset ( byte [ ] data ) { byte [ ] bytes = null ; if ( ( data [ NUM ] & NUM ) < NUM ) { bytes = new byte [ data [ NUM ] + NUM ] ; System . arraycopy ( data , NUM , bytes , NUM , data [ NUM ] + NUM ) ; } else { if ( ( data [ NUM ] & NUM ) > NUM ) { int len = data [ NUM ] & ( byte ) NUM ; int result = NUM ; for ( int i = NUM ; i < len ; i ++ ) { result |= ( data [ i + NUM ] & NUM ) << ( NUM * ( len - i - NUM ) ) ; } bytes = new byte [ result + len + NUM ] ; System . arraycopy ( data , NUM , bytes , NUM , result + len + NUM ) ; } } return bytes ; }
public Vector Clock ( ) { this ( new Array List < Clock Entry > ( NUM ) , System . current Time Millis ( ) ) ; }
public Analyzer add ( String name , Nondominated Population result ) { List < Nondominated Population > list = data . get ( name ) ; if ( list == null ) { list = new Array List < Nondominated Population > ( ) ; data . put ( name , list ) ; } list . add ( result ) ; return this ; }
public static void assert Equals ( String msg , double [ ] expected , double [ ] observed , double tolerance ) { String Builder out = new String Builder ( msg ) ; if ( expected . length != observed . length ) { out . append ( STRING ) ; out . append ( STRING ) ; out . append ( expected . length ) ; out . append ( STRING ) ; out . append ( observed . length ) ; Assert . fail ( out . to String ( ) ) ; } boolean failure = BOOL ; for ( int i = NUM ; i < expected . length ; i ++ ) { if ( ! Precision . equals Including Na N ( expected [ i ] , observed [ i ] , tolerance ) ) { failure = BOOL ; out . append ( STRING ) ; out . append ( i ) ; out . append ( STRING ) ; out . append ( STRING ) ; out . append ( expected [ i ] ) ; out . append ( STRING ) ; out . append ( observed [ i ] ) ; } } if ( failure ) { Assert . fail ( out . to String ( ) ) ; } }
public void initialize Atoms For Finite ( List < Datum > data , String filename , Random random ) { beta = new double [ K ] ; dof = new double [ K ] ; omega = new Array List < > ( K ) ; if ( filename != null ) { try { loc = Batch Mixture Model . initialize Clusters From File ( filename , K ) ; if ( loc . size ( ) < K ) { loc = Batch Mixture Model . gonzalez Initialize Mixture Centers ( loc , data , K , random ) ; } } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; loc = Batch Mixture Model . gonzalez Initialize Mixture Centers ( data , K , random ) ; } } else { loc = Batch Mixture Model . gonzalez Initialize Mixture Centers ( data , K , random ) ; } log . debug ( STRING , loc ) ; for ( int k = NUM ; k < this . K ; k ++ ) { beta [ k ] = base Beta ; dof [ k ] = base Nu ; omega . add ( base Omega ) ; } }
@ Override public void on Init ( List < ? extends Index Commit > commits ) throws IO Exception { if ( commits . is Empty ( ) ) { return ; } log . info ( STRING , new Commits Logging Info ( commits ) ) ; log . debug ( STRING , new Commits Logging Debug ( commits ) ) ; update Commits ( commits ) ; }
public boolean is Loading ( ) { return state . equals ( LOADING ) ; }
Char Sequence convert ( Object value , String key ) ;
@ Override public final void sample ( ) { synchronized ( lock ) { long count = count . get ( ) ; long last Count = last Avg Count ; last Avg Count = count ; long sum = sum . get ( ) ; double last Sum = last Avg Sum ; last Avg Sum = sum ; if ( count == last Count ) value = NUM ; else value = scale * ( sum - last Sum ) / ( double ) ( count - last Count ) ; } }
public boolean login ( ) throws Login Exception { try { load Password File ( ) ; } catch ( IO Exception ioe ) { Login Exception le = new Login Exception ( STRING + password File Display Name ) ; throw Env Help . init Cause ( le , ioe ) ; } if ( user Credentials == null ) { throw new Login Exception ( STRING ) ; } if ( logger . debug On ( ) ) { logger . debug ( STRING , STRING + password File Display Name ) ; } if ( try First Pass ) { try { attempt Authentication ( BOOL ) ; succeeded = BOOL ; if ( logger . debug On ( ) ) { logger . debug ( STRING , STRING ) ; } return BOOL ; } catch ( Login Exception le ) { clean State ( ) ; logger . debug ( STRING , STRING ) ; } } else if ( use First Pass ) { try { attempt Authentication ( BOOL ) ; succeeded = BOOL ; if ( logger . debug On ( ) ) { logger . debug ( STRING , STRING ) ; } return BOOL ; } catch ( Login Exception le ) { clean State ( ) ; logger . debug ( STRING , STRING ) ; throw le ; } } if ( logger . debug On ( ) ) { logger . debug ( STRING , STRING ) ; } try { attempt Authentication ( BOOL ) ; succeeded = BOOL ; if ( logger . debug On ( ) ) { logger . debug ( STRING , STRING ) ; } return BOOL ; } catch ( Login Exception le ) { clean State ( ) ; logger . debug ( STRING , STRING ) ; throw le ; } }
public Builder update Extension ( Extension extension ) { extensions . add ( extension ) ; return this ; }
public void process Utterance ( Utterance utterance ) throws Process Exception { if ( utterance . get Relation ( Relation . SEGMENT ) == null ) { throw new Illegal State Exception ( STRING ) ; } utterance . set Object ( Sample Info . UTT NAME , diphone Database . get Sample Info ( ) ) ; create Unit Relation ( utterance ) ; }
public static int copy ( Input Stream in , Output Stream out ) throws IO Exception { Assert . not Null ( in , STRING ) ; Assert . not Null ( out , STRING ) ; try { return Stream Utils . copy ( in , out ) ; } finally { try { in . close ( ) ; } catch ( IO Exception ex ) { } try { out . close ( ) ; } catch ( IO Exception ex ) { } } }
private String convert To Attribute Name ( String local Name ) { return local Name . replace ( STRING , STRING ) ; }
public Expanded Statement Builder reference ( String property , Object value ) { check Can Change ( ) ; extra Info . add ( new Reference Info ( property , value ) ) ; return this ; }
@ Target Api ( Build . VERSION CODES . HONEYCOMB ) protected void swipe View ( View child , float delta X , float delta Y ) { if ( is Fixed View ( child ) ) { delta X = delta X / NUM ; } float delta X Abs = Math . abs ( delta X ) ; float fraction Covered = delta X Abs / ( float ) child . get Width ( ) ; child . set Translation X ( delta X ) ; child . set Alpha ( NUM - fraction Covered ) ; if ( delta X > NUM ) child . set Rotation Y ( - NUM * fraction Covered ) ; else child . set Rotation Y ( NUM * fraction Covered ) ; }
private void verify Is Root ( ) { if ( hierarchy Elements . size ( ) != NUM ) { throw new Illegal State Exception ( STRING + STRING + hierarchy ) ; } }
@ Override public int size ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } }
private void verify With Separate Signing Key ( X509 Certificate cert , Public Key prev Key , boolean sign Flag , Set < X509 Certificate > stacked Certs ) throws Cert Path Validator Exception { String msg = STRING ; if ( debug != null ) { debug . println ( STRING + STRING + msg + STRING ) ; } if ( ( stacked Certs != null ) && stacked Certs . contains ( cert ) ) { if ( debug != null ) { debug . println ( STRING + STRING ) ; } throw new Cert Path Validator Exception ( STRING , null , null , - NUM , Basic Reason . UNDETERMINED REVOCATION STATUS ) ; } if ( ! sign Flag ) { build To New Key ( cert , null , stacked Certs ) ; } else { build To New Key ( cert , prev Key , stacked Certs ) ; } }
public boolean is Running ( ) { return this . running ; }
private boolean map Pattern Elem Pos ( int nesting , boolean is Start , boolean is Attr Name ) { if ( NUM == nesting ) { if ( m pattern Map Size >= m pattern Map . length ) { int pattern Map [ ] = m pattern Map ; int len = m pattern Map . length ; m pattern Map = new int [ m pattern Map Size + NUM ] ; System . arraycopy ( pattern Map , NUM , m pattern Map , NUM , len ) ; } if ( ! is Start ) { m pattern Map [ m pattern Map Size - NUM ] -= TARGETEXTRA ; } m pattern Map [ m pattern Map Size ] = ( m compiler . get Token Queue Size ( ) - ( is Attr Name ? NUM : NUM ) ) + TARGETEXTRA ; m pattern Map Size ++ ; is Start = BOOL ; } return is Start ; }
public boolean add Operation At First ( Operation operation ) { if ( is Running ) { if ( operation Handler Thread Handler == null ) return BOOL ; return operation Handler Thread Handler . post At Front Of Queue ( new Android Operation ( this , operation ) ) ; } else { return operation Queue . add ( new Android Operation ( this , operation , Android Operation . Type . ATFIRST , null , NUM ) ) ; } }
public void test Shift Left 1 ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = NUM ; int number = NUM ; byte r Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . shift Left ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public static String to Unitbytes ( long bytes ) { if ( bytes < NUM ) { return STRING + GENERAL UNIT KILOBYTES ; } long unit Value ; String unit Name ; if ( bytes < NUM ) { unit Value = NUM ; unit Name = GENERAL UNIT KILOBYTES ; } else if ( bytes < NUM ) { unit Value = NUM ; unit Name = GENERAL UNIT MEGABYTES ; } else if ( bytes < NUM ) { unit Value = NUM ; unit Name = GENERAL UNIT GIGABYTES ; } else { unit Value = NUM ; unit Name = GENERAL UNIT TERABYTES ; } Number Format number Format ; if ( ( double ) bytes * NUM / unit Value < NUM ) number Format = NUMBER FORMAT 1 ; else number Format = NUMBER FORMAT 0 ; try { return number Format . format ( ( double ) bytes / unit Value ) + STRING + unit Name ; } catch ( Arithmetic Exception ae ) { return STRING + unit Name ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public static String change Password ( Connection conn , String user Name , String password ) throws Exception { Prepared Statement prep = conn . prepare Statement ( STRING ) ; prep . set String ( NUM , password ) ; prep . set String ( NUM , user Name ) ; prep . execute Update ( ) ; return password ; }
public Object remove ( Object key ) { process Queue ( ) ; return map . remove ( Key . create ( key , null ) ) ; }
protected Rectangle compute Popup Bounds ( int px , int py , int pw , int ph ) { Toolkit toolkit = Toolkit . get Default Toolkit ( ) ; Rectangle screen Bounds ; Graphics Configuration gc = combo Box . get Graphics Configuration ( ) ; Point p = new Point ( ) ; Swing Utilities . convert Point From Screen ( p , combo Box ) ; if ( gc != null ) { Insets screen Insets = toolkit . get Screen Insets ( gc ) ; screen Bounds = gc . get Bounds ( ) ; screen Bounds . width -= ( screen Insets . left + screen Insets . right ) ; screen Bounds . height -= ( screen Insets . top + screen Insets . bottom ) ; screen Bounds . x += ( p . x + screen Insets . left ) ; screen Bounds . y += ( p . y + screen Insets . top ) ; } else { screen Bounds = new Rectangle ( p , toolkit . get Screen Size ( ) ) ; } Rectangle rect = new Rectangle ( px , py , pw , ph ) ; if ( py + ph > screen Bounds . y + screen Bounds . height && ph < screen Bounds . height ) { rect . y = - rect . height ; } return rect ; }
public static Intent build Background Shortcut Intent ( File script , Parcelable icon Resource ) { Intent intent = new Intent ( ) ; intent . put Extra ( Intent . EXTRA SHORTCUT INTENT , build Start In Background Intent ( script ) ) ; intent . put Extra ( Intent . EXTRA SHORTCUT NAME , script . get Name ( ) ) ; intent . put Extra ( Intent . EXTRA SHORTCUT ICON RESOURCE , icon Resource ) ; return intent ; }
public static boolean is Shown ( final Actor actor ) { return actor != null && actor . get Stage ( ) != null ; }
public static void add Listener ( final Diagnostic Listener listener ) { if ( listener != null ) { LISTENERS . add ( listener ) ; } }
public void shuffle Training Set ( ) { utils . shuffle List ( Training Files ) ; }
public NTLM Authentication ( boolean is Proxy , URL url , Password Authentication pw ) { super ( is Proxy ? PROXY AUTHENTICATION : SERVER AUTHENTICATION , Auth Scheme . NTLM , url , STRING ) ; init ( pw ) ; }
public Message Channel create Message Channel ( SIP Request request , Message Processor mp , Hop next Hop ) throws IO Exception { Host target Host = new Host ( ) ; target Host . set Hostname ( next Hop . get Host ( ) ) ; Host Port target Host Port = new Host Port ( ) ; target Host Port . set Host ( target Host ) ; target Host Port . set Port ( next Hop . get Port ( ) ) ; Message Channel return Channel = mp . create Message Channel ( target Host Port ) ; return return Channel ; }
public static byte [ ] generate Mac ( byte [ ] byte Cipher Text , Secret Key integrity Key ) throws No Such Algorithm Exception , Invalid Key Exception { Mac sha 256 HMAC = Mac . get Instance ( HMAC ALGORITHM ) ; sha 256 HMAC . init ( integrity Key ) ; return sha 256 HMAC . do Final ( byte Cipher Text ) ; }
public void populate Edit Text ( String query ) { String text = query . trim ( ) ; set Search String ( text , BOOL ) ; dispatch State Change ( Search View State . SEARCH ) ; }
public static byte [ ] concat ( byte [ ] b1 , byte [ ] b2 ) { byte [ ] out = new byte [ b1 . length + b2 . length ] ; System . arraycopy ( b1 , NUM , out , NUM , b1 . length ) ; System . arraycopy ( b2 , NUM , out , b1 . length , b2 . length ) ; return out ; }
private void clip View On The Right ( Rect cur View Bound , float cur View Width , int right ) { cur View Bound . right = ( int ) ( right - m Clip Padding ) ; cur View Bound . left = ( int ) ( cur View Bound . right - cur View Width ) ; }
public static void put Float ( String property , float val ) { SIMBRAIN PREFERENCES . put Float ( property , val ) ; }
public int hash Code ( ) { return Arrays . hash Code ( this . uid ) ; }
private void advance Run State ( int target State ) { for ( ; ; ) { int c = ctl . get ( ) ; if ( run State At Least ( c , target State ) || ctl . compare And Set ( c , ctl Of ( target State , worker Count Of ( c ) ) ) ) break ; } }
public static final double [ ] copy ( final double [ ] v ) { return Arrays . copy Of ( v , v . length ) ; }
public void add Action ( String action ) { Object [ ] args = new String [ NUM ] ; Simple Date Format sdf = new Simple Date Format ( context . get String ( R . string . date Format ) ) ; args [ NUM ] = sdf . format ( new Date ( ) ) ; String timestamp = context . get String ( R . string . timestamp , args ) ; history . add ( action + timestamp ) ; notify Listeners ( new Property Change Event ( this , Activity Constants . history Property , null , null ) ) ; }
private Filter Operation Codes ( ) { }
@ Override public String to String ( ) { String Buffer text = new String Buffer ( ) ; if ( m train Instances == null ) { text . append ( STRING ) ; } else { text . append ( STRING ) ; if ( ! m missing merge ) { text . append ( STRING ) ; } } text . append ( STRING ) ; return text . to String ( ) ; }
public Char Sequence sub Sequence ( int start , int end ) { return substring ( start , end ) ; }
private Creation Template to Creation Template ( Attr Set t ) { Attr name Attr = t . get Attribute ( TEMPLATE NAME ) ; String name = null ; if ( name Attr != null ) { name = name Attr . get Value ( ) ; } Attr naming Attr = t . get Attribute ( TEMPLATE NAMINGATTRIBUTE ) ; String naming Attribute = null ; if ( naming Attr != null ) { naming Attribute = naming Attr . get Value ( ) ; } Attr class Attr = t . get Attribute ( TEMPLATE JAVACLASS ) ; String [ ] class Names = null ; if ( class Attr != null ) { class Names = class Attr . get String Values ( ) ; } Attr Set required = decode Attr ( t . get Attribute ( TEMPLATE REQUIRED ) , STRING ) ; Attr Set optional = decode Attr ( t . get Attribute ( TEMPLATE OPTIONAL ) , STRING ) ; Attr Set validated = decode Attr ( t . get Attribute ( TEMPLATE VALIDATED ) , STRING ) ; Creation Template template = new Creation Template ( ) ; Array List classes = new Array List ( ) ; try { if ( class Names != null ) { for ( int i = NUM ; i < class Names . length ; i ++ ) { Class cls = Class . for Name ( class Names [ i ] ) ; classes . add ( cls ) ; } } template = new Creation Template ( name , required , optional , classes ) ; } catch ( Class Not Found Exception e ) { template = new Creation Template ( name , required , optional ) ; } if ( validated != null ) { template . set Validation ( validated ) ; } if ( naming Attribute != null ) { template . set Naming Attribute ( naming Attribute ) ; } return template ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
public void place Item ( Item Stack stack , Block Pos pos , World world , boolean centre Item ) { double offset = ( centre Item ) ? NUM : NUM ; Entity Item entityitem = new Entity Item ( world , ( double ) pos . get X ( ) + offset , ( double ) pos . get Y ( ) + offset , ( double ) pos . get Z ( ) + offset , stack ) ; entityitem . motion X = NUM ; entityitem . motion Y = NUM ; entityitem . motion Z = NUM ; entityitem . set Default Pickup Delay ( ) ; world . spawn Entity In World ( entityitem ) ; }
private E unlink First ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; not Full . signal ( ) ; return item ; }
private < M extends Configuration Client , P > Managed Object < M > create New Managed Object ( Managed Object Definition < M , ? > d , Managed Object Path < M , ? > p , Property Definition < P > naming Property Definition , String name , Collection < Property Exception > exceptions ) { Property Set child Properties = new Property Set ( ) ; for ( Property Definition < ? > pd : d . get All Property Definitions ( ) ) { try { create Property ( child Properties , p , pd ) ; } catch ( Property Exception e ) { if ( exceptions != null ) { exceptions . add ( e ) ; } } } if ( naming Property Definition != null ) { P value = naming Property Definition . decode Value ( name ) ; child Properties . set Property Values ( naming Property Definition , Collections . singleton ( value ) ) ; } return new Instance ( d , p , child Properties , BOOL , naming Property Definition ) ; }
public abstract void initialize Constraints ( Step step , Settings settings ) ;
public void test Empty Commits ( ) throws Exception { clear Index With Replication ( ) ; index ( master Client , STRING , STRING , STRING , STRING ) ; empty Update ( master Client , STRING , STRING ) ; pull From Master To Slave ( ) ; r Query ( NUM , STRING , slave Client ) ; assert Versions ( master Client , slave Client ) ; empty Update ( master Client , STRING , STRING ) ; pull From Master To Slave ( ) ; index ( master Client , STRING , STRING , STRING , STRING ) ; empty Update ( master Client , STRING , STRING ) ; pull From Master To Slave ( ) ; r Query ( NUM , STRING , slave Client ) ; assert Versions ( master Client , slave Client ) ; index ( master Client , STRING , STRING , STRING , STRING ) ; empty Update ( master Client , STRING , STRING , STRING , STRING ) ; pull From Master To Slave ( ) ; r Query ( NUM , STRING , master Client ) ; r Query ( NUM , STRING , slave Client ) ; index ( master Client , STRING , STRING , STRING , STRING ) ; empty Update ( master Client , STRING , STRING ) ; pull From Master To Slave ( ) ; String q = STRING ; r Query ( NUM , q , master Client ) ; r Query ( NUM , q , slave Client ) ; assert Versions ( master Client , slave Client ) ; }
private byte [ ] decrypt ( byte [ ] d , int start , int end , int key , int skip ) { if ( end - start - skip < NUM ) { skip = NUM ; } byte [ ] o = new byte [ end - start - skip ] ; int r = key ; int ipos ; int c1 = NUM ; int c2 = NUM ; for ( ipos = start ; ipos < end ; ipos ++ ) { int c = d [ ipos ] & NUM ; int p = ( c ^ ( r > > NUM ) ) & NUM ; r = ( ( c + r ) * c1 + c2 ) & NUM ; if ( ipos - start - skip >= NUM ) { o [ ipos - start - skip ] = ( byte ) p ; } } return o ; }
public static void append Instruction ( OF Flow Mod . Builder fmb , OF Instruction inst ) { List < OF Instruction > new Il = new Array List < OF Instruction > ( ) ; List < OF Instruction > old Il = fmb . get Instructions ( ) ; if ( old Il != null ) { new Il . add All ( fmb . get Instructions ( ) ) ; } for ( OF Instruction i : new Il ) { if ( i . get Type ( ) == inst . get Type ( ) ) { new Il . remove ( i ) ; } } new Il . add ( inst ) ; fmb . set Instructions ( new Il ) ; }
@ Override public final void insert All ( DBI Ds ids ) { if ( ids . is Empty ( ) || ( ids . size ( ) == NUM ) ) { return ; } if ( can Bulk Load ( ) ) { List < Rd KNN Entry > leafs = new Array List < > ( ids . size ( ) ) ; for ( DBID Iter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { leafs . add ( create New Leaf Entry ( DBID Util . deref ( iter ) ) ) ; } bulk Load ( leafs ) ; } else { for ( DBID Iter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { insert ( iter ) ; } } do Extra Integrity Checks ( ) ; }
public void test Case 14 ( ) { byte r Bytes [ ] = { NUM } ; Big Integer a Number = Big Integer . ONE ; Big Integer b Number = Big Integer . ONE ; Big Integer result = a Number . divide ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public abstract int compare ( String source , String target ) ;
public static byte [ ] as Unsigned Byte Array ( Big Integer value ) { byte [ ] bytes = value . to Byte Array ( ) ; if ( bytes [ NUM ] == NUM ) { byte [ ] tmp = new byte [ bytes . length - NUM ] ; System . arraycopy ( bytes , NUM , tmp , NUM , tmp . length ) ; return tmp ; } return bytes ; }
public static boolean is Supplemental ( int c ) { return ( c >= NUM && c <= NUM ) ; }
private final String decode Short Unicode Name ( int len ) throws IO Exception { int out Ptr = NUM ; char [ ] out Buf = text Buffer . empty And Get Current Segment ( ) ; int in Ptr = input Ptr ; input Ptr += len ; final int [ ] codes = Smile Constants . s Utf 8 Unit Lengths ; final byte [ ] in Buf = input Buffer ; for ( int end = in Ptr + len ; in Ptr < end ; ) { int i = in Buf [ in Ptr ++ ] & NUM ; int code = codes [ i ] ; if ( code != NUM ) { switch ( code ) { case NUM : i = ( ( i & NUM ) << NUM ) | ( in Buf [ in Ptr ++ ] & NUM ) ; break ; case NUM : i = ( ( i & NUM ) << NUM ) | ( ( in Buf [ in Ptr ++ ] & NUM ) << NUM ) | ( in Buf [ in Ptr ++ ] & NUM ) ; break ; case NUM : i = ( ( i & NUM ) << NUM ) | ( ( in Buf [ in Ptr ++ ] & NUM ) << NUM ) | ( ( in Buf [ in Ptr ++ ] & NUM ) << NUM ) | ( in Buf [ in Ptr ++ ] & NUM ) ; i -= NUM ; out Buf [ out Ptr ++ ] = ( char ) ( NUM | ( i > > NUM ) ) ; i = NUM | ( i & NUM ) ; break ; default : report Error ( STRING + Integer . to Hex String ( i ) + STRING ) ; } } out Buf [ out Ptr ++ ] = ( char ) i ; } return text Buffer . set Current And Return ( out Ptr ) ; }
public void save Device Profile ( @ Nonnull String user , @ Nonnull String realm , @ Nonnull Push Device Settings device Settings ) throws Auth Login Exception { Reject . if Null ( user , realm , device Settings ) ; try { devices Dao . save Device Profiles ( user , realm , json Utils . to Json Values ( Collections . singleton List ( device Settings ) ) ) ; } catch ( IO Exception e ) { debug . error ( STRING , user , realm , e ) ; throw new Auth Login Exception ( e ) ; } }
public Ranking Image List Provider in Days ( int days ) { m Time = Integer . to String ( days ) + STRING ; return this ; }
public void remove Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners == null ) { return ; } m Update Listeners . remove ( listener ) ; if ( m Update Listeners . size ( ) == NUM ) { m Update Listeners = null ; } }
public final void db Unavailable ( final boolean alarm Up , final String exception Msg , final String db Info ) { if ( alarm Up == Fallback Alarms Interface . ACTIVATED ) { Array List recipients = new Array List ( ) ; Mail Details Bean mail Details = new Mail Details Bean ( ) ; mail Details . set Sender ( STRING ) ; recipients . add ( STRING ) ; mail Details . set To Recipients ( recipients ) ; mail Details . set Subject ( STRING ) ; mail Details . set Message ( STRING + db Info + STRING + exception Msg ) ; mail Details . set Server ( STRING ) ; SMTP Mail Sender mail Sender = new SMTP Mail Sender ( ) ; try { mail Sender . send Mail ( mail Details ) ; } catch ( Mail Sender Exception e ) { LOG . debug ( e . get Message ( ) ) ; } } }
public static String tidy String ( String string ) { if ( string . matches ( STRING ) ) { return string ; } else { return string . replace All ( STRING , STRING ) ; } }
public Select < T > sort Desc ( String ... columns ) { for ( String column : columns ) { m Sorting Order List . add ( column + STRING ) ; } return this ; }
public String to String ( ) { String Builder result = new String Builder ( ) ; result . append ( STRING ) ; result . append ( klazz . get Name ( ) ) ; result . append ( STRING ) ; for ( int i = NUM ; i < elements . length ; ++ i ) { if ( i != NUM ) { result . append ( STRING ) ; } result . append ( elements [ i ] ) ; } result . append ( STRING ) ; return result . to String ( ) ; }
public void test Ulp Neg ( ) { String a = STRING ; int a Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal result = a Number . ulp ( ) ; String res = STRING ; int res Scale = NUM ; assert Equals ( STRING , res , result . to String ( ) ) ; assert Equals ( STRING , res Scale , result . scale ( ) ) ; }
public Log Record ( Level level , String msg ) { level . get Class ( ) ; this . level = level ; message = msg ; sequence Number = global Sequence Number . get And Increment ( ) ; thread ID = default Thread ID ( ) ; millis = System . current Time Millis ( ) ; need To Infer Caller = BOOL ; }
public Matrix correlation ( ) { final Matrix corr = covariance ( ) ; final Array v = corr . diagonal ( ) ; for ( int i = NUM ; i < dimension ; i ++ ) { for ( int j = NUM ; j < dimension ; j ++ ) { if ( i == j ) { if ( v . $ [ v . ( i ) ] == NUM ) { corr . $ [ corr . ( i , j ) ] = NUM ; } else { corr . $ [ corr . ( i , j ) ] *= NUM / Math . sqrt ( v . $ [ v . ( i ) ] * v . $ [ v . ( j ) ] ) ; } } else { if ( v . $ [ v . ( i ) ] == NUM && v . $ [ v . ( j ) ] == NUM ) { corr . $ [ corr . ( i , j ) ] = NUM ; } else if ( v . $ [ v . ( i ) ] == NUM || v . $ [ v . ( j ) ] == NUM ) { corr . $ [ corr . ( i , j ) ] = NUM ; } else { corr . $ [ corr . ( i , j ) ] *= NUM / Math . sqrt ( v . $ [ v . ( i ) ] * v . $ [ v . ( j ) ] ) ; } } } } return corr ; }
@ Not Null public static Save Directory from ( File file ) throws File Not Found Exception { File current File = file ; Save Directory result = null ; if ( current File == null ) { } else { result = create Valid Save Directory ( current File ) ; current File = current File . get Parent File ( ) ; if ( result != null ) { return result ; } else if ( current File == null ) { } else { result = create Valid Save Directory ( current File ) ; current File = current File . get Parent File ( ) ; if ( result != null ) { return result ; } else { } } } throw new File Not Found Exception ( STRING + file ) ; }
public Serializer serializer ( ) { return serializer ; }
private void add Included Resources ( Json Api Document json Api Document , Persistent Resource rec , List < String > requested Relation Paths ) { requested Relation Paths . for Each ( null ) ; }
protected Video DTO extract One Video From Cursor ( Cursor cursor ) { if ( video Id Col == - NUM ) { video Id Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . ID ) ; video Title Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . TITLE ) ; video Display Name Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . DISPLAY NAME ) ; video Description Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . DESCRIPTION ) ; video Bucket Id Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . BUCKET ID ) ; video Bucket Display Name Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . BUCKET DISPLAY NAME ) ; video Data Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . DATA ) ; video Mime Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . MIME TYPE ) ; video Resolution Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . RESOLUTION ) ; video Size Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . SIZE ) ; video Date Added Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . DATE ADDED ) ; video Date Taken Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . DATE TAKEN ) ; video Date Modify Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . DATE MODIFIED ) ; video Latitude Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . LATITUDE ) ; video Longitude Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . LONGITUDE ) ; video Album Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . ALBUM ) ; video Artist Col = cursor . get Column Index Or Throw ( Media Store . Video . Media . ARTIST ) ; } Video DTO video = new Video DTO ( ) ; video . set Id ( cursor . get Long ( video Id Col ) ) ; video . set Title ( cursor . get String ( video Title Col ) ) ; video . set Display Name ( cursor . get String ( video Display Name Col ) ) ; video . set Description ( cursor . get String ( video Description Col ) ) ; video . set Bucket Id ( cursor . get String ( video Bucket Id Col ) ) ; video . set Bucket Display Name ( cursor . get String ( video Bucket Display Name Col ) ) ; video . set Uri ( cursor . get String ( video Data Col ) ) ; video . set Mime Type ( cursor . get String ( video Mime Col ) ) ; video . set Size ( cursor . get Long ( video Size Col ) ) ; video . set Added Date ( new Date ( cursor . get Long ( video Date Added Col ) ) ) ; video . set Taken Date ( new Date ( cursor . get Long ( video Date Taken Col ) ) ) ; video . set Modify Date ( new Date ( cursor . get Long ( video Date Modify Col ) ) ) ; video . set Latitude ( cursor . get Double ( video Latitude Col ) ) ; video . set Longitude ( cursor . get Double ( video Longitude Col ) ) ; video . set Album ( cursor . get String ( video Album Col ) ) ; video . set Artist ( cursor . get String ( video Artist Col ) ) ; String resolution = cursor . get String ( video Resolution Col ) ; if ( resolution != null ) { try { String [ ] res = resolution . split ( STRING ) ; int width = Integer . parse Int ( res [ NUM ] ) ; int height = Integer . parse Int ( res [ NUM ] ) ; video . set Width ( width ) ; video . set Height ( height ) ; } catch ( Exception e ) { Log . w ( TAG , String . format ( STRING , video . get Id ( ) , video . get Title ( ) , video . get Display Name ( ) ) , e ) ; } } return video ; }
private void shift Segments ( int from Idx , int offset ) { for ( Element element : elements ) { if ( element . end . left > from Idx ) { shift Segment ( element . start , from Idx , offset ) ; shift Segment ( element . end , from Idx , offset ) ; if ( element . text != null ) { for ( Segment text Segment : element . text ) { shift Segment ( text Segment , from Idx , offset ) ; } } } } }
public Ref Update . Result modify File ( Change Edit edit , String file , Raw Input content ) throws Auth Exception , Invalid Change Operation Exception , IO Exception { return modify ( Tree Operation . CHANGE ENTRY , edit , file , null , content ) ; }
private void start Document ( final boolean multi Object Mode ) throws SAX Exception { if ( depth == NUM ) { content Handler . start Document ( ) ; if ( multi Object Mode ) { depth ++ ; } } }
public void flush ( ) throws IO Exception { writer . flush ( ) ; }
private static Array List < Grid Collision Job Context Wrapper > slice ( Collection < Collision Job Context > src , int num ) { Array List < Grid Collision Job Context Wrapper > slice = new Array List < > ( ) ; Iterator < Collision Job Context > iter = src . iterator ( ) ; for ( int i = NUM ; i < num && iter . has Next ( ) ; i ++ ) slice . add ( new Grid Collision Job Context Wrapper ( iter . next ( ) , i ) ) ; return slice ; }
protected void calculate Formatter ( float min , float max ) { float reference = NUM ; if ( m Data == null || m Data . get X Val Count ( ) < NUM ) { reference = Math . max ( Math . abs ( min ) , Math . abs ( max ) ) ; } else { reference = Math . abs ( max - min ) ; } int digits = Utils . get Decimals ( reference ) ; m Default Formatter = new Default Value Formatter ( digits ) ; }
public Request add ( Request request ) { request . set Request Queue ( this ) ; synchronized ( m Current Requests ) { m Current Requests . add ( request ) ; } request . set Sequence ( get Sequence Number ( ) ) ; request . add Marker ( STRING ) ; if ( ! request . should Cache ( ) ) { m Network Queue . add ( request ) ; return request ; } synchronized ( m Waiting Requests ) { String cache Key = request . get Cache Key ( ) ; if ( m Waiting Requests . contains Key ( cache Key ) ) { Queue < Request > staged Requests = m Waiting Requests . get ( cache Key ) ; if ( staged Requests == null ) { staged Requests = new Linked List < Request > ( ) ; } staged Requests . add ( request ) ; m Waiting Requests . put ( cache Key , staged Requests ) ; if ( Volley Log . DEBUG ) { Volley Log . v ( STRING , cache Key ) ; } } else { m Waiting Requests . put ( cache Key , null ) ; m Cache Queue . add ( request ) ; } return request ; } }
public String lookup ( String data ) { Iterator < String > it = map . get Prefixed By ( data ) ; if ( ! it . has Next ( ) ) return null ; return it . next ( ) ; }
public static Object load Module ( String homedir , Script Engine engine , String name ) throws File Not Found Exception , Script Exception { Hash Map < String , File > mp = ( Hash Map < String , File > ) engine . get ( STRING ) ; Object ret = load ( mp . get ( name ) , engine ) ; return ret ; }
@ Override public void modify Variable Id ( String node Id , String new Id ) { Map < Assignment , Utility Estimate > utilities 2 = new Hash Map < Assignment , Utility Estimate > ( ) ; for ( Assignment a : table . key Set ( ) ) { Assignment b = new Assignment ( ) ; for ( String var : a . get Variables ( ) ) { String new Var = ( var . equals ( node Id ) ) ? new Id : var ; b . add Pair ( new Var , a . get Value ( var ) ) ; } utilities 2 . put ( b , table . get ( a ) ) ; } table = utilities 2 ; }
public static long [ ] truncate I ( long [ ] v , int len ) { final int zap = ( v . length * Long . SIZE ) - len ; final int zap Words = ( zap > > > LONG LOG 2 SIZE ) ; final int zapbits = zap & LONG LOG 2 MASK ; Arrays . fill ( v , v . length - zap Words , v . length , NUM ) ; if ( zapbits > NUM ) { v [ v . length - zap Words - NUM ] &= ( LONG ALL BITS > > > zapbits ) ; } return v ; }
public void test no Resources Does Not Wait predeclare Locks synchronous Queue ( ) throws Exception { final Properties properties = new Properties ( ) ; final int ntasks = NUM ; final int core Pool Size = NUM ; final int max Pool Size = ntasks ; properties . set Property ( Test Options . SYNCHRONOUS QUEUE , STRING ) ; properties . set Property ( Test Options . CORE POOL SIZE , STRING + core Pool Size ) ; properties . set Property ( Test Options . MAX POOL SIZE , STRING + max Pool Size ) ; properties . set Property ( Test Options . NTASKS , STRING + ntasks ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; final Result result = do Comparison Test ( properties ) ; assert Equals ( STRING , ntasks , Integer . parse Int ( result . get ( STRING ) ) ) ; final int maxrunning = Integer . parse Int ( result . get ( STRING ) ) ; assert True ( STRING + maxrunning , core Pool Size <= maxrunning ) ; }
private void position At Central Directory ( ) throws IO Exception { boolean found = BOOL ; long off = archive . length ( ) - MIN EOCD SIZE ; if ( off >= NUM ) { archive . seek ( off ) ; byte [ ] sig = JB Zip Output Stream . EOCD SIG ; int curr = archive . read ( ) ; while ( curr != - NUM ) { if ( curr == sig [ POS 0 ] ) { curr = archive . read ( ) ; if ( curr == sig [ POS 1 ] ) { curr = archive . read ( ) ; if ( curr == sig [ POS 2 ] ) { curr = archive . read ( ) ; if ( curr == sig [ POS 3 ] ) { found = BOOL ; break ; } } } } archive . seek ( -- off ) ; curr = archive . read ( ) ; } } if ( ! found ) { throw new Zip Exception ( STRING ) ; } archive . seek ( off + CFD LOCATOR OFFSET ) ; byte [ ] cfd Offset = new byte [ WORD ] ; archive . read Fully ( cfd Offset ) ; currentcfdfoffset = Zip Long . get Value ( cfd Offset ) ; archive . seek ( currentcfdfoffset ) ; }
public List query ( double x1 , double x2 ) { return super . query ( new Interval ( Math . min ( x1 , x2 ) , Math . max ( x1 , x2 ) ) ) ; }
public static boolean is Null ( Object object ) { return object != null && object == NULL CACHE . get ( object . get Class ( ) ) ; }
public static void create Destination Folder ( String path ) { File fpath = new File ( path ) ; fpath . mkdirs ( ) ; }
public void remove All ( ) { log . debug ( STRING + connection To Added . size ( ) ) ; connection To Added . clear ( ) ; }
public float read Float ( ) throws IO Exception { return primitive Types . read Float ( ) ; }
public synchronized static int insert Lua State ( Lua State L ) { int i ; for ( i = NUM ; i < states . size ( ) ; i ++ ) { Lua State state = ( Lua State ) states . get ( i ) ; if ( state != null ) { if ( state . get C Ptr Peer ( ) == L . get C Ptr Peer ( ) ) return i ; } } i = get Next State Index ( ) ; states . set ( i , L ) ; return i ; }
public Phone Number Validator ( @ Non Null final Char Sequence error Message ) { super ( error Message , REGEX ) ; }
@ Override public int hash Code ( ) { return fully Qualified Name . hash Code ( ) ; }
public static void put String 2 bytes ( byte [ ] destbytes , String src String , int dest Offset , int src Offset , int count ) { for ( int i = NUM ; i < count ; i ++ ) { destbytes [ count + i ] = src String . get Bytes ( ) [ i ] ; } }
public Point 2 D convert Window To Reference ( Point 2 D apt ) { if ( scroll Back Reference Rect == null ) return null ; else return new Point 2 D . Double ( ( apt . get X ( ) - scroll Back Reference Rect . get X ( ) ) / scroll Back Reference Rect . get Width ( ) , ( apt . get Y ( ) - scroll Back Reference Rect . get Y ( ) ) / scroll Back Reference Rect . get Height ( ) ) ; }
public void clear ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { for ( Tenant Queue q : qs . values ( ) ) { q . clear ( ) ; } } finally { lock . unlock ( ) ; } }
public void print Usage ( Print Writer pw , int width , String cmd Line Syntax ) { int arg Pos = cmd Line Syntax . index Of ( STRING ) + NUM ; print Wrapped ( pw , width , default Syntax Prefix . length ( ) + arg Pos , default Syntax Prefix + cmd Line Syntax ) ; }
public boolean has Name Value ( String name ) { return name Value Map . contains Key ( name . to Lower Case ( ) ) ; }
private void add New Line ( ) { if ( add Line Dialog == null ) { add Line Dialog = new Add Parallel Line Dialog ( ) ; } add Line Dialog . set Chart Engine ( engine ) ; add Line Dialog . show Dialog ( ) ; if ( horizontal Line Radiobutton . is Selected ( ) ) { set Horizontal Line Selected ( ) ; } else if ( vertical Line Radiobutton . is Selected ( ) ) { set Vertical Line Selected ( ) ; } }
public final static < T > Completable Future < List < T > > stream To Completable Future ( final Stream < T > stream ) { return Completable Future . completed Future ( stream . collect ( Cyclops Collectors . to List X ( ) ) ) ; }
@ Suppress Warnings ( STRING ) public static boolean is Gzip Supported ( final Http Servlet Request request ) { if ( request != null ) { final Enumeration < String > header Names = request . get Header Names ( ) ; if ( header Names != null ) { while ( header Names . has More Elements ( ) ) { final String header Name = header Names . next Element ( ) ; final Matcher m = PATTERN ACCEPT ENCODING . matcher ( header Name ) ; if ( m . find ( ) ) { final String header Value = request . get Header ( header Name ) ; final Matcher m Value = PATTERN GZIP . matcher ( header Value ) ; return m Value . find ( ) ; } } } } return BOOL ; }
private boolean is Language Allowed ( String language Key ) { if ( allowed Languages == null ) return BOOL ; return allowed Languages . contains ( language Key ) ; }
public List < Boundary > populate Ward ( final Long zone Id ) { List < Boundary > ward List = new Linked List < Boundary > ( ) ; try { ward List = boundary Service . get Child Boundaries By Boundary Id ( zone Id ) ; } catch ( final Exception e ) { LOGGER . error ( STRING + e . get Message ( ) ) ; throw new Application Runtime Exception ( STRING , e ) ; } return ward List ; }
static Object new Instance ( String class Name , Class Loader cl , boolean do Fallback ) throws Configuration Error { try { Class provider Class = find Provider Class ( class Name , cl , do Fallback ) ; Object instance = provider Class . new Instance ( ) ; debug Println ( STRING + provider Class + STRING + cl ) ; return instance ; } catch ( Class Not Found Exception x ) { throw new Configuration Error ( STRING + class Name + STRING , x ) ; } catch ( Exception x ) { throw new Configuration Error ( STRING + class Name + STRING + x , x ) ; } }
public void handle Request ( List arguments ) { try { Install Logger migrate Log = new Install Logger ( STR MIGRATE ) ; Multiple Migrate Driver driver = new Multiple Migrate Driver ( ) ; if ( arguments . is Empty ( ) ) { Debug . log ( STRING ) ; driver . migrate ( migrate Log ) ; } else if ( arguments . size ( ) == NUM ) { Debug . log ( STRING ) ; driver . migrate ( migrate Log ) ; } } catch ( Install Abort Exception ia ) { Debug . log ( STRING , ia ) ; Console . println Raw Text ( ia . get Message ( ) ) ; } catch ( Install Exception ex ) { Debug . log ( STRING , ex ) ; print Console Message ( LOC HR ERR MIGRATE , new Object [ ] { ex . get Message ( ) } ) ; } }
@ Override public String to String ( ) { String Buffer result = new String Buffer ( ) ; for ( int i = NUM ; i < data . length ; i ++ ) { result . append ( ( i == NUM ? STRING : STRING ) + data [ i ] ) ; } return result . to String ( ) ; }
public static Synchronizer Status make Running Status ( ) { return new Synchronizer Status ( Status . RUNNING , new Date ( ) , null ) ; }
public static Iterable < File > apply Cwd ( File cwd , Iterable < File > files ) { if ( files != null ) { List < File > result = new Array List < File > ( ) ; for ( File f : files ) { result . add ( apply Cwd ( cwd , f ) ) ; } return result ; } else { return null ; } }
private void close ( boolean force ) { if ( close Guard . compare And Set ( BOOL , BOOL ) ) hadoop . close ( force ) ; }
Mutable Big Integer divide Knuth ( Mutable Big Integer b , Mutable Big Integer quotient , boolean need Remainder ) { if ( b . int Len == NUM ) throw new Arithmetic Exception ( STRING ) ; if ( int Len == NUM ) { quotient . int Len = quotient . offset = NUM ; return need Remainder ? new Mutable Big Integer ( ) : null ; } int cmp = compare ( b ) ; if ( cmp < NUM ) { quotient . int Len = quotient . offset = NUM ; return need Remainder ? new Mutable Big Integer ( this ) : null ; } if ( cmp == NUM ) { quotient . value [ NUM ] = quotient . int Len = NUM ; quotient . offset = NUM ; return need Remainder ? new Mutable Big Integer ( ) : null ; } quotient . clear ( ) ; if ( b . int Len == NUM ) { int r = divide One Word ( b . value [ b . offset ] , quotient ) ; if ( need Remainder ) { if ( r == NUM ) return new Mutable Big Integer ( ) ; return new Mutable Big Integer ( r ) ; } else { return null ; } } if ( int Len >= KNUTH POW 2 THRESH LEN ) { int trailing Zero Bits = Math . min ( get Lowest Set Bit ( ) , b . get Lowest Set Bit ( ) ) ; if ( trailing Zero Bits >= KNUTH POW 2 THRESH ZEROS * NUM ) { Mutable Big Integer a = new Mutable Big Integer ( this ) ; b = new Mutable Big Integer ( b ) ; a . right Shift ( trailing Zero Bits ) ; b . right Shift ( trailing Zero Bits ) ; Mutable Big Integer r = a . divide Knuth ( b , quotient ) ; r . left Shift ( trailing Zero Bits ) ; return r ; } } return divide Magnitude ( b , quotient , need Remainder ) ; }
public static Cache . Entry make Random Cache Entry ( byte [ ] data , boolean is Expired , boolean needs Refresh ) { Random random = new Random ( ) ; Cache . Entry entry = new Cache . Entry ( ) ; if ( data != null ) { entry . data = data ; } else { entry . data = new byte [ random . next Int ( NUM ) ] ; } entry . etag = String . value Of ( random . next Long ( ) ) ; entry . last Modified = random . next Long ( ) ; entry . ttl = is Expired ? NUM : Long . MAX VALUE ; entry . soft Ttl = needs Refresh ? NUM : Long . MAX VALUE ; return entry ; }
@ Suppress Warnings ( STRING ) public void insert ( int id , Comparable < E > priority ) { int i ; i = ++ n ; Element H p = new Element H ( ) ; while ( i > NUM ) { int p Idx = i / NUM ; Element H e Idx = ( Element H ) elements [ p Idx ] ; p . id = e Idx . id ; p . priority = e Idx . priority ; if ( priority . compare To ( ( E ) p . priority ) > NUM ) { break ; } Element H ei = ( Element H ) elements [ i ] ; ei . id = p . id ; ei . priority = p . priority ; pos [ p . id ] = i ; i = p Idx ; } Element H ei = ( Element H ) elements [ i ] ; ei . id = id ; ei . priority = priority ; pos [ id ] = i ; }
External Problem ( Socket socket ) throws IO Exception { this ( socket . get Input Stream ( ) , socket . get Output Stream ( ) ) ; }
private static void stop GC ( ) { gc Should Loop = BOOL ; synchronized ( LOCK ) { LOCK . notify ( ) ; } }
public final void insert Element At ( int value , int at ) { if ( ( m first Free + NUM ) >= m map Size ) { m map Size += m blocksize ; int new Map [ ] = new int [ m map Size ] ; System . arraycopy ( m map , NUM , new Map , NUM , m first Free + NUM ) ; m map = new Map ; } if ( at <= ( m first Free - NUM ) ) { System . arraycopy ( m map , at , m map , at + NUM , m first Free - at ) ; } m map [ at ] = value ; m first Free ++ ; }
public static @ Nullable Request Body create Gzip ( final Media Type media Type , final String body ) { Byte Array Output Stream gzip Byte Array Output Stream = new Byte Array Output Stream ( ) ; try { Output Stream gzip Output Stream = new GZIP Output Stream ( gzip Byte Array Output Stream ) ; gzip Output Stream . write ( body . get Bytes ( ) ) ; gzip Output Stream . close ( ) ; } catch ( IO Exception e ) { return null ; } return Request Body . create ( media Type , gzip Byte Array Output Stream . to Byte Array ( ) ) ; }
private void process TSBK ( TSBK Message tsbk ) { broadcast ( new Decoder State Event ( this , Event . CONTINUATION , State . CONTROL ) ) ; if ( tsbk . get Vendor ( ) == Vendor . STANDARD ) { switch ( tsbk . get Opcode ( ) ) { case ADJACENT STATUS BROADCAST : if ( tsbk instanceof Adjacent Status Broadcast ) { I Adjacent Site ias = ( I Adjacent Site ) tsbk ; m Neighbor Map . put ( ias . get Unique ID ( ) , ias ) ; update System ( ias . get System ID ( ) ) ; } break ; case ACKNOWLEDGE RESPONSE : process TSBK Response ( tsbk ) ; break ; case AUTHENTICATION COMMAND : process TSBK Command ( tsbk ) ; break ; case CALL ALERT : process TSBK Page ( tsbk ) ; break ; case DENY RESPONSE : process TSBK Response ( tsbk ) ; break ; case EXTENDED FUNCTION COMMAND : process TSBK Command ( tsbk ) ; break ; case GROUP AFFILIATION QUERY : process TSBK Query ( tsbk ) ; break ; case GROUP AFFILIATION RESPONSE : process TSBK Response ( tsbk ) ; break ; case GROUP DATA CHANNEL ANNOUNCEMENT : case GROUP DATA CHANNEL ANNOUNCEMENT EXPLICIT : process TSBK Data Channel Announcement ( tsbk ) ; break ; case GROUP DATA CHANNEL GRANT : case GROUP VOICE CHANNEL GRANT : case GROUP VOICE CHANNEL GRANT UPDATE : case GROUP VOICE CHANNEL GRANT UPDATE EXPLICIT : case INDIVIDUAL DATA CHANNEL GRANT : case TELEPHONE INTERCONNECT VOICE CHANNEL GRANT : case TELEPHONE INTERCONNECT VOICE CHANNEL GRANT UPDATE : case UNIT TO UNIT VOICE CHANNEL GRANT : case UNIT TO UNIT VOICE CHANNEL GRANT UPDATE : process TSBK Channel Grant ( tsbk ) ; break ; case IDENTIFIER UPDATE NON VUHF : case IDENTIFIER UPDATE VHF UHF BANDS : Identifier Update iu = ( Identifier Update ) tsbk ; if ( ! m Bands . contains Key ( iu . get Identifier ( ) ) ) { m Bands . put ( iu . get Identifier ( ) , iu ) ; } break ; case LOCATION REGISTRATION RESPONSE : case UNIT DEREGISTRATION ACKNOWLEDGE : process TSBK Response ( tsbk ) ; break ; case MESSAGE UPDATE : process TSBK Message ( tsbk ) ; break ; case NETWORK STATUS BROADCAST : m Network Status = ( module . decode . p25 . message . tsbk . osp . control . Network Status Broadcast ) tsbk ; break ; case PROTECTION PARAMETER UPDATE : process TSBK Response ( tsbk ) ; break ; case QUEUED RESPONSE : process TSBK Response ( tsbk ) ; break ; case RADIO UNIT MONITOR COMMAND : process TSBK Command ( tsbk ) ; break ; case RFSS STATUS BROADCAST : process TSBKRFSS Status ( ( RFSS Status Broadcast ) tsbk ) ; break ; case ROAMING ADDRESS COMMAND : process TSBK Command ( tsbk ) ; break ; case SECONDARY CONTROL CHANNEL BROADCAST : module . decode . p25 . message . tsbk . osp . control . Secondary Control Channel Broadcast sccb = ( module . decode . p25 . message . tsbk . osp . control . Secondary Control Channel Broadcast ) tsbk ; if ( sccb . get Downlink Frequency 1 ( ) > NUM ) { m Secondary Control Channels . add ( sccb ) ; } break ; case SNDCP DATA CHANNEL ANNOUNCEMENT EXPLICIT : mSNDCP Data Channel = ( SNDCP Data Channel Announcement Explicit ) tsbk ; break ; case SNDCP DATA CHANNEL GRANT : process TSBK Channel Grant ( tsbk ) ; break ; case STATUS QUERY : process TSBK Query ( tsbk ) ; break ; case STATUS UPDATE : process TSBK Response ( tsbk ) ; break ; case TELEPHONE INTERCONNECT ANSWER REQUEST : case UNIT TO UNIT ANSWER REQUEST : process TSBK Page ( tsbk ) ; break ; case UNIT REGISTRATION COMMAND : process TSBK Command ( tsbk ) ; break ; case UNIT REGISTRATION RESPONSE : process TSBK Response ( tsbk ) ; break ; default : break ; } } else if ( tsbk . get Vendor ( ) == Vendor . MOTOROLA ) { process Motorola TSBK ( ( Motorola TSBK Message ) tsbk ) ; } }
public Xintro Activity Builder remove Fragment ( int fragment Pos ) { intro Fragment Model List . remove ( fragment Pos ) ; return this ; }
public boolean update ( ) { return update ; }
public Tree Viewer Builder ( Composite parent , int style ) { mappings = Collections . empty Map ( ) ; checkable = ( style & SWT . CHECK ) == SWT . CHECK ; if ( checkable ) { viewer = new Checkbox Tree Viewer ( parent , style ) ; } else { viewer = new Tree Viewer ( parent , style ) ; } Column Viewer Tool Tip Support . enable For ( viewer , Tool Tip . NO RECREATE ) ; }
@ Override public void write ( byte [ ] buffer , int offset , int count ) throws IO Exception { synchronized ( int Thread ) { int avail = ( wrote Index - data End Index + data . length ) % data . length ; if ( avail == NUM ) avail = data . length ; if ( avail < count ) { throw new IO Exception ( STRING + avail + STRING + count ) ; } if ( count > data . length - data End Index ) { int first Part = data . length - data End Index ; int second Part = count - first Part ; System . arraycopy ( buffer , offset , data , data End Index , first Part ) ; System . arraycopy ( buffer , offset + first Part , data , NUM , second Part ) ; data End Index = second Part ; } else { System . arraycopy ( buffer , offset , data , data End Index , count ) ; data End Index += count ; } int Thread . notify ( ) ; } }
public void pause ( ) { pause Lock . lock ( ) ; try { paused = BOOL ; } finally { pause Lock . unlock ( ) ; } }
public void add To Consolitated Msg ( final String message ) { if ( consolidated Message != null && consolidated Message . length ( ) > NUM ) { consolidated Message = consolidated Message + STRING ; } consolidated Message = consolidated Message + message ; }
private static byte [ ] read Class ( final Input Stream is , boolean close ) throws IO Exception { if ( is == null ) { throw new IO Exception ( STRING ) ; } try { byte [ ] b = new byte [ is . available ( ) ] ; int len = NUM ; while ( BOOL ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - NUM ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; System . arraycopy ( b , NUM , c , NUM , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < NUM ) { return b ; } byte [ ] c = new byte [ b . length + NUM ] ; System . arraycopy ( b , NUM , c , NUM , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } } finally { if ( close ) { is . close ( ) ; } } }
public void sort ( final Comparator < ? super T > comparator ) { synchronized ( m Lock ) { Collections . sort ( m List , comparator ) ; } notify Data Set Changed ( ) ; }
public String crop Keep Final Character ( String string , char final Char ) { String cropped = crop ( string ) ; if ( ( null == string ) || string . equals ( cropped ) ) { return string ; } if ( cropped . length ( ) == NUM ) { return cropped ; } return cropped + final Char ; }
public static boolean is Derived Adjective ( final String word ) { if ( word . length ( ) > NUM ) { if ( word . ends With ( STRING ) || word . ends With ( STRING ) ) return BOOL ; if ( word . ends With ( STRING ) ) return BOOL ; } return BOOL ; }
String rename File ( String input Filename ) { for ( Pattern search Exp : regex Mappings . key Set ( ) ) { Matcher matcher = search Exp . matcher ( input Filename ) ; if ( matcher . find ( ) ) { String renamed = matcher . replace First ( regex Mappings . get ( search Exp ) ) ; return FILE SEP CHAR MATCHER . trim Leading From ( renamed ) ; } } throw new Moe Problem ( STRING + STRING , input Filename ) ; }
private static int validate Adb Server Port ( @ Non Null String adb Server Port ) throws Illegal Argument Exception { try { int port = Integer . decode ( adb Server Port ) ; if ( port <= NUM || port >= NUM ) { throw new Illegal Argument Exception ( STRING ) ; } return port ; } catch ( Number Format Exception e ) { throw new Illegal Argument Exception ( STRING ) ; } }
public static String format Elapsed ( Timestamp start ) { if ( start == null ) return STRING ; long start Time = start . get Time ( ) ; long end Time = System . current Time Millis ( ) ; return format Elapsed ( end Time - start Time ) ; }
@ Override public void stop ( ) { for ( Thread thread : threads ) { thread . interrupt ( ) ; } try { for ( Thread thread : threads ) { thread . join ( ) ; } } catch ( Interrupted Exception e ) { } }
private boolean verify Published Dual Inet Address ( String node Id ) { Dual Inet Address dual Address = null ; Configuration config = query Configuration ( Constants . NODE DUALINETADDR CONFIG , node Id ) ; if ( config != null ) { dual Address = parse Inet Address Config ( config ) ; } if ( ( dual Address != null ) && dual Address . equals ( inet Address Lookup Map . get Dual Inet Address ( ) ) ) { return BOOL ; } return BOOL ; }
public void test Recursive Chains ( ) throws Throwable { for ( Execution Mode m : Execution Mode . values ( ) ) for ( boolean add Dead Ends : new boolean [ ] { BOOL , BOOL } ) { final int val = NUM ; final int n = expensive Tests ? NUM : NUM ; Completable Future < Integer > head = new Completable Future < > ( ) ; Completable Future < Integer > tail = head ; for ( int i = NUM ; i < n ; i ++ ) { if ( add Dead Ends ) m . then Apply ( tail , null ) ; tail = m . then Apply ( tail , null ) ; if ( add Dead Ends ) m . apply To Either ( tail , tail , null ) ; tail = m . apply To Either ( tail , tail , null ) ; if ( add Dead Ends ) m . then Combine ( tail , tail , null ) ; tail = m . then Combine ( tail , tail , null ) ; } head . complete ( val ) ; assert Equals ( val + NUM * n , ( int ) tail . join ( ) ) ; } }
public boolean response Is String ( String oid ) { return string Responses . contains ( oid ) ; }
private static int type ( final Class Writer cw , final String desc ) { String t ; int index = desc . char At ( NUM ) == STRING ? desc . index Of ( STRING ) + NUM : NUM ; switch ( desc . char At ( index ) ) { case STRING : return NUM ; case STRING : case STRING : case STRING : case STRING : case STRING : return INTEGER ; case STRING : return FLOAT ; case STRING : return LONG ; case STRING : return DOUBLE ; case STRING : t = desc . substring ( index + NUM , desc . length ( ) - NUM ) ; return OBJECT | cw . add Type ( t ) ; default : int data ; int dims = index + NUM ; while ( desc . char At ( dims ) == STRING ) { ++ dims ; } switch ( desc . char At ( dims ) ) { case STRING : data = BOOLEAN ; break ; case STRING : data = CHAR ; break ; case STRING : data = BYTE ; break ; case STRING : data = SHORT ; break ; case STRING : data = INTEGER ; break ; case STRING : data = FLOAT ; break ; case STRING : data = LONG ; break ; case STRING : data = DOUBLE ; break ; default : t = desc . substring ( dims + NUM , desc . length ( ) - NUM ) ; data = OBJECT | cw . add Type ( t ) ; } return ( dims - index ) << NUM | data ; } }
public void log Fine ( String message ) { logger . fine ( log Prefix + message ) ; }
public static Optional < String > create Input Dialog ( final Window owner , final String title , final String label ) { final Text Input Dialog dialog = new Text Input Dialog ( ) ; dialog . set Title ( title ) ; dialog . set Header Text ( null ) ; dialog . set Content Text ( label ) ; dialog . init Owner ( owner ) ; return dialog . show And Wait ( ) ; }
public static void close Output Stream ( Output Stream stream , String tag ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( IO Exception e ) { Log . e ( tag , STRING + e ) ; } } }
private static String encode ( final String text ) throws Unsupported Encoding Exception { return URL Encoder . encode ( text , STRING ) ; }
public static String convert To RGB ( int color ) { String red = Integer . to Hex String ( Color . red ( color ) ) ; String green = Integer . to Hex String ( Color . green ( color ) ) ; String blue = Integer . to Hex String ( Color . blue ( color ) ) ; if ( red . length ( ) == NUM ) { red = STRING + red ; } if ( green . length ( ) == NUM ) { green = STRING + green ; } if ( blue . length ( ) == NUM ) { blue = STRING + blue ; } return STRING + red + green + blue ; }
private static final void append Encoded Byte ( String Buffer buffer , byte value , byte [ ] state ) { if ( state [ NUM ] != NUM ) { char c = ( char ) ( ( state [ NUM ] << NUM ) | ( ( ( int ) value ) & NUM ) ) ; buffer . append ( c ) ; state [ NUM ] = NUM ; } else { state [ NUM ] = NUM ; state [ NUM ] = value ; } }
public Sided Plane ( double pX , double pY , double pZ , Vector v , double D ) { super ( v , D ) ; sig Num = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sig Num == NUM ) throw new Illegal Argument Exception ( STRING ) ; }
public String build Union Query ( String [ ] sub Queries , String sort Order , String limit ) { String Builder query = new String Builder ( NUM ) ; int sub Query Count = sub Queries . length ; String union Operator = m Distinct ? STRING : STRING ; for ( int i = NUM ; i < sub Query Count ; i ++ ) { if ( i > NUM ) { query . append ( union Operator ) ; } query . append ( sub Queries [ i ] ) ; } append Clause ( query , STRING , sort Order ) ; append Clause ( query , STRING , limit ) ; return query . to String ( ) ; }
@ Override public String to String ( ) { String Buffer sb = new String Buffer ( ) ; sb . append ( client Id ) ; sb . append ( STRING ) ; switch ( status ) { case CONNECTED : sb . append ( context . get String ( R . string . connectedto ) ) ; break ; case DISCONNECTED : sb . append ( context . get String ( R . string . disconnected ) ) ; break ; case NONE : sb . append ( context . get String ( R . string . no status ) ) ; break ; case CONNECTING : sb . append ( context . get String ( R . string . connecting ) ) ; break ; case DISCONNECTING : sb . append ( context . get String ( R . string . disconnecting ) ) ; break ; case ERROR : sb . append ( context . get String ( R . string . connection Error ) ) ; } sb . append ( STRING ) ; sb . append ( host ) ; return sb . to String ( ) ; }
void register Callback ( Bluetooth Callback callback ) { synchronized ( m Callbacks ) { m Callbacks . add ( callback ) ; } }
private void validate Table Meta Data No Row ( String table Name Pattern , String [ ] types ) throws Exception { try ( Result Set tables = dbmd . get Tables ( null , null , table Name Pattern , types ) ) { assert False ( String . format ( STRING , table Name Pattern , Arrays . to String ( types ) ) , tables . next ( ) ) ; } }
void check Class Bounds ( Diagnostic Position pos , Type type ) { check Class Bounds ( pos , new Hash Map < Type Symbol , Type > ( ) , type ) ; }
private static String parse Token ( String pattern , int [ ] index Ref ) { String Buffer buf = new String Buffer ( ) ; int i = index Ref [ NUM ] ; int length = pattern . length ( ) ; char c = pattern . char At ( i ) ; if ( c >= STRING && c <= STRING || c >= STRING && c <= STRING ) { buf . append ( c ) ; while ( i + NUM < length ) { char peek = pattern . char At ( i + NUM ) ; if ( peek == c ) { buf . append ( c ) ; i ++ ; } else { break ; } } } else { buf . append ( STRING ) ; boolean in Literal = BOOL ; for ( ; i < length ; i ++ ) { c = pattern . char At ( i ) ; if ( c == STRING ) { if ( i + NUM < length && pattern . char At ( i + NUM ) == STRING ) { i ++ ; buf . append ( c ) ; } else { in Literal = ! in Literal ; } } else if ( ! in Literal && ( c >= STRING && c <= STRING || c >= STRING && c <= STRING ) ) { i -- ; break ; } else { buf . append ( c ) ; } } } index Ref [ NUM ] = i ; return buf . to String ( ) ; }
public int alloc ( final RW Store store , final int size , final I Allocation Context context ) { try { if ( size <= NUM ) throw new Illegal Argument Exception ( STRING + size ) ; if ( size > m size ) throw new Illegal Argument Exception ( STRING + m size + STRING + size + STRING ) ; if ( m free Bits == NUM ) { throw new Illegal State Exception ( STRING + m size + STRING ) ; } int addr = - NUM ; if ( m size <= m store . c Small Slot ) { return alloc From Index ( size ) ; } final Iterator < Alloc Block > iter = m alloc Blocks . iterator ( ) ; int count = - NUM ; while ( addr == - NUM && iter . has Next ( ) ) { count ++ ; final Alloc Block block = iter . next ( ) ; check Block ( block ) ; addr = block . alloc ( m size ) ; } if ( addr != - NUM ) { addr += NUM ; if ( -- m free Bits == NUM ) { if ( s islog Trace ) log . trace ( STRING ) ; remove From Free List ( ) ; if ( m free List . size ( ) > NUM ) { if ( s islog Debug ) { final Fixed Allocator nxt = ( Fixed Allocator ) m free List . get ( NUM ) ; log . debug ( STRING + nxt . get Summary Stats ( ) ) ; } } } addr += ( count * NUM * m bit Size ) ; final int value = - ( ( m index << RW Store . OFFSET BITS ) + addr ) ; if ( m stats Bucket != null ) { m stats Bucket . allocate ( size ) ; } return value ; } else { String Builder sb = new String Builder ( ) ; sb . append ( STRING + m free Bits + STRING ) ; for ( Alloc Block ab : m alloc Blocks ) { sb . append ( ab . show ( ) + STRING ) ; } log . error ( sb ) ; return NUM ; } } finally { if ( s islog Debug ) check Bits ( ) ; } }
public static Native Page create Native Page For URL ( String url , Native Page candidate Page , Tab tab , Tab Model Selector tab Model Selector , Activity activity ) { return create Native Page For URL ( url , candidate Page , tab , tab Model Selector , activity , tab . is Incognito ( ) ) ; }
@ Override public void node Down ( long event UID , String node ID ) { try { lock . lock ( ) ; untried Connectors . put All ( tried Connectors ) ; tried Connectors . clear ( ) ; if ( untried Connectors . size ( ) > NUM ) { condition . signal ( ) ; } } finally { lock . unlock ( ) ; } }
public static synchronized Collection < String > all Local MA Cs ( ) { List < String > macs = new Array List < > ( NUM ) ; try { Enumeration < Network Interface > itfs = Network Interface . get Network Interfaces ( ) ; if ( itfs != null ) { for ( Network Interface itf : as Iterable ( itfs ) ) { byte [ ] hw Addr = itf . get Hardware Address ( ) ; if ( hw Addr != null && hw Addr . length > NUM ) { String mac = byte Array 2 Hex String ( hw Addr ) ; if ( ! macs . contains ( mac ) ) macs . add ( mac ) ; } } } } catch ( Socket Exception ignore ) { return Collections . empty List ( ) ; } Collections . sort ( macs ) ; return macs ; }
public void remove Cart Item ( int index , boolean trigger External Ops , Local Dispatcher dispatcher ) throws Cart Item Modify Exception { if ( is Read Only Cart ( ) ) { throw new Cart Item Modify Exception ( STRING ) ; } if ( index < NUM ) return ; if ( cart Lines . size ( ) <= index ) return ; Shopping Cart Item item = cart Lines . remove ( index ) ; item . set Quantity ( Big Decimal . ZERO , dispatcher , this , trigger External Ops , BOOL , BOOL , BOOL ) ; }
private final void access Check ( T obj ) { if ( ! cclass . is Instance ( obj ) ) throw access Check Exception ( obj ) ; }
protected void mark First Time ( Element elem ) { String elem Name = elem . get Name ( ) ; if ( elem Name . equals ( STRING ) ) { seen Html = BOOL ; } else if ( elem Name . equals ( STRING ) ) { seen Head = BOOL ; } else if ( elem Name . equals ( STRING ) ) { if ( buf . length == NUM ) { char [ ] new Buf = new char [ NUM ] ; new Buf [ NUM ] = buf [ NUM ] ; buf = new Buf ; } seen Body = BOOL ; } }
public static String time To String ( long period ) { period /= NUM ; final long milsecs = period % NUM ; period /= NUM ; final long secs = period % NUM ; period /= NUM ; final long mins = period % NUM ; period /= NUM ; final long hours = period ; return String . format ( STRING , hours , mins , secs , milsecs ) ; }
protected static boolean is User Defined Property ( String prop Name ) { return ! standard Prop Names . contains ( prop Name ) ; }
private boolean condition M 0 ( String value , int index ) { if ( char At ( value , index + NUM ) == STRING ) { return BOOL ; } return contains ( value , index - NUM , NUM , STRING ) && ( ( index + NUM ) == value . length ( ) - NUM || contains ( value , index + NUM , NUM , STRING ) ) ; }
private void write Attribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( xml Writer . get Prefix ( namespace ) == null ) { xml Writer . write Namespace ( prefix , namespace ) ; xml Writer . set Prefix ( prefix , namespace ) ; } xml Writer . write Attribute ( namespace , att Name , att Value ) ; }
@ Reference ( authors = STRING , title = STRING , booktitle = STRING , url = STRING ) public double compute Tau ( long c , long d , double m , long wd , long bd ) { double tie = ( wd * ( wd - NUM ) + bd * ( bd - NUM ) ) > > > NUM ; return ( c - d ) / Math . sqrt ( ( m - tie ) * m ) ; }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; service ID = new Service ID ( in ) ; }
public void remove Swipe Listener ( Swipe Listener listener ) { if ( m Listeners == null ) { return ; } m Listeners . remove ( listener ) ; }
private void generate Create Events ( List < Igfs Path > created Paths , boolean file ) { if ( evts . is Recordable ( Event Type . EVT IGFS DIR CREATED ) ) { for ( int i = NUM ; i < created Paths . size ( ) - NUM ; i ++ ) Igfs Utils . send Events ( igfs Ctx . kernal Context ( ) , created Paths . get ( i ) , Event Type . EVT IGFS DIR CREATED ) ; } Igfs Path leaf Path = created Paths . get ( created Paths . size ( ) - NUM ) ; if ( file ) { Igfs Utils . send Events ( igfs Ctx . kernal Context ( ) , leaf Path , Event Type . EVT IGFS FILE CREATED ) ; Igfs Utils . send Events ( igfs Ctx . kernal Context ( ) , leaf Path , Event Type . EVT IGFS FILE OPENED WRITE ) ; } else Igfs Utils . send Events ( igfs Ctx . kernal Context ( ) , leaf Path , Event Type . EVT IGFS DIR CREATED ) ; }
public Opt In Template Class Resolver ( Set allowed Classes , List trusted Templates ) { this . allowed Classes = allowed Classes != null ? allowed Classes : Collections . EMPTY SET ; if ( trusted Templates != null ) { trusted Template Names = new Hash Set ( ) ; trusted Template Prefixes = new Array List ( ) ; Iterator it = trusted Templates . iterator ( ) ; while ( it . has Next ( ) ) { String li = ( String ) it . next ( ) ; if ( li . starts With ( STRING ) ) li = li . substring ( NUM ) ; if ( li . ends With ( STRING ) ) { trusted Template Prefixes . add ( li . substring ( NUM , li . length ( ) - NUM ) ) ; } else { trusted Template Names . add ( li ) ; } } } else { trusted Template Names = Collections . EMPTY SET ; trusted Template Prefixes = Collections . EMPTY LIST ; } }
protected void async Op Release ( ) { if ( async Ops Sem != null ) async Ops Sem . release ( ) ; }
public static boolean valid System Name Config ( String system Name , char type ) { if ( ! valid System Name Format ( system Name , type ) ) { return BOOL ; } return BOOL ; }
public void remove All ( ) { if ( m Records . size ( ) >= NUM ) { m Records . clear ( ) ; m Current Position = - NUM ; notify Observers ( ) ; } }
public synchronized boolean start Reindexer ( String name , boolean force ) throws Reindexer Already Running Exception { Online Reindexer < ? , ? , ? > reindexer = reindexers . get ( name ) ; validate Reindexer Not Running ( reindexer ) ; if ( force || ! is Current Index Version Latest ( name , reindexer ) ) { reindexer . start ( ) ; return BOOL ; } return BOOL ; }
@ Override public void print Stack Trace ( ) { super . print Stack Trace ( ) ; if ( nested != null ) nested . print Stack Trace ( ) ; }
private static void update Last Modified ( File dest Dir , String war File Path ) { File war File = new File ( war File Path ) ; dest Dir . set Last Modified ( war File . last Modified ( ) ) ; }
public void add Child ( Base Assembly Node child Node ) { child Node . parent Node = this ; child Nodes . add ( child Node ) ; }
protected void notify History Changed Listeners ( ) { Iterator < History Changed Listener > iter ; History Changed Listener l ; iter = m History Changed Listeners . iterator ( ) ; while ( iter . has Next ( ) ) { l = iter . next ( ) ; l . history Changed ( new History Changed Event ( this , HISTORY NAME , get History ( ) ) ) ; } }
private void signal Not Full ( ) { final Reentrant Lock put Lock = this . put Lock ; put Lock . lock ( ) ; try { not Full . signal ( ) ; } finally { put Lock . unlock ( ) ; } }
@ Requires Permission ( Manifest . permission . CAMERA ) public Camera Source start ( ) throws IO Exception { synchronized ( m Camera Lock ) { if ( m Camera != null ) { return this ; } m Camera = create Camera ( ) ; if ( Build . VERSION . SDK INT >= Build . VERSION CODES . HONEYCOMB ) { m Dummy Surface Texture = new Surface Texture ( DUMMY TEXTURE NAME ) ; m Camera . set Preview Texture ( m Dummy Surface Texture ) ; } else { m Dummy Surface View = new Surface View ( m Context ) ; m Camera . set Preview Display ( m Dummy Surface View . get Holder ( ) ) ; } m Camera . start Preview ( ) ; m Processing Thread = new Thread ( m Frame Processor ) ; m Frame Processor . set Active ( BOOL ) ; m Processing Thread . start ( ) ; } return this ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
private Text View find Text View By Tag Id ( final String tag Id ) { for ( final Text View view : m Tag View Map . values ( ) ) { final Tag tag = ( Tag ) view . get Tag ( ) ; if ( tag Id . equals ( tag . id ) ) { return view ; } } return null ; }
public Space prune ( Space prefix ) throws Scope Exception { Space x = this ; Array List < Space > stack = new Array List < > ( ) ; while ( x != null && ! x . equals ( prefix ) ) { stack . add ( NUM , x ) ; x = x . get Parent ( ) ; } if ( x == null ) { throw new Scope Exception ( STRING ) ; } else { Space result = new Space ( universe , x . get Domain ( ) ) ; for ( Space space : stack ) { result = result . S ( space . get Relation ( ) ) ; } return result ; } }
default void infof ( String format , Object ... args ) { info ( String . format ( format , args ) ) ; }
public static int darker ( int color , float factor ) { int a = Color . alpha ( color ) ; int r = Color . red ( color ) ; int g = Color . green ( color ) ; int b = Color . blue ( color ) ; return Color . argb ( a , Math . max ( ( int ) ( r * factor ) , NUM ) , Math . max ( ( int ) ( g * factor ) , NUM ) , Math . max ( ( int ) ( b * factor ) , NUM ) ) ; }
public < FV > FV extract Raw Java Field Value ( Object object ) throws SQL Exception { Object val ; if ( field Get Method == null ) { try { val = field . get ( object ) ; } catch ( Exception e ) { throw Sql Exception Util . create ( STRING + this , e ) ; } } else { try { val = field Get Method . invoke ( object ) ; } catch ( Exception e ) { throw Sql Exception Util . create ( STRING + field Get Method + STRING + this , e ) ; } } @ Suppress Warnings ( STRING ) FV converted = ( FV ) val ; return converted ; }
public static void write File ( File file , byte [ ] data ) { try { Random Access File ra = new Random Access File ( file , STRING ) ; ra . write ( data ) ; ra . set Length ( data . length ) ; ra . close ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING + file , e ) ; } }
public static double [ ] threshold String To Array ( String top , int L ) { if ( top . starts With ( STRING ) ) { return ML Utils . to Double Array ( top ) ; } else { double t [ ] = new double [ L ] ; Arrays . fill ( t , Double . parse Double ( top ) ) ; return t ; } }
@ Override public String [ ] determine Column Constraints ( Result Producer rp ) throws Exception { return null ; }
abstract Set < String > init Config Names ( ) ;
public static int eval ( String url , String text ) throws IO Exception { String return Value = null ; if ( url . starts With ( STRING ) ) { return Value = do Http ( url , text ) ; } else if ( url . starts With ( STRING ) ) { return Value = do Bsh ( url , text ) ; } else throw new IO Exception ( STRING + STRING ) ; try { return Integer . parse Int ( return Value ) ; } catch ( Exception e ) { return NUM ; } }
public DSA Private Key ( byte [ ] encoded ) throws Invalid Key Exception { clear Old Key ( ) ; decode ( encoded ) ; }
public static String read Fully ( Reader reader ) throws IO Exception { try { String Writer writer = new String Writer ( ) ; char [ ] buffer = new char [ NUM ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM ) { writer . write ( buffer , NUM , count ) ; } return writer . to String ( ) ; } finally { reader . close ( ) ; } }
private void send Broadcast New Operation ( Target target , Remote Operation operation ) { Intent intent = new Intent ( ACTION OPERATION ADDED ) ; if ( target . m Account != null ) { intent . put Extra ( EXTRA ACCOUNT , target . m Account ) ; } else { intent . put Extra ( EXTRA SERVER URL , target . m Server Url ) ; } send Sticky Broadcast ( intent ) ; }
int successful ( ) { return success . get ( ) ; }
public void monitor ( String key ) { Timer t = new Timer ( BOOL ) ; t . schedule ( new Watchable Registration ( key ) , NUM * NUM , NUM * NUM ) ; }
private synchronized void rebuild Journal ( ) throws IO Exception { if ( journal Writer != null ) { journal Writer . close ( ) ; } Writer writer = new Buffered Writer ( new File Writer ( journal File Tmp ) , IO BUFFER SIZE ) ; writer . write ( MAGIC ) ; writer . write ( STRING ) ; writer . write ( VERSION 1 ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( app Version ) ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( value Count ) ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; for ( Entry entry : lru Entries . values ( ) ) { if ( entry . current Editor != null ) { writer . write ( DIRTY + STRING + entry . key + STRING ) ; } else { writer . write ( CLEAN + STRING + entry . key + entry . get Lengths ( ) + STRING ) ; } } writer . close ( ) ; journal File Tmp . rename To ( journal File ) ; journal Writer = new Buffered Writer ( new File Writer ( journal File , BOOL ) , IO BUFFER SIZE ) ; }
protected int check Risk Attribute ( ) { int ret Val = NUM ; if ( debug . message Enabled ( ) ) { debug . message ( STRING , ADAPTIVE ) ; } if ( risk Attribute Name != null && risk Attribute Value != null ) { Set < String > risk Attribute Values = null ; risk Attribute Values = get Identity Attribute Set ( risk Attribute Name ) ; if ( risk Attribute Values != null ) { for ( String risk Attr : risk Attribute Values ) { if ( risk Attribute Value . equals Ignore Case ( risk Attr ) ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING , ADAPTIVE ) ; } ret Val = risk Attribute Score ; break ; } } } } if ( ! risk Attribute Invert ) { ret Val = risk Attribute Score - ret Val ; } return ret Val ; }
public static Meth Executor Result execute Instance ( String receiver , String selector , Class [ ] types , Object [ ] args ) { try { Class receiver Class = Class . for Name ( receiver ) ; Constructor init = receiver Class . get Declared Constructor ( new Class [ NUM ] ) ; init . set Accessible ( BOOL ) ; Object target = init . new Instance ( new Object [ NUM ] ) ; Object res = null ; try { Method the Method = get Method ( receiver Class , selector , types ) ; res = the Method . invoke ( target , args ) ; return new Meth Executor Result ( res ) ; } catch ( Invocation Target Exception inv Targ Ex ) { Throwable targ Ex = inv Targ Ex . get Target Exception ( ) ; if ( targ Ex == null ) { return new Meth Executor Result ( res ) ; } else { return new Meth Executor Result ( targ Ex ) ; } } } catch ( Virtual Machine Error e ) { System Failure . initiate Failure ( e ) ; throw e ; } catch ( Throwable t ) { return new Meth Executor Result ( t ) ; } }
private void write Object ( Object Output Stream stream ) throws IO Exception { stream . default Write Object ( ) ; marshal Attributes ( attrs , stream ) ; }
@ Override synchronized public void write ( byte b [ ] , int off , int len ) throws IO Exception { if ( b == null ) { throw new Null Pointer Exception ( ) ; } else if ( off < NUM || len < NUM || len > b . length - off ) { throw new Index Out Of Bounds Exception ( ) ; } else if ( len == NUM ) { return ; } c . check Write ( ) ; boolean is First Record Of The Payload = BOOL ; try { do { boolean hold Record = BOOL ; int howmuch ; if ( is First Record Of The Payload && c . need To Split Payload ( ) ) { howmuch = Math . min ( NUM , r . available Data Bytes ( ) ) ; if ( ( len != NUM ) && ( howmuch == NUM ) ) { hold Record = BOOL ; } } else { howmuch = Math . min ( len , r . available Data Bytes ( ) ) ; } if ( is First Record Of The Payload && howmuch != NUM ) { is First Record Of The Payload = BOOL ; } if ( howmuch > NUM ) { r . write ( b , off , howmuch ) ; off += howmuch ; len -= howmuch ; } c . write Record ( r , hold Record ) ; c . check Write ( ) ; } while ( len > NUM ) ; } catch ( Exception e ) { c . handle Exception ( e ) ; } }
public boolean on Intercept Touch Event ( Motion Event ev ) { @ Suppress Warnings ( STRING ) final boolean debug = BOOL ; if ( debug ) { Log . d ( Launcher . TAG , STRING + ev + STRING + m Dragging ) ; } acquire Velocity Tracker And Add Movement ( ev ) ; final int action = ev . get Action ( ) ; final int [ ] drag Layer Pos = get Clamped Drag Layer Pos ( ev . get X ( ) , ev . get Y ( ) ) ; final int drag Layer X = drag Layer Pos [ NUM ] ; final int drag Layer Y = drag Layer Pos [ NUM ] ; switch ( action ) { case Motion Event . ACTION MOVE : break ; case Motion Event . ACTION DOWN : m Motion Down X = drag Layer X ; m Motion Down Y = drag Layer Y ; m Last Drop Target = null ; break ; case Motion Event . ACTION UP : m Last Touch Up Time = System . current Time Millis ( ) ; if ( m Dragging ) { Point F vec = is Flinging To Delete ( m Drag Object . drag Source ) ; if ( ! Delete Drop Target . will Accept Drop ( m Drag Object . drag Info ) ) { vec = null ; } if ( vec != null ) { drop On Fling To Delete Target ( drag Layer X , drag Layer Y , vec ) ; } else { drop ( drag Layer X , drag Layer Y ) ; } } end Drag ( ) ; break ; case Motion Event . ACTION CANCEL : cancel Drag ( ) ; break ; } return m Dragging ; }
public void test concurrent KB Create And Discovery ( ) throws Exception { final String namespace = get Name ( ) ; final Properties properties = get Properties ( ) ; Journal jnl = null ; try { jnl = new Journal ( properties ) ; do Concurrent Create And Discovery Test ( jnl , namespace ) ; } finally { if ( jnl != null ) jnl . destroy ( ) ; } }
private void reset Database ( Tungsten Properties service Props , Map < String , String > progress ) throws Interrupted Exception { Data Source Administrator admin = null ; String service Name = service Props . get String ( Replicator Conf . SERVICE NAME ) ; try { admin = new Data Source Administrator ( service Props ) ; admin . prepare ( ) ; progress . put ( STRING , service Name ) ; boolean cleared = admin . reset All ( ) ; if ( cleared ) { logger . info ( STRING ) ; } else { logger . info ( STRING + service Name ) ; } } catch ( Replicator Exception e ) { logger . error ( String . format ( STRING , service Name , e . get Message ( ) ) , e ) ; } finally { if ( admin != null ) { admin . release ( ) ; } } }
public static final void write Value Xml ( Object v , String name , Xml Serializer out ) throws Xml Pull Parser Exception , IO Exception { String type Str ; if ( v == null ) { out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } out . end Tag ( null , STRING ) ; return ; } else if ( v instanceof String ) { out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } out . text ( v . to String ( ) ) ; out . end Tag ( null , STRING ) ; return ; } else if ( v instanceof Integer ) { type Str = STRING ; } else if ( v instanceof Long ) { type Str = STRING ; } else if ( v instanceof Float ) { type Str = STRING ; } else if ( v instanceof Double ) { type Str = STRING ; } else if ( v instanceof Boolean ) { type Str = STRING ; } else if ( v instanceof byte [ ] ) { write Byte Array Xml ( ( byte [ ] ) v , name , out ) ; return ; } else if ( v instanceof int [ ] ) { write Int Array Xml ( ( int [ ] ) v , name , out ) ; return ; } else if ( v instanceof Map ) { write Map Xml ( ( Map ) v , name , out ) ; return ; } else if ( v instanceof List ) { write List Xml ( ( List ) v , name , out ) ; return ; } else if ( v instanceof Char Sequence ) { out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } out . text ( v . to String ( ) ) ; out . end Tag ( null , STRING ) ; return ; } else { throw new Runtime Exception ( STRING + v ) ; } out . start Tag ( null , type Str ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } out . attribute ( null , STRING , v . to String ( ) ) ; out . end Tag ( null , type Str ) ; }
private void initialize Ideal Point ( ) { ideal Point = new double [ problem . get Number Of Objectives ( ) ] ; Arrays . fill ( ideal Point , Double . POSITIVE INFINITY ) ; }
private long start Wait ( ) { return System . nano Time ( ) ; }
public static String [ ] read Font Names ( final Font Data font Data ) { final String [ ] font Names = new String [ NUM ] ; font Names [ NUM ] = null ; final Buffered Reader br = new Buffered Reader ( new String Reader ( new String ( font Data . get Bytes ( NUM , font Data . length ( ) ) ) ) ) ; String line = null ; while ( BOOL ) { try { line = br . read Line ( ) ; } catch ( final IO Exception e ) { Log Writer . write Log ( STRING + e . get Message ( ) ) ; } if ( line == null ) { break ; } if ( line . starts With ( STRING ) ) { final int name Start = line . index Of ( STRING , NUM ) ; if ( name Start != - NUM ) { final int name End = line . index Of ( STRING , name Start ) ; if ( name End != - NUM ) { final String name = line . substring ( name Start + NUM , name End ) ; font Names [ NUM ] = name . to Lower Case ( ) ; break ; } } } } if ( br != null ) { try { br . close ( ) ; } catch ( final Exception e ) { Log Writer . write Log ( STRING + e + STRING ) ; } } if ( font Data != null ) { font Data . close ( ) ; } return font Names ; }
private void write Units Of Indentation ( int i ) throws IO Exception { for ( ; i > NUM ; i -- ) { writer . write ( INDENTATION UNIT ) ; } }
private Pattern Parser ( ) throws Hyphenation Exception { token = new String Builder ( ) ; parser = create Parser ( ) ; parser . set Content Handler ( this ) ; parser . set Error Handler ( this ) ; hyphen Char = STRING ; }
public static int cap Between ( int min , int number , int max ) { assert True ( min <= max ) ; return Math . min ( max , Math . max ( min , number ) ) ; }
public boolean has Extensions ( ) { return extensions != null ; }
public void munge ( String entity Id , Collection < Statement > statements , Collection < String > existing Values , Collection < String > existing Refs , Change source Change ) { if ( statements . is Empty ( ) ) { return ; } Munge Operation op = new Munge Operation ( entity Id , statements , existing Values , existing Refs ) ; if ( source Change != null ) { op . import From Change ( source Change ) ; } op . munge ( ) ; existing Values . remove All ( op . extra Valid Subjects ) ; existing Refs . remove All ( op . extra Valid Subjects ) ; return ; }
public void show Property Dialog ( ) { if ( m Editor . get Value ( ) != null ) { if ( m PD == null ) { int x = get Location On Screen ( ) . x ; int y = get Location On Screen ( ) . y ; if ( Property Dialog . get Parent Dialog ( this ) != null ) m PD = new Property Dialog ( Property Dialog . get Parent Dialog ( this ) , m Editor , x , y ) ; else m PD = new Property Dialog ( Property Dialog . get Parent Frame ( this ) , m Editor , x , y ) ; m PD . set Visible ( BOOL ) ; } else { m PD . set Visible ( BOOL ) ; } m Editor . set Value ( m Editor . get Value ( ) ) ; } }
public Lucene 60 Codec ( Mode mode ) { super ( STRING ) ; this . stored Fields Format = new Lucene 50 Stored Fields Format ( Objects . require Non Null ( mode ) ) ; }
public void delete ( ) throws IO Exception { close ( ) ; Util . delete Contents ( directory ) ; }
public synchronized void remove ( String name ) { for ( int i = NUM ; i < modifications . size ( ) ; i ++ ) { Modification mod = modifications . get ( i ) ; Attribute attr = mod . get Attribute ( ) ; if ( name . equals Ignore Case ( attr . get Attribute Description As String ( ) ) ) { modifications . remove ( i ) ; return ; } } }
void add Fill Components ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM , NUM ) ; boolean filled cell 11 = BOOL ; Cell Constraints cc = new Cell Constraints ( ) ; if ( cols . length > NUM && rows . length > NUM ) { if ( cols [ NUM ] == NUM && rows [ NUM ] == NUM ) { panel . add ( Box . create Rigid Area ( filler ) , cc . xy ( NUM , NUM ) ) ; filled cell 11 = BOOL ; } } for ( int index = NUM ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM && filled cell 11 ) { continue ; } panel . add ( Box . create Rigid Area ( filler ) , cc . xy ( cols [ index ] , NUM ) ) ; } for ( int index = NUM ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM && filled cell 11 ) { continue ; } panel . add ( Box . create Rigid Area ( filler ) , cc . xy ( NUM , rows [ index ] ) ) ; } }
private boolean quiet Sleep ( long ms ) { try { Thread . sleep ( ms ) ; } catch ( Interrupted Exception e ) { return BOOL ; } return BOOL ; }
public void push Frame ( Local Variable Map vars , DML Program Counter pc ) { call Stack . push ( new DML Frame ( vars , pc ) ) ; }
public boolean is Landing Page ( URL url ) { if ( url . get Query ( ) != null ) { return BOOL ; } else { return landing Page Suffix ( url ) != STRING ; } }
protected void layout Graphic Modifiers ( Draw Context dc , AV List modifiers , Ordered Symbol osym ) { }
public static synchronized void progress ( final String message ) { s Last Progress = message ; final Print Stream prog = get Progress Stream ( ) ; if ( prog != null ) { prog . println ( now ( ) + message ) ; prog . flush ( ) ; if ( prog . check Error ( ) ) { s Progress Stream = null ; } } }
private static boolean match ( Char Sequence string , Char Sequence pattern , int s Ndx , int p Ndx ) { int p Len = pattern . length ( ) ; if ( p Len == NUM ) { if ( pattern . char At ( NUM ) == STRING ) { return BOOL ; } } int s Len = string . length ( ) ; boolean next Is Not Wildcard = BOOL ; while ( BOOL ) { if ( ( s Ndx >= s Len ) == BOOL ) { while ( ( p Ndx < p Len ) && ( pattern . char At ( p Ndx ) == STRING ) ) { p Ndx ++ ; } return p Ndx >= p Len ; } if ( p Ndx >= p Len ) { return BOOL ; } char p = pattern . char At ( p Ndx ) ; if ( next Is Not Wildcard == BOOL ) { if ( p == STRING ) { p Ndx ++ ; next Is Not Wildcard = BOOL ; continue ; } if ( p == STRING ) { s Ndx ++ ; p Ndx ++ ; continue ; } if ( p == STRING ) { char p Next = NUM ; if ( p Ndx + NUM < p Len ) { p Next = pattern . char At ( p Ndx + NUM ) ; } if ( p Next == STRING ) { p Ndx ++ ; continue ; } int i ; p Ndx ++ ; for ( i = string . length ( ) ; i >= s Ndx ; i -- ) { if ( match ( string , pattern , i , p Ndx ) == BOOL ) { return BOOL ; } } return BOOL ; } } else { next Is Not Wildcard = BOOL ; } if ( p != string . char At ( s Ndx ) ) { return BOOL ; } s Ndx ++ ; p Ndx ++ ; } }
public String next CDATA ( ) throws JSON Exception { char c ; int i ; String Buffer sb = new String Buffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( end ( ) ) { throw syntax Error ( STRING ) ; } sb . append ( c ) ; i = sb . length ( ) - NUM ; if ( i >= NUM && sb . char At ( i ) == STRING && sb . char At ( i + NUM ) == STRING && sb . char At ( i + NUM ) == STRING ) { sb . set Length ( i ) ; return sb . to String ( ) ; } } }
public void add Grammar File ( String file Name ) { grammar Files . add ( file Name ) ; }
private Workflow . Method rollback Delete Mirror Device Method ( URI vplex URI , URI vplex Mirror URI ) { return new Workflow . Method ( RB DELETE MIRROR DEVICE METHOD NAME , vplex URI , vplex Mirror URI ) ; }
private String find Cipher And Strength ( byte [ ] supported Ciphers , String [ ] tokens ) { byte s ; for ( int i = NUM ; i < strength . length ; i ++ ) { if ( ( s = strength [ i ] ) != NUM ) { for ( int j = NUM ; j < supported Ciphers . length ; j ++ ) { if ( s == supported Ciphers [ j ] && ( specified Cipher == null || specified Cipher . equals ( tokens [ j ] ) ) ) { switch ( s ) { case HIGH STRENGTH : negotiated Strength = STRING ; break ; case MEDIUM STRENGTH : negotiated Strength = STRING ; break ; case LOW STRENGTH : negotiated Strength = STRING ; break ; } return tokens [ j ] ; } } } } return null ; }
public static String [ ] split ( String line , String delim ) { List list = new Array List ( ) ; String Tokenizer t = new String Tokenizer ( line , delim ) ; while ( t . has More Tokens ( ) ) { list . add ( t . next Token ( ) ) ; } return ( String [ ] ) list . to Array ( new String [ list . size ( ) ] ) ; }
public static String slurp File ( File file ) throws IO Exception { Reader r = new File Reader ( file ) ; return slurp Reader ( r ) ; }
@ Not Null public List < Player Nbt > create Singleplayer Player Nbts ( ) { Log . i ( STRING ) ; return Arrays . as List ( create Level Dat Player Nbt ( ) ) ; }
@ Override public String to String ( ) { String Builder result = new String Builder ( limit - position ) ; for ( int i = position ; i < limit ; i ++ ) { result . append ( get ( i ) ) ; } return result . to String ( ) ; }
public void test Equals Unequal 1 ( ) { String a = STRING ; int a Scale = - NUM ; String b = STRING ; int b Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; assert False ( a Number . equals ( b Number ) ) ; }
public void test Case 8 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; int b Sign = NUM ; byte r Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( - NUM , result . signum ( ) ) ; }
public Get Form Key Cmd ( String process Definition Id , String task Definition Key ) { set Process Definition Id ( process Definition Id ) ; if ( task Definition Key == null || task Definition Key . length ( ) < NUM ) { throw new Activiti Illegal Argument Exception ( STRING + task Definition Key + STRING ) ; } this . task Definition Key = task Definition Key ; }
protected abstract Storage Level storage Level ( ) ;
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
private void stat Init ( ) { l Document No . set Label For ( f Document No ) ; f Document No . set Background ( Adempiere PLAF . get Info Background ( ) ) ; f Document No . add Action Listener ( this ) ; fcheck Receipt . set Selected ( BOOL ) ; fcheck Receipt . set Action Command ( STRING ) ; fcheck Receipt . add Action Listener ( this ) ; fcheck Payment . set Selected ( BOOL ) ; fcheck Payment . set Action Command ( STRING ) ; fcheck Payment . add Action Listener ( this ) ; f Bank Account ID = new V Lookup ( STRING , BOOL , BOOL , BOOL , M Lookup Factory . get ( Env . get Ctx ( ) , p Window No , NUM , M Column . get Column ID ( M Payment . Table Name , M Payment . COLUMNNAME C Bank Account ID ) , Display Type . Table Dir ) ) ; l Bank Account ID . set Label For ( f Bank Account ID ) ; f Bank Account ID . set Background ( Adempiere PLAF . get Info Background ( ) ) ; f Bank Account ID . add Action Listener ( this ) ; fB Partner ID = new V Lookup ( STRING , BOOL , BOOL , BOOL , M Lookup Factory . get ( Env . get Ctx ( ) , p Window No , NUM , M Column . get Column ID ( M Payment . Table Name , M Payment . COLUMNNAME C B Partner ID ) , Display Type . Search ) ) ; lB Partner ID . set Label For ( fB Partner ID ) ; fB Partner ID . set Background ( Adempiere PLAF . get Info Background ( ) ) ; fB Partner ID . add Action Listener ( this ) ; l Date From . set Label For ( f Date From ) ; f Date From . set Background ( Adempiere PLAF . get Info Background ( ) ) ; f Date From . set Tool Tip Text ( Msg . translate ( Env . get Ctx ( ) , STRING ) ) ; f Date From . add Action Listener ( this ) ; l Date To . set Label For ( f Date To ) ; f Date To . set Background ( Adempiere PLAF . get Info Background ( ) ) ; f Date To . set Tool Tip Text ( Msg . translate ( Env . get Ctx ( ) , STRING ) ) ; f Date To . add Action Listener ( this ) ; l Amt From . set Label For ( f Amt From ) ; f Amt From . set Background ( Adempiere PLAF . get Info Background ( ) ) ; f Amt From . set Tool Tip Text ( Msg . translate ( Env . get Ctx ( ) , STRING ) ) ; f Amt From . set Border ( f Date From . get Border ( ) ) ; f Amt From . add Action Listener ( this ) ; l Amt To . set Label For ( f Amt To ) ; f Amt To . set Background ( Adempiere PLAF . get Info Background ( ) ) ; f Amt To . set Tool Tip Text ( Msg . translate ( Env . get Ctx ( ) , STRING ) ) ; f Amt To . set Border ( f Date From . get Border ( ) ) ; f Amt To . add Action Listener ( this ) ; C Panel amt Panel = new C Panel ( ) ; C Panel date Panel = new C Panel ( ) ; amt Panel . set Layout ( new A Layout ( NUM , NUM , BOOL ) ) ; amt Panel . add ( f Amt From , new A Layout Constraint ( NUM , NUM ) ) ; amt Panel . add ( l Amt To , null ) ; amt Panel . add ( f Amt To , null ) ; date Panel . set Layout ( new A Layout ( NUM , NUM , BOOL ) ) ; date Panel . add ( f Date From , new A Layout Constraint ( NUM , NUM ) ) ; date Panel . add ( l Date To , null ) ; date Panel . add ( f Date To , null ) ; p criteria Grid . add ( l Document No , new A Layout Constraint ( NUM , NUM ) ) ; p criteria Grid . add ( f Document No , null ) ; p criteria Grid . add ( lB Partner ID , null ) ; p criteria Grid . add ( fB Partner ID , null ) ; p criteria Grid . add ( fcheck Receipt , new A Layout Constraint ( NUM , NUM ) ) ; p criteria Grid . add ( l Bank Account ID , new A Layout Constraint ( NUM , NUM ) ) ; p criteria Grid . add ( f Bank Account ID ) ; p criteria Grid . add ( l Date From , null ) ; p criteria Grid . add ( date Panel , null ) ; p criteria Grid . add ( fcheck Payment , new A Layout Constraint ( NUM , NUM ) ) ; p criteria Grid . add ( l Amt From , new A Layout Constraint ( NUM , NUM ) ) ; p criteria Grid . add ( amt Panel , null ) ; }
@ Override public Graphics create ( ) { if ( DEBUG ) { m printstream . println ( STRING ) ; } Postscript Graphics psg = new Postscript Graphics ( this ) ; return ( psg ) ; }
private void parse Actions ( ) { String Tokenizer st = new String Tokenizer ( actions , STRING , BOOL ) ; boolean comma = BOOL ; while ( st . has More Tokens ( ) ) { String act = st . next Token ( ) ; if ( act . equals ( STRING ) ) { continue ; } else if ( comma ) { if ( ! act . equals ( STRING ) ) { comma = BOOL ; break ; } } else if ( act . equals Ignore Case ( STRING ) ) { mask |= CONNECT ; } else if ( act . equals Ignore Case ( STRING ) ) { mask |= ACCEPT ; } else if ( act . equals Ignore Case ( STRING ) ) { mask |= DELEGATE ; } else if ( act . equals Ignore Case ( STRING ) ) { mask |= LISTEN ; } else { break ; } comma = ! comma ; } if ( ! comma ) { throw new Illegal Argument Exception ( STRING ) ; } }
byte [ ] to Bytes ( SSL Session session ) { if ( ! ( session instanceof Open SSL Session Impl ) ) { return null ; } Open SSL Session Impl ssl Session = ( Open SSL Session Impl ) session ; try { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; Data Output Stream daos = new Data Output Stream ( baos ) ; daos . write Int ( OPEN SSL ) ; byte [ ] data = ssl Session . get Encoded ( ) ; daos . write Int ( data . length ) ; daos . write ( data ) ; Certificate [ ] certs = session . get Peer Certificates ( ) ; daos . write Int ( certs . length ) ; for ( Certificate cert : certs ) { data = cert . get Encoded ( ) ; daos . write Int ( data . length ) ; daos . write ( data ) ; } return baos . to Byte Array ( ) ; } catch ( IO Exception e ) { log ( e ) ; return null ; } catch ( Certificate Encoding Exception e ) { log ( e ) ; return null ; } }
private static void decode Text Compaction ( int [ ] text Compaction Data , int [ ] byte Compaction Data , int length , String Builder result ) { Mode sub Mode = Mode . ALPHA ; Mode prior To Shift Mode = Mode . ALPHA ; int i = NUM ; while ( i < length ) { int sub Mode Ch = text Compaction Data [ i ] ; char ch = NUM ; switch ( sub Mode ) { case ALPHA : if ( sub Mode Ch < NUM ) { ch = ( char ) ( STRING + sub Mode Ch ) ; } else { if ( sub Mode Ch == NUM ) { ch = STRING ; } else if ( sub Mode Ch == LL ) { sub Mode = Mode . LOWER ; } else if ( sub Mode Ch == ML ) { sub Mode = Mode . MIXED ; } else if ( sub Mode Ch == PS ) { prior To Shift Mode = sub Mode ; sub Mode = Mode . PUNCT SHIFT ; } else if ( sub Mode Ch == MODE SHIFT TO BYTE COMPACTION MODE ) { result . append ( ( char ) byte Compaction Data [ i ] ) ; } else if ( sub Mode Ch == TEXT COMPACTION MODE LATCH ) { sub Mode = Mode . ALPHA ; } } break ; case LOWER : if ( sub Mode Ch < NUM ) { ch = ( char ) ( STRING + sub Mode Ch ) ; } else { if ( sub Mode Ch == NUM ) { ch = STRING ; } else if ( sub Mode Ch == AS ) { prior To Shift Mode = sub Mode ; sub Mode = Mode . ALPHA SHIFT ; } else if ( sub Mode Ch == ML ) { sub Mode = Mode . MIXED ; } else if ( sub Mode Ch == PS ) { prior To Shift Mode = sub Mode ; sub Mode = Mode . PUNCT SHIFT ; } else if ( sub Mode Ch == MODE SHIFT TO BYTE COMPACTION MODE ) { result . append ( ( char ) byte Compaction Data [ i ] ) ; } else if ( sub Mode Ch == TEXT COMPACTION MODE LATCH ) { sub Mode = Mode . ALPHA ; } } break ; case MIXED : if ( sub Mode Ch < PL ) { ch = MIXED CHARS [ sub Mode Ch ] ; } else { if ( sub Mode Ch == PL ) { sub Mode = Mode . PUNCT ; } else if ( sub Mode Ch == NUM ) { ch = STRING ; } else if ( sub Mode Ch == LL ) { sub Mode = Mode . LOWER ; } else if ( sub Mode Ch == AL ) { sub Mode = Mode . ALPHA ; } else if ( sub Mode Ch == PS ) { prior To Shift Mode = sub Mode ; sub Mode = Mode . PUNCT SHIFT ; } else if ( sub Mode Ch == MODE SHIFT TO BYTE COMPACTION MODE ) { result . append ( ( char ) byte Compaction Data [ i ] ) ; } else if ( sub Mode Ch == TEXT COMPACTION MODE LATCH ) { sub Mode = Mode . ALPHA ; } } break ; case PUNCT : if ( sub Mode Ch < PAL ) { ch = PUNCT CHARS [ sub Mode Ch ] ; } else { if ( sub Mode Ch == PAL ) { sub Mode = Mode . ALPHA ; } else if ( sub Mode Ch == MODE SHIFT TO BYTE COMPACTION MODE ) { result . append ( ( char ) byte Compaction Data [ i ] ) ; } else if ( sub Mode Ch == TEXT COMPACTION MODE LATCH ) { sub Mode = Mode . ALPHA ; } } break ; case ALPHA SHIFT : sub Mode = prior To Shift Mode ; if ( sub Mode Ch < NUM ) { ch = ( char ) ( STRING + sub Mode Ch ) ; } else { if ( sub Mode Ch == NUM ) { ch = STRING ; } else if ( sub Mode Ch == TEXT COMPACTION MODE LATCH ) { sub Mode = Mode . ALPHA ; } } break ; case PUNCT SHIFT : sub Mode = prior To Shift Mode ; if ( sub Mode Ch < PAL ) { ch = PUNCT CHARS [ sub Mode Ch ] ; } else { if ( sub Mode Ch == PAL ) { sub Mode = Mode . ALPHA ; } else if ( sub Mode Ch == MODE SHIFT TO BYTE COMPACTION MODE ) { result . append ( ( char ) byte Compaction Data [ i ] ) ; } else if ( sub Mode Ch == TEXT COMPACTION MODE LATCH ) { sub Mode = Mode . ALPHA ; } } break ; } if ( ch != NUM ) { result . append ( ch ) ; } i ++ ; } }
public static boolean is Valid Name ( String name ) { if ( name == null ) { return BOOL ; } return name . length ( ) > NUM ; }
protected void add Counters ( Basic Counters < Mutable Long > target , Basic Counters < Mutable Long > source ) { for ( Enum < Reader Counter Keys > key : Reader Counter Keys . values ( ) ) { Mutable Long tcounter = target . get Counter ( key ) ; if ( tcounter == null ) { tcounter = new Mutable Long ( ) ; target . set Counter ( key , tcounter ) ; } Mutable Long scounter = source . get Counter ( key ) ; if ( scounter != null ) { tcounter . add ( scounter . long Value ( ) ) ; } } }
private void add Card ( Shared Preferences shared Preferences , String key ) { String json = shared Preferences . get String ( key , null ) ; if ( json != null ) { try { JSON Object json Data = new JSON Object ( json ) ; if ( json Data . has ( IMAGE KEY ) ) { String image = json Data . get String ( IMAGE KEY ) ; List < I Topic > cards = get Source Topic Model ( ) ; switch ( key ) { case POOL KEY : cards . add ( NUM , Cards . pool ( image , get Activity ( ) ) ) ; remove Duplicates ( POOL KEY , cards ) ; break ; case VIDEO KEY : switch ( json Data . get String ( ID KEY ) ) { case POOL CAMERA ID : m Great Shot Url = json Data . get String ( URL KEY ) ; m Elv . set On Group Click Listener ( great Shot Listener ) ; cards . add ( NUM , Cards . pool Video ( m Great Shot Url , get Activity ( ) ) ) ; remove Duplicates ( VIDEO KEY , cards ) ; break ; } break ; case FOOD KEY : cards . add ( NUM , Cards . food ( image , get Activity ( ) ) ) ; remove Duplicates ( FOOD KEY , cards ) ; break ; case PRINTER 3D KEY : cards . add ( NUM , Cards . printer 3 d ( image , get Activity ( ) ) ) ; remove Duplicates ( PRINTER 3D KEY , cards ) ; break ; } } else if ( json Data . has ( MESSAGE KEY ) ) { String message = json Data . get String ( MESSAGE KEY ) ; List < I Topic > cards = get Source Topic Model ( ) ; cards . add ( NUM , Cards . test ( message , get Activity ( ) ) ) ; } UI . execute ( null ) ; } catch ( JSON Exception e ) { e . print Stack Trace ( ) ; } } }
public static List < Logged Mqtt Message > parse Message Log ( final List < String > messages , final Progress Updater progress , final long current , final long max ) throws Spy Exception { try { final long start Time = Time Utils . get Monotonic Time ( ) ; final int items = messages . size ( ) ; final long chunk Size = items / NUM ; final Mqtt Message Log Parser parser = new Mqtt Message Log Parser ( ) ; final List < Logged Mqtt Message > list = new Array List < Logged Mqtt Message > ( ) ; long item = NUM ; long report At = NUM ; for ( int i = NUM ; i < items ; i ++ ) { final String message = messages . get ( i ) ; if ( progress != null ) { if ( progress . is Cancelled ( ) ) { logger . info ( STRING ) ; return null ; } item ++ ; if ( item % NUM == NUM ) { progress . update ( current + item , max ) ; } } if ( ( i > NUM ) && ( i == ( chunk Size * report At ) ) ) { final long current Time = Time Utils . get Monotonic Time ( ) ; final long time Taken = current Time - start Time ; final long total Time Expected = time Taken * items / i ; if ( time Taken > NUM ) { logger . info ( STRING , report At * NUM , ( total Time Expected - time Taken ) / NUM ) ; } report At ++ ; } try { list . add ( parser . parse ( message ) ) ; } catch ( XML Exception e ) { logger . error ( STRING + message , e ) ; } } logger . info ( STRING , list . size ( ) ) ; return list ; } catch ( XML Exception e ) { throw new Spy Exception ( STRING , e ) ; } }
private void recompute Seperation ( double [ ] [ ] means , double [ ] sep ) { final int k = means . length ; assert ( sep . length == k ) ; boolean issquared = ( distance Function instanceof Squared Euclidean Distance Function ) ; Arrays . fill ( sep , Double . POSITIVE INFINITY ) ; for ( int i = NUM ; i < k ; i ++ ) { Double Vector m1 = Double Vector . wrap ( means [ i ] ) ; for ( int j = NUM ; j < i ; j ++ ) { double d = distance Function . distance ( m1 , Double Vector . wrap ( means [ j ] ) ) ; sep [ i ] = ( d < sep [ i ] ) ? d : sep [ i ] ; sep [ j ] = ( d < sep [ j ] ) ? d : sep [ j ] ; } } for ( int i = NUM ; i < k ; i ++ ) { sep [ i ] = issquared ? Math . sqrt ( sep [ i ] ) : sep [ i ] ; sep [ i ] *= NUM ; } }
private int transition ( int state , int symbol ) { for ( int i = state ; i < transitions . length ; i ++ ) { if ( ( transitions [ i ] % vocabulary Size ) == symbol ) { return ( transitions [ i ] / vocabulary Size ) ; } } return - NUM ; }
public synchronized Ceylon Config merge ( Ceylon Config other ) { for ( String key : other . get Option Names ( null ) ) { String [ ] values = other . get Option Values ( key ) ; set Option Values ( key , values ) ; } return this ; }
public static synchronized String rot 13 ( String input ) { String Buffer output = new String Buffer ( ) ; if ( input != null ) { for ( int i = NUM ; i < input . length ( ) ; i ++ ) { char in Char = input . char At ( i ) ; if ( ( in Char >= STRING ) & ( in Char <= STRING ) ) { in Char += NUM ; if ( in Char > STRING ) { in Char -= NUM ; } } if ( ( in Char >= STRING ) & ( in Char <= STRING ) ) { in Char += NUM ; if ( in Char > STRING ) { in Char -= NUM ; } } output . append ( in Char ) ; } } return output . to String ( ) ; }
private long month Range ( ) { Value Range start Range = chrono . range ( MONTH OF YEAR ) ; if ( start Range . is Fixed ( ) && start Range . is Int Value ( ) ) { return start Range . get Maximum ( ) - start Range . get Minimum ( ) + NUM ; } return - NUM ; }
public void animate ( Marker With Position marker , Lat Lng from , Lat Lng to ) { lock . lock ( ) ; m Animation Tasks . add ( new Animation Task ( marker , from , to ) ) ; lock . unlock ( ) ; }
@ Override public int compare To ( Component Description o ) { int my Pos = NUM ; int o Pos = NUM ; if ( this instanceof Language Component Description ) { my Pos = NUM ; } else if ( this instanceof Voice Component Description ) { my Pos = NUM ; } if ( o instanceof Language Component Description ) { o Pos = NUM ; } else if ( o instanceof Voice Component Description ) { o Pos = NUM ; } if ( o Pos - my Pos != NUM ) { return ( o Pos - my Pos ) ; } return name . compare To ( o . name ) ; }
public boolean [ ] test To String ( ) { return super . test To String ( ) ; }
public static byte [ ] escape Eastern Unicode Byte Stream ( byte [ ] orig Bytes , String orig String ) { if ( orig Bytes == null ) { return null ; } if ( orig Bytes . length == NUM ) { return new byte [ NUM ] ; } int bytes Len = orig Bytes . length ; int buf Index = NUM ; int str Index = NUM ; Byte Array Output Stream bytes Out = new Byte Array Output Stream ( bytes Len ) ; while ( BOOL ) { if ( orig String . char At ( str Index ) == STRING ) { bytes Out . write ( orig Bytes [ buf Index ++ ] ) ; } else { int lo Byte = orig Bytes [ buf Index ] ; if ( lo Byte < NUM ) { lo Byte += NUM ; } bytes Out . write ( lo Byte ) ; if ( lo Byte >= NUM ) { if ( buf Index < ( bytes Len - NUM ) ) { int hi Byte = orig Bytes [ buf Index + NUM ] ; if ( hi Byte < NUM ) { hi Byte += NUM ; } bytes Out . write ( hi Byte ) ; buf Index ++ ; if ( hi Byte == NUM ) { bytes Out . write ( hi Byte ) ; } } } else if ( lo Byte == NUM ) { if ( buf Index < ( bytes Len - NUM ) ) { int hi Byte = orig Bytes [ buf Index + NUM ] ; if ( hi Byte < NUM ) { hi Byte += NUM ; } if ( hi Byte == NUM ) { bytes Out . write ( NUM ) ; bytes Out . write ( NUM ) ; buf Index ++ ; } } } buf Index ++ ; } if ( buf Index >= bytes Len ) { break ; } str Index ++ ; } return bytes Out . to Byte Array ( ) ; }
private static String Builder dump ( String Builder lbuffer , long value ) { for ( int j = NUM ; j < NUM ; j ++ ) { lbuffer . append ( CHARS [ ( int ) ( value > > SHIFTS [ j ] ) & NUM ] ) ; } return lbuffer ; }
@ Override protected void on Measure ( int width Measure Spec , int height Measure Spec ) { super . on Measure ( width Measure Spec , height Measure Spec ) ; int size Width = Measure Spec . get Size ( width Measure Spec ) - get Padding Left ( ) - get Padding Right ( ) ; int size Height = Measure Spec . get Size ( height Measure Spec ) ; int mode Width = Measure Spec . get Mode ( width Measure Spec ) ; int mode Height = Measure Spec . get Mode ( height Measure Spec ) ; int width = NUM ; int height = get Padding Top ( ) + get Padding Bottom ( ) ; int line Width = NUM ; int line Height = NUM ; int child Count = get Child Count ( ) ; for ( int i = NUM ; i < child Count ; i ++ ) { View child = get Child At ( i ) ; boolean last Child = i == child Count - NUM ; if ( child . get Visibility ( ) == View . GONE ) { if ( last Child ) { width = Math . max ( width , line Width ) ; height += line Height ; } continue ; } measure Child With Margins ( child , width Measure Spec , line Width , height Measure Spec , height ) ; Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; int child Width Mode = Measure Spec . AT MOST ; int child Width Size = size Width ; int child Height Mode = Measure Spec . AT MOST ; int child Height Size = size Height ; if ( lp . width == Layout Params . MATCH PARENT ) { child Width Mode = Measure Spec . EXACTLY ; child Width Size -= lp . left Margin + lp . right Margin ; } else if ( lp . width >= NUM ) { child Width Mode = Measure Spec . EXACTLY ; child Width Size = lp . width ; } if ( lp . height >= NUM ) { child Height Mode = Measure Spec . EXACTLY ; child Height Size = lp . height ; } else if ( mode Height == Measure Spec . UNSPECIFIED ) { child Height Mode = Measure Spec . UNSPECIFIED ; child Height Size = NUM ; } child . measure ( Measure Spec . make Measure Spec ( child Width Size , child Width Mode ) , Measure Spec . make Measure Spec ( child Height Size , child Height Mode ) ) ; int child Width = child . get Measured Width ( ) + lp . left Margin + lp . right Margin ; if ( line Width + child Width > size Width ) { width = Math . max ( width , line Width ) ; line Width = child Width ; height += line Height ; line Height = child . get Measured Height ( ) + lp . top Margin + lp . bottom Margin ; } else { line Width += child Width ; line Height = Math . max ( line Height , child . get Measured Height ( ) + lp . top Margin + lp . bottom Margin ) ; } if ( last Child ) { width = Math . max ( width , line Width ) ; height += line Height ; } } width += get Padding Left ( ) + get Padding Right ( ) ; set Measured Dimension ( ( mode Width == Measure Spec . EXACTLY ) ? size Width : width , ( mode Height == Measure Spec . EXACTLY ) ? size Height : height ) ; }
public Union Member Description With Error ( IE Object Description delegate , Composed Type Ref composed Type Ref , I Scope [ ] sub Scopes , boolean write Access ) { super ( delegate ) ; this . composed Type Ref = composed Type Ref ; this . sub Scopes = sub Scopes ; max = sub Scopes . length ; this . write Access = write Access ; }
private void read Object ( Object Input Stream oos ) throws IO Exception , Class Not Found Exception { i Instant = ( Date Midnight ) oos . read Object ( ) ; Date Time Field Type type = ( Date Time Field Type ) oos . read Object ( ) ; i Field = type . get Field ( i Instant . get Chronology ( ) ) ; }
public void generate Loot Chest ( World world , Random random , Block Pos pos , int min , int max , I Block State state , Resource Location loot Table ) { world . set Block State ( pos , state , NUM ) ; Tile Entity Chest chest = ( Tile Entity Chest ) world . get Tile Entity ( pos ) ; if ( chest != null ) chest . set Loot Table ( loot Table , random . next Long ( ) ) ; }
private void draw Auto Hit ( Graphics g , Coords hex ) { int base X = ( hex . get X ( ) * ( hex Side [ zoom ] + hex Side By Sin 30 [ zoom ] ) ) + left Margin + hex Side [ zoom ] ; int base Y = ( ( ( NUM * hex . get Y ( ) ) + NUM + ( hex . get X ( ) % NUM ) ) * hex Side By Cos 30 [ zoom ] ) + top Margin ; Color alt = g . get Color ( ) ; g . set Color ( Color . RED ) ; g . draw Oval ( base X - ( unit Size - NUM ) , base Y - ( unit Size - NUM ) , ( NUM * unit Size ) - NUM , ( NUM * unit Size ) - NUM ) ; g . draw Line ( base X - unit Size - NUM , base Y , ( base X - unit Size ) + NUM , base Y ) ; g . draw Line ( base X + unit Size + NUM , base Y , ( base X + unit Size ) - NUM , base Y ) ; g . draw Line ( base X , base Y - unit Size - NUM , base X , ( base Y - unit Size ) + NUM ) ; g . draw Line ( base X , base Y + unit Size + NUM , base X , ( base Y + unit Size ) - NUM ) ; g . set Color ( alt ) ; }
public void remove ( ) throws Recurrence Rule Exception { try { rule . remove ( ) ; } catch ( Generic Entity Exception e ) { throw new Recurrence Rule Exception ( e . get Message ( ) , e ) ; } }
private boolean should Be Escaped ( char c ) { return c < STRING || ( c >= STRING && c < STRING ) || ( c >= STRING && c < STRING ) ; }
public C Event Table Menu ( final J Table table , final List < I Trace Event > traces ) { add Open Function ( Swing Utilities . get Window Ancestor ( table ) , traces ) ; add ( new J Menu Item ( C Action Proxy . proxy ( new C Search Table Action ( Swing Utilities . get Window Ancestor ( table ) , table ) ) ) ) ; add ( new Copy Selection Action ( table ) ) ; }
@ Override public int available ( ) throws IO Exception { return ( out Bytes . length + input Stream . available ( ) ) ; }
public boolean check Error ( ) { return pw . check Error ( ) ; }
public Criteria create Criteria ( ) { Criteria criteria = create Criteria Internal ( ) ; if ( ored Criteria . size ( ) == NUM ) { ored Criteria . add ( criteria ) ; } return criteria ; }
public void add Bug Pattern ( Bug Pattern bug Pattern ) { bug Patterns . add ( bug Pattern ) ; }
public Spider Git Parser ( Spider Param params ) { super ( ) ; this . params = params ; }
public void on Retry ( int retry No ) { Log . d ( LOG TAG , String . format ( STRING , retry No ) ) ; }
protected void analyze Dto Setter Method ( Method method , Method Model method Model ) { method Model . set Setter ( BOOL ) ; Type field Type = method . get Generic Parameter Types ( ) [ NUM ] ; String field Name = get Setter Field Name ( method ) ; field Attributes . put ( field Name , field Type ) ; method Model . set Field Name ( field Name ) ; method Model . set Field Type ( convert Type ( field Type ) ) ; }
public static String load Last Color ( Context context ) { try { Shared Preferences shared Preferences = context . get Shared Preferences ( STRING , Context . MODE PRIVATE ) ; String s = shared Preferences . get String ( SP KEY LAST COLOR , null ) ; Color . parse Color ( s ) ; return s ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return null ; } }
public Bevel Border ( int bevel Type , Color highlight , Color shadow ) { this ( bevel Type , highlight . brighter ( ) , highlight , shadow , shadow . brighter ( ) ) ; }
protected final void refresh Session Layer ( final Location location ) { if ( ! m Refresh Session Pending && is Visible ( ) ) { Log . d ( TAG , STRING ) ; m Refresh Session Pending = BOOL ; trigger Session Objects Update ( null ) ; session Objects Refresh Time = System . current Time Millis ( ) ; session Objects Refreshed At = location ; } else if ( ! is Visible ( ) ) { Log . v ( TAG , STRING ) ; } else { Log . v ( TAG , STRING ) ; } }
public static int m Date Gap ( String day Name ) { Log . d ( STRING , day Name ) ; if ( day Name . equals ( STRING ) ) { return NUM ; } else if ( day Name . equals ( STRING ) ) { return NUM ; } else if ( day Name . equals ( STRING ) ) { return NUM ; } else if ( day Name . equals ( STRING ) ) { return NUM ; } else if ( day Name . equals ( STRING ) ) { return NUM ; } else if ( day Name . equals ( STRING ) ) { return NUM ; } else { return NUM ; } }
public static String remove Additional Party ( Http Servlet Request request , Http Servlet Response response ) { Shopping Cart cart = get Cart Object ( request ) ; String party Id = request . get Parameter ( STRING ) ; String role Type Id [ ] = request . get Parameter Values ( STRING ) ; List < String > event List = new Linked List < String > ( ) ; Locale locale = Util Http . get Locale ( request ) ; int i ; if ( Util Validate . is Empty ( party Id ) || role Type Id . length < NUM ) { request . set Attribute ( STRING , Util Properties . get Message ( resource error , STRING , locale ) ) ; return STRING ; } if ( request . get Attribute ( STRING ) != null ) { List < String > msg = Util Generics . check List ( request . get Attribute ( STRING ) ) ; event List . add All ( msg ) ; } for ( i = NUM ; i < role Type Id . length ; i ++ ) { try { cart . remove Additional Party Role ( party Id , role Type Id [ i ] ) ; } catch ( Exception e ) { Debug . log Info ( e . get Localized Message ( ) , module ) ; event List . add ( e . get Localized Message ( ) ) ; } } request . remove Attribute ( STRING ) ; request . set Attribute ( STRING , event List ) ; return STRING ; }
public Map < String , String [ ] > crop ( final Map < String , String [ ] > original ) { Map < String , String [ ] > result = new Hash Map < String , String [ ] > ( original . size ( ) ) ; for ( Map . Entry < String , String [ ] > entry : original . entry Set ( ) ) { String key = entry . get Key ( ) ; if ( null == key ) { continue ; } String [ ] value = entry . get Value ( ) ; String [ ] converted Value ; if ( null == value ) { converted Value = new String [ NUM ] ; converted Value [ NUM ] = STRING ; } else { boolean cropping Was Needed = BOOL ; converted Value = value ; for ( int i = NUM , l = value . length ; i < l ; i ++ ) { String cur Value = value [ i ] ; String cropping Result = crop ( cur Value ) ; if ( ( cur Value != cropping Result ) & ! cropping Was Needed ) { cropping Was Needed = BOOL ; converted Value = new String [ value . length ] ; System . arraycopy ( value , NUM , converted Value , NUM , i ) ; converted Value [ i ] = cropping Result ; } if ( cropping Was Needed ) { converted Value [ i ] = cropping Result ; } } } result . put ( key , converted Value ) ; } return result ; }
@ Override int look For Selectable Position ( int position , boolean look Down ) { final List Adapter adapter = m Adapter ; if ( adapter == null || is In Touch Mode ( ) ) { return INVALID POSITION ; } final int count = adapter . get Count ( ) ; if ( ! m Are All Items Selectable ) { if ( look Down ) { position = Math . max ( NUM , position ) ; while ( position < count && ! adapter . is Enabled ( position ) ) { position ++ ; } } else { position = Math . min ( position , count - NUM ) ; while ( position >= NUM && ! adapter . is Enabled ( position ) ) { position -- ; } } if ( position < NUM || position >= count ) { return INVALID POSITION ; } return position ; } else { if ( position < NUM || position >= count ) { return INVALID POSITION ; } return position ; } }
@ Override public void delete BCV Helper Volume ( Storage System storage System , Volume volume ) throws Exception { log . info ( String . format ( STRING , storage System . get Id ( ) , volume . get Id ( ) ) ) ; try { String device Name = volume . get Native Id ( ) ; String device Name Without Leading Zeros = device Name . replace All ( STRING , STRING ) ; String query = String . format ( STRING , Smis Constants . CP ELEMENT NAME , Smis Constants . CP DEVICE ID , Smis Constants . CP ELEMENT NAME , device Name Without Leading Zeros ) ; String query Language = STRING ; List < CIM Instance > bcv Volume Instance List = helper . execute Query ( storage System , query , query Language ) ; if ( bcv Volume Instance List == null || bcv Volume Instance List . is Empty ( ) ) { query = String . format ( STRING , Smis Constants . CP ELEMENT NAME , Smis Constants . CP DEVICE ID , Smis Constants . CP ELEMENT NAME , device Name ) ; bcv Volume Instance List = helper . execute Query ( storage System , query , query Language ) ; } String element Name = null ; String native Id = null ; CIM Instance bcv Volume Instance = null ; if ( bcv Volume Instance List != null && ! bcv Volume Instance List . is Empty ( ) ) { bcv Volume Instance = bcv Volume Instance List . get ( NUM ) ; element Name = CIM Property Factory . get Property Value ( bcv Volume Instance , Smis Constants . CP ELEMENT NAME ) ; native Id = CIM Property Factory . get Property Value ( bcv Volume Instance , Smis Constants . CP DEVICE ID ) ; log . info ( String . format ( STRING , element Name , native Id ) ) ; } else { log . warn ( String . format ( STRING , volume . get Id ( ) , volume . get Native Id ( ) ) ) ; return ; } log . info ( String . format ( STRING + native Id ) ) ; String [ ] native Ids = new String [ ] { native Id } ; CIM Object Path config Svc Path = cim Path . get Config Svc Path ( storage System ) ; CIM Argument [ ] in Args = helper . get Delete Volumes Input Arguments ( storage System , native Ids ) ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; String return Elements Method ; if ( storage System . get Using Smis 80 ( ) ) { return Elements Method = Smis Constants . RETURN ELEMENTS TO STORAGE POOL ; } else { return Elements Method = Smis Constants . EMC RETURN TO STORAGE POOL ; } helper . invoke Method Synchronously ( storage System , config Svc Path , return Elements Method , in Args , out Args , null ) ; log . info ( String . format ( STRING + native Id ) ) ; } catch ( Exception ex ) { log . error ( String . format ( STRING , storage System . get Id ( ) , volume . get Id ( ) ) ) ; } }
public void populate Bottom Tab Items ( @ Non Null Bottom Tabs Builder builder ) { if ( m Container . get Child Count ( ) >= MIN BOTTOM NAVIGATION ITEMS ) { check Bottom Item Guidelines ( m Container . get Child Count ( ) ) ; } List < Bottom Navigation Item > build = builder . build ( ) ; for ( int i = NUM ; i < build . size ( ) ; i ++ ) { Bottom Navigation Item item = build . get ( i ) ; item . set Position ( i ) ; add Bottom Navigation Item ( item ) ; } update Bottom Nav Views ( ) ; select Tab View ( ) ; }
public final int skip Bytes ( int count ) throws java . io . IO Exception { int skipped = NUM ; long skip ; while ( skipped < count && ( skip = in . skip ( count - skipped ) ) != NUM ) { skipped += skip ; } return skipped ; }
public General Anderson Darling Test ( List < Double > data , Real Distribution dist ) { if ( dist == null ) { throw new Null Pointer Exception ( ) ; } this . dist = dist ; Collections . sort ( data ) ; this . data = data ; run Test ( ) ; }
private final void insert ( Object text ) { buf . insert ( buf . length ( ) - NUM , STRING ) ; buf . insert ( buf . length ( ) - NUM , text ) ; }
public static void split Textures ( File destination , File texture Pack , double scale , boolean alphas , Progress Callback progress ) throws Exception { if ( destination == null ) throw new Illegal Argument Exception ( STRING ) ; Log . info ( STRING + destination + STRING ) ; if ( ! destination . exists ( ) || ! destination . is Directory ( ) ) { if ( destination . exists ( ) ) throw new Runtime Exception ( STRING ) ; if ( ! destination . mkdir ( ) ) throw new Runtime Exception ( STRING ) ; } get Textures ( texture Pack , scale , progress , alphas , BOOL , destination ) ; }
public void test Builder Root On Construct Multiple Appends ( ) { SQL Exception root = new SQL Exception ( ) ; List < SQL Exception > additional Exceptions = new Array List < SQL Exception > ( ) ; for ( int count = NUM ; count <= NUM ; count ++ ) { additional Exceptions . add ( new SQL Exception ( Integer . to String ( count ) ) ) ; } SQL Exception Chain Builder < SQL Exception > builder = new SQL Exception Chain Builder < SQL Exception > ( root ) ; for ( SQL Exception ex : additional Exceptions ) { builder . append ( ex ) ; } assert True ( STRING , builder . has Exception ( ) ) ; SQL Exception result Exception = builder . get Exception ( ) ; assert Same ( STRING , root , result Exception ) ; check Exception Chain ( result Exception , additional Exceptions ) ; }
protected synchronized String next Cnx Key ( ) { if ( connections Counter == Integer . MAX VALUE ) connections Counter = NUM ; connections Counter ++ ; int rand Long = random . next Int ( Integer . MAX VALUE ) ; return connections Counter + ( rand Long + STRING + ID SUFFIX ) ; }
public static boolean copy File Safe ( final Path src File , final Path dest File ) throws IO Exception { return copy File Safe ( src File , dest File , BOOL ) ; }
public static boolean is Header ( Header header ) { String xten = header . get String Value ( XTENSION ) ; if ( xten == null ) { return BOOL ; } xten = xten . trim ( ) ; return xten . equals ( XTENSION BINTABLE ) || xten . equals ( STRING ) ; }
final void put Float ( int offset , float value ) { unsafe . put Float ( offset + address , value ) ; }
public void doctype Decl ( String root Element , String public Id , String system Id , Augmentations augs ) throws XNI Exception { f In DTD = BOOL ; try { if ( f Lexical Handler != null ) { f Lexical Handler . start DTD ( root Element , public Id , system Id ) ; } } catch ( SAX Exception e ) { throw new XNI Exception ( e ) ; } if ( f Decl Handler != null ) { f Declared Attrs = new Symbol Hash ( ) ; } }
@ Visible For Testing static OMA Entry parse OMA Entry ( String entry ) { int index = entry . index Of ( STRING ) ; long download Id = Long . parse Long ( entry . substring ( NUM , index ) ) ; return new OMA Entry ( download Id , entry . substring ( index + NUM ) ) ; }
public void parse ( ) throws IO Exception { long length = NUM ; try { length = file . length ( ) ; } catch ( IO Exception e ) { throw new IO Exception ( STRING ) ; } try { parse ( STRING , length ) ; } catch ( IO Exception e ) { throw new IO Exception ( STRING ) ; } }
public void test Select Union Itself ( ) throws SQL Exception { String sql = STRING + STRING + Database Creator . CUSTOMERS TABLE + STRING + Database Creator . CUSTOMERS TABLE + STRING + STRING + STRING ; Result Set result = statement . execute Query ( sql ) ; Hash Map < Integer , String > value = new Hash Map < Integer , String > ( ) ; value . put ( NUM , STRING ) ; value . put ( NUM , STRING ) ; value . put ( NUM , STRING ) ; while ( result . next ( ) ) { int key = result . get Int ( STRING ) ; String val = result . get String ( STRING ) ; assert True ( STRING , value . contains Key ( key ) ) ; assert Equals ( STRING , value . get ( key ) , val ) ; value . remove ( key ) ; } assert True ( STRING , value . is Empty ( ) ) ; result . close ( ) ; }
public Reflective Property ( Class < T > property Holder , Class < V > value Type , String name ) { super ( value Type , name ) ; char first Letter = Character . to Upper Case ( name . char At ( NUM ) ) ; String the Rest = name . substring ( NUM ) ; String capitalized Name = first Letter + the Rest ; String getter Name = PREFIX GET + capitalized Name ; try { m Getter = property Holder . get Method ( getter Name , ( Class < ? > [ ] ) null ) ; } catch ( No Such Method Exception e ) { try { m Getter = property Holder . get Declared Method ( getter Name , ( Class < ? > [ ] ) null ) ; m Getter . set Accessible ( BOOL ) ; } catch ( No Such Method Exception e2 ) { getter Name = PREFIX IS + capitalized Name ; try { m Getter = property Holder . get Method ( getter Name , ( Class < ? > [ ] ) null ) ; } catch ( No Such Method Exception e3 ) { try { m Getter = property Holder . get Declared Method ( getter Name , ( Class < ? > [ ] ) null ) ; m Getter . set Accessible ( BOOL ) ; } catch ( No Such Method Exception e4 ) { try { m Field = property Holder . get Field ( name ) ; Class field Type = m Field . get Type ( ) ; if ( ! types Match ( value Type , field Type ) ) { throw new No Such Property Exception ( STRING + field Type + STRING + STRING + value Type + STRING ) ; } return ; } catch ( No Such Field Exception e5 ) { throw new No Such Property Exception ( STRING + STRING + name ) ; } } } } } Class getter Type = m Getter . get Return Type ( ) ; if ( ! types Match ( value Type , getter Type ) ) { throw new No Such Property Exception ( STRING + getter Type + STRING + STRING + value Type + STRING ) ; } String setter Name = PREFIX SET + capitalized Name ; try { m Setter = property Holder . get Declared Method ( setter Name , getter Type ) ; m Setter . set Accessible ( BOOL ) ; } catch ( No Such Method Exception ignored ) { } }
public C Function Type Panel ( final Listener Provider < I Filter Dialog Listener > listeners ) { super ( new Border Layout ( ) ) ; m listeners = listeners ; final J Panel inner Panel = new J Panel ( new Grid Layout ( NUM , NUM ) ) ; inner Panel . add ( build Row ( STRING , m normal Function Checkbox ) ) ; inner Panel . add ( build Row ( STRING , m imported Function Checkbox ) ) ; inner Panel . add ( build Row ( STRING , m library Function Checkbox ) ) ; inner Panel . add ( build Row ( STRING , m thunk Function Checkbox ) ) ; inner Panel . add ( build Row ( STRING , m adjustor Function Checkbox ) ) ; add ( inner Panel , Border Layout . NORTH ) ; set Border ( new Titled Border ( STRING ) ) ; }
public Drag Context ( Node draggable ) { this . node = draggable ; this . go To Foreground On Contact = BOOL ; this . touch Id = NULL ID ; this . activated = BOOL ; this . drag Limits = new Bounding Box ( NUM , NUM , Integer . MAX VALUE , Integer . MAX VALUE ) ; this . drag Threshold = NUM ; this . drag Started = BOOL ; this . relocate Threshold = NUM ; this . drag Init Action = null ; this . drag Finish Action = null ; touch Handler = null ; mouse Handler = null ; draggable . add Event Handler ( Touch Event . ANY , touch Handler ) ; draggable . add Event Handler ( Mouse Event . ANY , mouse Handler ) ; }
protected X509 Certificate [ ] open Certificate ( File certificate File ) { try { File Input Stream is = new File Input Stream ( certificate File ) ; return open Certificate ( is , certificate File . get Name ( ) ) ; } catch ( File Not Found Exception ex ) { J Option Pane . show Message Dialog ( frame , Message Format . format ( res . get String ( STRING ) , certificate File ) , res . get String ( STRING ) , J Option Pane . WARNING MESSAGE ) ; return null ; } }
public Shape Tile Simplex ( Pla Line Int Alist p line alist ) { lines list = new Array List < Pla Line Int > ( p line alist . size ( ) ) ; for ( Pla Line Int a line : p line alist ) lines list . add ( a line ) ; Collections . sort ( lines list ) ; }
public Proper Fraction Format ( Number Format format ) { this ( format , ( Number Format ) format . clone ( ) , ( Number Format ) format . clone ( ) ) ; }
private File create Capture File ( int encoding Type ) { return create Capture File ( encoding Type , STRING ) ; }
public double [ ] [ ] extract Main Set Jacobian ( final ODE State state ) { final double [ ] p = state . get Secondary State ( index ) ; final double [ ] [ ] d Yd Y 0 = new double [ jode . get Dimension ( ) ] [ jode . get Dimension ( ) ] ; int j = NUM ; for ( int i = NUM ; i < jode . get Dimension ( ) ; i ++ ) { System . arraycopy ( p , j , d Yd Y 0 [ i ] , NUM , jode . get Dimension ( ) ) ; j += jode . get Dimension ( ) ; } return d Yd Y 0 ; }
public static String byte To Hex String ( byte [ ] byte Array ) { String Builder builder = new String Builder ( ) ; for ( int i = NUM ; i < byte Array . length ; i ++ ) { int byte Code = byte Array [ i ] & NUM ; if ( byte Code < NUM ) { builder . append ( NUM ) ; } builder . append ( Integer . to Hex String ( byte Code ) ) ; } return builder . to String ( ) ; }
public static void assert Not Equal ( Object expected , Object actual ) { if ( verbose ) { log ( STRING + expected + STRING + actual + STRING ) ; } Test Utils . assert Bool ( ! expected . equals ( actual ) ) ; }
private boolean is Empty ( String value ) { return value . length ( ) == NUM ; }
private void dispose Codec ( Io Session session ) { dispose Encoder ( session ) ; dispose Decoder ( session ) ; dispose Decoder Out ( session ) ; }
public static Object Stream Class lookup Any ( Class < ? > cl ) { return lookup Stream Class ( cl ) ; }
public static void main ( String [ ] args ) { try { int server Port = Integer . parse Int ( System . get Property ( STRING , STRING ) ) ; T Transport transport ; transport = new T Framed Transport ( new T Socket ( STRING , server Port ) ) ; transport . open ( ) ; T Protocol protocol = new T Binary Protocol ( transport ) ; Packet Streamer . Client client = new Packet Streamer . Client ( protocol ) ; send Packets ( client , ( short ) NUM , OF Message Type . PACKET IN , BOOL ) ; log . debug ( STRING ) ; client . terminate Session ( STRING ) ; transport . close ( ) ; } catch ( T Exception x ) { x . print Stack Trace ( ) ; } }
public Configuration Parser ( boolean verify , Class Loader loader ) throws Parser Configuration Exception { factory = Document Builder Factory . new Instance ( ) ; factory . set Validating ( verify ) ; factory . set Namespace Aware ( BOOL ) ; factory . set Expand Entity References ( BOOL ) ; factory . set Coalescing ( BOOL ) ; builder = factory . new Document Builder ( ) ; if ( verify ) builder . set Error Handler ( new XML Error Handler ( ) ) ; if ( loader == null ) throw new Null Pointer Exception ( STRING ) ; }
Test Environment ( System Test Environment system Test Environment , Path working Dir , Path source Dir , Path class Dir , Path jacoco Dir ) { this . system Test Environment = system Test Environment ; this . working Dir = working Dir ; this . source Dir = source Dir ; this . class Dir = class Dir ; this . jacoco Dir = jacoco Dir ; this . test Class Path = system Test Environment . classpath + STRING + class Dir . to String ( ) ; }
public Application create Jmx Application Interactive ( String connection String , String display Name , Environment Provider provider , boolean persistent ) { return create Jmx Application Interactive ( connection String , display Name , provider , persistent , BOOL ) ; }
public static synchronized void remove Provider ( int provider Number ) { Provider p = providers . remove ( provider Number - NUM ) ; providers Names . remove ( p . get Name ( ) ) ; set Need Refresh ( ) ; }
public Object reference Insert ( String reference , Object value ) { String s = null ; if ( value != null ) { s = REFERENCE VALUE ; } else { if ( reference . equals ( STRING ) ) { s = NO REFERENCE VALUE ; } } return s ; }
public Graphic Component ( Graphic Attribute graphic , Decoration decorator , int [ ] chars Lto V , byte [ ] levels , int start , int limit , Affine Transform base Tx ) { if ( limit <= start ) { throw new Illegal Argument Exception ( STRING ) ; } this . graphic = graphic ; this . graphic Advance = graphic . get Advance ( ) ; this . decorator = decorator ; this . cm = create Core Metrics ( graphic ) ; this . base Tx = base Tx ; init Local Ordering ( chars Lto V , levels , start , limit ) ; }
public static boolean has Valid User In Context ( Security Context security Context ) { if ( ( security Context != null ) && ( security Context . get User Principal ( ) instanceof Storage OS User ) ) { return BOOL ; } else { return BOOL ; } }
private void handle End Of Stream ( State state , Inner State inner State ) throws Stop Request { m Info . m Current Bytes = inner State . m Bytes So Far ; mDB . update Download ( m Info ) ; boolean length Mismatched = ( inner State . m Header Content Length != null ) && ( inner State . m Bytes So Far != Integer . parse Int ( inner State . m Header Content Length ) ) ; if ( length Mismatched ) { if ( cannot Resume ( inner State ) ) { throw new Stop Request ( Downloader Service . STATUS CANNOT RESUME , STRING ) ; } else { throw new Stop Request ( get Final Status For Http Error ( state ) , STRING ) ; } } }
public void add ( String keyword , byte id ) { int key = get String Map Key ( keyword ) ; map [ key ] = new Keyword ( keyword . to Char Array ( ) , id , map [ key ] ) ; }
public String to String ( ) { return m Formatter . format ( get Stamp ( ) ) ; }
private String seconds To Time ( int seconds ) { String time = STRING ; String minutes Text = String . value Of ( seconds / NUM ) ; if ( minutes Text . length ( ) == NUM ) minutes Text = STRING + minutes Text ; String seconds Text = String . value Of ( seconds % NUM ) ; if ( seconds Text . length ( ) == NUM ) seconds Text = STRING + seconds Text ; time = minutes Text + STRING + seconds Text ; return time ; }
private void process New Port ( Datapath Id sw , OF Port p ) { if ( is Link Discovery Suppressed ( sw , p ) ) { return ; } IOF Switch iof Switch = switch Service . get Switch ( sw ) ; if ( iof Switch == null ) { return ; } Node Port Tuple npt = new Node Port Tuple ( sw , p ) ; discover ( sw , p ) ; add To Quarantine Queue ( npt ) ; }
public Amqp Receiver ( Amqp Session session , String address , String receiver Id ) { if ( address != null && address . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . user Specified Source = null ; this . session = session ; this . address = address ; this . receiver Id = receiver Id ; }
private void notify Service Map ( Object event Source , long event ID , long seq No , Service ID sid , Service Item item , int transition ) { if ( event Source == null ) return ; synchronized ( service Id Map ) { Proxy Reg reg = null ; Event Reg e Reg = null ; Set set = event Reg Map . entry Set ( ) ; Iterator iter = set . iterator ( ) ; while ( iter . has Next ( ) ) { Map . Entry e = ( Map . Entry ) iter . next ( ) ; e Reg = ( Event Reg ) e . get Value ( ) ; if ( event Source . equals ( e Reg . source ) && ( event ID == e Reg . event ID ) ) { reg = ( Proxy Reg ) e . get Key ( ) ; break ; } } if ( reg == null ) return ; long prev Seq No = e Reg . seq No ; e Reg . seq No = seq No ; Cache Task t ; if ( seq No == ( prev Seq No + NUM ) ) { t = new Notify Event Task ( lookup Cache Class Loader , reg , sid , item , transition , task Seq N ++ ) ; } else { t = new Lookup Task ( lookup Cache Class Loader , reg , task Seq N ++ ) ; if ( logger . is Loggable ( Levels . HANDLED ) ) { String msg = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Object [ ] params = new Object [ ] { reg == null ? null : reg . proxy , item . service , sid , event Source , new Long ( event ID ) , new Long ( prev Seq No ) , new Long ( seq No ) } ; logger . log ( Levels . HANDLED , msg , params ) ; } } cache Task Mgr . add ( t ) ; } }
@ Known Failure ( STRING ) public void test get Columns Table With No Catalog Schema ( ) throws SQL Exception { try { Result Set no Schema Table = meta . get Columns ( STRING , STRING , Database Creator . TEST TABLE 1 , STRING ) ; assert Not Null ( no Schema Table ) ; no Schema Table . last ( ) ; int size = no Schema Table . get Row ( ) ; assert Equals ( STRING , NUM , size ) ; } catch ( SQL Exception e ) { fail ( STRING + e . get Message ( ) ) ; } try { Result Set no Schema Table = meta . get Columns ( STRING , STRING , Database Creator . TEST TABLE 1 , STRING ) ; assert Not Null ( no Schema Table ) ; no Schema Table . last ( ) ; int size = no Schema Table . get Row ( ) ; assert Equals ( STRING , NUM , size ) ; } catch ( SQL Exception e ) { fail ( STRING + e . get Message ( ) ) ; } try { Result Set no Schema Table = meta . get Columns ( STRING , STRING , STRING , STRING ) ; assert Not Null ( no Schema Table ) ; no Schema Table . last ( ) ; int size = no Schema Table . get Row ( ) ; assert Equals ( STRING , NUM , size ) ; } catch ( SQL Exception e ) { fail ( STRING + e . get Message ( ) ) ; } conn . close ( ) ; try { meta . get Columns ( null , null , Database Creator . TEST TABLE 1 , STRING ) ; fail ( STRING ) ; } catch ( SQL Exception e ) { } }
public static byte read Byte ( ) { return scanner . next Byte ( ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return SUCCESS ; default : return null ; } }
public static void d ( String tag , String msg , Object ... args ) { if ( s Level > LEVEL DEBUG ) { return ; } if ( args . length > NUM ) { msg = String . format ( msg , args ) ; } Log . d ( tag , msg ) ; }
public void clear Value Local ( String column Header ) { values . remove ( column Header . to Lower Case ( ) ) ; }
public List close Bucket Advisors ( ) { List primaries Held = Collections . EMPTY LIST ; if ( this . buckets != null ) { for ( int i = NUM ; i < this . buckets . length ; i ++ ) { Proxy Bucket Region pbr = this . buckets [ i ] ; if ( pbr . is Primary ( ) ) { if ( primaries Held == Collections . EMPTY LIST ) { primaries Held = new Array List ( ) ; } primaries Held . add ( Integer . value Of ( i ) ) ; } pbr . close ( ) ; } } return primaries Held ; }
public boolean is Mac Muted ( final String mac ) { final long mute Till = get Mac Unmute Time ( mac ) ; return mute Till > System . current Time Millis ( ) ; }
public abstract void insert Spill Before ( Instruction s , Register r , byte type , int location ) ;
static public Test suite ( ) { return Proxy Suite Helper . suite When Standalone ( Test Sparql Update . class , STRING , new Linked Hash Set < Buffer Mode > ( Arrays . as List ( new Buffer Mode [ ] { Buffer Mode . Transient , Buffer Mode . Disk WORM , Buffer Mode . Mem Store , Buffer Mode . Disk RW } ) ) , Test Mode . quads ) ; }
private synchronized void cleanup Is Complex Type Attribute ( ) { first Attribute = null ; remaining Attributes . clear ( ) ; is Complex Type Attribute = BOOL ; }
public static String left Trim ( final String value ) { validate ( value , NULL STRING PREDICATE , NULL STRING MSG SUPPLIER ) ; return value . replace All ( STRING , STRING ) ; }
public float polar Angle ( ) { return ( float ) Math . to Degrees ( angle ( ) ) ; }
public String check Params Non Negative ( ) { String ret = STRING ; if ( param 1 < NUM ) { ret = ret . concat ( pdf . get Param 1 Name ( ) + STRING ) ; } if ( param 2 < NUM ) { ret = ret . concat ( pdf . get Param 2 Name ( ) + STRING ) ; } if ( upper Bound < NUM ) { ret = ret . concat ( STRING ) ; } if ( lower Bound < NUM ) { ret = ret . concat ( STRING ) ; } return ret ; }
public static boolean validate ( String str , String reg Ex , Debug tmp Debug ) { debug = tmp Debug ; if ( str == null || str . length ( ) == NUM ) { debug . message ( STRING ) ; return BOOL ; } char [ ] value = str . to Char Array ( ) ; int count = value . length ; Set h Set = new Hash Set ( ) ; String Tokenizer st = new String Tokenizer ( reg Ex , SEPERATOR ) ; while ( st . has More Tokens ( ) ) { h Set . add ( st . next Token ( ) ) ; } Iterator itr = h Set . iterator ( ) ; while ( itr . has Next ( ) ) { String obj = ( String ) itr . next ( ) ; if ( process ( value , obj , NUM , count ) > - NUM ) { debug . message ( STRING ) ; return BOOL ; } } return BOOL ; }
public static float turbulence 2 ( float x , float y , float octaves ) { float t = NUM ; for ( float f = NUM ; f <= octaves ; f *= NUM ) t += Math . abs ( noise 2 ( f * x , f * y ) ) / f ; return t ; }
public void add Map Object ( Internal Map Object map Object ) { map Objects . add ( map Object ) ; }
public List < Mock Response > enqueue ( String ... paths ) { if ( paths == null ) { return null ; } List < Mock Response > mock Response List = new Array List < > ( ) ; for ( String path : paths ) { Fixture fixture = Fixture . parse From ( path , parser ) ; Mock Response mock Response = new Mock Response ( ) ; if ( fixture . status Code != NUM ) { mock Response . set Response Code ( fixture . status Code ) ; } if ( fixture . body != null ) { mock Response . set Body ( fixture . body ) ; } if ( fixture . delay != NUM ) { mock Web Server . set Dispatcher ( new Delayed Dispatcher ( fixture . delay , Time Unit . MILLISECONDS ) ) ; } if ( fixture . headers != null ) { for ( String header : fixture . headers ) { mock Response . add Header ( header ) ; } } mock Web Server . enqueue ( mock Response ) ; mock Response List . add ( mock Response ) ; } return mock Response List ; }
@ Override public void end Of Stream ( ) throws Ade Exception { double min Prob = NUM ; if ( m total Interval Count == NUM ) { m total Interval Count = NUM ; } for ( Entry < String , Bernoulli Score . Msg Data > entry : m msg Data . entry Set ( ) ) { final Full Bernoulli Msg Data data = ( Full Bernoulli Msg Data ) entry . get Value ( ) ; data . m prob = ( ( double ) data . m count + NUM ) / ( m total Interval Count + NUM ) ; if ( data . m prob < NUM || data . m prob >= NUM ) { logger . info ( entry . get Key ( ) + STRING + data . m prob + STRING + data . m count + STRING + m total Interval Count + STRING ) ; } if ( data . m prob < min Prob ) { min Prob = data . m prob ; } data . m out Of Cluster Prob = ( ( double ) data . m out Of Cluster Count + NUM ) / ( m total Interval Count + NUM ) ; if ( data . m out Of Cluster Count < min Prob && data . m out Of Cluster Count > NUM ) { min Prob = data . m out Of Cluster Count ; } } for ( Bernoulli Score . Msg Data data Super : m msg Data . values ( ) ) { final Full Bernoulli Msg Data data = ( Full Bernoulli Msg Data ) data Super ; final double probability = data . m prob ; data . m score = - Math . log ( probability ) ; if ( data . m score > NUM ) { data . m score = NUM ; } final double out Of Context Probability = data . m out Of Cluster Prob ; data . m out Of Context Score = - Math . log ( out Of Context Probability ) ; if ( data . m out Of Context Score > NUM ) { data . m out Of Context Score = NUM ; } } m trained = BOOL ; }
public boolean has Next Key Typed ( ) { synchronized ( key Lock ) { return ! keys Typed . is Empty ( ) ; } }
public void add Operator ( Variation operator ) { operators . add ( operator ) ; }
public R params To Multipart Entity ( boolean isrepeatable ) { try { m Http Entity = create Multipart Entity ( isrepeatable ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } return ( R ) this ; }
private static int parse Int ( String value , int begin Index , int end Index ) throws Number Format Exception { if ( begin Index < NUM || end Index > value . length ( ) || begin Index > end Index ) { throw new Number Format Exception ( value ) ; } int i = begin Index ; int result = NUM ; int digit ; if ( i < end Index ) { digit = Character . digit ( value . char At ( i ++ ) , NUM ) ; if ( digit < NUM ) { throw new Number Format Exception ( STRING + value . substring ( begin Index , end Index ) ) ; } result = - digit ; } while ( i < end Index ) { digit = Character . digit ( value . char At ( i ++ ) , NUM ) ; if ( digit < NUM ) { throw new Number Format Exception ( STRING + value . substring ( begin Index , end Index ) ) ; } result *= NUM ; result -= digit ; } return - result ; }
public boolean is Alert Definition Created ( Stat Alert Definition alert Definition ) { synchronized ( ALERT DEFINITIONS ) { return ALERT DEFINITIONS . contains Key ( Integer . value Of ( alert Definition . get Id ( ) ) ) ; } }
public static double logpoisson PD Fm 1 ( double x plus 1 , double lambda ) { if ( Double . is Infinite ( lambda ) ) { return Double . NEGATIVE INFINITY ; } if ( x plus 1 > NUM ) { return raw Log Probability ( x plus 1 - NUM , lambda ) ; } if ( lambda > Math . abs ( x plus 1 - NUM ) * Math Util . LOG 2 * Double . MAX EXPONENT / NUM ) { return - lambda - Gamma Distribution . log Gamma ( x plus 1 ) ; } else { return raw Log Probability ( x plus 1 , lambda ) + Math . log ( x plus 1 / lambda ) ; } }
public void check And Notify ( ) { for ( File Alteration Listener listener : listeners ) { listener . on Start ( this ) ; } File root File = root Entry . get File ( ) ; if ( root File . exists ( ) ) { check And Notify ( root Entry , root Entry . get Children ( ) , list Files ( root File ) ) ; } else if ( root Entry . is Exists ( ) ) { check And Notify ( root Entry , root Entry . get Children ( ) , File Utils . EMPTY FILE ARRAY ) ; } else { } for ( File Alteration Listener listener : listeners ) { listener . on Stop ( this ) ; } }
private double allowable Error ( int rank ) { int size = samples . size ( ) ; final double error = calculate Error ( rank , size ) ; final double min Error = size + NUM ; if ( error < min Error ) { return error ; } return min Error ; }
public Retry Policy with Max Duration ( long max Duration , Time Unit time Unit ) { Assert . not Null ( time Unit , STRING ) ; Assert . state ( time Unit . to Nanos ( max Duration ) > delay . to Nanos ( ) , STRING ) ; this . max Duration = new Duration ( max Duration , time Unit ) ; return this ; }
private int measure Short ( int measure Spec ) { int result ; int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; if ( spec Mode == Measure Spec . EXACTLY ) { result = spec Size ; } else { result = ( int ) ( NUM * m Radius + get Padding Top ( ) + get Padding Bottom ( ) + NUM ) ; if ( spec Mode == Measure Spec . AT MOST ) { result = Math . min ( result , spec Size ) ; } } return result ; }
private static final void cleanup Namespace Nodes ( Zoo Keeper zkc , String root , String self Broker Url ) throws Exception { for ( String node : zkc . get Children ( root , BOOL ) ) { String current Path = root + STRING + node ; List < String > children = zkc . get Children ( current Path , BOOL ) ; if ( children . size ( ) == NUM ) { cleanup Single Namespace Node ( zkc , current Path , self Broker Url ) ; } else { cleanup Namespace Nodes ( zkc , current Path , self Broker Url ) ; } } }
String validate Logix Reference ( String name ) { Logix l = null ; if ( name != null ) { if ( name . length ( ) > NUM ) { l = logix Manager . get By User Name ( name ) ; if ( l != null ) { return name ; } } l = logix Manager . get By System Name ( name ) ; } if ( l == null ) { message Invalid Action Item Name ( name , STRING ) ; return null ; } return name ; }
protected void clear Menu Selection ( ) { popup Menu Group . clear Selection ( ) ; update Selection Status ( ) ; }
public double distance ( Lat Lng ll ) { double er = NUM ; double lat From = Math . to Radians ( get Lat ( ) ) ; double lat To = Math . to Radians ( ll . get Lat ( ) ) ; double lng From = Math . to Radians ( get Lng ( ) ) ; double lng To = Math . to Radians ( ll . get Lng ( ) ) ; double d = Math . acos ( Math . sin ( lat From ) * Math . sin ( lat To ) + Math . cos ( lat From ) * Math . cos ( lat To ) * Math . cos ( lng To - lng From ) ) * er ; return d ; }
@ Override public Integer [ ] apply Controls To Impact ( int risk Type , Cn A Tree Element asset , Integer impact C , Integer impact I , Integer impact A ) { if ( risk Type == RISK PRE CONTROLS ) { return null ; } asset = Retriever . check Retrieve Links ( asset , BOOL ) ; Map < Cn A Tree Element , Cn A Link > linked Elements = Cn A Link . get Linked Elements ( asset , Control . TYPE ID ) ; Integer impact C 0 = Integer . value Of ( impact C . int Value ( ) ) ; Integer impact I 0 = Integer . value Of ( impact I . int Value ( ) ) ; Integer impact A 0 = Integer . value Of ( impact A . int Value ( ) ) ; switch ( risk Type ) { case RISK WITH IMPLEMENTED CONTROLS : for ( Cn A Tree Element control : linked Elements . key Set ( ) ) { control = Retriever . check Retrieve Element ( control ) ; if ( Control . is Implemented ( control . get Entity ( ) ) ) { impact C 0 -= control . get Numeric Property ( I Risk Analysis Service . PROP CONTROL EFFECT C ) ; impact I 0 -= control . get Numeric Property ( I Risk Analysis Service . PROP CONTROL EFFECT I ) ; impact A 0 -= control . get Numeric Property ( I Risk Analysis Service . PROP CONTROL EFFECT A ) ; } } break ; case RISK WITH ALL CONTROLS : for ( Cn A Tree Element control : linked Elements . key Set ( ) ) { control = Retriever . check Retrieve Element ( control ) ; impact C 0 -= control . get Numeric Property ( I Risk Analysis Service . PROP CONTROL EFFECT C ) ; impact I 0 -= control . get Numeric Property ( I Risk Analysis Service . PROP CONTROL EFFECT I ) ; impact A 0 -= control . get Numeric Property ( I Risk Analysis Service . PROP CONTROL EFFECT A ) ; } break ; case RISK WITHOUT NA CONTROLS : for ( Cn A Tree Element control : linked Elements . key Set ( ) ) { control = Retriever . check Retrieve Element ( control ) ; if ( Control . is Planned ( control . get Entity ( ) ) ) { impact C 0 -= control . get Numeric Property ( I Risk Analysis Service . PROP CONTROL EFFECT C ) ; impact I 0 -= control . get Numeric Property ( I Risk Analysis Service . PROP CONTROL EFFECT I ) ; impact A 0 -= control . get Numeric Property ( I Risk Analysis Service . PROP CONTROL EFFECT A ) ; } } break ; default : break ; } impact C 0 = ( impact C 0 . int Value ( ) < NUM ) ? Integer . value Of ( NUM ) : impact C 0 ; impact I 0 = ( impact I 0 . int Value ( ) < NUM ) ? Integer . value Of ( NUM ) : impact I 0 ; impact A 0 = ( impact A 0 . int Value ( ) < NUM ) ? Integer . value Of ( NUM ) : impact A 0 ; return new Integer [ ] { impact C 0 , impact I 0 , impact A 0 } ; }
public static String encode ( String encode ) { String Builder str = new String Builder ( encode ) ; String key ; int i = NUM ; while ( i < str . length ( ) ) { key = find Value ( str . char At ( i ) ) ; if ( key != null ) { str . replace ( i , i + NUM , key ) ; i += key . length ( ) ; } else { i ++ ; } } return str . to String ( ) ; }
protected static Boolean try To Lock ( String service Name ) { Distributed Lock Service service = Distributed Lock Service . get Service Named ( service Name ) ; boolean locked = service . lock ( STRING , NUM , - NUM ) ; if ( locked ) { service . unlock ( STRING ) ; } return Boolean . value Of ( locked ) ; }
public int hash Code ( ) { Lat Lon Point llp = get Location ( ) ; int hc 1 = Float . float To Int Bits ( llp . get Latitude ( ) ) ; int hc 2 = Float . float To Int Bits ( llp . get Longitude ( ) ) ; return hc 1 ^ ( hc 2 << NUM ) ^ ( hc 2 > > > NUM ) ; }
private X Path Factory load From Services File ( String uri , String resource Name , Input Stream in ) { if ( debug ) debug Println ( STRING + resource Name ) ; Buffered Reader rd ; try { rd = new Buffered Reader ( new Input Stream Reader ( in , STRING ) , DEFAULT LINE LENGTH ) ; } catch ( java . io . Unsupported Encoding Exception e ) { rd = new Buffered Reader ( new Input Stream Reader ( in ) , DEFAULT LINE LENGTH ) ; } String factory Class Name ; X Path Factory result Factory = null ; while ( BOOL ) { try { factory Class Name = rd . read Line ( ) ; } catch ( IO Exception x ) { break ; } if ( factory Class Name != null ) { int hash Index = factory Class Name . index Of ( STRING ) ; if ( hash Index != - NUM ) { factory Class Name = factory Class Name . substring ( NUM , hash Index ) ; } factory Class Name = factory Class Name . trim ( ) ; if ( factory Class Name . length ( ) == NUM ) { continue ; } try { X Path Factory found Factory = create Instance ( factory Class Name ) ; if ( found Factory . is Object Model Supported ( uri ) ) { result Factory = found Factory ; break ; } } catch ( Exception ignored ) { } } else { break ; } } Io Utils . close Quietly ( rd ) ; return result Factory ; }
private synchronized void stop ( ) { while ( m activities . size ( ) > NUM ) { Activity a = ( Activity ) m activities . get ( m activities . size ( ) - NUM ) ; a . cancel ( ) ; } set Running ( BOOL ) ; notify ( ) ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String child Data ; int child Length ; java . util . List result = new java . util . Array List ( ) ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; child . delete Data ( NUM , NUM ) ; child Data = child . get Data ( ) ; assert Equals ( STRING , STRING , child Data ) ; child Length = ( int ) child . get Length ( ) ; assert Equals ( STRING , NUM , child Length ) ; }
public Rhythm Group make Group ( String title ) { final Rhythm Group group = new Rhythm Group ( ) ; group . m Title = title ; group . m Index = m Rhythm Groups . size ( ) ; group . m Control = this ; m Rhythm Groups . add ( group ) ; if ( m Current Notification Group Index == NOTIFICATION NO GROUPS ) { m Current Notification Group Index = NUM ; request Notification Update ( ) ; } return group ; }
public Char Sequence sub Sequence ( int start , int end ) { return substring ( start , end ) ; }
public void test Multiply Math Context Diff Scale Pos Neg ( ) { String a = STRING ; int a Scale = NUM ; String b = STRING ; int b Scale = - NUM ; String c = STRING ; int c Scale = - NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; Math Context mc = new Math Context ( NUM , Rounding Mode . HALF UP ) ; Big Decimal result = a Number . multiply ( b Number , mc ) ; assert Equals ( STRING , c , result . to String ( ) ) ; assert Equals ( STRING , c Scale , result . scale ( ) ) ; }
public void write To ( final Output Stream out ) throws IO Exception { for ( final Block block : blocks ) { out . write ( block . data , NUM , block . limit ) ; } }
public void test Merge One Servlet Into Document With Same Servlet And Param ( ) throws Exception { String src Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge ( merge Web Xml ) ; assert True ( Web Xml Utils . has Servlet ( src Web Xml , STRING ) ) ; List < String > init Params = Web Xml Utils . get Servlet Init Param Names ( src Web Xml , STRING ) ; assert Equals ( NUM , init Params . size ( ) ) ; assert Equals ( STRING , init Params . get ( NUM ) ) ; assert Equals ( STRING , Web Xml Utils . get Servlet Init Param ( src Web Xml , STRING , STRING ) ) ; }
public KMP ( String pat ) { this . R = NUM ; this . pat = pat ; int m = pat . length ( ) ; dfa = new int [ R ] [ m ] ; dfa [ pat . char At ( NUM ) ] [ NUM ] = NUM ; for ( int x = NUM , j = NUM ; j < m ; j ++ ) { for ( int c = NUM ; c < R ; c ++ ) dfa [ c ] [ j ] = dfa [ c ] [ x ] ; dfa [ pat . char At ( j ) ] [ j ] = j + NUM ; x = dfa [ pat . char At ( j ) ] [ x ] ; } }
private void load Configuration ( ) { m Client Id = m Configuration Manager . get String ( PREF CLIENT ID , STRING ) ; m Client Key = m Configuration Manager . get String ( PREF CLIENT KEY , STRING ) ; Timber . i ( STRING ) ; }
public static void put Boolean Field ( Object obj , long field Off , boolean val ) { UNSAFE . put Boolean ( obj , field Off , val ) ; }
public void sort ( Comparator < File > comparator ) { synchronized ( m Lock ) { Collections . sort ( file List , comparator ) ; } notify Data Set Changed ( ) ; }
public Accept Request Interceptor ( final String accept ) { this . accept = accept ; check Argument ( ! accept . is Empty ( ) , STRING ) ; }
public void test get Lowest Set Bit Neg ( ) { byte a Bytes [ ] = { - NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = - NUM ; int i Number = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; int result = a Number . get Lowest Set Bit ( ) ; assert True ( STRING , result == i Number ) ; }
private int tailing Non Newline ( String str , int off , int len ) { for ( int cnt = NUM ; cnt < len ; cnt ++ ) { final int pos = off + ( len - NUM ) - cnt ; if ( str . char At ( pos ) == UNIX NEWLINE ) { return cnt ; } if ( str . char At ( pos ) == CARRIAGE RETURN ) { return cnt ; } } return len ; }
@ Override public void reset ( ) { clear ( ) ; bnodes = null ; bnodes Total Count = NUM ; bnodes Resolved Count = NUM ; deferred Stmts = null ; reified Stmts = null ; if ( queue != null ) { final Future < Void > ft = this . ft ; if ( ft != null ) { ft . cancel ( BOOL ) ; this . ft = null ; } queue . clear ( ) ; } }
public static byte [ ] read Data ( final Input Stream input ) throws IO Exception { final byte [ ] input Buffer = new byte [ BUFFER LENGTH ] ; final Byte Array Output Stream byte Output = new Byte Array Output Stream ( BUFFER LENGTH ) ; int bytes Read ; while ( ( bytes Read = input . read ( input Buffer ) ) != - NUM ) { byte Output . write ( input Buffer , NUM , bytes Read ) ; } final byte [ ] r = byte Output . to Byte Array ( ) ; byte Output . close ( ) ; return r ; }
public static String make Log Tag ( Class cls ) { return make Log Tag ( cls . get Simple Name ( ) ) ; }
@ Override public synchronized void println ( ) { print ( STRING ) ; }
public boolean is Crash ( String test Path ) { for ( String prefix : get Prefixes ( test Path ) ) { if ( m Crash List . contains ( prefix ) ) { return BOOL ; } } return BOOL ; }
public Abstract Site Map parse Site Map ( String content Type , byte [ ] content , URL url ) throws Unknown Format Exception , IO Exception { Media Type media Type = Media Type . parse ( content Type ) ; while ( media Type != null && ! media Type . equals ( Media Type . OCTET STREAM ) ) { if ( XML MEDIA TYPES . contains ( media Type ) ) { return process Xml ( url , content ) ; } else if ( TEXT MEDIA TYPES . contains ( media Type ) ) { return process Text ( url . to String ( ) , content ) ; } else if ( GZ MEDIA TYPES . contains ( media Type ) ) { return process Gzip ( url , content ) ; } else { media Type = MEDIA TYPE REGISTRY . get Supertype ( media Type ) ; return parse Site Map ( media Type . to String ( ) , content , url ) ; } } throw new Unknown Format Exception ( STRING + content Type + STRING + url + STRING ) ; }
private void create Default Managed Object ( Managed Object Definition < ? , ? > d , Managed Object < ? > child , Default Managed Object < ? , ? > dmo ) { for ( Property Definition < ? > pd : d . get All Property Definitions ( ) ) { set Property Values ( child , pd , dmo ) ; } try { child . commit ( ) ; } catch ( Managed Object Already Exists Exception e ) { moaee = e ; } catch ( Missing Mandatory Properties Exception e ) { mmpe = e ; } catch ( Concurrent Modification Exception e ) { cme = e ; } catch ( Operation Rejected Exception e ) { ore = e ; } catch ( Ldap Exception e ) { ere = e ; } }
static String omit Quotes If Exist ( String str ) { if ( str == null ) { return null ; } if ( ( ( str . char At ( NUM ) == STRING ) || ( str . char At ( NUM ) == STRING ) ) && ( str . length ( ) >= NUM ) ) { str = str . substring ( NUM , str . length ( ) - NUM ) ; } return str ; }
public static byte [ ] decode ( byte [ ] input , int offset , int len , int flags ) { Decoder decoder = new Decoder ( flags , new byte [ len * NUM / NUM ] ) ; if ( ! decoder . process ( input , offset , len , BOOL ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( decoder . op == decoder . output . length ) { return decoder . output ; } byte [ ] temp = new byte [ decoder . op ] ; System . arraycopy ( decoder . output , NUM , temp , NUM , decoder . op ) ; return temp ; }
private static boolean can Complete Node Path ( Entity start , Entity end , Array List < Entity > network , int start Position , List < ECM Info > all ECM Info ) { Entity spotter = network . get ( start Position ) ; ECM Info spotter Start ECM = Compute ECM . get ECM Effects ( spotter , start . get Position ( ) , spotter . get Position ( ) , BOOL , all ECM Info ) ; boolean is C 3 B Defeated = start . has Boosted C 3 ( ) && ( spotter Start ECM != null ) && spotter Start ECM . is Angel ECM ( ) ; boolean is Nova Defeated = start . has Nova CEWS ( ) && ( spotter Start ECM != null ) && spotter Start ECM . is Nova ECM ( ) ; boolean is C 3 Defeated = ! ( start . has Boosted C 3 ( ) || start . has Nova CEWS ( ) ) && ( spotter Start ECM != null ) && spotter Start ECM . is ECM ( ) ; if ( is C 3 B Defeated || is Nova Defeated || is C 3 Defeated ) { return BOOL ; } ECM Info spotter End ECM = Compute ECM . get ECM Effects ( spotter , spotter . get Position ( ) , end . get Position ( ) , BOOL , all ECM Info ) ; is C 3 B Defeated = start . has Boosted C 3 ( ) && ( spotter End ECM != null ) && spotter End ECM . is Angel ECM ( ) ; is Nova Defeated = start . has Nova CEWS ( ) && ( spotter End ECM != null ) && spotter End ECM . is Nova ECM ( ) ; is C 3 Defeated = ! ( start . has Boosted C 3 ( ) || start . has Nova CEWS ( ) ) && ( spotter End ECM != null ) && spotter End ECM . is ECM ( ) ; if ( ! ( is C 3 B Defeated || is Nova Defeated || is C 3 Defeated ) ) { return BOOL ; } for ( ++ start Position ; start Position < network . size ( ) ; start Position ++ ) { if ( Compute . can Complete Node Path ( spotter , end , network , start Position , all ECM Info ) ) { return BOOL ; } } return BOOL ; }
static void make 72 Safe ( String Buffer line ) { int length = line . length ( ) ; if ( length > NUM ) { int index = NUM ; while ( index < length - NUM ) { line . insert ( index , STRING ) ; index += NUM ; length += NUM ; } } return ; }
@ Override public int last ( ) { Character Iterator t = get Text ( ) ; t . set Index ( t . get End Index ( ) ) ; return t . get Index ( ) ; }
public static I Status validate Method Name ( String name ) { return validate Method Name ( name , Compiler Options . VERSION 1 3 , Compiler Options . VERSION 1 3 ) ; }
public static void register Protocol ( final String id , final Protocol protocol ) { if ( id == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( protocol == null ) { throw new Illegal Argument Exception ( STRING ) ; } PROTOCOLS . put ( id , protocol ) ; }
public byte receive One Byte ( ) { Log . d ( TAG , STRING ) ; try { acquire Lock ( ) ; m Server Socket . receive ( m Receive Packet ) ; Log . d ( TAG , STRING + ( NUM + m Receive Packet . get Data ( ) [ NUM ] ) ) ; return m Receive Packet . get Data ( ) [ NUM ] ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } return Byte . MIN VALUE ; }
public static String link HTML ( String text ) { if ( text == null || text . length ( ) == NUM ) { return STRING ; } boolean http = text . index Of ( STRING ) != - NUM ; boolean www = text . index Of ( STRING ) != - NUM ; boolean email = text . index Of ( STRING ) != - NUM ; if ( ! http && ! www && ! email ) { return text ; } if ( text . index Of ( STRING ) != - NUM && text . index Of ( STRING ) != - NUM ) { return text ; } if ( http ) { Matcher matcher = http Regex . matcher ( text ) ; String Buffer sb = new String Buffer ( ) ; while ( matcher . find ( ) ) { String url = matcher . group ( ) ; if ( url . index Of ( STRING ) != - NUM || url . index Of ( STRING ) != - NUM || url . index Of ( STRING ) != - NUM || url . index Of ( STRING ) != - NUM ) { url = STRING + url + STRING + url + STRING ; } else if ( url . index Of ( STRING ) != - NUM || url . index Of ( STRING ) != - NUM || url . index Of ( STRING ) != - NUM ) { url = STRING + url + STRING + url + STRING ; } else if ( url . index Of ( STRING ) != - NUM || url . index Of ( STRING ) != - NUM ) { url = STRING + url + STRING + url + STRING ; } else { url = STRING + url + STRING + url + STRING ; } matcher . append Replacement ( sb , url ) ; } matcher . append Tail ( sb ) ; text = sb . to String ( ) ; } else if ( www ) { Matcher matcher = www Regex . matcher ( text ) ; String Buffer sb = new String Buffer ( ) ; while ( matcher . find ( ) ) { String url = matcher . group ( ) ; matcher . append Replacement ( sb , STRING + url + STRING + url + STRING ) ; } matcher . append Tail ( sb ) ; text = sb . to String ( ) ; } if ( email ) { Matcher matcher = email Regex . matcher ( text ) ; String Buffer sb = new String Buffer ( ) ; while ( matcher . find ( ) ) { String address = matcher . group ( ) ; matcher . append Replacement ( sb , STRING + address + STRING + address + STRING ) ; } matcher . append Tail ( sb ) ; text = sb . to String ( ) ; } return text ; }
public static int hash ( String key , int bit Size , String input , String hash Type ) { int bit Limited Hash ; try { Message Digest md = Message Digest . get Instance ( hash Type ) ; byte [ ] array = md . digest ( input . get Bytes ( ) ) ; int hash Int = from Byte Array ( array ) ; bit Limited Hash = hash Int ; if ( bit Size < NUM ) { bit Limited Hash = ( NUM > > > ( NUM - bit Size ) ) & hash Int ; } logger . debug ( STRING + hash Int + STRING + bit Limited Hash ) ; } catch ( No Such Algorithm Exception e ) { logger . info ( e . to String ( ) ) ; bit Limited Hash = hash ( key , bit Size , input ) ; } return bit Limited Hash ; }
private OF Factory compute Initial Factory ( Set < OF Version > of Versions ) { if ( of Versions == null || of Versions . is Empty ( ) ) { throw new Illegal State Exception ( STRING ) ; } OF Version highest = null ; for ( OF Version v : of Versions ) { if ( highest == null ) { highest = v ; } else if ( v . compare To ( highest ) > NUM ) { highest = v ; } } return OF Factories . get Factory ( highest ) ; }
private void load Jetty Configuration ( @ Nullable URL cfg Url ) throws Ignite Checked Exception { if ( cfg Url == null ) { Http Configuration http Cfg = new Http Configuration ( ) ; http Cfg . set Secure Scheme ( STRING ) ; http Cfg . set Secure Port ( NUM ) ; http Cfg . set Send Server Version ( BOOL ) ; http Cfg . set Send Date Header ( BOOL ) ; String srv Port Str = System . get Property ( IGNITE JETTY PORT , STRING ) ; int srv Port ; try { srv Port = Integer . parse Int ( srv Port Str ) ; } catch ( Number Format Exception ignore ) { throw new Ignite Checked Exception ( STRING + STRING + srv Port Str ) ; } http Srv = new Server ( new Queued Thread Pool ( NUM , NUM ) ) ; Server Connector srv Conn = new Server Connector ( http Srv , new Http Connection Factory ( http Cfg ) ) ; srv Conn . set Host ( System . get Property ( IGNITE JETTY HOST , STRING ) ) ; srv Conn . set Port ( srv Port ) ; srv Conn . set Idle Timeout ( NUM ) ; srv Conn . set Reuse Address ( BOOL ) ; http Srv . add Connector ( srv Conn ) ; http Srv . set Stop At Shutdown ( BOOL ) ; } else { Xml Configuration cfg ; try { cfg = new Xml Configuration ( cfg Url ) ; } catch ( File Not Found Exception e ) { throw new Ignite Spi Exception ( STRING + cfg Url , e ) ; } catch ( SAX Exception e ) { throw new Ignite Spi Exception ( STRING + cfg Url , e ) ; } catch ( IO Exception e ) { throw new Ignite Spi Exception ( STRING + cfg Url , e ) ; } catch ( Exception e ) { throw new Ignite Spi Exception ( STRING + cfg Url , e ) ; } try { http Srv = ( Server ) cfg . configure ( ) ; } catch ( Exception e ) { throw new Ignite Checked Exception ( STRING , e ) ; } } assert http Srv != null ; http Srv . set Handler ( jetty Hnd ) ; override ( get Jetty Connector ( ) ) ; }
public byte [ ] encode Frame ( ) { int length = this . payload . length + frame Length Overhead ; if ( this . payload . length > NUM ) { length += NUM ; } else if ( this . payload . length >= NUM ) { length += NUM ; } Byte Buffer buffer = Byte Buffer . allocate ( length ) ; append Fin And Op Code ( buffer , this . opcode , this . fin ) ; byte mask [ ] = generate Masking Key ( ) ; append Length And Mask ( buffer , this . payload . length , mask ) ; for ( int i = NUM ; i < this . payload . length ; i ++ ) { buffer . put ( ( byte ) ( this . payload [ i ] ^= mask [ i % NUM ] ) ) ; } buffer . flip ( ) ; return buffer . array ( ) ; }
public static void preload Icon ( Context context , Component Name component Name , Bitmap icon , int dpi ) { try { Package Manager package Manager = context . get Package Manager ( ) ; package Manager . get Activity Icon ( component Name ) ; return ; } catch ( Package Manager . Name Not Found Exception e ) { } final String key = component Name . flatten To String ( ) ; File Output Stream resource File = null ; try { resource File = context . open File Output ( get Resource Filename ( component Name ) , Context . MODE PRIVATE ) ; Byte Array Output Stream os = new Byte Array Output Stream ( ) ; if ( icon . compress ( android . graphics . Bitmap . Compress Format . PNG , NUM , os ) ) { byte [ ] buffer = os . to Byte Array ( ) ; resource File . write ( buffer , NUM , buffer . length ) ; } else { Log . w ( TAG , STRING + key ) ; return ; } } catch ( File Not Found Exception e ) { Log . w ( TAG , STRING + key , e ) ; } catch ( IO Exception e ) { Log . w ( TAG , STRING + key , e ) ; } finally { if ( resource File != null ) { try { resource File . close ( ) ; } catch ( IO Exception e ) { Log . d ( TAG , STRING + key , e ) ; } } } }
public void normalize ( ) { String Builder sb = new String Builder ( ) ; for ( String v : values ) { sb . append ( v ) ; } values . clear ( ) ; values . add ( sb . to String ( ) ) ; compacted = BOOL ; }
public void add Attribute ( String key , String value ) { extra Session Attributes . put ( key , value ) ; }
String capitalise ( final String s ) { if ( s . length ( ) == NUM ) { return s ; } final String Buffer s1 = new String Buffer ( s ) ; if ( Character . is Lower Case ( s1 . char At ( NUM ) ) ) { s1 . set Char At ( NUM , Character . to Upper Case ( s1 . char At ( NUM ) ) ) ; } for ( int j = NUM ; j < s1 . length ( ) ; j ++ ) { if ( Character . is Upper Case ( s1 . char At ( j ) ) ) { s1 . set Char At ( j , Character . to Lower Case ( s1 . char At ( j ) ) ) ; } } return s1 . to String ( ) ; }
public void recompose ( Vector recomposable Elements ) throws Transformer Exception { int n = get Include Count Composed ( ) ; for ( int i = - NUM ; i < n ; i ++ ) { Stylesheet included = get Include Composed ( i ) ; int s = included . get Output Count ( ) ; for ( int j = NUM ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Output ( j ) ) ; } s = included . get Attribute Set Count ( ) ; for ( int j = NUM ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Attribute Set ( j ) ) ; } s = included . get Decimal Format Count ( ) ; for ( int j = NUM ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Decimal Format ( j ) ) ; } s = included . get Key Count ( ) ; for ( int j = NUM ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Key ( j ) ) ; } s = included . get Namespace Alias Count ( ) ; for ( int j = NUM ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Namespace Alias ( j ) ) ; } s = included . get Template Count ( ) ; for ( int j = NUM ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Template ( j ) ) ; } s = included . get Variable Or Param Count ( ) ; for ( int j = NUM ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Variable Or Param ( j ) ) ; } s = included . get Strip Space Count ( ) ; for ( int j = NUM ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Strip Space ( j ) ) ; } s = included . get Preserve Space Count ( ) ; for ( int j = NUM ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Preserve Space ( j ) ) ; } } }
private Geometry union Actual ( Geometry g0 , Geometry g1 ) { return restrict To Polygons ( g0 . union ( g1 ) ) ; }
public boolean supports ( @ Magic Constant ( flags From Class = Features . class ) int capability ) { I Android Target target = get Target ( ) ; if ( target != null ) { return Render Service . supports Capability ( get Module ( ) , target , capability ) ; } return BOOL ; }
@ Override public void transaction Aborted ( ) { if ( listeners . is Empty ( ) ) { records . reset ( ) ; } else { records . flush ( ) ; listeners . for Each ( null ) ; } }
@ Override public boolean add ( E o ) { if ( null == o ) { throw new Null Pointer Exception ( ) ; } if ( offer ( o ) ) { return BOOL ; } throw new Illegal State Exception ( ) ; }
public Standard Crosshair Label Generator ( ) { this ( STRING , Number Format . get Number Instance ( ) ) ; }
private URI create Ethernet Storage Port ( Map < String , Object > key Map , Storage Port port , String name , String port Instance ID , List < Storage Port > new Ports , List < Storage Port > existing Ports ) throws IO Exception { Storage Port portin Memory = ( Storage Port ) key Map . get ( port Instance ID ) ; if ( null == port ) { portin Memory . set Port Network Id ( name ) ; portin Memory . set Port End Point ID ( name ) ; String port Native Guid = Native GUID Generator . generate Native Guid ( db Client , portin Memory ) ; portin Memory . set Native Guid ( port Native Guid ) ; portin Memory . set Label ( port Native Guid ) ; db Client . create Object ( portin Memory ) ; new Ports . add ( portin Memory ) ; return portin Memory . get Id ( ) ; } else { port . set Port Name ( portin Memory . get Port Name ( ) ) ; port . set Port Speed ( portin Memory . get Port Speed ( ) ) ; port . set Port End Point ID ( name ) ; port . set Compatibility Status ( portin Memory . get Compatibility Status ( ) ) ; port . set Discovery Status ( portin Memory . get Discovery Status ( ) ) ; port . set Operational Status ( portin Memory . get Operational Status ( ) ) ; port . set Port Type ( portin Memory . get Port Type ( ) ) ; db Client . persist Object ( port ) ; existing Ports . add ( port ) ; return port . get Id ( ) ; } }
default int add ( Item stack ) { int items Left = stack . count ( ) ; for ( int i = NUM ; i < size ( ) ; i ++ ) { items Left = add ( i , stack . with Amount ( items Left ) ) ; } if ( items Left != stack . count ( ) ) { mark Changed ( ) ; } return items Left ; }
public void mark ( long n ) { count . add And Get ( n ) ; m1 Rate . update ( n ) ; m5 Rate . update ( n ) ; m15 Rate . update ( n ) ; }
public String [ ] read All Lines ( ) { Array List < String > lines = new Array List < String > ( ) ; while ( has Next Line ( ) ) { lines . add ( read Line ( ) ) ; } return lines . to Array ( new String [ NUM ] ) ; }
public static boolean is Absolute Path ( String system Id ) { if ( system Id == null ) return BOOL ; final File file = new File ( system Id ) ; return file . is Absolute ( ) ; }
protected Qualified Item [ ] parse Qualified Items ( final Version Spec default Version , final boolean allow Version Range , final int start Index ) { return parse Qualified Items ( get Free Arguments ( ) , default Version , allow Version Range , start Index ) ; }
public void change Change Enabled ( Change Enabled State state ) throws Refactoring Exception { Refactoring Session session = get Refactoring Session ( state . get Session Id ( ) ) ; session . update Change Enabled ( state . get Change Id ( ) , state . is Enabled ( ) ) ; }
public Update Builder bind Uris ( String from , Collection < String > uris ) { return bind Uris ( from , uris , STRING ) ; }
public void populate All ( ) throws General Exception { for ( Service Eca Action eca Action : service Eca Rule . get Eca Action List ( ) ) { services Called By This Service Eca . add ( aif . get Service Artifact Info ( eca Action . get Service Name ( ) ) ) ; Util Misc . add To Sorted Set In Map ( this , aif . all Service Eca Infos Referring To Service Name , eca Action . get Service Name ( ) ) ; } }
private int [ ] find Nearest Area ( int pixel X , int pixel Y , int min Span X , int min Span Y , int span X , int span Y , boolean ignore Occupied , int [ ] result , int [ ] result Span ) { lazy Init Temp Rect Stack ( ) ; pixel X -= ( m Cell Width + m Width Gap ) * ( span X - NUM ) / NUM ; pixel Y -= ( m Cell Height + m Height Gap ) * ( span Y - NUM ) / NUM ; final int [ ] best XY = result != null ? result : new int [ NUM ] ; double best Distance = Double . MAX VALUE ; final Rect best Rect = new Rect ( - NUM , - NUM , - NUM , - NUM ) ; final Stack < Rect > valid Regions = new Stack < Rect > ( ) ; final int count X = m Count X ; final int count Y = m Count Y ; if ( min Span X <= NUM || min Span Y <= NUM || span X <= NUM || span Y <= NUM || span X < min Span X || span Y < min Span Y ) { return best XY ; } for ( int y = NUM ; y < count Y - ( min Span Y - NUM ) ; y ++ ) { inner : for ( int x = NUM ; x < count X - ( min Span X - NUM ) ; x ++ ) { int y Size = - NUM ; int x Size = - NUM ; if ( ignore Occupied ) { for ( int i = NUM ; i < min Span X ; i ++ ) { for ( int j = NUM ; j < min Span Y ; j ++ ) { if ( m Occupied [ x + i ] [ y + j ] ) { continue inner ; } } } x Size = min Span X ; y Size = min Span Y ; boolean inc X = BOOL ; boolean hit Max X = x Size >= span X ; boolean hit Max Y = y Size >= span Y ; while ( ! ( hit Max X && hit Max Y ) ) { if ( inc X && ! hit Max X ) { for ( int j = NUM ; j < y Size ; j ++ ) { if ( x + x Size > count X - NUM || m Occupied [ x + x Size ] [ y + j ] ) { hit Max X = BOOL ; } } if ( ! hit Max X ) { x Size ++ ; } } else if ( ! hit Max Y ) { for ( int i = NUM ; i < x Size ; i ++ ) { if ( y + y Size > count Y - NUM || m Occupied [ x + i ] [ y + y Size ] ) { hit Max Y = BOOL ; } } if ( ! hit Max Y ) { y Size ++ ; } } hit Max X |= x Size >= span X ; hit Max Y |= y Size >= span Y ; inc X = ! inc X ; } inc X = BOOL ; hit Max X = x Size >= span X ; hit Max Y = y Size >= span Y ; } final int [ ] cell XY = m Tmp Point ; cell To Center Point ( x , y , cell XY ) ; Rect current Rect = m Temp Rect Stack . pop ( ) ; current Rect . set ( x , y , x + x Size , y + y Size ) ; boolean contained = BOOL ; for ( Rect r : valid Regions ) { if ( r . contains ( current Rect ) ) { contained = BOOL ; break ; } } valid Regions . push ( current Rect ) ; double distance = Math . hypot ( cell XY [ NUM ] - pixel X , cell XY [ NUM ] - pixel Y ) ; if ( ( distance <= best Distance && ! contained ) || current Rect . contains ( best Rect ) ) { best Distance = distance ; best XY [ NUM ] = x ; best XY [ NUM ] = y ; if ( result Span != null ) { result Span [ NUM ] = x Size ; result Span [ NUM ] = y Size ; } best Rect . set ( current Rect ) ; } } } if ( best Distance == Double . MAX VALUE ) { best XY [ NUM ] = - NUM ; best XY [ NUM ] = - NUM ; } recycle Temp Rects ( valid Regions ) ; return best XY ; }
public void validation States Removed ( K key ) { hide Message ( key ) ; validation Error States . remove ( key ) ; notify Upstream ( key , Collections . < Validation State > empty Set ( ) ) ; }
public void kill Application ( String application Id ) throws IO Exception , Yarn Exception { log . info ( STRING + application Id ) ; yarn Client . kill Application ( get Application ID From String ( application Id ) ) ; }
public static String convert ( String prefix ) { String Builder sb = new String Builder ( ) ; prefix = prefix . replace ( STRING , STRING ) ; String [ ] lines = prefix . split ( STRING ) ; for ( String line : lines ) { List < String > tokens = new Array List < String > ( ) ; char [ ] c = Unsafe String . get Chars ( line ) ; int lastidx = NUM ; int idx = NUM ; while ( idx < c . length ) { while ( c [ idx ] != STRING && c [ idx ] != STRING && c [ idx ] != STRING ) { idx ++ ; } if ( idx != lastidx ) { tokens . add ( new String ( c , lastidx , idx - lastidx ) ) ; } idx ++ ; lastidx = idx ; } Collections . reverse ( tokens ) ; for ( String token : tokens ) { sb . append ( token ) ; sb . append ( STRING ) ; } } return sb . to String ( ) ; }
public boolean to Boolean ( Element el , String attribute Name , boolean default Value ) { String value = el . get Attribute ( attribute Name ) ; if ( value == null ) return default Value ; return Caster . to Boolean Value ( value , BOOL ) ; }
public synchronized void add Pan Listener ( Pan Listener listener ) { m Pan Listeners . add ( listener ) ; }
protected void serialize Pre Root ( ) throws IO Exception { int i ; if ( pre Root != null ) { for ( i = NUM ; i < pre Root . size ( ) ; ++ i ) { print Text ( ( String ) pre Root . element At ( i ) , BOOL , BOOL ) ; if ( indenting ) printer . break Line ( ) ; } pre Root . remove All Elements ( ) ; } }
private void create Schema Column Entities ( List < Schema Column > schema Columns , boolean is Partition List , Collection < Schema Column Entity > schema Column Entity List , Map < String , Schema Column Entity > schema Column Entity Map , Business Object Format Entity business Object Format Entity ) { if ( ! Collection Utils . is Empty ( schema Columns ) ) { int position = NUM ; for ( Schema Column schema Column : schema Columns ) { Schema Column Entity schema Column Entity = schema Column Entity Map . get ( schema Column . get Name ( ) ) ; if ( schema Column Entity == null ) { schema Column Entity = create Schema Column Entity ( schema Column , business Object Format Entity ) ; schema Column Entity List . add ( schema Column Entity ) ; schema Column Entity Map . put ( schema Column . get Name ( ) , schema Column Entity ) ; } if ( is Partition List ) { schema Column Entity . set Partition Level ( position ++ ) ; } else { schema Column Entity . set Position ( position ++ ) ; } } } }
public static < T > String join And ( final String delimiter , final String last Delimiter , final Collection < T > objs ) { if ( objs == null || objs . is Empty ( ) ) return STRING ; final Iterator < T > iter = objs . iterator ( ) ; final String Builder buffer = new String Builder ( ) ; while ( iter . has Next ( ) ) { final T obj = iter . next ( ) ; if ( not Empty ( obj ) ) { if ( buffer . length ( ) != NUM ) { buffer . append ( iter . has Next ( ) ? delimiter : last Delimiter ) ; } buffer . append ( Strings . to String ( obj ) ) ; } } return buffer . to String ( ) ; }
public static String generate Native Guid ( Db Client db Client , Snapshot snapshot ) throws IO Exception { File Share fs = db Client . query Object ( File Share . class , snapshot . get Parent ( ) ) ; Storage System device = db Client . query Object ( Storage System . class , fs . get Storage Device ( ) ) ; return String . format ( STRING + SNAPSHOT + STRING , device Type Map . get ( device . get System Type ( ) ) , device . get Serial Number ( ) , snapshot . get Native Id ( ) ) ; }
public static Map < String , Object > update File ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Map < String , Object > result = null ; try { result = update File Method ( dctx , context ) ; } catch ( Generic Service Exception e ) { return Service Util . return Error ( e . get Message ( ) ) ; } return result ; }
public static String read Fully ( Reader reader ) throws IO Exception { try { String Writer writer = new String Writer ( ) ; char [ ] buffer = new char [ NUM ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM ) { writer . write ( buffer , NUM , count ) ; } return writer . to String ( ) ; } finally { reader . close ( ) ; } }
public Edit Sensors Dialog ( final Collection < Sensor > sensors ) { super ( ) ; if ( sensors == null ) { throw new Illegal Argument Exception ( STRING ) ; } this . sensors = sensors ; set Title ( STRING + sensors . size ( ) + STRING ) ; init Components ( ) ; layout Components ( ) ; }
@ Visible For Testing synchronized void trim To Size ( int target Size ) { int bytes To Free = Math . min ( m Used . m Num Bytes + m Free . m Num Bytes - target Size , m Free . m Num Bytes ) ; if ( bytes To Free <= NUM ) { return ; } if ( F Log . is Loggable ( F Log . VERBOSE ) ) { F Log . v ( TAG , STRING , target Size , m Used . m Num Bytes + m Free . m Num Bytes , bytes To Free ) ; } log Stats ( ) ; for ( int i = NUM ; i < m Buckets . size ( ) ; ++ i ) { if ( bytes To Free <= NUM ) { break ; } Bucket < V > bucket = m Buckets . value At ( i ) ; while ( bytes To Free > NUM ) { V value = bucket . pop ( ) ; if ( value == null ) { break ; } free ( value ) ; bytes To Free -= bucket . m Item Size ; m Free . decrement ( bucket . m Item Size ) ; } } log Stats ( ) ; if ( F Log . is Loggable ( F Log . VERBOSE ) ) { F Log . v ( TAG , STRING , target Size , m Used . m Num Bytes + m Free . m Num Bytes ) ; } }
@ Override public void add Focusables ( Array List < View > views , int direction , int focusable Mode ) { final int focusable Count = views . size ( ) ; final int descendant Focusability = get Descendant Focusability ( ) ; if ( descendant Focusability != FOCUS BLOCK DESCENDANTS ) { for ( int i = NUM ; i < get Child Count ( ) ; i ++ ) { final View child = get Child At ( i ) ; if ( child . get Visibility ( ) == VISIBLE ) { Item Info ii = info For Child ( child ) ; if ( ii != null && ii . position == m Cur Item ) { child . add Focusables ( views , direction , focusable Mode ) ; } } } } if ( descendant Focusability != FOCUS AFTER DESCENDANTS || ( focusable Count == views . size ( ) ) ) { if ( ! is Focusable ( ) ) { return ; } if ( ( focusable Mode & FOCUSABLES TOUCH MODE ) == FOCUSABLES TOUCH MODE && is In Touch Mode ( ) && ! is Focusable In Touch Mode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }
public String read To Delimiter ( char delim ) throws Format Exception { String Buffer buildretval = new String Buffer ( ) ; char tmp ; try { while ( ( tmp = read Char ( ) ) != delim ) buildretval . append ( tmp ) ; } catch ( EOF Exception e ) { } catch ( Format Exception fe ) { if ( buildretval . length ( ) == NUM ) { throw fe ; } } return buildretval . to String ( ) ; }
private void add New Line At Top ( Recycler View . Recycler recycler ) { int x = layout Start Point ( ) . x , bottom = get Decorated Top ( get Child At ( get Max Height Layout Position In Line ( NUM ) ) ) , y ; int height = NUM ; List < View > line Children = new Linked List < > ( ) ; int current Adapter Position = NUM ; int end Adapter Position = get Child Adapter Position ( NUM ) - NUM ; Rect rect = new Rect ( ) ; boolean newline ; boolean first Item = BOOL ; Layout Context layout Context = Layout Context . from Layout Options ( flow Layout Options ) ; int first Item Adapter Position = get Child Adapter Position ( NUM ) ; if ( cache Helper . has Previous Line Cached ( first Item Adapter Position ) ) { int previous Line Index = cache Helper . item Line Index ( first Item Adapter Position ) - NUM ; Line previous Line = cache Helper . get Line ( previous Line Index ) ; int first New Item Adapter Position = cache Helper . first Item Index ( previous Line Index ) ; for ( int i = NUM ; i < previous Line . item Count ; i ++ ) { View new View = recycler . get View For Position ( first New Item Adapter Position + i ) ; add View ( new View , i ) ; line Children . add ( new View ) ; } height = previous Line . max Height ; } else { while ( current Adapter Position <= end Adapter Position ) { View new Child = recycler . get View For Position ( current Adapter Position ) ; newline = calc Child Layout Rect ( new Child , x , NUM , height , layout Context , rect ) ; cache Helper . set Item ( current Adapter Position , new Point ( rect . width ( ) , rect . height ( ) ) ) ; add View ( new Child , line Children . size ( ) ) ; if ( newline && ! first Item ) { for ( View view To Recycle : line Children ) { remove And Recycle View ( view To Recycle , recycler ) ; } line Children . clear ( ) ; x = advance In Same Line ( layout Start Point ( ) . x , rect , layout Context ) ; height = rect . height ( ) ; layout Context . current Line Item Count = NUM ; } else { x = advance In Same Line ( x , rect , layout Context ) ; height = Math . max ( height , rect . height ( ) ) ; first Item = BOOL ; layout Context . current Line Item Count ++ ; } line Children . add ( new Child ) ; current Adapter Position ++ ; } } x = layout Start Point ( ) . x ; y = bottom - height ; first Item = BOOL ; layout Context = Layout Context . from Layout Options ( flow Layout Options ) ; for ( int i = NUM ; i < line Children . size ( ) ; i ++ ) { View child View = line Children . get ( i ) ; newline = calc Child Layout Rect ( child View , x , y , height , layout Context , rect ) ; if ( newline && first Item ) { int rect Height = rect . height ( ) ; rect . top -= rect Height ; rect . bottom -= rect Height ; first Item = BOOL ; } layout Decorated ( child View , rect . left , rect . top , rect . right , rect . bottom ) ; x = advance In Same Line ( x , rect , layout Context ) ; } }
protected static final String add Escapes ( String str ) { String Buffer retval = new String Buffer ( ) ; char ch ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) { switch ( str . char At ( i ) ) { case NUM : continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; default : if ( ( ch = str . char At ( i ) ) < NUM || ch > NUM ) { String s = STRING + Integer . to String ( ch , NUM ) ; retval . append ( STRING + s . substring ( s . length ( ) - NUM , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . to String ( ) ; }
default T call ( Source Section source , T lhs , T argument 1 , T argument 2 ) { return call ( source , lhs , Arrays . as List ( argument ( argument 1 ) , argument ( argument 2 ) ) ) ; }
public boolean equal Map Gen Parameters ( Map Settings other ) { if ( ( board Width != other . get Board Width ( ) ) || ( board Height != other . get Board Height ( ) ) || ( map Width != other . get Map Width ( ) ) || ( map Height != other . get Map Height ( ) ) || ( invert Negative Terrain != other . get Invert Negative Terrain ( ) ) || ( hilliness != other . get Hilliness ( ) ) || ( cliffs != other . get Cliffs ( ) ) || ( range != other . get Range ( ) ) || ( min Water Spots != other . get Min Water Spots ( ) ) || ( max Water Spots != other . get Max Water Spots ( ) ) || ( min Water Size != other . get Min Water Size ( ) ) || ( max Water Size != other . get Max Water Size ( ) ) || ( prob Deep != other . get Prob Deep ( ) ) || ( min Forest Spots != other . get Min Forest Spots ( ) ) || ( max Forest Spots != other . get Max Forest Spots ( ) ) || ( min Forest Size != other . get Min Forest Size ( ) ) || ( max Forest Size != other . get Max Forest Size ( ) ) || ( prob Heavy != other . get Prob Heavy ( ) ) || ( min Rough Spots != other . get Min Rough Spots ( ) ) || ( max Rough Spots != other . get Max Rough Spots ( ) ) || ( min Rough Size != other . get Min Rough Size ( ) ) || ( max Rough Size != other . get Max Rough Size ( ) ) || ( min Sand Spots != other . get Min Sand Spots ( ) ) || ( max Sand Spots != other . get Max Sand Spots ( ) ) || ( min Sand Size != other . get Min Sand Size ( ) ) || ( max Sand Size != other . get Max Sand Size ( ) ) || ( min Planted Field Spots != other . get Min Planted Field Spots ( ) ) || ( max Planted Field Spots != other . get Max Planted Field Spots ( ) ) || ( min Planted Field Size != other . get Min Planted Field Size ( ) ) || ( max Planted Field Size != other . get Max Planted Field Size ( ) ) || ( min Swamp Spots != other . get Min Swamp Spots ( ) ) || ( max Swamp Spots != other . get Max Swamp Spots ( ) ) || ( min Swamp Size != other . get Min Swamp Size ( ) ) || ( max Swamp Size != other . get Max Swamp Size ( ) ) || ( min Pavement Spots != other . get Min Pavement Spots ( ) ) || ( max Pavement Spots != other . get Max Pavement Spots ( ) ) || ( min Pavement Size != other . get Min Pavement Size ( ) ) || ( max Pavement Size != other . get Max Pavement Size ( ) ) || ( min Rubble Spots != other . get Min Rubble Spots ( ) ) || ( max Rubble Spots != other . get Max Rubble Spots ( ) ) || ( min Rubble Size != other . get Min Rubble Size ( ) ) || ( max Rubble Size != other . get Max Rubble Size ( ) ) || ( min Fortified Spots != other . get Min Fortified Spots ( ) ) || ( max Fortified Spots != other . get Max Fortified Spots ( ) ) || ( min Fortified Size != other . get Min Fortified Size ( ) ) || ( max Fortified Size != other . get Max Fortified Size ( ) ) || ( min Ice Spots != other . get Min Ice Spots ( ) ) || ( max Ice Spots != other . get Max Ice Spots ( ) ) || ( min Ice Size != other . get Min Ice Size ( ) ) || ( max Ice Size != other . get Max Ice Size ( ) ) || ( prob Road != other . get Prob Road ( ) ) || ( prob Invert != other . get Prob Invert ( ) ) || ( prob River != other . get Prob River ( ) ) || ( prob Crater != other . get Prob Crater ( ) ) || ( min Radius != other . get Min Radius ( ) ) || ( max Radius != other . get Max Radius ( ) ) || ( min Craters != other . get Min Craters ( ) ) || ( max Craters != other . get Max Craters ( ) ) || ( ! theme . equals ( other . get Theme ( ) ) ) || ( fx Mod != other . get Fx Mod ( ) ) || ( city Blocks != other . get City Blocks ( ) ) || ( city Type != other . get City Type ( ) ) || ( city Min CF != other . get City Min CF ( ) ) || ( city Max CF != other . get City Max CF ( ) ) || ( city Min Floors != other . get City Min Floors ( ) ) || ( city Max Floors != other . get City Max Floors ( ) ) || ( city Density != other . get City Density ( ) ) || ( prob Flood != other . get Prob Flood ( ) ) || ( prob Forest Fire != other . get Prob Forest Fire ( ) ) || ( prob Freeze != other . get Prob Freeze ( ) ) || ( prob Drought != other . get Prob Drought ( ) ) || ( algorithm To Use != other . get Algorithm To Use ( ) ) || ( mountain Height Min != other . get Mountain Height Min ( ) ) || ( mountain Height Max != other . get Mountain Height Max ( ) ) || ( mountain Peaks != other . get Mountain Peaks ( ) ) || ( mountain Style != other . get Mountain Style ( ) ) || ( mountain Width Min != other . get Mountain Width Min ( ) ) || ( mountain Width Max != other . get Mountain Width Max ( ) ) || ( board Buildings != other . get Board Buildings ( ) ) ) { return BOOL ; } return BOOL ; }
private static void decode Text Segment ( Bit Source bits , String Builder result ) throws Format Exception { boolean upper Shift = BOOL ; int [ ] c Values = new int [ NUM ] ; int shift = NUM ; do { if ( bits . available ( ) == NUM ) { return ; } int first Byte = bits . read Bits ( NUM ) ; if ( first Byte == NUM ) { return ; } parse Two Bytes ( first Byte , bits . read Bits ( NUM ) , c Values ) ; for ( int i = NUM ; i < NUM ; i ++ ) { int c Value = c Values [ i ] ; switch ( shift ) { case NUM : if ( c Value < NUM ) { shift = c Value + NUM ; } else if ( c Value < TEXT BASIC SET CHARS . length ) { char text Char = TEXT BASIC SET CHARS [ c Value ] ; if ( upper Shift ) { result . append ( ( char ) ( text Char + NUM ) ) ; upper Shift = BOOL ; } else { result . append ( text Char ) ; } } else { throw Format Exception . get Format Instance ( ) ; } break ; case NUM : if ( upper Shift ) { result . append ( ( char ) ( c Value + NUM ) ) ; upper Shift = BOOL ; } else { result . append ( ( char ) c Value ) ; } shift = NUM ; break ; case NUM : if ( c Value < C40 SHIFT 2 SET CHARS . length ) { char c40 char = C40 SHIFT 2 SET CHARS [ c Value ] ; if ( upper Shift ) { result . append ( ( char ) ( c40 char + NUM ) ) ; upper Shift = BOOL ; } else { result . append ( c40 char ) ; } } else if ( c Value == NUM ) { result . append ( ( char ) NUM ) ; } else if ( c Value == NUM ) { upper Shift = BOOL ; } else { throw Format Exception . get Format Instance ( ) ; } shift = NUM ; break ; case NUM : if ( c Value < TEXT SHIFT 3 SET CHARS . length ) { char text Char = TEXT SHIFT 3 SET CHARS [ c Value ] ; if ( upper Shift ) { result . append ( ( char ) ( text Char + NUM ) ) ; upper Shift = BOOL ; } else { result . append ( text Char ) ; } shift = NUM ; } else { throw Format Exception . get Format Instance ( ) ; } break ; default : throw Format Exception . get Format Instance ( ) ; } } } while ( bits . available ( ) > NUM ) ; }
public synchronized void curl ( Point F curl Pos , Point F curl Dir , double radius ) { if ( DRAW CURL POSITION ) { m Buf Curl Position Lines . position ( NUM ) ; m Buf Curl Position Lines . put ( curl Pos . x ) ; m Buf Curl Position Lines . put ( curl Pos . y - NUM ) ; m Buf Curl Position Lines . put ( curl Pos . x ) ; m Buf Curl Position Lines . put ( curl Pos . y + NUM ) ; m Buf Curl Position Lines . put ( curl Pos . x - NUM ) ; m Buf Curl Position Lines . put ( curl Pos . y ) ; m Buf Curl Position Lines . put ( curl Pos . x + NUM ) ; m Buf Curl Position Lines . put ( curl Pos . y ) ; m Buf Curl Position Lines . put ( curl Pos . x ) ; m Buf Curl Position Lines . put ( curl Pos . y ) ; m Buf Curl Position Lines . put ( curl Pos . x + curl Dir . x * NUM ) ; m Buf Curl Position Lines . put ( curl Pos . y + curl Dir . y * NUM ) ; m Buf Curl Position Lines . position ( NUM ) ; } m Buf Vertices . position ( NUM ) ; m Buf Colors . position ( NUM ) ; if ( DRAW TEXTURE ) { m Buf Tex Coords . position ( NUM ) ; } double curl Angle = Math . acos ( curl Dir . x ) ; curl Angle = curl Dir . y > NUM ? - curl Angle : curl Angle ; m Arr Temp Vertices . add All ( m Arr Rotated Vertices ) ; m Arr Rotated Vertices . clear ( ) ; for ( int i = NUM ; i < NUM ; ++ i ) { Vertex v = m Arr Temp Vertices . remove ( NUM ) ; v . set ( m Rectangle [ i ] ) ; v . translate ( - curl Pos . x , - curl Pos . y ) ; v . rotate Z ( - curl Angle ) ; int j = NUM ; for ( ; j < m Arr Rotated Vertices . size ( ) ; ++ j ) { Vertex v2 = m Arr Rotated Vertices . get ( j ) ; if ( v . m Pos X > v2 . m Pos X ) { break ; } if ( v . m Pos X == v2 . m Pos X && v . m Pos Y > v2 . m Pos Y ) { break ; } } m Arr Rotated Vertices . add ( j , v ) ; } int lines [ ] [ ] = { { NUM , NUM } , { NUM , NUM } , { NUM , NUM } , { NUM , NUM } } ; { Vertex v0 = m Arr Rotated Vertices . get ( NUM ) ; Vertex v2 = m Arr Rotated Vertices . get ( NUM ) ; Vertex v3 = m Arr Rotated Vertices . get ( NUM ) ; double dist 2 = Math . sqrt ( ( v0 . m Pos X - v2 . m Pos X ) * ( v0 . m Pos X - v2 . m Pos X ) + ( v0 . m Pos Y - v2 . m Pos Y ) * ( v0 . m Pos Y - v2 . m Pos Y ) ) ; double dist 3 = Math . sqrt ( ( v0 . m Pos X - v3 . m Pos X ) * ( v0 . m Pos X - v3 . m Pos X ) + ( v0 . m Pos Y - v3 . m Pos Y ) * ( v0 . m Pos Y - v3 . m Pos Y ) ) ; if ( dist 2 > dist 3 ) { lines [ NUM ] [ NUM ] = NUM ; lines [ NUM ] [ NUM ] = NUM ; } } m Vertices Count Front = m Vertices Count Back = NUM ; if ( DRAW SHADOW ) { m Arr Temp Shadow Vertices . add All ( m Arr Drop Shadow Vertices ) ; m Arr Temp Shadow Vertices . add All ( m Arr Self Shadow Vertices ) ; m Arr Drop Shadow Vertices . clear ( ) ; m Arr Self Shadow Vertices . clear ( ) ; } double curl Length = Math . PI * radius ; m Arr Scan Lines . clear ( ) ; if ( m Max Curl Splits > NUM ) { m Arr Scan Lines . add ( ( double ) NUM ) ; } for ( int i = NUM ; i < m Max Curl Splits ; ++ i ) { m Arr Scan Lines . add ( ( - curl Length * i ) / ( m Max Curl Splits - NUM ) ) ; } m Arr Scan Lines . add ( m Arr Rotated Vertices . get ( NUM ) . m Pos X - NUM ) ; double scan Xmax = m Arr Rotated Vertices . get ( NUM ) . m Pos X + NUM ; for ( int i = NUM ; i < m Arr Scan Lines . size ( ) ; ++ i ) { double scan Xmin = m Arr Scan Lines . get ( i ) ; for ( int j = NUM ; j < m Arr Rotated Vertices . size ( ) ; ++ j ) { Vertex v = m Arr Rotated Vertices . get ( j ) ; if ( v . m Pos X >= scan Xmin && v . m Pos X <= scan Xmax ) { Vertex n = m Arr Temp Vertices . remove ( NUM ) ; n . set ( v ) ; Array < Vertex > intersections = get Intersections ( m Arr Rotated Vertices , lines , n . m Pos X ) ; if ( intersections . size ( ) == NUM && intersections . get ( NUM ) . m Pos Y > v . m Pos Y ) { m Arr Output Vertices . add All ( intersections ) ; m Arr Output Vertices . add ( n ) ; } else if ( intersections . size ( ) <= NUM ) { m Arr Output Vertices . add ( n ) ; m Arr Output Vertices . add All ( intersections ) ; } else { m Arr Temp Vertices . add ( n ) ; m Arr Temp Vertices . add All ( intersections ) ; } } } Array < Vertex > intersections = get Intersections ( m Arr Rotated Vertices , lines , scan Xmin ) ; if ( intersections . size ( ) == NUM ) { Vertex v1 = intersections . get ( NUM ) ; Vertex v2 = intersections . get ( NUM ) ; if ( v1 . m Pos Y < v2 . m Pos Y ) { m Arr Output Vertices . add ( v2 ) ; m Arr Output Vertices . add ( v1 ) ; } else { m Arr Output Vertices . add All ( intersections ) ; } } else if ( intersections . size ( ) != NUM ) { m Arr Temp Vertices . add All ( intersections ) ; } while ( m Arr Output Vertices . size ( ) > NUM ) { Vertex v = m Arr Output Vertices . remove ( NUM ) ; m Arr Temp Vertices . add ( v ) ; boolean texture Front ; if ( i == NUM ) { texture Front = BOOL ; m Vertices Count Front ++ ; } else if ( i == m Arr Scan Lines . size ( ) - NUM || curl Length == NUM ) { v . m Pos X = - ( curl Length + v . m Pos X ) ; v . m Pos Z = NUM * radius ; v . m Penumbra X = - v . m Penumbra X ; texture Front = BOOL ; m Vertices Count Back ++ ; } else { double rot Y = Math . PI * ( v . m Pos X / curl Length ) ; v . m Pos X = radius * Math . sin ( rot Y ) ; v . m Pos Z = radius - ( radius * Math . cos ( rot Y ) ) ; v . m Penumbra X *= Math . cos ( rot Y ) ; v . m Color Factor = ( float ) ( NUM + NUM * Math . sqrt ( Math . sin ( rot Y ) + NUM ) ) ; if ( v . m Pos Z >= radius ) { texture Front = BOOL ; m Vertices Count Back ++ ; } else { texture Front = BOOL ; m Vertices Count Front ++ ; } } if ( texture Front != m Flip Texture ) { v . m Tex X *= m Texture Rect Front . right ; v . m Tex Y *= m Texture Rect Front . bottom ; v . m Color = m Texture Page . get Color ( Curl Page . SIDE FRONT ) ; } else { v . m Tex X *= m Texture Rect Back . right ; v . m Tex Y *= m Texture Rect Back . bottom ; v . m Color = m Texture Page . get Color ( Curl Page . SIDE BACK ) ; } v . rotate Z ( curl Angle ) ; v . translate ( curl Pos . x , curl Pos . y ) ; add Vertex ( v ) ; if ( DRAW SHADOW && v . m Pos Z > NUM && v . m Pos Z <= radius ) { Shadow Vertex sv = m Arr Temp Shadow Vertices . remove ( NUM ) ; sv . m Pos X = v . m Pos X ; sv . m Pos Y = v . m Pos Y ; sv . m Pos Z = v . m Pos Z ; sv . m Penumbra X = ( v . m Pos Z / NUM ) * - curl Dir . x ; sv . m Penumbra Y = ( v . m Pos Z / NUM ) * - curl Dir . y ; sv . m Penumbra Color = v . m Pos Z / radius ; int idx = ( m Arr Drop Shadow Vertices . size ( ) + NUM ) / NUM ; m Arr Drop Shadow Vertices . add ( idx , sv ) ; } if ( DRAW SHADOW && v . m Pos Z > radius ) { Shadow Vertex sv = m Arr Temp Shadow Vertices . remove ( NUM ) ; sv . m Pos X = v . m Pos X ; sv . m Pos Y = v . m Pos Y ; sv . m Pos Z = v . m Pos Z ; sv . m Penumbra X = ( ( v . m Pos Z - radius ) / NUM ) * v . m Penumbra X ; sv . m Penumbra Y = ( ( v . m Pos Z - radius ) / NUM ) * v . m Penumbra Y ; sv . m Penumbra Color = ( v . m Pos Z - radius ) / ( NUM * radius ) ; int idx = ( m Arr Self Shadow Vertices . size ( ) + NUM ) / NUM ; m Arr Self Shadow Vertices . add ( idx , sv ) ; } } scan Xmax = scan Xmin ; } m Buf Vertices . position ( NUM ) ; m Buf Colors . position ( NUM ) ; if ( DRAW TEXTURE ) { m Buf Tex Coords . position ( NUM ) ; } if ( DRAW SHADOW ) { m Buf Shadow Colors . position ( NUM ) ; m Buf Shadow Vertices . position ( NUM ) ; m Drop Shadow Count = NUM ; for ( int i = NUM ; i < m Arr Drop Shadow Vertices . size ( ) ; ++ i ) { Shadow Vertex sv = m Arr Drop Shadow Vertices . get ( i ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos X ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos Y ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos Z ) ; m Buf Shadow Vertices . put ( ( float ) ( sv . m Pos X + sv . m Penumbra X ) ) ; m Buf Shadow Vertices . put ( ( float ) ( sv . m Pos Y + sv . m Penumbra Y ) ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos Z ) ; for ( int j = NUM ; j < NUM ; ++ j ) { double color = SHADOW OUTER COLOR [ j ] + ( SHADOW INNER COLOR [ j ] - SHADOW OUTER COLOR [ j ] ) * sv . m Penumbra Color ; m Buf Shadow Colors . put ( ( float ) color ) ; } m Buf Shadow Colors . put ( SHADOW OUTER COLOR ) ; m Drop Shadow Count += NUM ; } m Self Shadow Count = NUM ; for ( int i = NUM ; i < m Arr Self Shadow Vertices . size ( ) ; ++ i ) { Shadow Vertex sv = m Arr Self Shadow Vertices . get ( i ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos X ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos Y ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos Z ) ; m Buf Shadow Vertices . put ( ( float ) ( sv . m Pos X + sv . m Penumbra X ) ) ; m Buf Shadow Vertices . put ( ( float ) ( sv . m Pos Y + sv . m Penumbra Y ) ) ; m Buf Shadow Vertices . put ( ( float ) sv . m Pos Z ) ; for ( int j = NUM ; j < NUM ; ++ j ) { double color = SHADOW OUTER COLOR [ j ] + ( SHADOW INNER COLOR [ j ] - SHADOW OUTER COLOR [ j ] ) * sv . m Penumbra Color ; m Buf Shadow Colors . put ( ( float ) color ) ; } m Buf Shadow Colors . put ( SHADOW OUTER COLOR ) ; m Self Shadow Count += NUM ; } m Buf Shadow Colors . position ( NUM ) ; m Buf Shadow Vertices . position ( NUM ) ; } }
public void save Lock Password ( String password , int quality , boolean is Fallback ) { final byte [ ] hash = password To Hash ( password ) ; try { Random Access File raf = new Random Access File ( s Lock Password Filename , STRING ) ; try { if ( password == null ) { raf . set Length ( NUM ) ; } else { raf . write ( hash , NUM , hash . length ) ; } } finally { if ( raf != null ) raf . close ( ) ; } } catch ( File Not Found Exception fnfe ) { Log Util . e ( TAG , STRING + s Lock Password Filename ) ; } catch ( IO Exception ioe ) { Log Util . e ( TAG , STRING + s Lock Password Filename ) ; } }
public boolean check Username Exists ( String username ) throws Data Access Exception { return get User Info ( username ) != null ; }
public Code 39 Reader ( ) { using Check Digit = BOOL ; extended Mode = BOOL ; }
public static String encode ( final List < Position > path , int precision ) { long last Lat = NUM ; long last Lng = NUM ; final String Buffer result = new String Buffer ( ) ; double factor = Math . pow ( NUM , precision ) ; for ( final Position point : path ) { long lat = Math . round ( point . get Latitude ( ) * factor ) ; long lng = Math . round ( point . get Longitude ( ) * factor ) ; long d Lat = lat - last Lat ; long d Lng = lng - last Lng ; encode ( d Lat , result ) ; encode ( d Lng , result ) ; last Lat = lat ; last Lng = lng ; } return result . to String ( ) ; }
public Activity Resolve Info ( Resolve Info resolve Info ) { this . resolve Info = resolve Info ; }
@ Override public int compare To ( Lib Package p other ) { return pkg name . compare To Ignore Case ( p other . pkg name ) ; }
public void write Exif ( Bitmap bmap , String exif Out File Name ) throws File Not Found Exception , IO Exception { if ( bmap == null || exif Out File Name == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Output Stream s = null ; try { s = get Exif Writer Stream ( exif Out File Name ) ; bmap . compress ( Bitmap . Compress Format . JPEG , NUM , s ) ; s . flush ( ) ; } catch ( IO Exception e ) { close Silently ( s ) ; throw e ; } s . close ( ) ; }
public double entropy ( int [ ] x ) { double h = NUM ; int n = x . length ; double ln 2 = Math . log ( NUM ) ; int n0 = NUM ; for ( int i = NUM ; i < n ; i ++ ) { if ( x [ i ] == NUM ) { n0 ++ ; } } double p ; if ( n0 == NUM || n0 == n ) { return h ; } else { p = ( double ) n0 / ( double ) n ; h = - ( p * Math . log ( p ) + ( NUM - p ) * Math . log ( NUM - p ) ) / ln 2 ; } return h ; }
private String [ ] addto Selection Args ( final String arg Value , final String [ ] selection Args In ) { String [ ] selection Args = selection Args In ; List < String > selection Args List = new Array List < > ( ) ; selection Args List . add ( arg Value ) ; if ( null != selection Args In ) { for ( final String arg : selection Args In ) { selection Args List . add ( arg ) ; } } selection Args = selection Args List . to Array ( new String [ NUM ] ) ; selection Args List . clear ( ) ; selection Args List = null ; return selection Args ; }
public void put ( String sample , String attribute , Object value ) { if ( ! sample Order . contains ( sample ) ) sample Order . add ( sample ) ; if ( ! attribute Order . contains ( attribute ) ) attribute Order . add ( attribute ) ; table . put ( sample , attribute , value ) ; }
public boolean is Compacted ( ) { return compacted ; }
protected void center ( ) { Container parent = get Parent ( ) ; final Dimension size = get Preferred Size ( ) ; set Bounds ( ( parent . get Width ( ) - size . width ) / NUM , ( parent . get Height ( ) - size . height ) / NUM , size . width , size . height ) ; }
public boolean is Card Dismissible ( String tag ) { return m Dismissible Cards . contains ( tag ) ; }
public void write ( char cbuf [ ] , int off , int len ) throws IO Exception { se . write ( cbuf , off , len ) ; }
public boolean validate ( String telephone ) { char a Char ; String Builder buf = new String Builder ( telephone ) ; for ( int a Index = NUM ; a Index < buf . length ( ) ; a Index ++ ) { a Char = buf . char At ( a Index ) ; if ( ! Character . is Space Char ( a Char ) ) { if ( ! Character . is Digit ( a Char ) && ! is Valid Telephone Chars ( a Char ) ) { return BOOL ; } } } return BOOL ; }
public static void unpack ( Hash Map < String , Object > object , String key , Object value ) { String [ ] split = key . split ( STRING ) ; Hash Map lobj = object ; for ( int cur = NUM ; cur < split . length ; cur ++ ) { String current = split [ cur ] ; if ( ! ( lobj . contains Key ( current ) && lobj . get ( current ) instanceof Hash Map ) ) { lobj . put ( current , new Hash Map < String , Object > ( ) ) ; } if ( cur == split . length - NUM ) { lobj . put ( current , value ) ; } else lobj = ( Hash Map ) lobj . get ( current ) ; } }
public void remove Listener ( DNS Listener listener ) { listeners . remove ( listener ) ; }
static Set < String > parse Resource Path Params ( String resource Path ) { Matcher matcher = PARAM URL REGEX . matcher ( resource Path ) ; Set < String > patterns = new Linked Hash Set < > ( ) ; while ( matcher . find ( ) ) { patterns . add ( matcher . group ( NUM ) ) ; } return patterns ; }
@ Override public void close ( ) throws IO Exception { if ( logger != null ) { logger . println ( STRING + socket was closed ) ; } if ( ! socket was closed ) { if ( handshake started ) { alert Protocol . alert ( Alert Protocol . WARNING , Alert Protocol . CLOSE NOTIFY ) ; try { output . write ( alert Protocol . wrap ( ) ) ; } catch ( IO Exception ex ) { } alert Protocol . set Processed ( ) ; } shutdown ( ) ; close Transport Layer ( ) ; socket was closed = BOOL ; } }
public J Range Slider ( Bounded Range Model model , int orientation , int direction ) { super . set Focusable ( BOOL ) ; this . model = model ; this . orientation = orientation ; this . direction = direction ; set Foreground ( Color . LIGHT GRAY ) ; this . lstnr = create Listener ( ) ; model . add Change Listener ( lstnr ) ; add Mouse Listener ( this ) ; add Mouse Motion Listener ( this ) ; add Key Listener ( this ) ; }
public static boolean is Auto New ( Properties ctx ) { if ( ctx == null ) throw new Illegal Argument Exception ( STRING ) ; String s = get Context ( ctx , STRING ) ; if ( s != null && s . equals ( STRING ) ) return BOOL ; return BOOL ; }
public boolean can Read ( String path ) { try { Zip Entry entry = get Zip Entry ( path ) ; return entry != null && ! entry . is Directory ( ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; return BOOL ; } }
public static long [ ] and I ( long [ ] v , long [ ] o , int off ) { if ( off == NUM ) { return and I ( v , o ) ; } if ( off < NUM ) { throw new Unsupported Operation Exception ( STRING ) ; } final int shift Words = off > > > LONG LOG 2 SIZE ; final int shift Bits = off & LONG LOG 2 MASK ; if ( shift Words >= v . length ) { return v ; } if ( shift Bits == NUM ) { final int end = Math . min ( v . length , o . length + shift Words ) ; for ( int i = shift Words ; i < end ; i ++ ) { v [ i ] &= o [ i - shift Words ] ; } Arrays . fill ( v , NUM , shift Words , NUM ) ; return v ; } final int unshift Bits = Long . SIZE - shift Bits ; final int end = Math . min ( v . length , o . length + shift Words ) - NUM ; Arrays . fill ( v , end + NUM , v . length , NUM ) ; for ( int i = end ; i > shift Words ; i -- ) { final int src = i - shift Words ; v [ i ] &= ( o [ src ] << shift Bits ) | ( o [ src - NUM ] > > > unshift Bits ) ; } v [ shift Words ] &= o [ NUM ] << shift Bits ; Arrays . fill ( v , NUM , shift Words , NUM ) ; return v ; }
private int calculate Layout Width ( int width Size , int mode ) { init Resources If Necessary ( ) ; items Layout . set Layout Params ( new Layout Params ( Layout Params . WRAP CONTENT , Layout Params . WRAP CONTENT ) ) ; items Layout . measure ( Measure Spec . make Measure Spec ( width Size , Measure Spec . UNSPECIFIED ) , Measure Spec . make Measure Spec ( NUM , Measure Spec . UNSPECIFIED ) ) ; int width = items Layout . get Measured Width ( ) ; if ( mode == Measure Spec . EXACTLY ) { width = width Size ; } else { width += NUM * PADDING ; width = Math . max ( width , get Suggested Minimum Width ( ) ) ; if ( mode == Measure Spec . AT MOST && width Size < width ) { width = width Size ; } } items Layout . measure ( Measure Spec . make Measure Spec ( width - NUM * PADDING , Measure Spec . EXACTLY ) , Measure Spec . make Measure Spec ( NUM , Measure Spec . UNSPECIFIED ) ) ; return width ; }
public boolean equals ( Object p test ) { if ( p test instanceof URI ) { URI test URI = ( URI ) p test ; if ( ( ( m scheme == null && test URI . m scheme == null ) || ( m scheme != null && test URI . m scheme != null && m scheme . equals ( test URI . m scheme ) ) ) && ( ( m userinfo == null && test URI . m userinfo == null ) || ( m userinfo != null && test URI . m userinfo != null && m userinfo . equals ( test URI . m userinfo ) ) ) && ( ( m host == null && test URI . m host == null ) || ( m host != null && test URI . m host != null && m host . equals ( test URI . m host ) ) ) && m port == test URI . m port && ( ( m path == null && test URI . m path == null ) || ( m path != null && test URI . m path != null && m path . equals ( test URI . m path ) ) ) && ( ( m query String == null && test URI . m query String == null ) || ( m query String != null && test URI . m query String != null && m query String . equals ( test URI . m query String ) ) ) && ( ( m fragment == null && test URI . m fragment == null ) || ( m fragment != null && test URI . m fragment != null && m fragment . equals ( test URI . m fragment ) ) ) ) { return BOOL ; } } return BOOL ; }
public void test Case 5 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { - NUM , - NUM , - NUM , NUM , - NUM , - NUM , - NUM , - NUM , NUM , - NUM , - NUM , - NUM , NUM , - NUM , NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . multiply ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
public ISAAC Random ( ) { set Seed ( System . current Time Millis ( ) + System . identity Hash Code ( this ) ) ; }
public static boolean is MD 5 String ( final String string ) { Preconditions . check Not Null ( string , STRING ) ; return ( string . length ( ) == NUM ) && is Hex String ( string ) ; }
public synchronized void wait For Submitted Tasks ( ) throws Interrupted Exception { while ( current Task Count . get ( ) > NUM ) { wait For Single Task ( ) ; } }
private int scan Token ( int start Pos ) { int position = start Pos ; while ( position < max Position ) { if ( ! has Surrogates ) { char c = str . char At ( position ) ; if ( ( c <= max Delim Code Point ) && ( delimiters . index Of ( c ) >= NUM ) ) break ; position ++ ; } else { int c = str . code Point At ( position ) ; if ( ( c <= max Delim Code Point ) && is Delimiter ( c ) ) break ; position += Character . char Count ( c ) ; } } if ( ret Delims && ( start Pos == position ) ) { if ( ! has Surrogates ) { char c = str . char At ( position ) ; if ( ( c <= max Delim Code Point ) && ( delimiters . index Of ( c ) >= NUM ) ) position ++ ; } else { int c = str . code Point At ( position ) ; if ( ( c <= max Delim Code Point ) && is Delimiter ( c ) ) position += Character . char Count ( c ) ; } } return position ; }
public void zoom At ( double x , double y , double z , double zoom Value ) { double [ ] diff = { target Xoff - x , target Yoff - y , z - target Zoff } ; double length = Math . sqrt ( diff [ NUM ] * diff [ NUM ] + diff [ NUM ] * diff [ NUM ] + diff [ NUM ] * diff [ NUM ] ) ; if ( length == NUM ) { length = NUM ; } double [ ] normalized = { diff [ NUM ] / length , diff [ NUM ] / length , diff [ NUM ] / length } ; double percent = zoom Value / normalized [ NUM ] ; move To Position ( - ( float ) ( target Xoff + normalized [ NUM ] * percent ) , - ( float ) ( target Yoff + normalized [ NUM ] * percent ) ) ; zoom To Camera ( ( float ) ( target Zoff + normalized [ NUM ] * percent ) ) ; }
private static int string To Hash ( String s ) { int len = s . length ( ) ; int hash 2 = NUM ; int hash = len ; hash <<= NUM ; hash += s . char At ( NUM ) - NUM ; int j = len ; for ( int i = NUM ; i < NUM && j > NUM ; i ++ ) { j -- ; hash <<= NUM ; hash += s . char At ( j ) - NUM ; hash 2 <<= NUM ; hash 2 += s . char At ( i ) - NUM ; } return hash ^ hash 2 ; }
public void register Dense Features ( Array List < Feature Function > feature Functions ) { for ( Feature Function feature : feature Functions ) { Array List < String > names = feature . report Dense Features ( dense Features . size ( ) ) ; for ( String name : names ) { DENSE FEATURE NAMES . add ( name ) ; dense Features . add ( get Sparse ( name ) ) ; sparse Features . remove ( name ) ; } } }
private void add Flag ( final List < String > args , final String arg Name , final boolean value ) { if ( value ) { args . add ( arg Name ) ; } }
public static Private Key load ( Input Stream is ) throws IO Exception , Crypto Exception { byte [ ] pvk = Read Util . read Fully ( is ) ; Byte Buffer bb = Byte Buffer . wrap ( pvk ) ; bb . order ( Byte Order . LITTLE ENDIAN ) ; long key Type = read Reserved Magic Key Type ( bb ) ; long encrypted = Unsigned Util . get Int ( bb ) ; if ( encrypted != PVK UNENCRYPTED ) { throw new Private Key Encrypted Exception ( Message Format . format ( res . get String ( STRING ) , Long . to Hex String ( encrypted ) , Long . to Hex String ( PVK UNENCRYPTED ) ) ) ; } long salt Length = Unsigned Util . get Int ( bb ) ; if ( salt Length != UNENCRYPTED SALT LENGTH ) { throw new Crypto Exception ( Message Format . format ( res . get String ( STRING ) , Long . to Hex String ( salt Length ) , Long . to Hex String ( UNENCRYPTED SALT LENGTH ) ) ) ; } long key Length = Unsigned Util . get Int ( bb ) ; read Private Key Blob Header ( bb , key Type ) ; byte [ ] private Key Blob = new byte [ bb . remaining ( ) ] ; bb . get ( private Key Blob ) ; if ( key Length != ( private Key Blob . length + BLOB HEADER LENGTH ) ) { throw new Crypto Exception ( Message Format . format ( res . get String ( STRING ) , Long . to Hex String ( key Length ) , Long . to Hex String ( private Key Blob . length + BLOB HEADER LENGTH ) ) ) ; } return blob To Private Key ( private Key Blob ) ; }
public static byte [ ] key Gen Private ( byte [ ] random Bytes ) throws No Such Algorithm Exception , Digest Exception { if ( random Bytes . length < NUM ) { throw new Runtime Exception ( STRING ) ; } Message Digest digest = Message Digest . get Instance ( STRING ) ; digest . digest ( random Bytes , NUM , random Bytes . length ) ; byte [ ] private Key = digest . digest ( ) ; private Key [ NUM ] &= NUM ; private Key [ NUM ] &= NUM ; private Key [ NUM ] |= NUM ; return private Key ; }
private boolean is Checkpoint Table Exists ( Connection conn ) { Statement st = null ; Result Set rs = null ; try { st = conn . create Statement ( ) ; rs = st . execute Query ( chk Tbl Exists Sql ) ; return BOOL ; } catch ( SQL Exception ignored ) { return BOOL ; } finally { U . close ( rs , log ) ; U . close ( st , log ) ; } }
public Function Table Model ( ) { column List . add ( Localisation . get String ( Function Table Model . class , STRING ) ) ; column List . add ( Localisation . get String ( Function Table Model . class , STRING ) ) ; column List . add ( Localisation . get String ( Function Table Model . class , STRING ) ) ; column List . add ( Localisation . get String ( Function Table Model . class , STRING ) ) ; }
private New Cookie create Ws Cookie ( String cookie Name , String token , boolean set Max Age , String user Agent ) { String ie Expires = STRING ; int max Age = set Max Age ? token Manager . get Max Token Life Time In Secs ( ) : New Cookie . DEFAULT MAX AGE ; if ( set Max Age && String Utils . contains ( user Agent , STRING ) ) { ie Expires = STRING + get Expired Time GMT ( max Age ) ; log . debug ( STRING + ie Expires ) ; } if ( token != null && ! token . is Empty ( ) ) { return new New Cookie ( cookie Name , token + STRING + ie Expires , null , null , null , max Age , BOOL ) ; } return null ; }
protected void init View ( ) { p . set Fake Bold Text ( BOOL ) ; p . set Anti Alias ( BOOL ) ; p . set Text Size ( MINI DAY NUMBER TEXT SIZE ) ; p . set Style ( Style . FILL ) ; m Month Num Paint = new Paint ( ) ; m Month Num Paint . set Fake Bold Text ( BOOL ) ; m Month Num Paint . set Anti Alias ( BOOL ) ; m Month Num Paint . set Text Size ( MINI DAY NUMBER TEXT SIZE ) ; m Month Num Paint . set Color ( m Focus Month Color ) ; m Month Num Paint . set Style ( Style . FILL ) ; m Month Num Paint . set Text Align ( Align . CENTER ) ; }
@ Override public boolean connection Allowed ( Event Set Descriptor esd ) { return connection Allowed ( esd . get Name ( ) ) ; }
Scheduled Future Task ( Runnable r , V result , long ns , long period ) { super ( r , result ) ; this . time = ns ; this . period = period ; this . sequence Number = sequencer . get And Increment ( ) ; }
public boolean verify ( X509 Certificate cert , Provider sig Provider ) throws No Such Algorithm Exception , Certificate Expired Exception , Certificate Not Yet Valid Exception , CMS Exception { Time signing Time = get Signing Time ( ) ; if ( signing Time != null ) { cert . check Validity ( signing Time . get Date ( ) ) ; } return do Verify ( cert . get Public Key ( ) , sig Provider ) ; }
public Geo Mark analyse ( final String text , final String [ ] tags , final int maxlength , final String salt ) { Geo Location loc = geocode ( text , tags , maxlength ) ; if ( loc != null ) return new Geo Mark ( loc , salt ) ; return reverse geocode ( text ) ; }
public void find And Init ( Iterator it ) { while ( it . has Next ( ) ) { find And Init ( it . next ( ) ) ; } }
public void test Select Order By ( ) throws SQL Exception { String select Query = STRING + Database Creator . ORDERS TABLE + STRING ; Result Set result = statement . execute Query ( select Query ) ; Array List < Integer > values = new Array List < Integer > ( ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; values . add ( Integer . value Of ( NUM ) ) ; int index = NUM ; while ( result . next ( ) ) { Integer onum = result . get Int ( STRING ) ; assert True ( STRING , values . contains ( onum ) ) ; assert Equals ( STRING , index , values . index Of ( onum ) ) ; index ++ ; } result . close ( ) ; }
private static String format To 2 Digits ( String str ) { if ( str . length ( ) < NUM ) { str = STRING + str ; } return str ; }
protected static String quote SQL ( Object data , int type ) throws SQL Exception { if ( data == null ) { return STRING ; } switch ( type ) { case Types . BIT : case Types . BOOLEAN : case Types . INTEGER : case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . NUMERIC : case Types . REAL : case Types . SMALLINT : case Types . TINYINT : return data . to String ( ) ; case Types . DATE : case Types . TIME : case Types . TIMESTAMP : case Types . LONGVARCHAR : case Types . CHAR : case Types . VARCHAR : return quote String ( data . to String ( ) ) ; case Types . VARBINARY : case Types . LONGVARBINARY : case Types . BINARY : if ( data instanceof UUID ) { return STRING + data . to String ( ) + STRING ; } return STRING + String Utils . convert Bytes To Hex ( ( byte [ ] ) data ) + STRING ; case Types . CLOB : case Types . JAVA OBJECT : case Types . OTHER : case Types . BLOB : case Types . STRUCT : case Types . REF : case Types . NULL : case Types . ARRAY : case Types . DATALINK : case Types . DISTINCT : throw throw Exception ( STRING + type ) ; default : return STRING ; } }
public void add Footer View ( View v , Object data , boolean is Selectable ) { Fixed View Info info = new Fixed View Info ( ) ; info . view = v ; info . data = data ; info . is Selectable = is Selectable ; m Footer View Infos . add ( info ) ; if ( m Adapter != null && m Observer != null ) { m Observer . on Changed ( ) ; } }
public static int calculate Digit Count ( long value ) { if ( value < NUM ) { if ( value != Long . MIN VALUE ) { return calculate Digit Count ( - value ) + NUM ; } else { return NUM ; } } return ( value < NUM ? NUM : ( value < NUM ? NUM : ( value < NUM ? NUM : ( value < NUM ? NUM : ( ( int ) ( Math . log ( value ) / LOG 10 ) + NUM ) ) ) ) ) ; }
public static Byte [ ] convert Date ( String date ) { String Tokenizer st = new String Tokenizer ( date ) ; String sdate = st . next Token ( ) ; String stime = st . next Token ( ) ; st = new String Tokenizer ( sdate , STRING ) ; String year = st . next Token ( ) ; int iyear = NUM ; try { iyear = Integer . parse Int ( year ) ; } catch ( Number Format Exception ex ) { debug . error ( STRING + year + STRING ) ; } byte yrlow = ( byte ) ( iyear & NUM ) ; byte yrhigh = ( byte ) ( ( ( iyear & NUM ) > > NUM ) & NUM ) ; String month = st . next Token ( ) ; String day = st . next Token ( ) ; st = new String Tokenizer ( stime , STRING ) ; String hour = st . next Token ( ) ; String min = st . next Token ( ) ; String sec = st . next Token ( ) ; Byte bz = Byte . value Of ( ( byte ) NUM ) ; Byte byrhi = bz ; Byte byrlo = bz ; Byte bmo = bz ; Byte bdy = bz ; Byte bhr = bz ; Byte bmn = bz ; Byte bsc = bz ; try { byrhi = new Byte ( yrhigh ) ; byrlo = new Byte ( yrlow ) ; bmo = new Byte ( month ) ; bdy = new Byte ( day ) ; bhr = new Byte ( hour ) ; bmn = new Byte ( min ) ; bsc = new Byte ( sec ) ; } catch ( Number Format Exception ex ) { debug . error ( STRING + STRING + sdate + STRING + stime ) ; } Byte [ ] ret = new Byte [ NUM ] ; ret [ NUM ] = byrhi ; ret [ NUM ] = byrlo ; ret [ NUM ] = bmo ; ret [ NUM ] = bdy ; ret [ NUM ] = bhr ; ret [ NUM ] = bmn ; ret [ NUM ] = bsc ; ret [ NUM ] = bz ; return ret ; }
private void parse And Add ( String line , Buffered Reader reader ) throws IO Exception { try { String Tokenizer tokenizer = new String Tokenizer ( line , STRING ) ; String tag = tokenizer . next Token ( ) ; if ( tag . equals ( STRING ) ) { continuity Weight = Integer . parse Int ( tokenizer . next Token ( ) ) ; } else if ( tag . equals ( STRING ) ) { optimal Coupling = Integer . parse Int ( tokenizer . next Token ( ) ) ; } else if ( tag . equals ( STRING ) ) { extend Selections = Integer . parse Int ( tokenizer . next Token ( ) ) ; } else if ( tag . equals ( STRING ) ) { join Method = Integer . parse Int ( tokenizer . next Token ( ) ) ; } else if ( tag . equals ( STRING ) ) { int num Weights = Integer . parse Int ( tokenizer . next Token ( ) ) ; join Weights = new int [ num Weights ] ; for ( int i = NUM ; i < num Weights ; i ++ ) { join Weights [ i ] = Integer . parse Int ( tokenizer . next Token ( ) ) ; } join Weight Shift = calc Join Weight Shift ( join Weights ) ; } else if ( tag . equals ( STRING ) ) { String name = tokenizer . next Token ( ) ; if ( name . equals ( STRING ) ) { sts = new Sample Set ( tokenizer , reader ) ; } else { mcep = new Sample Set ( tokenizer , reader ) ; } } else if ( tag . equals ( STRING ) ) { int type = Integer . parse Int ( tokenizer . next Token ( ) ) ; int phone = Integer . parse Int ( tokenizer . next Token ( ) ) ; int start = Integer . parse Int ( tokenizer . next Token ( ) ) ; int end = Integer . parse Int ( tokenizer . next Token ( ) ) ; int prev = Integer . parse Int ( tokenizer . next Token ( ) ) ; int next = Integer . parse Int ( tokenizer . next Token ( ) ) ; Database Cluster Unit unit = new Database Cluster Unit ( type , phone , start , end , prev , next ) ; unit List . add ( unit ) ; } else if ( tag . equals ( STRING ) ) { String name = tokenizer . next Token ( ) ; int nodes = Integer . parse Int ( tokenizer . next Token ( ) ) ; CART cart = new CART Impl ( reader , nodes ) ; cart Map . put ( name , cart ) ; if ( default Cart == null ) { default Cart = cart ; } } else if ( tag . equals ( STRING ) ) { String name = tokenizer . next Token ( ) ; int start = Integer . parse Int ( tokenizer . next Token ( ) ) ; int count = Integer . parse Int ( tokenizer . next Token ( ) ) ; Unit Type unit Type = new Unit Type ( name , start , count ) ; unit Types List . add ( unit Type ) ; } else { throw new Error ( STRING + tag + STRING + line + STRING ) ; } } catch ( No Such Element Exception nse ) { throw new Error ( STRING + nse . get Message ( ) ) ; } catch ( Number Format Exception nfe ) { throw new Error ( STRING + line + STRING + nfe . get Message ( ) ) ; } }
public String byte String No Semicolon ( ) { String Builder retval = new String Builder ( ) ; try { while ( BOOL ) { char next = look Ahead ( NUM ) ; if ( next == STRING || next == STRING || next == STRING || next == STRING ) { break ; } else { consume ( NUM ) ; retval . append ( next ) ; } } } catch ( Parse Exception ex ) { return retval . to String ( ) ; } return retval . to String ( ) ; }
public void test Neg Neg First Longer ( ) { byte a Bytes [ ] = { - NUM , NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , - NUM } ; byte b Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { - NUM , NUM , NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
public static void println ( double x ) { out . println ( x ) ; }
public boolean subscribe Topic ( @ Non Null Context context , @ Non Null String [ ] new Topics ) { if ( ! initialized ) init ( context ) ; if ( new Topics . length == NUM ) return BOOL ; if ( null == topics ) { topics = new Array List < > ( ) ; } for ( String topic : new Topics ) { if ( topics . contains ( topic ) ) { return BOOL ; } topics . add ( topic ) ; } save Subscibed Topics ( context ) ; Intent intent = new Intent ( context , Registration Intent Service . class ) ; intent . set Action ( Registration Intent Service . ACTION SUBSCRIBE ) ; intent . put Extra ( Registration Intent Service . EXTRA TOPIC LIST , new Topics ) ; context . start Service ( intent ) ; return BOOL ; }
public static String serialise ( Node node ) { try { DOM Implementation Registry registry = DOM Implementation Registry . new Instance ( ) ; DOM Implementation LS ls Impl = ( DOM Implementation LS ) registry . get DOM Implementation ( STRING ) ; LS Serializer serializer = ls Impl . create LS Serializer ( ) ; return serializer . write To String ( node ) ; } catch ( Exception e ) { log . fine ( STRING + e ) ; return STRING ; } }
public static boolean is On Segment ( Geo a , Geo b , Geo i ) { return ( ( a . distance ( i ) < a . distance ( b ) ) && ( b . distance ( i ) < b . distance ( a ) ) ) ; }
public void add Extension Point ( Extension Point extension Point ) { f Extension Points . add ( extension Point ) ; }
private List add Node To List ( int start Index For Node , int end Index For Node ) { List localvm List = new Array List ( ) ; for ( int i = start Index For Node ; i < end Index For Node ; i ++ ) { localvm List . add ( vm [ i ] ) ; } return localvm List ; }
public void add Meta Method ( Meta Method method ) { if ( is Initialized ( ) ) { throw new Runtime Exception ( STRING + method ) ; } final Cached Class declaring Class = method . get Declaring Class ( ) ; add Meta Method To Index ( method , meta Method Index . get Header ( declaring Class . get The Class ( ) ) ) ; }
public void wait For Event ( long timeout ) { Thread thread = Thread . current Thread ( ) ; Semaphore semaphore = semaphores . get ( thread ) ; if ( semaphore == null ) { semaphore = new Semaphore ( NUM , BOOL ) ; semaphore . drain Permits ( ) ; semaphores . put If Absent ( thread , semaphore ) ; } semaphore = semaphores . get ( thread ) ; try { semaphore . try Acquire ( timeout , Time Unit . MILLISECONDS ) ; } catch ( Interrupted Exception exception ) { logger . log ( Level . FINER , STRING , exception ) ; } }
public String string Value ( ) { Object cv = Assert . check Non Null ( const Value ( ) ) ; return cv . to String ( ) ; }
public Date parse Date ( String str ) { try { return date Format . parse ( str ) ; } catch ( java . text . Parse Exception e ) { throw new Runtime Exception ( e ) ; } }
default int hash 32 ( String value ) { return hash 32 ( value . get Bytes ( ) ) ; }
public Name add All ( Name suffix ) throws Invalid Name Exception { return add All ( size ( ) , suffix ) ; }
public final Input Stream as Input Stream ( ) throws Unknown Resource Exception { return to Input Stream ( ) ; }
private static double euclidean Norm ( double vector [ ] ) { int n = vector . length ; if ( n < NUM ) { return NUM ; } if ( n == NUM ) { return Math . abs ( vector [ NUM ] ) ; } double scale = NUM ; double sum = NUM ; for ( int i = NUM ; i < n ; i ++ ) { if ( vector [ i ] != NUM ) { double abs = Math . abs ( vector [ i ] ) ; if ( scale < abs ) { double t = scale / abs ; sum = NUM + sum * ( t * t ) ; scale = abs ; } else { double t = abs / scale ; sum += t * t ; } } } return scale * Math . sqrt ( sum ) ; }
public static File Descriptor create Socket ( ) throws IO Exception { if ( ! is Supported ) throw new Unsupported Operation Exception ( STRING ) ; int fd Val = create 0 ( ) ; File Descriptor fd = new File Descriptor ( ) ; fd Access . set ( fd , fd Val ) ; return fd ; }
public static Grammar do The Merges ( Grammar grammar , Lexicon lexicon , boolean [ ] [ ] [ ] merge These Pairs , double [ ] [ ] merge Weights ) { short [ ] num Sub States Array = grammar . num Sub States ; short [ ] new Num Sub States Array = grammar . num Sub States ; Grammar new Grammar = null ; while ( BOOL ) { boolean something To Merge = BOOL ; for ( int tag = NUM ; tag < num Sub States Array . length ; tag ++ ) { for ( int i = NUM ; i < new Num Sub States Array [ tag ] ; i ++ ) { for ( int j = NUM ; j < new Num Sub States Array [ tag ] ; j ++ ) { something To Merge = something To Merge || merge These Pairs [ tag ] [ i ] [ j ] ; } } } if ( ! something To Merge ) break ; boolean [ ] [ ] [ ] merge This Iteration = new boolean [ new Num Sub States Array . length ] [ ] [ ] ; for ( int tag = NUM ; tag < num Sub States Array . length ; tag ++ ) { merge This Iteration [ tag ] = new boolean [ merge These Pairs [ tag ] . length ] [ merge These Pairs [ tag ] . length ] ; for ( int i = NUM ; i < merge These Pairs [ tag ] . length ; i ++ ) { for ( int j = NUM ; j < merge These Pairs [ tag ] . length ; j ++ ) { merge This Iteration [ tag ] [ i ] [ j ] = merge These Pairs [ tag ] [ i ] [ j ] ; } } } for ( int tag = NUM ; tag < num Sub States Array . length ; tag ++ ) { boolean [ ] already Decided To Merge = new boolean [ merge These Pairs [ tag ] . length ] ; for ( int i = NUM ; i < merge These Pairs [ tag ] . length ; i ++ ) { for ( int j = NUM ; j < merge These Pairs [ tag ] . length ; j ++ ) { if ( already Decided To Merge [ i ] || already Decided To Merge [ j ] ) merge This Iteration [ tag ] [ i ] [ j ] = BOOL ; already Decided To Merge [ i ] = already Decided To Merge [ i ] || merge These Pairs [ tag ] [ i ] [ j ] ; already Decided To Merge [ j ] = already Decided To Merge [ j ] || merge These Pairs [ tag ] [ i ] [ j ] ; } } } for ( int tag = NUM ; tag < num Sub States Array . length ; tag ++ ) { for ( int i = NUM ; i < merge These Pairs [ tag ] . length ; i ++ ) { for ( int j = NUM ; j < merge These Pairs [ tag ] . length ; j ++ ) { merge These Pairs [ tag ] [ i ] [ j ] = merge These Pairs [ tag ] [ i ] [ j ] && ! merge This Iteration [ tag ] [ i ] [ j ] ; } } } new Grammar = grammar . merge States ( merge This Iteration , merge Weights ) ; lexicon . merge States ( merge This Iteration , merge Weights ) ; grammar . fix Merge Weights Etc ( merge These Pairs , merge Weights , merge This Iteration ) ; grammar = new Grammar ; new Num Sub States Array = grammar . num Sub States ; } grammar . make CR Arrays ( ) ; return grammar ; }
private static void extract File ( Zip Input Stream zip In , String file Path ) throws IO Exception { Buffered Output Stream bos = new Buffered Output Stream ( new File Output Stream ( file Path ) ) ; byte [ ] bytes In = new byte [ BUFFER SIZE ] ; int read = NUM ; while ( ( read = zip In . read ( bytes In ) ) != - NUM ) { bos . write ( bytes In , NUM , read ) ; } bos . close ( ) ; }
public static final String square To String ( int square ) { String Builder ret = new String Builder ( ) ; int x = Position . get X ( square ) ; int y = Position . get Y ( square ) ; ret . append ( ( char ) ( x + STRING ) ) ; ret . append ( ( char ) ( y + STRING ) ) ; return ret . to String ( ) ; }
protected void draw Vertical Item ( Graphics 2 D g2 , Category Item Renderer State state , Rectangle 2 D data Area , Category Plot plot , Category Axis domain Axis , Value Axis range Axis , Statistical Category Dataset dataset , int visible Row , int row , int column ) { double rect X = calculate Bar W 0 ( plot , Plot Orientation . VERTICAL , data Area , domain Axis , state , visible Row , column ) ; Number mean Value = dataset . get Mean Value ( row , column ) ; if ( mean Value == null ) { return ; } double value = mean Value . double Value ( ) ; double base = NUM ; double lclip = get Lower Clip ( ) ; double uclip = get Upper Clip ( ) ; if ( uclip <= NUM ) { if ( value >= uclip ) { return ; } base = uclip ; if ( value <= lclip ) { value = lclip ; } } else if ( lclip <= NUM ) { if ( value >= uclip ) { value = uclip ; } else { if ( value <= lclip ) { value = lclip ; } } } else { if ( value <= lclip ) { return ; } base = get Lower Clip ( ) ; if ( value >= uclip ) { value = uclip ; } } Rectangle Edge y Axis Location = plot . get Range Axis Edge ( ) ; double trans Y 1 = range Axis . value To Java 2 D ( base , data Area , y Axis Location ) ; double trans Y 2 = range Axis . value To Java 2 D ( value , data Area , y Axis Location ) ; double rect Y = Math . min ( trans Y 2 , trans Y 1 ) ; double rect Width = state . get Bar Width ( ) ; double rect Height = Math . abs ( trans Y 2 - trans Y 1 ) ; Rectangle 2 D bar = new Rectangle 2 D . Double ( rect X , rect Y , rect Width , rect Height ) ; Paint item Paint = get Item Paint ( row , column ) ; Gradient Paint Transformer t = get Gradient Paint Transformer ( ) ; if ( t != null && item Paint instanceof Gradient Paint ) { item Paint = t . transform ( ( Gradient Paint ) item Paint , bar ) ; } g2 . set Paint ( item Paint ) ; g2 . fill ( bar ) ; if ( is Draw Bar Outline ( ) && state . get Bar Width ( ) > BAR OUTLINE WIDTH THRESHOLD ) { Stroke stroke = get Item Outline Stroke ( row , column ) ; Paint paint = get Item Outline Paint ( row , column ) ; if ( stroke != null && paint != null ) { g2 . set Stroke ( stroke ) ; g2 . set Paint ( paint ) ; g2 . draw ( bar ) ; } } Number n = dataset . get Std Dev Value ( row , column ) ; if ( n != null ) { double value Delta = n . double Value ( ) ; double high Val = range Axis . value To Java 2 D ( mean Value . double Value ( ) + value Delta , data Area , y Axis Location ) ; double low Val = range Axis . value To Java 2 D ( mean Value . double Value ( ) - value Delta , data Area , y Axis Location ) ; if ( this . error Indicator Paint != null ) { g2 . set Paint ( this . error Indicator Paint ) ; } else { g2 . set Paint ( get Item Outline Paint ( row , column ) ) ; } if ( this . error Indicator Stroke != null ) { g2 . set Stroke ( this . error Indicator Stroke ) ; } else { g2 . set Stroke ( get Item Outline Stroke ( row , column ) ) ; } Line 2 D line ; line = new Line 2 D . Double ( rect X + rect Width / NUM , low Val , rect X + rect Width / NUM , high Val ) ; g2 . draw ( line ) ; line = new Line 2 D . Double ( rect X + rect Width / NUM - NUM , high Val , rect X + rect Width / NUM + NUM , high Val ) ; g2 . draw ( line ) ; line = new Line 2 D . Double ( rect X + rect Width / NUM - NUM , low Val , rect X + rect Width / NUM + NUM , low Val ) ; g2 . draw ( line ) ; } Category Item Label Generator generator = get Item Label Generator ( row , column ) ; if ( generator != null && is Item Label Visible ( row , column ) ) { draw Item Label ( g2 , dataset , row , column , plot , generator , bar , ( value < NUM ) ) ; } Entity Collection entities = state . get Entity Collection ( ) ; if ( entities != null ) { add Item Entity ( entities , dataset , row , column , bar ) ; } }
public static boolean has Valid Cover ( I Game game , Coords pos , int elevation ) { if ( ( pos == null ) || ( elevation > NUM ) ) { return BOOL ; } boolean has Moved Entity = BOOL ; for ( Entity e : game . get Entities Vector ( pos ) ) { if ( e . is Done ( ) && ! ( e instanceof Infantry ) && ( e . get Elevation ( ) == elevation ) ) { has Moved Entity = BOOL ; break ; } } if ( ! has Moved Entity ) { Enumeration < Entity > wrecks = game . get Wrecked Entities ( ) ; while ( wrecks . has More Elements ( ) ) { Entity e = wrecks . next Element ( ) ; if ( pos . equals ( e . get Position ( ) ) && ! ( e instanceof Infantry ) ) { has Moved Entity = BOOL ; } } } return has Moved Entity ; }
public static Coordinate [ ] compute Tangents Through Point ( Coordinate circle Center , double radius , Coordinate point ) { Coordinate [ ] ret = new Coordinate [ NUM ] ; double dx = ( point . x - circle Center . x ) / NUM ; double dy = ( point . y - circle Center . y ) / NUM ; double d = Math . sqrt ( dx * dx + dy * dy ) ; double a = ( radius * radius ) / ( NUM * d ) ; double x2 = circle Center . x + ( dx * a / d ) ; double y2 = circle Center . y + ( dy * a / d ) ; double h = Math . sqrt ( radius * radius - a * a ) ; double rx = - dy * ( h / d ) ; double ry = dx * ( h / d ) ; double xi = x2 + rx ; double yi = y2 + ry ; double xi Prime = x2 - rx ; double yi Prime = y2 - ry ; ret [ NUM ] = new Coordinate ( point ) ; ret [ NUM ] = new Coordinate ( xi , yi ) ; ret [ NUM ] = new Coordinate ( xi Prime , yi Prime ) ; return ret ; }
public void add Group ( Group Config Interface sub Group ) { sub Group List . add ( sub Group ) ; }
public void start Scanning ( final Beacon Service Connection service Connection ) { final Cursor cursor = m Database Helper . get All Regions ( ) ; while ( cursor . move To Next ( ) ) { final UUID uuid = UUID . from String ( cursor . get String ( NUM ) ) ; final int major = cursor . get Int ( NUM ) ; final int minor = cursor . get Int ( NUM ) ; final int event = cursor . get Int ( NUM ) ; service Connection . start Ranging Beacons In Region ( Beacons Fragment . BEACON COMPANY ID , uuid , major , minor , this ) ; if ( event == Beacon Contract . EVENT IN RANGE || event == Beacon Contract . EVENT OUT OF RANGE ) service Connection . start Monitoring For Region ( Beacons Fragment . BEACON COMPANY ID , uuid , major , minor , this ) ; } }
public void test Divide Round Half Down Neg 1 ( ) { String a = STRING ; int a Scale = - NUM ; String b = STRING ; int b Scale = NUM ; String c = STRING ; int res Scale = - NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; Big Decimal result = a Number . divide ( b Number , res Scale , Big Decimal . ROUND HALF DOWN ) ; assert Equals ( STRING , c , result . to String ( ) ) ; assert Equals ( STRING , res Scale , result . scale ( ) ) ; }
public static boolean is Header ( Header hdr ) { return hdr . get Boolean Value ( ZIMAGE , BOOL ) ; }
public static Info Register create Folder ( User user , Integer book Id , List atts , List inter , Map documents , String entidad , boolean consolidacion ) throws Validation Exception , Security Exception , Book Exception , Session Exception , Tec Doc Exception , Parse Exception , Attributes Exception { Info Register result = new Info Register ( ) ; String session ID = new String ( ) ; try { session ID = Login . login ( user , entidad ) ; set Office User Register ( entidad , session ID , atts ) ; Book Session . open Book ( session ID , book Id , entidad ) ; Integer launch Dist Out Register = Register Services Util . get Inves Conf Actions ( entidad ) ; Register Services Util . can Create Folder ( session ID , book Id , documents , user , atts , entidad , consolidacion ) ; Ax Sf axsf Q = Book Session . get Form Format ( session ID , book Id , entidad ) ; Field Format field Format = Register Services Util . get Field Format ( session ID , book Id ) ; Map translated Ids = Register Services Util . get Fields With Sustitute ( atts , axsf Q , session ID , book Id , entidad ) ; Ax Sf new Ax SF = Register Services Util . init In Or Out Folder ( user , axsf Q ) ; new Ax SF = Register Services Util . complete Folder ( translated Ids , axsf Q , new Ax SF , user . get Locale ( ) , atts , field Format , consolidacion ) ; Folder Data Session data = Register . create New Folder ( session ID , book Id , new Ax SF , inter , documents , launch Dist Out Register , user . get Locale ( ) , entidad , consolidacion ) ; result = Consult Register . consult Register Info ( book Id , data . get Axsf New ( ) , data . get New Register ID ( ) , data . get Scrofic ( ) , data . get User Name ( ) , user . get Locale ( ) ) ; } finally { Book Session . close Book ( session ID , book Id ) ; Security Session . logout ( session ID , entidad ) ; } return result ; }
public void close ( ) throws IO Exception { f Input Stream . close ( ) ; }
private void handle Subscription Error ( Azure Allocation Context ctx , String namespace , Throwable e ) { if ( e instanceof Cloud Exception ) { Cloud Exception ce = ( Cloud Exception ) e ; Cloud Error body = ce . get Body ( ) ; if ( body != null ) { String code = body . get Code ( ) ; if ( MISSING SUBSCRIPTION CODE . equals ( code ) ) { register Subscription ( ctx , namespace ) ; return ; } } } handle Error ( ctx , e ) ; }
public boolean has Shutdown Hook ( Runnable shutdown Hook ) { return hooks . contains ( shutdown Hook ) ; }
@ Override public void end Process Sub Tokens ( ) { if ( ! skey . is Empty ( ) ) { map . put ( skey , sval ) ; skey = STRING ; sval = STRING ; } }
private void heapify Down ( Comparable < Object > cur ) { final int stop = size > > > NUM ; int twopos = NUM ; while ( twopos < stop ) { int bestchild = ( twopos << NUM ) + NUM ; Comparable < Object > best = twoheap [ bestchild ] ; final int right = bestchild + NUM ; if ( right < size && best . compare To ( twoheap [ right ] ) > NUM ) { bestchild = right ; best = twoheap [ right ] ; } if ( cur . compare To ( best ) <= NUM ) { break ; } twoheap [ twopos ] = best ; twopos = bestchild ; } twoheap [ twopos ] = cur ; }
public void add Feature ( I Feature Vector fv ) { idx List . add All ( Ints . as List ( fv . get Indices ( ) ) ) ; val List . add All ( Floats . as List ( fv . get Values ( ) ) ) ; }
protected void wait For External Store Mount ( ) throws Exception { String ext Storage State = Environment . get External Storage State ( ) ; int current Wait Time = NUM ; while ( ! ext Storage State . equals ( Environment . MEDIA MOUNTED ) ) { Log . i ( LOG TAG , STRING ) ; current Wait Time = timeout Wait ( current Wait Time , DEFAULT WAIT POLL TIME , DEFAULT MAX WAIT TIME , STRING ) ; ext Storage State = Environment . get External Storage State ( ) ; } }
public static Data Display Table list Glyph Dimension Bounds ( Font font ) { String [ ] header = { STRING , STRING } ; Align [ ] display Alignment = { Align . Left , Align . Right } ; Data Display Table table = new Data Display Table ( Arrays . as List ( header ) ) ; table . set Alignment ( Arrays . as List ( display Alignment ) ) ; Loca Table loca Table = Font Utils . get Loca Table ( font ) ; Glyph Table glyf Table = Font Utils . get Glyph Table ( font ) ; int x Min = Integer . MAX VALUE ; int y Min = Integer . MAX VALUE ; int x Max = Integer . MIN VALUE ; int y Max = Integer . MIN VALUE ; for ( int i = NUM ; i < loca Table . num Glyphs ( ) ; i ++ ) { Glyph glyph = glyf Table . glyph ( loca Table . glyph Offset ( i ) , loca Table . glyph Length ( i ) ) ; if ( glyph . x Min ( ) < x Min ) { x Min = glyph . x Min ( ) ; } if ( glyph . y Min ( ) < y Min ) { y Min = glyph . y Min ( ) ; } if ( glyph . x Max ( ) > x Max ) { x Max = glyph . x Max ( ) ; } if ( glyph . y Max ( ) > y Max ) { y Max = glyph . y Max ( ) ; } } table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , x Min ) } ) ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , x Max ) } ) ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , y Min ) } ) ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , y Max ) } ) ) ; return table ; }
private boolean is In Thumb Range ( float touch X , double normalized Thumb Value ) { return Math . abs ( touch X - normalized To Screen ( normalized Thumb Value ) ) <= thumb Half Width ; }
public static byte [ ] str 2 Unicode Byte Array ( final JBBP Byte Order byte Order , final String str ) { final byte [ ] result = new byte [ str . length ( ) << NUM ] ; int index = NUM ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) { final int val = str . char At ( i ) ; switch ( byte Order ) { case BIG ENDIAN : { result [ index ++ ] = ( byte ) ( val > > NUM ) ; result [ index ++ ] = ( byte ) val ; } break ; case LITTLE ENDIAN : { result [ index ++ ] = ( byte ) val ; result [ index ++ ] = ( byte ) ( val > > NUM ) ; } break ; default : throw new Error ( STRING + byte Order + STRING ) ; } } return result ; }
private Method Def parse method ( Str Tok st ) { String method name = st . need word ( ) ; st . need ( STRING ) ; Array List < String > args = new Array List < > ( ) ; String tok = st . next Token ( ) ; if ( tok != STRING ) { st . push Back ( ) ; do { tok = st . need word ( ) ; args . add ( tok ) ; } while ( st . next Token ( ) == STRING ) ; st . push Back ( ) ; st . need ( STRING ) ; } Type [ ] targs = new Type [ args . size ( ) ] ; for ( int ii = NUM ; ii < args . size ( ) ; ii ++ ) { targs [ ii ] = BCEL Util . classname to type ( args . get ( ii ) ) ; } return new Method Def ( method name , targs ) ; }
private void write Experieced And Causing Person Delay ( ) { Sorted Map < Double , Map < Id < Person > , Double > > time Bin 2 Affected Person 2 Delay = get Experienced Person Delay ( NUM ) ; Sorted Map < Double , Map < Id < Person > , Double > > time Bin 2 Causing Person 2 Delay = get Causing Person Delay ( NUM ) ; if ( time Bin 2 Affected Person 2 Delay . size ( ) != NUM ) throw new Runtime Exception ( STRING ) ; Map < Id < Person > , Double > affectedperson 2 Delay = time Bin 2 Affected Person 2 Delay . get ( simulation End Time ) ; Map < Id < Person > , Double > caused Person 2 Delay = time Bin 2 Causing Person 2 Delay . get ( simulation End Time ) ; Buffered Writer writer = IO Utils . get Buffered Writer ( run Dir + STRING + pricing Scenario + suffix For Soring + STRING ) ; try { writer . write ( STRING ) ; for ( Id < Person > id : caused Person 2 Delay . key Set ( ) ) { writer . write ( id + STRING + pf . get Munich User Group From Person Id ( id ) + STRING + affectedperson 2 Delay . get ( id ) / NUM + STRING + caused Person 2 Delay . get ( id ) / NUM + STRING ) ; } writer . close ( ) ; } catch ( Exception e ) { throw new Runtime Exception ( STRING + e ) ; } }
static List < List < File > > partition ( final int bin Count , final File ... files ) { final File [ ] sort = Arrays . copy Of ( files , files . length ) ; return bin Them ( bin Count , sort ) ; }
private void calc Bite Point ( int center X , int center Y , float circle Edge X , float circle Edge Y , double bite Line , boolean is First Bite , boolean is Random Bite ) { double bite Percent ; if ( is First Bite ) { bite X = ( int ) circle Edge X ; bite Y = ( int ) circle Edge Y ; } else { bite Percent = bite Radius / bite Line ; if ( is Random Bite ) { bite Percent *= bites Taken Map . get ( bite Direction ) ; } else { bite Percent *= ( num Bites For One Direction - num Bites For One Direction Left ) ; } bite X = Draw Utils . get Point Between Two Points ( circle Edge X , center X , bite Percent ) ; bite Y = Draw Utils . get Point Between Two Points ( circle Edge Y , center Y , bite Percent ) ; } }
private boolean zz Refill ( ) throws java . io . IO Exception { if ( zz Start Read > NUM ) { System . arraycopy ( zz Buffer , zz Start Read , zz Buffer , NUM , zz End Read - zz Start Read ) ; zz End Read -= zz Start Read ; zz Current Pos -= zz Start Read ; zz Marked Pos -= zz Start Read ; zz Pushback Pos -= zz Start Read ; zz Start Read = NUM ; } if ( zz Current Pos >= zz Buffer . length ) { char new Buffer [ ] = new char [ zz Current Pos * NUM ] ; System . arraycopy ( zz Buffer , NUM , new Buffer , NUM , zz Buffer . length ) ; zz Buffer = new Buffer ; } int num Read = zz Reader . read ( zz Buffer , zz End Read , zz Buffer . length - zz End Read ) ; if ( num Read < NUM ) { return BOOL ; } else { zz End Read += num Read ; return BOOL ; } }
private void update Business Object Definition Entity Descriptive Information ( Business Object Definition Entity business Object Definition Entity , Business Object Definition Descriptive Information Update Request request ) { business Object Definition Entity . set Description ( request . get Description ( ) ) ; business Object Definition Entity . set Display Name ( request . get Display Name ( ) ) ; business Object Definition Dao . save And Refresh ( business Object Definition Entity ) ; }
@ Override public void on Download Progress ( Download Progress Info progress ) { m Average Speed . set Text ( get String ( R . string . kilobytes per second , Helpers . get Speed String ( progress . m Current Speed ) ) ) ; m Time Remaining . set Text ( get String ( R . string . time remaining , Helpers . get Time Remaining ( progress . m Time Remaining ) ) ) ; progress . m Overall Total = progress . m Overall Total ; mPB . set Max ( ( int ) ( progress . m Overall Total > > NUM ) ) ; mPB . set Progress ( ( int ) ( progress . m Overall Progress > > NUM ) ) ; m Progress Percent . set Text ( Long . to String ( progress . m Overall Progress * NUM / progress . m Overall Total ) + STRING ) ; m Progress Fraction . set Text ( Helpers . get Download Progress String ( progress . m Overall Progress , progress . m Overall Total ) ) ; }
static public boolean is Same Day ( Timestamp one , Timestamp two ) { Gregorian Calendar cal One = new Gregorian Calendar ( ) ; if ( one != null ) cal One . set Time In Millis ( one . get Time ( ) ) ; Gregorian Calendar cal Two = new Gregorian Calendar ( ) ; if ( two != null ) cal Two . set Time In Millis ( two . get Time ( ) ) ; if ( cal One . get ( Calendar . YEAR ) == cal Two . get ( Calendar . YEAR ) && cal One . get ( Calendar . MONTH ) == cal Two . get ( Calendar . MONTH ) && cal One . get ( Calendar . DAY OF MONTH ) == cal Two . get ( Calendar . DAY OF MONTH ) ) return BOOL ; return BOOL ; }
public static void update All For Facade ( Data Store data Store , Iterable < Update > updates ) { update All For Facade ( data Store , updates . iterator ( ) ) ; }
public Array Field Vector ( Field Vector < T > v1 , Field Vector < T > v2 ) throws Null Argument Exception { Math Utils . check Not Null ( v1 ) ; Math Utils . check Not Null ( v2 ) ; field = v1 . get Field ( ) ; final T [ ] v1 Data = ( v1 instanceof Array Field Vector ) ? ( ( Array Field Vector < T > ) v1 ) . data : v1 . to Array ( ) ; final T [ ] v2 Data = ( v2 instanceof Array Field Vector ) ? ( ( Array Field Vector < T > ) v2 ) . data : v2 . to Array ( ) ; data = Math Arrays . build Array ( field , v1 Data . length + v2 Data . length ) ; System . arraycopy ( v1 Data , NUM , data , NUM , v1 Data . length ) ; System . arraycopy ( v2 Data , NUM , data , v1 Data . length , v2 Data . length ) ; }
public boolean equals ( Object o ) { if ( o instanceof Service Config Manager ) { Service Config Manager oscm = ( Service Config Manager ) o ; if ( service Name . equals ( oscm . service Name ) && version . equals ( oscm . version ) ) { return ( BOOL ) ; } } return ( BOOL ) ; }
public void add Item Bounds Listener ( Item Bounds Listener ibl ) { if ( m bounders == null ) m bounders = new Copy On Write Array List ( ) ; m bounders . add ( ibl ) ; }
public static S2 Cell Id from Face IJ ( int face , int i , int j ) { long n [ ] = { NUM , face << ( POS BITS - NUM ) } ; int bits = ( face & SWAP MASK ) ; for ( int k = NUM ; k >= NUM ; -- k ) { bits = get Bits ( n , i , j , k , bits ) ; } S2 Cell Id s = new S2 Cell Id ( ( ( ( n [ NUM ] << NUM ) + n [ NUM ] ) << NUM ) + NUM ) ; return s ; }
public void increase Dpi ( ) { if ( this . current Dpi Pos < ( this . dpi Sizes . length - NUM ) ) { ++ this . current Dpi Pos ; } }
String Vector process PREFIX URLLIST ( Stylesheet Handler handler , String uri , String name , String raw Name , String value ) throws org . xml . sax . SAX Exception { String Tokenizer tokenizer = new String Tokenizer ( value , STRING ) ; int n Strings = tokenizer . count Tokens ( ) ; String Vector strings = new String Vector ( n Strings ) ; for ( int i = NUM ; i < n Strings ; i ++ ) { String prefix = tokenizer . next Token ( ) ; String url = handler . get Namespace For Prefix ( prefix ) ; if ( url != null ) strings . add Element ( url ) ; else throw new org . xml . sax . SAX Exception ( XSL Messages . create Message ( XSLT Error Resources . ER CANT RESOLVE NSPREFIX , new Object [ ] { prefix } ) ) ; } return strings ; }
@ Override public void write ( Data Output out ) throws IO Exception { out . write Long ( duration ) ; out . write Int ( get Length ( ) ) ; for ( int i = NUM ; i < coeffs . length ; i ++ ) { out . write Float ( coeffs [ i ] ) ; } }
private void add Sharing Profiles ( Collection < Sharing Profile > sharing Profiles ) throws Guacamole Exception { for ( Sharing Profile sharing Profile : sharing Profiles ) { String primary Connection Identifier = sharing Profile . get Primary Connection Identifier ( ) ; API Connection primary Connection = retrieved Connections . get ( primary Connection Identifier ) ; if ( primary Connection != null ) { Collection < API Sharing Profile > children = primary Connection . get Sharing Profiles ( ) ; if ( children == null ) { children = new Array List < API Sharing Profile > ( ) ; primary Connection . set Sharing Profiles ( children ) ; } children . add ( new API Sharing Profile ( sharing Profile ) ) ; } else logger . debug ( STRING + STRING + STRING , sharing Profile . get Identifier ( ) , primary Connection Identifier ) ; } }
public void failover Copy ( RP Copy Request Params copy To Failover To ) throws Recover Point Exception { String bookmark Name = copy To Failover To . get Bookmark Name ( ) ; Date apit Time = copy To Failover To . get Apit Time ( ) ; if ( bookmark Name != null ) { logger . info ( STRING + bookmark Name ) ; } else if ( apit Time != null ) { logger . info ( STRING + apit Time . to String ( ) ) ; } else { logger . info ( STRING ) ; } Recover Point Image Management Utils image Manager = new Recover Point Image Management Utils ( ) ; image Manager . enable Copy Image ( functional API , copy To Failover To , BOOL ) ; }
private static void prepare Logging System Enviroment ( ) { System . set Property ( STRING , get Log Folder ( ) ) ; }
public State Attribute ( byte [ ] octets ) { super ( octets ) ; state = new String ( octets , NUM , octets . length - NUM , Charset . for Name ( STRING ) ) ; }
private static long calc Size ( long size , long skip , long limit ) { return size >= NUM ? Math . max ( - NUM , Math . min ( size - skip , limit ) ) : - NUM ; }
public static Collection < Inet Socket Address > resolve Addresses ( Address Resolver addr Rslvr , Iterable < String > addrs , int port ) throws Ignite Spi Exception { assert addr Rslvr != null ; Collection < Inet Socket Address > ext Addrs = new Hash Set < > ( ) ; for ( String addr : addrs ) { Inet Socket Address sock Addr = new Inet Socket Address ( addr , port ) ; if ( ! sock Addr . is Unresolved ( ) ) { Collection < Inet Socket Address > ext Addrs 0 = resolve Address ( addr Rslvr , sock Addr ) ; if ( ext Addrs 0 != null ) ext Addrs . add All ( ext Addrs 0 ) ; } } return ext Addrs ; }
private double sample From Gamma ( double k , double theta ) { boolean accept = BOOL ; if ( k < NUM ) { double c = ( NUM / k ) ; double d = ( ( NUM - k ) * Math . pow ( k , ( k / ( NUM - k ) ) ) ) ; double u , v , z , e , x ; do { u = rng . next Double ( ) ; v = rng . next Double ( ) ; z = - Math . log ( u ) ; e = - Math . log ( v ) ; x = Math . pow ( z , c ) ; if ( ( z + e ) >= ( d + x ) ) { accept = BOOL ; } } while ( ! accept ) ; return ( x * theta ) ; } else { double b = ( k - Math . log ( NUM ) ) ; double c = ( k + Math . sqrt ( NUM * k - NUM ) ) ; double lam = Math . sqrt ( NUM * k - NUM ) ; double cheng = ( NUM + Math . log ( NUM ) ) ; double u , v , x , y , z , r ; do { u = rng . next Double ( ) ; v = rng . next Double ( ) ; y = ( ( NUM / lam ) * Math . log ( v / ( NUM - v ) ) ) ; x = ( k * Math . exp ( y ) ) ; z = ( u * v * v ) ; r = ( b + ( c * y ) - x ) ; if ( ( r >= ( ( NUM * z ) - cheng ) ) || ( r >= Math . log ( z ) ) ) { accept = BOOL ; } } while ( ! accept ) ; return ( x * theta ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public Blockly Controller build ( ) { if ( m View Factory == null && ( m Workspace Fragment != null || m Trash Fragment != null || m Toolbox Fragment != null || m Toolbox Drawer != null ) ) { throw new Illegal State Exception ( STRING ) ; } if ( m Workspace Helper == null ) { m Workspace Helper = new Workspace Helper ( m Context ) ; } Block Factory factory = new Block Factory ( m Context , null ) ; for ( int i = NUM ; i < m Block Def Resources . size ( ) ; i ++ ) { try { factory . add Blocks ( m Block Def Resources . get ( i ) ) ; } catch ( Throwable e ) { factory . clear ( ) ; throw e ; } } for ( int i = NUM ; i < m Block Def Assets . size ( ) ; i ++ ) { String asset Path = m Block Def Assets . get ( i ) ; try { factory . add Blocks ( m Asset Manager . open ( asset Path ) ) ; } catch ( IO Exception e ) { factory . clear ( ) ; throw new Illegal State Exception ( STRING + asset Path , e ) ; } } for ( int i = NUM ; i < m Block Defs . size ( ) ; i ++ ) { factory . add Block Template ( m Block Defs . get ( i ) ) ; } Blockly Controller controller = new Blockly Controller ( m Context , factory , m Workspace Helper , m View Factory ) ; if ( m Toolbox Res Id != NUM ) { controller . load Toolbox Contents ( m Toolbox Res Id ) ; } else if ( m Toolbox Xml != null ) { controller . load Toolbox Contents ( m Toolbox Xml ) ; } else if ( m Toolbox Asset Id != null && m Asset Manager != null ) { try { controller . load Toolbox Contents ( m Asset Manager . open ( m Toolbox Asset Id ) ) ; } catch ( IO Exception e ) { throw new Illegal Argument Exception ( STRING + m Toolbox Asset Id , e ) ; } } controller . set Workspace Fragment ( m Workspace Fragment ) ; controller . set Trash Fragment ( m Trash Fragment ) ; controller . set Toolbox Fragment ( m Toolbox Fragment ) ; controller . set Trash Icon ( m Trash Icon ) ; controller . set Variable Callback ( m Variable Callback ) ; return controller ; }
@ Override public void run ( ) { while ( ! is Interrupted ( ) ) { try { Key Holder < K > ref = ( Key Holder < K > ) queue . remove ( ) ; V removed = table . remove ( ref ) ; if ( listener != null && removed != null ) listener . weak Entry Removed ( removed ) ; } catch ( Interrupted Exception e ) { interrupt ( ) ; break ; } } }
public Job Definition Create Request create Job Definition Create Request ( String namespace Cd , String job Name , String job Description , String activiti Xml , List < Parameter > parameters ) { Job Definition Create Request request = new Job Definition Create Request ( ) ; request . set Namespace ( namespace Cd ) ; request . set Job Name ( job Name ) ; request . set Description ( job Description ) ; request . set Activiti Job Xml ( activiti Xml ) ; request . set Parameters ( parameters ) ; return request ; }
public Tab State restore Tab State ( int tab Id , boolean encrypted ) { return Tab State . restore Tab State ( get Tab State File ( tab Id , encrypted ) , encrypted ) ; }
public FTP Client ( ) { add List Parser ( new Unix List Parser ( ) ) ; add List Parser ( new DOS List Parser ( ) ) ; add List Parser ( new EPLF List Parser ( ) ) ; add List Parser ( new Net Ware List Parser ( ) ) ; add List Parser ( new MLSD List Parser ( ) ) ; }
public String add Extension ( String test File Name ) { return test File Name + STRING ; }
public < T > String make String Value SQ ( T value ) { return value . to String ( ) ; }
private Level description To Log Level ( String description ) { Level result = Level . OFF ; if ( description . equals ( s logger . localize Message ( STRING ) ) ) { result = Level . OFF ; } else if ( description . equals ( s logger . localize Message ( STRING ) ) ) { result = Level . SEVERE ; } else if ( description . equals ( s logger . localize Message ( STRING ) ) ) { result = Level . WARNING ; } else if ( description . equals ( s logger . localize Message ( STRING ) ) ) { result = Level . INFO ; } else if ( description . equals ( s logger . localize Message ( STRING ) ) ) { result = Level . CONFIG ; } else if ( description . equals ( s logger . localize Message ( STRING ) ) ) { result = Level . FINE ; } else if ( description . equals ( s logger . localize Message ( STRING ) ) ) { result = Level . FINER ; } else if ( description . equals ( s logger . localize Message ( STRING ) ) ) { result = Level . FINEST ; } else if ( description . equals ( s logger . localize Message ( STRING ) ) ) { result = Level . ALL ; } return result ; }
default boolean is Immutable ( ) { return BOOL ; }
public long renew ( String entry Uid , String class Name , int object Type , long duration , boolean from Replication , boolean origin , boolean is From Gateway ) throws Unknown Lease Exception , Internal Space Exception { try { extend Lease Period ( entry Uid , class Name , object Type , duration , from Replication , origin , BOOL , null , is From Gateway ) ; } catch ( Unknown Lease Exception unknown Lease Exception ) { if ( cache Manager . is Cache External DB ( ) && object Type != Object Types . NOTIFY NULL TEMPLATE && object Type != Object Types . NOTIFY TEMPLATE ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING , unknown Lease Exception ) ; } } else throw unknown Lease Exception ; } return duration ; }
public JK Tag Mapping ( ) { }
public static void in Range ( final long value , final String name , final long min Inclusive , final long max Inclusive ) { if ( value < min Inclusive || value > max Inclusive ) { final String message = String . format ( STRING , name , min Inclusive , max Inclusive ) ; throw new Illegal Argument Exception ( message ) ; } }
public Criteria or ( ) { Criteria criteria = create Criteria Internal ( ) ; ored Criteria . add ( criteria ) ; return criteria ; }
public static File unzip To Temp Folder ( File zip File ) { String zip Filename = zip File . get Name ( ) ; String temp Folder Prefix = zip Filename . substring ( NUM , zip Filename . last Index Of ( STRING ) ) ; File temp Folder = create Temp Folder ( temp Folder Prefix ) ; try { PU Zip Utils . unzip ( zip File , temp Folder ) ; return temp Folder ; } catch ( Exception e ) { try { File Utils . delete File Or Directory ( temp Folder ) ; } catch ( Runtime Exception ex ) { logger . debug ( STRING + temp Folder , ex ) ; } throw new Runtime Exception ( STRING + zip File + STRING + temp Folder , e ) ; } }
public void test Ascii ( ) throws Exception { String str = STRING ; Byte Array Input Stream aa = new Byte Array Input Stream ( str . get Bytes ( STRING ) ) ; Input Stream Reader a = new Input Stream Reader ( aa , STRING ) ; try { int x = a . read ( ) ; assert Equals ( STRING , x ) ; char [ ] c = new char [ NUM ] ; x = a . read ( c , NUM , NUM ) ; assert Equals ( STRING , a . get Encoding ( ) ) ; assert Equals ( NUM , x ) ; assert Equals ( STRING , String . value Of ( c ) ) ; } finally { a . close ( ) ; } }
public void clear ( ) { m reduced Results . clear ( ) ; m current Search Index = NUM ; }
public static void create Accessor Method ( Soot Method container , Stmt stmt ) { Body container Body = container . get Active Body ( ) ; soot . util . Chain container Stmts = container Body . get Units ( ) ; if ( ! container Stmts . contains ( stmt ) ) throw new Runtime Exception ( ) ; if ( stmt . contains Invoke Expr ( ) ) { create Invoke Accessor ( container , stmt ) ; } else if ( stmt instanceof Assign Stmt ) { Assign Stmt as = ( Assign Stmt ) stmt ; Field Ref ref ; if ( as . get Left Op ( ) instanceof Field Ref ) { ref = ( Field Ref ) as . get Left Op ( ) ; create Set Accessor ( container , as , ref ) ; } else if ( as . get Right Op ( ) instanceof Field Ref ) { ref = ( Field Ref ) as . get Right Op ( ) ; create Get Accessor ( container , as , ref ) ; } else { throw new Runtime Exception ( STRING ) ; } } else throw new Runtime Exception ( STRING ) ; }
@ Override public void display Changed ( ) { update GC ( ) ; }
public final void push Pair ( Node v1 , Node v2 ) { if ( null == m map ) { m map = new Node [ m blocksize ] ; m map Size = m blocksize ; } else { if ( ( m first Free + NUM ) >= m map Size ) { m map Size += m blocksize ; Node new Map [ ] = new Node [ m map Size ] ; System . arraycopy ( m map , NUM , new Map , NUM , m first Free ) ; m map = new Map ; } } m map [ m first Free ] = v1 ; m map [ m first Free + NUM ] = v2 ; m first Free += NUM ; }
private static String escape JSON ( String text ) { String Builder builder = new String Builder ( ) ; builder . append ( STRING ) ; for ( int index = NUM ; index < text . length ( ) ; index ++ ) { char chr = text . char At ( index ) ; switch ( chr ) { case STRING : case STRING : builder . append ( STRING ) ; builder . append ( chr ) ; break ; case STRING : builder . append ( STRING ) ; break ; case STRING : builder . append ( STRING ) ; break ; case STRING : builder . append ( STRING ) ; break ; case STRING : builder . append ( STRING ) ; break ; default : if ( chr < STRING ) { String t = STRING + Integer . to Hex String ( chr ) ; builder . append ( STRING + t . substring ( t . length ( ) - NUM ) ) ; } else { builder . append ( chr ) ; } break ; } } builder . append ( STRING ) ; return builder . to String ( ) ; }
final Segment < K , V > segment For ( int hash ) { return segments [ ( hash > > > segment Shift ) & segment Mask ] ; }
@ Suppress Warnings ( STRING ) private void start Set Time Changed ( ) { int hours = NUM ; int minutes = NUM ; try { hours = Integer . parse Int ( start Hours Field . get Text ( ) ) ; } catch ( Exception e ) { J Option Pane . show Message Dialog ( this , ( Bundle . get Message ( STRING ) + STRING + e ) , Bundle . get Message ( STRING ) , J Option Pane . ERROR MESSAGE ) ; log . error ( STRING + e ) ; return ; } if ( ( hours < NUM ) || ( hours > NUM ) ) { J Option Pane . show Message Dialog ( this , ( Bundle . get Message ( STRING ) ) , Bundle . get Message ( STRING ) , J Option Pane . ERROR MESSAGE ) ; return ; } try { minutes = Integer . parse Int ( start Minutes Field . get Text ( ) ) ; } catch ( Exception e ) { J Option Pane . show Message Dialog ( this , ( Bundle . get Message ( STRING ) + STRING + e ) , Bundle . get Message ( STRING ) , J Option Pane . ERROR MESSAGE ) ; log . error ( STRING + e ) ; return ; } if ( ( minutes < NUM ) || ( minutes > NUM ) ) { J Option Pane . show Message Dialog ( this , ( Bundle . get Message ( STRING ) ) , Bundle . get Message ( STRING ) , J Option Pane . ERROR MESSAGE ) ; return ; } long m Sec Per Hour = NUM ; long m Sec Per Minute = NUM ; Date tem = clock . get Time ( ) ; int c Hours = tem . get Hours ( ) ; long c Num M Sec = tem . get Time ( ) ; long n Num M Sec = ( ( c Num M Sec / m Sec Per Hour ) * m Sec Per Hour ) - ( c Hours * m Sec Per Hour ) + ( hours * m Sec Per Hour ) + ( minutes * m Sec Per Minute ) ; clock . set Start Set Time ( start Set Time Check Box . is Selected ( ) , new Date ( n Num M Sec ) ) ; changed = BOOL ; }
public static String serialize ( Object to Serialize ) throws Exception { Class < ? > xstream Class ; java . lang . reflect . Constructor < ? > constructor ; Object xstream ; Class < ? > [ ] serialize Args Classes = new Class [ NUM ] ; Object [ ] serialize Args = new Object [ NUM ] ; java . lang . reflect . Method method Serialize ; String result ; xstream Class = Class . for Name ( STRING ) ; constructor = xstream Class . get Constructor ( ) ; xstream = constructor . new Instance ( ) ; serialize Args Classes [ NUM ] = Object . class ; serialize Args [ NUM ] = to Serialize ; method Serialize = xstream Class . get Method ( STRING , serialize Args Classes ) ; try { result = ( String ) method Serialize . invoke ( xstream , serialize Args ) ; } catch ( Exception ex ) { result = null ; } return result ; }
@ Override public void release ( ) { super . release ( ) ; }
public void update And Test Counter ( OF Message ofm , String type ) { validate Counter ( type , NUM ) ; counters . update Write Stats ( ofm ) ; counters . update Write Stats ( ofm ) ; counters . update Read Stats ( ofm ) ; counters . update Read Stats ( ofm ) ; validate Counter ( type , NUM ) ; }
public static < E > List < E > of ( ) { return Collections . empty List ( ) ; }
protected void draw Domain Crosshair ( Graphics 2 D g2 , Rectangle 2 D data Area , Plot Orientation orientation , int dataset Index , Comparable row Key , Comparable column Key , Stroke stroke , Paint paint ) { Category Dataset dataset = get Dataset ( dataset Index ) ; Category Axis axis = get Domain Axis For Dataset ( dataset Index ) ; Category Item Renderer renderer = get Renderer ( dataset Index ) ; Line 2 D line ; if ( orientation == Plot Orientation . VERTICAL ) { double xx = renderer . get Item Middle ( row Key , column Key , dataset , axis , data Area , Rectangle Edge . BOTTOM ) ; line = new Line 2 D . Double ( xx , data Area . get Min Y ( ) , xx , data Area . get Max Y ( ) ) ; } else { double yy = renderer . get Item Middle ( row Key , column Key , dataset , axis , data Area , Rectangle Edge . LEFT ) ; line = new Line 2 D . Double ( data Area . get Min X ( ) , yy , data Area . get Max X ( ) , yy ) ; } g2 . set Stroke ( stroke ) ; g2 . set Paint ( paint ) ; g2 . draw ( line ) ; }
@ Override public Table summary ( ) { Table table = Table . create ( STRING + name ( ) ) ; Category Column measure = Category Column . create ( STRING ) ; Category Column value = Category Column . create ( STRING ) ; table . add Column ( measure ) ; table . add Column ( value ) ; measure . add ( STRING ) ; value . add ( String . value Of ( size ( ) ) ) ; measure . add ( STRING ) ; value . add ( String . value Of ( count Missing ( ) ) ) ; measure . add ( STRING ) ; value . add ( String . value Of ( min ( ) ) ) ; measure . add ( STRING ) ; value . add ( String . value Of ( max ( ) ) ) ; return table ; }
private Object js parse Float ( Object [ ] args ) { if ( args . length < NUM ) return Script Runtime . Na Nobj ; String s = Script Runtime . to String ( args [ NUM ] ) ; int len = s . length ( ) ; int start = NUM ; char c ; for ( ; ; ) { if ( start == len ) { return Script Runtime . Na Nobj ; } c = s . char At ( start ) ; if ( ! Script Runtime . is Str White Space Char ( c ) ) { break ; } ++ start ; } int i = start ; if ( c == STRING || c == STRING ) { ++ i ; if ( i == len ) { return Script Runtime . Na Nobj ; } c = s . char At ( i ) ; } if ( c == STRING ) { if ( i + NUM <= len && s . region Matches ( i , STRING , NUM , NUM ) ) { double d ; if ( s . char At ( start ) == STRING ) { d = Double . NEGATIVE INFINITY ; } else { d = Double . POSITIVE INFINITY ; } return Script Runtime . wrap Number ( d ) ; } return Script Runtime . Na Nobj ; } int decimal = - NUM ; int exponent = - NUM ; boolean exponent Valid = BOOL ; for ( ; i < len ; i ++ ) { switch ( s . char At ( i ) ) { case STRING : if ( decimal != - NUM ) break ; decimal = i ; continue ; case STRING : case STRING : if ( exponent != - NUM ) { break ; } else if ( i == len - NUM ) { break ; } exponent = i ; continue ; case STRING : case STRING : if ( exponent != i - NUM ) { break ; } else if ( i == len - NUM ) { -- i ; break ; } continue ; case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : if ( exponent != - NUM ) { exponent Valid = BOOL ; } continue ; default : break ; } break ; } if ( exponent != - NUM && ! exponent Valid ) { i = exponent ; } s = s . substring ( start , i ) ; try { return Double . value Of ( s ) ; } catch ( Number Format Exception ex ) { return Script Runtime . Na Nobj ; } }
public C Visibility Criterium Panel ( final C Visibility Criterium criterium ) { super ( new Border Layout ( ) ) ; visibility Criterium = criterium ; visibility State Box . add Action Listener ( visibility State Box Listener ) ; init Panel ( ) ; }
public boolean is Alter Add ( ) { return columns To Add . size ( ) > NUM ; }
private boolean process Removed Node ( final I Navi View Node node ) { if ( node instanceof I Navi Code Node ) { final I Navi Code Node cnode = ( I Navi Code Node ) node ; try { final I Navi Function target Function = cnode . get Parent Function ( ) ; if ( m node Counter . contains Key ( target Function ) ) { final int new Counter = m node Counter . get ( target Function ) - NUM ; if ( new Counter == NUM ) { m node Counter . remove ( target Function ) ; final Set < C Cross Reference > to Delete = new Hash Set < C Cross Reference > ( ) ; for ( final C Cross Reference reference : m cross References ) { if ( reference . get Called Function ( ) == target Function ) { to Delete . add ( reference ) ; } } m cross References . remove All ( to Delete ) ; return BOOL ; } else { m node Counter . put ( target Function , new Counter ) ; } } } catch ( final Maybe Null Exception exception ) { } } return BOOL ; }
public long transfer To ( long position , long count , Output Stream dst ) throws IO Exception { return transfer To ( position , count , Channels . new Channel ( dst ) ) ; }
public void test is Lenient ( ) { Date Format df = Date Format . get Instance ( ) ; Calendar c = df . get Calendar ( ) ; if ( df . is Lenient ( ) ) { try { c . set ( Calendar . DAY OF MONTH , NUM ) ; c . get ( Calendar . DAY OF MONTH ) ; } catch ( Exception e ) { fail ( STRING + e . to String ( ) ) ; } c . set Lenient ( BOOL ) ; try { c . set ( Calendar . DAY OF MONTH , NUM ) ; c . get ( Calendar . DAY OF MONTH ) ; fail ( STRING ) ; } catch ( Illegal Argument Exception e ) { } catch ( Exception e ) { fail ( STRING + e . to String ( ) ) ; } } else { try { c . set ( Calendar . DAY OF MONTH , NUM ) ; c . get ( Calendar . DAY OF MONTH ) ; fail ( STRING ) ; } catch ( Illegal Argument Exception e ) { } catch ( Exception e ) { fail ( STRING + e . to String ( ) ) ; } c . set Lenient ( BOOL ) ; try { c . set ( Calendar . DAY OF MONTH , NUM ) ; c . get ( Calendar . DAY OF MONTH ) ; } catch ( Exception e ) { fail ( STRING + e . to String ( ) ) ; } } }
private void write Index File ( ) throws IO Exception , Carbon Data Writer Exception { Index Header index Header = Carbon Metadata Util . get Index Header ( local Cardinality , thrift Column Schema List ) ; List < Block Index > block Index Thrift = Carbon Metadata Util . get Block Index Info ( block Index Info List ) ; String file Name = store Location + File . separator + carbon Table Path . get Carbon Index File Name ( carbon Data File Attributes . get Task Id ( ) , carbon Data File Attributes . get Fact Time Stamp ( ) ) ; Carbon Index File Writer writer = new Carbon Index File Writer ( ) ; writer . open Thrift Writer ( file Name ) ; writer . write Thrift ( index Header ) ; for ( Block Index block Index : block Index Thrift ) { writer . write Thrift ( block Index ) ; } writer . close ( ) ; copy Carbon Data File To Carbon Store Path ( file Name ) ; }
public void nack All ( Pubsub Reader < T > reader ) throws IO Exception { check State ( this . reader == null , STRING ) ; List < String > batch Yet To Ack Ids = new Array List < > ( Math . min ( not Yet Read Ids . size ( ) , ACK BATCH SIZE ) ) ; for ( String ack Id : not Yet Read Ids ) { batch Yet To Ack Ids . add ( ack Id ) ; if ( batch Yet To Ack Ids . size ( ) >= ACK BATCH SIZE ) { long now Ms Since Epoch = now ( reader ) ; reader . nack Batch ( now Ms Since Epoch , batch Yet To Ack Ids ) ; batch Yet To Ack Ids . clear ( ) ; } } if ( ! batch Yet To Ack Ids . is Empty ( ) ) { long now Ms Since Epoch = now ( reader ) ; reader . nack Batch ( now Ms Since Epoch , batch Yet To Ack Ids ) ; } }
static public void assert Equals ( String message , Object expected , Object actual ) { if ( expected == null && actual == null ) return ; if ( expected != null && expected . equals ( actual ) ) return ; fail Not Equals ( message , expected , actual ) ; }
public static Naming Exception map Error Code ( int error Code , String error Message ) { if ( error Code == Ldap Client . LDAP SUCCESS ) return null ; Naming Exception e = null ; String message = Ldap Client . get Error Message ( error Code , error Message ) ; switch ( error Code ) { case Ldap Client . LDAP ALIAS DEREFERENCING PROBLEM : e = new Naming Exception ( message ) ; break ; case Ldap Client . LDAP ALIAS PROBLEM : e = new Naming Exception ( message ) ; break ; case Ldap Client . LDAP ATTRIBUTE OR VALUE EXISTS : e = new Attribute In Use Exception ( message ) ; break ; case Ldap Client . LDAP AUTH METHOD NOT SUPPORTED : case Ldap Client . LDAP CONFIDENTIALITY REQUIRED : case Ldap Client . LDAP STRONG AUTH REQUIRED : case Ldap Client . LDAP INAPPROPRIATE AUTHENTICATION : e = new Authentication Not Supported Exception ( message ) ; break ; case Ldap Client . LDAP ENTRY ALREADY EXISTS : e = new Name Already Bound Exception ( message ) ; break ; case Ldap Client . LDAP INVALID CREDENTIALS : case Ldap Client . LDAP SASL BIND IN PROGRESS : e = new Authentication Exception ( message ) ; break ; case Ldap Client . LDAP INAPPROPRIATE MATCHING : e = new Invalid Search Filter Exception ( message ) ; break ; case Ldap Client . LDAP INSUFFICIENT ACCESS RIGHTS : e = new No Permission Exception ( message ) ; break ; case Ldap Client . LDAP INVALID ATTRIBUTE SYNTAX : case Ldap Client . LDAP CONSTRAINT VIOLATION : e = new Invalid Attribute Value Exception ( message ) ; break ; case Ldap Client . LDAP LOOP DETECT : e = new Naming Exception ( message ) ; break ; case Ldap Client . LDAP NO SUCH ATTRIBUTE : e = new No Such Attribute Exception ( message ) ; break ; case Ldap Client . LDAP NO SUCH OBJECT : e = new Name Not Found Exception ( message ) ; break ; case Ldap Client . LDAP OBJECT CLASS MODS PROHIBITED : case Ldap Client . LDAP OBJECT CLASS VIOLATION : case Ldap Client . LDAP NOT ALLOWED ON RDN : e = new Schema Violation Exception ( message ) ; break ; case Ldap Client . LDAP NOT ALLOWED ON NON LEAF : e = new Context Not Empty Exception ( message ) ; break ; case Ldap Client . LDAP OPERATIONS ERROR : e = new Naming Exception ( message ) ; break ; case Ldap Client . LDAP OTHER : e = new Naming Exception ( message ) ; break ; case Ldap Client . LDAP PROTOCOL ERROR : e = new Communication Exception ( message ) ; break ; case Ldap Client . LDAP SIZE LIMIT EXCEEDED : e = new Size Limit Exceeded Exception ( message ) ; break ; case Ldap Client . LDAP TIME LIMIT EXCEEDED : e = new Time Limit Exceeded Exception ( message ) ; break ; case Ldap Client . LDAP UNAVAILABLE CRITICAL EXTENSION : e = new Operation Not Supported Exception ( message ) ; break ; case Ldap Client . LDAP UNAVAILABLE : case Ldap Client . LDAP BUSY : e = new Service Unavailable Exception ( message ) ; break ; case Ldap Client . LDAP UNDEFINED ATTRIBUTE TYPE : e = new Invalid Attribute Identifier Exception ( message ) ; break ; case Ldap Client . LDAP UNWILLING TO PERFORM : e = new Operation Not Supported Exception ( message ) ; break ; case Ldap Client . LDAP COMPARE FALSE : case Ldap Client . LDAP COMPARE TRUE : case Ldap Client . LDAP IS LEAF : e = new Naming Exception ( message ) ; break ; case Ldap Client . LDAP ADMIN LIMIT EXCEEDED : e = new Limit Exceeded Exception ( message ) ; break ; case Ldap Client . LDAP REFERRAL : e = new Naming Exception ( message ) ; break ; case Ldap Client . LDAP PARTIAL RESULTS : e = new Naming Exception ( message ) ; break ; case Ldap Client . LDAP INVALID DN SYNTAX : case Ldap Client . LDAP NAMING VIOLATION : e = new Invalid Name Exception ( message ) ; break ; default : e = new Naming Exception ( message ) ; break ; } return e ; }
public final void compute Index ( ) { if ( index Computed ) { return ; } List < Long > cell List = new Array List ( ) ; List < Integer > edge List = new Array List ( ) ; for ( int i = NUM ; i < get Num Edges ( ) ; ++ i ) { S2 Point from = edge From ( i ) ; S2 Point to = edge To ( i ) ; Array List < S2 Cell Id > cover = new Array List ( ) ; int level = get Covering ( from , to , BOOL , cover ) ; minimum S 2 Level Used = Math . min ( minimum S 2 Level Used , level ) ; for ( S2 Cell Id cell Id : cover ) { cell List . add ( cell Id . id ( ) ) ; edge List . add ( i ) ; } } cells = new long [ cell List . size ( ) ] ; edges = new int [ edge List . size ( ) ] ; for ( int i = NUM ; i < cells . length ; i ++ ) { cells [ i ] = cell List . get ( i ) ; edges [ i ] = edge List . get ( i ) ; } sort Index ( ) ; index Computed = BOOL ; }
public Wait For Any Listener ( int number Of Results ) { this ( number Of Results , null ) ; }
public static Object string To Value ( String string ) { Double d ; if ( string . equals ( STRING ) ) { return string ; } if ( string . equals Ignore Case ( STRING ) ) { return Boolean . TRUE ; } if ( string . equals Ignore Case ( STRING ) ) { return Boolean . FALSE ; } if ( string . equals Ignore Case ( STRING ) ) { return JSON Object . NULL ; } char b = string . char At ( NUM ) ; if ( ( b >= STRING && b <= STRING ) || b == STRING || b == STRING || b == STRING ) { try { if ( string . index Of ( STRING ) > - NUM || string . index Of ( STRING ) > - NUM || string . index Of ( STRING ) > - NUM ) { d = Double . value Of ( string ) ; if ( ! d . is Infinite ( ) && ! d . is Na N ( ) ) { return d ; } } else { Long my Long = new Long ( string ) ; if ( my Long . long Value ( ) == my Long . int Value ( ) ) { return new Integer ( my Long . int Value ( ) ) ; } else { return my Long ; } } } catch ( Exception ignore ) { } } return string ; }
public abstract void on Pin Set ( String pin ) ;
public void test Case 9 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
public Entity Query order By ( String ... fields ) { this . order By = Arrays . as List ( fields ) ; return this ; }
public void remove Nodes From Partition ( List < I Group Member Node > nodes To Remove ) { for ( final I Group Member Node node To Remove : nodes To Remove ) { if ( node To Remove != null ) { if ( ! non Optional Non Minus Nodes . remove ( node To Remove ) ) { if ( node To Remove . equals ( optional Or Minus ) ) { optional Or Minus = null ; } } } } recompute Definitely Produced ( ) ; }
public static void banner ( Logger logger , Class < ? > clazz , String method Name , String text ) { String string = clazz . get Simple Name ( ) + STRING + method Name ; if ( text != null ) { string += STRING + text ; } logger . info ( STRING ) ; logger . info ( STRING ) ; logger . info ( STRING + string ) ; logger . info ( STRING ) ; }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; if ( resource Bundle Name != null ) { try { rb = Resource Bundle . get Bundle ( resource Bundle Name ) ; } catch ( Missing Resource Exception e ) { rb = null ; } } }
private static void exit ( @ Nullable String err Msg , @ Nullable Options options , int exit Code ) { if ( err Msg != null ) echo ( STRING + err Msg ) ; String runner = System . get Property ( IGNITE PROG NAME , STRING ) ; int space = runner . index Of ( STRING ) ; runner = runner . substring ( NUM , space == - NUM ? runner . length ( ) : space ) ; if ( options != null ) { Help Formatter formatter = new Help Formatter ( ) ; formatter . print Help ( runner , options ) ; } System . exit ( exit Code ) ; }
private static void replace Alt Special Instructions ( ) { fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , andccr U 8 Simulation Code ) ) ; fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , stilm U 8 Simulation Code ) ) ; fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , orccr U 8 Simulation Code ) ) ; fill Instruction Map ( NUM , NUM , new Fr Instruction ( Instruction Format . D , NUM , NUM , STRING , STRING , STRING , Instruction . Flow Type . NONE , BOOL , BOOL , addsp S 10 Simulation Code ) ) ; }
@ Override public boolean add Sensor To Route ( String sensor Name , int mode ) { if ( control Sensor List . size ( ) >= MAX CONTROL SENSORS ) { log . warn ( STRING , get System Name ( ) ) ; } Control Sensor sensor = new Control Sensor ( sensor Name ) ; log . debug ( STRING , get System Name ( ) , sensor Name ) ; if ( ! sensor . set State ( mode ) ) { return BOOL ; } if ( is Control Sensor Included ( sensor ) ) { log . debug ( STRING , sensor Name , get System Name ( ) ) ; } else { control Sensor List . add ( sensor ) ; } return BOOL ; }
private void eliminate Backfill States ( int base State ) { if ( states To Backfill . contains ( new Integer ( base State ) ) ) { states To Backfill . remove Element ( new Integer ( base State ) ) ; short [ ] state = temp State Table . element At ( base State ) ; for ( int i = NUM ; i < num Categories ; i ++ ) { if ( state [ i ] != NUM ) { eliminate Backfill States ( state [ i ] ) ; } } } }
static boolean separate Convex Polygons ( float [ ] verts 1 , float [ ] verts 2 , Vector 2 separation ) { final int length 1 = verts 1 . length ; final int length 2 = verts 2 . length ; for ( int i = NUM ; i < length 1 ; i += NUM ) { final int j = ( i + NUM ) % length 1 ; float proj X = verts 1 [ j + NUM ] - verts 1 [ i + NUM ] ; float proj Y = verts 1 [ i ] - verts 1 [ j ] ; final float length = ( float ) Math . sqrt ( proj X * proj X + proj Y * proj Y ) ; proj X /= length ; proj Y /= length ; float min 1 = Float . POSITIVE INFINITY , max 1 = Float . NEGATIVE INFINITY ; for ( int k = NUM ; k < length 1 ; k += NUM ) { final float dot = proj X * verts 1 [ k ] + proj Y * verts 1 [ k + NUM ] ; if ( dot < min 1 ) min 1 = dot ; if ( dot > max 1 ) max 1 = dot ; } float min 2 = Float . POSITIVE INFINITY , max 2 = Float . NEGATIVE INFINITY ; for ( int k = NUM ; k < length 2 ; k += NUM ) { final float dot = proj X * verts 2 [ k ] + proj Y * verts 2 [ k + NUM ] ; if ( dot < min 2 ) min 2 = dot ; if ( dot > max 2 ) max 2 = dot ; } if ( ( max 1 < min 2 ) || ( max 2 < min 1 ) ) { if ( null != separation ) separation . set ( proj Y , - proj X ) ; return BOOL ; } } return BOOL ; }
public String payment Term ( Properties ctx , int Window No , Grid Tab m Tab , Grid Field m Field , Object value ) { Integer C Payment Term ID = ( Integer ) value ; int C Invoice ID = Env . get Context As Int ( ctx , Window No , STRING ) ; if ( C Payment Term ID == null || C Payment Term ID . int Value ( ) == NUM || C Invoice ID == NUM ) return STRING ; M Payment Term pt = new M Payment Term ( ctx , C Payment Term ID . int Value ( ) , null ) ; if ( pt . get ID ( ) == NUM ) return STRING ; boolean valid = pt . apply ( C Invoice ID ) ; m Tab . set Value ( STRING , valid ? STRING : STRING ) ; return STRING ; }
static void check Type Ref And Path ( int type Ref , Type Path type Path ) { int mask = NUM ; switch ( type Ref > > > NUM ) { case Type Reference . CLASS TYPE PARAMETER : case Type Reference . METHOD TYPE PARAMETER : case Type Reference . METHOD FORMAL PARAMETER : mask = NUM ; break ; case Type Reference . FIELD : case Type Reference . METHOD RETURN : case Type Reference . METHOD RECEIVER : case Type Reference . LOCAL VARIABLE : case Type Reference . RESOURCE VARIABLE : case Type Reference . INSTANCEOF : case Type Reference . NEW : case Type Reference . CONSTRUCTOR REFERENCE : case Type Reference . METHOD REFERENCE : mask = NUM ; break ; case Type Reference . CLASS EXTENDS : case Type Reference . CLASS TYPE PARAMETER BOUND : case Type Reference . METHOD TYPE PARAMETER BOUND : case Type Reference . THROWS : case Type Reference . EXCEPTION PARAMETER : mask = NUM ; break ; case Type Reference . CAST : case Type Reference . CONSTRUCTOR INVOCATION TYPE ARGUMENT : case Type Reference . METHOD INVOCATION TYPE ARGUMENT : case Type Reference . CONSTRUCTOR REFERENCE TYPE ARGUMENT : case Type Reference . METHOD REFERENCE TYPE ARGUMENT : mask = NUM ; break ; default : throw new Illegal Argument Exception ( STRING + Integer . to Hex String ( type Ref > > > NUM ) ) ; } if ( ( type Ref & ~ mask ) != NUM ) { throw new Illegal Argument Exception ( STRING + Integer . to Hex String ( type Ref ) ) ; } if ( type Path != null ) { for ( int i = NUM ; i < type Path . get Length ( ) ; ++ i ) { int step = type Path . get Step ( i ) ; if ( step != Type Path . ARRAY ELEMENT && step != Type Path . INNER TYPE && step != Type Path . TYPE ARGUMENT && step != Type Path . WILDCARD BOUND ) { throw new Illegal Argument Exception ( STRING + i + STRING + type Path ) ; } if ( step != Type Path . TYPE ARGUMENT && type Path . get Step Argument ( i ) != NUM ) { throw new Illegal Argument Exception ( STRING + i + STRING + type Path ) ; } } } }
public static void transform Criteria ( Properties form Properties , Input Stream xsl Is , Result result ) throws SAX Exception , IO Exception , Parser Configuration Exception , Transformer Exception { dbf . set Namespace Aware ( BOOL ) ; Document Builder builder = dbf . new Document Builder ( ) ; org . w3 c . dom . Document xsl Doc = builder . parse ( xsl Is ) ; DOM Source ds = new DOM Source ( xsl Doc ) ; Transformer transformer = null ; synchronized ( t Factory ) { transformer = t Factory . new Transformer ( ds ) ; } transform Criteria ( form Properties , transformer , result ) ; }
public static List < byte [ ] > split And Pad ( byte [ ] byte Array , int blocksize ) { List < byte [ ] > blocks = new Array List < byte [ ] > ( ) ; int num Blocks = ( int ) Math . ceil ( byte Array . length / ( double ) blocksize ) ; for ( int i = NUM ; i < num Blocks ; i ++ ) { byte [ ] block = new byte [ blocksize ] ; Arrays . fill ( block , ( byte ) NUM ) ; if ( i + NUM == num Blocks ) { int remaining Bytes = byte Array . length - ( i * blocksize ) ; System . arraycopy ( byte Array , i * blocksize , block , NUM , remaining Bytes ) ; } else { System . arraycopy ( byte Array , i * blocksize , block , NUM , blocksize ) ; } blocks . add ( block ) ; } return blocks ; }
public void put ( E item ) throws Interrupted Exception { if ( ! done . get ( ) ) { queue . put ( item ) ; } }
protected void notify Complete ( ) { final String method Name = STRING ; log . fine ( CLASS NAME , method Name , STRING , new Object [ ] { get Key ( ) , this . response , this . exception } ) ; synchronized ( response Lock ) { if ( exception == null && pending Complete ) { completed = BOOL ; pending Complete = BOOL ; } else { pending Complete = BOOL ; } response Lock . notify All ( ) ; } synchronized ( sent Lock ) { sent = BOOL ; sent Lock . notify All ( ) ; } }
private Node < K , V > [ ] init Table ( ) { Node < K , V > [ ] tab ; int sc ; while ( ( tab = table ) == null || tab . length == NUM ) { if ( ( sc = size Ctl ) < NUM ) { Thread . yield ( ) ; } else if ( U . compare And Swap Int ( this , SIZECTL , sc , - NUM ) ) { try { if ( ( tab = table ) == null || tab . length == NUM ) { int n = ( sc > NUM ) ? sc : DEFAULT CAPACITY ; @ Suppress Warnings ( STRING ) Node < K , V > [ ] nt = ( Node < K , V > [ ] ) new Node < ? , ? > [ n ] ; table = tab = nt ; sc = n - ( n > > > NUM ) ; } } finally { size Ctl = sc ; } break ; } } return tab ; }
public Buffered Image draw Bar Graph With Std Dev ( String graph Title , String x Label , String y Label , Hash Map < Comparable Label , Integer [ ] > bar Data Points , String [ ] bar Labels , Long std Dev High , Long std Dev Low , Long graph Max Value ) { Buffered Image bi = new Buffered Image ( this . WIDTH , this . HEIGHT , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D g2 d = bi . create Graphics ( ) ; Rendering Hints render Hints = new Rendering Hints ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; g2 d . set Rendering Hints ( render Hints ) ; draw Chart And Graph Rectangles ( g2 d ) ; draw Bar Legend ( g2 d , STRING , bar Labels , std Dev High , std Dev Low ) ; draw Title And Labels ( g2 d , graph Title , x Label , y Label ) ; Collection < Integer [ ] > value Collection = bar Data Points . values ( ) ; Set < Comparable Label > date Key Set = bar Data Points . key Set ( ) ; long max Value = NUM ; for ( Integer [ ] int Array : value Collection ) { for ( Integer int Value : int Array ) { if ( max Value < int Value ) { max Value = int Value ; } } } long y Max Mark = NUM ; int y Label X Offset = NUM ; y Max Mark = determine Y Max Mark ( max Value , std Dev High , graph Max Value ) ; draw Y Axis Divisions ( g2 d , y Max Mark , y Label X Offset ) ; Array List < Comparable Label > ordered Date Set = new Array List < Comparable Label > ( ) ; ordered Date Set . add All ( date Key Set ) ; Collections . sort ( ordered Date Set ) ; draw X Axis Divisions ( g2 d , ordered Date Set ) ; draw Bars On Graph ( g2 d , ordered Date Set , bar Data Points , y Max Mark ) ; if ( std Dev High != null ) { draw Std Dev Line ( g2 d , std Dev High , y Max Mark , this . std Dev High Color ) ; } if ( std Dev Low != null ) { draw Std Dev Line ( g2 d , std Dev Low , y Max Mark , this . std Dev Low Color ) ; } return bi ; }
public synchronized boolean load Public Key ( ) { if ( ! has ( STRING ) || ! has ( STRING ) ) return BOOL ; String encoded Key = get String ( STRING ) ; String algorithm = get String ( STRING ) ; Public Key pub = IO . decode Public Key ( encoded Key , algorithm ) ; if ( pub != null ) { public key = pub ; key algorithm = algorithm ; set Peer Hash ( ) ; return BOOL ; } return BOOL ; }
private String extract Project Name From Uri ( @ Not Null String uri ) { int index Finish Project Name = uri . last Index Of ( STRING ) ; int index Start Project Name = uri . last Index Of ( STRING ) != - NUM ? uri . last Index Of ( STRING ) + NUM : ( uri . last Index Of ( STRING ) + NUM ) ; if ( index Start Project Name != NUM && index Start Project Name < index Finish Project Name ) { return uri . substring ( index Start Project Name , index Finish Project Name ) ; } if ( index Start Project Name != NUM ) { return uri . substring ( index Start Project Name ) ; } return STRING ; }
private void load Text Data ( Data Input Stream dis ) throws IO Exception { for ( int f = NUM ; f < num Frames ; f ++ ) { times [ f ] = Float . parse Float ( General . read Word ( dis ) ) ; General . read Word ( dis ) ; for ( int c = NUM ; c < num Channels ; c ++ ) { frames [ f ] [ c ] = Float . parse Float ( General . read Word ( dis ) ) ; } } }
public void add Swipe Listener ( Swipe Listener listener ) { if ( m Listeners == null ) { m Listeners = new Array List < Swipe Listener > ( ) ; } m Listeners . add ( listener ) ; }
public static boolean is Gzip Content ( String content Encoding ) { return content Encoding != null && content Encoding . contains ( STRING ) ; }
public synchronized boolean check Size ( final int size Checked ) { if ( ! started ) { throw new Illegal State Exception ( STRING ) ; } if ( size Checked > buffer Size ) { throw new Illegal State Exception ( STRING + buffer Size + STRING ) ; } if ( buffer Limit == NUM || buffer . writer Index ( ) + size Checked > buffer Limit ) { flush ( ) ; delay Flush = BOOL ; final int remaining In File = buffer Observer . get Remaining Bytes ( ) ; if ( size Checked > remaining In File ) { return BOOL ; } else { buffer Limit = Math . min ( remaining In File , buffer Size ) ; return BOOL ; } } else { delay Flush = BOOL ; return BOOL ; } }
public void test Compare Less Scale 1 ( ) { String a = STRING ; int a Scale = NUM ; String b = STRING ; int b Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; int result = NUM ; assert Equals ( STRING , result , a Number . compare To ( b Number ) ) ; }
void reclaim Scrap Views ( List < View > views ) { if ( m View Type Count == NUM ) { views . add All ( m Current Scrap ) ; } else { final int view Type Count = m View Type Count ; final Array List < View > [ ] scrap Views = m Scrap Views ; for ( int i = NUM ; i < view Type Count ; ++ i ) { final Array List < View > scrap Pile = scrap Views [ i ] ; views . add All ( scrap Pile ) ; } } }
public void exit ( ) { exit Called = BOOL ; if ( thread Map != null ) { delete All Threads ( ) ; log . info ( STRING ) ; if ( Duration Statistics . collect Statistics ) { statistics . exit ( ) ; log . info ( String . format ( STRING , statistics . all Cycles , statistics . get Duration Millis ( ) / NUM ) ) ; Collections . sort ( statistics . threads ) ; for ( Statistics . Thread Statistics thread Statistics : statistics . threads ) { double percentage = NUM ; if ( statistics . all Cycles != NUM ) { percentage = ( thread Statistics . run Clocks / ( double ) statistics . all Cycles ) * NUM ; } log . info ( String . format ( STRING , thread Statistics . get Quoted Name ( ) , thread Statistics . run Clocks , percentage ) ) ; } } } }
private void format Node To ( Formatter f , int level , Radix Tree Node < T > node ) { for ( int i = NUM ; i < level ; i ++ ) { f . format ( STRING ) ; } f . format ( STRING ) ; for ( int i = NUM ; i < level ; i ++ ) { f . format ( STRING ) ; } if ( node . is Real ( ) == BOOL ) f . format ( STRING , node . get Key ( ) , node . get Value ( ) ) ; else f . format ( STRING , node . get Key ( ) ) ; for ( Radix Tree Node < T > child : node . get Childern ( ) ) { format Node To ( f , level + NUM , child ) ; } }
protected void start Download ( int blocks ) { if ( blocks > NUM ) log . info ( STRING + blocks + STRING + ( blocks > NUM ? STRING : STRING ) ) ; }
public void add ( int start , int end , int handler , int type ) { if ( start < end ) entries . add ( new Exception Table Entry ( start , end , handler , type ) ) ; }
private void free Kick ( Team offense ) { if ( game Time <= NUM ) return ; else { if ( game Time < NUM && ( ( game Poss && ( away Score - home Score ) <= NUM && ( away Score - home Score ) > NUM ) || ( ! game Poss && ( home Score - away Score ) <= NUM && ( home Score - away Score ) > NUM ) ) ) { if ( offense . get K ( NUM ) . rat Kick Fum * Math . random ( ) > NUM || Math . random ( ) < NUM ) { game Event Log += get Event Prefix ( ) + offense . abbr + STRING + offense . get K ( NUM ) . name + STRING + offense . abbr + STRING ; game Yard Line = NUM ; game Down = NUM ; game Yards Need = NUM ; } else { game Event Log += get Event Prefix ( ) + offense . abbr + STRING + offense . get K ( NUM ) . name + STRING ; game Poss = ! game Poss ; game Yard Line = NUM ; game Down = NUM ; game Yards Need = NUM ; } game Time -= NUM + NUM * Math . random ( ) ; } else { game Yard Line = ( int ) ( NUM - ( offense . get K ( NUM ) . rat Kick Pow + NUM - NUM * Math . random ( ) ) ) ; if ( game Yard Line <= NUM ) game Yard Line = NUM ; game Down = NUM ; game Yards Need = NUM ; game Poss = ! game Poss ; game Time -= NUM * Math . random ( ) ; } } }
private void process New Port ( long sw , short p ) { if ( is Link Discovery Suppressed ( sw , p ) ) { return ; } IOF Switch iof Switch = floodlight Provider . get Switch ( sw ) ; if ( iof Switch == null ) return ; if ( auto Port Fast Feature && iof Switch . is Fast Port ( p ) ) { return ; } Node Port Tuple npt = new Node Port Tuple ( sw , p ) ; discover ( sw , p ) ; if ( ! iof Switch . is Fast Port ( p ) ) { add To Quarantine Queue ( npt ) ; } else { add To Maintenance Queue ( npt ) ; } }
public static void put 3 Byte Int ( Byte Buffer buffer , int val ) { put 3 Byte Int ( buffer , val , buffer . order ( ) ) ; }
public static void assert No Exception ( Runnable expression , String error Message ) { if ( verbose ) { log ( STRING + expression + STRING + error Message + STRING ) ; } try { expression . run ( ) ; } catch ( Runtime Exception failure ) { Test Utils . fail ( error Message ) ; } }
@ Override public int index Of ( Object object ) { return index Of ( object , NUM ) ; }
protected Response Format Type generate Accept Format ( String format ) throws Bad Api Request Exception { try { return format == null ? Response Format Type . JSON : Response Format Type . value Of ( format . to Upper Case ( Locale . ENGLISH ) ) ; } catch ( Illegal Argument Exception e ) { LOG . error ( ACCEPT FORMAT INVALID . log Format ( format ) , e ) ; throw new Bad Api Request Exception ( ACCEPT FORMAT INVALID . format ( format ) ) ; } }
public Shared Object ( Map < String , Object > data , String name , String path , boolean persistent ) { super ( ) ; this . name = name ; this . path = path ; this . persistent SO = persistent ; owner Message = new Shared Object Message ( null , name , NUM , persistent ) ; creation Time = System . current Time Millis ( ) ; super . set Attributes ( data ) ; }
public static String date To String ( Date date ) { if ( date == null ) { return null ; } else { Date Format df = new Simple Date Format ( date Format ) ; df . set Time Zone ( utc ) ; return df . format ( date ) ; } }
public static String info First Last Pixels ( Image Line Int line ) { return line . img Info . channels == NUM ? String . format ( STRING , line . scanline [ NUM ] , line . scanline [ line . scanline . length - NUM ] ) : String . format ( STRING , line . scanline [ NUM ] , line . scanline [ NUM ] , line . scanline [ NUM ] , line . scanline [ line . scanline . length - line . img Info . channels ] , line . scanline [ line . scanline . length - line . img Info . channels + NUM ] , line . scanline [ line . scanline . length - line . img Info . channels + NUM ] ) ; }
private Ast Node member Expr Tail ( boolean allow Call Syntax , Ast Node pn ) throws IO Exception { if ( pn == null ) code Bug ( ) ; int pos = pn . get Position ( ) ; int lineno ; tail Loop : for ( ; ; ) { int tt = peek Token ( ) ; switch ( tt ) { case Token . DOT : case Token . DOTDOT : lineno = ts . lineno ; pn = property Access ( tt , pn ) ; pn . set Lineno ( lineno ) ; break ; case Token . DOTQUERY : consume Token ( ) ; int op Pos = ts . token Beg , rp = - NUM ; lineno = ts . lineno ; must Have XML ( ) ; set Requires Activation ( ) ; Ast Node filter = expr ( ) ; int end = get Node End ( filter ) ; if ( must Match Token ( Token . RP , STRING ) ) { rp = ts . token Beg ; end = ts . token End ; } Xml Dot Query q = new Xml Dot Query ( pos , end - pos ) ; q . set Left ( pn ) ; q . set Right ( filter ) ; q . set Operator Position ( op Pos ) ; q . set Rp ( rp - pos ) ; q . set Lineno ( lineno ) ; pn = q ; break ; case Token . LB : consume Token ( ) ; int lb = ts . token Beg , rb = - NUM ; lineno = ts . lineno ; Ast Node expr = expr ( ) ; end = get Node End ( expr ) ; if ( must Match Token ( Token . RB , STRING ) ) { rb = ts . token Beg ; end = ts . token End ; } Element Get g = new Element Get ( pos , end - pos ) ; g . set Target ( pn ) ; g . set Element ( expr ) ; g . set Parens ( lb , rb ) ; g . set Lineno ( lineno ) ; pn = g ; break ; case Token . LP : if ( ! allow Call Syntax ) { break tail Loop ; } lineno = ts . lineno ; consume Token ( ) ; check Call Requires Activation ( pn ) ; Function Call f = new Function Call ( pos ) ; f . set Target ( pn ) ; f . set Lineno ( lineno ) ; f . set Lp ( ts . token Beg - pos ) ; List < Ast Node > args = argument List ( ) ; if ( args != null && args . size ( ) > ARGC LIMIT ) report Error ( STRING ) ; f . set Arguments ( args ) ; f . set Rp ( ts . token Beg - pos ) ; f . set Length ( ts . token End - pos ) ; pn = f ; break ; default : break tail Loop ; } } return pn ; }
public static Iterable < Element > elements ( Node List nodes ) { return null ; }
public static int min Distance ( String word 1 , String word 2 ) { if ( word 1 . equals ( word 2 ) ) return NUM ; int m = word 1 . length ( ) ; int n = word 2 . length ( ) ; int [ ] [ ] d = new int [ m + NUM ] [ n + NUM ] ; d [ NUM ] [ NUM ] = NUM ; for ( int i = NUM ; i < m + NUM ; i ++ ) d [ i ] [ NUM ] = i ; for ( int j = NUM ; j < n + NUM ; j ++ ) d [ NUM ] [ j ] = j ; for ( int i = NUM ; i < m + NUM ; i ++ ) { for ( int j = NUM ; j < n + NUM ; j ++ ) { d [ i ] [ j ] = Math . min ( Math . min ( d [ i ] [ j - NUM ] + NUM , d [ i - NUM ] [ j ] + NUM ) , word 1 . char At ( i - NUM ) == word 2 . char At ( j - NUM ) ? d [ i - NUM ] [ j - NUM ] : d [ i - NUM ] [ j - NUM ] + NUM ) ; } } return d [ m ] [ n ] ; }
public void add Url ( String url ) { Set < String > urls = get Cached Urls ( ) ; urls . add ( url ) ; put Cached Urls ( urls ) ; update Notification ( urls ) ; }
public void test Value Of Long Max ( ) { long long Val = Long . MAX VALUE ; Big Integer a Number = Big Integer . value Of ( long Val ) ; byte r Bytes [ ] = { NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM } ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
private void close Database Connection ( Connection connection ) { if ( connection == null ) return ; try { connection . close ( ) ; } catch ( SQL Exception e ) { } connection = null ; return ; }
@ Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case Information Model Package . INFORMATION MODEL NAME : return NAME EDEFAULT == null ? name != null : ! NAME EDEFAULT . equals ( name ) ; case Information Model Package . INFORMATION MODEL NAMESPACE : return NAMESPACE EDEFAULT == null ? namespace != null : ! NAMESPACE EDEFAULT . equals ( namespace ) ; case Information Model Package . INFORMATION MODEL VERSION : return VERSION EDEFAULT == null ? version != null : ! VERSION EDEFAULT . equals ( version ) ; case Information Model Package . INFORMATION MODEL REFERENCES : return references != null && ! references . is Empty ( ) ; case Information Model Package . INFORMATION MODEL DESCRIPTION : return DESCRIPTION EDEFAULT == null ? description != null : ! DESCRIPTION EDEFAULT . equals ( description ) ; case Information Model Package . INFORMATION MODEL DISPLAYNAME : return DISPLAYNAME EDEFAULT == null ? displayname != null : ! DISPLAYNAME EDEFAULT . equals ( displayname ) ; case Information Model Package . INFORMATION MODEL CATEGORY : return CATEGORY EDEFAULT == null ? category != null : ! CATEGORY EDEFAULT . equals ( category ) ; case Information Model Package . INFORMATION MODEL PROPERTIES : return properties != null && ! properties . is Empty ( ) ; } return super . e Is Set ( feature ID ) ; }
public void add Unnamed Task ( Tmm Task task ) { if ( unnamed Task Executor == null || unnamed Task Executor . is Shutdown ( ) ) { unnamed Task Executor = create Unnamed Task Executor ( ) ; } task . add Listener ( this ) ; task . set State ( Task State . QUEUED ) ; unnamed Task Executor . execute ( task ) ; }
public Path ( final Vertex v0 , final Vertex v1 , final Edge Sample edge Sample ) { if ( v0 == null ) throw new Illegal Argument Exception ( ) ; if ( v1 == null ) throw new Illegal Argument Exception ( ) ; if ( v0 . sample == null ) throw new Illegal Argument Exception ( ) ; if ( edge Sample == null ) throw new Illegal Argument Exception ( ) ; if ( edge Sample . get Sample ( ) == null ) throw new Illegal Argument Exception ( ) ; this . vertices = new Vertex [ ] { v0 , v1 } ; this . preds = get Predicates ( vertices ) ; this . edge Sample = edge Sample ; this . sum Est Read = v0 . sample . est Card + edge Sample . est Read ; this . sum Est Card = edge Sample . est Card ; this . sum Est Cost = get Cost ( this . sum Est Read , this . sum Est Card ) ; }
public boolean evaluate ( Map record ) { Object rec Val = record . get ( key Field ) ; return op . evaluate ( this . val , rec Val ) ; }
protected static final String add Escapes ( String str ) { String Buffer retval = new String Buffer ( ) ; char ch ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) { switch ( str . char At ( i ) ) { case NUM : continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; default : if ( ( ch = str . char At ( i ) ) < NUM || ch > NUM ) { String s = STRING + Integer . to String ( ch , NUM ) ; retval . append ( STRING + s . substring ( s . length ( ) - NUM , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . to String ( ) ; }
public char [ ] to Char Array ( ) { Charset utf 8 = Charset . for Name ( STRING ) ; Char Buffer char Buffer = utf 8 . decode ( Byte Buffer . wrap ( buffer , offset , length ) ) ; char [ ] chars = new char [ char Buffer . remaining ( ) ] ; char Buffer . get ( chars ) ; return chars ; }
public static byte [ ] chars 2 utf ( char [ ] src , int sindex , int len ) { byte [ ] dst = new byte [ len * NUM ] ; int len 1 = chars 2 utf ( src , sindex , dst , NUM , len ) ; byte [ ] result = new byte [ len 1 ] ; System . arraycopy ( dst , NUM , result , NUM , len 1 ) ; return result ; }
private void read Reference ( ) { String sql ; if ( Env . is Base Language ( Env . get Ctx ( ) , STRING ) ) sql = STRING + STRING ; else sql = STRING + STRING + STRING + STRING + Env . get AD Language ( Env . get Ctx ( ) ) + STRING + STRING ; Array List < String > v value = new Array List < String > ( ) ; Array List < String > v name = new Array List < String > ( ) ; Array List < String > v description = new Array List < String > ( ) ; try { Prepared Statement pstmt = DB . prepare Statement ( sql , null ) ; Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { String value = rs . get String ( NUM ) ; String name = rs . get String ( NUM ) ; String description = rs . get String ( NUM ) ; if ( description == null ) description = STRING ; v value . add ( value ) ; v name . add ( name ) ; v description . add ( description ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } int size = v value . size ( ) ; s value = new String [ size ] ; s name = new String [ size ] ; s description = new String [ size ] ; for ( int i = NUM ; i < size ; i ++ ) { s value [ i ] = ( String ) v value . get ( i ) ; s name [ i ] = ( String ) v name . get ( i ) ; s description [ i ] = ( String ) v description . get ( i ) ; } }
private Carbon Dictionary Sort Info create Column Sort Info ( Carbon Dictionary Sort Model [ ] dictionary Sort Models ) { int [ ] sort Index ; int [ ] sort Index Inverted ; Arrays . sort ( dictionary Sort Models ) ; sort Index = new int [ dictionary Sort Models . length ] ; sort Index Inverted = new int [ dictionary Sort Models . length ] ; for ( int i = NUM ; i < dictionary Sort Models . length ; i ++ ) { Carbon Dictionary Sort Model dictionary Sort Model = dictionary Sort Models [ i ] ; sort Index [ i ] = dictionary Sort Model . get Key ( ) ; sort Index Inverted [ dictionary Sort Model . get Key ( ) - NUM ] = i + NUM ; } dictionary Sort Models = null ; List < Integer > sort Index List = convert To List ( sort Index ) ; List < Integer > sort Index Inverted List = convert To List ( sort Index Inverted ) ; return new Carbon Dictionary Sort Info ( sort Index List , sort Index Inverted List ) ; }
private Integer Polynomial MGF ( byte [ ] seed , int N , int min Calls R , boolean hash Seed ) { Digest hash Alg = params . hash Alg ; int hash Len = hash Alg . get Digest Size ( ) ; byte [ ] buf = new byte [ min Calls R * hash Len ] ; byte [ ] Z = hash Seed ? calc Hash ( hash Alg , seed ) : seed ; int counter = NUM ; while ( counter < min Calls R ) { hash Alg . update ( Z , NUM , Z . length ) ; put Int ( hash Alg , counter ) ; byte [ ] hash = calc Hash ( hash Alg ) ; System . arraycopy ( hash , NUM , buf , counter * hash Len , hash Len ) ; counter ++ ; } Integer Polynomial i = new Integer Polynomial ( N ) ; while ( BOOL ) { int cur = NUM ; for ( int index = NUM ; index != buf . length ; index ++ ) { int O = ( int ) buf [ index ] & NUM ; if ( O >= NUM ) { continue ; } for ( int ter Idx = NUM ; ter Idx < NUM ; ter Idx ++ ) { int rem 3 = O % NUM ; i . coeffs [ cur ] = rem 3 - NUM ; cur ++ ; if ( cur == N ) { return i ; } O = ( O - rem 3 ) / NUM ; } i . coeffs [ cur ] = O - NUM ; cur ++ ; if ( cur == N ) { return i ; } } if ( cur >= N ) { return i ; } hash Alg . update ( Z , NUM , Z . length ) ; put Int ( hash Alg , counter ) ; byte [ ] hash = calc Hash ( hash Alg ) ; buf = hash ; counter ++ ; } }
public static void agentmain ( String agent Args , Instrumentation inst ) throws Exception { synchronized ( JVM Agent . class ) { if ( instance == null ) { instance = new JVM Agent ( inst ) ; wait For Instance . count Down ( ) ; } } }
public void close ( ) { Handler [ ] handler Array = m logger . get Handlers ( ) ; for ( int i = NUM ; i < handler Array . length ; i ++ ) { Handler h = handler Array [ i ] ; h . flush ( ) ; h . close ( ) ; m logger . remove Handler ( h ) ; } }
public String to String ( ) { if ( val == null ) return STRING ; if ( val instanceof Long || val instanceof Integer ) { return Long . to String ( val . long Value ( ) ) ; } double d = val . double Value ( ) ; if ( Double . is Infinite ( d ) ) return ( d > NUM ) ? STRING : STRING ; if ( Double . is Na N ( d ) ) return STRING ; return Double . to String ( d ) ; }
public static List < String > split Text ( String text ) { int start Line = NUM ; int i = NUM ; int n = text . length ( ) ; Array List < String > rc = new Array List < String > ( ) ; while ( i < n ) { switch ( text . char At ( i ) ) { case STRING : i ++ ; if ( i < n && text . char At ( i ) == STRING ) { i ++ ; } rc . add ( text . substring ( start Line , i ) ) ; start Line = i ; break ; case STRING : i ++ ; if ( i < n && text . char At ( i ) == STRING ) { i ++ ; } rc . add ( text . substring ( start Line , i ) ) ; start Line = i ; break ; default : i ++ ; } } if ( start Line == text . length ( ) ) { rc . add ( STRING ) ; } else { rc . add ( text . substring ( start Line , i ) ) ; } return rc ; }
Country Code Source maybe Strip International Prefix And Normalize ( String Builder number , String possible Idd Prefix ) { if ( number . length ( ) == NUM ) { return Country Code Source . FROM DEFAULT COUNTRY ; } Matcher m = PLUS CHARS PATTERN . matcher ( number ) ; if ( m . looking At ( ) ) { number . delete ( NUM , m . end ( ) ) ; normalize ( number ) ; return Country Code Source . FROM NUMBER WITH PLUS SIGN ; } Pattern idd Pattern = regex Cache . get Pattern For Regex ( possible Idd Prefix ) ; normalize ( number ) ; return parse Prefix As Idd ( idd Pattern , number ) ? Country Code Source . FROM NUMBER WITH IDD : Country Code Source . FROM DEFAULT COUNTRY ; }
@ Override public void write ( int value ) { digest . update ( ( byte ) value ) ; }
public boolean is Manufactured ( boolean ignore Supplier Products ) { List < Generic Value > supplier Products = null ; try { supplier Products = product . get Related ( STRING , Util Misc . to Map ( STRING , STRING ) , Util Misc . to List ( STRING ) , BOOL ) ; } catch ( Generic Entity Exception gee ) { Debug . log Error ( STRING , module ) ; } supplier Products = Entity Util . filter By Date ( supplier Products , Util Date Time . now Timestamp ( ) , STRING , STRING , BOOL ) ; return children Nodes . size ( ) > NUM && ( ignore Supplier Products || Util Validate . is Empty ( supplier Products ) ) ; }
private void add Code From Field ( String Builder sb , Field f ) { try { sb . append ( f . get Name ( ) + STRING + f . get Int ( Key Event . class ) ) ; } catch ( Illegal Argument Exception e ) { e . print Stack Trace ( ) ; } catch ( Illegal Access Exception e ) { e . print Stack Trace ( ) ; } sb . append ( STRING ) ; }
protected boolean scroll Up ( Text View widget , Spannable buffer , int amount ) { final Layout layout = widget . get Layout ( ) ; final int top = widget . get Scroll Y ( ) ; int top Line = layout . get Line For Vertical ( top ) ; if ( layout . get Line Top ( top Line ) == top ) { top Line -= NUM ; } if ( top Line >= NUM ) { top Line = Math . max ( top Line - amount + NUM , NUM ) ; Touch . scroll To ( widget , layout , widget . get Scroll X ( ) , layout . get Line Top ( top Line ) ) ; return BOOL ; } return BOOL ; }
public void load ( String filename ) { ++ num Mappings ; load Class File ( filename ) ; }
protected void fill Face Tool Bar ( J Tool Bar face TB , Button Group bg ) { for ( Edit Tool Loader loader : loader List ) { String [ ] classnames = loader . get Editable Classes ( ) ; for ( int i = NUM ; i < classnames . length ; i ++ ) { Image Icon icon = loader . get Icon ( classnames [ i ] ) ; J Toggle Button btn = new J Toggle Button ( icon , BOOL ) ; btn . set Tool Tip Text ( loader . get Pretty Name ( classnames [ i ] ) ) ; btn . set Focusable ( BOOL ) ; btn . set Action Command ( classnames [ i ] ) ; btn . add Action Listener ( this ) ; bg . add ( btn ) ; face TB . add ( btn ) ; } } }
public void write To File ( File filename ) throws IO Exception { File Utils . string To File ( m Text . to String ( ) , filename ) ; }
protected void transform Rects Touch ( Array List < Rect F > rects ) { for ( int i = NUM ; i < rects . size ( ) ; i ++ ) { m Matrix Touch . map Rect ( rects . get ( i ) ) ; } }
@ Override public String to String ( ) { String Builder buf = new String Builder ( ) ; for ( Name Value Pair pair : name Value Pair List ) { buf . append ( STRING ) ; buf . append ( pair . get Name ( ) ) ; buf . append ( STRING ) ; buf . append ( STRING ) ; buf . append ( get Quoted Attribute Value ( pair . get Value ( ) ) ) ; buf . append ( STRING ) ; } return buf . to String ( ) ; }
@ Override public final int array Offset ( ) { return protected Array Offset ( ) ; }
public DOM Test Document Builder Factory new Instance ( Document Builder Setting [ ] new Settings ) throws DOM Test Incompatible Exception { if ( new Settings == null ) { return this ; } Document Builder Setting [ ] merged Settings = merge Settings ( new Settings ) ; return new Batik Test Document Builder Factory ( merged Settings ) ; }
public float [ ] value Array ( float [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new float [ count ] ; } System . arraycopy ( values , NUM , array , NUM , count ) ; return array ; }
public static Set < Type Variable > method Type To Targets ( final Annotated Executable Type method Type ) { final List < Annotated Type Variable > annotated Type Vars = method Type . get Type Variables ( ) ; final Set < Type Variable > targets = new Linked Hash Set < > ( annotated Type Vars . size ( ) ) ; for ( final Annotated Type Variable atv : annotated Type Vars ) { targets . add ( atv . get Underlying Type ( ) ) ; } return targets ; }
private void validate Table Meta Data Single Row ( String table Name Pattern , String [ ] types , Map < Table Meta Data , Object > validation Rules ) throws Exception { check Validation Rules Complete ( validation Rules ) ; try ( Result Set tables = dbmd . get Tables ( null , null , table Name Pattern , types ) ) { assert True ( STRING , tables . next ( ) ) ; validate Row Values ( tables , validation Rules ) ; assert False ( STRING , tables . next ( ) ) ; } }
public void flush ( ) throws IO Exception { try { writer . write ( buffer , NUM , pos ) ; writer . flush ( ) ; } catch ( IO Exception except ) { if ( exception == null ) exception = except ; throw except ; } pos = NUM ; }
private Java Script Relation Sets ( ) { }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
private J Menu make Log Level Menu ( ) { return new Log Level Menu ( ) ; }
@ Override public void close ( ) throws IO Exception { synchronized ( lock ) { buf = null ; in . close ( ) ; } }
public D Get Alias ( J Frame parent , String title , String alias ) { super ( parent , title , Dialog . Modality Type . DOCUMENT MODAL ) ; init Components ( alias ) ; }
public static void close Quietly ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( Runtime Exception rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
public static Array List < Hop > deep Copy Hops Dag ( Array List < Hop > hops ) throws Hops Exception { Array List < Hop > ret = new Array List < Hop > ( ) ; try { Hash Map < Long , Hop > memo = new Hash Map < Long , Hop > ( ) ; for ( Hop hop Root : hops ) ret . add ( r Deep Copy Hops Dag ( hop Root , memo ) ) ; } catch ( Exception ex ) { throw new Hops Exception ( ex ) ; } return ret ; }
public void add All ( T ... items ) { if ( m Event Delegate != null ) m Event Delegate . add Data ( items == null ? NUM : items . length ) ; if ( items != null && items . length != NUM ) { synchronized ( m Lock ) { Collections . add All ( m Objects , items ) ; } } if ( m Notify On Change ) notify Data Set Changed ( ) ; }
private void replace Impl ( final int start Index , final int end Index , final int remove Len , final String insert Str , final int insert Len ) { final int new Size = size - remove Len + insert Len ; if ( insert Len != remove Len ) { ensure Capacity ( new Size ) ; System . arraycopy ( buffer , end Index , buffer , start Index + insert Len , size - end Index ) ; size = new Size ; } if ( insert Len > NUM ) { insert Str . get Chars ( NUM , insert Len , buffer , start Index ) ; } }
public void update Cheque DD Card Deposit Receipt ( final Map instrument Details Map ) { update Instrument And Payin Sql ( instrument Details Map ) ; add To Bank Reconcilation SQL ( instrument Details Map ) ; }
public void testtest Is Last ( ) throws SQL Exception { assert False ( target . is Last ( ) ) ; target . absolute ( - NUM ) ; assert True ( target . is Last ( ) ) ; assert False ( empty Target . is Last ( ) ) ; assert False ( empty Target . next ( ) ) ; assert False ( empty Target . is Last ( ) ) ; try { target . close ( ) ; target . is Last ( ) ; fail ( STRING ) ; } catch ( SQL Exception e ) { } }
public final void add Helper Text ( @ Non Null final Char Sequence helper Text ) { ensure Not Null ( helper Text , STRING ) ; ensure Not Empty ( helper Text , STRING ) ; if ( ! helper Texts . contains ( helper Text ) ) { helper Texts . add ( helper Text ) ; verify Password Strength ( ) ; } }
void wait For Log Entry ( int index , int timeout ) throws Gondola Exception , Interrupted Exception , Timeout Exception { reset ( ) ; this . index = index ; long end Ts = timeout < NUM ? Long . MAX VALUE : gondola . get Clock ( ) . now ( ) + timeout ; lock . lock ( ) ; try { while ( status == Command . STATUS NONE && gondola . get Clock ( ) . now ( ) < end Ts ) { if ( timeout < NUM ) { update Cond . await ( ) ; } else { update Cond . await ( timeout , Time Unit . MILLISECONDS ) ; } } if ( this . index != index ) { logger . error ( STRING ) ; } } finally { lock . unlock ( ) ; } switch ( status ) { case Command . STATUS NONE : status = Command . STATUS TIMEOUT ; throw new Timeout Exception ( String . format ( STRING , timeout , index ) ) ; case Command . STATUS NOT LEADER : assert BOOL ; break ; case Command . STATUS SLAVE MODE : throw new Gondola Exception ( Gondola Exception . Code . SLAVE MODE , cmember . member Id ) ; case Command . STATUS ERROR : throw new Illegal State Exception ( STRING + index + STRING + error Message ) ; case Command . STATUS OK : break ; } }
public static String generate Native Guid ( Db Client db Client , Volume volume ) throws IO Exception { Storage System device = db Client . query Object ( Storage System . class , volume . get Storage Controller ( ) ) ; return String . format ( STRING + VOLUME + STRING , device Type Map . get ( device . get System Type ( ) ) , device . get Serial Number ( ) , volume . get Native Id ( ) ) ; }
public Agent Mappings save Agent Mappings ( Agent Mappings agent Mappings , boolean check Environments ) throws Business Exception , JAXB Exception , IO Exception { if ( check Environments ) { check Environments ( agent Mappings ) ; } Agent Mappings current ; do { current = agent Mappings Reference . get ( ) ; if ( current . get Revision ( ) != agent Mappings . get Revision ( ) ) { throw new Business Exception ( STRING , Configuration Interface Error Code Enum . REVISION CHECK FAILED ) ; } } while ( ! agent Mappings Reference . compare And Set ( current , agent Mappings ) ) ; agent Mappings . set Revision ( agent Mappings . get Revision ( ) + NUM ) ; save Agent Mapping ( agent Mappings ) ; publish Agent Mappings Update Event ( ) ; return agent Mappings ; }
public E push ( E object ) { add Element ( object ) ; return object ; }
protected void new Cert Btn Listener ( ) { New Certificate Dialog Data data = new New Certificate Dialog Data ( ) ; New Certificate Dialog dialog = new New Certificate Dialog ( get Shell ( ) , data , STRING ) ; int return Code = dialog . open ( ) ; if ( return Code == Window . OK ) { String cert Path = data . get Cer File Path ( ) ; cert Txt . set Text ( cert Path != null ? cert Path . replace ( STRING , STRING ) : cert Path ) ; cert Info Txt . set Text ( get Cert Info ( cert Txt . get Text ( ) ) ) ; } }
public static void generate Mov ( final I Translation Environment environment , final long base Offset , final I Instruction instruction , final List < Reil Instruction > instructions ) throws Internal Translation Exception { Preconditions . check Not Null ( environment , STRING ) ; Preconditions . check Not Null ( instruction , STRING ) ; Preconditions . check Not Null ( instructions , STRING ) ; long reil Offset = base Offset ; final List < ? extends I Operand Tree > operands = instruction . get Operands ( ) ; final Translation Result load Source = Helpers . translate Operand ( environment , reil Offset , operands . get ( NUM ) , BOOL ) ; instructions . add All ( load Source . get Instructions ( ) ) ; reil Offset = base Offset + instructions . size ( ) ; final Translation Result load Dest = Helpers . translate Operand ( environment , reil Offset , operands . get ( NUM ) , BOOL ) ; instructions . add All ( load Dest . get Instructions ( ) ) ; reil Offset = base Offset + instructions . size ( ) ; Helpers . write Back ( environment , reil Offset , operands . get ( NUM ) , load Source . get Register ( ) , load Dest . get Size ( ) , load Dest . get Address ( ) , load Dest . get Type ( ) , instructions ) ; }
public void characters ( char ch [ ] , int start , int length ) throws org . xml . sax . SAX Exception { if ( ! m should Process ) return ; XSLT Element Processor elem Processor = get Current Processor ( ) ; XSLT Element Def def = elem Processor . get Elem Def ( ) ; if ( def . get Type ( ) != XSLT Element Def . T PCDATA ) elem Processor = def . get Processor For ( null , STRING ) ; if ( null == elem Processor ) { if ( ! XML Character Recognizer . is White Space ( ch , start , length ) ) error ( XSL Messages . create Message ( XSLT Error Resources . ER NONWHITESPACE NOT ALLOWED IN POSITION , null ) , null ) ; } else elem Processor . characters ( this , ch , start , length ) ; }
public boolean remove Entry ( int x Index , int data Set Index ) { if ( data Set Index >= m Data Sets . size ( ) ) return BOOL ; T data Set = m Data Sets . get ( data Set Index ) ; Entry e = data Set . get Entry For X Index ( x Index ) ; return remove Entry ( e , data Set Index ) ; }
public void test Bug 68562 ( ) throws Exception { test Bug 68562 Batch With Size ( NUM ) ; test Bug 68562 Batch With Size ( NUM ) ; }
public Vec 2 to Vector ( Point 2 D v ) { return new Vec 2 ( to Meters ( v . get X ( ) ) , to Meters ( - v . get Y ( ) ) ) ; }
@ Override public void terminate Any Restore Sessions ( Storage System storage , Block Object from , URI volume , Task Completer task Completer ) throws Exception { Block Object block Object = Block Object . fetch ( db Client , volume ) ; Collection < CIM Object Path > sync Objects = null ; if ( storage . check If Vmax 3 ( ) ) { sync Objects = helper . get Settings Define State Paths ( storage , block Object , ( Block Snapshot ) from ) ; } else { sync Objects = get Restored Or Mixed State Sync Objects ( storage , block Object ) ; } for ( CIM Object Path sync Object : sync Objects ) { resume Snapshot ( storage , from , block Object , sync Object , task Completer ) ; } }
public static < T > Set < T > to Set ( T obj 1 , T obj 2 , T obj 3 , T obj 4 , T obj 5 , T obj 6 ) { Set < T > the Set = new Linked Hash Set < T > ( ) ; the Set . add ( obj 1 ) ; the Set . add ( obj 2 ) ; the Set . add ( obj 3 ) ; the Set . add ( obj 4 ) ; the Set . add ( obj 5 ) ; the Set . add ( obj 6 ) ; return the Set ; }
protected void write Graphic Ctrl Ext ( ) throws IO Exception { out . write ( NUM ) ; out . write ( NUM ) ; out . write ( NUM ) ; int transp , disp ; if ( transparent == - NUM ) { transp = NUM ; disp = NUM ; } else { transp = NUM ; disp = NUM ; } if ( dispose >= NUM ) { disp = dispose & NUM ; } disp <<= NUM ; out . write ( NUM | disp | NUM | transp ) ; write Short ( delay ) ; out . write ( trans Index ) ; out . write ( NUM ) ; }
public final double do Operation ( ) throws Operator Failed Exception { int index ; if ( update Map == null ) { index = Math Utils . next Int ( parameter . get Dimension ( ) ) ; } else { index = update Map . get ( Math Utils . next Int ( update Map Size ) ) ; } double draw = ( NUM * Math Utils . next Double ( ) - NUM ) * window Size ; double new Value = parameter . get Parameter Value ( index ) + draw ; final Bounds < Double > bounds = parameter . get Bounds ( ) ; final double lower = ( lower Operator Bound == null ? bounds . get Lower Limit ( index ) : Math . max ( bounds . get Lower Limit ( index ) , lower Operator Bound ) ) ; final double upper = ( upper Operator Bound == null ? bounds . get Upper Limit ( index ) : Math . min ( bounds . get Upper Limit ( index ) , upper Operator Bound ) ) ; if ( condition == Boundary Condition . reflecting ) { new Value = reflect Value ( new Value , lower , upper ) ; } else if ( condition == Boundary Condition . absorbing && ( new Value < lower || new Value > upper ) ) { return NUM ; } else if ( new Value < lower || new Value > upper ) { throw new Operator Failed Exception ( STRING ) ; } parameter . set Parameter Value ( index , new Value ) ; return NUM ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String child Data ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; child . replace Data ( NUM , NUM , STRING ) ; child Data = child . get Data ( ) ; assert Equals ( STRING , STRING , child Data ) ; }
public Collection < Object > injectables ( ) { return Collections . empty List ( ) ; }
private void update Effective Dimensions ( ) { effective Width = Math . max ( NUM , width - left Border - right Border ) ; effective Height = Math . max ( NUM , height - top Border - bottom Border ) ; }
public void add Attribute ( Attribute Info info ) { if ( attribute == null ) attribute = new Array List ( ) ; Attribute Info . remove ( attribute , info . get Name ( ) ) ; attribute . add ( info ) ; }
public void add Line ( String text ) throws Bad Location Exception { if ( text == null || text . length ( ) == NUM || text . equals ( STRING ) ) { return ; } document . replace ( document . get Length ( ) , NUM , text ) ; }
protected void mute Button Pressed ( Action Event e ) { J Toggle Button b = ( J Toggle Button ) e . get Source ( ) ; log . debug ( STRING + b . is Selected ( ) ) ; fire Property Change ( Property Change ID . MUTE , ! b . is Selected ( ) , b . is Selected ( ) ) ; }
public Two D Point ( String s ) { String Tokenizer st = new String Tokenizer ( s , STRING ) ; x = Double . value Of ( st . next Token ( ) ) ; y = Double . value Of ( st . next Token ( ) ) ; }
private void read Object ( final Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; init ( ) ; }
public static boolean is Class Support ( String clz Name ) { try { Class . for Name ( clz Name ) ; return BOOL ; } catch ( Class Not Found Exception e ) { return BOOL ; } }
public void add Popup Listener ( final Popup Listener listener ) { if ( ! popup Listeners . contains ( listener ) ) { popup Listeners . add ( listener ) ; } }
public static byte [ ] decode ( byte [ ] data ) { int len = data . length / NUM * NUM ; Byte Array Output Stream b Out = new Byte Array Output Stream ( len ) ; try { encoder . decode ( data , NUM , data . length , b Out ) ; } catch ( Exception e ) { throw new Decoder Exception ( STRING + e . get Message ( ) , e ) ; } return b Out . to Byte Array ( ) ; }
public static String build Selector From Attribute Type And Value ( String attribute Type , String attribute Value ) { String Builder strb = new String Builder ( ) ; strb . append ( OPEN BRACKET ) ; strb . append ( attribute Type ) ; strb . append ( EQUAL ) ; strb . append ( attribute Value ) ; strb . append ( CLOSE BRACKET ) ; return strb . to String ( ) ; }
public static Bitmap scale Fit ( Bitmap src , int max W , int max H ) { float ratio = Math . min ( max W / ( float ) src . get Width ( ) , max H / ( float ) src . get Height ( ) ) ; int new W = ( int ) ( src . get Width ( ) * ratio ) ; int new H = ( int ) ( src . get Height ( ) * ratio ) ; return scale ( src , new W , new H ) ; }
public File ( String dir Path , String name ) { if ( name == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( dir Path == null || dir Path . is Empty ( ) ) { this . path = fix Slashes ( name ) ; } else if ( name . is Empty ( ) ) { this . path = fix Slashes ( dir Path ) ; } else { this . path = fix Slashes ( join ( dir Path , name ) ) ; } }
void decode Attribute Body ( byte [ ] attribute Value , char offset , char length ) { username = new byte [ length ] ; System . arraycopy ( attribute Value , offset , username , NUM , length ) ; }
protected synchronized byte [ ] engine Generate Seed ( int num Bytes ) { byte [ ] my Bytes ; if ( num Bytes < NUM ) { throw new Negative Array Size Exception ( Integer . to String ( num Bytes ) ) ; } if ( num Bytes == NUM ) { return Empty Array . BYTE ; } if ( my Random == null ) { my Random = new SHA 1 PRNG Secure Random Impl ( ) ; my Random . engine Set Seed ( get Random Bytes ( DIGEST LENGTH ) ) ; } my Bytes = new byte [ num Bytes ] ; my Random . engine Next Bytes ( my Bytes ) ; return my Bytes ; }
public static String normalize Inet 4 Address ( String ip 4 String ) { final int [ ] octets = parse Inet 4 Address ( ip 4 String ) ; if ( octets == null ) { return null ; } String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( octets [ i ] ) ; } return sb . to String ( ) ; }
public static int [ ] shuffle ( int [ ] input ) { List < Integer > vals = new Array List < Integer > ( input . length ) ; for ( int i = NUM ; i < input . length ; i ++ ) vals . add ( input [ i ] ) ; Collections . shuffle ( vals , SEEDED RANDOM ) ; int [ ] copy = new int [ input . length ] ; for ( int i = NUM ; i < input . length ; i ++ ) copy [ i ] = vals . get ( i ) ; return copy ; }
public boolean offer ( Pooled Connection pooled Connection ) { acquired Connections . remove ( pooled Connection ) ; boolean offer = queue . offer ( pooled Connection ) ; if ( ! offer ) { pooled Connection . dispose ( ) ; } if ( is Terminating . get ( ) ) { Pooled Connection poll = queue . poll ( ) ; if ( poll != null ) { poll . dispose ( ) ; } } return offer ; }
private int parse Style In Default Workspace ( Geo Server REST Reader reader , int count , List < Style Wrapper > style List ) { REST Style List geo Server Style List = reader . get Styles ( ) ; for ( String style : geo Server Style List . get Names ( ) ) { Style Wrapper new Style Wrapper = new Style Wrapper ( DEFAULT WORKSPACE NAME , style ) ; style List . add ( new Style Wrapper ) ; if ( parent Obj != null ) { parent Obj . read Styles Progress ( connection , count , count ) ; } count ++ ; } return count ; }
private Class Signature load Class From Jigsaw ( String classname ) throws IO Exception { if ( method Class get Module == null || method Module get Name == null ) { return null ; } final Class < ? > clazz ; final String module Name ; try { clazz = Class . for Name ( classname , BOOL , loader ) ; final Object module = method Class get Module . invoke ( clazz ) ; module Name = ( String ) method Module get Name . invoke ( module ) ; } catch ( Exception e ) { return null ; } return new Class Signature ( clazz , Asm Utils . is Runtime Module ( module Name ) ) ; }
public void test Connect ANT Sensor Cadence ( ) { if ( ! run Test ) { Log . d ( TAG , Big Test Utils . DISABLE MESSAGE ) ; return ; } use ANT Seonsor ( ) ; assert True ( check Sensors Status not Recording ( ) ) ; check ANT Sensors Status ( R . id . sensor state cadence ) ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return BOOL ; } if ( obj == null ) { return BOOL ; } if ( get Class ( ) != obj . get Class ( ) ) { return BOOL ; } Diff other = ( Diff ) obj ; if ( operation != other . operation ) { return BOOL ; } if ( text == null ) { if ( other . text != null ) { return BOOL ; } } else if ( ! text . equals ( other . text ) ) { return BOOL ; } return BOOL ; }
public void clear Attribute Specs ( ) { if ( m attribute Specs == null ) { m attribute Specs = new Array List < Attribute Spec > ( ) ; } m attribute Specs . clear ( ) ; }
public void load Properties ( boolean silent ) { load Properties File ( System . get Property ( PROPERTIES FILE , STRING ) , silent ) ; initialize Properties ( ) ; }
@ Override public void start ( ) { try { Journal Client Endpoint endpoint = connect ( ) ; if ( endpoint != null ) { Output Stream os ; os = os = endpoint . start Message ( ) ; if ( os != null ) { os . write ( STRING ) ; } } } catch ( Exception e ) { log . finer ( e . to String ( ) ) ; } }
static private int read Bytes ( int c [ ] , int len , Input Stream is ) throws IO Exception { byte buf [ ] = new byte [ len ] ; if ( is . read ( buf , NUM , len ) < len ) { return - NUM ; } for ( int i = NUM ; i < len ; i ++ ) { c [ i ] = buf [ i ] & NUM ; } return NUM ; }
public static void sort ( Object [ ] array ) { if ( array . length > NUM ) { Arrays . sort ( array , INSTANCE ) ; } }
public static int expected Size Of Probability Table ( Random Variable ... vars ) { int expected Size Of Distribution = NUM ; if ( null != vars ) { for ( Random Variable rv : vars ) { if ( ! ( rv . get Domain ( ) instanceof Finite Domain ) ) { throw new Illegal Argument Exception ( STRING + rv ) ; } Finite Domain d = ( Finite Domain ) rv . get Domain ( ) ; expected Size Of Distribution *= d . size ( ) ; } } return expected Size Of Distribution ; }
native private static void initialize ( String application Id ) ;
public static Anim Game Item process ( MD 5 Model md 5 Model , MD 5 Anim Model anim Model , Vector 3 f default Colour ) throws Exception { List < Matrix 4 f > inv Joint Matrices = calc In Joint Matrices ( md 5 Model ) ; List < Animated Frame > animated Frames = process Animation Frames ( md 5 Model , anim Model , inv Joint Matrices ) ; List < Mesh > list = new Array List < > ( ) ; for ( MD 5 Mesh md 5 Mesh : md 5 Model . get Meshes ( ) ) { Mesh mesh = generate Mesh ( md 5 Model , md 5 Mesh ) ; handle Texture ( mesh , md 5 Mesh , default Colour ) ; list . add ( mesh ) ; } Mesh [ ] meshes = new Mesh [ list . size ( ) ] ; meshes = list . to Array ( meshes ) ; Anim Game Item result = new Anim Game Item ( meshes , animated Frames , inv Joint Matrices ) ; return result ; }
static String encode High Level ( String msg , Compaction compaction , Charset encoding ) throws Writer Exception { String Builder sb = new String Builder ( msg . length ( ) ) ; if ( encoding == null ) { encoding = DEFAULT ENCODING ; } else if ( ! DEFAULT ENCODING . equals ( encoding ) ) { Character Set ECI eci = Character Set ECI . get Character Set ECI By Name ( encoding . name ( ) ) ; if ( eci != null ) { encoding ECI ( eci . get Value ( ) , sb ) ; } } int len = msg . length ( ) ; int p = NUM ; int text Sub Mode = SUBMODE ALPHA ; byte [ ] bytes = null ; if ( compaction == Compaction . TEXT ) { encode Text ( msg , p , len , sb , text Sub Mode ) ; } else if ( compaction == Compaction . BYTE ) { bytes = msg . get Bytes ( encoding ) ; encode Binary ( bytes , p , bytes . length , BYTE COMPACTION , sb ) ; } else if ( compaction == Compaction . NUMERIC ) { sb . append ( ( char ) LATCH TO NUMERIC ) ; encode Numeric ( msg , p , len , sb ) ; } else { int encoding Mode = TEXT COMPACTION ; while ( p < len ) { int n = determine Consecutive Digit Count ( msg , p ) ; if ( n >= NUM ) { sb . append ( ( char ) LATCH TO NUMERIC ) ; encoding Mode = NUMERIC COMPACTION ; text Sub Mode = SUBMODE ALPHA ; encode Numeric ( msg , p , n , sb ) ; p += n ; } else { int t = determine Consecutive Text Count ( msg , p ) ; if ( t >= NUM || n == len ) { if ( encoding Mode != TEXT COMPACTION ) { sb . append ( ( char ) LATCH TO TEXT ) ; encoding Mode = TEXT COMPACTION ; text Sub Mode = SUBMODE ALPHA ; } text Sub Mode = encode Text ( msg , p , t , sb , text Sub Mode ) ; p += t ; } else { if ( bytes == null ) { bytes = msg . get Bytes ( encoding ) ; } int b = determine Consecutive Binary Count ( msg , bytes , p ) ; if ( b == NUM ) { b = NUM ; } if ( b == NUM && encoding Mode == TEXT COMPACTION ) { encode Binary ( bytes , p , NUM , TEXT COMPACTION , sb ) ; } else { encode Binary ( bytes , p , b , encoding Mode , sb ) ; encoding Mode = BYTE COMPACTION ; text Sub Mode = SUBMODE ALPHA ; } p += b ; } } } } return sb . to String ( ) ; }
private int read Annotation Value ( int v , final char [ ] buf , final String name , final Annotation Visitor av ) { int i ; if ( av == null ) { switch ( b [ v ] & NUM ) { case STRING : return v + NUM ; case STRING : return read Annotation Values ( v + NUM , buf , BOOL , null ) ; case STRING : return read Annotation Values ( v + NUM , buf , BOOL , null ) ; default : return v + NUM ; } } switch ( b [ v ++ ] & NUM ) { case STRING : case STRING : case STRING : case STRING : av . visit ( name , read Const ( read Unsigned Short ( v ) , buf ) ) ; v += NUM ; break ; case STRING : av . visit ( name , new Byte ( ( byte ) read Int ( items [ read Unsigned Short ( v ) ] ) ) ) ; v += NUM ; break ; case STRING : av . visit ( name , read Int ( items [ read Unsigned Short ( v ) ] ) == NUM ? Boolean . FALSE : Boolean . TRUE ) ; v += NUM ; break ; case STRING : av . visit ( name , new Short ( ( short ) read Int ( items [ read Unsigned Short ( v ) ] ) ) ) ; v += NUM ; break ; case STRING : av . visit ( name , new Character ( ( char ) read Int ( items [ read Unsigned Short ( v ) ] ) ) ) ; v += NUM ; break ; case STRING : av . visit ( name , read UTF 8 ( v , buf ) ) ; v += NUM ; break ; case STRING : av . visit Enum ( name , read UTF 8 ( v , buf ) , read UTF 8 ( v + NUM , buf ) ) ; v += NUM ; break ; case STRING : av . visit ( name , Type . get Type ( read UTF 8 ( v , buf ) ) ) ; v += NUM ; break ; case STRING : v = read Annotation Values ( v + NUM , buf , BOOL , av . visit Annotation ( name , read UTF 8 ( v , buf ) ) ) ; break ; case STRING : int size = read Unsigned Short ( v ) ; v += NUM ; if ( size == NUM ) { return read Annotation Values ( v - NUM , buf , BOOL , av . visit Array ( name ) ) ; } switch ( this . b [ v ++ ] & NUM ) { case STRING : byte [ ] bv = new byte [ size ] ; for ( i = NUM ; i < size ; i ++ ) { bv [ i ] = ( byte ) read Int ( items [ read Unsigned Short ( v ) ] ) ; v += NUM ; } av . visit ( name , bv ) ; -- v ; break ; case STRING : boolean [ ] zv = new boolean [ size ] ; for ( i = NUM ; i < size ; i ++ ) { zv [ i ] = read Int ( items [ read Unsigned Short ( v ) ] ) != NUM ; v += NUM ; } av . visit ( name , zv ) ; -- v ; break ; case STRING : short [ ] sv = new short [ size ] ; for ( i = NUM ; i < size ; i ++ ) { sv [ i ] = ( short ) read Int ( items [ read Unsigned Short ( v ) ] ) ; v += NUM ; } av . visit ( name , sv ) ; -- v ; break ; case STRING : char [ ] cv = new char [ size ] ; for ( i = NUM ; i < size ; i ++ ) { cv [ i ] = ( char ) read Int ( items [ read Unsigned Short ( v ) ] ) ; v += NUM ; } av . visit ( name , cv ) ; -- v ; break ; case STRING : int [ ] iv = new int [ size ] ; for ( i = NUM ; i < size ; i ++ ) { iv [ i ] = read Int ( items [ read Unsigned Short ( v ) ] ) ; v += NUM ; } av . visit ( name , iv ) ; -- v ; break ; case STRING : long [ ] lv = new long [ size ] ; for ( i = NUM ; i < size ; i ++ ) { lv [ i ] = read Long ( items [ read Unsigned Short ( v ) ] ) ; v += NUM ; } av . visit ( name , lv ) ; -- v ; break ; case STRING : float [ ] fv = new float [ size ] ; for ( i = NUM ; i < size ; i ++ ) { fv [ i ] = Float . int Bits To Float ( read Int ( items [ read Unsigned Short ( v ) ] ) ) ; v += NUM ; } av . visit ( name , fv ) ; -- v ; break ; case STRING : double [ ] dv = new double [ size ] ; for ( i = NUM ; i < size ; i ++ ) { dv [ i ] = Double . long Bits To Double ( read Long ( items [ read Unsigned Short ( v ) ] ) ) ; v += NUM ; } av . visit ( name , dv ) ; -- v ; break ; default : v = read Annotation Values ( v - NUM , buf , BOOL , av . visit Array ( name ) ) ; } } return v ; }
private static final boolean compare And Set Wait Status ( Node node , int expect , int update ) { return unsafe . compare And Swap Int ( node , wait Status Offset , expect , update ) ; }
public Network Connectivity Listener ( ) { m State = State . UNKNOWN ; }
Vector process SIMPLEPATTERNLIST ( Stylesheet Handler handler , String uri , String name , String raw Name , String value , Elem Template Element owner ) throws org . xml . sax . SAX Exception { try { String Tokenizer tokenizer = new String Tokenizer ( value , STRING ) ; int n Patterns = tokenizer . count Tokens ( ) ; Vector patterns = new Vector ( n Patterns ) ; for ( int i = NUM ; i < n Patterns ; i ++ ) { X Path pattern = handler . create Match Pattern X Path ( tokenizer . next Token ( ) , owner ) ; patterns . add Element ( pattern ) ; } return patterns ; } catch ( Transformer Exception te ) { throw new org . xml . sax . SAX Exception ( te ) ; } }
protected ASN 1 Sequence ( ASN 1 Encodable [ ] array ) { for ( int i = NUM ; i != array . length ; i ++ ) { seq . add Element ( array [ i ] ) ; } }
public void add Copy ( I Resource copy , Copy Arguments arguments ) { if ( f Copy == null ) { f Copy = new Array List ( NUM ) ; f Copy Arguments = new Array List ( NUM ) ; } f Copy . add ( copy ) ; f Copy Arguments . add ( arguments ) ; add Copy Delta ( copy , arguments ) ; }
@ Override public void write ( byte [ ] buffer , int offset , int length ) throws IO Exception { while ( ( m Byte To Skip > NUM || m Byte To Copy > NUM || m State != STATE JPEG DATA ) && length > NUM ) { if ( m Byte To Skip > NUM ) { int byte To Process = length > m Byte To Skip ? m Byte To Skip : length ; length -= byte To Process ; m Byte To Skip -= byte To Process ; offset += byte To Process ; } if ( m Byte To Copy > NUM ) { int byte To Process = length > m Byte To Copy ? m Byte To Copy : length ; out . write ( buffer , offset , byte To Process ) ; length -= byte To Process ; m Byte To Copy -= byte To Process ; offset += byte To Process ; } if ( length == NUM ) { return ; } switch ( m State ) { case STATE SOI : int byte Read = request Byte To Buffer ( NUM , buffer , offset , length ) ; offset += byte Read ; length -= byte Read ; if ( m Buffer . position ( ) < NUM ) { return ; } m Buffer . rewind ( ) ; if ( m Buffer . get Short ( ) != Jpeg Header . SOI ) { throw new IO Exception ( STRING ) ; } out . write ( m Buffer . array ( ) , NUM , NUM ) ; m State = STATE FRAME HEADER ; m Buffer . rewind ( ) ; write Exif Data ( ) ; break ; case STATE FRAME HEADER : byte Read = request Byte To Buffer ( NUM , buffer , offset , length ) ; offset += byte Read ; length -= byte Read ; if ( m Buffer . position ( ) == NUM ) { short tag = m Buffer . get Short ( ) ; if ( tag == Jpeg Header . EOI ) { out . write ( m Buffer . array ( ) , NUM , NUM ) ; m Buffer . rewind ( ) ; } } if ( m Buffer . position ( ) < NUM ) { return ; } m Buffer . rewind ( ) ; short marker = m Buffer . get Short ( ) ; if ( marker == Jpeg Header . APP 1 ) { m Byte To Skip = ( m Buffer . get Short ( ) & NUM ) - NUM ; m State = STATE JPEG DATA ; } else if ( ! Jpeg Header . is Sof Marker ( marker ) ) { out . write ( m Buffer . array ( ) , NUM , NUM ) ; m Byte To Copy = ( m Buffer . get Short ( ) & NUM ) - NUM ; } else { out . write ( m Buffer . array ( ) , NUM , NUM ) ; m State = STATE JPEG DATA ; } m Buffer . rewind ( ) ; } } if ( length > NUM ) { out . write ( buffer , offset , length ) ; } }
protected boolean [ ] dataset Integrity ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing ) { print ( STRING ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( STRING ) ; int num Train = get Num Instances ( ) , num Classes = NUM , missing Level = NUM ; boolean [ ] result = new boolean [ NUM ] ; Instances train = null ; Instances train Copy = null ; AS Search search = null ; AS Evaluation evaluation = null ; try { train = make Test Dataset ( NUM , num Train , nominal Predictor ? get Num Nominal ( ) : NUM , numeric Predictor ? get Num Numeric ( ) : NUM , string Predictor ? get Num String ( ) : NUM , date Predictor ? get Num Date ( ) : NUM , relational Predictor ? get Num Relational ( ) : NUM , num Classes , class Type , multi Instance ) ; if ( missing Level > NUM ) { add Missing ( train , missing Level , predictor Missing , class Missing ) ; } search = AS Search . make Copies ( get Search ( ) , NUM ) [ NUM ] ; evaluation = AS Evaluation . make Copies ( get Evaluator ( ) , NUM ) [ NUM ] ; train Copy = new Instances ( train ) ; } catch ( Exception ex ) { throw new Error ( STRING + ex . get Message ( ) ) ; } try { search ( search , evaluation , train Copy ) ; compare Datasets ( train , train Copy ) ; println ( STRING ) ; result [ NUM ] = BOOL ; } catch ( Exception ex ) { println ( STRING ) ; result [ NUM ] = BOOL ; if ( m Debug ) { println ( STRING ) ; print ( STRING ) ; println ( STRING + ex . get Message ( ) + STRING ) ; println ( STRING ) ; println ( STRING + train Copy . to String ( ) + STRING ) ; println ( STRING + train . to String ( ) + STRING ) ; } } return result ; }
public void insert trace ( Polyline p polyline , int p layer , int p half width , Net Nos List p net no arr , int p clearance class , Item Fix State p fixed state ) { Brd Tracep new trace = insert trace without cleaning ( p polyline , p layer , p half width , p net no arr , p clearance class , p fixed state ) ; if ( new trace == null ) return ; new trace . normalize ( changed area . get area ( p layer ) ) ; }
void send Transmit ( Multiplex Connection Info info , byte buf [ ] , int off , int len ) throws IO Exception { synchronized ( data Out ) { if ( alive && ! info . closed ) try { data Out . write Byte ( TRANSMIT ) ; data Out . write Short ( info . id ) ; data Out . write Int ( len ) ; data Out . write ( buf , off , len ) ; data Out . flush ( ) ; } catch ( IO Exception e ) { multiplex Log . log ( Log . BRIEF , STRING , e ) ; shut Down ( ) ; throw e ; } } }
public < T extends SQL Exception > T to Flat SQL Exception ( Class < T > type ) throws Class Cast Exception { return type . cast ( to Flat SQL Exception ( ) ) ; }
public void add Total Result Count Cookie ( Workbench Request req , Http Servlet Response resp , int value ) { add Cookie ( req , resp , STRING , String . value Of ( value ) ) ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
abstract void start Poll ( int fd , int events ) ;
private Rectangle integerise ( Rectangle 2 D rect ) { int x0 = ( int ) Math . ceil ( rect . get Min X ( ) ) ; int y0 = ( int ) Math . ceil ( rect . get Min Y ( ) ) ; int x1 = ( int ) Math . floor ( rect . get Max X ( ) ) ; int y1 = ( int ) Math . floor ( rect . get Max Y ( ) ) ; return new Rectangle ( x0 , y0 , ( x1 - x0 ) , ( y1 - y0 ) ) ; }
@ Override public void mouse Moved ( Mouse Event evt ) { delegate . mouse Moved ( evt ) ; }
protected void validate Config ( ) { A . not Null ( get Streamer ( ) , STRING ) ; A . not Null ( get Ignite ( ) , STRING ) ; A . not Null ( endpoint Url , STRING ) ; A . ensure ( get Single Tuple Extractor ( ) != null || get Multiple Tuple Extractor ( ) != null , STRING ) ; String follow Param = api Params . get ( SITE USER ID KEY ) ; A . ensure ( follow Param != null && follow Param . matches ( STRING ) , STRING ) ; }
public long [ ] select Zero ( long rank , long [ ] dest , final int offset , final int length ) { if ( length == NUM ) return dest ; long s = select Zero ( rank ) ; dest [ offset ] = s ; int curr = ( int ) ( s / Long . SIZE ) ; long window = ~ bits [ curr ] & - NUM << s ; window &= window - NUM ; for ( int i = NUM ; i < length ; i ++ ) { while ( window == NUM ) window = ~ bits [ ++ curr ] ; dest [ offset + i ] = curr * Long . SIZE + Long . number Of Trailing Zeros ( window ) ; window &= window - NUM ; } return dest ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return STRING FIELD ; case NUM : return SET FIELD ; case NUM : return LIST FIELD ; case NUM : return BINARY FIELD ; default : return null ; } }
public int size ( ) { synchronized ( children ) { return children . size ( ) ; } }
private String flatten Comment ( String string ) { String Buffer buffer = new String Buffer ( string . length ( ) + NUM ) ; boolean skip Adjacent Line Separator = BOOL ; for ( int i = NUM ; i < string . length ( ) ; i ++ ) { char c = string . char At ( i ) ; if ( c == STRING || c == STRING ) { if ( ! skip Adjacent Line Separator ) buffer . append ( Policy . bind ( STRING ) ) ; skip Adjacent Line Separator = BOOL ; } else { buffer . append ( c ) ; skip Adjacent Line Separator = BOOL ; } } return buffer . to String ( ) ; }
private boolean is Accelerating ( Sensor Event event ) { float ax = event . values [ NUM ] ; float ay = event . values [ NUM ] ; float az = event . values [ NUM ] ; final double magnitude = Math . sqrt ( ax * ax + ay * ay + az * az ) ; return magnitude > ACCELERATION THRESHOLD ; }
@ Override public byte [ ] read Byte Array ( String file Path , int length ) { File Channel file Channel = update Cache ( file Path ) ; Byte Buffer byte Bffer = read ( file Channel , length ) ; return byte Bffer . array ( ) ; }
public void pop Drag Entry ( int index ) { if ( is Index In Bound ( index ) ) { m Dragged Entry = m Drag Entries . get ( index ) ; m Dragged Entry Index = index ; m Drag Entered Entry Index = index ; mark Drop Area ( index ) ; } }
public void test load And Verify small quads Mode ( ) throws Exception { final String resource = STRING ; final Properties p = get Properties ( ) ; p . set Property ( Abstract Triple Store . Options . QUADS , STRING ) ; do Load And Verify Test ( resource , p ) ; }
public void add Email ( Email Entity email ) { emails . add ( email ) ; }
private static int manhattan Distance ( final int x1 , final int y1 , final int x2 , final int y2 ) { return Math . abs ( x1 - x2 ) + Math . abs ( y1 - y2 ) ; }
private static final boolean compare And Set Wait Status ( Node node , int expect , int update ) { return unsafe . compare And Swap Int ( node , wait Status Offset , expect , update ) ; }
public void put Grammar ( Schema Grammar grammar ) { if ( grammar . get Target Namespace ( ) == null ) f No NS Grammar = grammar ; else f Grammar Registry . put ( grammar . get Target Namespace ( ) , grammar ) ; }
public JSON Array opt JSON Array ( String key ) { Object o = opt ( key ) ; return o instanceof JSON Array ? ( JSON Array ) o : null ; }
private void status ( ) { ps . println ( STRING ) ; ps . println ( STRING ) ; ps . println ( STRING ) ; ps . println ( STRING ) ; write Keys With Prefix ( STRING , STRING ) ; }
@ Override public void chart Progress ( Chart Progress Event event ) { }
void push Import Source ( Source source From URI Resolver ) { m import Source Stack . push ( source From URI Resolver ) ; }
public static byte [ ] build Nal Unit ( byte [ ] data , int offset , int length ) { byte [ ] nal Unit = new byte [ length + NAL START CODE . length ] ; System . arraycopy ( NAL START CODE , NUM , nal Unit , NUM , NAL START CODE . length ) ; System . arraycopy ( data , offset , nal Unit , NAL START CODE . length , length ) ; return nal Unit ; }
protected void do Log Oob Message Outbound ( Message message ) { if ( rpc Logger != null ) { rpc Logger . log Oob Message ( client Info , server Info , message , System . current Time Millis ( ) ) ; } }
@ Override public void stop ( ) { Count Down Latch latch = stopped ; Thread old Thread = thread . get And Update ( null ) ; if ( old Thread != null && latch != null ) { try { latch . await ( NUM , Time Unit . SECONDS ) ; } catch ( Interrupted Exception e ) { Thread . interrupted ( ) ; } } }
@ Override public byte [ ] encode ( Buffered Image buffered Image ) throws IO Exception { Byte Array Output Stream output Stream = new Byte Array Output Stream ( ) ; encode ( buffered Image , output Stream ) ; return output Stream . to Byte Array ( ) ; }
private Json Parser Exception create Helpful Exception ( char first , char [ ] expected , int failure Position ) throws Json Parser Exception { String Builder error Token = new String Builder ( first + ( expected == null ? STRING : new String ( expected , NUM , failure Position ) ) ) ; while ( is Ascii Letter ( peek Char ( ) ) && error Token . length ( ) < NUM ) error Token . append ( ( char ) advance Char ( ) ) ; return create Parse Exception ( null , STRING + error Token + STRING + ( expected == null ? STRING : STRING + first + new String ( expected ) + STRING ) , BOOL ) ; }
public void test Constructor Bytes Positive 3 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM } ; byte r Bytes [ ] = { NUM , NUM , NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public static void i ( String tag , String s , Object ... args ) { if ( LOG . INFO >= LOGLEVEL ) Log . i ( tag , String . format ( s , args ) ) ; }
public void remove Lifecycle Listener ( Lifecycle Listener lifecycle Listener ) { lifecycle Listeners . remove ( lifecycle Listener ) ; }
private synchronized void init Registry ( boolean force ) throws Matlab Connection Exception { if ( registry == null || force ) { try { registry = Local Host RMI Helper . create Registry ( options . get Port ( ) ) ; } catch ( Exception e ) { try { registry = Local Host RMI Helper . get Registry ( options . get Port ( ) ) ; } catch ( Exception ex ) { throw new Matlab Connection Exception ( STRING , ex ) ; } } } }
public boolean phase Has Turns ( I Game . Phase this Phase ) { switch ( this Phase ) { case PHASE SET ARTYAUTOHITHEXES : case PHASE DEPLOY MINEFIELDS : case PHASE DEPLOYMENT : case PHASE MOVEMENT : case PHASE FIRING : case PHASE PHYSICAL : case PHASE TARGETING : case PHASE OFFBOARD : return BOOL ; default : return BOOL ; } }
public int read ( ) throws IO Exception { int ch 1 = is . read ( ) ; int ch 2 = is . read ( ) ; if ( ch 2 < NUM ) return - NUM ; return ( ch 2 << NUM ) + ch 1 ; }
public static boolean is Url ( String resource Location ) { if ( resource Location == null ) { return BOOL ; } if ( resource Location . starts With ( CLASSPATH URL PREFIX ) ) { return BOOL ; } try { new URL ( resource Location ) ; return BOOL ; } catch ( Malformed URL Exception ex ) { return BOOL ; } }
public static String encode URL ( String uri ) { Char Buffer cb = Char Buffer . allocate ( ) ; for ( int i = NUM ; i < uri . length ( ) ; i ++ ) { char ch = uri . char At ( i ) ; switch ( ch ) { case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : cb . append ( STRING ) ; cb . append ( encode Hex ( ch > > NUM ) ) ; cb . append ( encode Hex ( ch ) ) ; break ; default : cb . append ( ch ) ; } } return cb . close ( ) ; }
public void close ( ) throws IO Exception { if ( closed ) { return ; } if ( queued For Cleanup ) { return ; } try { if ( expected > count ) { long nskip = expected - count ; if ( nskip <= available ( ) ) { do { } while ( ( nskip = ( expected - count ) ) > NUM && skip ( Math . min ( nskip , available ( ) ) ) > NUM ) ; } else if ( expected <= Keep Alive Stream Cleaner . MAX DATA REMAINING && ! hurried ) { queue For Cleanup ( new Keep Alive Cleaner Entry ( this , hc ) ) ; } else { hc . close Server ( ) ; } } if ( ! closed && ! hurried && ! queued For Cleanup ) { hc . finished ( ) ; } } finally { if ( pi != null ) pi . finish Tracking ( ) ; if ( ! queued For Cleanup ) { in = null ; hc = null ; closed = BOOL ; } } }
public boolean is Public ( ) { return Modifier . is Public ( method . get Modifiers ( ) ) ; }
private Object [ ] initialize Caller Hierarchy Roots ( Map < String , Map < String , Set < Json Element > > > caller Map ) { List < Tree Element < Source Method Node , Source Method Node > > roots = new Array List < Tree Element < Source Method Node , Source Method Node > > ( ) ; Caller Hierarchy caller Hierarchy = ( Caller Hierarchy ) f Input ; Source Method Node root Node = caller Hierarchy . get Root ( ) ; Set < Source Method Node > processed Nodes = new Hash Set < Source Method Node > ( ) ; Tree Element < Source Method Node , Source Method Node > root = initialize Caller Hierarchy ( root Node , processed Nodes , caller Map ) ; return new Object [ ] { root } ; }
private List < Entry > reduce With Douglas Peuker ( List < Entry > entries , double epsilon ) { if ( epsilon <= NUM || entries . size ( ) < NUM ) { return entries ; } keep [ NUM ] = BOOL ; keep [ entries . size ( ) - NUM ] = BOOL ; algorithm Douglas Peucker ( entries , epsilon , NUM , entries . size ( ) - NUM ) ; List < Entry > reduced Entries = new Array List < Entry > ( ) ; for ( int i = NUM ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { Entry cur Entry = entries . get ( i ) ; reduced Entries . add ( new Entry ( cur Entry . get Val ( ) , cur Entry . get X Index ( ) ) ) ; } } return reduced Entries ; }
public static double [ ] compute Log Amplitude Spectrum ( final double [ ] signal ) { double [ ] spectrum = compute Amplitude Spectrum ( signal ) ; for ( int i = NUM ; i < spectrum . length ; i ++ ) { spectrum [ i ] = Math . log ( spectrum [ i ] ) ; } return spectrum ; }
private Segment create Memory Segment ( Segment Descriptor descriptor ) { File segment File = Segment File . create Segment File ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ; Buffer buffer = Heap Buffer . allocate ( Math . min ( DEFAULT BUFFER SIZE , descriptor . max Segment Size ( ) ) , Integer . MAX VALUE ) ; descriptor . copy To ( buffer ) ; Segment segment = new Segment ( new Segment File ( segment File ) , buffer . slice ( ) , descriptor , create Index ( descriptor ) , new Offset Predicate ( ) , serializer . clone ( ) , this ) ; LOGGER . debug ( STRING , segment ) ; return segment ; }
public static void init ( final Async Context context ) { final Security Context security = ( Security Context ) context . get Attribute ( Async Context . SECURITY CTX ) ; final boolean force Set Security = force Set Security Context ( context ) ; if ( force Set Security ) { Security Context Holder . set Context ( security ) ; } ctx . set ( context ) ; }
private void cancel Previous Web Rtc Notifications ( ) { Set < String > notification Ids = m Shared Preferences . get String Set ( WEBRTC NOTIFICATION IDS , null ) ; if ( notification Ids == null ) return ; Iterator < String > iterator = notification Ids . iterator ( ) ; while ( iterator . has Next ( ) ) { m Notification Manager . cancel ( NOTIFICATION NAMESPACE , Integer . parse Int ( iterator . next ( ) ) ) ; } Shared Preferences . Editor shared Preference Editor = m Shared Preferences . edit ( ) ; shared Preference Editor . remove ( Media Capture Notification Service . WEBRTC NOTIFICATION IDS ) ; shared Preference Editor . apply ( ) ; }
public static final String read String ( byte [ ] bytes , int offset , int length , String charset ) throws IO Exception { return read String ( bytes , NUM , bytes . length , Charset . for Name ( charset ) ) ; }
private Topology Updater Thread ( ) { super ( id + STRING ) ; }
private void type Parameters Rest ( List < ? extends Type Parameter Tree > type Parameters , Indent plus Indent ) { builder . open ( plus Indent ) ; builder . break Op ( ) ; builder . open ( ZERO ) ; boolean first = BOOL ; for ( Type Parameter Tree type Parameter : type Parameters ) { if ( ! first ) { token ( STRING ) ; builder . break Op ( STRING ) ; } scan ( type Parameter , null ) ; first = BOOL ; } token ( STRING ) ; builder . close ( ) ; builder . close ( ) ; }
public void write String ( String str ) throws IO Exception { if ( str == null ) write Int ( NUM ) ; else { if ( use Compression && str . length ( ) >= Compressor . MIN SIZE FOR DEFLATION ) { byte [ ] bytes = compressor . deflate String 2 Byte Array ( str ) ; write Int ( - bytes . length ) ; outs . write ( bytes , NUM , bytes . length ) ; position += bytes . length ; } else { byte [ ] bytes = str . get Bytes ( STRING ) ; write Int ( bytes . length ) ; outs . write ( bytes , NUM , bytes . length ) ; position += bytes . length ; } } }
public void dequeue Sound ( Uri uri ) { m Audio Queue . remove ( new Audio Queue Item ( uri , null ) ) ; }
public void remove Bookmark ( final C Bookmark bookmark ) { Preconditions . check Not Null ( bookmark , STRING ) ; Preconditions . check Argument ( m bookmarks . remove ( bookmark ) , STRING ) ; for ( final I Bookmark Manager Listener listener : m listeners ) { try { listener . removed Bookmark ( this , bookmark ) ; } catch ( final Exception exception ) { C Utility Functions . log Exception ( exception ) ; } } }
public static Key Store load Key Store ( String type , File file , char [ ] password ) throws Exception { Key Store key Store = Key Store . get Instance ( type ) ; try ( File Input Stream fis = new File Input Stream ( file ) ) { key Store . load ( fis , password ) ; } return key Store ; }
public void loop ( double ellapsed Millis ) { for ( Spring System Listener listener : m Listeners ) { listener . on Before Integrate ( this ) ; } advance ( ellapsed Millis ) ; if ( m Active Springs . is Empty ( ) ) { m Idle = BOOL ; } for ( Spring System Listener listener : m Listeners ) { listener . on After Integrate ( this ) ; } if ( m Idle ) { m Spring Looper . stop ( ) ; } }
private void update Recording Track ( Track track , long last Track Point Id , boolean increase Number Of Points ) { if ( last Track Point Id >= NUM ) { if ( track . get Start Id ( ) < NUM ) { track . set Start Id ( last Track Point Id ) ; } track . set Stop Id ( last Track Point Id ) ; } if ( increase Number Of Points ) { track . set Number Of Points ( track . get Number Of Points ( ) + NUM ) ; } track Trip Statistics Updater . update Time ( System . current Time Millis ( ) ) ; track . set Trip Statistics ( track Trip Statistics Updater . get Trip Statistics ( ) ) ; my Tracks Provider Utils . update Track ( track ) ; }
@ Override public void request Startup Updates ( String from , byte [ ] table Key , int pod Index , long delta Time , Result < Boolean > cont ) { if ( log . is Loggable ( Level . FINEST ) ) { log . finest ( STRING + from + STRING + pod Index + STRING + delta Time ) ; } long access Time = Current Time . current Time ( ) + delta Time ; Table Pod table Pod = client Kraken . get Table ( table Key ) ; if ( table Pod == null ) { if ( log . is Loggable ( Level . FINEST ) ) { log . finest ( L . l ( STRING , Hex . to Short Hex ( table Key ) , Bartender System . get Current Self Server ( ) ) ) ; } cont . ok ( BOOL ) ; return ; } table Pod . get Updates From Local ( pod Index , access Time , cont ) ; }
private void refresh Mute Video Button ( ) { if ( ( null != m Call ) && m Call . is Video ( ) ) { m Mute Local Camera View . set Visibility ( View . VISIBLE ) ; boolean is Muted = m Call . is Video Recording Muted ( ) ; Log . d ( LOG TAG , STRING + is Muted ) ; int icon Id = is Muted ? R . drawable . ic material videocam off pink red : R . drawable . ic material videocam off grey ; m Mute Local Camera View . set Image Resource ( icon Id ) ; } else { Log . d ( LOG TAG , STRING ) ; m Mute Local Camera View . set Visibility ( View . INVISIBLE ) ; } }
public boolean is Auto Update Trl ( String Table Name ) { if ( super . is Multi Lingual Document ( ) ) return BOOL ; if ( Table Name == null ) return BOOL ; if ( Table Name . starts With ( STRING ) && get AD Client ID ( ) == NUM ) return BOOL ; return BOOL ; }
private void create Preference Controls ( Composite parent , Set < Preference Id > preference Set , Input Definition input Definition ) { for ( Preference Id preference Id Enum : preference Set ) { I Preference Control preference Control = Preference Control Factory . create Preference Controls ( parent , toolkit , preference Id Enum , this , input Definition ) ; if ( null != preference Control ) { preference Control List . add ( preference Control ) ; } } }
@ Request Mapping ( value = STRING , method = POST , produces = APPLICATION JSON VALUE ) public Response Entity < Page Response < Project DTO > > find All ( @ Request Body Page Request By Example < Project DTO > prbe ) throws URI Syntax Exception { Page Response < Project DTO > page Response = project DTO Service . find All ( prbe ) ; return new Response Entity < > ( page Response , new Http Headers ( ) , Http Status . OK ) ; }
public void test SHA Provider ( ) { Message Digest md = null ; try { md = Message Digest . get Instance ( STRING ) ; } catch ( No Such Algorithm Exception e ) { fail ( STRING + e ) ; } byte [ ] bytes = new byte [ ] { NUM , NUM , NUM , NUM , NUM } ; try { md . update ( bytes , - NUM , NUM ) ; fail ( STRING ) ; } catch ( Index Out Of Bounds Exception e ) { } try { md . update ( bytes , NUM , - NUM ) ; fail ( STRING ) ; } catch ( Index Out Of Bounds Exception e ) { } try { md = Message Digest . get Instance ( STRING ) ; } catch ( No Such Algorithm Exception e ) { fail ( STRING + e ) ; } try { md . digest ( bytes , NUM , - NUM ) ; fail ( STRING ) ; } catch ( Digest Exception e ) { } try { md . digest ( bytes , - NUM , NUM ) ; fail ( STRING ) ; } catch ( Digest Exception e ) { } try { md = Message Digest . get Instance ( STRING ) ; fail ( STRING ) ; } catch ( No Such Algorithm Exception e ) { } }
static private double fac 2 ( int j ) { long i = j ; if ( j < NUM ) i = Math . abs ( j ) ; double d = NUM ; while ( i > NUM ) d *= i -- ; if ( j < NUM ) return - d ; else return d ; }
private static boolean is Input Exhausted ( Stream Tokenizer input ) throws Parse Error { try { if ( input . next Token ( ) == Stream Tokenizer . TT EOF ) { return BOOL ; } input . push Back ( ) ; return BOOL ; } catch ( IO Exception e ) { throw new Parse Error ( e . get Message ( ) ) ; } }
public void clear ( ) { m . clear ( ) ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
public static void write Unsafe ( Packet Output Stream out , Input Stream is , long length , boolean no Backslash Escapes ) throws IO Exception { out . write Unsafe ( QUOTE ) ; byte [ ] buffer = new byte [ NUM ] ; long bytes Left = length ; int len ; for ( ; ; ) { int bytes To Read = ( int ) Math . min ( bytes Left , buffer . length ) ; if ( bytes To Read == NUM ) { break ; } len = is . read ( buffer , NUM , bytes To Read ) ; if ( len <= NUM ) { break ; } write Bytes Escaped Unsafe ( out , buffer , len , no Backslash Escapes ) ; bytes Left -= len ; } out . write Unsafe ( QUOTE ) ; }
public SQL Query ( Class < T > type , String sql Expression , Query Result Type query Result Type ) { this ( sql Expression , type . get Name ( ) , null , query Result Type , null ) ; }
public Builder retry ( long duration , Time Unit time Unit ) { this . retry = time Unit . to Seconds ( duration ) ; return this ; }
private Record Buffer < R > try Take ( long elapsed Waiting ) { Record Buffer < R > result = null ; if ( ! retry Queue . is Empty ( ) ) { result = retry Queue . poll ( ) ; } else { result = never Pub Queue . poll ( ) ; } if ( result != null ) { return on Take Success ( result , elapsed Waiting ) ; } else if ( elapsed Waiting > NUM ) { return on Take Timeout ( elapsed Waiting ) ; } else return null ; }
public void test Constructor Bytes Negative 1 ( ) { byte a Bytes [ ] = { - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , a Number . signum ( ) ) ; }
private < T > List < T > to Sorted List ( T [ ] array , Comparator < T > comparator ) { List < T > list = new Array List < > ( ) ; Collections . add All ( list , array ) ; Collections . sort ( list , comparator ) ; return list ; }
private Geo Mark reverse geocode ( final String text ) { for ( String t : text . split ( STRING ) ) { if ( t . length ( ) < NUM ) continue ; String [ ] c = t . split ( STRING ) ; if ( c . length != NUM ) continue ; try { double lat = Double . parse Double ( c [ NUM ] ) ; double lon = Double . parse Double ( c [ NUM ] ) ; Geo Mark mark = city Near ( lat , lon ) ; if ( mark == null ) continue ; return mark ; } catch ( Number Format Exception e ) { continue ; } } return null ; }
public Array List < Pla Touple Int > entrance points ( Polyline p polyline ) { Array List < Pla Touple Int > result = new Array List < Pla Touple Int > ( NUM * p polyline . plaline len ( ) ) ; int prev intersection line no = - NUM ; int prev intersection edge no = - NUM ; for ( int line no = NUM ; line no < p polyline . plaline len ( - NUM ) ; ++ line no ) { Pla Segment Int curr line seg = p polyline . segment get ( line no ) ; int [ ] curr intersections = curr line seg . border intersections ( this ) ; for ( int index = NUM ; index < curr intersections . length ; ++ index ) { int edge no = curr intersections [ index ] ; if ( line no != prev intersection line no || edge no != prev intersection edge no ) { result . add ( new Pla Touple Int ( line no , edge no ) ) ; prev intersection line no = line no ; prev intersection edge no = edge no ; } } } return result ; }
private void emit Clear ( String field Name , String Builder builder ) { builder . append ( STRING ) ; builder . append ( get Clear Name ( field Name ) ) ; builder . append ( STRING ) ; builder . append ( get Ensure Name ( field Name ) ) ; builder . append ( STRING ) ; builder . append ( field Name ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; }
public static byte [ ] serialize As Byte Array ( Object b ) throws IO Exception { Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; Object Output Stream out = new Object Output Stream ( bos ) ; try { out . write Object ( b ) ; } finally { out . close ( ) ; } return bos . to Byte Array ( ) ; }
public static void put Int LE ( long addr , int val ) { if ( UNALIGNED ) UNSAFE . put Int ( addr , Integer . reverse Bytes ( val ) ) ; else put Int By Byte ( addr , val , BOOL ) ; }
public Floating Action Button create Sub FAB ( char icon , String text ) { Floating Action Button sub = new Floating Action Button ( icon , text , NUM ) ; if ( sub Menu == null ) { sub Menu = new Array List < Floating Action Button > ( ) ; } sub Menu . add ( sub ) ; return sub ; }
public String read Value ( Input Node from ) throws Exception { if ( ! stack . is Relevant ( from ) ) { return null ; } int length = text . length ( ) ; if ( length <= NUM ) { Event Node event = reader . peek ( ) ; if ( event . is End ( ) ) { if ( stack . top ( ) == from ) { return null ; } else { stack . pop ( ) ; } event = reader . next ( ) ; } } return read Text ( from ) ; }
private void fit Image To View ( ) { Drawable drawable = get Drawable ( ) ; if ( drawable == null || drawable . get Intrinsic Width ( ) == NUM || drawable . get Intrinsic Height ( ) == NUM ) { return ; } if ( matrix == null || prev Matrix == null ) { return ; } int drawable Width = drawable . get Intrinsic Width ( ) ; int drawable Height = drawable . get Intrinsic Height ( ) ; float scale X = ( float ) view Width / drawable Width ; float scale Y = ( float ) view Height / drawable Height ; switch ( m Scale Type ) { case CENTER : scale X = scale Y = NUM ; break ; case CENTER CROP : scale X = scale Y = Math . max ( scale X , scale Y ) ; break ; case CENTER INSIDE : scale X = scale Y = Math . min ( NUM , Math . min ( scale X , scale Y ) ) ; case FIT CENTER : scale X = scale Y = Math . min ( scale X , scale Y ) ; break ; case FIT XY : break ; default : throw new Unsupported Operation Exception ( STRING ) ; } float redundant X Space = view Width - ( scale X * drawable Width ) ; float redundant Y Space = view Height - ( scale Y * drawable Height ) ; match View Width = view Width - redundant X Space ; match View Height = view Height - redundant Y Space ; if ( ! is Zoomed ( ) && ! image Rendered At Least Once ) { matrix . set Scale ( scale X , scale Y ) ; matrix . post Translate ( redundant X Space / NUM , redundant Y Space / NUM ) ; normalized Scale = NUM ; } else { if ( prev Match View Width == NUM || prev Match View Height == NUM ) { save Previous Image Values ( ) ; } prev Matrix . get Values ( m ) ; m [ Matrix . MSCALE X ] = match View Width / drawable Width * normalized Scale ; m [ Matrix . MSCALE Y ] = match View Height / drawable Height * normalized Scale ; float trans X = m [ Matrix . MTRANS X ] ; float trans Y = m [ Matrix . MTRANS Y ] ; float prev Actual Width = prev Match View Width * normalized Scale ; float actual Width = get Image Width ( ) ; translate Matrix After Rotate ( Matrix . MTRANS X , trans X , prev Actual Width , actual Width , prev View Width , view Width , drawable Width ) ; float prev Actual Height = prev Match View Height * normalized Scale ; float actual Height = get Image Height ( ) ; translate Matrix After Rotate ( Matrix . MTRANS Y , trans Y , prev Actual Height , actual Height , prev View Height , view Height , drawable Height ) ; matrix . set Values ( m ) ; } fix Trans ( ) ; set Image Matrix ( matrix ) ; }
private void dispatch On Third Party Registered ( ) { synchronized ( this ) { for ( Third Party Registration Listener listener : m Third Party Registration Listeners ) { try { listener . on Third Party Registered ( ) ; } catch ( Exception e ) { Log . e ( LOG TAG , STRING + e . get Localized Message ( ) ) ; } } m Third Party Registration Listeners . clear ( ) ; } }
void update For Decoder Type ID ( List < Decoder File > p List ) { decoder Box . set Model ( Decoder Index File . j Combo Box Model From List ( p List ) ) ; decoder Box . insert Item At ( STRING , NUM ) ; decoder Box . set Selected Index ( NUM ) ; }
@ Override public void action Performed ( Action Event event ) { switch ( event . get Action Command ( ) ) { case NEW ALIAS : add Alias ( new Alias ( STRING ) ) ; break ; case COPY ALIAS : for ( Alias alias : get Selected Aliases ( ) ) { add Alias ( Alias Factory . copy Of ( alias ) ) ; } break ; case DELETE ALIAS : List < Alias > to Delete = get Selected Aliases ( ) ; if ( to Delete != null && ! to Delete . is Empty ( ) ) { String title = to Delete . size ( ) == NUM ? STRING : STRING ; String prompt = to Delete . size ( ) == NUM ? STRING : STRING + to Delete . size ( ) + STRING ; int choice = J Option Pane . show Confirm Dialog ( Alias Controller . this , prompt , title , J Option Pane . YES NO OPTION , J Option Pane . WARNING MESSAGE ) ; if ( choice == J Option Pane . YES OPTION ) { for ( Alias alias : to Delete ) { m Alias Model . remove Alias ( alias ) ; } } } break ; default : break ; } }
public boolean direction Key Is Pressed ( ) { return pressed State Keys . contains ( Key Event . VK UP ) || pressed State Keys . contains ( Key Event . VK DOWN ) || pressed State Keys . contains ( Key Event . VK LEFT ) || pressed State Keys . contains ( Key Event . VK RIGHT ) || pressed State Keys . contains ( Key Event . VK KP LEFT ) || pressed State Keys . contains ( Key Event . VK KP RIGHT ) || pressed State Keys . contains ( Key Event . VK KP UP ) || pressed State Keys . contains ( Key Event . VK KP DOWN ) ; }
private void calculate Calibration ( long difference , float current Measure , byte current Index ) { if ( difference >= Medtronic Constants . TIME 15 MIN IN MS && difference < Medtronic Constants . TIME 20 MIN IN MS ) { if ( is Sensor Measure In Range ( current Index , expected Sensor Sort Number For Calibration ) ) { is Calibrating = BOOL ; calibration Status = Medtronic Constants . CALIBRATED ; calibration Isig Value = current Measure ; Shared Preferences . Editor editor = settings . edit ( ) ; calibration Factor = last Glucometer Value / calibration Isig Value ; editor . remove ( STRING ) ; editor . remove ( STRING ) ; editor . put Float ( STRING , ( float ) calibration Factor ) ; editor . put Int ( STRING , calibration Status ) ; editor . commit ( ) ; } else { if ( calibration Status != Medtronic Constants . WITHOUT ANY CALIBRATION && current Index != expected Sensor Sort Number ) { calibration Status = Medtronic Constants . LAST CALIBRATION FAILED USING PREVIOUS ; is Calibrating = BOOL ; } else { calibration Status = Medtronic Constants . WITHOUT ANY CALIBRATION ; } Shared Preferences . Editor editor = settings . edit ( ) ; editor . remove ( STRING ) ; editor . remove ( STRING ) ; editor . commit ( ) ; } } else if ( difference >= Medtronic Constants . TIME 20 MIN IN MS ) { if ( is Sensor Measure In Range ( current Index , expected Sensor Sort Number For Calibration ) ) { calibration Status = Medtronic Constants . CALIBRATED IN 15 MIN ; calibration Isig Value = current Measure ; Shared Preferences . Editor editor = settings . edit ( ) ; calibration Factor = last Glucometer Value / calibration Isig Value ; editor . remove ( STRING ) ; editor . remove ( STRING ) ; editor . put Float ( STRING , ( float ) calibration Factor ) ; editor . put Int ( STRING , calibration Status ) ; editor . commit ( ) ; } else { if ( calibration Status != Medtronic Constants . WITHOUT ANY CALIBRATION ) calibration Status = Medtronic Constants . LAST CALIBRATION FAILED USING PREVIOUS ; else { calibration Status = Medtronic Constants . WITHOUT ANY CALIBRATION ; } Shared Preferences . Editor editor = settings . edit ( ) ; editor . remove ( STRING ) ; editor . remove ( STRING ) ; editor . commit ( ) ; } is Calibrating = BOOL ; } else { if ( is Calibrating ) { if ( difference < Medtronic Constants . TIME 5 MIN IN MS ) { calibration Status = Medtronic Constants . CALIBRATING ; } else if ( difference >= Medtronic Constants . TIME 5 MIN IN MS && difference <= Medtronic Constants . TIME 15 MIN IN MS ) calibration Status = Medtronic Constants . CALIBRATING 2 ; else calibration Status = Medtronic Constants . CALIBRATING ; } else { if ( calibration Status != Medtronic Constants . WITHOUT ANY CALIBRATION ) calibration Status = Medtronic Constants . LAST CALIBRATION FAILED USING PREVIOUS ; else { calibration Status = Medtronic Constants . WITHOUT ANY CALIBRATION ; } Shared Preferences . Editor editor = settings . edit ( ) ; editor . remove ( STRING ) ; editor . remove ( STRING ) ; editor . put Int ( STRING , calibration Status ) ; editor . commit ( ) ; } } }
public void add Position ( int offset , int length , String ... ids ) { Text Attribute highlighting = ids . length == NUM ? attribute Provider . get Attribute ( ids [ NUM ] ) : attribute Provider . get Merged Attributes ( ids ) ; boolean is Existing = BOOL ; for ( int i = NUM , n = removed Positions . size ( ) ; i < n ; i ++ ) { Attributed Position position = removed Positions . get ( i ) ; if ( position == null ) continue ; if ( position . is Equal ( offset , length , highlighting ) ) { is Existing = BOOL ; removed Positions . set ( i , null ) ; removed Position Count -- ; break ; } } if ( ! is Existing ) { Attributed Position position = presenter . create Highlighted Position ( offset , length , highlighting ) ; added Positions . add ( position ) ; } }
static void export Mask Update ( Export Mask export Mask , Map < URI , Integer > volume Map , List < Initiator > initiators , List < URI > targets ) { if ( volume Map != null ) { for ( URI volume : volume Map . key Set ( ) ) { export Mask . add Volume ( volume , volume Map . get ( volume ) ) ; } } if ( initiators != null ) { for ( Initiator initiator : initiators ) { export Mask . add Initiator ( initiator ) ; } } if ( targets != null ) { for ( URI target : targets ) { export Mask . add Target ( target ) ; } } }
private void internal Add Head ( final Message Reference ref ) { queue Memory Size . add And Get ( ref . get Message Memory Estimate ( ) ) ; ref Added ( ref ) ; int priority = get Priority ( ref ) ; message References . add Head ( ref , priority ) ; }
private boolean create New ( M Product product , M Acct Schema as ) { M Cost dimension = M Cost . get Or Create ( product , NUM , as , NUM , NUM , as . get M Cost Type ID ( ) , m ce . get M Cost Element ID ( ) ) ; if ( dimension . is new ( ) ) return dimension . save ( ) ; return BOOL ; }
@ Override protected void step ( ) { while ( iter . has Next ( ) ) { reg = ( Svc Reg ) iter . next ( ) ; if ( reg . lease Expiration > now ) return ; } reg = null ; }
public Enumeration < String > packages ( ) { return m Cache . keys ( ) ; }
protected int size ( ) { return document . length ( ) ; }
public TPS current Row ( ) { return current Row ( null ) ; }
public final void delete All Entries ( ) { if ( num Entries > NUM ) { Arrays . fill ( entries , null ) ; this . num Entries = NUM ; } }
public List < Map < String , Object > > query ( final String index Name , final String q , final Operator operator , final int offset , final int count ) { assert count > NUM ; Search Request Builder request = elasticsearch Client . prepare Search ( index Name ) . set Query ( Query Builders . multi Match Query ( q , STRING ) . operator ( operator ) . zero Terms Query ( Zero Terms Query . ALL ) ) . set From ( offset ) . set Size ( count ) ; Search Response response = request . execute ( ) . action Get ( ) ; Search Hit [ ] hits = response . get Hits ( ) . get Hits ( ) ; Array List < Map < String , Object > > result = new Array List < Map < String , Object > > ( ) ; for ( Search Hit hit : hits ) { Map < String , Object > map = hit . get Source ( ) ; result . add ( map ) ; } return result ; }
public Sorted Set < String > plugins ( ) { Sorted Set < String > r = new Tree Set < > ( ) ; for ( Name Pair p : items . key Set ( ) ) { r . add ( p . plugin Name ) ; } return Collections . unmodifiable Sorted Set ( r ) ; }
public static void error ( int Window No , Container c , String AD Message ) { error ( Window No , c , AD Message , null ) ; }
public Reil Function translate ( final I Translation Environment environment , final I Block Container < Instruction Type > function ) throws Internal Translation Exception { return translate ( environment , function , new Array List < I Translation Extension < Instruction Type > > ( ) ) ; }
public Name parse ( String name ) throws Naming Exception { Vector < String > comps = ins String To Stringified Comps ( name ) ; return new CN Compound Name ( comps . elements ( ) ) ; }
public CSV Data Source Factory ( ) { super ( STRING , CSV MIME TYPES , CSV FILE ENDINGS , CSV Format Specification Wizard Step . CSV FORMAT SPECIFICATION STEP ID ) ; }
private void send Ack ( String index , String message , Guacamole Status status ) { if ( status != Guacamole Status . SUCCESS ) close Intercepted Stream ( index ) ; send Instruction ( new Guacamole Instruction ( STRING , index , message , Integer . to String ( status . get Guacamole Status Code ( ) ) ) ) ; }
public static boolean is Windows Platform ( ) { String os = System . get Property ( STRING ) ; return ( os != null && os . starts With ( WIN ID ) ) ; }
static public int count Ranges That Collide Zone ( List < Bounds > ranges , List < Bounds > zone Ranges ) { int overall EOAA = NUM ; Collections . sort ( zone Ranges ) ; for ( Bounds extracted Bounds : ranges ) { for ( Bounds expected Bounds : zone Ranges ) { if ( expected Bounds . start >= extracted Bounds . end ) { break ; } if ( extracted Bounds . overlaps ( expected Bounds ) ) { overall EOAA ++ ; break ; } } } return overall EOAA ; }
public static boolean time Stamp Changed ( String location ) { synchronized ( install Lock ) { if ( fg Has Changed . contains ( location ) ) { return BOOL ; } File file = new File ( location ) ; if ( file . exists ( ) ) { if ( fg Install Time Map == null ) { read Install Info ( ) ; } Long stamp = fg Install Time Map . get ( location ) ; long fstamp = file . last Modified ( ) ; if ( stamp != null ) { if ( stamp . long Value ( ) == fstamp ) { return BOOL ; } } stamp = new Long ( fstamp ) ; fg Install Time Map . put ( location , stamp ) ; write Install Info ( ) ; fg Has Changed . add ( location ) ; return BOOL ; } } return BOOL ; }
public static Boolean [ ] values Of ( boolean [ ] array ) { Boolean [ ] dest = new Boolean [ array . length ] ; for ( int i = NUM ; i < array . length ; i ++ ) { dest [ i ] = Boolean . value Of ( array [ i ] ) ; } return dest ; }
public void add Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners == null ) { m Update Listeners = new Array List < Animator Update Listener > ( ) ; } m Update Listeners . add ( listener ) ; }
private void correct Too High ( int child Count ) { int last Position = m First Position + child Count - NUM ; if ( last Position == m Item Count - NUM && child Count > NUM ) { final int last Bottom = get Lowest Child Bottom ( ) ; final int end = ( get Bottom ( ) - get Top ( ) ) - get List Padding Bottom ( ) ; int bottom Offset = end - last Bottom ; final int first Top = get Highest Child Top ( ) ; if ( bottom Offset > NUM && ( m First Position > NUM || first Top < get List Padding Top ( ) ) ) { if ( m First Position == NUM ) { bottom Offset = Math . min ( bottom Offset , get List Padding Top ( ) - first Top ) ; } offset Children Top And Bottom ( bottom Offset ) ; if ( m First Position > NUM ) { int previous Position = m First Position - NUM ; fill Up ( previous Position , get Next Child Ups Bottom ( previous Position ) ) ; adjust Views Up Or Down ( ) ; } } } }
public static boolean write Line ( String file Name , String value ) { Buffered Writer writer = null ; try { writer = new Buffered Writer ( new File Writer ( file Name ) ) ; writer . write ( value ) ; } catch ( File Not Found Exception e ) { Log . w ( TAG , STRING + file Name + STRING , e ) ; return BOOL ; } catch ( IO Exception e ) { Log . e ( TAG , STRING + file Name , e ) ; return BOOL ; } finally { try { if ( writer != null ) { writer . close ( ) ; } } catch ( IO Exception e ) { } } return BOOL ; }
public void did Rollback ( ) { synchronized ( this ) { if ( pending != null ) { pending . cancel ( BOOL ) ; pending = null ; } docs Since Commit . set ( NUM ) ; } }
@ Override protected void calculate Thumb Location ( ) { super . calculate Thumb Location ( ) ; if ( slider . get Snap To Ticks ( ) ) { int upper Value = slider . get Value ( ) + slider . get Extent ( ) ; int snapped Value = upper Value ; int major Tick Spacing = slider . get Major Tick Spacing ( ) ; int minor Tick Spacing = slider . get Minor Tick Spacing ( ) ; int tick Spacing = NUM ; if ( minor Tick Spacing > NUM ) { tick Spacing = minor Tick Spacing ; } else if ( major Tick Spacing > NUM ) { tick Spacing = major Tick Spacing ; } if ( tick Spacing != NUM ) { if ( ( upper Value - slider . get Minimum ( ) ) % tick Spacing != NUM ) { float temp = ( float ) ( upper Value - slider . get Minimum ( ) ) / ( float ) tick Spacing ; int which Tick = Math . round ( temp ) ; snapped Value = slider . get Minimum ( ) + ( which Tick * tick Spacing ) ; } if ( snapped Value != upper Value ) { slider . set Extent ( snapped Value - slider . get Value ( ) ) ; } } } if ( slider . get Orientation ( ) == J Slider . HORIZONTAL ) { int upper Position = x Position For Value ( slider . get Value ( ) + slider . get Extent ( ) ) ; upper Thumb Rect . x = upper Position - ( upper Thumb Rect . width / NUM ) ; upper Thumb Rect . y = track Rect . y ; } else { int upper Position = y Position For Value ( slider . get Value ( ) + slider . get Extent ( ) ) ; upper Thumb Rect . x = track Rect . x ; upper Thumb Rect . y = upper Position - ( upper Thumb Rect . height / NUM ) ; } }
public void compile ( int through Phase ) throws Compilation Failed Exception { goto Phase ( Phases . INITIALIZATION ) ; through Phase = Math . min ( through Phase , Phases . ALL ) ; while ( through Phase >= phase && phase <= Phases . ALL ) { if ( phase == Phases . SEMANTIC ANALYSIS ) { do Phase Operation ( resolve ) ; if ( dequeued ( ) ) continue ; } process Phase Operations ( phase ) ; process New Phase Operations ( phase ) ; if ( progress Callback != null ) progress Callback . call ( this , phase ) ; complete Phase ( ) ; apply To Source Units ( mark ) ; if ( dequeued ( ) ) continue ; goto Phase ( phase + NUM ) ; if ( phase == Phases . CLASS GENERATION ) { sort Classes ( ) ; } } error Collector . fail If Errors ( ) ; }
public String generate Bearer Token ( String email , String username , Map < String , String > payload ) { String token = token Generator . generate ( ) ; Map < String , String > payload Copy = payload == null ? new Hash Map ( ) : new Hash Map ( payload ) ; payload Copy . put ( STRING , email ) ; payload Copy . put ( STRING , username ) ; payload Copy . put ( STRING , Long . to String ( System . current Time Millis ( ) ) ) ; token Map . put ( token , payload Copy ) ; return token ; }
public void end Document ( Augmentations augs ) throws XNI Exception { try { if ( f Document Handler != null ) { f Document Handler . end Document ( ) ; } if ( f Content Handler != null ) { f Content Handler . end Document ( ) ; } } catch ( SAX Exception e ) { throw new XNI Exception ( e ) ; } }
public final Connection State new Input ( ) throws IO Exception { if ( in . has Remaining ( ) ) { throw new Runtime Exception ( STRING ) ; } in . clear ( ) ; int r = ch . read ( in ) ; if ( r == - NUM ) throw new IO Exception ( STRING ) ; if ( r == NUM ) return Connection State . SELECTOR WAIT FOR NEW INPUT ; in . flip ( ) ; return new Request Chunk ( ) ; }
protected final void refresh Loading Views Size ( ) { final int maximum Pull Scroll = ( int ) ( get Maximum Pull Scroll ( ) * NUM ) ; int p Left = get Padding Left ( ) ; int p Top = get Padding Top ( ) ; int p Right = get Padding Right ( ) ; int p Bottom = get Padding Bottom ( ) ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Width ( maximum Pull Scroll ) ; p Left = - maximum Pull Scroll ; } else { p Left = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Width ( maximum Pull Scroll ) ; p Right = - maximum Pull Scroll ; } else { p Right = NUM ; } break ; case VERTICAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Height ( maximum Pull Scroll ) ; p Top = - maximum Pull Scroll ; } else { p Top = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Height ( maximum Pull Scroll ) ; p Bottom = - maximum Pull Scroll ; } else { p Bottom = NUM ; } break ; } if ( DEBUG ) { Log . d ( LOG TAG , String . format ( STRING , p Left , p Top , p Right , p Bottom ) ) ; } set Padding ( p Left , p Top , p Right , p Bottom ) ; }
public boolean can Move Forward ( ) { return current Index >= NUM && current Index < ( history . size ( ) - NUM ) ; }
public void clear Cache ( ) { Disk Lru Cache . clear Cache ( m Cache Dir ) ; }
public void add Natural Join Column ( Column c ) { if ( natural Join Columns == null ) { natural Join Columns = New . array List ( ) ; } natural Join Columns . add ( c ) ; }
private Refactoring Status check Can Create Intermediary Method ( ) throws Java Model Exception { List < I Type Binding > parameter Bindings = new Array List < I Type Binding > ( ) ; if ( ! is Static Target ( ) ) parameter Bindings . add ( f Intermediary First Parameter Type ) ; parameter Bindings . add All ( Arrays . as List ( f Target Method Binding . get Parameter Types ( ) ) ) ; return Checks . check Method In Type ( f Intermediary Type Binding , f Intermediary Method Name , parameter Bindings . to Array ( new I Type Binding [ parameter Bindings . size ( ) ] ) ) ; }
@ Override public String generate Tool Tip ( XY Dataset data , int series , int item ) { return get Tool Tip Text ( series , item ) ; }
private Class < ? > find Class Non Dalvik ( String name ) throws Class Not Found Exception { String path Name = CLASS PATH + name + STRING ; File path = new File ( path Name ) ; Random Access File raf ; try { raf = new Random Access File ( path , STRING ) ; } catch ( File Not Found Exception fnfe ) { throw new Class Not Found Exception ( STRING + path Name ) ; } byte [ ] file Data ; try { file Data = new byte [ ( int ) raf . length ( ) ] ; raf . read Fully ( file Data ) ; } catch ( IO Exception ioe ) { throw new Class Not Found Exception ( STRING + path Name ) ; } finally { try { raf . close ( ) ; } catch ( IO Exception ioe ) { } } try { return define Class ( name , file Data , NUM , file Data . length ) ; } catch ( Throwable th ) { throw new Class Not Found Exception ( STRING , th ) ; } }
public static void load ( Class < ? > parent ) { load ( parent , Class Loader . get System Class Loader ( ) ) ; }
public void remove Change Listener ( Change Listener cl ) { listeners . remove ( cl ) ; }
@ Guarded By ( STRING ) void apply Read ( Node < K , V > node ) { if ( eviction Deque . contains ( node ) ) { eviction Deque . move To Back ( node ) ; } }
private void flush Write Chunk ( ) { if ( write Chunk == null ) return ; if ( write Chunk . position ( ) == NUM ) return ; if ( ! write Chunk . has Remaining ( ) ) { bytes Written += write Chunk . position ( ) ; write Chunk . flip ( ) ; list . add Last ( write Chunk ) ; write Chunk = null ; return ; } bytes Written += write Chunk . position ( ) ; Byte Buffer flush Chunk = write Chunk ; write Chunk = write Chunk . slice ( ) ; write Chunk . order ( order ) ; flush Chunk . flip ( ) ; list . add Last ( flush Chunk ) ; return ; }
public final double sin ( ) { return Math . sin ( this . radians ) ; }
public Axis Label Layout ( String group , int axis , Valued Range Model values ) { this ( group , axis , values , null ) ; }
public double angle ( I Moving Agent agent ) { return Geometric . angle ( this . location , agent . get Location ( ) ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL ; } if ( ! ( obj instanceof Default Drawing Supplier ) ) { return BOOL ; } Default Drawing Supplier that = ( Default Drawing Supplier ) obj ; if ( ! Arrays . equals ( this . paint Sequence , that . paint Sequence ) ) { return BOOL ; } if ( this . paint Index != that . paint Index ) { return BOOL ; } if ( ! Arrays . equals ( this . outline Paint Sequence , that . outline Paint Sequence ) ) { return BOOL ; } if ( this . outline Paint Index != that . outline Paint Index ) { return BOOL ; } if ( ! Arrays . equals ( this . stroke Sequence , that . stroke Sequence ) ) { return BOOL ; } if ( this . stroke Index != that . stroke Index ) { return BOOL ; } if ( ! Arrays . equals ( this . outline Stroke Sequence , that . outline Stroke Sequence ) ) { return BOOL ; } if ( this . outline Stroke Index != that . outline Stroke Index ) { return BOOL ; } if ( ! equal Shapes ( this . shape Sequence , that . shape Sequence ) ) { return BOOL ; } if ( this . shape Index != that . shape Index ) { return BOOL ; } return BOOL ; }
public static int brighter ( int c ) { int r = red ( c ) , g = green ( c ) , b = blue ( c ) ; int i = ( int ) ( NUM / ( NUM - scale ) ) ; if ( r == NUM && g == NUM && b == NUM ) { return rgba ( i , i , i , alpha ( c ) ) ; } if ( r > NUM && r < i ) r = i ; if ( g > NUM && g < i ) g = i ; if ( b > NUM && b < i ) b = i ; return rgba ( Math . min ( NUM , ( int ) ( r / scale ) ) , Math . min ( NUM , ( int ) ( g / scale ) ) , Math . min ( NUM , ( int ) ( b / scale ) ) , alpha ( c ) ) ; }
public void add Property Change Listener ( String property Name , Property Change Listener in pcl ) { pc Support . add Property Change Listener ( property Name , in pcl ) ; }
@ Override protected void paint Component ( Graphics g ) { super . paint Component ( g ) ; Graphics 2 D g2 = ( Graphics 2 D ) g ; if ( should Draw ) { draw Display List On ( g2 ) ; } }
public void load ( Input Stream in ) throws IO Exception { properties . load ( in ) ; dirty = BOOL ; }
@ Override public void on Bind View Holder ( VH holder , int position ) { if ( list . get ( position ) . type == TYPE ITEM ) { on Bind Item View Holder ( holder , position ) ; } else if ( list . get ( position ) . type == TYPE HEADER ) { on Bind Header View Holder ( holder , position ) ; } }
public static Map < Component Wrapper , CC > parse Component Constraints ( Map < Component Wrapper , String > constr Map ) { Hash Map < Component Wrapper , CC > flow Constr Map = new Hash Map < Component Wrapper , CC > ( ) ; for ( Component Wrapper c : constr Map . key Set ( ) ) { flow Constr Map . put ( c , parse Component Constraint ( constr Map . get ( c ) ) ) ; } return flow Constr Map ; }
private void send Stage Progress Patch ( Task State state ) { Service Utils . log Info ( this , STRING , state . stage , state . sub Stage ) ; Task Utils . send Self Patch ( this , build Patch ( state . stage , state . sub Stage , null ) ) ; }
public void test Common Prefix ( ) { String returned = m Trie . get Common Prefix ( ) ; assert Equals ( STRING , NUM , returned . length ( ) ) ; String expected = STRING ; Trie t = build Trie ( new String [ ] { m Data [ NUM ] , m Data [ NUM ] } ) ; returned = t . get Common Prefix ( ) ; assert Equals ( STRING , expected . length ( ) , returned . length ( ) ) ; }
public String move Back ( ) { Check . is True ( current Index > NUM , STRING ) ; current Index -- ; return history . get ( current Index ) ; }
public static long hash 64 ( final String text ) { final byte [ ] bytes = text . get Bytes ( ) ; return hash 64 ( bytes , bytes . length ) ; }
public static void delete Core ( ) { log . info ( STRING ) ; if ( h != null ) { h . close ( ) ; } if ( factory Prop == null ) { System . clear Property ( STRING ) ; } solr Config = null ; h = null ; lrf = null ; config String = schema String = null ; }
public static boolean can Tab ( List constraints ) { for ( Iterator iter = constraints . iterator ( ) ; iter . has Next ( ) ; ) { Dock Constraint dc = ( Dock Constraint ) iter . next ( ) ; if ( ! dc . can Tab ( ) ) return BOOL ; } return BOOL ; }
public Imdn Parser parse ( ) throws Parser Configuration Exception , SAX Exception , Parse Failure Exception { try { SAX Parser Factory factory = SAX Parser Factory . new Instance ( ) ; SAX Parser parser = factory . new SAX Parser ( ) ; parser . parse ( m Input Source , this ) ; return this ; } catch ( IO Exception e ) { throw new Parse Failure Exception ( STRING , e ) ; } }
static boolean chunk Set ( Internal Distributed Member recipient , Set set , int CHUNK SIZE IN BYTES , boolean include Values , Object Int Procedure proc ) throws IO Exception { Iterator it = set . iterator ( ) ; boolean keep Going = BOOL ; boolean sent Last Chunk = BOOL ; final Heap Data Output Stream mos = new Heap Data Output Stream ( Initial Image Operation . CHUNK SIZE IN BYTES + NUM , recipient . get Version Object ( ) ) ; do { mos . reset ( ) ; int avg Item Size = NUM ; int item Count = NUM ; while ( ( mos . size ( ) + avg Item Size ) < Initial Image Operation . CHUNK SIZE IN BYTES && it . has Next ( ) ) { Object key = it . next ( ) ; Data Serializer . write Object ( key , mos ) ; item Count ++ ; avg Item Size = mos . size ( ) / item Count ; } Data Serializer . write Object ( ( Object ) null , mos ) ; int last Msg = it . has Next ( ) ? NUM : NUM ; keep Going = proc . execute With ( mos , last Msg ) ; sent Last Chunk = last Msg == NUM && keep Going ; } while ( keep Going && it . has Next ( ) ) ; return sent Last Chunk ; }
public static Big Integer to Big Integer ( final Ed 25519 Encoded Field Element encoded ) { return to Big Integer ( encoded . get Raw ( ) ) ; }
public String escape LDAP Search Filter ( String filter ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < filter . length ( ) ; i ++ ) { char cur Char = filter . char At ( i ) ; switch ( cur Char ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; default : sb . append ( cur Char ) ; } } return sb . to String ( ) ; }
protected synchronized void save ( ) { int ret Val ; File file ; String text ; File Writer fwriter ; Buffered Writer bwriter ; ret Val = m File Chooser . show Open Dialog ( this ) ; if ( ret Val != Meka File Chooser . APPROVE OPTION ) return ; file = m File Chooser . get Selected File ( ) ; text = m Text Area . get Text ( ) ; fwriter = null ; bwriter = null ; try { fwriter = new File Writer ( file ) ; bwriter = new Buffered Writer ( fwriter ) ; bwriter . write ( text ) ; bwriter . new Line ( ) ; bwriter . flush ( ) ; log ( STRING + file ) ; } catch ( Exception e ) { handle Exception ( STRING + file , e ) ; } finally { File Utils . close Quietly ( bwriter ) ; File Utils . close Quietly ( fwriter ) ; } }
public Eigenvalue Decomposition ( double [ ] [ ] A ) { n = A . length ; V = new double [ n ] [ n ] ; d = new double [ n ] ; e = new double [ n ] ; issymmetric = BOOL ; for ( int j = NUM ; ( j < n ) && issymmetric ; j ++ ) { for ( int i = NUM ; ( i < n ) && issymmetric ; i ++ ) { issymmetric = ( A [ i ] [ j ] == A [ j ] [ i ] ) ; if ( Double . is Na N ( A [ i ] [ j ] ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( Double . is Infinite ( A [ i ] [ j ] ) ) { throw new Illegal Argument Exception ( STRING ) ; } } } if ( issymmetric ) { for ( int i = NUM ; i < n ; i ++ ) { System . arraycopy ( A [ i ] , NUM , V [ i ] , NUM , n ) ; } tred 2 ( ) ; tql 2 ( ) ; } else { H = new double [ n ] [ n ] ; ort = new double [ n ] ; for ( int j = NUM ; j < n ; j ++ ) { for ( int i = NUM ; i < n ; i ++ ) { H [ i ] [ j ] = A [ i ] [ j ] ; } } orthes ( ) ; hqr 2 ( ) ; } }
public Search Source Builder fields ( String ... fields ) { if ( field Names == null ) { field Names = new Array List < > ( ) ; } Collections . add All ( field Names , fields ) ; return this ; }
public static String Builder format To ( String Builder buf , boolean [ ] d , String sep ) { if ( d == null ) { return buf . append ( STRING ) ; } if ( d . length == NUM ) { return buf ; } buf . append ( d [ NUM ] ) ; for ( int i = NUM ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( format ( d [ i ] ) ) ; } return buf ; }
public String to Complete String ( ) { String ret = STRING ; if ( ! lines . is Empty ( ) && ! Config . v ( ) . no Source Info ) { for ( Source Location Tag line : lines ) { ret += STRING + line + STRING ; } } ret += to Signature String ( ) ; return ret ; }
@ Override public void update Receipt Details ( final Set < Bill Receipt Info > bill Receipts ) { LOGGER . debug ( STRING + bill Receipts ) ; final Boolean status = BOOL ; if ( bill Receipts != null ) super . update Receipt Details ( bill Receipts ) ; LOGGER . debug ( STRING + status ) ; }
public static void remove Map Entries ( Map map , Set set ) { if ( ( set != null ) && ! set . is Empty ( ) ) { for ( Iterator iter = set . iterator ( ) ; iter . has Next ( ) ; ) { map . remove ( iter . next ( ) ) ; } } }
public static void put File ( Service Client h , final Operation put , File f ) throws IO Exception { final Asynchronous File Channel ch = Asynchronous File Channel . open ( f . to Path ( ) , Standard Open Option . READ ) ; Atomic Integer completion Count = new Atomic Integer ( NUM ) ; String content Type = File Utils . get Content Type ( f . to URI ( ) ) ; final boolean [ ] file Is Done = { BOOL } ; put Chunks ( h , put , ch , content Type , f . length ( ) , NUM , completion Count , file Is Done ) ; }
protected String Builder process Line ( String next Element ) { String Builder sb = new String Builder ( INITIAL STRING SIZE ) ; for ( int j = NUM ; j < next Element . length ( ) ; j ++ ) { char next Char = next Element . char At ( j ) ; process Character ( sb , next Char ) ; } return sb ; }
public Java Refactoring Descriptor ( final String id , final String project , final String description , final String comment , final Map arguments , final int flags ) { super ( id , project , description , comment , flags ) ; f Arguments = arguments ; f Arguments . put ( ATTRIBUTE VERSION , VALUE VERSION 1 0 ) ; }
private static Supported Group negotiate Named Curve ( Client Hello client Hello ) { Supported Group result = null ; List < Supported Group > preferred Groups = Supported Group . get Preferred Groups ( ) ; Supported Elliptic Curves Extension extension = client Hello . get Supported Elliptic Curves Extension ( ) ; if ( extension == null ) { if ( ! preferred Groups . is Empty ( ) ) { result = preferred Groups . get ( NUM ) ; } } else { for ( Integer preferred Group Id : extension . get Supported Group Ids ( ) ) { Supported Group group = Supported Group . from Id ( preferred Group Id ) ; if ( group != null && group . is Usable ( ) && preferred Groups . contains ( group ) ) { result = group ; break ; } } } return result ; }
public void zoom ( ) { if ( get Selected Row Key ( ) != null && get Selected Row Key ( ) > NUM ) { M Query zoom Query = new M Query ( ) ; String column = get Key Column ( ) ; if ( column . index Of ( STRING ) > NUM ) column = column . substring ( column . index Of ( STRING ) + NUM ) ; zoom Query . add Restriction ( column , M Query . EQUAL , get Selected Row Key ( ) ) ; zoom Query . set Record Count ( NUM ) ; zoom Query . set Table Name ( column . substring ( NUM , column . length ( ) - NUM ) ) ; A Env . zoom ( NUM , zoom Query ) ; } }
public long avg Rate ( ) { long sum = NUM ; for ( Sample s : samples ) { sum += s . rate ( ) ; } return ( long ) ( sum / ( long ) samples . size ( ) ) ; }
@ Override public synchronized void close ( ) throws IO Exception { try { if ( sync Task != null ) { sync Task . cancel ( ) ; } sync ( ) ; unmap File ( ) ; } finally { super . close ( ) ; } }
public boolean mouse Moved ( Mouse Event e ) { OM Graphic new Selected Graphic ; if ( show plot && graph != null ) { new Selected Graphic = graph . select Point ( e . get X ( ) , e . get Y ( ) , NUM ) ; if ( new Selected Graphic != null ) { String infostring = ( String ) ( new Selected Graphic . get Attribute ( OM Graphic . APP OBJECT ) ) ; if ( infostring != null ) { fire Request Info Line ( infostring ) ; } } else { fire Request Info Line ( STRING ) ; } return BOOL ; } else { OM Graphic List list = get List ( ) ; if ( list != null ) { new Selected Graphic = list . select Closest ( e . get X ( ) , e . get Y ( ) , NUM ) ; if ( new Selected Graphic != null && ( selected Graphic == null || new Selected Graphic != selected Graphic ) ) { Debug . message ( STRING , STRING ) ; selected Graphic = new Selected Graphic ; selected Graphic . regenerate ( get Projection ( ) ) ; GLOBE Site site = ( GLOBE Site ) ( new Selected Graphic . get Attribute ( OM Graphic . APP OBJECT ) ) ; if ( site != null ) { fire Request Info Line ( site . get Info ( ) ) ; } repaint ( ) ; } else if ( selected Graphic != null && new Selected Graphic == null ) { Debug . message ( STRING , STRING ) ; selected Graphic . regenerate ( get Projection ( ) ) ; fire Request Info Line ( STRING ) ; selected Graphic = null ; repaint ( ) ; } return BOOL ; } } return BOOL ; }
public void hide Popup ( ) { show Pending = BOOL ; if ( popup != null ) { popup . hide ( ) ; popup = null ; } }
private float interpolate ( ) { long curr Time = System . current Time Millis ( ) ; float elapsed = ( curr Time - start Time ) / ZOOM TIME ; elapsed = Math . min ( NUM , elapsed ) ; return interpolator . get Interpolation ( elapsed ) ; }
private Point F is Flinging To Delete ( Drag Source source ) { if ( m Fling To Delete Drop Target == null ) return null ; if ( ! source . supports Fling To Delete ( ) ) return null ; View Configuration config = View Configuration . get ( m Launcher ) ; m Velocity Tracker . compute Current Velocity ( NUM , config . get Scaled Maximum Fling Velocity ( ) ) ; if ( m Velocity Tracker . get Y Velocity ( ) < m Fling To Delete Threshold Velocity ) { Point F vel = new Point F ( m Velocity Tracker . get X Velocity ( ) , m Velocity Tracker . get Y Velocity ( ) ) ; Point F up Vec = new Point F ( NUM , - NUM ) ; float theta = ( float ) Math . acos ( ( ( vel . x * up Vec . x ) + ( vel . y * up Vec . y ) ) / ( vel . length ( ) * up Vec . length ( ) ) ) ; if ( theta <= Math . to Radians ( MAX FLING DEGREES ) ) { return vel ; } } return null ; }
public final Runtime Exception process Do Method Invoke Exception ( Exception e , Object object , Object [ ] argument Array ) { if ( e instanceof Runtime Exception ) return ( Runtime Exception ) e ; return Meta Class Helper . create Exception Text ( STRING , this , object , argument Array , e , BOOL ) ; }
protected boolean build Subfield Defns ( String psz Sublist ) { if ( psz Sublist . char At ( NUM ) == STRING ) { b Repeating Subfields = BOOL ; psz Sublist = psz Sublist . substring ( NUM ) ; } Vector papsz Subfield Names = Prop Utils . parse Markers ( psz Sublist , STRING ) ; pao Subfield Defns = new Vector ( ) ; for ( Iterator it = papsz Subfield Names . iterator ( ) ; it . has Next ( ) ; ) { DDF Subfield Definition ddfsd = new DDF Subfield Definition ( ) ; ddfsd . set Name ( ( String ) it . next ( ) ) ; pao Subfield Defns . add ( ddfsd ) ; } return BOOL ; }
public boolean is Running ( ) { return m Running . get ( ) ; }
private static Map < String , Boolean > object Methods To Generate ( List < Executable Element > methods ) { Map < String , Boolean > vars = new Tree Map < String , Boolean > ( ) ; vars . put ( STRING , BOOL ) ; vars . put ( STRING , BOOL ) ; vars . put ( STRING , BOOL ) ; for ( Executable Element method : methods ) { if ( is To String Or Equals Or Hash Code ( method ) ) { boolean can Generate = method . get Modifiers ( ) . contains ( Modifier . ABSTRACT ) || is Java Lang Object ( ( Type Element ) method . get Enclosing Element ( ) ) ; vars . put ( method . get Simple Name ( ) . to String ( ) , can Generate ) ; } } assert vars . size ( ) == NUM ; return vars ; }
public void add Entry Time ( double time ) { if ( entry Times == null ) { return ; } if ( time < NUM ) { time = NUM ; } entry Times . add ( Double . value Of ( time ) ) ; }
public void test single Resource Locking serialized waits For high Concurrency ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = NUM ; final int ntasks = NUM ; properties . set Property ( Test Options . CORE POOL SIZE , STRING + nthreads ) ; properties . set Property ( Test Options . NTASKS , STRING + ntasks ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; final Result result = do Comparison Test ( properties ) ; assert Equals ( STRING , NUM , Integer . parse Int ( result . get ( STRING ) ) ) ; assert Equals ( STRING , NUM , Integer . parse Int ( result . get ( STRING ) ) ) ; assert Equals ( STRING , ntasks , Integer . parse Int ( result . get ( STRING ) ) ) ; }
public final double NPV ( ) { calculate ( ) ; QL . require ( ! Double . is Na N ( this . NPV ) , STRING ) ; return NPV ; }
public Array Real Vector ( Array Real Vector v1 , Real Vector v2 ) { final int l1 = v1 . data . length ; final int l2 = v2 . get Dimension ( ) ; data = new double [ l1 + l2 ] ; System . arraycopy ( v1 . data , NUM , data , NUM , l1 ) ; for ( int i = NUM ; i < l2 ; ++ i ) { data [ l1 + i ] = v2 . get Entry ( i ) ; } }
public static Map < String , Object > deactivate Content Assoc ( Dispatch Context dctx , Map < String , ? extends Object > rcontext ) { Map < String , Object > context = Util Misc . make Map Writable ( rcontext ) ; context . put ( STRING , STRING ) ; List < String > target Operation List = Content Worker . prep Target Operation List ( context , STRING ) ; List < String > content Purpose List = Content Worker . prep Content Purpose List ( context ) ; context . put ( STRING , target Operation List ) ; context . put ( STRING , content Purpose List ) ; context . put ( STRING , null ) ; Map < String , Object > result = deactivate Content Assoc Method ( dctx , context ) ; return result ; }
public Byte Buffer flush And Release Buffer ( ) throws IO Exception { lock . lock ( ) ; try { flush Pending = BOOL ; while ( buffer Use Count != NUM ) { flush Ready . await ( ) ; } buffer . flip ( ) ; if ( buffer . limit ( ) != NUM && modified ) { if ( backing File == null ) { backing File = Files . create Temp File ( STRING , STRING ) ; } log . debug ( STRING , start Index , backing File , buffer . limit ( ) , block Size ) ; try ( Byte Channel out = Files . new Byte Channel ( backing File , WRITE ) ) { out . write ( buffer ) ; } } else { log . debug ( STRING , start Index ) ; } Byte Buffer old Buffer = buffer ; buffer = null ; loaded = BOOL ; return old Buffer ; } catch ( Interrupted Exception e ) { throw Throwables . propagate ( e ) ; } finally { flush Pending = BOOL ; flush Complete . signal All ( ) ; lock . unlock ( ) ; } }
public static boolean is Directly Getting Powered ( World world , Coord 4 D coord ) { for ( Forge Direction side : Forge Direction . VALID DIRECTIONS ) { Coord 4 D side Coord = coord . get From Side ( side ) ; if ( side Coord . exists ( world ) ) { if ( world . is Block Providing Power To ( coord . x Coord , coord . y Coord , coord . z Coord , side . ordinal ( ) ) > NUM ) { return BOOL ; } } } return BOOL ; }
public < T extends Property Container > List < Search Match < T > > search ( String query , Class < T > clazz ) { Search Result result = do Query ( query , clazz ) ; List < Search Match < T > > matches = build Search Matches ( result ) ; @ Suppress Warnings ( STRING ) Function < Search Match , T > resolver = ( Function < Search Match , T > ) ( clazz . equals ( Node . class ) ? get Node Resolver ( ) : get Relationship Resolver ( ) ) ; return resolve Match Items ( matches , resolver ) ; }
private synchronized void enumerate ( Hashtable < String , Object > h ) { if ( defaults != null ) { defaults . enumerate ( h ) ; } for ( Enumeration < ? > e = keys ( ) ; e . has More Elements ( ) ; ) { String key = ( String ) e . next Element ( ) ; h . put ( key , get ( key ) ) ; } }
public void update Quantity Csv ( Item Bean original , Item Bean item To Add , boolean add ) { Big Decimal original Quantity = original . get Qty Csv ( ) ; Big Decimal quantity To Add = item To Add . get Qty Csv ( ) ; Big Decimal final Quantity = null ; if ( ! add ) final Quantity = original Quantity . subtract ( quantity To Add ) ; else final Quantity = original Quantity . add ( quantity To Add ) ; original . set Qty Csv ( final Quantity ) ; }
public static Number abs ( Number a ) { if ( is Floating Point ( a ) ) { return Math . abs ( a . double Value ( ) ) ; } else { return Math . abs ( a . long Value ( ) ) ; } }
public void remove Swipe Listener ( Swipe Listener listener ) { if ( m Listeners == null ) { return ; } m Listeners . remove ( listener ) ; }
private void send Response ( String status , String mime , Properties header , Input Stream data ) { try { if ( status == null ) throw new Error ( STRING ) ; Output Stream out = my Socket . get Output Stream ( ) ; Print Writer pw = new Print Writer ( out ) ; pw . print ( STRING + status + STRING ) ; if ( mime != null ) pw . print ( STRING + mime + STRING ) ; if ( header == null || header . get Property ( STRING ) == null ) pw . print ( STRING + gmt Frmt . format ( new Date ( ) ) + STRING ) ; if ( header != null ) { Enumeration e = header . keys ( ) ; while ( e . has More Elements ( ) ) { String key = ( String ) e . next Element ( ) ; String value = header . get Property ( key ) ; pw . print ( key + STRING + value + STRING ) ; } } pw . print ( STRING ) ; pw . flush ( ) ; if ( data != null ) { int pending = data . available ( ) ; byte [ ] buff = new byte [ NUM ] ; while ( pending > NUM ) { int read = data . read ( buff , NUM , ( ( pending > NUM ) ? NUM : pending ) ) ; if ( read <= NUM ) break ; out . write ( buff , NUM , read ) ; pending -= read ; } } out . flush ( ) ; out . close ( ) ; if ( data != null ) data . close ( ) ; } catch ( IO Exception ioe ) { try { my Socket . close ( ) ; } catch ( Throwable t ) { } } }
public static Input Stream to Input Stream ( Char Sequence input , Charset encoding ) { return to Input Stream ( input . to String ( ) , encoding ) ; }
public User ( String id , String name , String email ) { this . id = id ; this . email = email ; this . name = name ; }
public static void force Delete On Exit ( File file ) throws IO Exception { if ( file . is Directory ( ) ) { delete Directory On Exit ( file ) ; } else { file . delete On Exit ( ) ; } }
@ Suppress Warnings ( STRING ) public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
public static Asset create Asset From Bitmap ( Bitmap bitmap ) { if ( bitmap != null ) { final Byte Array Output Stream byte Stream = new Byte Array Output Stream ( ) ; bitmap . compress ( Bitmap . Compress Format . PNG , NUM , byte Stream ) ; return Asset . create From Bytes ( byte Stream . to Byte Array ( ) ) ; } return null ; }
public boolean is IP Valid ( Session sess , String client IP ) throws SSO Exception { boolean check = BOOL ; try { Inet Address sess IP Address = Inet Address . get By Name ( sess . get Property ( STRING ) ) ; Inet Address client IP Address = Inet Address . get By Name ( client IP ) ; if ( sess IP Address . equals ( client IP Address ) ) { check = BOOL ; } } catch ( Exception e ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING , e ) ; } } return check ; }
@ Suppress Warnings ( STRING ) private static void handle Method Node ( Get Static Graph static Usage Tree , Class Node cn , Method Node mn , int depth ) { Insn List instructions = mn . instructions ; Iterator < Abstract Insn Node > iterator = instructions . iterator ( ) ; while ( iterator . has Next ( ) ) { Abstract Insn Node insn = iterator . next ( ) ; if ( insn instanceof Method Insn Node ) { handle Method Insn Node ( static Usage Tree , cn , mn , ( Method Insn Node ) insn , depth + NUM ) ; } else if ( insn instanceof Field Insn Node ) { handle Field Insn Node ( static Usage Tree , cn , mn , ( Field Insn Node ) insn , depth + NUM ) ; } } }
public boolean handle Touch ( Motion Event event ) { int action = event . get Action ( ) ; if ( m Renderer != null && action == Motion Event . ACTION MOVE ) { if ( old X >= NUM || old Y >= NUM ) { float new X = event . get X ( NUM ) ; float new Y = event . get Y ( NUM ) ; if ( event . get Pointer Count ( ) > NUM && ( old X 2 >= NUM || old Y 2 >= NUM ) && m Renderer . is Zoom Enabled ( ) ) { float new X 2 = event . get X ( NUM ) ; float new Y 2 = event . get Y ( NUM ) ; float new Delta X = Math . abs ( new X - new X 2 ) ; float new Delta Y = Math . abs ( new Y - new Y 2 ) ; float old Delta X = Math . abs ( old X - old X 2 ) ; float old Delta Y = Math . abs ( old Y - old Y 2 ) ; float zoom Rate = NUM ; float tan 1 = Math . abs ( new Y - old Y ) / Math . abs ( new X - old X ) ; float tan 2 = Math . abs ( new Y 2 - old Y 2 ) / Math . abs ( new X 2 - old X 2 ) ; if ( tan 1 <= NUM && tan 2 <= NUM ) { zoom Rate = new Delta X / old Delta X ; apply Zoom ( zoom Rate , Zoom . ZOOM AXIS X ) ; } else if ( tan 1 >= NUM && tan 2 >= NUM ) { zoom Rate = new Delta Y / old Delta Y ; apply Zoom ( zoom Rate , Zoom . ZOOM AXIS Y ) ; } else { if ( Math . abs ( new X - old X ) >= Math . abs ( new Y - old Y ) ) { zoom Rate = new Delta X / old Delta X ; } else { zoom Rate = new Delta Y / old Delta Y ; } apply Zoom ( zoom Rate , Zoom . ZOOM AXIS XY ) ; } old X 2 = new X 2 ; old Y 2 = new Y 2 ; } else if ( m Renderer . is Pan Enabled ( ) ) { m Pan . apply ( old X , old Y , new X , new Y ) ; old X 2 = NUM ; old Y 2 = NUM ; } old X = new X ; old Y = new Y ; graphical View . repaint ( ) ; return BOOL ; } } else if ( action == Motion Event . ACTION DOWN ) { old X = event . get X ( NUM ) ; old Y = event . get Y ( NUM ) ; if ( m Renderer != null && m Renderer . is Zoom Enabled ( ) && zoom R . contains ( old X , old Y ) ) { if ( old X < zoom R . left + zoom R . width ( ) / NUM ) { graphical View . zoom In ( ) ; } else if ( old X < zoom R . left + zoom R . width ( ) * NUM / NUM ) { graphical View . zoom Out ( ) ; } else { graphical View . zoom Reset ( ) ; } return BOOL ; } } else if ( action == Motion Event . ACTION UP || action == Motion Event . ACTION POINTER UP ) { old X = NUM ; old Y = NUM ; old X 2 = NUM ; old Y 2 = NUM ; if ( action == Motion Event . ACTION POINTER UP ) { old X = - NUM ; old Y = - NUM ; } } return ! m Renderer . is Click Enabled ( ) ; }
public void add Parameter ( Name Value Pair param ) throws Illegal Argument Exception { log . trace ( STRING ) ; if ( param == null ) { throw new Illegal Argument Exception ( STRING ) ; } add Parameter ( param . get Name ( ) , param . get Value ( ) ) ; }
public static String read As String ( Input Stream is ) throws IO Exception { String Buffer buf = new String Buffer ( ) ; byte [ ] b = new byte [ NUM ] ; int nread = - NUM ; while ( ( nread = is . read ( b ) ) >= NUM ) { String s = new String ( b , NUM , nread ) ; buf . append ( s ) ; } return buf . to String ( ) ; }
private void read Policies ( Xml Pull Parser parser ) throws IO Exception , Xml Pull Parser Exception { while ( parser . next ( ) != Xml Pull Parser . END TAG ) { if ( parser . get Event Type ( ) != Xml Pull Parser . START TAG ) { continue ; } String name = parser . get Name ( ) ; if ( TAG USER RESTRICTION . equals ( name ) ) { String user Restriction = parser . get Attribute Value ( null , ATTRIBUTE NAME ) ; if ( user Restriction != null ) { m User Restrictions . add ( user Restriction ) ; } } else if ( TAG GLOBAL SETTING . equals ( name ) ) { String setting = parser . get Attribute Value ( null , ATTRIBUTE NAME ) ; String value = parser . get Attribute Value ( null , ATTRIBUTE VALUE ) ; if ( setting != null && value != null ) { m Global Settings . add ( new Global Setting ( setting , value ) ) ; } } else if ( TAG DISABLE STATUS BAR . equals ( name ) ) { m Disable Status Bar = Boolean . parse Boolean ( parser . get Attribute Value ( null , ATTRIBUTE VALUE ) ) ; } else if ( TAG DISABLE KEYGUARD . equals ( name ) ) { m Disable Keyguard = Boolean . parse Boolean ( parser . get Attribute Value ( null , ATTRIBUTE VALUE ) ) ; } else if ( TAG DISABLE CAMERA . equals ( name ) ) { m Disable Camera = Boolean . parse Boolean ( parser . get Attribute Value ( null , ATTRIBUTE VALUE ) ) ; } else if ( TAG DISABLE SCREEN CAPTURE . equals ( name ) ) { m Disable Screen Capture = Boolean . parse Boolean ( parser . get Attribute Value ( null , ATTRIBUTE VALUE ) ) ; } skip Current Tag ( parser ) ; } }
public boolean read Header ( Random Access File raf ) throws IO Exception { String Buffer id = new String Buffer ( NUM ) ; for ( int i = NUM ; i < NUM ; i ++ ) { int ch = raf . read ( ) ; if ( ch < NUM ) { String hx = Integer . to Hex String ( ch ) ; if ( hx . length ( ) < NUM ) { hx = STRING + hx ; } return BOOL ; } id . append ( ( char ) ch ) ; } chunk ID = id . to String ( ) ; size = Aiff Util . read UINT 32 ( raf ) ; return BOOL ; }
private XY Plot initialize Plot ( ) { jmx Chart = new Y Interval Series Improved ( STRING ) ; Y Interval Series Collection yintervalseriescollection = new Y Interval Series Collection ( ) ; yintervalseriescollection . add Series ( jmx Chart ) ; Deviation Renderer renderer = new Deviation Renderer ( BOOL , BOOL ) ; renderer . set Base Shapes Visible ( BOOL ) ; renderer . set Series Stroke ( NUM , new Basic Stroke ( NUM , Basic Stroke . CAP ROUND , Basic Stroke . JOIN ROUND ) ) ; renderer . set Series Fill Paint ( NUM , new Color ( NUM , NUM , NUM ) ) ; renderer . set Series Outline Stroke ( NUM , new Basic Stroke ( NUM ) ) ; renderer . set Series Shape ( NUM , new Ellipse 2 D . Double ( - NUM , - NUM , NUM , NUM ) ) ; renderer . set Base Tool Tip Generator ( new Standard XY Tool Tip Generator ( Standard XY Tool Tip Generator . DEFAULT TOOL TIP FORMAT , Date Format . get Date Time Instance ( ) , Number Format . get Number Instance ( ) ) ) ; Number Axis range Axis = plot Data Solver . get Axis ( ) ; subplot = new XY Plot ( yintervalseriescollection , null , range Axis , renderer ) ; subplot . set Axis Offset ( new Rectangle Insets ( NUM , NUM , NUM , NUM ) ) ; subplot . set Range Axis Location ( Axis Location . TOP OR LEFT ) ; subplot . set Range Crosshair Visible ( BOOL ) ; return subplot ; }
private boolean is Fatal State ( String sql State ) { if ( sql State == null || sql State . length ( ) < NUM ) { return BOOL ; } for ( String FATAL SQL STATE CLASS : FATAL SQL STATE CLASSES ) { if ( sql State . starts With ( FATAL SQL STATE CLASS ) ) { return BOOL ; } } return BOOL ; }
private void analyze File ( File input File , Optional < Common Token Stream > opt Token Stream , Optional < Top Level Context > opt Tree , Formatter formatter , Severity max Severity , Construct Lengths construct Lengths , Set < Rules > enabled Rules ) throws CLI Argument Parser Exception { try { Printer printer = new Printer ( input File , max Severity , formatter ) ; if ( opt Token Stream . is Present ( ) && opt Tree . is Present ( ) ) { Common Token Stream token Stream = opt Token Stream . get ( ) ; Top Level Context tree = opt Tree . get ( ) ; Comment Extractor comment Extractor = new Comment Extractor ( token Stream ) ; Violation Suppressor disable Analysis = new Violation Suppressor ( printer , comment Extractor . get Single Line Comments ( ) , comment Extractor . get Multiline Comments ( ) ) ; disable Analysis . analyze ( ) ; List < Swift Base Listener > listeners = create Listeners ( enabled Rules , printer , token Stream , construct Lengths , comment Extractor ) ; walk Parse Tree ( listeners , tree ) ; try ( File Listener file Listener = new File Listener ( printer , input File , construct Lengths , enabled Rules ) ) { file Listener . verify ( ) ; } num Errors . add And Get ( printer . get Num Error Messages ( ) ) ; num Warnings . add And Get ( printer . get Num Warning Messages ( ) ) ; } else { printer . set Should Print Parse Error Message ( BOOL ) ; } printers For All Files . add ( printer ) ; } catch ( IO Exception e ) { handle IO Exception ( e ) ; } catch ( CLI Argument Parser Exception e ) { handle CLI Exception ( e ) ; } }
@ Suppress Warnings ( STRING ) public static < Value T > Value T to Object ( Byte Buffer bf ) throws IO Exception , Class Not Found Exception { Object obj = null ; Input Stream is = null ; Object Input Stream ois = null ; try { is = new Byte Buffer Backed Input Stream ( bf ) ; ois = new Object Input Stream ( is ) ; obj = ois . read Object ( ) ; } finally { if ( is != null ) { is . close ( ) ; } if ( ois != null ) { ois . close ( ) ; } } return ( Value T ) obj ; }
static private void scan Deadline Queue ( final long now Nanos , final Priority Blocking Queue < Query Deadline > deadline Queue ) { final List < Query Deadline > c = new Array List < Query Deadline > ( DEADLINE QUEUE SCAN SIZE ) ; deadline Queue . drain To ( c , DEADLINE QUEUE SCAN SIZE ) ; int ndropped = NUM , nrunning = NUM ; for ( Query Deadline x : c ) { if ( x . check Deadline ( now Nanos ) != null ) { deadline Queue . add ( x ) ; nrunning ++ ; } else { ndropped ++ ; } } if ( log . is Info Enabled ( ) ) log . info ( STRING + DEADLINE QUEUE SCAN SIZE + STRING + ndropped + STRING + nrunning + STRING + deadline Queue . size ( ) ) ; }
public int compare ( File file 1 , File file 2 ) { return case Sensitivity . check Compare To ( file 1 . get Name ( ) , file 2 . get Name ( ) ) ; }
@ Override public String last String ( ) { return Integer . to String ( lastint ) ; }
public boolean remove Item Content ( String uid ) { if ( ! users . is Empty ( ) ) { return remove Content ( uid , users ) ; } else if ( ! reports . is Empty ( ) ) { return remove Content ( uid , reports ) ; } else { return remove Content ( uid , resources ) ; } }
public void close ( ) { if ( dialog != null ) { dialog . set Visible ( BOOL ) ; dialog . dispose ( ) ; dialog = null ; pane = null ; my Bar = null ; } }
public static void expand Ordinal ( String raw Number String , Word Relation word Relation ) { String number String = Utilities . delete Char ( raw Number String , STRING ) ; expand Number ( number String , word Relation ) ; Item last Item = word Relation . get Tail ( ) ; if ( last Item != null ) { Feature Set feature Set = last Item . get Features ( ) ; String last Number = feature Set . get String ( STRING ) ; String ordinal = find Match In Array ( last Number , digit 2 num , ord 2 num ) ; if ( ordinal == null ) { ordinal = find Match In Array ( last Number , digit 2 teen , ord 2 teen ) ; } if ( ordinal == null ) { ordinal = find Match In Array ( last Number , digit 2 enty , ord 2 enty ) ; } if ( last Number . equals ( STRING ) ) { ordinal = STRING ; } else if ( last Number . equals ( STRING ) ) { ordinal = STRING ; } else if ( last Number . equals ( STRING ) ) { ordinal = STRING ; } if ( ordinal != null ) { word Relation . set Last Word ( ordinal ) ; } } }
private void check Bounded Type Parameter ( Method method ) { Type Variable < Method > type Parameter = get Type Parameter ( method ) ; assert Equals ( STRING , type Parameter . get Name ( ) ) ; assert Equals ( method , type Parameter . get Generic Declaration ( ) ) ; Type [ ] bounds = type Parameter . get Bounds ( ) ; assert Lenght One ( bounds ) ; Type bound = bounds [ NUM ] ; assert Equals ( Bounded Wildcards Generic Methods . class , bound ) ; }
public void register Sensor ( Sensor s , int i ) { if ( ( i < NUM ) || ( i > ( input Bits [ node Type ] - NUM ) ) || ( i > MAXSENSORS ) ) { log . error ( STRING + Integer . to String ( i + NUM ) ) ; return ; } has Active Sensors = BOOL ; if ( sensor Array [ i ] == null ) { sensor Array [ i ] = s ; if ( last Used Sensor < i ) { last Used Sensor = i ; } } else { log . warn ( STRING + Integer . to String ( ( get Node Address ( ) * Serial Sensor Manager . SENSORSPERNODE ) + i + NUM ) ) ; } }
public boolean has Organisation Units ( ) { List < Dimensional Item Object > dim Opts = get Dimension Options ( ORGUNIT DIM ID ) ; List < Dimensional Item Object > filter Opts = get Filter Options ( ORGUNIT DIM ID ) ; return ! dim Opts . is Empty ( ) || ! filter Opts . is Empty ( ) ; }
protected void fixup Blocks ( byte [ ] bytes 2 ) { byte [ ] bytes = bytes 2 ; for ( Iterator enumerator = blocks . iterator ( ) ; enumerator . has Next ( ) ; ) { int [ ] info = ( int [ ] ) enumerator . next ( ) ; int code Size = info [ NUM ] ; int offset = info [ NUM ] ; byte [ ] size Bytes = Out Stream . sint To 2 Bytes ( code Size ) ; bytes [ offset ] = size Bytes [ NUM ] ; bytes [ offset + NUM ] = size Bytes [ NUM ] ; } }
protected double negative Log Likelihood ( double [ ] [ ] data Ys , double [ ] [ ] probs ) { double log Likelihood = NUM ; for ( int i = NUM ; i < data Ys . length ; i ++ ) { for ( int j = NUM ; j < m num Classes ; j ++ ) { if ( data Ys [ i ] [ j ] == NUM ) { log Likelihood -= Math . log ( probs [ i ] [ j ] ) ; } } } return log Likelihood ; }
public static boolean valid System Name Config ( String system Name , char type , Acela System Connection Memo memo ) { if ( ! valid System Name Format ( system Name , type , memo . get System Prefix ( ) ) ) { return BOOL ; } Acela Node node = get Node From System Name ( system Name , memo ) ; if ( node == null ) { return BOOL ; } int bit = get Bit From System Name ( system Name ) ; if ( ( type == STRING ) || ( type == STRING ) ) { if ( ( bit < MINOUTPUTADDRESS ) || ( bit > MAXOUTPUTADDRESS ) ) { return BOOL ; } } else if ( type == STRING ) { if ( ( bit < MINSENSORADDRESS ) || ( bit > MAXSENSORADDRESS ) ) { return BOOL ; } } else { log . error ( STRING ) ; return BOOL ; } return BOOL ; }
public void read Encryption Object ( final Pdf Object encyption Obj , final Pdf File Reader pdf File Reader ) throws Pdf Security Exception { strings Encoded = BOOL ; is Meta Data Encypted = BOOL ; Stm F Obj = null ; Str F Obj = null ; is AES = BOOL ; if ( ! is Initialised ) { is Initialised = BOOL ; Set Security . init ( ) ; } if ( Set Security . use Bouncy Castle ) { decryption Methods = new Bouncy Castle Decryption ( ) ; } else { decryption Methods = new JCA Decryption ( ) ; } final int v = encyption Obj . get Int ( Pdf Dictionary . V ) ; final Pdf Array Iterator filters = encyption Obj . get Mixed Array ( Pdf Dictionary . Filter ) ; int first Value = Pdf Dictionary . Standard ; if ( filters != null && filters . has More Tokens ( ) ) { first Value = filters . get Next Value As Constant ( BOOL ) ; } if ( v == NUM ) { throw new Pdf Security Exception ( STRING ) ; } else if ( ( v > NUM ) && ( first Value != Pdf Dictionary . Standard ) ) { throw new Pdf Security Exception ( STRING ) ; } final int new Length = encyption Obj . get Int ( Pdf Dictionary . Length ) > > NUM ; if ( new Length != - NUM ) { this . key Length = new Length ; } rev = encyption Obj . get Int ( Pdf Dictionary . R ) ; P = encyption Obj . get Int ( Pdf Dictionary . P ) ; O = encyption Obj . get Text Stream Value As Byte ( Pdf Dictionary . O ) ; U = encyption Obj . get Text Stream Value As Byte ( Pdf Dictionary . U ) ; OE = encyption Obj . get Text Stream Value As Byte ( Pdf Dictionary . OE ) ; UE = encyption Obj . get Text Stream Value As Byte ( Pdf Dictionary . UE ) ; Perms = encyption Obj . get Text Stream Value As Byte ( Pdf Dictionary . Perms ) ; if ( v >= NUM ) { is AES = BOOL ; String C Fkey ; final Pdf Object CF = encyption Obj . get Dictionary ( Pdf Dictionary . CF ) ; if ( v == NUM ) { is Meta Data Encypted = encyption Obj . get Boolean ( Pdf Dictionary . Encrypt Metadata ) ; } is AES Identity = BOOL ; String key = encyption Obj . get Name ( Pdf Dictionary . Str F ) ; if ( key != null ) { is AES Identity = key . equals ( STRING ) ; strings Encoded = BOOL ; final Pdf Key Pairs Iterator key Pairs = CF . get Key Pairs Iterator ( ) ; while ( key Pairs . has More Pairs ( ) ) { C Fkey = key Pairs . get Next Key As String ( ) ; if ( C Fkey . equals ( key ) ) { Str F Obj = Pdf Object Factory . get PDF Object Object From Ref Or Direct ( new Encryption Object ( encyption Obj . get Object Ref As String ( ) ) , pdf File Reader , key Pairs . get Next Value As Bytes ( ) , Pdf Dictionary . CF ) ; } key Pairs . next Pair ( ) ; } } key = encyption Obj . get Name ( Pdf Dictionary . Stm F ) ; if ( key != null ) { is AES Identity = key . equals ( STRING ) ; final Pdf Key Pairs Iterator key Pairs = CF . get Key Pairs Iterator ( ) ; while ( key Pairs . has More Pairs ( ) ) { C Fkey = key Pairs . get Next Key As String ( ) ; if ( C Fkey . equals ( key ) ) { Stm F Obj = Pdf Object Factory . get PDF Object Object From Ref Or Direct ( new Encryption Object ( encyption Obj . get Object Ref As String ( ) ) , pdf File Reader , key Pairs . get Next Value As Bytes ( ) , Pdf Dictionary . CF ) ; } key Pairs . next Pair ( ) ; } } } is Encrypted = BOOL ; is File Viewable = BOOL ; Log Writer . write Log ( STRING ) ; if ( first Value == Pdf Dictionary . Standard ) { try { verify Access ( ) ; } catch ( final Pdf Security Exception e ) { Log Writer . write Log ( STRING + e ) ; } } else if ( certificate != null ) { is File Viewable = BOOL ; is Password Supplied = BOOL ; extraction Is Allowed = BOOL ; password Status = PD Fflags . VALID OWNER PASSWORD ; } if ( rev == NUM ) { Perms = v5 Decrypt ( Perms , encryption Key ) ; is Meta Data Encypted = Perms [ NUM ] == STRING ; P = ( Perms [ NUM ] & NUM ) | ( ( Perms [ NUM ] & NUM ) << NUM ) | ( ( Perms [ NUM ] & NUM ) << NUM ) | ( ( Perms [ NUM ] & NUM ) << NUM ) ; } }
public void add Member ( String player Name ) { open Invites . remove ( player Name ) ; members And Last Seen . put ( player Name , Long . value Of ( System . current Time Millis ( ) ) ) ; if ( leader == null ) { leader = player Name ; } send Group Change Event ( ) ; }
public Bubble XY Item Label Generator ( ) { this ( DEFAULT FORMAT STRING , Number Format . get Number Instance ( ) , Number Format . get Number Instance ( ) , Number Format . get Number Instance ( ) ) ; }
void add Nodes ( List < Node > new Nodes , boolean at Beginning ) { if ( at Beginning ) { if ( ( nodes . size ( ) > NUM ) && nodes . get ( NUM ) == new Nodes . get ( new Nodes . size ( ) - NUM ) ) { Log . i ( DEBUG TAG , STRING ) ; if ( new Nodes . size ( ) > NUM ) { Log . i ( DEBUG TAG , STRING ) ; new Nodes . remove ( new Nodes . size ( ) - NUM ) ; add Nodes ( new Nodes , at Beginning ) ; } return ; } nodes . add All ( NUM , new Nodes ) ; } else { if ( ( nodes . size ( ) > NUM ) && new Nodes . get ( NUM ) == nodes . get ( nodes . size ( ) - NUM ) ) { Log . i ( DEBUG TAG , STRING ) ; if ( new Nodes . size ( ) > NUM ) { Log . i ( DEBUG TAG , STRING ) ; new Nodes . remove ( NUM ) ; add Nodes ( new Nodes , at Beginning ) ; } return ; } nodes . add All ( new Nodes ) ; } }
public synchronized Boolean update AV Client By Stream Id ( String stream Id , Room Client rcm ) { try { Room Client rcl Usual = get Client By Public SID ( rcm . get Public SID ( ) , BOOL ) ; if ( rcl Usual != null ) { rcl Usual . set Broad Cast ID ( rcm . get Broad Cast ID ( ) ) ; rcl Usual . set Avsettings ( rcm . get Avsettings ( ) ) ; rcl Usual . set V Height ( rcm . get V Height ( ) ) ; rcl Usual . set V Width ( rcm . get V Width ( ) ) ; rcl Usual . set VX ( rcm . get VX ( ) ) ; rcl Usual . set VY ( rcm . get VY ( ) ) ; if ( client List . contains Key ( rcl Usual . get Streamid ( ) ) ) { client List . put ( rcl Usual . get Streamid ( ) , rcl Usual ) ; } else { log . debug ( STRING + rcl Usual . get Streamid ( ) ) ; } } update Client By Stream Id ( stream Id , rcm ) ; } catch ( Exception err ) { log . error ( STRING , err ) ; } return null ; }
public void add Color ( int color ) { if ( m Colors == null ) m Colors = new Array List < Integer > ( ) ; m Colors . add ( color ) ; }
private void clamp Starting Position ( ) { final float cX = m Bounds . exact Center X ( ) ; final float cY = m Bounds . exact Center Y ( ) ; final float dX = m Starting X - cX ; final float dY = m Starting Y - cY ; final float r = m Target Radius ; if ( dX * dX + dY * dY > r * r ) { final double angle = Math . atan 2 ( dY , dX ) ; m Clamped Starting X = cX + ( float ) ( Math . cos ( angle ) * r ) ; m Clamped Starting Y = cY + ( float ) ( Math . sin ( angle ) * r ) ; } else { m Clamped Starting X = m Starting X ; m Clamped Starting Y = m Starting Y ; } }
public Criteria create Criteria ( ) { Criteria criteria = create Criteria Internal ( ) ; if ( ored Criteria . size ( ) == NUM ) { ored Criteria . add ( criteria ) ; } return criteria ; }
public boolean is Empty ( ) { if ( last Batch != null ) { if ( ! last Batch . is Empty ( ) ) { return BOOL ; } } return current Batch . is Empty ( ) ; }
@ Suppress Warnings ( STRING ) public Dummy Data ( int cols , int rows , Comparable < ? > value ) { value . get Class ( ) ; this . cols = cols ; this . rows = rows ; this . value = value ; Class < ? extends Comparable < ? > > [ ] types = new Class [ cols ] ; Arrays . fill ( types , value . get Class ( ) ) ; set Column Types ( types ) ; }
public Object clone ( ) throws Clone Not Supported Exception { Node Vector clone = ( Node Vector ) super . clone ( ) ; if ( ( null != this . m map ) && ( this . m map == clone . m map ) ) { clone . m map = new int [ this . m map . length ] ; System . arraycopy ( this . m map , NUM , clone . m map , NUM , this . m map . length ) ; } return clone ; }
public boolean match With Pattern ( String pattern ) { if ( Text Utils . is Empty ( pattern ) ) { m Current Pattern = STRING ; m Upper Case Pattern = STRING ; m Lower Case Pattern = STRING ; } if ( Text Utils . is Empty ( m Display Name ) ) { return BOOL ; } if ( Text Utils . is Empty ( m Upper Case Display Name ) ) { m Upper Case Display Name = m Display Name . to Lower Case ( ) ; m Lower Case Display Name = m Display Name . to Upper Case ( ) ; } if ( ! pattern . equals ( m Current Pattern ) ) { m Current Pattern = pattern ; m Upper Case Pattern = pattern . to Upper Case ( ) ; m Lower Case Pattern = pattern . to Lower Case ( ) ; } return ( m Upper Case Display Name . index Of ( m Upper Case Pattern ) >= NUM ) || ( m Lower Case Display Name . index Of ( m Upper Case Pattern ) >= NUM ) ; }
public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL ; } if ( obj instanceof Annotation Member ) { Annotation Member that = ( Annotation Member ) obj ; if ( name . equals ( that . name ) && tag == that . tag ) { if ( tag == ARRAY ) { return equal Array Value ( that . value ) ; } else if ( tag == ERROR ) { return BOOL ; } else { return value . equals ( that . value ) ; } } } return BOOL ; }
public int hle Jpeg Decode Y Cb Cr ( Buffered Image buffered Image , T Pointer y Cb Cr Buffer , int y Cb Cr Buffer Size , int dht Mode ) { int width = buffered Image . get Width ( ) ; int height = buffered Image . get Height ( ) ; int size Y = width * height ; int size Cb = size Y > > NUM ; int address Y = y Cb Cr Buffer . get Address ( ) ; int address Cb = address Y + size Y ; int address Cr = address Cb + size Cb ; if ( log . is Debug Enabled ( ) ) { log . debug ( String . format ( STRING , address Y , address Cb , address Cr ) ) ; } int [ ] buffer Cb = new int [ size Cb ] ; int [ ] buffer Cr = new int [ size Cb ] ; I Memory Writer image Writer Y = Memory Writer . get Memory Writer ( address Y , size Y , NUM ) ; for ( int y = NUM ; y < height ; y ++ ) { int index Cb = ( y > > NUM ) * ( width > > NUM ) ; for ( int x = NUM ; x < width ; x += NUM , index Cb ++ ) { int argb 0 = buffered Image . get RGB ( x , y ) ; int y Cb Cr 0 = color ARGB To Y Cb Cr ( argb 0 ) ; int argb 1 = buffered Image . get RGB ( x + NUM , y ) ; int y Cb Cr 1 = color ARGB To Y Cb Cr ( argb 1 ) ; image Writer Y . write Next ( get Y ( y Cb Cr 0 ) ) ; image Writer Y . write Next ( get Y ( y Cb Cr 1 ) ) ; buffer Cb [ index Cb ] += get Cb ( y Cb Cr 0 ) ; buffer Cb [ index Cb ] += get Cb ( y Cb Cr 1 ) ; buffer Cr [ index Cb ] += get Cr ( y Cb Cr 0 ) ; buffer Cr [ index Cb ] += get Cr ( y Cb Cr 1 ) ; } } image Writer Y . flush ( ) ; I Memory Writer image Writer Cb = Memory Writer . get Memory Writer ( address Cb , size Cb , NUM ) ; I Memory Writer image Writer Cr = Memory Writer . get Memory Writer ( address Cr , size Cb , NUM ) ; for ( int i = NUM ; i < size Cb ; i ++ ) { image Writer Cb . write Next ( buffer Cb [ i ] > > NUM ) ; image Writer Cr . write Next ( buffer Cr [ i ] > > NUM ) ; } image Writer Cb . flush ( ) ; image Writer Cr . flush ( ) ; return get Width Height ( width , height ) ; }
public static Range iterate Z Bounds ( XYZ Dataset dataset , boolean include Interval ) { double minimum = Double . POSITIVE INFINITY ; double maximum = Double . NEGATIVE INFINITY ; int series Count = dataset . get Series Count ( ) ; for ( int series = NUM ; series < series Count ; series ++ ) { int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { double value = dataset . get Z Value ( series , item ) ; if ( ! Double . is Na N ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } } } if ( minimum == Double . POSITIVE INFINITY ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
public void remove View From Fade List ( View view ) { if ( m Fade View List != null && view != null ) { m Fade View List . remove ( view ) ; } }
void add Indifferent Algorithm ( String algorithm ) { indifferent Algorithms . add ( algorithm ) ; }
public Union Iterator ( Iterable < ? extends E > ... args ) { this ( Arrays . as List ( args ) ) ; }
public static String mangle Native Method ( String owner , String name , String desc ) { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; sb . append ( mangle Native String ( owner ) ) ; sb . append ( STRING ) ; sb . append ( mangle Native String ( name ) ) ; if ( desc != null ) { sb . append ( STRING ) ; sb . append ( mangle Native String ( desc . substring ( NUM , desc . last Index Of ( STRING ) ) ) ) ; } return sb . to String ( ) ; }
public String read Line ( ) throws IO Exception { boolean got CR = BOOL , got LF = BOOL ; pos = NUM ; line Buf = new String Buffer ( ) ; while ( ! got LF ) { int c = is . read ( ) ; if ( c == - NUM ) { return null ; } if ( got CR ) { if ( c == LF ) { got LF = BOOL ; } else { got CR = BOOL ; consume ( CR ) ; consume ( c ) ; } } else { if ( c == CR ) { got CR = BOOL ; } else { consume ( c ) ; } } } line Buf . append ( buf , NUM , pos ) ; return new String ( line Buf ) ; }
public Lobby Client login ( ) { if ( ! m server Properties . is Server Available ( ) ) { J Option Pane . show Message Dialog ( m parent , m server Properties . server Error Message , STRING , J Option Pane . ERROR MESSAGE ) ; return null ; } if ( m server Properties . port == - NUM ) { if ( Client File System Helper . are We Old Extra Jar ( ) ) { J Option Pane . show Message Dialog ( m parent , STRING + Url Constants . LATEST GAME DOWNLOAD WEBSITE + STRING + STRING , STRING , J Option Pane . ERROR MESSAGE ) ; } else { J Option Pane . show Message Dialog ( m parent , STRING + Url Constants . LATEST GAME DOWNLOAD WEBSITE + STRING , STRING , J Option Pane . ERROR MESSAGE ) ; } return null ; } return login To Server ( ) ; }
@ Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case Functionblock Package . PARAM MULTIPLICITY : return multiplicity != MULTIPLICITY EDEFAULT ; case Functionblock Package . PARAM NAME : return NAME EDEFAULT == null ? name != null : ! NAME EDEFAULT . equals ( name ) ; case Functionblock Package . PARAM DESCRIPTION : return DESCRIPTION EDEFAULT == null ? description != null : ! DESCRIPTION EDEFAULT . equals ( description ) ; } return super . e Is Set ( feature ID ) ; }
protected Node pop Node ( Stack < Node > stack , Class < ? extends Node > cls , String uri ) { Node top = stack . is Empty ( ) ? null : stack . peek ( ) ; if ( top != null ) { if ( node Matches ( top , cls , uri ) ) { Node node = stack . pop ( ) ; popped Nodes . push ( node ) ; return node ; } else { for ( int i = stack . size ( ) - NUM ; i >= NUM ; i -- ) { if ( node Matches ( stack . get ( i ) , cls , uri ) ) { Node node = stack . remove ( i ) ; popped Nodes . push ( node ) ; return node ; } } } } return null ; }
static String path To Cookie Path ( String path ) { if ( path == null ) { return STRING ; } int last Slash = path . last Index Of ( STRING ) ; return path . substring ( NUM , last Slash + NUM ) ; }
public static double [ ] [ ] compute Weight Matrix ( int bpp ) { final int dim = bpp * bpp * bpp ; final double [ ] [ ] m = new double [ dim ] [ dim ] ; final double max = NUM * ( bpp - NUM ) ; for ( int x = NUM ; x < dim ; x ++ ) { final int rx = ( x / bpp ) / bpp ; final int gx = ( x / bpp ) % bpp ; final int bx = x % bpp ; for ( int y = x ; y < dim ; y ++ ) { final int ry = ( y / bpp ) / bpp ; final int gy = ( y / bpp ) % bpp ; final int by = y % bpp ; final double dr = Math . abs ( rx - ry ) ; final double dg = Math . abs ( gx - gy ) ; final double db = Math . abs ( bx - by ) ; final double val = NUM - ( dr + dg + db ) / max ; m [ x ] [ y ] = m [ y ] [ x ] = val ; } } return m ; }
public boolean move Entry ( User user , Entry entry , String direction , boolean is Admin , Errors errors ) { if ( direction == null ) { Errors . add ( errors , error Messages . error Direction Is Null ( ) ) ; return BOOL ; } if ( entry == null ) { Errors . add ( errors , error Messages . error Entry Is Null ( ) ) ; return BOOL ; } if ( ! can User Modify Entry ( user , entry , is Admin ) ) { Errors . add ( errors , error Messages . error User Is Not Entitled To Move The Entry ( ) ) ; return BOOL ; } final String parent Id = entry . get Parent Id ( ) ; String parent First Child Id = null ; String parent Last Child Id = null ; final Entry parent = get Entry By Id ( parent Id ) ; if ( parent == null ) { Errors . add ( errors , error Messages . error The Entry Had No Parent So It Could Not Be Moved ( ) ) ; return BOOL ; } parent First Child Id = parent . get First Child Id ( ) ; parent Last Child Id = parent . get Last Child Id ( ) ; if ( direction . equals ( STRING ) ) { final String previous Id = entry . get Previous Sibling Id ( ) ; if ( previous Id == null ) { Errors . add ( errors , error Messages . error There Is No Entry To Move Before ( ) ) ; return BOOL ; } final Entry previous = get Entry By Id ( previous Id ) ; final String previous Previous Id = previous . get Previous Sibling Id ( ) ; if ( previous Previous Id != null ) { final Entry previous Previous = get Entry By Id ( previous Previous Id ) ; if ( previous Previous != null ) { previous Previous . set Next Sibling Id ( entry . get Id ( ) ) ; } } final String next Id = entry . get Next Sibling Id ( ) ; if ( next Id != null ) { final Entry next = get Entry By Id ( next Id ) ; if ( next != null ) { next . set Previous Sibling Id ( previous Id ) ; } } entry . set Previous Sibling Id ( previous Previous Id ) ; entry . set Next Sibling Id ( previous Id ) ; previous . set Previous Sibling Id ( entry . get Id ( ) ) ; previous . set Next Sibling Id ( next Id ) ; if ( parent First Child Id != null && previous Id != null && parent First Child Id . equals ( previous Id ) ) { parent . set First Child Id ( entry . get Id ( ) ) ; } if ( parent Last Child Id != null && parent Last Child Id . equals ( entry . get Id ( ) ) ) { parent . set Last Child Id ( previous Id ) ; } } else if ( direction . equals ( STRING ) ) { final String next Id = entry . get Next Sibling Id ( ) ; if ( next Id == null ) { Errors . add ( errors , error Messages . error There Is No Entry To Move After ( ) ) ; return BOOL ; } final Entry next = get Entry By Id ( next Id ) ; final String next Next Id = next . get Next Sibling Id ( ) ; if ( next Next Id != null ) { final Entry next Next = get Entry By Id ( next Next Id ) ; if ( next Next != null ) { next Next . set Previous Sibling Id ( entry . get Id ( ) ) ; } } final String previous Id = entry . get Previous Sibling Id ( ) ; if ( previous Id != null ) { final Entry previous = get Entry By Id ( previous Id ) ; if ( previous Id != null ) { previous . set Next Sibling Id ( next Id ) ; } } entry . set Previous Sibling Id ( next Id ) ; entry . set Next Sibling Id ( next Next Id ) ; next . set Previous Sibling Id ( previous Id ) ; next . set Next Sibling Id ( entry . get Id ( ) ) ; if ( parent First Child Id != null && parent First Child Id . equals ( entry . get Id ( ) ) ) { parent . set First Child Id ( next Id ) ; } if ( parent Last Child Id != null && next Id != null && parent Last Child Id . equals ( next Id ) ) { parent . set Last Child Id ( entry . get Id ( ) ) ; } } else if ( direction . equals ( STRING ) ) { final String parent Parent Id = parent . get Parent Id ( ) ; if ( parent Parent Id == null ) { Errors . add ( errors , error Messages . error There Is No Parent Of The Parent ( ) ) ; return BOOL ; } snip Out Entry ( entry , parent , BOOL ) ; insert Entry After ( entry , parent , BOOL ) ; } else if ( direction . equals ( STRING ) ) { final String previous Id = entry . get Previous Sibling Id ( ) ; if ( previous Id == null ) { Errors . add ( errors , error Messages . error There Is No Previous Entry To Use As A Parent ( ) ) ; return BOOL ; } snip Out Entry ( entry , parent , BOOL ) ; final Entry previous = get Entry By Id ( previous Id ) ; final String previous Last Child Id = previous . get Last Child Id ( ) ; if ( previous Last Child Id != null ) { final Entry previous Last Child = get Entry By Id ( previous Last Child Id ) ; previous Last Child . set Next Sibling Id ( entry . get Id ( ) ) ; } entry . set Previous Sibling Id ( previous Last Child Id ) ; entry . set Next Sibling Id ( null ) ; previous . set Last Child Id ( entry . get Id ( ) ) ; if ( ! previous . has First Child Id ( ) ) { previous . set First Child Id ( entry . get Id ( ) ) ; } previous . set Last Child Id ( entry . get Id ( ) ) ; entry . set Parent Id ( previous . get Id ( ) ) ; } else { Errors . add ( errors , error Messages . error The Direction Is Invalid ( ) ) ; return BOOL ; } return BOOL ; }
private static boolean is Gnome ( ) { return System . getenv ( STRING ) != null ; }
protected Size Requirements calculate Major Axis Requirements ( int axis , Size Requirements r ) { Size Requirements req = super . calculate Major Axis Requirements ( axis , r ) ; req . maximum = Integer . MAX VALUE ; return req ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public void add Nodes In Doc Order ( DTM Iterator iterator , X Path Context support ) { if ( ! m mutable ) throw new Runtime Exception ( XSL Messages . create XPATH Message ( XPATH Error Resources . ER NODESETDTM NOT MUTABLE , null ) ) ; int node ; while ( DTM . NULL != ( node = iterator . next Node ( ) ) ) { add Node In Doc Order ( node , support ) ; } }
public Map < String , List < Revision File > > current Revision Files ( ) ;
protected static Pair < String , String > ror Register ( final long offset , final I Translation Environment environment , final List < Reil Instruction > instructions , final String register Node Value 1 , final String register Node Value 2 ) { final String shifter Operand = environment . get Next Variable String ( ) ; final String shifter Carry Out = environment . get Next Variable String ( ) ; final String tmp Rs Four = environment . get Next Variable String ( ) ; final String tmp Rs Four Negative = environment . get Next Variable String ( ) ; final String tmp Rs Seven = environment . get Next Variable String ( ) ; final String is Zero Condition Four = environment . get Next Variable String ( ) ; final String is Not Zero Condition Four = environment . get Next Variable String ( ) ; final String is Zero Condition Seven = environment . get Next Variable String ( ) ; final String tmp Var 1 = environment . get Next Variable String ( ) ; final String tmp Var 2 = environment . get Next Variable String ( ) ; final String tmp Var 3 = environment . get Next Variable String ( ) ; final String tmp Var 4 = environment . get Next Variable String ( ) ; final String tmp Var 5 = environment . get Next Variable String ( ) ; final String tmp Var 6 = environment . get Next Variable String ( ) ; final String tmp Var 7 = environment . get Next Variable String ( ) ; final String tmp Var 8 = environment . get Next Variable String ( ) ; final String shifter Carry Out Tmp 1 = environment . get Next Variable String ( ) ; final String shifter Carry Out Tmp 2 = environment . get Next Variable String ( ) ; final String shifter Carry Out Tmp 3 = environment . get Next Variable String ( ) ; final String shifter Carry Out Tmp 4 = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add ( Reil Helpers . create And ( base Offset ++ , d Word Size , register Node Value 2 , d Word Size , String . value Of ( NUM ) , d Word Size , tmp Rs Seven ) ) ; instructions . add ( Reil Helpers . create Bisz ( base Offset ++ , d Word Size , tmp Rs Seven , byte Size , is Zero Condition Seven ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , d Word Size , tmp Rs Seven , d Word Size , String . value Of ( NUM ) , d Word Size , tmp Rs Four ) ) ; instructions . add ( Reil Helpers . create Bisz ( base Offset ++ , d Word Size , tmp Rs Four , byte Size , is Zero Condition Four ) ) ; instructions . add ( Reil Helpers . create Bisz ( base Offset ++ , byte Size , is Zero Condition Four , byte Size , is Not Zero Condition Four ) ) ; instructions . add ( Reil Helpers . create Sub ( base Offset ++ , d Word Size , zero Set , d Word Size , tmp Rs Four , d Word Size , tmp Rs Four Negative ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value 1 , d Word Size , tmp Rs Four Negative , d Word Size , tmp Var 1 ) ) ; instructions . add ( Reil Helpers . create Sub ( base Offset ++ , d Word Size , String . value Of ( NUM ) , d Word Size , tmp Rs Four , d Word Size , tmp Var 2 ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value 1 , d Word Size , tmp Var 2 , d Word Size , tmp Var 3 ) ) ; instructions . add ( Reil Helpers . create Or ( base Offset ++ , d Word Size , tmp Var 1 , d Word Size , tmp Var 3 , d Word Size , tmp Var 4 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , d Word Size , tmp Var 4 , d Word Size , bit Mask All Bits Set , d Word Size , shifter Operand ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , byte Size , STRING , byte Size , is Zero Condition Seven , byte Size , shifter Carry Out Tmp 1 ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value 1 , d Word Size , minus Thirty One Set , byte Size , tmp Var 5 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , byte Size , tmp Var 5 , byte Size , is Zero Condition Four , byte Size , shifter Carry Out Tmp 2 ) ) ; instructions . add ( Reil Helpers . create Sub ( base Offset ++ , d Word Size , tmp Rs Four , byte Size , one Set , d Word Size , tmp Var 6 ) ) ; instructions . add ( Reil Helpers . create Sub ( base Offset ++ , d Word Size , zero Set , d Word Size , tmp Var 6 , d Word Size , tmp Var 7 ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value 1 , d Word Size , tmp Var 7 , d Word Size , tmp Var 8 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , d Word Size , tmp Var 8 , byte Size , is Not Zero Condition Four , byte Size , shifter Carry Out Tmp 3 ) ) ; instructions . add ( Reil Helpers . create Or ( base Offset ++ , byte Size , shifter Carry Out Tmp 1 , byte Size , shifter Carry Out Tmp 2 , byte Size , shifter Carry Out Tmp 4 ) ) ; instructions . add ( Reil Helpers . create Or ( base Offset ++ , byte Size , shifter Carry Out Tmp 3 , byte Size , shifter Carry Out Tmp 4 , byte Size , shifter Carry Out ) ) ; return new Pair < String , String > ( shifter Operand , shifter Carry Out ) ; }
public static byte [ ] read Fully ( Input Stream in ) throws IO Exception { try { return read Fully No Close ( in ) ; } finally { in . close ( ) ; } }
public void end Subreport ( String subreport ) { if ( subreport . is Empty ( ) ) { LOG . error ( String . format ( STRING , subreport ) ) ; return ; } String top Subreport = subreports . peek ( ) ; if ( top Subreport . equals ( subreport ) ) { subreports . pop ( ) ; add Log Entry ( new Subreport End Entry ( subreport ) ) ; return ; } LOG . error ( String . format ( STRING , subreport ) ) ; }
public static double dnorm Log ( double x , double mean , double sd ) { if ( sd <= NUM ) throw new Illegal Argument Exception ( STRING ) ; return - Math . log ( sd ) + dnorm Log ( ( x - mean ) / sd ) ; }
public static void delete ( File f ) { delete ( f , BOOL ) ; }
public Buffered Header ( final Char Array Buffer buffer ) throws Parse Exception { super ( ) ; if ( buffer == null ) { throw new Illegal Argument Exception ( STRING ) ; } int colon = buffer . index Of ( STRING ) ; if ( colon == - NUM ) { throw new Parse Exception ( STRING + buffer . to String ( ) ) ; } String s = buffer . substring Trimmed ( NUM , colon ) ; if ( s . length ( ) == NUM ) { throw new Parse Exception ( STRING + buffer . to String ( ) ) ; } this . buffer = buffer ; this . name = s ; this . value Pos = colon + NUM ; }
public boolean extends Entity ( Class < ? > entity Definition ) { return entity Definition . get Annotation ( Extends Entity . class ) != null ; }
private void pull Event ( ) { final int new Scroll Value ; final int item Dimension ; final float initial Motion Value , last Motion Value ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : initial Motion Value = m Initial Motion X ; last Motion Value = m Last Motion X ; break ; case VERTICAL : default : initial Motion Value = m Initial Motion Y ; last Motion Value = m Last Motion Y ; break ; } switch ( m Current Mode ) { case PULL FROM END : new Scroll Value = Math . round ( Math . max ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Footer Size ( ) ; break ; case PULL FROM START : default : new Scroll Value = Math . round ( Math . min ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Header Size ( ) ; break ; } set Header Scroll ( new Scroll Value ) ; if ( new Scroll Value != NUM && ! is Refreshing ( ) ) { float scale = Math . abs ( new Scroll Value ) / ( float ) item Dimension ; switch ( m Current Mode ) { case PULL FROM END : m Footer Layout . on Pull ( scale ) ; break ; case PULL FROM START : default : m Header Layout . on Pull ( scale ) ; break ; } if ( m State != State . PULL TO REFRESH && item Dimension >= Math . abs ( new Scroll Value ) ) { set State ( State . PULL TO REFRESH ) ; } else if ( m State == State . PULL TO REFRESH && item Dimension < Math . abs ( new Scroll Value ) ) { set State ( State . RELEASE TO REFRESH ) ; } } }
public void parse ( Input Source input ) throws IO Exception , SAX Exception { if ( parsing ) { throw new SAX Exception ( STRING ) ; } setup Parser ( ) ; parsing = BOOL ; try { parser . parse ( input ) ; } finally { parsing = BOOL ; } parsing = BOOL ; }
private void release 0 ( long ptr , long size , Atomic Long cnt ) { if ( ptr != NUM ) { if ( SAFE RELEASE ) fill ( ptr , size , ( byte ) NUM ) ; Grid Unsafe . free Memory ( ptr ) ; cnt . add And Get ( - size ) ; if ( lsnr != null ) lsnr . on Event ( RELEASE ) ; } }
public void add Services ( List < Service Definition > services ) throws Exception { ensure Path Exists ( ) ; Set < String > remaining Descriptors = new Hash Set < > ( data Manager . get Children ( ZK SERVICE DEFINITION PATH ) ) ; for ( Service Definition service : services ) { LOG . debug ( String . format ( STRING , service . service Id ) ) ; String path = get Service Definition Path ( service . service Id ) ; try { Stat before = data Manager . check Exists ( path ) ; data Manager . put Data ( path , service ) ; Stat after = data Manager . check Exists ( path ) ; node Updated ( path , before , after ) ; remaining Descriptors . remove ( service . service Id ) ; } catch ( Exception e ) { LOG . error ( String . format ( STRING , service . service Id , path ) , e ) ; throw e ; } } for ( String descriptor Name : remaining Descriptors ) { LOG . info ( String . format ( STRING , descriptor Name ) ) ; data Manager . remove Node ( ZK SERVICE DEFINITION PATH + STRING + descriptor Name ) ; } }
protected void read Props ( ) { int count ; Properties props ; int i ; String item Str ; T item ; m Ignore Changes = BOOL ; props = load Props ( ) ; count = Integer . parse Int ( props . get Property ( expand ( get Count Key ( ) ) , STRING ) ) ; m Recent Items . clear ( ) ; for ( i = count - NUM ; i >= NUM ; i -- ) { item Str = props . get Property ( get Item Prefix ( ) + i , STRING ) ; if ( item Str . length ( ) > NUM ) { item = from String ( item Str ) ; if ( check ( item ) ) add Recent Item ( item ) ; } } m Ignore Changes = BOOL ; }
public Form Index step Index Out ( Form Index index ) { if ( index . is Terminal ( ) ) { return null ; } else { return new Form Index ( step Index Out ( index . get Next Level ( ) ) , index ) ; } }
protected double kernel Helper LP ( int n , char [ ] s , int end Index S , char [ ] t , int end Index T , int remaining Match Length ) { if ( n == NUM ) { return get Return Value ( n ) ; } if ( Math . min ( end Index S + NUM , end Index T + NUM ) < n ) { ; return get Return Value ( n ) ; } if ( remaining Match Length < NUM * n ) { return get Return Value ( n ) ; } int adr = NUM ; if ( m use Recursion Cache ) { adr = m mult X * n + m mult Y * end Index S + m mult Z * end Index T + m mult ZZ * remaining Match Length ; if ( cachekh 2 K [ adr % max Cache ] == adr + NUM ) { return cachekh 2 [ adr % max Cache ] ; } } int rml = NUM ; double result = NUM ; for ( int iS = ( end Index S - remaining Match Length ) ; iS <= end Index S ; iS ++ ) { result *= m lambda ; result += kernel Helper 2 LP ( n , s , iS , t , end Index T , rml ++ ) ; } if ( m use Recursion Cache && end Index S >= NUM && end Index T >= NUM && n >= NUM ) { cachekh K [ adr % max Cache ] = adr + NUM ; cachekh [ adr % max Cache ] = result ; } return result ; }
@ Override protected synchronized void on Measure ( int width Measure Spec , int height Measure Spec ) { int width = NUM ; if ( Measure Spec . UNSPECIFIED != Measure Spec . get Mode ( width Measure Spec ) ) { width = Measure Spec . get Size ( width Measure Spec ) ; } int height = thumb Image . get Height ( ) ; if ( Measure Spec . UNSPECIFIED != Measure Spec . get Mode ( height Measure Spec ) ) { height = Math . min ( height , Measure Spec . get Size ( height Measure Spec ) ) ; } set Measured Dimension ( width , height ) ; }
public void start ( ) { calculate Position Array ( ) ; set Preferred Size ( calculate Preferred Size ( ) ) ; offset = get Width ( ) ; timer = new Timer ( interval , this ) ; timer . start ( ) ; }
public static void write Plain File ( String file Path , byte [ ] content ) throws IO Exception { File Output Stream file Ouput Stream = new File Output Stream ( file Path ) ; file Ouput Stream . write ( content ) ; file Ouput Stream . close ( ) ; }
public void transform ( Affine Transform at ) { clip [ NUM ] = clip [ NUM ] ; clip [ NUM ] = clip [ NUM ] ; clip [ NUM ] = clip [ NUM ] ; clip [ NUM ] = clip [ NUM ] ; at . transform ( clip , NUM , clip , NUM , NUM ) ; double xmin = clip [ NUM ] , ymin = clip [ NUM ] ; double xmax = clip [ NUM ] , ymax = clip [ NUM ] ; for ( int i = NUM ; i < NUM ; i += NUM ) { if ( clip [ i ] < xmin ) xmin = clip [ i ] ; if ( clip [ i ] > xmax ) xmax = clip [ i ] ; if ( clip [ i + NUM ] < ymin ) ymin = clip [ i + NUM ] ; if ( clip [ i + NUM ] > ymax ) ymax = clip [ i + NUM ] ; } clip [ NUM ] = xmin ; clip [ NUM ] = ymin ; clip [ NUM ] = xmax ; clip [ NUM ] = ymax ; }
@ Suppress Warnings ( STRING ) public boolean is Portable Filename ( String filename ) { return ( filename . starts With ( PROGRAM ) || filename . starts With ( HOME ) || filename . starts With ( PREFERENCES ) || filename . starts With ( SCRIPTS ) || filename . starts With ( PROFILE ) || filename . starts With ( SETTINGS ) || filename . starts With ( FILE ) || filename . starts With ( RESOURCE ) ) ; }
void configure Basic Auth ( Http Server Request server Request , Http Client Request http Client Request ) { final String authorization = server Request . get Param ( STRING ) ; if ( authorization != null ) { http Client Request . put Header ( Http Headers . AUTHORIZATION , authorization ) ; } }
public void rejected Execution ( Runnable r , Thread Pool Executor e ) { if ( ! e . is Shutdown ( ) ) { r . run ( ) ; } }
public boolean node Change ( Catalog Tree Node node , String name ) { Catalog Tree Node c Node = get Corresponding Node ( node ) ; c Node . set Leaves ( node . get Leaves ( ) ) ; Abstract Catalog Tree tree = ( Abstract Catalog Tree ) get Coresponding Model ( node ) ; c Node . set User Object ( name ) ; node . set User Object ( name ) ; tree . node Changed ( c Node ) ; model . node Changed ( node ) ; update Panel ( ) ; Image Index Editor . index Changed ( BOOL ) ; update Panel ( ) ; return BOOL ; }
public static Enumeration all ( ) { return all . elements ( ) ; }
public boolean wait Until Empty ( long timeout ) throws Interrupted Exception { if ( ! notify Lock . try Lock ( timeout , Time Unit . MILLISECONDS ) ) { return BOOL ; } try { return pending . is Empty ( ) || notify Condition . await ( timeout , Time Unit . MILLISECONDS ) ; } finally { notify Lock . unlock ( ) ; } }
public static Set < Java Class And Method > resolve Method Call Targets ( Reference Type receiver Type , Invoke Instruction invoke Instruction , Constant Pool Gen cpg ) throws Class Not Found Exception { return resolve Method Call Targets ( receiver Type , invoke Instruction , cpg , BOOL ) ; }
private String safe ( String src ) { String Buffer sb = new String Buffer ( ) ; for ( int i = NUM ; i < src . length ( ) ; i ++ ) { char c = src . char At ( i ) ; if ( c >= NUM && c < NUM ) { sb . append ( c ) ; } else { sb . append ( STRING + ( int ) c + STRING ) ; } } return sb . to String ( ) ; }
public Algorithm ( Element el ) { required Key = el . get Attribute ( STRING ) ; jce Name = el . get Attribute ( STRING ) ; algorithm Class = el . get Attribute ( STRING ) ; if ( el . has Attribute ( STRING ) ) { key Length = Integer . parse Int ( el . get Attribute ( STRING ) ) ; } else { key Length = NUM ; } }
protected abstract boolean is SSL Socket ( ) ;
private Run consume Run ( int offset ) { char ch = f Text . char At ( offset ) ; int length = f Text . length ( ) ; Run run = get Run ( ch ) ; while ( run . consume ( ch ) && offset < length - NUM ) { offset ++ ; ch = f Text . char At ( offset ) ; } return run ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static String format For UI ( Calendar today , Calendar date ) { if ( today . get ( Calendar . YEAR ) == date . get ( Calendar . YEAR ) ) { if ( today . get ( Calendar . DAY OF YEAR ) == date . get ( Calendar . DAY OF YEAR ) ) { return STRING ; } return current Year Date Format ( date . get Time In Millis ( ) ) ; } else { return format ( date . get Time In Millis ( ) ) ; } }
public Output Stream Writer ( Output Stream out , Charset Encoder enc ) { super ( out ) ; if ( enc == null ) throw new Null Pointer Exception ( STRING ) ; se = Stream Encoder . for Output Stream Writer ( out , this , enc ) ; }
public synchronized void free ( long pos , int length ) { int start = get Block ( pos ) ; int blocks = get Block Count ( length ) ; Block Range x = new Block Range ( start , blocks ) ; Block Range next = free Space . ceiling ( x ) ; if ( next == null ) { throw Data Utils . new Illegal State Exception ( Data Utils . ERROR INTERNAL , STRING ) ; } Block Range prev = free Space . lower ( x ) ; if ( prev != null ) { if ( prev . start + prev . blocks == start ) { prev . blocks += blocks ; if ( prev . start + prev . blocks == next . start ) { prev . blocks += next . blocks ; free Space . remove ( next ) ; } return ; } } if ( start + blocks == next . start ) { next . start -= blocks ; next . blocks += blocks ; return ; } free Space . add ( x ) ; }
private static void decode Hanzi Segment ( Bit Source bits , String Builder result , int count ) throws Format Exception { if ( count * NUM > bits . available ( ) ) { throw Format Exception . get Format Instance ( ) ; } byte [ ] buffer = new byte [ NUM * count ] ; int offset = NUM ; while ( count > NUM ) { int two Bytes = bits . read Bits ( NUM ) ; int assembled Two Bytes = ( ( two Bytes / NUM ) << NUM ) | ( two Bytes % NUM ) ; if ( assembled Two Bytes < NUM ) { assembled Two Bytes += NUM ; } else { assembled Two Bytes += NUM ; } buffer [ offset ] = ( byte ) ( ( assembled Two Bytes > > NUM ) & NUM ) ; buffer [ offset + NUM ] = ( byte ) ( assembled Two Bytes & NUM ) ; offset += NUM ; count -- ; } try { result . append ( new String ( buffer , String Utils . GB 2312 ) ) ; } catch ( Unsupported Encoding Exception ignored ) { throw Format Exception . get Format Instance ( ) ; } }
public URI csrf Token ( ) { URI Builder builder = api Builder ( ) ; builder . set Parameter ( STRING , STRING ) ; builder . set Parameter ( STRING , STRING ) ; builder . set Parameter ( STRING , STRING ) ; return build ( builder ) ; }
private static char [ ] zz Unpack C Map ( String packed ) { char [ ] map = new char [ NUM ] ; int i = NUM ; int j = NUM ; while ( i < NUM ) { int count = packed . char At ( i ++ ) ; char value = packed . char At ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM ) ; } return map ; }
public Distributed Log Multi Stream Writer build ( ) { Preconditions . check Argument ( ( null != streams && ! streams . is Empty ( ) ) , STRING ) ; Preconditions . check Not Null ( client , STRING ) ; Preconditions . check Not Null ( codec , STRING ) ; Preconditions . check Argument ( first Speculative Timeout Ms > NUM && first Speculative Timeout Ms <= max Speculative Timeout Ms && speculative Backoff Multiplier > NUM && max Speculative Timeout Ms < request Timeout Ms , STRING ) ; return new Distributed Log Multi Stream Writer ( streams , client , Math . min ( buffer Size , MAX LOGRECORDSET SIZE ) , flush Interval Ms , request Timeout Ms , first Speculative Timeout Ms , max Speculative Timeout Ms , speculative Backoff Multiplier , codec , ticker , executor Service ) ; }
private void write Chars ( int number , char c ) throws IO Exception { for ( ; number > NUM ; number -- ) { writer . write ( c ) ; } }
@ Override public void error ( String msg , Throwable t ) { if ( logger . is Loggable ( Level . SEVERE ) ) { log ( SELF , Level . SEVERE , msg , t ) ; } }
public int exit signal ( ) { return Integer . parse Int ( fields [ NUM ] ) ; }
public Command ( ) { msg Queue = new Linked List < Message > ( ) ; msg Queue . clear ( ) ; }
public synchronized int index Of ( V item ) { return items . index Of ( item ) ; }
protected void create Node ( Default Mutable Tree Node top , String title , String info , String content , int line Count ) { Default Mutable Tree Node thread Info = null ; thread Info = new Default Mutable Tree Node ( new Thread Info ( title , info , content , line Count , get Thread Tokens ( title ) ) ) ; top . add ( thread Info ) ; }
public Peer clone ( ) { Peer clone = new Peer ( network . clone ( ) , address ) ; return clone ; }
public static String generate Native Guid ( String device Type , String serial Number , String file Share Native Id ) { return String . format ( STRING + FILESYSTEM + STRING , device Type Map . get ( device Type ) , serial Number , file Share Native Id ) ; }
public Str Builder ensure Capacity ( final int capacity ) { if ( capacity > buffer . length ) { final char [ ] old = buffer ; buffer = new char [ capacity * NUM ] ; System . arraycopy ( old , NUM , buffer , NUM , size ) ; } return this ; }
private void on Start Tracking Touch ( ) { m Is Dragging = BOOL ; }
private static void create Super Forwarder ( Class Node target Node , Method Node forwarder , final Map < String , Class Node > generics Spec ) { List < Class Node > interfaces = new Array List < Class Node > ( Traits . collect All Interfaces Reverse Order ( target Node , new Linked Hash Set < Class Node > ( ) ) ) ; String name = forwarder . get Name ( ) ; Parameter [ ] forwarder Parameters = forwarder . get Parameters ( ) ; Linked Hash Set < Class Node > traits = new Linked Hash Set < Class Node > ( ) ; List < Method Node > super Forwarders = new Linked List < Method Node > ( ) ; for ( Class Node node : interfaces ) { if ( Traits . is Trait ( node ) ) { Method Node method = node . get Declared Method ( name , forwarder Parameters ) ; if ( method != null ) { traits . add ( node ) ; super Forwarders . add ( method ) ; } } } for ( Method Node super Forwarder : super Forwarders ) { do Create Super Forwarder ( target Node , super Forwarder , traits . to Array ( new Class Node [ traits . size ( ) ] ) , generics Spec ) ; } }
public void test Case 15 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { NUM } ; int a Sign = - NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public boolean is Virtual Pool Accessible ( Virtual Pool resource ) { return permissions Helper . tenant Has Usage ACL ( URI . create ( user . get Tenant Id ( ) ) , resource ) ; }
public void test Timed Invoke All Null Time Unit ( ) throws Throwable { Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Callable < String > > l = new Array List < Callable < String > > ( ) ; l . add ( new String Task ( ) ) ; try { e . invoke All ( l , MEDIUM DELAY MS , null ) ; should Throw ( ) ; } catch ( Null Pointer Exception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
private static boolean intersects One Of ( final Rectangle 2 D r , final Collection < ? extends Shape > shapes ) { if ( shapes . is Empty ( ) ) { return BOOL ; } for ( final Shape item : shapes ) { if ( item . intersects ( r ) ) { return BOOL ; } } return BOOL ; }
private void expected Byte ( int position , int count ) throws UTF Data Format Exception { throw new UTF Data Format Exception ( Localizer . get Message ( STRING , Integer . to String ( position ) , Integer . to String ( count ) ) ) ; }
private List < String > check Config List ( Configuration config , String name ) { String peer I Ps = config . get Config ( name ) ; Array List < String > peers = new Array List < String > ( ) ; if ( peer I Ps != null ) { for ( String ip : String Utils . split ( peer I Ps , STRING ) ) { peers . add ( ip ) ; } } return peers ; }
public final Byte Buffer encode ( Char Buffer in ) throws Character Coding Exception { int length = ( int ) ( in . remaining ( ) * average Bytes Per Char ) ; Byte Buffer out = Byte Buffer . allocate ( length ) ; reset ( ) ; while ( state != FLUSHED ) { Coder Result result = encode ( in , out , BOOL ) ; if ( result == Coder Result . OVERFLOW ) { out = allocate More ( out ) ; continue ; } else { check Coder Result ( result ) ; } result = flush ( out ) ; if ( result == Coder Result . OVERFLOW ) { out = allocate More ( out ) ; } else { check Coder Result ( result ) ; } } out . flip ( ) ; return out ; }
private void load External ( ) { Properties properties = new Properties ( ) ; try { properties . load From XML ( new File Input Stream ( PROPERTIES PATH ) ) ; for ( String key : properties . string Property Names ( ) ) { external Support . put ( key , properties . get Property ( key ) ) ; } } catch ( IO Exception ignore ) { } }
public static URI parse URI ( String nuri , URI baseuri ) throws URI Syntax Exception { int colon Location = nuri . index Of ( STRING ) ; int fragment Location = get Fragment Location ( nuri ) ; if ( colon Location == - NUM || colon Location > fragment Location ) { if ( baseuri == null ) throw new URI Syntax Exception ( STRING + nuri + STRING + STRING , nuri ) ; } String protocol = nuri . substring ( NUM , colon Location ) ; if ( protocol . equals ( STRING ) ) { return parse URN ( nuri , colon Location , fragment Location ) ; } else if ( protocol . equals ( STRING ) ) { return new URI ( nuri ) ; } else if ( protocol . equals ( STRING ) ) { return new URI ( nuri ) ; } else if ( protocol . equals ( STRING ) ) { return new URI ( nuri ) ; } else { return parse General URI ( nuri , colon Location , fragment Location ) ; } }
protected void update Us ( ) { try { set Text ( m Editor . get As Text ( ) ) ; } catch ( Illegal Argument Exception ex ) { } }
public File make Dirty ( ) throws IO Exception { File f = File . create Temp File ( STRING , STRING , repository Location . get Parent File ( ) ) ; File Writer fw = new File Writer ( f ) ; fw . write ( STRING + System . current Time Millis ( ) ) ; fw . flush ( ) ; fw . close ( ) ; return f ; }
private static boolean is ASCII Superset ( String encoding ) throws Exception { String chk S = STRING + STRING ; byte [ ] chk B = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte [ ] b = chk S . get Bytes ( encoding ) ; return Arrays . equals ( b , chk B ) ; }
public static Big Decimal allocated ( int p C Payment ID , int p C Currency ID ) throws SQL Exception { Big Decimal Pay Amt = null ; int C Charge ID = NUM ; String sql = STRING + STRING + STRING ; Prepared Statement pstmt = Adempiere . prepare Statement ( sql ) ; pstmt . set Int ( NUM , p C Payment ID ) ; Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { Pay Amt = rs . get Big Decimal ( NUM ) ; C Charge ID = rs . get Int ( NUM ) ; } rs . close ( ) ; pstmt . close ( ) ; if ( C Charge ID > NUM ) return Pay Amt ; int C Conversion Type ID = NUM ; Big Decimal allocated Amt = get Allocated Amt ( p C Payment ID , p C Currency ID , C Conversion Type ID ) ; return Currency . round ( allocated Amt , p C Currency ID , null ) ; }
public static Byte Buffer process Outbound Package ( Byte Buffer ro Data , int exchange Id , boolean connection Ok ) { ro Data . rewind ( ) ; if ( Build Config . DEBUG ) { Xposed Bridge . log ( STRING + Integer . to String ( ro Data . remaining ( ) ) ) ; } try { synchronized ( sync ) { } } catch ( Throwable e ) { Xposed Bridge . log ( e ) ; } return null ; }
public void initialize ( ) { if ( is Closed . get ( ) ) { logger . info ( STRING ) ; Actor Config . create And Get Actor System ( ) ; http Client Store . init ( ) ; tcp Ssh Ping Resource Store . init ( ) ; Parallel Task Manager . get Instance ( ) ; is Closed . set ( BOOL ) ; logger . info ( STRING ) ; } else { logger . debug ( STRING ) ; } }
@ Not Null private static Text Range process Spaces ( @ Not Null Helper helper , @ Not Null Text Range range , int tab Width ) { Char Sequence indent = helper . get Current Line Indent ( ) ; int start = Math . max ( NUM , range . get Start Offset ( ) - helper . get Current Line Start Offset ( ) ) ; int end = Math . min ( indent . length ( ) , range . get End Offset ( ) - helper . get Current Line Start Offset ( ) ) ; int tabs Number = NUM ; int indent Offset = end ; for ( int i = start ; i < end ; i ++ ) { char c = indent . char At ( i ) ; if ( c == STRING ) { tabs Number ++ ; } else if ( c != STRING ) { indent Offset = i ; break ; } } if ( tabs Number > NUM ) { helper . replace ( start , indent Offset , String Util . repeat ( STRING , indent Offset - start - tabs Number + tabs Number * tab Width ) ) ; return Text Range . create ( range . get Start Offset ( ) , range . get End Offset ( ) - tabs Number + tabs Number * tab Width ) ; } else { return range ; } }
public void remove Alarm ( final Alarm ALARM ) { if ( alarms . contains ( ALARM ) ) alarms . remove ( ALARM ) ; }
public int read ( ) throws java . io . IO Exception { synchronized ( lock ) { char char Array [ ] = new char [ NUM ] ; if ( read ( char Array , NUM , NUM ) != - NUM ) { return char Array [ NUM ] ; } return - NUM ; } }
protected void check Parameters ( ) { if ( parameters != null ) { for ( int i = NUM , size = parameters . size ( ) ; i < size ; i ++ ) { Parameter param = parameters . get ( i ) ; param . check Set ( ) ; } } }
private static Properties create Properties 1 ( String conflation ) { Properties props = new Properties ( ) ; props . set Property ( DELTA PROPAGATION , STRING ) ; props . set Property ( MCAST PORT , STRING ) ; props . set Property ( LOCATORS , STRING ) ; props . set Property ( CONFLATE EVENTS , conflation ) ; return props ; }
public static void CF 3 ( double [ ] x , double [ ] f , double [ ] c , int nx ) { int count 1 = NUM ; int count 2 = NUM ; double sum 1 = NUM ; double sum 2 = NUM ; double prod 1 = NUM ; double prod 2 = NUM ; double yj ; double pj ; double N = NUM ; double a = NUM ; for ( int j = NUM ; j <= nx ; j ++ ) { yj = x [ j - NUM ] - Math . sin ( NUM * PI * x [ NUM ] + j * PI / nx ) ; pj = Math . cos ( NUM * yj * PI / Math . sqrt ( j + NUM ) ) ; if ( j % NUM == NUM ) { sum 2 += yj * yj ; prod 2 *= pj ; count 2 ++ ; } else { sum 1 += yj * yj ; prod 1 *= pj ; count 1 ++ ; } } f [ NUM ] = x [ NUM ] + NUM * ( NUM * sum 1 - NUM * prod 1 + NUM ) / ( double ) count 1 ; f [ NUM ] = NUM - x [ NUM ] * x [ NUM ] + NUM * ( NUM * sum 2 - NUM * prod 2 + NUM ) / ( double ) count 2 ; c [ NUM ] = f [ NUM ] + f [ NUM ] * f [ NUM ] - a * Math . sin ( N * PI * ( f [ NUM ] * f [ NUM ] - f [ NUM ] + NUM ) ) - NUM ; }
public static void close Silently ( Result Set rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQL Exception e ) { } } }
public static void execute ( Pool Impl pool , Function function , Object args , Member Mapped Argument member Mapped Arg , boolean all Servers , byte has Result , boolean is Fn Serialization Reqd , String [ ] groups ) { List servers = null ; Abstract Op op = new Execute Function No Ack Op Impl ( function , args , member Mapped Arg , has Result , is Fn Serialization Reqd , groups , all Servers ) ; try { if ( all Servers && groups . length == NUM ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + op . get Message ( ) + STRING + pool ) ; } servers = pool . get Current Servers ( ) ; Iterator i = servers . iterator ( ) ; while ( i . has Next ( ) ) { pool . execute On ( ( Server Location ) i . next ( ) , op ) ; } } else { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + op . get Message ( ) + STRING + pool + STRING + Arrays . to String ( groups ) + STRING + all Servers ) ; } pool . execute ( op , NUM ) ; } } catch ( Exception ex ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + op . get Message ( ) + STRING + pool , ex ) ; } if ( ex . get Message ( ) != null ) throw new Function Exception ( ex . get Message ( ) , ex ) ; else throw new Function Exception ( STRING , ex ) ; } }
public static Script create Multi Sig Input Script ( Transaction Signature ... signatures ) { return create Multi Sig Input Script ( Arrays . as List ( signatures ) ) ; }
Object proxy If Return Type Is Jdbc Interface ( Class < ? > return Type , Object to Proxy ) { if ( to Proxy != null ) { if ( Util . is Jdbc Interface ( return Type ) ) { Class < ? > to Proxy Class = to Proxy . get Class ( ) ; return Proxy . new Proxy Instance ( to Proxy Class . get Class Loader ( ) , Util . get Implemented Interfaces ( to Proxy Class ) , get New Jdbc Interface Proxy ( to Proxy ) ) ; } } return to Proxy ; }
public final void empty ( ) { synchronized ( buffer ) { buffer . clear ( ) ; buffer Map . clear ( ) ; } }
public void test Moderately Complex Templating ( ) throws Exception { Html Page page = get Page ( STRING ) ; String text = page . as Text ( ) ; assert True ( text . contains ( STRING ) ) ; }
private Value Range range By Week ( Temporal Accessor temporal , Temporal Field field ) { int dow = localized Day Of Week ( temporal ) ; int offset = start Of Week Offset ( temporal . get ( field ) , dow ) ; Value Range field Range = temporal . range ( field ) ; return Value Range . of ( compute Week ( offset , ( int ) field Range . get Minimum ( ) ) , compute Week ( offset , ( int ) field Range . get Maximum ( ) ) ) ; }
public Object apply ( Object in ) { if ( in instanceof Has Word ) { Has Word w = ( Has Word ) in ; String str = w . word ( ) ; String out Str = americanize ( str , capitalize Timex ) ; if ( ! out Str . equals ( str ) ) { w . set Word ( out Str ) ; } return w ; } else { String str = ( String ) in ; return americanize ( str , capitalize Timex ) ; } }
public void add Way Ref ( Map Way way , int node Idx ) { if ( ways == null ) ways = new Array List < Way Ref > ( NUM ) ; if ( ways . is Empty ( ) || ways . get ( NUM ) != way ) ways . add ( new Default Way Ref ( way , ( short ) node Idx ) ) ; }
public double do Cross Validation ( Iterable < T > data , int data Size ) throws Interrupted Exception , Execution Exception { stats = new One Variable Stats ( ) ; log . info ( STRING + ( new Date ( ) ) ) ; log . info ( STRING + num Folds + STRING ) ; List < List < T > > splits = split Data ( data , data Size ) ; log . info ( STRING ) ; Executor Service executor = Executors . new Fixed Thread Pool ( num Threads ) ; List < Future Task < Double > > folds = new Array List < > ( ) ; for ( int i = NUM ; i < num Folds ; i ++ ) { List < T > training Set = new Array List < > ( ) ; for ( int j = NUM ; j < num Folds ; j ++ ) { if ( j != i ) training Set . add All ( splits . get ( j ) ) ; } List < T > test Set = splits . get ( i ) ; Future Task < Double > fold = create Fold Task ( training Set , test Set , i ) ; executor . execute ( fold ) ; folds . add ( fold ) ; } executor . shutdown ( ) ; executor . await Termination ( timeout Seconds , Time Unit . SECONDS ) ; for ( Future Task < Double > fold : folds ) { stats . add ( fold . get ( ) ) ; } log . info ( STRING + ( new Date ( ) ) ) ; return stats . mean ( ) ; }
public Entire Text Builder add Background ( @ Color Int int bg Color , int start , int end ) { Background Holder background Holder = new Background Holder ( bg Color , start , end ) ; m Backgrounds . add ( background Holder ) ; return this ; }
public void remove Changing Listener ( On Wheel Changed Listener listener ) { changing Listeners . remove ( listener ) ; }
public boolean matches ( String filename ) { if ( exts == null ) return BOOL ; int j = filename . last Index Of ( STRING ) ; if ( j == - NUM || j == filename . length ( ) ) return BOOL ; String suffix = filename . substring ( j + NUM ) ; return exts . contains ( suffix ) ; }
public Rectangle [ ] compute Gaps ( ) { Array List < Rectangle > ret = new Array List < > ( ) ; Rectangle gap = new Rectangle ( ) ; for ( int i = NUM ; i < m Rect List . length ; i ++ ) { Rectangle rectangle A = m Rect List [ i ] ; for ( int j = i + NUM ; j < m Rect List . length ; j ++ ) { Rectangle rectangle B = m Rect List [ j ] ; boolean viable = calculate Gap ( rectangle A , rectangle B , gap ) ; if ( viable ) { for ( int k = NUM ; k < m Rect List . length ; k ++ ) { if ( k != j && k != i ) { if ( gap . intersects ( m Rect List [ k ] ) ) { viable = BOOL ; break ; } } } } if ( viable ) { ret . add ( new Rectangle ( gap ) ) ; } } } return ret . to Array ( new Rectangle [ ret . size ( ) ] ) ; }
public synchronized Method Count Set collect Hot Methods ( int opt Level , double threshold ) { if ( DEBUG ) validity Check ( ) ; Array List < Hot Method Recompilation Event > collect = new Array List < Hot Method Recompilation Event > ( ) ; collect Hot Opt Methods Internal ( NUM , collect , hotness To Counts ( threshold ) , opt Level ) ; int num Hot Methods = collect . size ( ) ; double [ ] num Counts = new double [ num Hot Methods ] ; Compiled Method [ ] hot Methods = new Compiled Method [ num Hot Methods ] ; for ( int i = NUM ; i < num Hot Methods ; i ++ ) { Hot Method Event event = collect . get ( i ) ; hot Methods [ i ] = event . get Compiled Method ( ) ; num Counts [ i ] = event . get Num Samples ( ) ; } return new Method Count Set ( hot Methods , num Counts ) ; }
public synchronized void add Ban ( long duration , String reason , String id ) { add Line ( new Ban Message ( System . current Time Millis ( ) , duration , reason , id ) ) ; }
private void write Header ( ) throws Open Stego Exception { DCT Data Header header = null ; try { header = new DCT Data Header ( this . data Length , this . file Name , this . config ) ; if ( ( ( header . get Header Size ( ) + this . data Length ) * NUM ) > ( this . img Width * this . img Height / ( DCT . NJPEG * DCT . NJPEG ) ) ) { throw new Open Stego Exception ( null , Dct LSB Plugin . NAMESPACE , Dct LSB Errors . IMAGE SIZE INSUFFICIENT ) ; } this . coord = new Coordinates ( ( header . get Header Size ( ) + this . data Length ) * NUM ) ; write ( header . get Header Data ( ) ) ; } catch ( IO Exception io Ex ) { throw new Open Stego Exception ( io Ex ) ; } }
public int decrement Subscriber Count ( ) { if ( is Available ( ) ) { return jmdns Subscriber Count . decrement And Get ( ) ; } return NUM ; }
public static boolean add Shapeless Enchanting Recipe ( Item Stack a Result , Enchantment [ ] a Enchantments Added , int [ ] a Enchantment Levels Added , Object [ ] a Recipe ) { return add Shapeless Crafting Recipe ( a Result , a Enchantments Added , a Enchantment Levels Added , BOOL , BOOL , BOOL , BOOL , a Recipe ) ; }
public void start ( ) throws Tomcat Exception { if ( cat == null ) init ( ) ; cat . start ( ) ; }
@ Override public synchronized void initialize ( ) { if ( ! m Root Directory . exists ( ) ) { if ( ! m Root Directory . mkdirs ( ) ) { Volley Log . e ( STRING , m Root Directory . get Absolute Path ( ) ) ; } return ; } File [ ] files = m Root Directory . list Files ( ) ; if ( files == null ) { return ; } for ( File file : files ) { Buffered Input Stream fis = null ; try { fis = new Buffered Input Stream ( new File Input Stream ( file ) ) ; Cache Header entry = Cache Header . read Header ( fis ) ; entry . size = file . length ( ) ; put Entry ( entry . key , entry ) ; } catch ( IO Exception e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IO Exception ignored ) { } } } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
private List < View > add View ( View view , List < View > cache ) { if ( cache == null ) { cache = new Linked List < View > ( ) ; } cache . add ( view ) ; return cache ; }
private boolean image Outline ( Default Mutable Tree Node node ) { boolean is Outline = BOOL ; if ( node != null ) { Default Mutable Tree Node parent Node = ( Default Mutable Tree Node ) node . get Parent ( ) ; if ( parent Node != null ) { if ( parent Node . get User Object ( ) instanceof Raster Symbolizer ) { is Outline = BOOL ; } } } return is Outline ; }
private short add Entry ( Entry entry ) { pool . add ( entry ) ; if ( pool . size ( ) >= NUM ) { throw new Illegal Argument Exception ( STRING ) ; } return ( short ) pool . size ( ) ; }
private boolean load Next Page ( ) { result = pageable . get Page ( query , skip , page Size ) ; index = NUM ; if ( result == null || result . is Empty ( ) ) { return BOOL ; } return BOOL ; }
public boolean contains ( Node s ) { run To ( - NUM ) ; if ( null == m map ) return BOOL ; for ( int i = NUM ; i < m first Free ; i ++ ) { Node node = m map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) return BOOL ; } return BOOL ; }
public void close ( ) throws IO Exception { if ( ! closed ) { if ( uses Default Inflater ) inf . end ( ) ; in . close ( ) ; closed = BOOL ; } }
public Field Analysis Request add Field Type ( String field Type Name ) { if ( field Types == null ) { field Types = new Linked List < > ( ) ; } field Types . add ( field Type Name ) ; return this ; }
public static Big Fraction parse Edit Rate ( String edit Rate ) { edit Rate = edit Rate . contains ( STRING ) ? r Frame Rate To Edit Rate ( edit Rate ) : edit Rate ; String [ ] parts = edit Rate . split ( STRING ) ; try { if ( parts . length == NUM ) { return new Big Fraction ( Long . parse Long ( parts [ NUM ] ) , Long . parse Long ( parts [ NUM ] ) ) ; } else if ( parts . length == NUM ) { return new Big Fraction ( Long . parse Long ( parts [ NUM ] ) ) ; } } catch ( Number Format Exception e ) { throw new Conversion Helper Exception ( STRING , e ) ; } throw new Conversion Helper Exception ( STRING ) ; }
public FST < T > finish ( ) throws IO Exception { final Un Compiled Node < T > root = frontier [ NUM ] ; freeze Tail ( NUM ) ; if ( root . input Count < min Suffix Count 1 || root . input Count < min Suffix Count 2 || root . num Arcs == NUM ) { if ( fst . empty Output == null ) { return null ; } else if ( min Suffix Count 1 > NUM || min Suffix Count 2 > NUM ) { return null ; } } else { if ( min Suffix Count 2 != NUM ) { compile All Targets ( root , last Input . length ( ) ) ; } } fst . finish ( compile Node ( root , last Input . length ( ) ) . node ) ; if ( do Pack FST ) { return fst . pack ( this , NUM , Math . max ( NUM , ( int ) ( get Node Count ( ) / NUM ) ) , acceptable Overhead Ratio ) ; } else { return fst ; } }
public void on Configuration ( Contacts Ops . View view , boolean first Time In ) { m Contacts View = new Weak Reference < > ( view ) ; if ( first Time In ) { initialize Account ( ) ; m Cursor Adapter = new Simple Cursor Adapter ( view . get Application Context ( ) , R . layout . list layout , null , s Columns To Display , s Column Res Ids , NUM ) ; } }
public static final int random Unset Bit ( Random r , Bit Set bits , final int max ) { if ( bits . cardinality ( ) == max + NUM ) { return - NUM ; } final int candidate = Test Util . next Int ( r , NUM , max ) ; if ( bits . get ( candidate ) ) { final int lo = bits . previous Clear Bit ( candidate ) ; final int hi = bits . next Clear Bit ( candidate ) ; if ( lo < NUM && max < hi ) { fail ( STRING + bits . cardinality ( ) + STRING + bits . size ( ) ) ; } else if ( lo < NUM ) { return hi ; } else if ( max < hi ) { return lo ; } return ( ( candidate - lo ) < ( hi - candidate ) ) ? lo : hi ; } return candidate ; }
@ Override public void flush ( ) throws IO Exception { synchronized ( lock ) { out . flush ( ) ; } }
public double std ( ) { if ( min == max || num == NUM ) { return NUM ; } double m = mean ( ) ; return Math . sqrt ( sigmax 2 / num - m * m ) ; }
public boolean contains Instruction ( Instruction Handle handle ) { Iterator < Instruction Handle > i = instruction Iterator ( ) ; while ( i . has Next ( ) ) { if ( i . next ( ) == handle ) { return BOOL ; } } return BOOL ; }
public static String send Fedex Request ( String xml String , Delegator delegator , String shipment Gateway Config Id , String resource , Locale locale ) throws Fedex Connect Exception { String url = get Shipment Gateway Config Value ( delegator , shipment Gateway Config Id , STRING , resource , STRING ) ; if ( Util Validate . is Empty ( url ) ) { throw new Fedex Connect Exception ( Util Properties . get Message ( resource Error , STRING , locale ) ) ; } if ( ! xml String . matches ( STRING ) ) { throw new Fedex Connect Exception ( Util Properties . get Message ( resource Error , STRING , locale ) ) ; } url = url . trim ( ) ; String time Out Str = get Shipment Gateway Config Value ( delegator , shipment Gateway Config Id , STRING , resource , STRING , STRING ) ; int timeout = NUM ; try { timeout = Integer . parse Int ( time Out Str ) ; } catch ( Number Format Exception e ) { Debug . log Error ( e , STRING + time Out Str + STRING + timeout ) ; } if ( Debug . verbose On ( ) ) { Debug . log Verbose ( STRING + url , module ) ; Debug . log Verbose ( STRING + xml String , module ) ; } Http Client http = new Http Client ( url ) ; http . set Timeout ( timeout * NUM ) ; String response = null ; try { response = http . post ( xml String ) ; } catch ( Http Client Exception e ) { Debug . log Error ( e , STRING , module ) ; throw new Fedex Connect Exception ( Util Properties . get Message ( resource Error , STRING , Util Misc . to Map ( STRING , e . to String ( ) ) , locale ) ) ; } if ( response == null ) { throw new Fedex Connect Exception ( Util Properties . get Message ( resource Error , STRING , locale ) ) ; } if ( Debug . verbose On ( ) ) { Debug . log Verbose ( STRING + response , module ) ; } return response ; }
public String trim To Size ( String str , int max String Length ) { if ( str == null ) return null ; if ( str . length ( ) > max String Length ) { String Builder sb = new String Builder ( str ) ; sb . set Length ( max String Length ) ; str = sb . to String ( ) ; } return str ; }
public Subject login ( String username , String password ) { if ( String Utils . is Blank ( username ) || String Utils . is Blank ( password ) ) return null ; Properties credentials = new Properties ( ) ; credentials . set Property ( Resource Constants . USER NAME , username ) ; credentials . set Property ( Resource Constants . PASSWORD , password ) ; return login ( credentials ) ; }
@ Timed @ Exception Metered @ Path ( STRING ) @ GET @ Produces ( APPLICATION JSON ) public Iterable < Sanitized Secret > secret Listing V 2 ( @ Auth Automation Client automation Client , @ Query Param ( STRING ) Integer idx , @ Query Param ( STRING ) Integer num , @ Default Value ( STRING ) @ Query Param ( STRING ) boolean newest First ) { if ( idx != null && num != null ) { if ( idx < NUM || num < NUM ) { throw new Bad Request Exception ( STRING ) ; } return secret Controller . get Secrets Batched ( idx , num , newest First ) ; } return secret Controller . get Sanitized Secrets ( null , null ) ; }
public void deselect ( Iterable < Integer > positions ) { Iterator < Integer > entries = positions . iterator ( ) ; while ( entries . has Next ( ) ) { deselect ( entries . next ( ) , entries ) ; } }
public static String map 2 OID ( String alg Name ) { check Cache Version ( ) ; String result = alg 2 Oid Map . get ( alg Name . to Upper Case ( Locale . US ) ) ; if ( result != null ) { return result ; } Alg Name Mapper Source s = source ; if ( s != null ) { return s . map Name To Oid ( alg Name ) ; } return null ; }
public Push History ( int max History Length , JSON Object json ) { this . max History Length = max History Length ; this . entries = new Priority Queue < Entry > ( max History Length + NUM ) ; this . push Ids = new Hash Set < String > ( max History Length + NUM ) ; this . last Time = null ; if ( json != null ) { JSON Object json History = json . opt JSON Object ( STRING ) ; if ( json History != null ) { Iterator < String > it = json History . keys ( ) ; while ( it . has Next ( ) ) { String push Id = ( String ) it . next ( ) ; String timestamp = json History . opt String ( push Id , null ) ; if ( push Id != null && timestamp != null ) { try Insert Push ( push Id , timestamp ) ; } } } set Last Received Timestamp ( json . opt String ( STRING , null ) ) ; } }
private void end List ( boolean ordered List ) { if ( ! m Paragraph Styles . is Empty ( ) ) { Accumulated Paragraph Style style = m Paragraph Styles . peek ( ) ; Paragraph Type type = style . get Type ( ) ; if ( ( ordered List && ( type . is Numbering ( ) || type == Paragraph Type . INDENTATION OL ) ) || ( ! ordered List && ( type . is Bullet ( ) || type == Paragraph Type . INDENTATION UL ) ) ) { int indent = style . get Relative Indent ( ) ; if ( indent > NUM ) { style . set Relative Indent ( indent - NUM ) ; style . set Absolute Indent ( style . get Absolute Indent ( ) - NUM ) ; } else { m Paragraph Styles . pop ( ) ; } } else { m Paragraph Styles . pop ( ) ; end List ( ordered List ) ; } } }
private boolean process Key Up ( int key Code ) { if ( key Code == Key Event . KEYCODE ESCAPE || key Code == Key Event . KEYCODE BACK ) { dismiss ( ) ; return BOOL ; } else if ( key Code == Key Event . KEYCODE TAB ) { if ( m In Kb Mode ) { if ( is Typed Time Fully Legal ( ) ) { finish Kb Mode ( BOOL ) ; } return BOOL ; } } else if ( key Code == Key Event . KEYCODE ENTER ) { if ( m In Kb Mode ) { if ( ! is Typed Time Fully Legal ( ) ) { return BOOL ; } finish Kb Mode ( BOOL ) ; } if ( m Callback != null ) { m Callback . on Time Set ( m Time Picker , m Time Picker . get Hours ( ) , m Time Picker . get Minutes ( ) ) ; } dismiss ( ) ; return BOOL ; } else if ( key Code == Key Event . KEYCODE DEL ) { if ( m In Kb Mode ) { if ( ! m Typed Times . is Empty ( ) ) { int deleted = delete Last Typed Key ( ) ; String deleted Key Str ; if ( deleted == get Am Or Pm Key Code ( AM ) ) { deleted Key Str = m Am Text ; } else if ( deleted == get Am Or Pm Key Code ( PM ) ) { deleted Key Str = m Pm Text ; } else { deleted Key Str = String . format ( STRING , get Val From Key Code ( deleted ) ) ; } Utils . try Accessibility Announce ( m Time Picker , String . format ( m Deleted Key Format , deleted Key Str ) ) ; update Display ( BOOL ) ; } } } else if ( key Code == Key Event . KEYCODE 0 || key Code == Key Event . KEYCODE 1 || key Code == Key Event . KEYCODE 2 || key Code == Key Event . KEYCODE 3 || key Code == Key Event . KEYCODE 4 || key Code == Key Event . KEYCODE 5 || key Code == Key Event . KEYCODE 6 || key Code == Key Event . KEYCODE 7 || key Code == Key Event . KEYCODE 8 || key Code == Key Event . KEYCODE 9 || ( ! m Is 24 Hour Mode && ( key Code == get Am Or Pm Key Code ( AM ) || key Code == get Am Or Pm Key Code ( PM ) ) ) ) { if ( ! m In Kb Mode ) { if ( m Time Picker == null ) { Log . e ( TAG , STRING ) ; return BOOL ; } m Typed Times . clear ( ) ; try Starting Kb Mode ( key Code ) ; return BOOL ; } if ( add Key If Legal ( key Code ) ) { update Display ( BOOL ) ; } return BOOL ; } return BOOL ; }
public boolean is Natural Join Column ( Column c ) { return natural Join Columns != null && natural Join Columns . contains ( c ) ; }
public int read ( byte [ ] b , int off , int len ) throws IO Exception { ensure Open ( ) ; if ( b == null ) { throw new Null Pointer Exception ( STRING ) ; } else if ( off < NUM || len < NUM || len > b . length - off ) { throw new Index Out Of Bounds Exception ( ) ; } else if ( len == NUM ) { return NUM ; } int cnt = NUM ; while ( len > NUM && ! def . finished ( ) ) { int n ; if ( def . needs Input ( ) ) { n = in . read ( buf , NUM , buf . length ) ; if ( n < NUM ) { def . finish ( ) ; } else if ( n > NUM ) { def . set Input ( buf , NUM , n ) ; } } n = def . deflate ( b , off , len ) ; cnt += n ; off += n ; len -= n ; } if ( cnt == NUM && def . finished ( ) ) { reach EOF = BOOL ; cnt = - NUM ; } return cnt ; }
@ Override public void passivate ( ) { cleanup User Transaction ( ) ; super . passivate ( ) ; }
public Builder delay ( long duration , Time Unit time Unit ) { this . delay = time Unit . to Seconds ( duration ) ; return this ; }
private boolean contains ( int part ) { return parts . contains ( part ) ; }
int key Count ( Class clazz ) { Map map = get ( clazz ) ; int count = map . size ( ) ; if ( map . contains Key ( CONSTRUCTORS KEY ) ) count -- ; if ( map . contains Key ( GENERIC GET KEY ) ) count -- ; if ( map . contains Key ( ARGTYPES KEY ) ) count -- ; return count ; }
public Mp 4 Stco Box ( Mp 4 Box Header header , Byte Buffer original Data Buffer , int adjustment ) { this . header = header ; this . data Buffer = original Data Buffer . slice ( ) ; data Buffer . position ( data Buffer . position ( ) + VERSION FLAG LENGTH + OTHER FLAG LENGTH ) ; this . no Of Off Sets = Utils . get Int BE ( data Buffer , data Buffer . position ( ) , ( data Buffer . position ( ) + NO OF OFFSETS LENGTH - NUM ) ) ; data Buffer . position ( data Buffer . position ( ) + NO OF OFFSETS LENGTH ) ; for ( int i = NUM ; i < no Of Off Sets ; i ++ ) { int offset = Utils . get Int BE ( data Buffer , data Buffer . position ( ) , ( data Buffer . position ( ) + NO OF OFFSETS LENGTH - NUM ) ) ; offset = offset + adjustment ; data Buffer . put ( Utils . get Size BE Int 32 ( offset ) ) ; } }
public static void create OPUS Directories ( Config config ) { log . info ( STRING ) ; Urban Sim Parameter Config Module V 3 module = M4 U Config Utils . get Urban Sim Parameter Config And Possibly Convert ( config ) ; File temp File = new File ( module . get Opus Home ( ) ) ; temp File . mkdirs ( ) ; temp File = new File ( module . get MAT Sim 4 Opus ( ) ) ; temp File . mkdirs ( ) ; temp File = new File ( module . get MAT Sim 4 Opus Output ( ) ) ; temp File . mkdirs ( ) ; temp File = new File ( module . get MAT Sim 4 Opus Temp ( ) ) ; temp File . mkdirs ( ) ; temp File = new File ( module . get MAT Sim 4 Opus Config ( ) ) ; temp File . mkdirs ( ) ; log . info ( STRING ) ; }
public static String lcfirst ( String input ) { return with First ( input , null ) ; }
void compress ( int page , byte [ ] old ) { byte [ ] [ ] array = data ; if ( page >= array . length ) { return ; } byte [ ] d = array [ page ] ; if ( d != old ) { return ; } synchronized ( LZF ) { int len = LZF . compress ( d , BLOCK SIZE , BUFFER , NUM ) ; if ( len <= BLOCK SIZE ) { d = new byte [ len ] ; System . arraycopy ( BUFFER , NUM , d , NUM , len ) ; byte [ ] o = array [ page ] ; if ( o != old ) { return ; } array [ page ] = d ; } } }
public Hadoop Process Descriptor local Process Descriptor ( ) { return loc Proc Desc ; }
private Pair < String , Boolean > describe Rain ( Calendar calendar , int temperature Mod ) { int month = calendar . get ( Calendar . MONTH ) ; month = NUM * Math . abs ( month - NUM ) ; int hour = calendar . get ( Calendar . HOUR OF DAY ) ; hour = Math . abs ( ( hour + NUM ) % NUM - NUM ) / NUM ; int temp = temperature . get Value ( ) - hour - month + ( temperature Mod * NUM ) ; LOGGER . debug ( STRING + temp + STRING + temperature Mod ) ; if ( temp <= - NUM ) { return new Pair < String , Boolean > ( STRING , Boolean . FALSE ) ; } return new Pair < String , Boolean > ( STRING , temp >= - NUM && thunder . get Description ( NUM ) != null ) ; }
@ Visible For Testing @ Called By Native Unchecked ( STRING ) public void add Child ( Bookmark Node child ) { m Children . add ( child ) ; }
public void test Get Min CRL ( ) { X509 CRL Selector selector = new X509 CRL Selector ( ) ; assert Null ( STRING , selector . get Min CRL ( ) ) ; Big Integer min CRL = new Big Integer ( STRING ) ; selector . set Min CRL Number ( min CRL ) ; assert True ( STRING , min CRL . equals ( selector . get Min CRL ( ) ) ) ; }
public void test When Complete exceptional Completion ( ) { for ( Execution Mode m : Execution Mode . values ( ) ) for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) f . complete Exceptionally ( ex ) ; final Completable Future < Integer > g = m . when Complete ( f , null ) ; if ( create Incomplete ) f . complete Exceptionally ( ex ) ; check Completed With Wrapped Exception ( g , ex ) ; check Completed Exceptionally ( f , ex ) ; assert Equals ( NUM , a . get ( ) ) ; } }
@ Override public String read ( String pattern ) { return read ( Pattern . compile ( pattern , Pattern . DOTALL | Pattern . MULTILINE ) ) ; }
protected void add Sub Keys And Aggregator ( Set < String > values , Set < String > keys Of Composite Aggregator , Set < String > sub Keys , String aggregator Name , Map < Set < String > , Integer > keys To Combination Id ) { if ( keys Of Composite Aggregator == null || sub Keys == null || keys Of Composite Aggregator . is Empty ( ) || sub Keys . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } Set < String > all Keys = Sets . new Hash Set ( ) ; all Keys . add All ( keys Of Composite Aggregator ) ; all Keys . add All ( sub Keys ) ; if ( all Keys . size ( ) != keys Of Composite Aggregator . size ( ) + sub Keys . size ( ) ) { throw new Illegal Argument Exception ( STRING + keys Of Composite Aggregator . to String ( ) + STRING + sub Keys ) ; } Integer combination Id = keys To Combination Id . get ( all Keys ) ; if ( combination Id == null ) { if ( dimensions Descriptor ID To Keys . add ( new Fields ( all Keys ) ) ) { combination Id = dimensions Descriptor ID To Keys . size ( ) - NUM ; } else { throw new Runtime Exception ( STRING + all Keys + STRING ) ; } keys To Combination Id . put ( all Keys , combination Id ) ; add Value To Aggregator To Combination ( values , all Keys , aggregator Name ) ; } else { Set < String > incremental Aggregator Names ; boolean is OTF Aggregator = BOOL ; if ( ! is Incremental Aggregator ( aggregator Name ) ) { incremental Aggregator Names = get OTF Depended Incremental Aggregator Names ( aggregator Name ) ; is OTF Aggregator = BOOL ; } else { incremental Aggregator Names = Sets . new Hash Set ( ) ; incremental Aggregator Names . add ( aggregator Name ) ; } Map < String , Set < String > > new Value To Incremental Aggregators = Maps . new Hash Map ( ) ; Map < String , Set < String > > new Value To OTF Aggregators = Maps . new Hash Map ( ) ; for ( String value : values ) { new Value To Incremental Aggregators . put ( value , incremental Aggregator Names ) ; if ( is OTF Aggregator ) { new Value To OTF Aggregators . put ( value , Sets . new Hash Set ( aggregator Name ) ) ; } } int ddid = combination Id * custom Time Buckets Combination . size ( ) ; for ( int index = NUM ; index < custom Time Buckets Combination . size ( ) ; ++ index , ++ ddid ) { merge Maps ( dimensions Descriptor ID To Value To Aggregator . get ( ddid ) , new Value To Incremental Aggregators ) ; merge Maps ( dimensions Descriptor ID To Value To OTF Aggregator . get ( ddid ) , new Value To OTF Aggregators ) ; } } }
protected boolean find Canonical Labelling ( boolean tmp Previously Equal To Min ) { boolean found New Minimum = BOOL ; Int Array List underlying Vertex Pos That Extend Tmp = get Underlying Vertex Pos That Extend Tmp ( ) ; Int Cursor underlying Vertex Pos That Extend Tmp Cursor = underlying Vertex Pos That Extend Tmp . cursor ( ) ; while ( underlying Vertex Pos That Extend Tmp Cursor . move Next ( ) ) { int underlying Vertex Pos To Add = underlying Vertex Pos That Extend Tmp Cursor . elem ( ) ; int new Tmp Vertex Pos = add Tmp Vertex ( underlying Vertex Pos To Add ) ; int new Tmp Vertex Label = underlying Pos To Label . get Unchecked ( underlying Vertex Pos To Add ) ; Int Set neighbour Underlying Positions = underlying Adjacency List . get ( underlying Vertex Pos To Add ) ; Int Cursor neighbour Underlying Positions Cursor = neighbour Underlying Positions . cursor ( ) ; Pattern Edge Array List edges To Add = create Pattern Edge Array List ( ) ; while ( neighbour Underlying Positions Cursor . move Next ( ) ) { int neighbour Underlying Pos = neighbour Underlying Positions Cursor . elem ( ) ; int neighbour Tmp Pos = tmp Labelling . get ( neighbour Underlying Pos ) ; if ( neighbour Tmp Pos == - NUM ) { continue ; } add Candidate Pattern Edges ( edges To Add , neighbour Underlying Pos , neighbour Tmp Pos , underlying Vertex Pos To Add , new Tmp Vertex Pos ) ; } if ( edges To Add . size ( ) > NUM || new Tmp Vertex Pos == NUM ) { edges To Add . sort ( ) ; boolean promising Tmp Pattern = BOOL ; boolean equal To Min Tmp Pattern = tmp Previously Equal To Min ; if ( found Minimum ) { int comparison Result ; if ( new Tmp Vertex Pos > NUM ) { Pattern Edge Array List min Equivalent Edges = min Edges . get ( new Tmp Vertex Pos ) ; comparison Result = edges To Add . compare To ( min Equivalent Edges ) ; } else { int min First Underlying Vertex Pos = min Inverse Labelling . get ( new Tmp Vertex Pos ) ; int min First Underyling Vertex Label = underlying Pos To Label . get Unchecked ( min First Underlying Vertex Pos ) ; comparison Result = Integer . compare ( new Tmp Vertex Label , min First Underyling Vertex Label ) ; } equal To Min Tmp Pattern = equal To Min Tmp Pattern && comparison Result == NUM ; if ( tmp Previously Equal To Min && ! equal To Min Tmp Pattern ) { if ( comparison Result > NUM ) { promising Tmp Pattern = BOOL ; } } } if ( promising Tmp Pattern ) { add Tmp Edges ( edges To Add ) ; if ( tmp Labelling . size ( ) == get Number Of Vertices ( ) ) { if ( ! equal To Min Tmp Pattern || ! found Minimum ) { copy Tmp To Min ( ) ; found New Minimum = BOOL ; vertex Position Equivalences . clear ( ) ; } Int Int Cursor tmp Labelling Cursor = tmp Labelling . cursor ( ) ; while ( tmp Labelling Cursor . move Next ( ) ) { int underlying Pos = tmp Labelling Cursor . key ( ) ; int tmp Equivalent Pos = tmp Labelling Cursor . value ( ) ; int underlying Pos According To Min = min Inverse Labelling . get ( tmp Equivalent Pos ) ; vertex Position Equivalences . add Equivalence ( underlying Pos , underlying Pos According To Min ) ; } } else { boolean found New Minimum In Child = find Canonical Labelling ( equal To Min Tmp Pattern ) ; if ( found New Minimum In Child ) { tmp Previously Equal To Min = BOOL ; found New Minimum = BOOL ; } } remove Last Tmp Edges ( ) ; } else { edges To Add . reclaim ( ) ; } } remove Last Tmp Vertex ( ) ; } underlying Vertex Pos That Extend Tmp . reclaim ( ) ; return found New Minimum ; }
private String construct ISCSI Names Query ( String system Id , List < Host Storage Domain > hsd List , String model ) { Map < String , Object > attribute Map = new Hash Map < String , Object > ( ) ; Storage Array array = new Storage Array ( system Id ) ; Add add Op = new Add ( HDS Constants . ISCSI NAME FOR HSD TARGET ) ; attribute Map . put ( HDS Constants . STORAGEARRAY , array ) ; attribute Map . put ( HDS Constants . ADD , add Op ) ; attribute Map . put ( HDS Constants . MODEL , model ) ; attribute Map . put ( HDS Constants . HOSTGROUP LIST , hsd List ) ; String add WWN Query = Input XML Generation Client . get Input XML String ( HDS Constants . BATCH ADD WWN TO HSD OP , attribute Map , HDS Constants . HITACHI INPUT XML CONTEXT FILE , HDS Constants . HITACHI SMOOKS CONFIG FILE ) ; return add WWN Query ; }
public static void try Claim ( Publication publication , Buffer Filler fill Buffer , int length , int timeout , Time Unit time Unit ) { if ( publication . is Closed ( ) ) { throw new Not Connected Exception ( ) ; } final Buffer Claim buffer Claim = buffer Claims . get ( ) ; final long start = System . nano Time ( ) ; do { final long current = System . nano Time ( ) ; if ( ( current - start ) > time Unit . to Nanos ( timeout ) ) { throw new Timed Out Exception ( ) ; } final long offer = publication . try Claim ( length , buffer Claim ) ; if ( offer >= NUM ) { try { final Mutable Direct Buffer buffer = buffer Claim . buffer ( ) ; final int offset = buffer Claim . offset ( ) ; fill Buffer . fill ( offset , buffer ) ; break ; } finally { buffer Claim . commit ( ) ; } } else if ( Publication . NOT CONNECTED == offer ) { throw new Not Connected Exception ( ) ; } } while ( BOOL ) ; }
Builder add Lenient ( String line ) { int index = line . index Of ( STRING , NUM ) ; if ( index != - NUM ) { return add Lenient ( line . substring ( NUM , index ) , line . substring ( index + NUM ) ) ; } else if ( line . starts With ( STRING ) ) { return add Lenient ( STRING , line . substring ( NUM ) ) ; } else { return add Lenient ( STRING , line ) ; } }
protected boolean table Exists ( Table t ) throws SQL Exception { String sql = STRING + ( t . is Temporary ( ) ? STRING : ( STRING + t . get Schema ( ) + STRING ) ) + STRING + ( t . is Temporary ( ) ? ( t . get Schema ( ) + STRING ) : STRING ) + t . get Name ( ) + STRING ; Statement stmt = db Conn . create Statement ( ) ; try { Result Set rs = stmt . execute Query ( sql ) ; return rs . next ( ) ; } finally { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQL Exception e ) { } } } }
private void read Unlocked Thread ( ) { final long this Thread Id = Thread . current Thread ( ) . get Id ( ) ; final Integer entry = thread Lock Map . get ( this Thread Id ) ; assert entry != null ; if ( entry . int Value ( ) == NUM ) { thread Lock Map . remove ( this Thread Id ) ; } else { thread Lock Map . put ( this Thread Id , entry . int Value ( ) - NUM ) ; } }
boolean is Single Window Standard Offset ( ) { return window End . equals ( Local Date Time . MAX ) && time Definition == Time Definition . WALL && fixed Saving Amount Secs == null && last Rule List . is Empty ( ) && rule List . is Empty ( ) ; }
public void add ( Character ok ) { add ( ok . char Value ( ) ) ; }
private Workflow . Method delete Volumes Method ( URI system URI , List < URI > volume UR Is ) { return new Workflow . Method ( STRING , system URI , volume UR Is ) ; }
public boolean remove ( Accessible State state ) { if ( states == null ) { return BOOL ; } else { return states . remove Element ( state ) ; } }
public void test Radix 10 Pos ( ) { String value = STRING ; int radix = NUM ; Big Integer a Number = new Big Integer ( value , radix ) ; String result = a Number . to String ( radix ) ; assert True ( result . equals ( value ) ) ; }
public void output Example XML ( Print Writer writer , Attribute Rule rule ) { writer . print ( STRING + rule . get Name ( ) + STRING ) ; if ( rule . has Example ( ) ) { writer . print ( rule . get Example ( ) ) ; } else { output Attribute Value ( writer , rule . get Attribute Class ( ) ) ; } writer . print ( STRING ) ; }
private void before Value ( ) throws JSON Exception { if ( stack . is Empty ( ) ) { return ; } Scope context = peek ( ) ; if ( context == Scope . EMPTY ARRAY ) { replace Top ( Scope . NONEMPTY ARRAY ) ; newline ( ) ; } else if ( context == Scope . NONEMPTY ARRAY ) { out . append ( STRING ) ; newline ( ) ; } else if ( context == Scope . DANGLING KEY ) { out . append ( indent == null ? STRING : STRING ) ; replace Top ( Scope . NONEMPTY OBJECT ) ; } else if ( context != Scope . NULL ) { throw new JSON Exception ( STRING ) ; } }
public static double calculate Julian Date ( Gregorian Calendar cal ) { int year = cal . get ( Calendar . YEAR ) ; int month = cal . get ( Calendar . MONTH ) ; int day = cal . get ( Calendar . DAY OF MONTH ) ; month ++ ; if ( ( month == NUM ) || ( month == NUM ) ) { year -= NUM ; month += NUM ; } int A = year / NUM ; int B = ( int ) ( NUM - A + ( A / NUM ) ) ; int C = ( int ) ( NUM * ( float ) year ) ; int D = ( int ) ( NUM * ( float ) ( month + NUM ) ) ; double julian Date = ( double ) ( B + C + D + day ) + NUM ; return julian Date ; }
public boolean is Upload In Progress ( ) { return m Upload Started . get ( ) ; }
private int index Of ( int tab Id ) { return m Tab Id List . index Of ( tab Id ) ; }
public Ndef Message ( Ndef Record record , Ndef Record ... records ) { if ( record == null ) throw new Null Pointer Exception ( STRING ) ; for ( Ndef Record r : records ) { if ( r == null ) { throw new Null Pointer Exception ( STRING ) ; } } m Records = new Ndef Record [ NUM + records . length ] ; m Records [ NUM ] = record ; System . arraycopy ( records , NUM , m Records , NUM , records . length ) ; }
private int find Checkpoint Position ( int [ ] cids ) { if ( checkpoint Period < NUM ) { return - NUM ; } if ( cids . length == NUM ) { throw new Illegal Argument Exception ( ) ; } int first CID = cids [ NUM ] ; if ( ( first CID + NUM ) % checkpoint Period == NUM ) { return cid Position ( cids , first CID ) ; } else { int next Ckp Index = ( ( ( first CID / checkpoint Period ) + NUM ) * checkpoint Period ) - NUM ; if ( next Ckp Index <= cids [ cids . length - NUM ] ) { return cid Position ( cids , next Ckp Index ) ; } } return - NUM ; }
private boolean read Next Line ( ) throws IO Exception { if ( header Lines . has More Elements ( ) ) { try { pos = NUM ; String line = ( header Lines . next Element ( ) + LINE SEPERATOR ) ; if ( ! header Lines . has More Elements ( ) ) { line += LINE SEPERATOR ; } curr Line = line . get Bytes ( STRING ) ; return BOOL ; } catch ( Unsupported Encoding Exception e ) { throw new IO Exception ( STRING ) ; } } else { return BOOL ; } }
private boolean pause ( ) { try { U . await ( pause Latch , REMAP PAUSE , MILLISECONDS ) ; return BOOL ; } catch ( Ignite Interrupted Checked Exception e ) { on Done ( e ) ; return BOOL ; } }
public static Input Stream to Input Stream ( final Char Sequence input ) { return IO Utils . to Input Stream ( input , Charset . default Charset ( ) ) ; }
private static ITL Rest Rep create Initiator Target Ref Rep ( Export Group export Group , Block Object block Object , String hlu , Initiator initiator , Storage Port port , FC Zone Reference fc Zone Reference ) { ITL Rest Rep rep = new ITL Rest Rep ( ) ; rep . set Hlu ( Integer . parse Int ( hlu ) ) ; ITL Rest Rep . ITL Block Object Rest Rep block Object Rest Rep = new ITL Rest Rep . ITL Block Object Rest Rep ( ) ; block Object Rest Rep . set Id ( block Object . get Id ( ) ) ; block Object Rest Rep . set Link ( new Rest Link Rep ( STRING , Rest Link Factory . new Link ( block Object ) ) ) ; block Object Rest Rep . set Wwn ( get Block Object Formatted WWN ( block Object ) ) ; rep . set Block Object ( block Object Rest Rep ) ; ITL Rest Rep . ITL Initiator Rest Rep initiator Rest Rep = new ITL Rest Rep . ITL Initiator Rest Rep ( ) ; initiator Rest Rep . set Id ( initiator . get Id ( ) ) ; initiator Rest Rep . set Link ( new Rest Link Rep ( STRING , Rest Link Factory . new Link ( initiator ) ) ) ; initiator Rest Rep . set Port ( initiator . get Initiator Port ( ) ) ; rep . set Initiator ( initiator Rest Rep ) ; ITL Rest Rep . ITL Storage Port Rest Rep storage Port Rest Rep = new ITL Rest Rep . ITL Storage Port Rest Rep ( ) ; if ( port != null ) { storage Port Rest Rep . set Id ( port . get Id ( ) ) ; storage Port Rest Rep . set Link ( new Rest Link Rep ( STRING , Rest Link Factory . new Link ( port ) ) ) ; storage Port Rest Rep . set Port ( port . get Port Network Id ( ) ) ; if ( port . get Ip Address ( ) != null ) { storage Port Rest Rep . set Ip Address ( port . get Ip Address ( ) ) ; storage Port Rest Rep . set Tcp Port ( String . value Of ( port . get Tcp Port Number ( ) ) ) ; } } rep . set Storage Port ( storage Port Rest Rep ) ; rep . set Export ( to Named Related Resource ( export Group , export Group . get Label ( ) ) ) ; if ( fc Zone Reference != null ) { rep . set San Zone Name ( fc Zone Reference . get Zone Name ( ) ) ; } return rep ; }
public void write ( final int c ) throws IO Exception { if ( m writer != null ) m writer . write ( c ) ; if ( count >= buf length ) flush Buffer ( ) ; if ( c < NUM ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < NUM ) { buf [ count ++ ] = ( byte ) ( NUM + ( c > > NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( c & NUM ) ) ; } else { buf [ count ++ ] = ( byte ) ( NUM + ( c > > NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( ( c > > NUM ) & NUM ) ) ; buf [ count ++ ] = ( byte ) ( NUM + ( c & NUM ) ) ; } }
private static List < C Operand Tree > convert ( final I Navi Module module , final List < Operand > operands ) { final List < C Operand Tree > converted Operands = new Array List < C Operand Tree > ( ) ; for ( final Operand operand : operands ) { converted Operands . add ( module . create Operand ( convert ( module , operand . get Root Node ( ) , null ) ) ) ; } return converted Operands ; }
public static String xml Escape ( String s ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char ch = s . char At ( i ) ; switch ( ch ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : break ; default : sb . append ( ch ) ; break ; } } return sb . to String ( ) ; }
public boolean write Header ( Output Stream os ) { try { write Int ( os , CACHE MAGIC ) ; write String ( os , key ) ; write String ( os , etag == null ? STRING : etag ) ; write Long ( os , server Date ) ; write Long ( os , ttl ) ; write Long ( os , soft Ttl ) ; write String String Map ( response Headers , os ) ; os . flush ( ) ; return BOOL ; } catch ( IO Exception e ) { Volley Log . d ( STRING , e . to String ( ) ) ; return BOOL ; } }
@ Visible For Testing public Bitmap ensure Normalized Icon ( Bitmap icon , String origin ) { if ( icon == null || icon . get Width ( ) == NUM ) { if ( m Icon Generator == null ) { int corner Radius Px = Math . min ( m Large Icon Width Px , m Large Icon Height Px ) / NUM ; m Icon Generator = new Rounded Icon Generator ( m Large Icon Width Px , m Large Icon Height Px , corner Radius Px , NOTIFICATION ICON BG COLOR , NOTIFICATION TEXT SIZE DP * m Density ) ; } return m Icon Generator . generate Icon For Url ( origin , BOOL ) ; } if ( icon . get Width ( ) > m Large Icon Width Px || icon . get Height ( ) > m Large Icon Height Px ) { return icon . create Scaled Bitmap ( icon , m Large Icon Width Px , m Large Icon Height Px , BOOL ) ; } return icon ; }
protected boolean [ ] can Handle Zero Training ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type ) { print ( STRING ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( STRING ) ; Array List < String > accepts = new Array List < String > ( ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; int num Train = NUM , num Classes = NUM , missing Level = NUM ; boolean predictor Missing = BOOL , class Missing = BOOL ; return run Basic Test ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type , missing Level , predictor Missing , class Missing , num Train , num Classes , accepts ) ; }
public SQL Query ( String type Name , String sql Expression ) { this ( sql Expression , type Name , null , DEFAULT QUERY RESULT TYPE , null ) ; }
private static void check Offset ( String value , int offset , char expected ) throws Index Out Of Bounds Exception { char found = value . char At ( offset ) ; if ( found != expected ) { throw new Index Out Of Bounds Exception ( STRING + expected + STRING + found + STRING ) ; } }
public boolean is In Net ( String host , String pattern , String mask ) { host = dns Resolve ( host ) ; if ( host == null || host . length ( ) == NUM ) { return BOOL ; } long lhost = parse Ip Address To Long ( host ) ; long lpattern = parse Ip Address To Long ( pattern ) ; long lmask = parse Ip Address To Long ( mask ) ; return ( lhost & lmask ) == lpattern ; }
protected static Pair < String , String > rrx Register ( final long offset , final I Translation Environment environment , final List < Reil Instruction > instructions , final String register Node Value ) { final String shifter Operand = environment . get Next Variable String ( ) ; final String shifter Carry Out = environment . get Next Variable String ( ) ; final String tmp Var 1 = environment . get Next Variable String ( ) ; final String tmp Var 2 = environment . get Next Variable String ( ) ; final String tmp Var 3 = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , byte Size , STRING , word Size , thirty One Set , d Word Size , tmp Var 1 ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value , byte Size , STRING + one Set , d Word Size , tmp Var 2 ) ) ; instructions . add ( Reil Helpers . create Or ( base Offset ++ , d Word Size , tmp Var 1 , d Word Size , tmp Var 2 , d Word Size , tmp Var 3 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , d Word Size , tmp Var 3 , d Word Size , bit Mask All Bits Set , d Word Size , shifter Operand ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , d Word Size , register Node Value , byte Size , String . value Of ( NUM ) , byte Size , shifter Carry Out ) ) ; return new Pair < String , String > ( shifter Operand , shifter Carry Out ) ; }
public int enumerate ( Thread [ ] threads ) { return enumerate ( threads , BOOL ) ; }
public void find And Undo ( Object some Obj ) { if ( some Obj instanceof Layer Handler ) { logger . fine ( STRING ) ; if ( get Layer Handler ( ) == ( Layer Handler ) some Obj ) { set Layer Handler ( null ) ; } } if ( controls != null && some Obj != this ) { controls . find And Undo ( some Obj ) ; } if ( some Obj instanceof Layer ) { pane Look Up . remove ( ( Layer ) some Obj ) ; } }
public void start ( ) { log . info ( STRING , this . name , this . frequency In Secs ) ; stopped = BOOL ; Thread dr Health Monitor Thread = new Thread ( this ) ; dr Health Monitor Thread . set Name ( this . name ) ; dr Health Monitor Thread . start ( ) ; }
public void connect ( String event Source Url ) throws IO Exception { LOG . entering ( CLASS NAME , STRING , event Source Url ) ; if ( stream != null ) { LOG . warning ( STRING ) ; throw new Illegal Argument Exception ( STRING ) ; } stream = new Sse Event Stream ( event Source Url ) ; stream . set Listener ( event Stream Listener ) ; stream . connect ( ) ; }
private static String method Name ( @ Non Nls final String method ) { return Git SSH Handler . HANDLER NAME + STRING + method ; }
public Data Row remove Data Row ( int index ) { return data List . remove ( index ) ; }
public void put ( Object key , Object value ) { int bucket = ( key . hash Code ( ) & NUM ) % f Table Size ; Entry entry = search ( key , bucket ) ; if ( entry != null ) { entry . value = value ; } else { entry = new Entry ( key , value , f Buckets [ bucket ] ) ; f Buckets [ bucket ] = entry ; f Num ++ ; } }
public void value Changed ( List Selection Event e ) { if ( table == null ) { return ; } int row = table . get Selected Row ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + row ) ; } if ( row >= NUM ) { add Button . set Enabled ( BOOL ) ; add Button . set Tool Tip Text ( null ) ; if ( type != null && type . equals ( STRING ) ) { make Icon Map ( pick List Model . get Bean At ( row ) ) ; clear Icon Panel ( ) ; do Icon Panel ( ) ; } } else { add Button . set Enabled ( BOOL ) ; add Button . set Tool Tip Text ( Bundle . get Message ( STRING ) ) ; } validate ( ) ; }
private int process Poll Fds ( ) throws IO Exception { if ( poll Fds . get ( NUM ) . revents == POLLIN ) { byte [ ] buffer = new byte [ NUM ] ; while ( Io Bridge . read ( wakeup In , buffer , NUM , NUM ) > NUM ) { } } int ready Key Count = NUM ; for ( int i = NUM ; i < poll Fds . size ( ) ; ++ i ) { Struct Pollfd poll Fd = poll Fds . get ( i ) ; if ( poll Fd . revents == NUM ) { continue ; } if ( poll Fd . fd == null ) { break ; } Selection Key Impl key = ( Selection Key Impl ) poll Fd . user Data ; poll Fd . fd = null ; poll Fd . user Data = null ; int ops = key . interest Ops No Check ( ) ; int selected Ops = NUM ; if ( ( poll Fd . revents & POLLHUP ) != NUM ) { selected Ops |= ops ; } if ( ( poll Fd . revents & POLLIN ) != NUM ) { selected Ops |= ops & ( OP ACCEPT | OP READ ) ; } if ( ( poll Fd . revents & POLLOUT ) != NUM ) { if ( key . is Connected ( ) ) { selected Ops |= ops & OP WRITE ; } else { selected Ops |= ops & OP CONNECT ; } } if ( selected Ops != NUM ) { boolean was Selected = mutable Selected Keys . contains ( key ) ; if ( was Selected && key . ready Ops ( ) != selected Ops ) { key . set Ready Ops ( key . ready Ops ( ) | selected Ops ) ; ++ ready Key Count ; } else if ( ! was Selected ) { key . set Ready Ops ( selected Ops ) ; mutable Selected Keys . add ( key ) ; ++ ready Key Count ; } } } return ready Key Count ; }
private void fit Image To View ( ) { Drawable drawable = get Drawable ( ) ; if ( drawable == null || drawable . get Intrinsic Width ( ) == NUM || drawable . get Intrinsic Height ( ) == NUM ) { return ; } if ( matrix == null || prev Matrix == null ) { return ; } int drawable Width = drawable . get Intrinsic Width ( ) ; int drawable Height = drawable . get Intrinsic Height ( ) ; float scale X = ( float ) view Width / drawable Width ; float scale Y = ( float ) view Height / drawable Height ; switch ( m Scale Type ) { case CENTER : scale X = scale Y = NUM ; break ; case CENTER CROP : scale X = scale Y = Math . max ( scale X , scale Y ) ; break ; case CENTER INSIDE : scale X = scale Y = Math . min ( NUM , Math . min ( scale X , scale Y ) ) ; case FIT CENTER : scale X = scale Y = Math . min ( scale X , scale Y ) ; break ; case FIT XY : break ; default : throw new Unsupported Operation Exception ( STRING ) ; } float redundant X Space = view Width - ( scale X * drawable Width ) ; float redundant Y Space = view Height - ( scale Y * drawable Height ) ; match View Width = view Width - redundant X Space ; match View Height = view Height - redundant Y Space ; if ( ! is Zoomed ( ) && ! image Rendered At Least Once ) { matrix . set Scale ( scale X , scale Y ) ; matrix . post Translate ( redundant X Space / NUM , redundant Y Space / NUM ) ; normalized Scale = NUM ; } else { if ( prev Match View Width == NUM || prev Match View Height == NUM ) { save Previous Image Values ( ) ; } prev Matrix . get Values ( m ) ; m [ Matrix . MSCALE X ] = match View Width / drawable Width * normalized Scale ; m [ Matrix . MSCALE Y ] = match View Height / drawable Height * normalized Scale ; float trans X = m [ Matrix . MTRANS X ] ; float trans Y = m [ Matrix . MTRANS Y ] ; float prev Actual Width = prev Match View Width * normalized Scale ; float actual Width = get Image Width ( ) ; translate Matrix After Rotate ( Matrix . MTRANS X , trans X , prev Actual Width , actual Width , prev View Width , view Width , drawable Width ) ; float prev Actual Height = prev Match View Height * normalized Scale ; float actual Height = get Image Height ( ) ; translate Matrix After Rotate ( Matrix . MTRANS Y , trans Y , prev Actual Height , actual Height , prev View Height , view Height , drawable Height ) ; matrix . set Values ( m ) ; } fix Trans ( ) ; set Image Matrix ( matrix ) ; }
public static boolean is Intermediate Table ( String table Name , SQ Lite Database db ) { if ( ! Text Utils . is Empty ( table Name ) ) { if ( table Name . matches ( STRING ) ) { Cursor cursor = null ; try { cursor = db . query ( Const . Table Schema . TABLE NAME , null , null , null , null , null , null ) ; if ( cursor . move To First ( ) ) { do { String table Name DB = cursor . get String ( cursor . get Column Index Or Throw ( Const . Table Schema . COLUMN NAME ) ) ; if ( table Name . equals Ignore Case ( table Name DB ) ) { int table Type = cursor . get Int ( cursor . get Column Index Or Throw ( Const . Table Schema . COLUMN TYPE ) ) ; if ( table Type == Const . Table Schema . INTERMEDIATE JOIN TABLE ) { return BOOL ; } break ; } } while ( cursor . move To Next ( ) ) ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } } } return BOOL ; }
public static void initialize ( File help Dir ) throws Help Exception { if ( help Dir . is Directory ( ) && help Dir . exists ( ) ) Help Manager . help Dir = help Dir ; else throw new Help Exception ( STRING + help Dir . get Absolute Path ( ) , null ) ; }
public Real Matrix create ( ) { Real Matrix rotation = new Identity Matrix ( ) ; for ( Plane plane : planes ) { double theta = plane . get Theta ( ) ; if ( Double . is Na N ( theta ) ) { continue ; } rotation = rotation . multiply ( new Rotation Matrix ( plane . get First Axis ( ) , plane . get Second Axis ( ) , theta ) ) ; } return rotation ; }
public static String to Upper Case ( String str ) { return str . to Upper Case ( Locale . ENGLISH ) ; }
protected static void init ( ) { String notificationfactory Class Name = null ; try { notificationfactory Class Name = System . get Property ( NOTIFICATION FACTORY NAME ) ; } catch ( Security Exception e ) { throw new Runtime Exception ( e ) ; } if ( notificationfactory Class Name != null ) { Class < ? > nfc ; try { nfc = Class . for Name ( notificationfactory Class Name ) ; factory = ( I Notification Manager Factory ) nfc . new Instance ( ) ; } catch ( Class Not Found Exception | Instantiation Exception | Illegal Access Exception e ) { throw new Runtime Exception ( e ) ; } } else { factory = new Syslog Notification Factory ( ) ; } }
public boolean is Declared Entity ( String entity Name ) { Entity entity = ( Entity ) f Entities . get ( entity Name ) ; return entity != null ; }
private void open Context Menu ( Mouse Event e ) { if ( e . is Popup Trigger ( ) ) { select Clicked ( e , BOOL ) ; List < Removed List Item > selected Items = list . get Selected Values List ( ) ; List < Stream Info > selected = new Array List < > ( ) ; for ( Removed List Item item : selected Items ) { selected . add ( item . get Stream Info ( ) ) ; } Stream Infos Context Menu m = new Stream Infos Context Menu ( selected , BOOL ) ; for ( Context Menu Listener cml : context Menu Listeners ) { m . add Context Menu Listener ( cml ) ; } m . show ( list , e . get X ( ) , e . get Y ( ) ) ; } }
private boolean put ( boolean is Root , Vector names , int len , Object value ) { if ( len == NUM ) { if ( is Root ) { if ( root Value != null ) return BOOL ; root Value = value ; } else { if ( other Value != null ) return BOOL ; other Value = value ; } return BOOL ; } else { Object name = names . element At ( len - NUM ) ; Context Map nested Map = ( Context Map ) name Table . get ( name ) ; if ( nested Map == null ) { nested Map = new Context Map ( ) ; name Table . put ( name , nested Map ) ; } return nested Map . put ( is Root , names , len - NUM , value ) ; } }
static String encode High Level ( String msg , Compaction compaction ) throws Writer Exception { byte [ ] bytes = null ; String Builder sb = new String Builder ( msg . length ( ) ) ; int len = msg . length ( ) ; int p = NUM ; int text Sub Mode = SUBMODE ALPHA ; if ( compaction == Compaction . TEXT ) { encode Text ( msg , p , len , sb , text Sub Mode ) ; } else if ( compaction == Compaction . BYTE ) { bytes = get Bytes For Message ( msg ) ; encode Binary ( bytes , p , bytes . length , BYTE COMPACTION , sb ) ; } else if ( compaction == Compaction . NUMERIC ) { sb . append ( ( char ) LATCH TO NUMERIC ) ; encode Numeric ( msg , p , len , sb ) ; } else { int encoding Mode = TEXT COMPACTION ; while ( p < len ) { int n = determine Consecutive Digit Count ( msg , p ) ; if ( n >= NUM ) { sb . append ( ( char ) LATCH TO NUMERIC ) ; encoding Mode = NUMERIC COMPACTION ; text Sub Mode = SUBMODE ALPHA ; encode Numeric ( msg , p , n , sb ) ; p += n ; } else { int t = determine Consecutive Text Count ( msg , p ) ; if ( t >= NUM || n == len ) { if ( encoding Mode != TEXT COMPACTION ) { sb . append ( ( char ) LATCH TO TEXT ) ; encoding Mode = TEXT COMPACTION ; text Sub Mode = SUBMODE ALPHA ; } text Sub Mode = encode Text ( msg , p , t , sb , text Sub Mode ) ; p += t ; } else { if ( bytes == null ) { bytes = get Bytes For Message ( msg ) ; } int b = determine Consecutive Binary Count ( msg , bytes , p ) ; if ( b == NUM ) { b = NUM ; } if ( b == NUM && encoding Mode == TEXT COMPACTION ) { encode Binary ( bytes , p , NUM , TEXT COMPACTION , sb ) ; } else { encode Binary ( bytes , p , b , encoding Mode , sb ) ; encoding Mode = BYTE COMPACTION ; text Sub Mode = SUBMODE ALPHA ; } p += b ; } } } } return sb . to String ( ) ; }
protected void queue ( final Path file ) throws Interrupted Exception { if ( null != base && file . starts With ( base ) ) { queue . put ( file . subpath ( base . get Name Count ( ) , file . get Name Count ( ) ) ) ; } else { queue . put ( file ) ; } }
public Input Stream open Path ( ) throws IO Exception { Path file Path = Paths . get ( path ( ) ) ; if ( Files . exists ( file Path ) ) { logger . info ( STRING , file Path ) ; return Files . new Input Stream ( file Path ) ; } URL resource Url = Resources . get Resource ( path ( ) ) ; logger . info ( STRING , resource Url ) ; return resource Url . open Stream ( ) ; }
public static String replace Characters ( final Conversion Method conversion Method , final String input , final int from Character , final int to Character , final String wrap ) { String converted Text = input ; for ( int i = from Character ; i <= to Character ; i ++ ) { final String character To Replace = new String ( Character . to Chars ( i ) ) ; if ( wrap != null ) { converted Text = converted Text . replace ( character To Replace , wrap + convert Text ( conversion Method , character To Replace ) + wrap ) ; } else { converted Text = converted Text . replace ( character To Replace , convert Text ( conversion Method , character To Replace ) ) ; } } return converted Text ; }
public static byte [ ] hmac sha 1 ( byte [ ] key Bytes , byte [ ] text ) throws No Such Algorithm Exception , Invalid Key Exception { Mac hmac Sha 1 ; try { hmac Sha 1 = Mac . get Instance ( STRING ) ; } catch ( final No Such Algorithm Exception nsae ) { hmac Sha 1 = Mac . get Instance ( STRING ) ; } final Secret Key Spec mac Key = new Secret Key Spec ( key Bytes , STRING ) ; hmac Sha 1 . init ( mac Key ) ; return hmac Sha 1 . do Final ( text ) ; }
public static byte [ ] read Bytes And Close ( Input Stream in , int length ) throws IO Exception { try { if ( length <= NUM ) { length = Integer . MAX VALUE ; } int block = Math . min ( Constants . IO BUFFER SIZE , length ) ; Byte Array Output Stream out = new Byte Array Output Stream ( block ) ; copy ( in , out , length ) ; return out . to Byte Array ( ) ; } catch ( Exception e ) { throw Db Exception . convert To IO Exception ( e ) ; } finally { in . close ( ) ; } }
public Ident Value as Ident Value ( ) { if ( ! ident Is Set ) { ident Val = Ident Value . get By Ident String ( css Primitive Value . get Css Text ( ) ) ; ident Is Set = BOOL ; } return ident Val ; }
public final Test Suite build ( ) { root Suite = new Test Suite ( get Suite Name ( ) ) ; current Classname = null ; try { for ( Test Method test : test Grouping . get Tests ( ) ) { if ( satisfies All Predicates ( test ) ) { add Test ( test ) ; } } if ( test Cases . size ( ) > NUM ) { for ( Test Case test Case : test Cases ) { if ( satisfies All Predicates ( new Test Method ( test Case ) ) ) { add Test ( test Case ) ; } } } } catch ( Exception exception ) { Log . i ( STRING , STRING , exception ) ; Test Suite suite = new Test Suite ( get Suite Name ( ) ) ; suite . add Test ( new Failed To Create Tests ( exception ) ) ; return suite ; } return root Suite ; }
public javax . naming . Binding next ( ) throws Naming Exception { if ( more && counter >= binding List . value . length ) { get More ( ) ; } if ( more && counter < binding List . value . length ) { org . omg . Cos Naming . Binding bndg = binding List . value [ counter ] ; counter ++ ; return map Binding ( bndg ) ; } else { throw new No Such Element Exception ( ) ; } }
protected < T extends AST Node > T move Node ( T old Node , AST Rewrite rewrite ) { T moved Node ; if ( AST Nodes . is Existing Node ( old Node ) ) moved Node = AST Nodes . create Move Target ( rewrite , old Node ) ; else moved Node = AST Nodes . copy Subtree ( rewrite . get AST ( ) , old Node ) ; return moved Node ; }
@ Ignore @ Test public void should Be Faster When Running Processing In Parallel ( ) throws Exception { test Mojo With Configurable Wro Manager Factory With Valid Config File Set ( ) ; final long begin = System . current Time Millis ( ) ; victim . set Parallel Processing ( BOOL ) ; test Mojo With Configurable Wro Manager Factory With Valid Config File Set ( ) ; final long end Serial = System . current Time Millis ( ) ; victim . set Parallel Processing ( BOOL ) ; test Mojo With Configurable Wro Manager Factory With Valid Config File Set ( ) ; final long end Parallel = System . current Time Millis ( ) ; final long serial = end Serial - begin ; final long parallel = end Parallel - end Serial ; LOG . info ( STRING , serial ) ; LOG . info ( STRING , parallel ) ; assert True ( String . format ( STRING , serial , parallel ) , serial > parallel ) ; }
public static Tetrad Matrix incomplete Cholesky Gram Matrix ( List < Kernel > kernels , Data Set dataset , List < Node > nodes , double precision ) { if ( precision <= NUM ) { throw new Illegal Argument Exception ( STRING ) ; } int m = dataset . get Num Rows ( ) ; Tetrad Matrix G = new Tetrad Matrix ( m , m ) ; double [ ] Dadv = new double [ m ] ; int [ ] p = new int [ m ] ; for ( int i = NUM ; i < m ; i ++ ) { Dadv [ i ] = evaluate ( kernels , dataset , nodes , i , i ) ; p [ i ] = i ; } int cols = m ; for ( int k = NUM ; k < m ; k ++ ) { double best = Dadv [ k ] ; int best Ind = k ; for ( int j = ( k + NUM ) ; j < m ; j ++ ) { if ( Dadv [ j ] > best / NUM ) { best = Dadv [ j ] ; best Ind = j ; } } if ( best < precision ) { cols = k - NUM ; break ; } int pk = p [ k ] ; p [ k ] = p [ best Ind ] ; p [ best Ind ] = pk ; double dk = Dadv [ k ] ; Dadv [ k ] = Dadv [ best Ind ] ; Dadv [ best Ind ] = dk ; for ( int j = NUM ; j < k ; j ++ ) { double gk = G . get ( k , j ) ; G . set ( k , j , G . get ( best Ind , j ) ) ; G . set ( best Ind , j , gk ) ; } double diag = Math . sqrt ( Dadv [ k ] ) ; G . set ( k , k , diag ) ; for ( int j = ( k + NUM ) ; j < m ; j ++ ) { double s = NUM ; for ( int i = NUM ; i < k ; i ++ ) { s += G . get ( j , i ) * G . get ( k , i ) ; } G . set ( j , k , ( evaluate ( kernels , dataset , nodes , p [ j ] , p [ k ] ) - s ) / diag ) ; } for ( int j = ( k + NUM ) ; j < m ; j ++ ) { Dadv [ j ] -= Math . pow ( G . get ( j , k ) , NUM ) ; } Dadv [ k ] = NUM ; } Tetrad Matrix Gm = new Tetrad Matrix ( m , cols ) ; for ( int i = NUM ; i < m ; i ++ ) { for ( int j = NUM ; j < cols ; j ++ ) { Gm . set ( i , j , G . get ( i , j ) ) ; } } return Gm ; }
Format Specifier Parser ( String format ) { this . format = format ; this . length = format . length ( ) ; }
public void add Consumer Type ( Attribute Type type ) { if ( ! consumer Types . contains ( type ) ) { consumer Types . add ( type ) ; } }
public final void print Verbose Message ( final Localizable Message msg ) { if ( is Verbose ( ) ) { out . println ( wrap ( msg ) ) ; } }
private static void order Matches ( List < Variable > type Matches , String param Name ) { if ( type Matches != null ) Collections . sort ( type Matches , new Match Comparator ( param Name ) ) ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
@ Override public boolean is Scraped ( ) { if ( ! scraped ) { if ( ! plot . is Empty ( ) && ! ( year . is Empty ( ) || year . equals ( STRING ) ) && ! ( genres == null || genres . size ( ) == NUM ) && ! ( actors == null || actors . size ( ) == NUM ) ) { return BOOL ; } } return scraped ; }
public Noise Tag Lda Model ( Input Stream in ) throws IO Exception { GZIP Input Stream zipin = new GZIP Input Stream ( in ) ; Buffered Input Stream bin = new Buffered Input Stream ( zipin ) ; Data Input Stream datain = new Data Input Stream ( bin ) ; num Topics = datain . read Int ( ) ; int num Words = datain . read Int ( ) ; alpha = datain . read Double ( ) ; beta = datain . read Double ( ) ; locked = datain . read Boolean ( ) ; wnz = new int [ num Topics ] ; Arrays . fill ( wnz , NUM ) ; for ( int i = NUM ; i < num Words ; i ++ ) { String word = datain . read UTF ( ) ; int [ ] count = new int [ num Topics ] ; for ( int j = NUM ; j < num Topics ; j ++ ) { count [ j ] = datain . read Int ( ) ; wnz [ j ] += count [ j ] ; nw += count [ j ] ; } nwz . put ( word , count ) ; } tnz = new int [ num Topics + NUM ] ; Arrays . fill ( tnz , NUM ) ; int num Tags = datain . read Int ( ) ; eta = datain . read Double ( ) ; for ( int i = NUM ; i < num Tags ; i ++ ) { String word = datain . read UTF ( ) ; int [ ] count = new int [ num Topics + NUM ] ; for ( int j = NUM ; j < num Topics + NUM ; j ++ ) { count [ j ] = datain . read Int ( ) ; tnz [ j ] += count [ j ] ; nt += count [ j ] ; } ntz . put ( word , count ) ; } noise = num Topics ; }
public void check ( final int api ) { if ( api == Opcodes . ASM 4 ) { if ( visible Type Annotations != null && visible Type Annotations . size ( ) > NUM ) { throw new Runtime Exception ( ) ; } if ( invisible Type Annotations != null && invisible Type Annotations . size ( ) > NUM ) { throw new Runtime Exception ( ) ; } for ( Field Node f : fields ) { f . check ( api ) ; } for ( Method Node m : methods ) { m . check ( api ) ; } } }
public static String RTF Enc ( String s ) { int ln = s . length ( ) ; int first Esc Idx = - NUM ; int last Esc Idx = NUM ; int plus Out Ln = NUM ; for ( int i = NUM ; i < ln ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING || c == STRING || c == STRING ) { if ( first Esc Idx == - NUM ) { first Esc Idx = i ; } last Esc Idx = i ; plus Out Ln ++ ; } } if ( first Esc Idx == - NUM ) { return s ; } else { char [ ] esced = new char [ ln + plus Out Ln ] ; if ( first Esc Idx != NUM ) { s . get Chars ( NUM , first Esc Idx , esced , NUM ) ; } int dst = first Esc Idx ; for ( int i = first Esc Idx ; i <= last Esc Idx ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING || c == STRING || c == STRING ) { esced [ dst ++ ] = STRING ; } esced [ dst ++ ] = c ; } if ( last Esc Idx != ln - NUM ) { s . get Chars ( last Esc Idx + NUM , ln , esced , dst ) ; } return String . value Of ( esced ) ; } }
public String to String ( cp info constant pool [ ] ) { return Integer . to String ( ( int ) bytes ) ; }
public Inet Network ( Inet Address inet Address , int subnet Bits ) { inet Address = inet Address ; address = inet Address . get Address ( ) ; if ( subnet Bits < NUM ) subnet Bits = NUM * address . length ; subnet Bits = subnet Bits ; subnet Byte = subnet Bits / NUM ; subnet Mask = ~ ( ( NUM << ( NUM - subnet Bits % NUM ) ) - NUM ) & NUM ; }
public boolean equal Array Value ( Object other Value ) { if ( value instanceof Object [ ] && other Value instanceof Object [ ] ) { return Arrays . equals ( ( Object [ ] ) value , ( Object [ ] ) other Value ) ; } Class type = value . get Class ( ) ; if ( type != other Value . get Class ( ) ) { return BOOL ; } if ( type == int [ ] . class ) { return Arrays . equals ( ( int [ ] ) value , ( int [ ] ) other Value ) ; } else if ( type == byte [ ] . class ) { return Arrays . equals ( ( byte [ ] ) value , ( byte [ ] ) other Value ) ; } else if ( type == short [ ] . class ) { return Arrays . equals ( ( short [ ] ) value , ( short [ ] ) other Value ) ; } else if ( type == long [ ] . class ) { return Arrays . equals ( ( long [ ] ) value , ( long [ ] ) other Value ) ; } else if ( type == char [ ] . class ) { return Arrays . equals ( ( char [ ] ) value , ( char [ ] ) other Value ) ; } else if ( type == boolean [ ] . class ) { return Arrays . equals ( ( boolean [ ] ) value , ( boolean [ ] ) other Value ) ; } else if ( type == float [ ] . class ) { return Arrays . equals ( ( float [ ] ) value , ( float [ ] ) other Value ) ; } else if ( type == double [ ] . class ) { return Arrays . equals ( ( double [ ] ) value , ( double [ ] ) other Value ) ; } return BOOL ; }
@ Override public Hierarchy Wrapper Operation create Sub Operation ( ) { return new To String Operation ( builder , base Indent ) ; }
private static byte [ ] read Class ( final Input Stream is , boolean close ) throws IO Exception { if ( is == null ) { throw new IO Exception ( STRING ) ; } try { byte [ ] b = new byte [ is . available ( ) ] ; int len = NUM ; while ( BOOL ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - NUM ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; System . arraycopy ( b , NUM , c , NUM , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < NUM ) { return b ; } byte [ ] c = new byte [ b . length + NUM ] ; System . arraycopy ( b , NUM , c , NUM , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } } finally { if ( close ) { is . close ( ) ; } } }
protected final boolean execute ( ) throws Ade Exception { logger . info ( STRING + m request Type . name ( ) ) ; final long start = System . current Time Millis ( ) ; final boolean success = do Control Logic ( ) ; final long total = System . current Time Millis ( ) - start ; logger . info ( m request Type . name ( ) + ( success ? STRING : STRING ) + STRING + milliseconds To Human Time ( total ) ) ; return success ; }
public abstract Json Value sync ( ) throws Synchronization Exception ;
private boolean valid Consist ( ) { int cN = valid Consist ( consist Text Field . get Text ( ) ) ; if ( cN == - NUM ) { consist Status . set Text ( rb . get String ( STRING ) ) ; J Option Pane . show Message Dialog ( this , rb . get String ( STRING ) , rb . get String ( STRING ) , J Option Pane . ERROR MESSAGE ) ; return BOOL ; } return BOOL ; }
private void activity ( ) { connection Checked Count = NUM ; }
public static Schedule Spec compute Values ( Object [ ] args ) throws Schedule Parameter Exception { if ( args . length <= NUM || args . length >= NUM ) { throw new Schedule Parameter Exception ( STRING + args . length ) ; } Enum Map < Schedule Unit , Sorted Set < Integer > > unit Map = new Enum Map < Schedule Unit , Sorted Set < Integer > > ( Schedule Unit . class ) ; Object minutes = args [ NUM ] ; Object hours = args [ NUM ] ; Object days Of Month = args [ NUM ] ; Object months = args [ NUM ] ; Object days Of Week = args [ NUM ] ; unit Map . put ( Schedule Unit . MINUTES , compute Values ( minutes , Schedule Unit . MINUTES ) ) ; unit Map . put ( Schedule Unit . HOURS , compute Values ( hours , Schedule Unit . HOURS ) ) ; Sorted Set < Integer > result Months = compute Values ( months , Schedule Unit . MONTHS ) ; if ( days Of Week instanceof Cron Parameter && days Of Month instanceof Cron Parameter ) { throw new Schedule Parameter Exception ( STRING ) ; } if ( result Months != null && result Months . size ( ) == NUM && ( result Months . first ( ) instanceof Integer ) ) { Cron Parameter parameter = null ; if ( days Of Month instanceof Cron Parameter ) { parameter = ( ( Cron Parameter ) days Of Month ) ; } else if ( days Of Week instanceof Cron Parameter ) { parameter = ( ( Cron Parameter ) days Of Week ) ; } if ( parameter != null ) { parameter . set Month ( result Months . first ( ) ) ; } } Sorted Set < Integer > result Days Of Week = compute Values ( days Of Week , Schedule Unit . DAYS OF WEEK ) ; Sorted Set < Integer > result Days Of Month = compute Values ( days Of Month , Schedule Unit . DAYS OF MONTH ) ; if ( result Days Of Week != null && result Days Of Week . size ( ) == NUM && ( result Days Of Week . first ( ) instanceof Integer ) ) { if ( result Days Of Week . first ( ) > NUM ) { if ( result Days Of Month != null ) { throw new Schedule Parameter Exception ( STRING ) ; } result Days Of Month = result Days Of Week ; result Days Of Week = null ; } } if ( result Days Of Month != null && result Days Of Month . size ( ) == NUM && ( result Days Of Month . first ( ) instanceof Integer ) ) { if ( result Days Of Week != null ) { throw new Schedule Parameter Exception ( STRING ) ; } } unit Map . put ( Schedule Unit . DAYS OF WEEK , result Days Of Week ) ; unit Map . put ( Schedule Unit . DAYS OF MONTH , result Days Of Month ) ; unit Map . put ( Schedule Unit . MONTHS , result Months ) ; if ( args . length > NUM ) { unit Map . put ( Schedule Unit . SECONDS , compute Values ( args [ NUM ] , Schedule Unit . SECONDS ) ) ; } String timezone = null ; if ( args . length > NUM ) { if ( ! ( args [ NUM ] instanceof Wildcard Parameter ) ) { if ( ! ( args [ NUM ] instanceof String ) ) { throw new Schedule Parameter Exception ( STRING + args [ NUM ] + STRING ) ; } timezone = ( String ) args [ NUM ] ; } } Cron Parameter optional Day Of Month Op = get Optional Special Op ( days Of Month ) ; Cron Parameter optional Day Of Week Op = get Optional Special Op ( days Of Week ) ; return new Schedule Spec ( unit Map , timezone , optional Day Of Month Op , optional Day Of Week Op ) ; }
public void remove ( int position ) { m Data . remove ( position ) ; notify Item Removed ( position + get Header Layout Count ( ) ) ; }
public Async Buffered Output Stream ( Output Stream out , int buf Size , int max Buffers ) { super ( out ) ; buffers = new Concurrent Linked Deque < > ( ) ; buf = new byte [ buf Size ] ; flusher Thread . start ( ) ; }
public boolean startlist Contains ( String x ) { if ( startwords == null ) return BOOL ; return startwords . contains ( x ) ; }
private void close Media Info ( ) { if ( media Info != null ) { media Info . close ( ) ; media Info = null ; } mi Snapshot = null ; }
public void add Header ( final Header header ) { headers . add ( header ) ; }
private void read Version ( Input Node node , Object source , Label label ) throws Exception { Object value = read Instance ( node , source , label ) ; Class expect = type . get Type ( ) ; if ( value != null ) { Version version = context . get Version ( expect ) ; Double actual = version . revision ( ) ; if ( ! value . equals ( revision ) ) { revision . compare ( actual , value ) ; } } }
protected Ignite start Grid With Igfs ( String grid Name , String igfs Name , Igfs Mode mode , @ Nullable Igfs Secondary File System secondary Fs , @ Nullable Igfs Ipc Endpoint Configuration rest Cfg ) throws Exception { File System Configuration igfs Cfg = new File System Configuration ( ) ; igfs Cfg . set Data Cache Name ( STRING ) ; igfs Cfg . set Meta Cache Name ( STRING ) ; igfs Cfg . set Name ( igfs Name ) ; igfs Cfg . set Block Size ( IGFS BLOCK SIZE ) ; igfs Cfg . set Default Mode ( mode ) ; igfs Cfg . set Ipc Endpoint Configuration ( rest Cfg ) ; igfs Cfg . set Secondary File System ( secondary Fs ) ; igfs Cfg . set Prefetch Blocks ( PREFETCH BLOCKS ) ; igfs Cfg . set Sequential Reads Before Prefetch ( SEQ READS BEFORE PREFETCH ) ; Cache Configuration data Cache Cfg = default Cache Configuration ( ) ; data Cache Cfg . set Name ( STRING ) ; data Cache Cfg . set Cache Mode ( PARTITIONED ) ; data Cache Cfg . set Near Configuration ( null ) ; data Cache Cfg . set Write Synchronization Mode ( Cache Write Synchronization Mode . FULL SYNC ) ; data Cache Cfg . set Affinity Mapper ( new Igfs Group Data Blocks Key Mapper ( NUM ) ) ; data Cache Cfg . set Backups ( NUM ) ; data Cache Cfg . set Atomicity Mode ( TRANSACTIONAL ) ; data Cache Cfg . set Off Heap Max Memory ( NUM ) ; Cache Configuration meta Cache Cfg = default Cache Configuration ( ) ; meta Cache Cfg . set Name ( STRING ) ; meta Cache Cfg . set Cache Mode ( REPLICATED ) ; meta Cache Cfg . set Write Synchronization Mode ( Cache Write Synchronization Mode . FULL SYNC ) ; meta Cache Cfg . set Atomicity Mode ( TRANSACTIONAL ) ; Ignite Configuration cfg = new Ignite Configuration ( ) ; cfg . set Grid Name ( grid Name ) ; Tcp Discovery Spi disco Spi = new Tcp Discovery Spi ( ) ; disco Spi . set Ip Finder ( new Tcp Discovery Vm Ip Finder ( BOOL ) ) ; cfg . set Discovery Spi ( disco Spi ) ; cfg . set Cache Configuration ( data Cache Cfg , meta Cache Cfg ) ; cfg . set File System Configuration ( igfs Cfg ) ; cfg . set Local Host ( STRING ) ; cfg . set Connector Configuration ( null ) ; return G . start ( cfg ) ; }
Type Simplifier ( Types type Utils , String package Name , Set < Type Mirror > types , Type Mirror base ) { this . type Utils = type Utils ; Set < Type Mirror > types Plus Base = new Type Mirror Set ( types ) ; if ( base != null ) { types Plus Base . add ( base ) ; } Set < Type Mirror > referenced = referenced Class Types ( type Utils , types Plus Base ) ; Set < Type Mirror > defined = non Private Declared Types ( type Utils , base ) ; this . imports = find Imports ( type Utils , package Name , referenced , defined ) ; }
private List < Statistics > remove Failed ( List < Statistics > statistics ) { List < Statistics > result = new Array List < > ( ) ; for ( Statistics statistic : statistics ) { if ( statistic . get Succeeded ( ) ) result . add ( statistic ) ; } return result ; }
public void add Associated Gefahr ( Gefaehrdungs Umsetzung gefaehrdung ) { if ( ! associated Gefaehrdungen . contains ( gefaehrdung ) ) { associated Gefaehrdungen . add ( gefaehrdung ) ; } }
public static byte [ ] pack Byte Buffer Into Single Byte Array ( Byte Buffer [ ] byte Buffer Arr ) { if ( null == byte Buffer Arr || byte Buffer Arr . length == NUM ) { return null ; } int no Of Col = byte Buffer Arr . length ; short to Determine Length Of Byte Arr = NUM ; short offset Len = ( short ) ( no Of Col * NUM + to Determine Length Of Byte Arr ) ; int total Bytes = calculate Total Bytes ( byte Buffer Arr ) + offset Len ; Byte Buffer buffer = Byte Buffer . allocate ( total Bytes ) ; buffer . put Short ( ( short ) ( total Bytes - to Determine Length Of Byte Arr ) ) ; buffer . put Short ( offset Len ) ; for ( int index = NUM ; index < byte Buffer Arr . length - NUM ; index ++ ) { Byte Buffer individual Col = byte Buffer Arr [ index ] ; int no Of Bytes = individual Col . capacity ( ) ; buffer . put Short ( ( short ) ( offset Len + no Of Bytes ) ) ; offset Len += no Of Bytes ; individual Col . rewind ( ) ; } for ( int index = NUM ; index < byte Buffer Arr . length ; index ++ ) { Byte Buffer individual Col = byte Buffer Arr [ index ] ; buffer . put ( individual Col . array ( ) ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }
public void connect ( Socket Address endpoint , int timeout ) throws IO Exception { if ( endpoint == null ) throw new Illegal Argument Exception ( STRING ) ; if ( timeout < NUM ) throw new Illegal Argument Exception ( STRING ) ; if ( is Closed ( ) ) throw new Socket Exception ( STRING ) ; if ( ! old Impl && is Connected ( ) ) throw new Socket Exception ( STRING ) ; if ( ! ( endpoint instanceof Inet Socket Address ) ) throw new Illegal Argument Exception ( STRING ) ; Inet Socket Address epoint = ( Inet Socket Address ) endpoint ; Inet Address addr = epoint . get Address ( ) ; int port = epoint . get Port ( ) ; check Address ( addr , STRING ) ; Security Manager security = System . get Security Manager ( ) ; if ( security != null ) { if ( epoint . is Unresolved ( ) ) security . check Connect ( epoint . get Host Name ( ) , port ) ; else security . check Connect ( addr . get Host Address ( ) , port ) ; } if ( ! created ) create Impl ( BOOL ) ; if ( ! old Impl ) impl . connect ( epoint , timeout ) ; else if ( timeout == NUM ) { if ( epoint . is Unresolved ( ) ) impl . connect ( addr . get Host Name ( ) , port ) ; else impl . connect ( addr , port ) ; } else throw new Unsupported Operation Exception ( STRING ) ; connected = BOOL ; bound = BOOL ; }
private Pair < Hash Step Type , Hash Chain Type > fetch Hash Step ( String uri , Hash Chain Type current Chain ) throws Exception { int hash Index = uri . index Of ( STRING ) ; if ( hash Index < NUM ) { throw new Coded Exception ( X MALFORMED HASH CHAIN , STRING , uri ) ; } String base Uri = uri . substring ( NUM , hash Index ) ; String fragment = uri . substring ( hash Index + NUM ) ; if ( fragment . is Empty ( ) ) { throw new Coded Exception ( X MALFORMED HASH CHAIN , STRING , uri ) ; } Hash Chain Type hash Chain ; if ( base Uri . is Empty ( ) ) { hash Chain = current Chain ; } else { hash Chain = get Hash Chain ( base Uri ) ; } for ( Hash Step Type step : hash Chain . get Hash Step ( ) ) { if ( fragment . equals ( step . get Id ( ) ) ) { return new Immutable Pair < > ( step , hash Chain ) ; } } throw new Coded Exception ( X MALFORMED HASH CHAIN , STRING , uri ) ; }
@ Suppress Warnings ( STRING ) public static boolean load By Current Classloader ( String cls Name ) { if ( cls Name . starts With ( STRING ) ) return BOOL ; if ( cls Name . starts With ( STRING ) ) { if ( cls Name . contains ( STRING ) || cls Name . contains ( STRING ) || cls Name . contains ( STRING ) ) return BOOL ; } return BOOL ; }
public void decrement Targets Count All ( ) { final long decrement And Get = targets Count All . decrement And Get ( ) ; if ( decrement And Get < NUM ) { targets Count All . set ( NUM ) ; } }
private void add Not Available Business Object Data Statuses ( List < Business Object Data Status > not Available Statuses , List < Storage Unit Entity > storage Unit Entities , Set < Business Object Data Entity > archived Business Object Data Entities ) { for ( Storage Unit Entity storage Unit Entity : storage Unit Entities ) { not Available Statuses . add ( create Not Available Business Object Data Status ( storage Unit Entity , archived Business Object Data Entities ) ) ; } }
private List < Jdbc Statement > create Default Query Jdbc Statements ( ) { List < Jdbc Statement > jdbc Statements = new Array List < > ( ) ; { Jdbc Statement jdbc Statement = new Jdbc Statement ( ) ; jdbc Statement . set Type ( Jdbc Statement Type . QUERY ) ; jdbc Statement . set Sql ( Mock Jdbc Operations . CASE 1 SQL ) ; jdbc Statements . add ( jdbc Statement ) ; } return jdbc Statements ; }
private void test Memory Spatial Index ( ) throws SQL Exception { delete Db ( STRING ) ; Connection conn = get Connection ( URL ) ; Statement stat = conn . create Statement ( ) ; stat . execute ( STRING ) ; stat . execute ( STRING ) ; stat . execute ( STRING ) ; stat . execute ( STRING ) ; Result Set rs ; rs = stat . execute Query ( STRING + STRING + STRING ) ; assert False ( rs . next ( ) ) ; rs = stat . execute Query ( STRING + STRING ) ; rs . next ( ) ; if ( config . mv Store ) { assert Contains ( rs . get String ( NUM ) , STRING ) ; } stat . execute Query ( STRING + STRING ) ; stat . execute Query ( STRING + STRING ) ; rs = stat . execute Query ( STRING + STRING ) ; assert True ( rs . next ( ) ) ; rs = stat . execute Query ( STRING + STRING ) ; assert True ( rs . next ( ) ) ; rs = stat . execute Query ( STRING + STRING ) ; assert False ( rs . next ( ) ) ; stat . execute ( STRING ) ; conn . close ( ) ; delete Db ( STRING ) ; }
public static boolean is Valid ( Date expiration Date ) { Date current Date = new Date ( ) ; String formatted Date = date Format . format ( current Date ) ; current Date = convert Date ( formatted Date ) ; boolean is Expired = current Date . after ( expiration Date ) ; boolean is Equal = current Date . equals ( expiration Date ) ; if ( is Expired == BOOL || is Equal == BOOL ) { return BOOL ; } return BOOL ; }
public long content Length ( ) { long size ; try { size = Long . parse Long ( request . get Header ( File Upload . CONTENT LENGTH ) ) ; } catch ( Number Format Exception e ) { size = request . get Content Length ( ) ; } return size ; }
private E unlink First ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; not Full . signal ( ) ; return item ; }
public void test Zero Pos ( ) { String num A = STRING ; String num B = STRING ; String res = STRING ; Big Integer a Number = new Big Integer ( num A ) ; Big Integer b Number = new Big Integer ( num B ) ; Big Integer result = a Number . xor ( b Number ) ; assert True ( res . equals ( result . to String ( ) ) ) ; }
public Check Box add Listener ( Listener listener ) { if ( listener != null && ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } return this ; }
@ Suppress Warnings ( STRING ) public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
private void take Picture ( ) { Log . d ( TAG , STRING ) ; lock Focus ( ) ; }
private int measure Short ( int measure Spec ) { int result ; int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; if ( spec Mode == Measure Spec . EXACTLY ) { result = spec Size ; } else { result = ( int ) ( NUM * m Radius + get Padding Top ( ) + get Padding Bottom ( ) + NUM ) ; if ( spec Mode == Measure Spec . AT MOST ) { result = Math . min ( result , spec Size ) ; } } return result ; }
private static int [ ] [ ] parse ( String members ) { Vector the Ranges = new Vector ( ) ; int n = ( members == null ? NUM : members . length ( ) ) ; int i = NUM ; int state = NUM ; int lb = NUM ; int ub = NUM ; char c ; int digit ; while ( i < n ) { c = members . char At ( i ++ ) ; switch ( state ) { case NUM : if ( Character . is Whitespace ( c ) ) { state = NUM ; } else if ( ( digit = Character . digit ( c , NUM ) ) != - NUM ) { lb = digit ; state = NUM ; } else { throw new Illegal Argument Exception ( ) ; } break ; case NUM : if ( Character . is Whitespace ( c ) ) { state = NUM ; } else if ( ( digit = Character . digit ( c , NUM ) ) != - NUM ) { lb = NUM * lb + digit ; state = NUM ; } else if ( c == STRING || c == STRING ) { state = NUM ; } else if ( c == STRING ) { accumulate ( the Ranges , lb , lb ) ; state = NUM ; } else { throw new Illegal Argument Exception ( ) ; } break ; case NUM : if ( Character . is Whitespace ( c ) ) { state = NUM ; } else if ( c == STRING || c == STRING ) { state = NUM ; } else if ( c == STRING ) { accumulate ( the Ranges , lb , lb ) ; state = NUM ; } else { throw new Illegal Argument Exception ( ) ; } break ; case NUM : if ( Character . is Whitespace ( c ) ) { state = NUM ; } else if ( ( digit = Character . digit ( c , NUM ) ) != - NUM ) { ub = digit ; state = NUM ; } else { throw new Illegal Argument Exception ( ) ; } break ; case NUM : if ( Character . is Whitespace ( c ) ) { state = NUM ; } else if ( ( digit = Character . digit ( c , NUM ) ) != - NUM ) { ub = NUM * ub + digit ; state = NUM ; } else if ( c == STRING ) { accumulate ( the Ranges , lb , ub ) ; state = NUM ; } else { throw new Illegal Argument Exception ( ) ; } break ; case NUM : if ( Character . is Whitespace ( c ) ) { state = NUM ; } else if ( c == STRING ) { accumulate ( the Ranges , lb , ub ) ; state = NUM ; } else { throw new Illegal Argument Exception ( ) ; } break ; case NUM : if ( Character . is Whitespace ( c ) ) { state = NUM ; } else if ( ( digit = Character . digit ( c , NUM ) ) != - NUM ) { lb = digit ; state = NUM ; } else { throw new Illegal Argument Exception ( ) ; } break ; } } switch ( state ) { case NUM : break ; case NUM : case NUM : accumulate ( the Ranges , lb , lb ) ; break ; case NUM : case NUM : accumulate ( the Ranges , lb , ub ) ; break ; case NUM : case NUM : throw new Illegal Argument Exception ( ) ; } return canonical Array Form ( the Ranges ) ; }
public static String show Dialog ( final Component component , final String title , final Object message , final String ... buttons ) { return show Dialog ( J Option Pane . get Frame For Component ( component ) , title , message , J Option Pane . PLAIN MESSAGE , buttons ) ; }
public static void encode ( Input Stream in , Writer out ) throws IO Exception { int column = NUM ; while ( BOOL ) { int byte 1 = in . read ( ) ; int byte 2 = in . read ( ) ; int byte 3 = in . read ( ) ; if ( byte 1 < NUM ) { return ; } if ( column >= NUM ) { column = NUM ; out . write ( STRING ) ; } out . write ( charset [ byte 1 > > NUM ] ) ; int index = ( byte 1 & NUM ) << NUM ; if ( byte 2 < NUM ) { out . write ( charset [ index ] ) ; out . write ( padding Char ) ; out . write ( padding Char ) ; return ; } index += byte 2 > > NUM ; out . write ( charset [ index ] ) ; index = ( byte 2 & NUM ) << NUM ; if ( byte 3 < NUM ) { out . write ( charset [ index ] ) ; out . write ( padding Char ) ; return ; } index += byte 3 > > NUM ; out . write ( charset [ index ] ) ; out . write ( charset [ byte 3 & NUM ] ) ; column += NUM ; } }
public static String canonical ID ( String id ) { if ( id == null ) return STRING ; int st = NUM ; int len = id . length ( ) ; boolean substr = BOOL ; int c ; while ( st < len && ( ( c = id . char At ( st ) ) == STRING || c <= STRING ) ) { st ++ ; substr = BOOL ; } while ( st < len && ( ( c = id . char At ( len - NUM ) ) == STRING || c <= STRING ) ) { len -- ; substr = BOOL ; } return substr ? id . substring ( st , len ) : id ; }
protected void send Message ( String handler , List < ? > arguments ) { owner Message . add Event ( Type . CLIENT SEND MESSAGE , handler , arguments ) ; sync Events . add ( new Shared Object Event ( Type . CLIENT SEND MESSAGE , handler , arguments ) ) ; send Stats . increment And Get ( ) ; }
public void task Now ( final Runnable r , boolean async ) { if ( async ) { async ( r ) ; } else if ( r != null ) { r . run ( ) ; } }
public void reset ( ) { cur . reset ( ) ; line . reset ( ) ; inuse = BOOL ; word . set Length ( NUM ) ; }
protected void engine Set Mode ( String mode ) throws No Such Algorithm Exception { if ( ( mode != null ) && ( ! mode . equals Ignore Case ( STRING ) ) ) { throw new No Such Algorithm Exception ( STRING + mode ) ; } }
private void move Pos ( float delta Y ) { if ( ( delta Y < NUM && m Ptr Indicator . is In Start Position ( ) ) ) { if ( DEBUG ) { Ptr C Log . e ( LOG TAG , String . format ( STRING ) ) ; } return ; } int to = m Ptr Indicator . get Current Pos Y ( ) + ( int ) delta Y ; if ( m Ptr Indicator . will Over Top ( to ) ) { if ( DEBUG ) { Ptr C Log . e ( LOG TAG , String . format ( STRING ) ) ; } to = Ptr Indicator . POS START ; } m Ptr Indicator . set Current Pos ( to ) ; int change = to - m Ptr Indicator . get Last Pos Y ( ) ; update Pos ( change ) ; }
public static List < ? extends Element > child Element List ( Document Fragment fragment ) { if ( fragment == null ) return null ; List < Element > elements = new Linked List < Element > ( ) ; Node node = fragment . get First Child ( ) ; if ( node != null ) { do { if ( node . get Node Type ( ) == Node . ELEMENT NODE ) { Element child Element = ( Element ) node ; elements . add ( child Element ) ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; } return elements ; }
public void simulate Method ( Soot Method method , Reference Variable this Var , Reference Variable return Var , Reference Variable params [ ] ) { String sub Signature = method . get Sub Signature ( ) ; if ( sub Signature . equals ( STRING ) ) { java lang reflect Field set ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java lang reflect Field get ( method , this Var , return Var , params ) ; return ; } else { default Method ( method , this Var , return Var , params ) ; return ; } }
public Float Array resize ( Float Array array , long size ) { if ( array instanceof Big Float Array ) { return resize In Place ( ( Big Float Array ) array , size ) ; } else { Abstract Array arr = ( Abstract Array ) array ; final Float Array new Array = new Float Array ( size , arr . clear On Resize ) ; for ( long i = NUM , end = Math . min ( size , array . size ( ) ) ; i < end ; ++ i ) { new Array . set ( i , array . get ( i ) ) ; } arr . close ( ) ; return new Array ; } }
@ Override public boolean domain Match ( final String host , String domain ) { if ( host . equals ( domain ) ) { return BOOL ; } if ( ! domain . starts With ( STRING ) ) { domain = STRING + domain ; } return host . ends With ( domain ) || host . equals ( domain . substring ( NUM ) ) ; }
public boolean is Dirty ( String key ) { return dirty Keys . contains ( key ) ; }
final public void println ( float v ) { Writer out = this . out ; if ( out == null ) return ; String s = String . value Of ( v ) ; try { out . write ( s , NUM , s . length ( ) ) ; out . write ( newline , NUM , newline . length ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } }
public static Big Integer size Of Directory As Big Integer ( File directory ) { check Directory ( directory ) ; final File [ ] files = directory . list Files ( ) ; if ( files == null ) { return Big Integer . ZERO ; } Big Integer size = Big Integer . ZERO ; for ( final File file : files ) { try { if ( ! is Symlink ( file ) ) { size = size . add ( Big Integer . value Of ( size Of ( file ) ) ) ; } } catch ( IO Exception ioe ) { } } return size ; }
public double log Density For Instance ( Instance instance ) throws Exception { double [ ] a = log Joint Densities For Instance ( instance ) ; double max = a [ Utils . max Index ( a ) ] ; double sum = NUM ; for ( int i = NUM ; i < a . length ; i ++ ) { sum += Math . exp ( a [ i ] - max ) ; } return max + Math . log ( sum ) ; }
public void test When Complete source Failed Action Failed ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) for ( Execution Mode m : Execution Mode . values ( ) ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex 1 = new CF Exception ( ) ; final CF Exception ex 2 = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) f . complete Exceptionally ( ex 1 ) ; final Completable Future < Integer > g = m . when Complete ( f , null ) ; if ( create Incomplete ) f . complete Exceptionally ( ex 1 ) ; check Completed With Wrapped Exception ( g , ex 1 ) ; check Completed Exceptionally ( f , ex 1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
public static Angle great Circle Distance ( Lat Lon p1 , Lat Lon p2 ) { if ( ( p1 == null ) || ( p2 == null ) ) { throw new Illegal Argument Exception ( STRING ) ; } double lat 1 = p1 . get Latitude ( ) . radians ; double lon 1 = p1 . get Longitude ( ) . radians ; double lat 2 = p2 . get Latitude ( ) . radians ; double lon 2 = p2 . get Longitude ( ) . radians ; if ( lat 1 == lat 2 && lon 1 == lon 2 ) return Angle . ZERO ; double a = Math . sin ( ( lat 2 - lat 1 ) / NUM ) ; double b = Math . sin ( ( lon 2 - lon 1 ) / NUM ) ; double c = a * a + + Math . cos ( lat 1 ) * Math . cos ( lat 2 ) * b * b ; double distance Radians = NUM * Math . asin ( Math . sqrt ( c ) ) ; return Double . is Na N ( distance Radians ) ? Angle . ZERO : Angle . from Radians ( distance Radians ) ; }
public int index Of ( java . lang . String sub String , int start ) { if ( start < NUM ) { start = NUM ; } int sub Count = sub String . count ; int count = count ; if ( sub Count > NUM ) { if ( sub Count + start > count ) { return - NUM ; } char [ ] target = sub String . value ; int sub Offset = sub String . offset ; char first Char = target [ sub Offset ] ; int end = sub Offset + sub Count ; while ( BOOL ) { int i = index Of ( first Char , start ) ; if ( i == - NUM || sub Count + i > count ) { return - NUM ; } int o1 = offset + i , o2 = sub Offset ; char [ ] value = value ; while ( ++ o2 < end && value [ ++ o1 ] == target [ o2 ] ) { } if ( o2 == end ) { return i ; } start = i + NUM ; } } return start < count ? start : count ; }
@ Override public Query rewrite ( Index Reader reader ) throws IO Exception { if ( disjuncts . length == NUM ) { return disjuncts [ NUM ] ; } boolean actually Rewritten = BOOL ; List < Query > rewritten Disjuncts = new Array List < > ( ) ; for ( Query sub : disjuncts ) { Query rewritten Sub = sub . rewrite ( reader ) ; actually Rewritten |= rewritten Sub != sub ; rewritten Disjuncts . add ( rewritten Sub ) ; } if ( actually Rewritten ) { return new Disjunction Max Query ( rewritten Disjuncts , tie Breaker Multiplier ) ; } return super . rewrite ( reader ) ; }
public static String value Of ( long value ) { return Long . to String ( value ) ; }
public static < T > boolean are Sets Identical ( final Set < T > set 1 , final Set < T > set 2 ) { if ( set 1 == set 2 ) return BOOL ; if ( Collection Util . size ( set 1 ) != Collection Util . size ( set 2 ) ) return BOOL ; if ( Collection Util . is Empty ( set 1 ) ) return BOOL ; for ( final T t : set 1 ) if ( ! set 2 . contains ( t ) ) return BOOL ; return BOOL ; }
@ Override public int compare To ( Value o ) { return hash Code ( ) - o . hash Code ( ) ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
private static void add Options ( final List < String > cmd , Map < Checker Prop , Object > props ) { for ( Checker Prop cp : Checker Prop . values ( ) ) { cmd . add All ( cp . get Cmd Line ( props ) ) ; } }
public boolean obsolete ( ) { int [ ] stamp = new int [ NUM ] ; boolean undeployed = usage . get ( stamp ) ; return undeployed && stamp [ NUM ] == NUM ; }
public void delete ( ) throws IO Exception { close ( ) ; Util . delete Contents ( directory ) ; }
boolean pop Namespace ( String prefix ) { if ( prefix . starts With ( XML PREFIX ) ) { return BOOL ; } Stack stack ; if ( ( stack = get Prefix Stack ( prefix ) ) != null ) { stack . pop ( ) ; return BOOL ; } return BOOL ; }
public void redo Last Action ( ) { try { if ( undo Manager . can Redo ( ) ) undo Manager . redo ( ) ; } catch ( Cannot Redo Exception cre ) { cre . print Stack Trace ( ) ; } }
protected void continue Write ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } Iterator < Variable Value > i = variables . iterator ( ) ; while ( i . has Next ( ) ) { Variable Value v = i . next ( ) ; if ( v . is To Write ( ) && ( ! writing Changes || v . is Changed ( ) ) ) { am Writing = BOOL ; set Busy ( BOOL ) ; log . debug ( STRING + v . label ( ) + STRING + writing Changes ) ; if ( writing Changes ) { v . write Changes ( ) ; } else { v . write All ( ) ; } log . debug ( STRING ) ; return ; } } am Writing = BOOL ; super . set State ( STORED ) ; set Busy ( BOOL ) ; log . debug ( STRING ) ; }
private void start Game ( Game Launch Message game Launch Message , Faction faction , Rating Mode rating Mode , Integer local Relay Port ) { if ( is Running ( ) ) { logger . warn ( STRING ) ; return ; } stop Search Ranked 1 v 1 ( ) ; List < String > args = fix Malformed Args ( game Launch Message . get Args ( ) ) ; try { local Relay Server . get Port ( ) ; process = forged Alliance Service . start Game ( game Launch Message . get Uid ( ) , game Launch Message . get Mod ( ) , faction , args , rating Mode , local Relay Port , rehost Requested ) ; set Game Running ( BOOL ) ; this . rating Mode = rating Mode ; spawn Termination Listener ( process ) ; } catch ( IO Exception e ) { logger . warn ( STRING , e ) ; notification Service . add Notification ( new Immediate Notification ( i18 n . get ( STRING ) , i18 n . get ( STRING ) , Severity . ERROR , e , Arrays . as List ( new Report Action ( i18 n , reporting Service , e ) , new Dismiss Action ( i18 n ) ) ) ) ; } }
public void add Line ( String line ) { int index = line . index Of ( STRING , NUM ) ; if ( index != - NUM ) { add Lenient ( line . substring ( NUM , index ) , line . substring ( index + NUM ) ) ; } else if ( line . starts With ( STRING ) ) { add Lenient ( STRING , line . substring ( NUM ) ) ; } else { add Lenient ( STRING , line ) ; } }
private synchronized void add Entries ( Hashtable entries ) { entry Directory . put All ( entries ) ; }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . POST ) @ Response Body public Rest Wrapper update One Record ( @ Model Attribute ( STRING ) @ Valid General Config general Config , Binding Result binding Result , Principal principal ) { Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { if ( general Config . get Required ( ) <= NUM ) { com . wipro . ats . bdre . md . dao . jpa . General Config jpa General Config Update = new com . wipro . ats . bdre . md . dao . jpa . General Config ( ) ; General Config Id jpa General Config Id = new General Config Id ( ) ; jpa General Config Id . set Config Group ( general Config . get Config Group ( ) ) ; jpa General Config Id . set Gc Key ( general Config . get Key ( ) ) ; jpa General Config Update . set Id ( jpa General Config Id ) ; jpa General Config Update . set Default Val ( general Config . get Default Val ( ) ) ; jpa General Config Update . set Description ( general Config . get Description ( ) ) ; jpa General Config Update . set Enabled ( general Config . is Enabled ( ) ) ; jpa General Config Update . set Gc Value ( general Config . get Value ( ) ) ; if ( general Config . get Required ( ) == NUM ) jpa General Config Update . set Required ( BOOL ) ; else jpa General Config Update . set Required ( BOOL ) ; jpa General Config Update . set Type ( general Config . get Type ( ) ) ; LOGGER . info ( general Config ) ; general Config DAO . update ( jpa General Config Update ) ; rest Wrapper = new Rest Wrapper ( general Config , Rest Wrapper . OK ) ; LOGGER . info ( STRING + jpa General Config Id . get Gc Key ( ) + STRING + jpa General Config Id . get Config Group ( ) + STRING + principal . get Name ( ) ) ; } else { LOGGER . error ( STRING ) ; rest Wrapper = new Rest Wrapper ( STRING , Rest Wrapper . ERROR ) ; } } catch ( Metadata Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
public static void load Project ( final J Tree tree , final I Navi Project project ) { Preconditions . check Not Null ( tree , STRING ) ; Preconditions . check Not Null ( project , STRING ) ; load Project Threaded ( Swing Utilities . get Window Ancestor ( tree ) , project , tree ) ; }
public Enumeration list Options ( ) { Vector new Vector = new Vector ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public static Data Policy from Ordinal ( byte ordinal ) { return VALUES [ ordinal ] ; }
public static boolean is Installed ( Package Manager package Manager , String package Name ) { List < Package Info > packs = package Manager . get Installed Packages ( NUM ) ; for ( int i = NUM ; i < packs . size ( ) ; i ++ ) { if ( Text Utils . equals ( packs . get ( i ) . package Name , package Name ) ) return BOOL ; } return BOOL ; }
public void add Set Attribute ( final Set Attribute set Attribute ) { set Attributes . add ( set Attribute ) ; }
static String apply Template ( final String template , final Map < String , Object > map ) { configuration = get Configuration ( ) ; try ( Byte Array Output Stream output Stream = new Byte Array Output Stream ( ) ; Writer writer = new Output Stream Writer ( output Stream ) ) { Template configuration Template = configuration . get Template ( template ) ; configuration Template . process ( map , writer ) ; return output Stream . to String ( ) ; } catch ( Exception e ) { throw new Runtime Exception ( e . get Message ( ) , e ) ; } }
final void put Short ( int offset , short value ) { unsafe . put Short ( offset + address , value ) ; }
public static Clob to Clob ( Object value ) throws Page Exception { if ( value instanceof Clob ) return ( Clob ) value ; else if ( value instanceof char [ ] ) return to Clob ( new String ( ( char [ ] ) value ) ) ; else if ( value instanceof Reader ) { String Writer sw = new String Writer ( ) ; try { IO Util . copy ( ( Reader ) value , sw , BOOL , BOOL ) ; } catch ( IO Exception e ) { throw Expression Exception . new Instance ( e ) ; } return to Clob ( sw . to String ( ) ) ; } return to Clob ( Caster . to String ( value ) ) ; }
private J Free Chart create Histogram Chart ( Example Set example Set ) { J Free Chart chart = Chart Factory . create Histogram ( null , null , null , create Histogram Dataset ( example Set ) , Plot Orientation . VERTICAL , BOOL , BOOL , BOOL ) ; Abstract Attribute Statistics Model . set Default Chart Fonts ( chart ) ; chart . set Background Paint ( null ) ; chart . set Background Image Alpha ( NUM ) ; XY Plot plot = ( XY Plot ) chart . get Plot ( ) ; plot . set Range Gridlines Visible ( BOOL ) ; plot . set Domain Gridlines Visible ( BOOL ) ; plot . set Outline Visible ( BOOL ) ; plot . set Range Zero Baseline Visible ( BOOL ) ; plot . set Domain Zero Baseline Visible ( BOOL ) ; plot . set Background Paint ( COLOR INVISIBLE ) ; plot . set Background Image Alpha ( NUM ) ; XY Bar Renderer renderer = ( XY Bar Renderer ) plot . get Renderer ( ) ; renderer . set Series Paint ( NUM , Attribute Gui Tools . get Color For Value Type ( Ontology . NUMERICAL ) ) ; renderer . set Bar Painter ( new Standard XY Bar Painter ( ) ) ; renderer . set Draw Bar Outline ( BOOL ) ; renderer . set Shadow Visible ( BOOL ) ; return chart ; }
List < Type > save ( ) { List Buffer < Type > buf = new List Buffer < > ( ) ; for ( Type t : undetvars ) { Undet Var uv = ( Undet Var ) t ; Undet Var uv 2 = new Undet Var ( ( Type Var ) uv . qtype , types ) ; for ( Inference Bound ib : Inference Bound . values ( ) ) { for ( Type b : uv . get Bounds ( ib ) ) { uv 2 . add Bound ( ib , b , types ) ; } } uv 2 . inst = uv . inst ; buf . add ( uv 2 ) ; } return buf . to List ( ) ; }
public int execute Process ( ) { final List < String > process Strings = tokenize String ( exec Command ) ; process Strings . add All ( tokenize String ( script ) ) ; logger . info ( Message Format . format ( STRING , process Strings ) ) ; final Process Builder process Builder = new Process Builder ( process Strings ) ; if ( working Directory != null ) { final Path dir = Paths . get ( working Directory ) ; if ( Files . not Exists ( dir ) ) { try { Files . create Directories ( dir ) ; } catch ( IO Exception e ) { logger . warning ( STRING + working Directory ) ; return - NUM ; } } else if ( ! Files . is Directory ( dir ) ) { logger . warning ( working Directory + STRING ) ; return - NUM ; } final File directory = dir . to File ( ) ; process Builder . directory ( directory ) ; } process Builder . redirect Error Stream ( BOOL ) ; Integer exit Value ; try { logger . info ( STRING ) ; final Process process = process Builder . start ( ) ; send Input String To Process ( process ) ; handle Process Output ( process ) ; try { exit Value = process . wait For ( ) ; } catch ( Interrupted Exception e ) { logger . warning ( STRING ) ; process . destroy ( ) ; exit Value = - NUM ; } logger . info ( STRING + exit Value + STRING ) ; } catch ( IO Exception e ) { logger . log ( SEVERE , STRING , e . get Cause ( ) ) ; exit Value = - NUM ; } return exit Value ; }
static void check Method Desc ( final String desc ) { if ( desc == null || desc . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( desc . char At ( NUM ) != STRING || desc . length ( ) < NUM ) { throw new Illegal Argument Exception ( STRING + desc ) ; } int start = NUM ; if ( desc . char At ( start ) != STRING ) { do { if ( desc . char At ( start ) == STRING ) { throw new Illegal Argument Exception ( STRING + desc ) ; } start = check Desc ( desc , start , BOOL ) ; } while ( start < desc . length ( ) && desc . char At ( start ) != STRING ) ; } start = check Desc ( desc , start + NUM , BOOL ) ; if ( start != desc . length ( ) ) { throw new Illegal Argument Exception ( STRING + desc ) ; } }
protected Rectangle apply Margins ( Rectangle rect , float [ ] margins , boolean reverse ) { if ( is Positioned ( ) ) return rect ; return rect . < Rectangle > apply Margins ( margins [ NUM ] , margins [ NUM ] , margins [ NUM ] , margins [ NUM ] , reverse ) ; }
private void reset Attempts ( ) { for ( final Political Action Attachment paa : Political Action Attachment . get Political Action Attachments ( m player ) ) { paa . reset Attempts ( get Bridge ( ) ) ; } }
public static Number minus ( Character left , Character right ) { return minus ( Integer . value Of ( left ) , right ) ; }
public void find And Init ( Object some Obj ) { if ( some Obj instanceof Mouse Delegator ) { Debug . message ( STRING , STRING ) ; set Mouse Delegator ( ( Mouse Delegator ) some Obj ) ; } }
public static int to Int ( final String value ) { return Integer . parse Int ( value ) ; }
protected Object evaluate Left Less Right ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Left Less Right ( ( Structured Content ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM ) { return ( Structured Content ) array . get ( NUM ) ; } return array ; }
static void check Type Ref And Path ( int type Ref , Type Path type Path ) { int mask = NUM ; switch ( type Ref > > > NUM ) { case Type Reference . CLASS TYPE PARAMETER : case Type Reference . METHOD TYPE PARAMETER : case Type Reference . METHOD FORMAL PARAMETER : mask = NUM ; break ; case Type Reference . FIELD : case Type Reference . METHOD RETURN : case Type Reference . METHOD RECEIVER : case Type Reference . LOCAL VARIABLE : case Type Reference . RESOURCE VARIABLE : case Type Reference . INSTANCEOF : case Type Reference . NEW : case Type Reference . CONSTRUCTOR REFERENCE : case Type Reference . METHOD REFERENCE : mask = NUM ; break ; case Type Reference . CLASS EXTENDS : case Type Reference . CLASS TYPE PARAMETER BOUND : case Type Reference . METHOD TYPE PARAMETER BOUND : case Type Reference . THROWS : case Type Reference . EXCEPTION PARAMETER : mask = NUM ; break ; case Type Reference . CAST : case Type Reference . CONSTRUCTOR INVOCATION TYPE ARGUMENT : case Type Reference . METHOD INVOCATION TYPE ARGUMENT : case Type Reference . CONSTRUCTOR REFERENCE TYPE ARGUMENT : case Type Reference . METHOD REFERENCE TYPE ARGUMENT : mask = NUM ; break ; default : throw new Illegal Argument Exception ( STRING + Integer . to Hex String ( type Ref > > > NUM ) ) ; } if ( ( type Ref & ~ mask ) != NUM ) { throw new Illegal Argument Exception ( STRING + Integer . to Hex String ( type Ref ) ) ; } if ( type Path != null ) { for ( int i = NUM ; i < type Path . get Length ( ) ; ++ i ) { int step = type Path . get Step ( i ) ; if ( step != Type Path . ARRAY ELEMENT && step != Type Path . INNER TYPE && step != Type Path . TYPE ARGUMENT && step != Type Path . WILDCARD BOUND ) { throw new Illegal Argument Exception ( STRING + i + STRING + type Path ) ; } if ( step != Type Path . TYPE ARGUMENT && type Path . get Step Argument ( i ) != NUM ) { throw new Illegal Argument Exception ( STRING + i + STRING + type Path ) ; } } } }
public void remove Catchable ( Catchable Pokemon pokemon ) { if ( cached Catchable . size ( ) > NUM ) { cached Catchable . remove ( pokemon ) ; } }
@ Suppress Warnings ( STRING ) @ Override protected void fill Buffer ( ) { int old P = p ; int index = tokens . size ( ) ; Token t = token Source . next Token ( ) ; while ( t != null && t . get Type ( ) != Char Stream . EOF ) { int type = t . get Type ( ) ; if ( type == Internal N 4 JS Lexer . Solidus || type == Internal N 4 JS Lexer . Solidus Equals Sign || type == Internal N 4 JS Lexer . Right Curly Bracket ) { t . set Token Index ( index ) ; tokens . add ( t ) ; index ++ ; break ; } boolean discard = BOOL ; if ( channel Override Map != null ) { Integer channel I = ( Integer ) channel Override Map . get ( Integer . value Of ( type ) ) ; if ( channel I != null ) { t . set Channel ( channel I . int Value ( ) ) ; } } if ( discard Set != null && discard Set . contains ( Integer . value Of ( type ) ) ) { discard = BOOL ; } else if ( discard Off Channel Tokens && t . get Channel ( ) != this . channel ) { discard = BOOL ; } if ( ! discard ) { t . set Token Index ( index ) ; tokens . add ( t ) ; index ++ ; } t = token Source . next Token ( ) ; } p = old P == - NUM ? NUM : old P ; p = skip Off Token Channels ( p ) ; }
char case Fold ( char c ) { if ( alternate Casing ) { if ( c == STRING ) { return STRING ; } else if ( c == STRING ) { return STRING ; } else { return Character . to Lower Case ( c ) ; } } else { return Character . to Lower Case ( c ) ; } }
public void write Counts Comparison List ( final String filename , final String format ) { if ( format . compare To Ignore Case ( STRING ) == NUM ) { Count Sim Comparison KML Writer kml Writer = new Count Sim Comparison KML Writer ( counts Comparison List , this . network , Transformation Factory . get Coordinate Transformation ( this . coordinate System , Transformation Factory . WGS 84 ) ) ; kml Writer . write File ( filename ) ; } else if ( format . compare To Ignore Case ( STRING ) == NUM ) { Count Sim Comparison Table Writer writer = new Count Sim Comparison Table Writer ( counts Comparison List , Locale . US ) ; writer . write File ( filename ) ; } else { throw new Illegal Argument Exception ( STRING ) ; } Comparison Error Stats Calculator error Stats = new Comparison Error Stats Calculator ( counts Comparison List ) ; double [ ] hours = new double [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { hours [ i - NUM ] = i ; } Double Array Table Writer table Writer = new Double Array Table Writer ( ) ; table Writer . add Column ( hours ) ; table Writer . add Column ( error Stats . get Mean Rel Error ( ) ) ; table Writer . write File ( filename + STRING ) ; }
public void test Subtract Math Context Diff Scale Pos Neg ( ) { String a = STRING ; int a Scale = NUM ; String b = STRING ; int b Scale = - NUM ; String c = STRING ; int c Scale = - NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; Math Context mc = new Math Context ( NUM , Rounding Mode . DOWN ) ; Big Decimal result = a Number . subtract ( b Number , mc ) ; assert Equals ( STRING , c , result . to String ( ) ) ; assert Equals ( STRING , c Scale , result . scale ( ) ) ; }
public void put Grammar ( DTD Grammar grammar ) { XMLDTD Description desc = ( XMLDTD Description ) grammar . get Grammar Description ( ) ; f Grammars . put ( desc , grammar ) ; }
public Service Call < Translation Result > translate ( final String text , final Language source , final Language target ) { return translate ( Collections . singleton List ( text ) , source , target ) ; }
@ Override public int execute ( final Form Object form , final int type , final String code , final int event Type , final char key Pressed ) { int message Code ; final String js = code ; final String [ ] args = JS Function . convert To Array ( js ) ; final String command = args [ NUM ] ; if ( command . starts With ( STRING ) ) { message Code = handle AF Commands ( form , command , js , args , event Type , key Pressed ) ; } else { execute Functions ( js , form , acro ) ; message Code = Action Handler . VALUESCHANGED ; } if ( type == Pdf Dictionary . F ) { calcualte Event ( ) ; message Code = Action Handler . VALUESCHANGED ; } return message Code ; }
private Object read Resolve ( ) { synchronized ( levels ) { for ( Level level : levels ) { if ( value != level . value ) { continue ; } if ( ! name . equals ( level . name ) ) { continue ; } if ( Objects . equal ( resource Bundle Name , level . resource Bundle Name ) ) { return level ; } } levels . add ( this ) ; return this ; } }
private static void repeat ( String pattern , int count , Appendable out ) throws IO Exception { while ( count >= pattern . length ( ) ) { out . append ( pattern ) ; count -= pattern . length ( ) ; } if ( count > NUM ) { out . append ( pattern , NUM , count ) ; } }
private void clean Up ( Reference < ? > reference ) throws Shut Down { Method finalize Referent Method = get Finalize Referent Method ( ) ; do { reference . clear ( ) ; if ( reference == frq Reference ) { throw new Shut Down ( ) ; } try { finalize Referent Method . invoke ( reference ) ; } catch ( Throwable t ) { logger . log ( Level . SEVERE , STRING , t ) ; } } while ( ( reference = queue . poll ( ) ) != null ) ; }
private boolean is Mineshafter Present ( ) { try { Class . for Name ( STRING ) ; return BOOL ; } catch ( Exception e ) { return BOOL ; } }
public @ Check For Null Queue . Item run 2 ( @ Nonnull String replacement Main Script , @ Nonnull Map < String , String > replacement Loaded Scripts ) { List < Action > actions = new Array List < Action > ( ) ; Cps Flow Execution execution = get Execution ( ) ; if ( execution == null ) { return null ; } actions . add ( new Replay Flow Factory Action ( replacement Main Script , replacement Loaded Scripts , execution . is Sandbox ( ) ) ) ; actions . add ( new Cause Action ( new Cause . User Id Cause ( ) , new Replay Cause ( run ) ) ) ; for ( Class < ? extends Action > c : COPIED ACTIONS ) { actions . add All ( run . get Actions ( c ) ) ; } return Parameterized Job Mix In . schedule Build 2 ( run . get Parent ( ) , NUM , actions . to Array ( new Action [ actions . size ( ) ] ) ) ; }
public static Secret Keys keys ( String keys Str ) throws Invalid Key Exception { String [ ] keys Arr = keys Str . split ( STRING ) ; if ( keys Arr . length != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } else { byte [ ] confidentiality Key = Base 64 . decode ( keys Arr [ NUM ] , BASE 64 FLAGS ) ; if ( confidentiality Key . length != AES KEY LENGTH BITS / NUM ) { throw new Invalid Key Exception ( STRING + AES KEY LENGTH BITS + STRING ) ; } byte [ ] integrity Key = Base 64 . decode ( keys Arr [ NUM ] , BASE 64 FLAGS ) ; if ( integrity Key . length != HMAC KEY LENGTH BITS / NUM ) { throw new Invalid Key Exception ( STRING + HMAC KEY LENGTH BITS + STRING ) ; } Secret Keys secret Keys = new Secret Keys ( ) ; Secret Key Spec secret Key Spec = new Secret Key Spec ( ) ; secret Key Spec . generate ( confidentiality Key , NUM , confidentiality Key . length , CIPHER ) ; Secret Key Spec secret Key Spec 1 = new Secret Key Spec ( ) ; secret Key Spec 1 . generate ( integrity Key , HMAC ALGORITHM ) ; secret Keys . set Confidentiality Key ( secret Key Spec ) ; secret Keys . set Integrity Key ( secret Key Spec 1 ) ; return secret Keys ; } }
public Path [ ] choose Starting Paths ( final int nedges , final Path [ ] paths ) { final List < Path > tmp = new Linked List < Path > ( ) ; Arrays . sort ( paths , NUM , paths . length , Estimated Cardinality Comparator . INSTANCE ) ; for ( int i = NUM ; i < paths . length && i < nedges ; i ++ ) { tmp . add ( paths [ i ] ) ; } return tmp . to Array ( new Path [ tmp . size ( ) ] ) ; }
private void safe Bottom View ( ) { Status status = get Open Status ( ) ; View Group bottom = get Bottom View ( ) ; if ( status == Status . Close ) { if ( bottom . get Visibility ( ) != INVISIBLE ) bottom . set Visibility ( INVISIBLE ) ; } else { if ( bottom . get Visibility ( ) != VISIBLE ) bottom . set Visibility ( VISIBLE ) ; } }
public static int uniform ( int n ) { if ( n <= NUM ) throw new Illegal Argument Exception ( STRING ) ; return random . next Int ( n ) ; }
private void view Delta ( final Item item ) { final Delta Fragment fragment = Delta Fragment . new Instance ( item ) ; navigate To Fragment ( fragment ) ; }
public Message ( String type , double value ) { if ( ! VALID TYPES . contains ( type ) ) { throw new Illegal Argument Exception ( type + STRING + STRING ) ; } this . type = type ; this . value = value ; }
public void add All ( final Casualty List casualty List ) { m damaged . add All ( casualty List . get Damaged ( ) ) ; m killed . add All ( casualty List . get Killed ( ) ) ; }
public static String import Result Set ( Result Set source , Database db , String name , Import Filter filter , boolean use Existing Table ) throws SQL Exception , IO Exception { Result Set Meta Data md = source . get Meta Data ( ) ; name = Table Builder . escape Identifier ( name ) ; Table table = null ; if ( ! use Existing Table || ( ( table = db . get Table ( name ) ) == null ) ) { List < Column Builder > columns = to Columns ( md ) ; table = create Unique Table ( db , name , columns , md , filter ) ; } List < Object [ ] > rows = new Array List < Object [ ] > ( COPY TABLE BATCH SIZE ) ; int num Columns = md . get Column Count ( ) ; while ( source . next ( ) ) { Object [ ] row = new Object [ num Columns ] ; for ( int i = NUM ; i < row . length ; i ++ ) { row [ i ] = source . get Object ( i + NUM ) ; } row = filter . filter Row ( row ) ; if ( row == null ) { continue ; } rows . add ( row ) ; if ( rows . size ( ) == COPY TABLE BATCH SIZE ) { table . add Rows ( rows ) ; rows . clear ( ) ; } } if ( rows . size ( ) > NUM ) { table . add Rows ( rows ) ; } return table . get Name ( ) ; }
@ Override public long skip ( long n ) throws IO Exception { long remaining = n ; final char [ ] ch = new char [ f Buffer . length ] ; do { int length = ch . length < remaining ? ch . length : ( int ) remaining ; int count = read ( ch , NUM , length ) ; if ( count > NUM ) { remaining -= count ; } else { break ; } } while ( remaining > NUM ) ; long skipped = n - remaining ; return skipped ; }
public static long [ ] hash To Longs ( double datum , long seed ) { double d = ( datum == NUM ) ? NUM : datum ; long [ ] data = { Double . double To Long Bits ( d ) } ; return hash ( data , seed ) ; }
private boolean allow Upload Crash Dump ( ) { if ( is Cellular Experiment Enabled ( ) ) return is Usage And Crash Reporting Enabled ( ) ; if ( is Mobile Network Capable ( ) ) { String option = m Shared Preferences . get String ( PREF CRASH DUMP UPLOAD , m Crash Dump Never Upload ) ; return option . equals ( m Crash Dump Always Upload ) || ( option . equals ( m Crash Dump Wifi Only Upload ) && is Wi Fi Or Ethernet Network ( ) ) ; } return m Shared Preferences . get Boolean ( PREF CRASH DUMP UPLOAD NO CELLULAR , BOOL ) ; }
private int [ ] join Map ( int [ ] a , int [ ] b ) { if ( a == null ) { return b ; } if ( b == null ) { return a ; } int [ ] result = new int [ a . length + b . length ] ; System . arraycopy ( a , NUM , result , NUM , a . length ) ; System . arraycopy ( b , NUM , result , a . length , b . length ) ; return result ; }
private void read Object ( Object Input Stream in ) throws Class Not Found Exception , IO Exception { in . default Read Object ( ) ; iter = col . iterator ( ) ; }
public Label Set ( int indices [ ] , boolean sort ) { this . indices = indices ; if ( sort == BOOL ) Arrays . sort ( this . indices ) ; }
public void diff Equals ( ) { double [ ] col = null ; for ( int i = NUM ; i < A . length ; i ++ ) { col = new double [ A [ i ] . length - NUM ] ; for ( int j = NUM ; j < A [ i ] . length ; j ++ ) col [ j - NUM ] = Math . abs ( A [ i ] [ j ] - A [ i ] [ j - NUM ] ) ; A [ i ] = col ; } n -- ; }
private static void print Stack Trace Element ( Stack Trace Element trace , Print Writer out , Class Loader loader ) { try { Line Map map = get Script Line Map ( trace . get Class Name ( ) , loader ) ; if ( map != null ) { Line Map . Line line = map . get Line ( trace . get Line Number ( ) ) ; if ( line != null ) { out . print ( trace . get Class Name ( ) + STRING + trace . get Method Name ( ) ) ; out . print ( STRING + line . get Source Filename ( ) + STRING ) ; out . println ( line . get Source Line ( trace . get Line Number ( ) ) + STRING ) ; return ; } } } catch ( Throwable e ) { } out . println ( trace ) ; }
private static void decode Text Compaction ( int [ ] text Compaction Data , int [ ] byte Compaction Data , int length , String Builder result ) { Mode sub Mode = Mode . ALPHA ; Mode prior To Shift Mode = Mode . ALPHA ; int i = NUM ; while ( i < length ) { int sub Mode Ch = text Compaction Data [ i ] ; char ch = NUM ; switch ( sub Mode ) { case ALPHA : if ( sub Mode Ch < NUM ) { ch = ( char ) ( STRING + sub Mode Ch ) ; } else { if ( sub Mode Ch == NUM ) { ch = STRING ; } else if ( sub Mode Ch == LL ) { sub Mode = Mode . LOWER ; } else if ( sub Mode Ch == ML ) { sub Mode = Mode . MIXED ; } else if ( sub Mode Ch == PS ) { prior To Shift Mode = sub Mode ; sub Mode = Mode . PUNCT SHIFT ; } else if ( sub Mode Ch == MODE SHIFT TO BYTE COMPACTION MODE ) { result . append ( ( char ) byte Compaction Data [ i ] ) ; } else if ( sub Mode Ch == TEXT COMPACTION MODE LATCH ) { sub Mode = Mode . ALPHA ; } } break ; case LOWER : if ( sub Mode Ch < NUM ) { ch = ( char ) ( STRING + sub Mode Ch ) ; } else { if ( sub Mode Ch == NUM ) { ch = STRING ; } else if ( sub Mode Ch == AS ) { prior To Shift Mode = sub Mode ; sub Mode = Mode . ALPHA SHIFT ; } else if ( sub Mode Ch == ML ) { sub Mode = Mode . MIXED ; } else if ( sub Mode Ch == PS ) { prior To Shift Mode = sub Mode ; sub Mode = Mode . PUNCT SHIFT ; } else if ( sub Mode Ch == MODE SHIFT TO BYTE COMPACTION MODE ) { result . append ( ( char ) byte Compaction Data [ i ] ) ; } else if ( sub Mode Ch == TEXT COMPACTION MODE LATCH ) { sub Mode = Mode . ALPHA ; } } break ; case MIXED : if ( sub Mode Ch < PL ) { ch = MIXED CHARS [ sub Mode Ch ] ; } else { if ( sub Mode Ch == PL ) { sub Mode = Mode . PUNCT ; } else if ( sub Mode Ch == NUM ) { ch = STRING ; } else if ( sub Mode Ch == LL ) { sub Mode = Mode . LOWER ; } else if ( sub Mode Ch == AL ) { sub Mode = Mode . ALPHA ; } else if ( sub Mode Ch == PS ) { prior To Shift Mode = sub Mode ; sub Mode = Mode . PUNCT SHIFT ; } else if ( sub Mode Ch == MODE SHIFT TO BYTE COMPACTION MODE ) { result . append ( ( char ) byte Compaction Data [ i ] ) ; } else if ( sub Mode Ch == TEXT COMPACTION MODE LATCH ) { sub Mode = Mode . ALPHA ; } } break ; case PUNCT : if ( sub Mode Ch < PAL ) { ch = PUNCT CHARS [ sub Mode Ch ] ; } else { if ( sub Mode Ch == PAL ) { sub Mode = Mode . ALPHA ; } else if ( sub Mode Ch == MODE SHIFT TO BYTE COMPACTION MODE ) { result . append ( ( char ) byte Compaction Data [ i ] ) ; } else if ( sub Mode Ch == TEXT COMPACTION MODE LATCH ) { sub Mode = Mode . ALPHA ; } } break ; case ALPHA SHIFT : sub Mode = prior To Shift Mode ; if ( sub Mode Ch < NUM ) { ch = ( char ) ( STRING + sub Mode Ch ) ; } else { if ( sub Mode Ch == NUM ) { ch = STRING ; } else if ( sub Mode Ch == TEXT COMPACTION MODE LATCH ) { sub Mode = Mode . ALPHA ; } } break ; case PUNCT SHIFT : sub Mode = prior To Shift Mode ; if ( sub Mode Ch < PAL ) { ch = PUNCT CHARS [ sub Mode Ch ] ; } else { if ( sub Mode Ch == PAL ) { sub Mode = Mode . ALPHA ; } else if ( sub Mode Ch == MODE SHIFT TO BYTE COMPACTION MODE ) { result . append ( ( char ) byte Compaction Data [ i ] ) ; } else if ( sub Mode Ch == TEXT COMPACTION MODE LATCH ) { sub Mode = Mode . ALPHA ; } } break ; } if ( ch != NUM ) { result . append ( ch ) ; } i ++ ; } }
public void read Information Object ( final Pdf Object info Obj , final Object Decoder object Decoder ) { try { object Decoder . check Resolved ( info Obj ) ; } catch ( final Exception e ) { Log Writer . write Log ( STRING + e . get Message ( ) ) ; } String new Value ; int id ; byte [ ] data ; final int count = Pdf File Information . information field I Ds . length ; for ( int i = NUM ; i < count ; i ++ ) { id = Pdf File Information . information field I Ds [ i ] ; if ( id == Pdf Dictionary . Trapped ) { new Value = info Obj . get Name ( id ) ; if ( new Value == null ) { new Value = STRING ; } } else { data = info Obj . get Text Stream Value As Byte ( id ) ; if ( data == null ) { new Value = STRING ; } else { new Value = String Utils . get Text String ( data , BOOL ) ; } } set Field Value ( i , new Value ) ; } }
private void cmd calculate Difference ( ) { Big Decimal previous Value , actual Value ; Timestamp today = Time Util . get Day ( System . current Time Millis ( ) ) ; M Cash cash = M Cash . get ( p pos . get Ctx ( ) , p pos . get C Cash Book ID ( ) , today , null ) ; v previous Balance . set Value ( cash . get Ending Balance ( ) ) ; previous Value = cash . get Ending Balance ( ) ; actual Value = ( Big Decimal ) v Actual Balance . get Value ( ) ; v difference . set Value ( actual Value . subtract ( previous Value ) ) ; }
public boolean test Allocation ( ) { boolean change = BOOL ; if ( is Processed ( ) ) { Big Decimal alloc = get Allocated Amt ( ) ; if ( alloc == null ) alloc = Env . ZERO ; Big Decimal total = get Grand Total ( ) ; if ( ! is SO Trx ( ) ) total = total . negate ( ) ; if ( is Credit Memo ( ) ) total = total . negate ( ) ; boolean test = total . compare To ( alloc ) == NUM ; change = test != is Paid ( ) ; if ( change ) set Is Paid ( test ) ; log . fine ( STRING + test + STRING + alloc + STRING + total + STRING ) ; } return change ; }
private void request For Upload ( OC File file ) { File Uploader . Upload Requester requester = new File Uploader . Upload Requester ( ) ; requester . upload Update ( m Context , m Account , file , File Uploader . LOCAL BEHAVIOUR MOVE , BOOL ) ; m Transfer Was Requested = BOOL ; }
protected void decode Image Data ( ) { int Null Code = - NUM ; int npix = iw * ih ; int available , clear , code mask , code size , end of information , in code , old code , bits , code , count , i , datum , data size , first , top , bi , pi ; if ( ( pixels == null ) || ( pixels . length < npix ) ) { pixels = new byte [ npix ] ; } if ( prefix == null ) prefix = new short [ Max Stack Size ] ; if ( suffix == null ) suffix = new byte [ Max Stack Size ] ; if ( pixel Stack == null ) pixel Stack = new byte [ Max Stack Size + NUM ] ; data size = read ( ) ; clear = NUM << data size ; end of information = clear + NUM ; available = clear + NUM ; old code = Null Code ; code size = data size + NUM ; code mask = ( NUM << code size ) - NUM ; for ( code = NUM ; code < clear ; code ++ ) { prefix [ code ] = NUM ; suffix [ code ] = ( byte ) code ; } datum = bits = count = first = top = pi = bi = NUM ; for ( i = NUM ; i < npix ; ) { if ( top == NUM ) { if ( bits < code size ) { if ( count == NUM ) { count = read Block ( ) ; if ( count <= NUM ) break ; bi = NUM ; } datum += ( ( ( int ) block [ bi ] ) & NUM ) << bits ; bits += NUM ; bi ++ ; count -- ; continue ; } code = datum & code mask ; datum >>= code size ; bits -= code size ; if ( ( code > available ) || ( code == end of information ) ) break ; if ( code == clear ) { code size = data size + NUM ; code mask = ( NUM << code size ) - NUM ; available = clear + NUM ; old code = Null Code ; continue ; } if ( old code == Null Code ) { pixel Stack [ top ++ ] = suffix [ code ] ; old code = code ; first = code ; continue ; } in code = code ; if ( code == available ) { pixel Stack [ top ++ ] = ( byte ) first ; code = old code ; } while ( code > clear ) { pixel Stack [ top ++ ] = suffix [ code ] ; code = prefix [ code ] ; } first = ( ( int ) suffix [ code ] ) & NUM ; if ( available >= Max Stack Size ) break ; pixel Stack [ top ++ ] = ( byte ) first ; prefix [ available ] = ( short ) old code ; suffix [ available ] = ( byte ) first ; available ++ ; if ( ( ( available & code mask ) == NUM ) && ( available < Max Stack Size ) ) { code size ++ ; code mask += available ; } old code = in code ; } top -- ; pixels [ pi ++ ] = pixel Stack [ top ] ; i ++ ; } for ( i = pi ; i < npix ; i ++ ) { pixels [ i ] = NUM ; } }
void refresh Custom Master List ( ) { if ( custom Master Countries == null || custom Master Countries . length ( ) == NUM ) { custom Master Countries List = null ; } else { List < Country > local Country List = new Array List < > ( ) ; for ( String name Code : custom Master Countries . split ( STRING ) ) { Country country = Country . get Country For Name Code From Library Master List ( custom Language , name Code ) ; if ( country != null ) { if ( ! is Already In List ( country , local Country List ) ) { local Country List . add ( country ) ; } } } if ( local Country List . size ( ) == NUM ) { custom Master Countries List = null ; } else { custom Master Countries List = local Country List ; } } if ( custom Master Countries List != null ) { for ( Country country : custom Master Countries List ) { country . log ( ) ; } } else { } }
protected boolean is Dto Getter ( Method method ) { if ( method . is Annotation Present ( Delegate To . class ) ) { return BOOL ; } String method Name = method . get Name ( ) ; if ( ( method Name . starts With ( STRING ) || method Name . starts With ( STRING ) ) && method . get Parameter Types ( ) . length == NUM ) { if ( method Name . length ( ) > NUM && method Name . starts With ( STRING ) ) { return method . get Return Type ( ) == Boolean . class || method . get Return Type ( ) == boolean . class ; } return method Name . length ( ) > NUM ; } return BOOL ; }
protected void handle Parse Conversion Exception ( Exception e ) throws SAX Exception { if ( e instanceof Runtime Exception ) throw ( Runtime Exception ) e ; Parse Conversion Event pce = new Parse Conversion Event Impl ( Validation Event . ERROR , e . get Message ( ) , new Validation Event Locator Impl ( context . get Locator ( ) ) , e ) ; context . handle Event ( pce , BOOL ) ; }
private static char [ ] yy unpack cmap ( String packed ) { char [ ] map = new char [ NUM ] ; int i = NUM ; int j = NUM ; while ( i < NUM ) { int count = packed . char At ( i ++ ) ; char value = packed . char At ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM ) ; } return map ; }
public Status Bar ( boolean show Memory ) { super ( new Border Layout ( ) ) ; add ( create Info Panel ( ) , Border Layout . WEST ) ; if ( show Memory ) { add ( create Memory Status ( ) , Border Layout . CENTER ) ; J Panel icon Panel = new J Panel ( new Border Layout ( ) ) ; icon Panel . add ( new J Label ( new Angled Lines Windows Corner Icon ( ) ) , Border Layout . SOUTH ) ; add ( icon Panel , Border Layout . EAST ) ; } else { set Background ( Color . WHITE ) ; } }
public void execute ( final Runnable task ) { String name = metadata . get ( Metadata . RESOURCE NAME KEY ) ; if ( name != null ) { name = STRING + name ; } else { name = STRING ; } final Thread thread = new Thread ( task , name ) ; thread . set Daemon ( BOOL ) ; thread . start ( ) ; }
static int string Size ( String string ) { int size = NUM ; if ( string != null ) { size += HEADERS + NUM * NUM ; size += HEADERS + NUM * string . length ( ) ; } return size ; }
public static Graph Request new Post Open Graph Object Request ( Access Token access Token , JSON Object open Graph Object , Callback callback ) { if ( open Graph Object == null ) { throw new Facebook Exception ( STRING ) ; } if ( Utility . is Null Or Empty ( open Graph Object . opt String ( STRING ) ) ) { throw new Facebook Exception ( STRING ) ; } if ( Utility . is Null Or Empty ( open Graph Object . opt String ( STRING ) ) ) { throw new Facebook Exception ( STRING ) ; } String path = String . format ( MY OBJECTS FORMAT , open Graph Object . opt String ( STRING ) ) ; Bundle bundle = new Bundle ( ) ; bundle . put String ( OBJECT PARAM , open Graph Object . to String ( ) ) ; return new Graph Request ( access Token , path , bundle , Http Method . POST , callback ) ; }
public void add Graph ( Graph g ) { graphs . add ( g ) ; }
protected void add To Quarantine Queue ( Node Port Tuple npt ) { if ( quarantine Queue . contains ( npt ) == BOOL ) { quarantine Queue . add ( npt ) ; } }
private Mrc Message load Chars ( ) throws java . io . IO Exception { int nchars ; byte [ ] rcv Buffer = new byte [ NUM ] ; nchars = inpipe . read ( rcv Buffer , NUM , NUM ) ; Mrc Message msg = new Mrc Message ( nchars ) ; for ( int i = NUM ; i < nchars ; i ++ ) { msg . set Element ( i , rcv Buffer [ i ] & NUM ) ; } return msg ; }
@ Suppress Warnings ( STRING ) @ Override protected Money handle Transaction That Is A Late Repayment Of Installment ( final Loan Repayment Schedule Installment current Installment , final List < Loan Repayment Schedule Installment > installments , final Loan Transaction loan Transaction , final Money transaction Amount Unprocessed , List < Loan Transaction To Repayment Schedule Mapping > transaction Mappings ) { return handle Transaction That Is On Time Payment Of Installment ( current Installment , loan Transaction , transaction Amount Unprocessed , transaction Mappings ) ; }
protected void fire Tuple Event ( Table t , int start , int end , int type ) { if ( m tuple Listeners != null && m tuple Listeners . size ( ) > NUM ) { Object [ ] lstnrs = m tuple Listeners . get Array ( ) ; Tuple [ ] tuples = new Tuple [ end - start + NUM ] ; for ( int i = NUM , r = start ; r <= end ; ++ r , ++ i ) { tuples [ i ] = t . get Tuple ( r ) ; } for ( int i = NUM ; i < lstnrs . length ; ++ i ) { Tuple Set Listener tsl = ( Tuple Set Listener ) lstnrs [ i ] ; if ( type == Event Constants . INSERT ) { tsl . tuple Set Changed ( this , tuples , EMPTY ARRAY ) ; } else { tsl . tuple Set Changed ( this , EMPTY ARRAY , tuples ) ; } } } }
public String build Query ( String [ ] projection In , String selection , String group By , String having , String sort Order , String limit ) { String [ ] projection = compute Projection ( projection In ) ; String Builder where = new String Builder ( ) ; boolean has Base Where Clause = m Where Clause != null && m Where Clause . length ( ) > NUM ; if ( has Base Where Clause ) { where . append ( m Where Clause . to String ( ) ) ; where . append ( STRING ) ; } if ( selection != null && selection . length ( ) > NUM ) { if ( has Base Where Clause ) { where . append ( STRING ) ; } where . append ( STRING ) ; where . append ( selection ) ; where . append ( STRING ) ; } return build Query String ( m Distinct , m Tables , projection , where . to String ( ) , group By , having , sort Order , limit ) ; }
public static boolean is Exception Time ( Calendar schedule Time , Schedule Info schedule Info ) throws Exception { if ( schedule Info . get Date Exceptions ( ) != null ) { for ( String date Exception : schedule Info . get Date Exceptions ( ) ) { Date Format formatter = new Simple Date Format ( Schedule Info . FULL DAYTIME FORMAT ) ; Date date = formatter . parse ( schedule Info . get Start Date ( ) ) ; Calendar exception Time = Calendar . get Instance ( Time Zone . get Time Zone ( STRING ) ) ; exception Time . set Time ( date ) ; if ( exception Time . equals ( schedule Time ) ) { log . info ( STRING , schedule Time . to String ( ) ) ; return BOOL ; } } } return BOOL ; }
protected void init Port ( ) { String port Param = get Init Parameter ( STRING ) ; set Port ( ( port Param == null ) ? DEFAULT PORT : Integer . parse Int ( port Param ) ) ; if ( is Debug ( ) ) { log ( STRING + get Port ( ) ) ; } }
public JPEGQ Table ( int [ ] table ) { if ( table == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( table . length != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } q Table = Arrays . copy Of ( table , table . length ) ; }
public VN Xe Nfs Share find Snap Nfs Share ( String snap Id , String share Name , String software Version ) { String Builder query Filter = new String Builder ( VN Xe Constants . NAME FILTER ) ; if ( ! VN Xe Utils . is Higher Version ( software Version , VN Xe Constants . VNXE BASE SOFT VER ) ) { query Filter . append ( share Name ) ; query Filter . append ( VN Xe Constants . AND ) ; query Filter . append ( VN Xe Constants . SNAP FILTER ) ; query Filter . append ( snap Id ) ; } else { query Filter . append ( STRING + share Name + STRING ) ; query Filter . append ( VN Xe Constants . AND ) ; query Filter . append ( VN Xe Constants . SNAP FILTER V31 ) ; query Filter . append ( STRING + snap Id + STRING ) ; } set Filter ( query Filter . to String ( ) ) ; VN Xe Nfs Share result = null ; List < VN Xe Nfs Share > share List = get Data For Objects ( VN Xe Nfs Share . class ) ; if ( share List != null && ! share List . is Empty ( ) ) { result = share List . get ( NUM ) ; logger . info ( STRING , snap Id , share Name ) ; } else { logger . info ( STRING , snap Id , share Name ) ; } return result ; }
@ Override public final int read ( ) throws IO Exception { Byte Buffer bb = wait For Available Data ( ) ; return ( bb . get ( ) & NUM ) ; }
protected Token Position ( Token Position other ) { Objects . require Non Null ( other ) ; this . line = other . line ; this . column = other . column ; this . offset = other . offset ; }
private J Component create Detail Panel ( Throwable error ) { Stack Trace List stl = new Stack Trace List ( error ) ; J Scroll Pane detail Pane = new Extended J Scroll Pane ( stl ) ; detail Pane . set Preferred Size ( new Dimension ( get Width ( ) , NUM ) ) ; detail Pane . set Border ( null ) ; return detail Pane ; }
abstract boolean contains Key ( T container , String key ) ;
private JMX Connector connect ( String host , int port ) { try { if ( ! is Node Available ( host ) ) { log . info ( STRING , host ) ; throw new Illegal State Exception ( STRING ) ; } log . debug ( STRING , host , port ) ; String connector Address = String . format ( service Url , host , port ) ; JMX Service URL jmx Url = new JMX Service URL ( connector Address ) ; return JMX Connector Factory . connect ( jmx Url ) ; } catch ( Malformed URL Exception e ) { log . error ( String . format ( STRING , host , port ) , e ) ; throw new Illegal State Exception ( STRING ) ; } catch ( IO Exception e ) { log . error ( String . format ( STRING , host , port ) , e ) ; throw new Illegal State Exception ( STRING + host ) ; } }
public Tag Handler process Object Value ( Object value ) throws Jsp Exception { if ( value instanceof Attribute Definition ) { return process Typed Attribute ( ( Attribute Definition ) value ) ; } else if ( value instanceof Component Definition ) { return process Definition ( ( Component Definition ) value ) ; } return process As Definition Or URL ( value . to String ( ) ) ; }
public List < Integer > emit ( String stream Id , Tuple anchor , List < Object > tuple ) { return emit ( stream Id , Arrays . as List ( anchor ) , tuple ) ; }
private synchronized void write To Output Stream ( int one Byte ) { if ( m Closed ) { return ; } try { m Output Stream . write ( one Byte ) ; report Decoded Size If Applicable ( ) ; } catch ( IO Exception e ) { handle IO Exception Writing To Stream ( e ) ; } }
public int difference ( String s1 , String s2 ) throws Encoder Exception { return Soundex Utils . difference ( this , s1 , s2 ) ; }
public static Enumeration all ( ) { return all . elements ( ) ; }
protected List < Model Entity > make Entity Model To Use List ( ) throws Generic Entity Exception { List < Generic Value > entity Sync Includes = entity Sync . get Related ( STRING , null , null , BOOL ) ; List < Generic Value > entity Sync Group Includes = entity Sync . get Related ( STRING , null , null , BOOL ) ; entity Sync Includes . add All ( entity Sync Group Includes ) ; List < Model Entity > entity Model To Use List = Entity Group Util . get Model Entities From Records ( entity Sync Includes , delegator , BOOL ) ; if ( Debug . info On ( ) ) Debug . log Info ( STRING + entity Sync . get ( STRING ) + STRING + entity Model To Use List . size ( ) + STRING , module ) ; return entity Model To Use List ; }
private static String lz ( int num ) { return String . format ( STRING , num ) ; }
public void on Child Idle Begin ( ) { idle Count . increment And Get ( ) ; }
private Startup Mode check Startup Mode ( Configuration config ) throws IO Exception { Startup Mode boot Mode = check Startup Mode On Disk ( config ) ; if ( boot Mode != null ) { return boot Mode ; } if ( check Config Bool ( config , Constants . STARTUPMODE RESTORE REINIT ) ) { log . info ( STRING , Constants . STARTUPMODE RESTORE REINIT ) ; Geodb Restore Mode mode = new Geodb Restore Mode ( config ) ; mode . set Coordinator ( coordinator ) ; mode . set Schema Util ( schema Util ) ; mode . set Db Dir ( db Dir ) ; return mode ; } if ( check Config Bool ( config , Constants . REINIT DB ) ) { log . info ( STRING , Constants . REINIT DB ) ; Db Reinit Mode mode = new Db Reinit Mode ( config ) ; mode . set Coordinator ( coordinator ) ; mode . set Schema Util ( schema Util ) ; mode . set Db Dir ( db Dir ) ; return mode ; } List < String > obsolete Peers = check Config List ( config , Constants . OBSOLETE CASSANDRA PEERS ) ; if ( ! obsolete Peers . is Empty ( ) ) { Obsolete Peers Cleanup Mode mode = new Obsolete Peers Cleanup Mode ( config ) ; mode . set Coordinator ( coordinator ) ; mode . set Schema Util ( schema Util ) ; mode . set Obsolete Peers ( obsolete Peers ) ; return mode ; } else { Normal Mode mode = new Normal Mode ( config ) ; mode . set Coordinator ( coordinator ) ; mode . set Schema Util ( schema Util ) ; return mode ; } }
private void write Object ( java . io . Object Output Stream s ) throws java . io . IO Exception { lock . lock ( ) ; try { q = new Priority Queue < E > ( Math . max ( size , NUM ) , comparator ) ; q . add All ( this ) ; s . default Write Object ( ) ; } finally { q = null ; lock . unlock ( ) ; } }
private void run ( ) { try { Thread current = Thread . current Thread ( ) ; byte [ ] buf = new byte [ NUM ] ; for ( int len = in . read ( buf ) ; len != - NUM ; len = in . read ( buf ) ) { buffer . write ( buf , NUM , len ) ; if ( current != thread ) { break ; } } buffer . flush ( ) ; buffer . close ( ) ; } catch ( IO Exception e ) { log . error ( e . get Message ( ) , e ) ; } }
protected boolean shard Available ( @ Nullable Index Shard shard ) { return shard != null && shard . can Index ( ) && CAN UPDATE INDEX BUFFER STATES . contains ( shard . state ( ) ) ; }
synchronized void update Auth Config Globals ( Service Schema Manager scm ) throws SMS Exception { Service Schema schema = scm . get Organization Schema ( ) ; schema = schema . get Sub Schema ( STRING ) ; schema = schema . get Sub Schema ( STRING ) ; Map attrs = schema . get Attribute Defaults ( ) ; if ( attrs != null ) { default Service Success URL Set = ( Set ) attrs . get ( IS Auth Constants . LOGIN SUCCESS URL ) ; default Service Failure URL Set = ( Set ) attrs . get ( IS Auth Constants . LOGIN FAILURE URL ) ; } if ( debug . message Enabled ( ) ) { debug . message ( STRING + default Service Success URL Set ) ; debug . message ( STRING + default Service Failure URL Set ) ; } }
public void increment ( ) { count . increment And Get ( ) ; rate Window . increment For Timestamp ( timer Getter . now ( ) ) ; }
long total Memory ( ) ;
@ Override public int preceding ( int offset ) { Character Iterator text = get Text ( ) ; check Offset ( offset , text ) ; text . set Index ( offset ) ; return previous ( ) ; }
public void log ( String event , String message ) { boolean event Active = is Event Active ( event ) ; if ( ( this . logging && event Active && ! writers . is Empty ( ) ) ) { try { for ( Writer writer : writers . values ( ) ) { writer . write ( message ) ; writer . write ( STRING ) ; writer . flush ( ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } }
public int write ( final Byte Buffer byte Buffer ) throws IO Exception { ensure Open ( ) ; final int remaining = byte Buffer . remaining ( ) ; if ( inspectable < buffer . length ) { final int to Buffer = Math . min ( buffer . length - inspectable , remaining ) ; byte Buffer . get ( buffer , inspectable , to Buffer ) ; inspectable += to Buffer ; } if ( byte Buffer . has Remaining ( ) ) { file Channel . position ( write Position ) ; write Position += file Channel . write ( byte Buffer ) ; } return remaining ; }
public void copy Into ( int str Offset , byte [ ] bytes , int array Offset , int len ) { System . arraycopy ( m bytes , m offset + str Offset , bytes , array Offset , len ) ; }
public static String repeat String ( String pattern , int repeats ) { String Builder buffer = new String Builder ( pattern . length ( ) * repeats ) ; for ( int i = NUM ; i < repeats ; i ++ ) { buffer . append ( pattern ) ; } return new String ( buffer ) ; }
private boolean is Music Player ( ) { return player Setting != null && player Setting . equals Ignore Case ( STRING ) ; }
private void fit Image To View ( ) { Drawable drawable = get Drawable ( ) ; if ( drawable == null || drawable . get Intrinsic Width ( ) == NUM || drawable . get Intrinsic Height ( ) == NUM ) { return ; } if ( matrix == null || prev Matrix == null ) { return ; } int drawable Width = drawable . get Intrinsic Width ( ) ; int drawable Height = drawable . get Intrinsic Height ( ) ; float scale X = ( float ) view Width / drawable Width ; float scale Y = ( float ) view Height / drawable Height ; switch ( m Scale Type ) { case CENTER : scale X = scale Y = NUM ; break ; case CENTER CROP : scale X = scale Y = Math . max ( scale X , scale Y ) ; break ; case CENTER INSIDE : scale X = scale Y = Math . min ( NUM , Math . min ( scale X , scale Y ) ) ; case FIT CENTER : scale X = scale Y = Math . min ( scale X , scale Y ) ; break ; case FIT XY : break ; default : throw new Unsupported Operation Exception ( STRING ) ; } float redundant X Space = view Width - ( scale X * drawable Width ) ; float redundant Y Space = view Height - ( scale Y * drawable Height ) ; match View Width = view Width - redundant X Space ; match View Height = view Height - redundant Y Space ; if ( ! is Zoomed ( ) && ! image Rendered At Least Once ) { matrix . set Scale ( scale X , scale Y ) ; matrix . post Translate ( redundant X Space / NUM , redundant Y Space / NUM ) ; normalized Scale = NUM ; } else { if ( prev Match View Width == NUM || prev Match View Height == NUM ) { save Previous Image Values ( ) ; } prev Matrix . get Values ( m ) ; m [ Matrix . MSCALE X ] = match View Width / drawable Width * normalized Scale ; m [ Matrix . MSCALE Y ] = match View Height / drawable Height * normalized Scale ; float trans X = m [ Matrix . MTRANS X ] ; float trans Y = m [ Matrix . MTRANS Y ] ; float prev Actual Width = prev Match View Width * normalized Scale ; float actual Width = get Image Width ( ) ; translate Matrix After Rotate ( Matrix . MTRANS X , trans X , prev Actual Width , actual Width , prev View Width , view Width , drawable Width ) ; float prev Actual Height = prev Match View Height * normalized Scale ; float actual Height = get Image Height ( ) ; translate Matrix After Rotate ( Matrix . MTRANS Y , trans Y , prev Actual Height , actual Height , prev View Height , view Height , drawable Height ) ; matrix . set Values ( m ) ; } fix Trans ( ) ; set Image Matrix ( matrix ) ; }
public final static Version Info [ ] load Version Info ( String [ ] pckgs , Class Loader clsldr ) { if ( pckgs == null ) { throw new Illegal Argument Exception ( STRING ) ; } Array List vil = new Array List ( pckgs . length ) ; for ( int i = NUM ; i < pckgs . length ; i ++ ) { Version Info vi = load Version Info ( pckgs [ i ] , clsldr ) ; if ( vi != null ) vil . add ( vi ) ; } return ( Version Info [ ] ) vil . to Array ( new Version Info [ vil . size ( ) ] ) ; }
public static Collection < Content Stream > to Content Streams ( final String str , final String content Type ) { if ( str == null ) return null ; Array List < Content Stream > streams = new Array List < > ( NUM ) ; Content Stream Base ccc = new Content Stream Base . String Stream ( str ) ; ccc . set Content Type ( content Type ) ; streams . add ( ccc ) ; return streams ; }
void write Repeated Sqrt ( DD xdd ) { int count = NUM ; while ( xdd . double Value ( ) > NUM ) { count ++ ; double x = xdd . double Value ( ) ; DD x Sqrt = xdd . sqrt ( ) ; String s = x Sqrt . to String ( ) ; DD x Sqrt 2 = DD . parse ( s ) ; DD xx = x Sqrt 2 . multiply ( x Sqrt 2 ) ; double err = Math . abs ( xx . double Value ( ) - x ) ; xdd = x Sqrt ; DD dist From 1 DD = x Sqrt . subtract ( DD . value Of ( NUM ) ) ; double dist From 1 = dist From 1 DD . double Value ( ) ; if ( Math . abs ( dist From 1 ) < NUM ) break ; } }
@ Override public String format ( Date Time Formatter formatter ) { Objects . require Non Null ( formatter , STRING ) ; return formatter . format ( this ) ; }
void verify Unique Xids ( List < OF Message > msgs ) { if ( seen Xids == null ) seen Xids = new Hash Set < Long > ( ) ; for ( OF Message m : msgs ) { long xid = m . get Xid ( ) ; assert True ( STRING , xid != NUM ) ; assert False ( STRING + xid + STRING , seen Xids . contains ( xid ) ) ; seen Xids . add ( xid ) ; } }
public static boolean has Extension ( String extension ) { if ( extension == null || extension . is Empty ( ) ) { return BOOL ; } return extension To Mime Type Map . contains Key ( extension ) ; }
private float apply Friction ( float velocity , float simulation Rate ) { if ( is Zero ( velocity ) ) { velocity = NUM ; } else if ( velocity > NUM ) { velocity = Math . max ( NUM , velocity - ( FRICTION * simulation Rate ) ) ; } else { velocity = Math . min ( NUM , velocity + ( FRICTION * simulation Rate ) ) ; } return velocity ; }
static Boolean real Is J Unit 4 Test ( Class script Class , Groovy Class Loader loader ) { boolean is Test = BOOL ; try { try { Class run With Annotation Class = loader . load Class ( STRING ) ; Annotation annotation = script Class . get Annotation ( run With Annotation Class ) ; if ( annotation != null ) { is Test = BOOL ; } else { Class test Annotation Class = loader . load Class ( STRING ) ; Method [ ] methods = script Class . get Methods ( ) ; for ( int i = NUM ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; annotation = method . get Annotation ( test Annotation Class ) ; if ( annotation != null ) { is Test = BOOL ; break ; } } } } catch ( Class Not Found Exception e ) { } } catch ( Throwable e ) { } return is Test ? Boolean . TRUE : Boolean . FALSE ; }
private Dimension layout Size ( Container target , boolean preferred ) { synchronized ( target . get Tree Lock ( ) ) { int target Width = target . get Size ( ) . width ; if ( target Width == NUM ) { target Width = Integer . MAX VALUE ; } int hgap = get Hgap ( ) ; int vgap = get Vgap ( ) ; Insets insets = target . get Insets ( ) ; int horizontal Insets And Gap = insets . left + insets . right + ( hgap * NUM ) ; int max Width = target Width - horizontal Insets And Gap ; Dimension dim = new Dimension ( NUM , NUM ) ; int row Width = NUM ; int row Height = NUM ; int nmembers = target . get Component Count ( ) ; for ( int i = NUM ; i < nmembers ; i ++ ) { Component m = target . get Component ( i ) ; if ( m . is Visible ( ) ) { Dimension d = preferred ? m . get Preferred Size ( ) : m . get Minimum Size ( ) ; if ( row Width + d . width > max Width ) { add Row ( dim , row Width , row Height ) ; row Width = NUM ; row Height = NUM ; } if ( row Width != NUM ) { row Width += hgap ; } row Width += d . width ; row Height = Math . max ( row Height , d . height ) ; } } add Row ( dim , row Width , row Height ) ; dim . width += horizontal Insets And Gap ; dim . height += insets . top + insets . bottom + vgap * NUM ; Container scroll Pane = Swing Utilities . get Ancestor Of Class ( J Scroll Pane . class , target ) ; if ( scroll Pane != null ) { dim . width -= ( hgap + NUM ) ; } return dim ; } }
private static void parse Expression ( final Reader reader , final boolean writing String , final String Builder template Expressions ) throws IO Exception { if ( ! writing String ) { template Expressions . append ( STRING ) ; } template Expressions . append ( STRING ) ; while ( BOOL ) { int c = reader . read ( ) ; if ( c == - NUM ) break ; if ( c == STRING ) { c = reader . read ( ) ; if ( c == STRING ) break ; template Expressions . append ( STRING ) ; } template Expressions . append ( ( char ) c ) ; } template Expressions . append ( STRING ) ; }
private static String do Get Path ( String filename , int separator Add ) { if ( filename == null ) { return null ; } int prefix = get Prefix Length ( filename ) ; if ( prefix < NUM ) { return null ; } int index = index Of Last Separator ( filename ) ; int end Index = index + separator Add ; if ( prefix >= filename . length ( ) || index < NUM || prefix >= end Index ) { return STRING ; } return filename . substring ( prefix , end Index ) ; }
protected void reduce Parse Tree ( Compilation Unit Declaration unit ) { Type Declaration [ ] types = unit . types ; for ( int i = NUM , l = types . length ; i < l ; i ++ ) purge Method Statements ( types [ i ] , BOOL ) ; }
public synchronized void write To ( Output Stream out ) throws IO Exception { int remaining = count ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; out . write ( buf , NUM , c ) ; remaining -= c ; if ( remaining == NUM ) { break ; } } }
public static long find Revision ( final List < String > output , final Pattern pattern ) { long revision = - NUM ; for ( final String line : output ) { final Matcher matcher = pattern . matcher ( line ) ; if ( matcher . find ( ) ) { revision = Long . parse Long ( matcher . group ( NUM ) ) ; break ; } } return revision ; }
protected int choose High Water Mark ( int capacity , double max Load ) { return Math . min ( capacity - NUM , ( int ) ( capacity * max Load ) ) ; }
private Access Grant create Access Grant ( Map < String , String > params ) { Access Grant access Grant = new Access Grant ( ) ; if ( params . get ( STRING ) != null ) { String access Token = params . get ( STRING ) ; Integer expires = null ; if ( params . get ( STRING ) != null ) { expires = Integer . value Of ( params . get ( STRING ) ) ; } access Grant . set Key ( access Token ) ; access Grant . set Attribute ( STRING , expires ) ; } access Grant . set Provider Id ( m Provider Name . to String ( ) ) ; return access Grant ; }
protected final boolean load To Have At Least ( int min Available ) throws IO Exception { if ( input Stream == null ) { return BOOL ; } int amount = input End - input Ptr ; if ( amount > NUM && input Ptr > NUM ) { curr Input Processed += input Ptr ; curr Input Row Start -= input Ptr ; System . arraycopy ( input Buffer , input Ptr , input Buffer , NUM , amount ) ; input End = amount ; } else { input End = NUM ; } input Ptr = NUM ; while ( input End < min Available ) { int count = input Stream . read ( input Buffer , input End , input Buffer . length - input End ) ; if ( count < NUM ) { close Input ( ) ; if ( count == NUM ) { throw new IO Exception ( STRING + amount + STRING ) ; } return BOOL ; } input End += count ; } return BOOL ; }
public double log Pdf ( double x ) { return Math . log ( pdf ( x ) ) ; }
private void select File ( int title Msg , int button Msg , String settings Name , String default Dir , int dialog , int result ) { set Auto Mode ( Auto Mode . OFF ) ; String action = STRING ; Intent i = new Intent ( action ) ; String current File = settings . get String ( settings Name , STRING ) ; String sep = File . separator ; if ( ! current File . contains ( sep ) ) current File = Environment . get External Storage Directory ( ) + sep + default Dir + sep + current File ; i . set Data ( Uri . from File ( new File ( current File ) ) ) ; i . put Extra ( STRING , get String ( title Msg ) ) ; i . put Extra ( STRING , get String ( button Msg ) ) ; try { start Activity For Result ( i , result ) ; } catch ( Activity Not Found Exception e ) { remove Dialog ( dialog ) ; show Dialog ( dialog ) ; } }
private static void encode Binary ( byte [ ] bytes , int startpos , int count , int startmode , String Builder sb ) { if ( count == NUM && startmode == TEXT COMPACTION ) { sb . append ( ( char ) SHIFT TO BYTE ) ; } else { boolean sixpack = ( ( count % NUM ) == NUM ) ; if ( sixpack ) { sb . append ( ( char ) LATCH TO BYTE ) ; } else { sb . append ( ( char ) LATCH TO BYTE PADDED ) ; } } int idx = startpos ; if ( count >= NUM ) { char [ ] chars = new char [ NUM ] ; while ( ( startpos + count - idx ) >= NUM ) { long t = NUM ; for ( int i = NUM ; i < NUM ; i ++ ) { t <<= NUM ; t += bytes [ idx + i ] & NUM ; } for ( int i = NUM ; i < NUM ; i ++ ) { chars [ i ] = ( char ) ( t % NUM ) ; t /= NUM ; } for ( int i = chars . length - NUM ; i >= NUM ; i -- ) { sb . append ( chars [ i ] ) ; } idx += NUM ; } } for ( int i = idx ; i < startpos + count ; i ++ ) { int ch = bytes [ i ] & NUM ; sb . append ( ( char ) ch ) ; } }
public String timer String ( int level , String message ) { String Builder ret String Buf = new String Builder ( ) ; for ( int i = NUM ; i < level ; i ++ ) { ret String Buf . append ( STRING ) ; } ret String Buf . append ( STRING ) ; String time Since Start Str = String . value Of ( time Since Start ( ) ) ; ret String Buf . append ( time Since Start Str + STRING ) ; String time Since Last Str = String . value Of ( time Since Last ( ) ) ; ret String Buf . append ( time Since Last Str ) ; ret String Buf . append ( STRING ) ; int spacecount = NUM + ( NUM * level ) - ret String Buf . length ( ) ; for ( int i = NUM ; i < spacecount ; i ++ ) { ret String Buf . append ( STRING ) ; } ret String Buf . append ( message ) ; last Message Time = System . current Time Millis ( ) ; String ret String = ret String Buf . to String ( ) ; if ( log && Debug . timing On ( ) ) Debug . log Timing ( ret String , module ) ; return ret String ; }
public static int recompile With Opt ( Normal Method method ) { if ( VM . Build For Opt Compiler ) { Compilation Plan plan = new Compilation Plan ( method , ( Optimization Plan Element [ ] ) optimization Plan , null , ( Opt Options ) options ) ; return recompile With Opt ( plan ) ; } else { if ( VM . Verify Assertions ) VM . assert ( VM . NOT REACHED ) ; return - NUM ; } }
public String find Match ( Pattern pattern , String text ) { return find Match ( pattern , text , NUM ) ; }
private void add Hit ( String cname , Class < ? > c ) { if ( len == names . length ) { final int nl = ( len << NUM ) + NUM ; names = Arrays . copy Of ( names , nl ) ; clazzes = Arrays . copy Of ( clazzes , nl ) ; } names [ len ] = cname ; clazzes [ len ] = c ; ++ len ; }
private Object query Command Value ( final String command Identifier ) { Check . not Null ( command Identifier , STRING ) ; final String Buffer cmd = new String Buffer ( ) ; cmd . append ( STRING ) ; cmd . append ( command Identifier ) ; cmd . append ( STRING ) ; return browser . evaluate ( cmd . to String ( ) ) ; }
public void line ( double x , double y ) { Line line = new Line ( x , y ) ; if ( x < min X ) { min X = x ; } if ( y < min Y ) { min Y = y ; } if ( x > max X ) { max X = x ; } if ( y > max Y ) { max Y = y ; } elements . add ( line ) ; }
private void clip View On The Right ( Rect cur View Bound , float cur View Width , int right ) { cur View Bound . right = ( int ) ( right - m Clip Padding ) ; cur View Bound . left = ( int ) ( cur View Bound . right - cur View Width ) ; }
@ Override public List < Cluster < T > > cluster ( final Collection < T > points ) throws Null Argument Exception { Math Utils . check Not Null ( points ) ; final List < Cluster < T > > clusters = new Array List < Cluster < T > > ( ) ; final Map < Clusterable , Point Status > visited = new Hash Map < Clusterable , Point Status > ( ) ; for ( final T point : points ) { if ( visited . get ( point ) != null ) { continue ; } final List < T > neighbors = get Neighbors ( point , points ) ; if ( neighbors . size ( ) >= min Pts ) { final Cluster < T > cluster = new Cluster < T > ( ) ; clusters . add ( expand Cluster ( cluster , point , neighbors , points , visited ) ) ; } else { visited . put ( point , Point Status . NOISE ) ; } } return clusters ; }
public void test Get Version 25 ( ) throws Exception { String xml = WEBAPP 25 HEADER + STRING ; Web Xml web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( xml . get Bytes ( STRING ) ) , get Entity Resolver ( ) ) ; assert Equals ( Web Xml Version . V2 5 , web Xml . get Version ( ) ) ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
private static void mat 4 util inplace rotate ( float [ ] in Out Matrix , float euler Radians X , float euler Radians Y , float euler Radians Z ) { float cos rx = ( float ) Math . cos ( euler Radians X ) ; float cos ry = ( float ) Math . cos ( euler Radians Y ) ; float cos rz = ( float ) Math . cos ( euler Radians Z ) ; float sin rx = ( float ) Math . sin ( euler Radians X ) ; float sin ry = ( float ) Math . sin ( euler Radians Y ) ; float sin rz = ( float ) Math . sin ( euler Radians Z ) ; float b00 = cos rz * cos ry ; float b10 = sin rz * cos ry ; float b20 = - sin ry ; float b30 = NUM ; float b01 = - sin rz * cos rx + cos rz * sin ry * sin rx ; float b11 = cos rz * cos rx + sin rz * sin ry * sin rx ; float b21 = cos ry * sin rx ; float b31 = NUM ; float b02 = sin rz * sin rx + cos rz * sin ry * cos rx ; float b12 = - cos rz * sin rx + sin rz * sin ry * cos rx ; float b22 = cos ry * cos rx ; float b32 = NUM ; float b03 = NUM ; float b13 = NUM ; float b23 = NUM ; float b33 = NUM ; float a00 = in Out Matrix [ NUM ] ; float a10 = in Out Matrix [ NUM ] ; float a20 = in Out Matrix [ NUM ] ; float a30 = in Out Matrix [ NUM ] ; float a01 = in Out Matrix [ NUM ] ; float a11 = in Out Matrix [ NUM ] ; float a21 = in Out Matrix [ NUM ] ; float a31 = in Out Matrix [ NUM ] ; float a02 = in Out Matrix [ NUM ] ; float a12 = in Out Matrix [ NUM ] ; float a22 = in Out Matrix [ NUM ] ; float a32 = in Out Matrix [ NUM ] ; float a03 = in Out Matrix [ NUM ] ; float a13 = in Out Matrix [ NUM ] ; float a23 = in Out Matrix [ NUM ] ; float a33 = in Out Matrix [ NUM ] ; in Out Matrix [ NUM ] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30 ; in Out Matrix [ NUM ] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30 ; in Out Matrix [ NUM ] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30 ; in Out Matrix [ NUM ] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30 ; in Out Matrix [ NUM ] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31 ; in Out Matrix [ NUM ] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31 ; in Out Matrix [ NUM ] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31 ; in Out Matrix [ NUM ] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31 ; in Out Matrix [ NUM ] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32 ; in Out Matrix [ NUM ] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32 ; in Out Matrix [ NUM ] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32 ; in Out Matrix [ NUM ] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32 ; in Out Matrix [ NUM ] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33 ; in Out Matrix [ NUM ] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33 ; in Out Matrix [ NUM ] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33 ; in Out Matrix [ NUM ] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33 ; }
@ Override public void mouse Pressed ( Mouse Event evt ) { int pos = ( slider . get Orientation ( ) == J Slider . HORIZONTAL ) ? evt . get X ( ) : evt . get Y ( ) ; int loc = get Location For Value ( get Snapped Value ( evt ) ) ; this . offset = ( loc < NUM ) ? NUM : pos - loc ; }
private String print D Format ( final long x ) { return print D Format ( Long . to String ( x ) ) ; }
public void write ( int ch ) throws IO Exception { Output Stream os = get Output Stream ( ) ; os . write ( STRING ) ; os . write ( NUM ) ; os . write ( NUM ) ; os . write ( ch ) ; }
public static < S > Service Loader < S > load Installed ( Class < S > service ) { Class Loader cl = Class Loader . get System Class Loader ( ) ; if ( cl != null ) { while ( cl . get Parent ( ) != null ) { cl = cl . get Parent ( ) ; } } return Service Loader . load ( service , cl ) ; }
private static Iterator < Operand > iterate Return Values ( IR ir ) { Array List < Operand > return Values = new Array List < Operand > ( ) ; for ( Enumeration < Instruction > e = ir . forward Instr Enumerator ( ) ; e . has More Elements ( ) ; ) { Instruction s = e . next Element ( ) ; if ( Return . conforms ( s ) ) { return Values . add ( Return . get Val ( s ) ) ; } } return return Values . iterator ( ) ; }
public static Pattern glob 2 Pattern ( String ... globs ) { final String Builder regex = new String Builder ( ) ; boolean need Or = BOOL ; for ( String glob : globs ) { if ( need Or ) { regex . append ( STRING ) ; } int i = NUM , len = glob . length ( ) ; while ( i < len ) { char c = glob . char At ( i ++ ) ; switch ( c ) { case STRING : if ( i < len && glob . char At ( i ) == STRING ) { regex . append ( STRING ) ; i ++ ; } else { regex . append ( STRING ) ; } break ; case STRING : regex . append ( STRING ) ; break ; default : if ( is Regex Meta ( c ) ) { regex . append ( STRING ) ; } regex . append ( c ) ; } } need Or = BOOL ; } return Pattern . compile ( regex . to String ( ) , NUM ) ; }
public static boolean contains Trace Explorer Module Conflict ( String root Module Name ) { String root Module File Name = root Module Name ; if ( ! root Module Name . ends With ( Resource Helper . TLA EXTENSION ) ) { root Module File Name = Resource Helper . get Module File Name ( root Module Name ) ; } List < String > extended Module Names = Toolbox Handle . get Extended Modules ( root Module File Name ) ; Iterator < String > it = extended Module Names . iterator ( ) ; while ( it . has Next ( ) ) { String module Name = it . next ( ) ; if ( module Name . equals ( TE FILE TLA ) ) { return BOOL ; } } return BOOL ; }
public void test Flip Bit Negative Inside 2 ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = - NUM ; int number = NUM ; byte r Bytes [ ] = { - NUM , NUM , - NUM , - NUM , NUM , NUM , - NUM , - NUM , - NUM , - NUM , NUM , - NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . flip Bit ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
private String build Full Message ( String msg , Object arg 0 , Object arg 1 , Object arg 2 , Object [ ] arg Array ) { String Builder sb = null ; int last Index = NUM ; int arg C = NUM ; while ( BOOL ) { int arg Index = msg . index Of ( ARG STRING , last Index ) ; if ( arg Index == - NUM ) { break ; } if ( sb == null ) { sb = new String Builder ( NUM ) ; } sb . append ( msg , last Index , arg Index ) ; last Index = arg Index + ARG STRING LENGTH ; if ( arg Array == null ) { if ( arg C == NUM ) { append Arg ( sb , arg 0 ) ; } else if ( arg C == NUM ) { append Arg ( sb , arg 1 ) ; } else if ( arg C == NUM ) { append Arg ( sb , arg 2 ) ; } else { } } else if ( arg C < arg Array . length ) { append Arg ( sb , arg Array [ arg C ] ) ; } else { } arg C ++ ; } if ( sb == null ) { return msg ; } else { sb . append ( msg , last Index , msg . length ( ) ) ; return sb . to String ( ) ; } }
protected void remove From Parent Info ( Openable child ) { Openable parent = ( Openable ) child . get Parent ( ) ; if ( parent != null && parent . is Open ( ) ) { try { Openable Element Info info = ( Openable Element Info ) parent . get Element Info ( ) ; info . remove Child ( child ) ; } catch ( Java Model Exception e ) { } } }
public void remove All Update Listeners ( ) { if ( m Update Listeners == null ) { return ; } m Update Listeners . clear ( ) ; m Update Listeners = null ; }
public static String encode String ( String s ) { return new String ( encode ( s . get Bytes ( ) ) ) ; }
public void execute Plan ( Task Completer completer , String success Message , Workflow Callback Handler callback Handler , Object [ ] callback Handler Args , Workflow Rollback Handler rollback Handler , Object [ ] rollback Handler Args ) throws Workflow Exception { this . callback Handler = callback Handler ; if ( callback Handler Args != null ) { this . callback Handler Args = callback Handler Args . clone ( ) ; } this . rollback Handler = rollback Handler ; if ( rollback Handler Args != null ) { this . rollback Handler Args = rollback Handler Args . clone ( ) ; } this . task Completer = completer ; this . success Message = success Message ; service . execute Plan ( this ) ; }
private OS Info ( ) { }
public boolean is Mutable ( ) { return mutable ; }
public void handle Request ( Request Context rc ) throws CLI Exception { super . handle Request ( rc ) ; ldap Login ( ) ; String service Name = get String Option Value ( I Argument . SERVICE NAME ) ; String sub Config Name = get String Option Value ( I Argument . SUB CONFIGURATION NAME ) ; String realm Name = get String Option Value ( I Argument . REALM NAME ) ; if ( ( realm Name == null ) || ( realm Name . length ( ) == NUM ) ) { delete Sub Config To Root ( service Name , sub Config Name ) ; } else { delete Sub Config From Realm ( realm Name , service Name , sub Config Name ) ; } }
public void enforce Context ( Resource ... contexts ) { Open RDF Util . verify Context Not Null ( contexts ) ; this . contexts = Arrays . copy Of ( contexts , contexts . length ) ; }
protected void run Upload ( Integer num Of Threads , Hash Map < String , String > attributes , Boolean create New Version , Boolean force ) throws Exception { run Upload ( num Of Threads , attributes , create New Version , force , null , null ) ; }
public final Collection < Component > components ( ) { return new Hash Set < > ( components . values ( ) ) ; }
protected boolean [ ] can Predict ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type ) { print ( STRING ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( STRING ) ; Array List < String > accepts = new Array List < String > ( ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; int num Train = get Num Instances ( ) , num Classes = NUM , missing Level = NUM ; boolean predictor Missing = BOOL , class Missing = BOOL ; return run Basic Test ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type , missing Level , predictor Missing , class Missing , num Train , num Classes , accepts ) ; }
public void test history Index Disabled ( ) throws Sail Exception { final Properties properties = get Properties ( ) ; properties . set Property ( com . bigdata . rdf . store . Abstract Triple Store . Options . HISTORY SERVICE , STRING ) ; final Bigdata Sail sail = get Sail ( properties ) ; try { sail . initialize ( ) ; final Bigdata Sail Connection conn = sail . get Connection ( ) ; try { final I Index ndx = get History Index ( conn . get Triple Store ( ) ) ; assert Null ( ndx ) ; conn . rollback ( ) ; } finally { conn . close ( ) ; } } finally { sail . tear Down Unit Test ( ) ; } }
public void collapse ( ) { collapse ( BOOL ) ; }
public int num Instances ( ) { return m Instances . size ( ) ; }
@ Override public void start Document ( XML Locator locator , String encoding , Namespace Context namespace Context , Augmentations augs ) throws XNI Exception { f Namespace Context = namespace Context ; try { if ( f Document Handler != null ) { if ( locator != null ) { f Document Handler . set Document Locator ( new Locator Proxy ( locator ) ) ; } if ( f Document Handler != null ) { f Document Handler . start Document ( ) ; } } if ( f Content Handler != null ) { if ( locator != null ) { f Content Handler . set Document Locator ( new Locator Proxy ( locator ) ) ; } if ( f Content Handler != null ) { f Content Handler . start Document ( ) ; } } } catch ( SAX Exception e ) { throw new XNI Exception ( e ) ; } }
public static double parse Number Percent With Separate Range ( FXG Node node , String value , String name , double min Number , double max Number , double min Percent , double max Percent , double default Value ) { if ( value . length ( ) != NUM && value . char At ( value . length ( ) - NUM ) == STRING ) { String double Value = value . substring ( NUM , value . length ( ) - NUM ) ; try { return parse Double ( node , double Value , name , min Percent , max Percent , default Value ) ; } catch ( FXG Exception e ) { throw new FXG Exception ( node . get Start Line ( ) , node . get Start Column ( ) , STRING , name , value ) ; } } else { return parse Double ( node , value , name , min Number , max Number , default Value ) ; } }
private void check Download Can Proceed ( ) throws Stop Request Exception { if ( clock . interval Less Than ( Clock . Interval . ONE SECOND ) ) { return ; } clock . start Interval ( ) ; check Is Paused Or Canceled ( ) ; check Client Rules ( ) ; }
private void calculate Color ( int coord ) { coord = coord - m Bar Pointer Halo Radius ; if ( coord < NUM ) { coord = NUM ; } else if ( coord > m Bar Length ) { coord = m Bar Length ; } m Color = Color . HSV To Color ( Math . round ( m Pos To Opac Factor * coord ) , mHSV Color ) ; if ( Color . alpha ( m Color ) > NUM ) { m Color = Color . HSV To Color ( mHSV Color ) ; } else if ( Color . alpha ( m Color ) < NUM ) { m Color = Color . TRANSPARENT ; } }
private void delete Event ( Event Reg Key Expiration reg Expiration , Event Reg reg ) { listeners . dec ( ) ; synchronized ( reg ) { Entry Rep [ ] tmpls = reg . tmpl . attribute Set Templates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= NUM ; ) { Entry Class eclass = tmpls [ i ] . eclass ; eclass . set Num Templates ( eclass . get Num Templates ( ) - NUM ) ; } } Long id = reg . event ID ; event By ID . remove ( id ) ; if ( reg Expiration != null ) { event By Time . remove ( reg Expiration ) ; } else { event By Time . remove ( new Event Reg Key Expiration ( reg , reg . lease Expiration ) ) ; } if ( reg . tmpl . service ID != null ) { Object val = sub Event By Service . get ( reg . tmpl . service ID ) ; if ( val == reg ) { sub Event By Service . remove ( reg . tmpl . service ID ) ; } else { Object [ ] array = ( Event Reg [ ] ) val ; array = array Del ( array , index Of ( array , reg ) ) ; if ( array . length == NUM ) val = array [ NUM ] ; else val = array ; sub Event By Service . put ( reg . tmpl . service ID , val ) ; } } else { sub Event By ID . remove ( id ) ; } compute Max Leases ( ) ; } }
public String gtid Set ( ) { return this . gtid Set != null ? this . gtid Set : null ; }
public static Peer create Map Peer ( Map map ) throws Message Exception { if ( ! map . contains Key ( PORT ) || ! map . contains Key ( ADDRESS ) ) throw new Message Exception ( STRING ) ; int port = ( int ) ( long ) map . get ( PORT ) ; String address = ( String ) map . get ( ADDRESS ) ; String peer Id = null ; if ( map . contains Key ( PEER ID ) ) peer Id = ( String ) map . get ( PEER ID ) ; return new Peer ( peer Id , new Inet Socket Address ( address , port ) ) ; }
private static int count Gaps Dash Dot Star ( String sequence ) { int count = NUM ; for ( int i = NUM ; i < sequence . length ( ) ; i ++ ) { int a = sequence . char At ( i ) ; if ( a == STRING || a == STRING || a == STRING ) count ++ ; } return count ; }
private boolean test Password ( ) throws Pdf Security Exception { int count = NUM ; final byte [ ] raw Value = new byte [ NUM ] ; byte [ ] key Value ; for ( int i = NUM ; i < NUM ; i ++ ) { raw Value [ i ] = ( byte ) Integer . parse Int ( pad [ i ] , NUM ) ; } byte [ ] encrypted = Object Clone Factory . clone Array ( raw Value ) ; if ( rev == NUM ) { encryption Key = calculate Key ( O , P , ID ) ; encrypted = decrypt ( encrypted , STRING , BOOL , null , BOOL , BOOL ) ; } else if ( rev >= NUM ) { int key Length = this . key Length ; count = NUM ; encryption Key = calculate Key ( O , P , ID ) ; final byte [ ] original Key = Object Clone Factory . clone Array ( encryption Key ) ; Message Digest md = null ; try { md = Message Digest . get Instance ( STRING ) ; } catch ( final Exception e ) { Log Writer . write Log ( STRING + e + STRING ) ; } md . update ( encrypted ) ; key Value = md . digest ( ID ) ; key Value = decrypt ( key Value , STRING , BOOL , null , BOOL , BOOL ) ; final byte [ ] next Key = new byte [ key Length ] ; for ( int i = NUM ; i <= NUM ; i ++ ) { for ( int j = NUM ; j < key Length ; j ++ ) { next Key [ j ] = ( byte ) ( original Key [ j ] ^ i ) ; } encryption Key = next Key ; key Value = decrypt ( key Value , STRING , BOOL , null , BOOL , BOOL ) ; } encryption Key = original Key ; encrypted = new byte [ NUM ] ; System . arraycopy ( key Value , NUM , encrypted , NUM , NUM ) ; System . arraycopy ( raw Value , NUM , encrypted , NUM , NUM ) ; } return compare Keys ( U , encrypted , count ) ; }
public static void put Double Field ( Object obj , long field Off , double val ) { UNSAFE . put Double ( obj , field Off , val ) ; }
public static String read Fully ( Reader reader ) throws IO Exception { try { String Writer writer = new String Writer ( ) ; char [ ] buffer = new char [ NUM ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM ) { writer . write ( buffer , NUM , count ) ; } return writer . to String ( ) ; } finally { reader . close ( ) ; } }
public String to OID String ( ) { if ( sOID == null ) { sOID = STRING + to String ( ) ; } return sOID ; }
public void emit Direct ( int task Id , String stream Id , Tuple anchor , List < Object > tuple ) { emit Direct ( task Id , stream Id , Arrays . as List ( anchor ) , tuple ) ; }
protected void load Value ( String s Value ) { s Value = s Value . trim ( ) ; try { int r = Integer . parse Int ( s Value . substring ( NUM , NUM ) , NUM ) ; int g = Integer . parse Int ( s Value . substring ( NUM , NUM ) , NUM ) ; int b = Integer . parse Int ( s Value . substring ( NUM , NUM ) , NUM ) ; value = new Color ( r , g , b ) ; } catch ( Number Format Exception nfe ) { revert To Default ( ) ; } catch ( String Index Out Of Bounds Exception sioobe ) { revert To Default ( ) ; } }
public void schema Changed ( String service Name , String version ) { update Status ( ) ; }
private static int byte Compaction ( int mode , int [ ] codewords , int code Index , String Builder result ) { if ( mode == BYTE COMPACTION MODE LATCH ) { int count = NUM ; long value = NUM ; char [ ] decoded Data = new char [ NUM ] ; int [ ] byte Compacted Codewords = new int [ NUM ] ; boolean end = BOOL ; int next Code = codewords [ code Index ++ ] ; while ( ( code Index < codewords [ NUM ] ) && ! end ) { byte Compacted Codewords [ count ++ ] = next Code ; value = NUM * value + next Code ; next Code = codewords [ code Index ++ ] ; if ( next Code == TEXT COMPACTION MODE LATCH || next Code == BYTE COMPACTION MODE LATCH || next Code == NUMERIC COMPACTION MODE LATCH || next Code == BYTE COMPACTION MODE LATCH 6 || next Code == BEGIN MACRO PDF 417 CONTROL BLOCK || next Code == BEGIN MACRO PDF 417 OPTIONAL FIELD || next Code == MACRO PDF 417 TERMINATOR ) { code Index -- ; end = BOOL ; } else { if ( ( count % NUM == NUM ) && ( count > NUM ) ) { for ( int j = NUM ; j < NUM ; ++ j ) { decoded Data [ NUM - j ] = ( char ) ( value % NUM ) ; value >>= NUM ; } result . append ( decoded Data ) ; count = NUM ; } } } if ( code Index == codewords [ NUM ] && next Code < TEXT COMPACTION MODE LATCH ) { byte Compacted Codewords [ count ++ ] = next Code ; } for ( int i = NUM ; i < count ; i ++ ) { result . append ( ( char ) byte Compacted Codewords [ i ] ) ; } } else if ( mode == BYTE COMPACTION MODE LATCH 6 ) { int count = NUM ; long value = NUM ; boolean end = BOOL ; while ( code Index < codewords [ NUM ] && ! end ) { int code = codewords [ code Index ++ ] ; if ( code < TEXT COMPACTION MODE LATCH ) { count ++ ; value = NUM * value + code ; } else { if ( code == TEXT COMPACTION MODE LATCH || code == BYTE COMPACTION MODE LATCH || code == NUMERIC COMPACTION MODE LATCH || code == BYTE COMPACTION MODE LATCH 6 || code == BEGIN MACRO PDF 417 CONTROL BLOCK || code == BEGIN MACRO PDF 417 OPTIONAL FIELD || code == MACRO PDF 417 TERMINATOR ) { code Index -- ; end = BOOL ; } } if ( ( count % NUM == NUM ) && ( count > NUM ) ) { char [ ] decoded Data = new char [ NUM ] ; for ( int j = NUM ; j < NUM ; ++ j ) { decoded Data [ NUM - j ] = ( char ) ( value & NUM ) ; value >>= NUM ; } result . append ( decoded Data ) ; count = NUM ; } } } return code Index ; }
public int add And Get ( T obj , int delta ) { for ( ; ; ) { int current = get ( obj ) ; int next = current + delta ; if ( compare And Set ( obj , current , next ) ) return next ; } }
public KC Response serve ( String uri , String method , Properties header , Properties parms , Properties files ) { return serve File ( uri , header , my Root Dir , BOOL ) ; }
protected void fill Mem Data ( Object data , int [ ] posits , int length , Object output , int output Offset , int dim ) { if ( data instanceof Object [ ] ) { Object [ ] xo = ( Object [ ] ) data ; fill Mem Data ( xo [ posits [ dim ] ] , posits , length , output , output Offset , dim + NUM ) ; } else { int start From = posits [ dim ] ; int start To = output Offset ; int copy Length = length ; if ( posits [ dim ] < NUM ) { start From -= posits [ dim ] ; start To -= posits [ dim ] ; copy Length += posits [ dim ] ; } if ( posits [ dim ] + length > this . dims [ dim ] ) { copy Length -= posits [ dim ] + length - this . dims [ dim ] ; } System . arraycopy ( data , start From , output , start To , copy Length ) ; } }
public Optional < String > start Async Job ( String job Type ) { try { final Job Runnable job Runnable = find Job Runnable ( job Type ) ; Job Info job Info = create Job Info ( job Type ) ; repository . mark Job As Running If Possible ( job Info , mutex Job Types For ( job Type ) ) ; repository . create Or Update ( job Info ) ; return Optional . of ( start Async ( metered ( job Runnable ) , job Info . get Job Id ( ) ) ) ; } catch ( Job Blocked Exception e ) { LOG . info ( e . get Message ( ) ) ; return Optional . empty ( ) ; } }
public boolean is Legal Replacement ( byte [ ] replacement ) { if ( decoder == null ) { decoder = charset . new Decoder ( ) ; decoder . on Malformed Input ( Coding Error Action . REPORT ) ; decoder . on Unmappable Character ( Coding Error Action . REPORT ) ; } Byte Buffer in = Byte Buffer . wrap ( replacement ) ; Char Buffer out = Char Buffer . allocate ( ( int ) ( replacement . length * decoder . max Chars Per Byte ( ) ) ) ; Coder Result result = decoder . decode ( in , out , BOOL ) ; return ! result . is Error ( ) ; }
public static void adapt Table ( Constraint Table Layout table ) { int width = table . get Width ( ) ; int height = table . get Height ( ) ; Constraint Widget . Dimension Behaviour horizontal Behaviour = table . get Horizontal Dimension Behaviour ( ) ; Constraint Widget . Dimension Behaviour vertical Behaviour = table . get Vertical Dimension Behaviour ( ) ; table . set Horizontal Dimension Behaviour ( Constraint Widget . Dimension Behaviour . WRAP CONTENT ) ; table . set Vertical Dimension Behaviour ( Constraint Widget . Dimension Behaviour . WRAP CONTENT ) ; table . layout ( ) ; table . layout ( ) ; table . set Min Width ( table . get Width ( ) ) ; table . set Min Height ( table . get Height ( ) ) ; table . compute Guidelines Percent Positions ( ) ; table . set Horizontal Dimension Behaviour ( horizontal Behaviour ) ; table . set Vertical Dimension Behaviour ( vertical Behaviour ) ; table . set Width ( width < table . get Min Width ( ) ? table . get Min Width ( ) : width ) ; table . set Height ( height < table . get Min Height ( ) ? table . get Min Height ( ) : height ) ; table . layout ( ) ; }
public static < V , C extends Collection < ? super V > > C add All ( C c , V ... vals ) { Collections . add All ( c , vals ) ; return c ; }
public static void add Strut ( J Component b , int layout , int size ) { if ( size < NUM ) return ; b . add ( get Axis ( b , layout ) == Box Layout . X AXIS ? Box . create Horizontal Strut ( size ) : Box . create Vertical Strut ( size ) ) ; }
public void element Type ( String name , int model , int member Of , int flags ) { Element Type e = new Element Type ( name , model , member Of , flags , this ) ; the Element Types . put ( name . to Lower Case ( ) , e ) ; if ( member Of == M ROOT ) the Root = e ; }
public int array Index Scale ( Class clazz ) { if ( ! clazz . is Array ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } return array Index Scale 0 ( clazz ) ; }
public static String Pool read String Pool ( Byte Buffer buffer , String Pool Header string Pool Header ) { long begin Pos = buffer . position ( ) ; long [ ] offsets = new long [ ( int ) string Pool Header . get String Count ( ) ] ; if ( string Pool Header . get String Count ( ) > NUM ) { for ( int idx = NUM ; idx < string Pool Header . get String Count ( ) ; idx ++ ) { offsets [ idx ] = Buffers . read U Int ( buffer ) ; } } boolean utf 8 = ( string Pool Header . get Flags ( ) & String Pool Header . UTF 8 FLAG ) != NUM ; long string Pos = begin Pos + string Pool Header . get Strings Start ( ) - string Pool Header . get Header Size ( ) ; buffer . position ( ( int ) string Pos ) ; String Pool Entry [ ] entries = new String Pool Entry [ offsets . length ] ; for ( int i = NUM ; i < offsets . length ; i ++ ) { entries [ i ] = new String Pool Entry ( i , string Pos + offsets [ i ] ) ; } String last Str = null ; long last Offset = - NUM ; String Pool string Pool = new String Pool ( ( int ) string Pool Header . get String Count ( ) ) ; for ( String Pool Entry entry : entries ) { if ( entry . offset == last Offset ) { string Pool . set ( entry . index , last Str ) ; continue ; } buffer . position ( ( int ) entry . offset ) ; last Offset = entry . offset ; String str = Parse Utils . read String ( buffer , utf 8 ) ; last Str = str ; string Pool . set ( entry . index , str ) ; } buffer . position ( ( int ) ( begin Pos + string Pool Header . get Body Size ( ) ) ) ; return string Pool ; }
public String str Rep ( ) { return STRING + rank Team Poll Score + STRING + abbr + STRING + wins + STRING + losses + STRING ; }
@ Override public String to String ( ) { if ( e Is Proxy ( ) ) return super . to String ( ) ; String Buffer result = new String Buffer ( super . to String ( ) ) ; result . append ( STRING ) ; result . append ( kind ) ; result . append ( STRING ) ; return result . to String ( ) ; }
public static < V > int add Distinct List ( List < V > source List , List < V > entry List ) { if ( source List == null || is Empty ( entry List ) ) { return NUM ; } int source Count = source List . size ( ) ; for ( V entry : entry List ) { if ( ! source List . contains ( entry ) ) { source List . add ( entry ) ; } } return source List . size ( ) - source Count ; }
private void record RP Operation ( Db Client db Client , Operation Type Enum op Type , Operation . Status status , Object ... ext Param ) { try { boolean op Status = ( Operation . Status . ready == status ) ? BOOL : BOOL ; String ev Type ; ev Type = op Type . get Ev Type ( op Status ) ; String ev Desc = op Type . get Description ( ) ; String op Stage = Audit Log Manager . AUDITOP END ; log . info ( STRING , op Type . to String ( ) , ev Type . to String ( ) + STRING + ev Desc ) ; record Bourne RP Event ( db Client , get Id ( ) , ev Type , status , ev Desc ) ; switch ( op Type ) { case START RP LINK : case STOP RP LINK : case PAUSE RP LINK : case RESUME RP LINK : case FAILOVER RP LINK : case FAILOVER CANCEL RP LINK : case CHANGE RP IMAGE ACCESS MODE : case SWAP RP VOLUME : Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , ext Param ) ; break ; default : log . error ( STRING ) ; } } catch ( Exception e ) { log . error ( STRING , op Type . to String ( ) , e ) ; } }
void auto Closing Clip Opened ( Auto Closing Clip clip ) { if ( Printer . debug ) Printer . debug ( STRING ) ; int index = NUM ; synchronized ( auto Closing Clips ) { index = get Auto Closing Clip Index ( clip ) ; if ( index == - NUM ) { if ( Printer . debug ) Printer . debug ( STRING + clip ) ; auto Closing Clips . add ( new Clip Info ( clip ) ) ; } } if ( index == - NUM ) { synchronized ( this ) { notify All ( ) ; } } if ( Printer . debug ) Printer . debug ( STRING + auto Closing Clips . size ( ) + STRING ) ; }
public boolean implies ( Permission permission ) { if ( ! ( permission instanceof Exec Option Permission ) ) return BOOL ; Exec Option Permission p = ( Exec Option Permission ) permission ; if ( all allowed ) return BOOL ; String pname = p . get Name ( ) ; Permission x = permissions . get ( pname ) ; if ( x != null ) return x . implies ( permission ) ; int last , offset ; offset = pname . length ( ) - NUM ; while ( ( last = pname . last Index Of ( STRING , offset ) ) != - NUM ) { pname = pname . substring ( NUM , last + NUM ) + STRING ; x = permissions . get ( pname ) ; if ( x != null ) { return x . implies ( permission ) ; } offset = last - NUM ; } pname = p . get Name ( ) ; offset = pname . length ( ) - NUM ; while ( ( last = pname . last Index Of ( STRING , offset ) ) != - NUM ) { pname = pname . substring ( NUM , last + NUM ) + STRING ; x = permissions . get ( pname ) ; if ( x != null ) { return x . implies ( permission ) ; } offset = last - NUM ; } return BOOL ; }
public void add Tail Arg ( String arg ) { tail Args . add ( arg ) ; }
private static byte [ ] save ( Bitmap src , Bitmap . Compress Format format , int quality ) { Byte Array Output Stream output Stream = null ; try { output Stream = new Byte Array Output Stream ( ) ; src . compress ( format , quality , output Stream ) ; return output Stream . to Byte Array ( ) ; } finally { if ( output Stream != null ) { try { output Stream . close ( ) ; } catch ( IO Exception e1 ) { e1 . print Stack Trace ( ) ; } } } }
public boolean is External ( Resource input ) { return external Resources . contains ( input ) ; }
protected final void write D ( Byte Buffer buf , int value ) { buf . put Int ( value ) ; }
@ Override public Abstract Scanned Result scan Blocklet ( Blocks Chunk Holder blocks Chunk Holder ) throws Query Execution Exception { try { fill Scanned Result ( blocks Chunk Holder ) ; } catch ( Filter Unsupported Exception e ) { throw new Query Execution Exception ( e . get Message ( ) ) ; } return scanned Result ; }
public List < Shopping Cart Item > items ( ) { List < Shopping Cart Item > result = Fast List . new Instance ( ) ; result . add All ( cart Lines ) ; return result ; }
Mutable Big Integer ( Big Integer b ) { int Len = b . mag . length ; value = Arrays . copy Of ( b . mag , int Len ) ; }
public boolean is Http 11 ( ) { if ( m Version . equals Ignore Case ( HTTP 11 ) ) { return BOOL ; } return BOOL ; }
private int read Next ( boolean charstring ) { num = ( int ) ( data [ pos ++ ] ) & NUM ; if ( num == NUM && ! charstring ) { read F Num ( ) ; return type = FLT ; } else if ( num == NUM ) { num = ( ( ( int ) data [ pos ] ) << NUM ) + ( ( ( int ) data [ pos + NUM ] ) & NUM ) ; pos += NUM ; return type = NUM ; } else if ( num == NUM && ! charstring ) { num = ( ( ( int ) data [ pos ] & NUM ) << NUM ) | ( ( ( int ) data [ pos + NUM ] & NUM ) << NUM ) | ( ( ( int ) data [ pos + NUM ] & NUM ) << NUM ) | ( ( ( int ) data [ pos + NUM ] & NUM ) ) ; pos += NUM ; return type = NUM ; } else if ( num == NUM ) { num = NUM + ( ( int ) ( data [ pos ++ ] ) & NUM ) ; return type = CMD ; } else if ( num < NUM ) { return type = CMD ; } else if ( num < NUM ) { num -= NUM ; return type = NUM ; } else if ( num < NUM ) { num = ( num - NUM ) * NUM + ( ( ( int ) data [ pos ++ ] ) & NUM ) + NUM ; return type = NUM ; } else if ( num < NUM ) { num = - ( num - NUM ) * NUM - ( ( ( int ) data [ pos ++ ] ) & NUM ) - NUM ; return type = NUM ; } else if ( ! charstring ) { print Data ( ) ; throw new Runtime Exception ( STRING ) ; } else { fnum = ( ( ( ( int ) data [ pos ] & NUM ) << NUM ) | ( ( ( int ) data [ pos + NUM ] & NUM ) << NUM ) | ( ( ( int ) data [ pos + NUM ] & NUM ) << NUM ) | ( ( ( int ) data [ pos + NUM ] & NUM ) ) ) / NUM ; pos += NUM ; return type = FLT ; } }
protected void delete Icon ( ) { if ( selected Icon == null ) { return ; } if ( icon Map . remove ( selected Icon . get Name ( ) ) != null ) { remove Icon Families Panel ( ) ; add Icons To Panel ( icon Map ) ; delete Icon Button . set Enabled ( BOOL ) ; validate ( ) ; } }
public boolean equals ( Object obj ) { if ( obj == null ) return BOOL ; if ( this == obj ) return BOOL ; if ( get Class ( ) != obj . get Class ( ) ) return BOOL ; Choice Format other = ( Choice Format ) obj ; return ( Arrays . equals ( choice Limits , other . choice Limits ) && Arrays . equals ( choice Formats , other . choice Formats ) ) ; }
private static File create Reserve Disk Cache Dir ( Context context ) { File cache Dir = Storage Utils . get Cache Directory ( context , BOOL ) ; File individual Dir = new File ( cache Dir , STRING ) ; if ( individual Dir . exists ( ) || individual Dir . mkdir ( ) ) { cache Dir = individual Dir ; } return cache Dir ; }
public static Date updated ( Date self , Map < Object , Integer > updates ) { Calendar cal = Calendar . get Instance ( ) ; cal . set Time ( self ) ; set ( cal , updates ) ; return cal . get Time ( ) ; }
public boolean display Topic ( String name ) { String topic = null ; if ( name == null ) topic = DEFAULT + FILE TYPE ; else topic = name . to Lower Case ( ) + FILE TYPE ; File help File = new File ( help Dir , topic ) ; return display ( help File ) ; }
private void dash To Words ( String token Val ) { int index = token Val . index Of ( STRING ) ; String aaa = token Val . substring ( NUM , index ) ; String bbb = token Val . substring ( index + NUM , token Val . length ( ) ) ; if ( matches ( digits Pattern , aaa ) && matches ( digits Pattern , bbb ) ) { Feature Set feature Set = token Item . get Features ( ) ; feature Set . set String ( STRING , aaa ) ; token To Words ( aaa ) ; word Relation . add Word ( STRING ) ; feature Set . set String ( STRING , bbb ) ; token To Words ( bbb ) ; feature Set . set String ( STRING , STRING ) ; } else { token To Words ( aaa ) ; token To Words ( bbb ) ; } }
public static int number Of Trailing Zeros Signed ( long [ ] v ) { for ( int p = NUM ; ; p ++ ) { if ( p == v . length ) { return - NUM ; } if ( v [ p ] != NUM ) { return Long . number Of Trailing Zeros ( v [ p ] ) + p * Long . SIZE ; } } }
public static void apply WM Rule ( Collection < MWM In Out Bound > lines , String bound Type ) { for ( MWM In Out Bound line : lines ) { for ( MWM Definition definition : MWM Definition . get All ( line . get Ctx ( ) , line . get Trx Name ( ) ) ) { WM Rule Engine . validate Definition ( line , definition , bound Type ) ; } } }
public static float read Float ( final JSON Array json Array , final int index , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return ( float ) json Array . get Double ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT ARRAY , index ) ) ; } float value = NUM ; if ( ! json Array . is Null ( index ) ) { value = ( float ) json Array . get Double ( index ) ; } return value ; }
public void flush ( ) throws IO Exception { flush Bits ( ) ; out . flush ( ) ; }
public final Flux < T > on Error Resume With ( Predicate < ? super Throwable > predicate , Function < ? super Throwable , ? extends Publisher < ? extends T > > fallback ) { Objects . require Non Null ( predicate , STRING ) ; return on Error Resume With ( null ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public @ Test final void test Set Users Negative ( ) { Role role = new Role ( TEST ROLE ) ; thrown . expect ( Illegal Argument Exception . class ) ; role . set Users ( null ) ; }
private Set < String > find Resource Names ( String path , String prefix , String suffix ) throws IO Exception { Set < String > resource Names = find Resource Names From File System ( path , new File ( path ) ) ; return filter Resource Names ( resource Names , prefix , suffix ) ; }
public boolean add ( K key , V item ) { Set < V > values = map . get ( key ) ; if ( values == null ) { values = ( sorted ? new Tree Set < V > ( ) : new Hash Set < V > ( ) ) ; map . put ( key , values ) ; } if ( item == null ) return BOOL ; return values . add ( item ) ; }
public void add ECM ( ECM Info info ) { ecm Effects . add ( info ) ; }
protected void load Image ( String file Path , OM Graphic List ret ) { File file = new File ( file Path ) ; if ( file . exists ( ) && file . is Directory ( ) ) { String [ ] files = file . list ( ) ; for ( int i = NUM ; i < files . length ; i ++ ) { load Image ( file Path + STRING + files [ i ] , ret ) ; } } else { fire Status Update ( Layer Status Event . START WORKING ) ; try { URL file URL = Prop Utils . get Resource Or File Or URL ( file Path ) ; if ( file URL != null ) { if ( image Reader Loaders != null ) { Image Tile image Tile = null ; for ( Image Reader Loader idl : image Reader Loaders ) { if ( idl . is Loadable ( file Path ) ) { Image Reader id = idl . get Image Reader ( file URL ) ; Image Tile tmp Image Tile = id . get Image Tile ( image Cache ) ; if ( image Tile == null ) { image Tile = tmp Image Tile ; } else if ( tmp Image Tile != null && image Tile instanceof Err Image Tile ) { image Tile = tmp Image Tile ; } if ( image Tile != null && ! ( image Tile instanceof Err Image Tile ) ) { break ; } } } if ( image Tile != null ) { add Image To Lists ( image Tile , ret , file URL ) ; } } else { logger . warning ( STRING + get Name ( ) + STRING ) ; } } else { logger . warning ( STRING + file Path ) ; } } catch ( Malformed URL Exception murle ) { } } }
@ Override protected final boolean write Data ( Byte Buffer data ) { synchronized ( guard ) { Gs Server Packet packet = send Msg Queue . poll First ( ) ; if ( packet == null ) { return BOOL ; } packet . write ( this , data ) ; return BOOL ; } }
public static Export Mask create Export Mask ( Db Client db Client , Export Group export Group , URI sd Uri , String mask Name ) throws Database Exception { Export Mask export Mask = new Export Mask ( ) ; export Mask . set Id ( URI Util . create Id ( Export Mask . class ) ) ; export Mask . set Mask Name ( mask Name ) ; export Mask . set Storage Device ( sd Uri ) ; db Client . create Object ( export Mask ) ; export Group . add Export Mask ( export Mask . get Id ( ) ) ; db Client . update Object ( export Group ) ; return export Mask ; }
public Log Entry ( String timestamp , String contents ) { this . timestamp = timestamp ; this . contents = contents ; }
public static boolean cancel Potential Work ( Object data , Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . m Data ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( BOOL ) ; if ( Build Config . DEBUG ) { Log . d ( TAG , STRING + data ) ; } } else { return BOOL ; } } return BOOL ; }
void replace Policy In Resource Tree ( Policy old Policy , Policy new Policy ) throws Policy Exception , SSO Exception { remove Policy From Resource Tree ( old Policy ) ; add Policy To Resource Tree ( new Policy ) ; }
private Shape [ ] create Horizontal Block ( double x0 , double width , double y0 , double y1 , boolean inverted ) { Shape [ ] result = new Shape [ NUM ] ; Point 2 D p00 = new Point 2 D . Double ( y0 , x0 ) ; Point 2 D p01 = new Point 2 D . Double ( y0 , x0 + width ) ; Point 2 D p02 = new Point 2 D . Double ( p01 . get X ( ) + get X Offset ( ) , p01 . get Y ( ) - get Y Offset ( ) ) ; Point 2 D p03 = new Point 2 D . Double ( p00 . get X ( ) + get X Offset ( ) , p00 . get Y ( ) - get Y Offset ( ) ) ; Point 2 D p0 = new Point 2 D . Double ( y1 , x0 ) ; Point 2 D p1 = new Point 2 D . Double ( y1 , x0 + width ) ; Point 2 D p2 = new Point 2 D . Double ( p1 . get X ( ) + get X Offset ( ) , p1 . get Y ( ) - get Y Offset ( ) ) ; Point 2 D p3 = new Point 2 D . Double ( p0 . get X ( ) + get X Offset ( ) , p0 . get Y ( ) - get Y Offset ( ) ) ; General Path bottom = new General Path ( ) ; bottom . move To ( ( float ) p1 . get X ( ) , ( float ) p1 . get Y ( ) ) ; bottom . line To ( ( float ) p01 . get X ( ) , ( float ) p01 . get Y ( ) ) ; bottom . line To ( ( float ) p02 . get X ( ) , ( float ) p02 . get Y ( ) ) ; bottom . line To ( ( float ) p2 . get X ( ) , ( float ) p2 . get Y ( ) ) ; bottom . close Path ( ) ; General Path top = new General Path ( ) ; top . move To ( ( float ) p0 . get X ( ) , ( float ) p0 . get Y ( ) ) ; top . line To ( ( float ) p00 . get X ( ) , ( float ) p00 . get Y ( ) ) ; top . line To ( ( float ) p03 . get X ( ) , ( float ) p03 . get Y ( ) ) ; top . line To ( ( float ) p3 . get X ( ) , ( float ) p3 . get Y ( ) ) ; top . close Path ( ) ; General Path back = new General Path ( ) ; back . move To ( ( float ) p2 . get X ( ) , ( float ) p2 . get Y ( ) ) ; back . line To ( ( float ) p02 . get X ( ) , ( float ) p02 . get Y ( ) ) ; back . line To ( ( float ) p03 . get X ( ) , ( float ) p03 . get Y ( ) ) ; back . line To ( ( float ) p3 . get X ( ) , ( float ) p3 . get Y ( ) ) ; back . close Path ( ) ; General Path front = new General Path ( ) ; front . move To ( ( float ) p0 . get X ( ) , ( float ) p0 . get Y ( ) ) ; front . line To ( ( float ) p1 . get X ( ) , ( float ) p1 . get Y ( ) ) ; front . line To ( ( float ) p01 . get X ( ) , ( float ) p01 . get Y ( ) ) ; front . line To ( ( float ) p00 . get X ( ) , ( float ) p00 . get Y ( ) ) ; front . close Path ( ) ; General Path left = new General Path ( ) ; left . move To ( ( float ) p0 . get X ( ) , ( float ) p0 . get Y ( ) ) ; left . line To ( ( float ) p1 . get X ( ) , ( float ) p1 . get Y ( ) ) ; left . line To ( ( float ) p2 . get X ( ) , ( float ) p2 . get Y ( ) ) ; left . line To ( ( float ) p3 . get X ( ) , ( float ) p3 . get Y ( ) ) ; left . close Path ( ) ; General Path right = new General Path ( ) ; right . move To ( ( float ) p00 . get X ( ) , ( float ) p00 . get Y ( ) ) ; right . line To ( ( float ) p01 . get X ( ) , ( float ) p01 . get Y ( ) ) ; right . line To ( ( float ) p02 . get X ( ) , ( float ) p02 . get Y ( ) ) ; right . line To ( ( float ) p03 . get X ( ) , ( float ) p03 . get Y ( ) ) ; right . close Path ( ) ; result [ NUM ] = bottom ; result [ NUM ] = back ; if ( inverted ) { result [ NUM ] = right ; result [ NUM ] = left ; } else { result [ NUM ] = left ; result [ NUM ] = right ; } result [ NUM ] = top ; result [ NUM ] = front ; return result ; }
public OIDC Tokens acquire Tokens By Secur ID ( String username , String passcode , Secur ID Retriever secur Id Retriever , Token Spec token Spec ) throws OIDC Client Exception , OIDC Server Exception , Token Validation Exception , SSL Connection Exception { Validate . not Empty ( username , STRING ) ; Validate . not Empty ( passcode , STRING ) ; Validate . not Null ( secur Id Retriever , STRING ) ; Validate . not Null ( token Spec , STRING ) ; Http Response http Response = OIDC Client Utils . handle Secur ID Multi Legged Grant ( username , passcode , secur Id Retriever , token Spec , get Token Endpoint URI ( ) , this . client Id , this . holder Of Key Config , this . key Store ) ; return OIDC Client Utils . parse Token Response ( http Response , this . provider Public Key , this . issuer , this . client Id , this . clock Tolerance In Seconds ) ; }
public void load Nested ( Environment env ) { load Nested ( env , NUM ) ; }
private JSON Array request All File Systems ( ) throws IO Exception , JSON Exception { JSON Array ret = new JSON Array ( ) ; for ( Filesystem fs : filesystems ) { ret . put ( fs . get Root Entry ( ) ) ; } return ret ; }
private Promise < Action Response , Resource Exception > internal Handle Action ( String token Id , Context context , Action Request request ) { final String action = request . get Action ( ) ; final Action Handler action Handler = action Handlers . get ( action ) ; if ( action Handler != null ) { return action Handler . handle ( token Id , context , request ) ; } else { String message = String . format ( STRING , action ) ; Not Supported Exception e = new Not Supported Exception ( message ) ; if ( LOGGER . message Enabled ( ) ) { LOGGER . message ( STRING + message , e ) ; } return e . as Promise ( ) ; } }
public int compare To ( Object obj ) { int diff = - NUM ; if ( obj instanceof Parser Notice ) { Parser Notice p2 = ( Parser Notice ) obj ; diff = level - p2 . get Level ( ) ; if ( diff == NUM ) { diff = line - p2 . get Line ( ) ; if ( diff == NUM ) { diff = message . compare To ( p2 . get Message ( ) ) ; } } } return diff ; }
@ Override @ Suppress Warnings ( STRING ) public Named List < Object > do Highlighting ( Doc List docs , Query query , Solr Query Request req , String [ ] default Fields ) throws IO Exception { Solr Params params = req . get Params ( ) ; if ( ! is Highlighting Enabled ( params ) ) return null ; Solr Index Searcher searcher = req . get Searcher ( ) ; Index Schema schema = searcher . get Schema ( ) ; Named List fragments = new Simple Ordered Map ( ) ; String [ ] field Names = get Highlight Fields ( query , req , default Fields ) ; Set < String > fset = new Hash Set < > ( ) ; { for ( String f : field Names ) { fset . add ( f ) ; } Schema Field key Field = schema . get Unique Key Field ( ) ; if ( null != key Field ) fset . add ( key Field . get Name ( ) ) ; } Fast Vector Highlighter fvh = new Fast Vector Highlighter ( params . get Bool ( Highlight Params . USE PHRASE HIGHLIGHTER , BOOL ) , params . get Bool ( Highlight Params . FIELD MATCH , BOOL ) ) ; fvh . set Phrase Limit ( params . get Int ( Highlight Params . PHRASE LIMIT , Solr Highlighter . DEFAULT PHRASE LIMIT ) ) ; Field Query field Query = fvh . get Field Query ( query , searcher . get Index Reader ( ) ) ; Doc Iterator iterator = docs . iterator ( ) ; for ( int i = NUM ; i < docs . size ( ) ; i ++ ) { int doc Id = iterator . next Doc ( ) ; Document doc = searcher . doc ( doc Id , fset ) ; Named List doc Summaries = new Simple Ordered Map ( ) ; for ( String field Name : field Names ) { field Name = field Name . trim ( ) ; if ( use Fast Vector Highlighter ( params , schema , field Name ) ) do Highlighting By Fast Vector Highlighter ( fvh , field Query , req , doc Summaries , doc Id , doc , field Name ) ; else do Highlighting By Highlighter ( query , req , doc Summaries , doc Id , doc , field Name ) ; } String print Id = schema . printable Unique Key ( doc ) ; fragments . add ( print Id == null ? null : print Id , doc Summaries ) ; } return fragments ; }
protected abstract Map < Integer , Filter Operation Delegate Invoker > do Get Invoker Lookup ( ) ;
private I Binding Set aggregate ( final Iterable < I Binding Set > solutions ) { final I Binding Set aggregates = new Context Binding Set ( context , new List Binding Set ( ) ) ; if ( group By != null ) { final I Binding Set a Solution = solutions . iterator ( ) . next ( ) ; for ( I Value Expression < ? > expr : group By ) { if ( expr instanceof I Variable < ? > ) { final I Variable < ? > var = ( I Variable < ? > ) expr ; final Object var Value = var . get ( a Solution ) ; final Constant < ? > val ; if ( var Value == null ) { val = Constant . error Value ( ) ; } else { val = new Constant ( var Value . get Class ( ) . cast ( var Value ) ) ; } ; aggregates . set ( var , val ) ; } else if ( expr instanceof I Bind < ? > ) { final I Bind < ? > bind Expr = ( I Bind < ? > ) expr ; final Constant < ? > val ; final Object expr Value = bind Expr . get ( a Solution ) ; if ( expr Value == null ) { val = Constant . error Value ( ) ; } else { val = new Constant ( expr Value . get Class ( ) . cast ( expr Value ) ) ; } final I Variable < ? > ovar = ( ( I Bind < ? > ) expr ) . get Var ( ) ; aggregates . set ( ovar , val ) ; } } } { final boolean nested Aggregates = group By State . is Nested Aggregates ( ) ; final Iterator < Map . Entry < I Aggregate < ? > , I Variable < ? > > > itr = rewrite . get Agg Expr ( ) . entry Set ( ) . iterator ( ) ; while ( itr . has Next ( ) ) { final Map . Entry < I Aggregate < ? > , I Variable < ? > > e = itr . next ( ) ; do Aggregate ( e . get Key ( ) , e . get Value ( ) , nested Aggregates , aggregates , solutions , stats ) ; } if ( log . is Trace Enabled ( ) ) log . trace ( STRING + aggregates ) ; } for ( I Value Expression < ? > expr : rewrite . get Select 2 ( ) ) { try { expr . get ( aggregates ) ; } catch ( Sparql Type Error Exception ex ) { Type Error Log . handle Type Error ( ex , expr , stats ) ; continue ; } catch ( Illegal Argument Exception ex ) { Type Error Log . handle Type Error ( ex , expr , stats ) ; continue ; } } { final boolean drop ; final I Constraint [ ] having 2 = rewrite . get Having 2 ( ) ; if ( having 2 != null && ! B Op Utility . is Consistent ( having 2 , aggregates ) ) { drop = BOOL ; } else { drop = BOOL ; } if ( log . is Info Enabled ( ) ) log . info ( ( drop ? STRING : STRING ) + STRING + aggregates ) ; if ( drop ) { return null ; } } final I Binding Set out ; if ( group By == null ) { assert ! aggregates . contains Error Values ( ) ; out = aggregates . copy ( group By State . get Select Vars ( ) . to Array ( new I Variable [ NUM ] ) ) ; } else { out = aggregates . copy Minus Errors ( group By State . get Select Vars ( ) . to Array ( new I Variable [ NUM ] ) ) ; } return out ; }
public static void delete Collection ( String host , String collection ) throws Exception { String delete Collection Template = STRING ; String delete Collection Command = String . format ( delete Collection Template , host , DEFAULT SOLR PORT , collection ) ; execute Solr Command ( delete Collection Command ) ; }
private Iterable < Fragment Constructor > create Constructors ( ) { return Collections . unmodifiable List ( Arrays . as List ( new Biome Data Constructor ( Resolution . QUARTER ) , new End Islands Constructor ( ) , new Image Constructor ( Resolution . QUARTER , Layer Ids . BACKGROUND ) , new Image Constructor ( Resolution . CHUNK , Layer Ids . SLIME ) ) ) ; }
public static < T > int copy ( final List < T > from , int first , int last , List < T > to ) { int i = first ; for ( ; i < last ; i ++ ) { to . add ( from . get ( i ) ) ; } return i ; }
@ Nullable public static H Key psi Key ( @ Not Null Psi Method psi Method , @ Not Null Direction direction , @ Not Null Message Digest md ) { final Psi Class psi Class = Psi Tree Util . get Parent Of Type ( psi Method , Psi Class . class , BOOL ) ; if ( psi Class == null ) { return null ; } byte [ ] class Digest = psi Class Digest ( psi Class , md ) ; if ( class Digest == null ) { return null ; } byte [ ] sig Digest = method Digest ( psi Method , md ) ; if ( sig Digest == null ) { return null ; } byte [ ] digest = new byte [ HASH SIZE ] ; System . arraycopy ( class Digest , NUM , digest , NUM , CLASS HASH SIZE ) ; System . arraycopy ( sig Digest , NUM , digest , CLASS HASH SIZE , SIGNATURE HASH SIZE ) ; return new H Key ( digest , mk Direction Key ( direction ) , BOOL ) ; }
public static boolean is Sd Card Mounted ( ) { String status = Environment . get External Storage State ( ) ; if ( status . equals ( Environment . MEDIA MOUNTED ) ) return BOOL ; return BOOL ; }
private void parse Resource ( final Element resource Element , final Collection < Resource > resources ) { final String tag Name = resource Element . get Tag Name ( ) ; final String uri = resource Element . get Text Content ( ) ; if ( TAG GROUP REF . equals ( tag Name ) ) { resources . add All ( get Resources For Group ( uri ) ) ; } if ( get Resource Type ( resource Element ) != null ) { final Resource resource = create Resource ( resource Element ) ; LOG . debug ( STRING , resource ) ; resources . add ( resource ) ; } }
@ Override public void licence File ( String text To Show , File licence File ) throws Cancel Exception { try { final File Input Stream content = new File Input Stream ( licence File ) ; final String Writer writer = new String Writer ( ) ; IO Utils . copy ( content , writer , STRING ) ; content . close ( ) ; licence ( text To Show , writer . to String ( ) ) ; } catch ( IO Exception e ) { throw new Script Failure Exception ( STRING , e ) ; } }
public int mean Allocation ( ) { if ( m slot Allocations == NUM ) return NUM ; return ( int ) ( m size Allocations / m slot Allocations ) ; }
public void test Time Zones ( ) throws Exception { Map < String , String > tz Map = new Hash Map < String , String > ( ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; tz Map . put ( STRING , STRING ) ; for ( String key : tz Map . key Set ( ) ) { assert Equals ( STRING + key + STRING , tz Map . get ( key ) , Time Util . get Canonical Timezone ( key , null ) ) ; } for ( String tz : Time Zone . get Available I Ds ( ) ) { String canonical TZ ; try { canonical TZ = Time Util . get Canonical Timezone ( tz , null ) ; } catch ( SQL Exception e ) { canonical TZ = null ; } assert Not Null ( STRING + tz + STRING , canonical TZ ) ; } }
@ Override public String to String ( ) { return Message Format . format ( STRING + STRING + STRING , get LDAP Filter ( ) , String Utils . join ( requested Attributes , STRING ) ) ; }
public static void convolve And Transpose ( Kernel kernel , int [ ] in Pixels , int [ ] out Pixels , int width , int height , boolean alpha , boolean premultiply , boolean unpremultiply , int edge Action ) { float [ ] matrix = kernel . get Kernel Data ( null ) ; int cols = kernel . get Width ( ) ; int cols 2 = cols / NUM ; for ( int y = NUM ; y < height ; y ++ ) { int index = y ; int ioffset = y * width ; for ( int x = NUM ; x < width ; x ++ ) { float r = NUM , g = NUM , b = NUM , a = NUM ; int moffset = cols 2 ; for ( int col = - cols 2 ; col <= cols 2 ; col ++ ) { float f = matrix [ moffset + col ] ; if ( f != NUM ) { int ix = x + col ; if ( ix < NUM ) { if ( edge Action == CLAMP EDGES ) ix = NUM ; else if ( edge Action == WRAP EDGES ) ix = ( x + width ) % width ; } else if ( ix >= width ) { if ( edge Action == CLAMP EDGES ) ix = width - NUM ; else if ( edge Action == WRAP EDGES ) ix = ( x + width ) % width ; } int rgb = in Pixels [ ioffset + ix ] ; int pa = ( rgb > > NUM ) & NUM ; int pr = ( rgb > > NUM ) & NUM ; int pg = ( rgb > > NUM ) & NUM ; int pb = rgb & NUM ; if ( premultiply ) { float a255 = pa * ( NUM / NUM ) ; pr *= a255 ; pg *= a255 ; pb *= a255 ; } a += f * pa ; r += f * pr ; g += f * pg ; b += f * pb ; } } if ( unpremultiply && a != NUM && a != NUM ) { float f = NUM / a ; r *= f ; g *= f ; b *= f ; } int ia = alpha ? Pixel Utils . clamp ( ( int ) ( a + NUM ) ) : NUM ; int ir = Pixel Utils . clamp ( ( int ) ( r + NUM ) ) ; int ig = Pixel Utils . clamp ( ( int ) ( g + NUM ) ) ; int ib = Pixel Utils . clamp ( ( int ) ( b + NUM ) ) ; out Pixels [ index ] = ( ia << NUM ) | ( ir << NUM ) | ( ig << NUM ) | ib ; index += height ; } } }
public void test Case 6 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { - NUM , - NUM , - NUM , NUM , - NUM , - NUM , - NUM , - NUM , NUM , - NUM , - NUM , - NUM , NUM , - NUM , NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . multiply ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
public void animate Progress Fill ( int animate To ) { m Animation Handler . remove Messages ( NUM ) ; if ( animate To > m Max || animate To < NUM ) { throw new Illegal Argument Exception ( String . format ( STRING , animate To , m Max ) ) ; } m Animation Handler . set Animate To ( animate To ) ; m Animation Handler . send Empty Message ( NUM ) ; invalidate ( ) ; }
static boolean is Registered ( Object Name object Name ) { Set < Object Name > registered Object Names = m Bean Server . query Names ( object Name , null ) ; return ! registered Object Names . is Empty ( ) ; }
public < T > Pushable Lazy Future Stream < T > future Stream ( final Lazy React s ) { final Queue < T > q = create Queue ( ) ; return new Pushable Lazy Future Stream < T > ( q , s . from Stream ( q . stream ( ) ) ) ; }
public byte [ ] convert Hex String To Binary ( String hex String ) throws Illegal Argument Exception { int length = hex String . length ( ) ; if ( length % NUM != NUM ) { throw new Illegal Argument Exception ( STRING + length + STRING + hex String ) ; } byte [ ] binary = new byte [ length / NUM ] ; for ( int i = NUM ; i < length ; i += NUM ) { char high Bits Char = hex String . char At ( i ) ; char low Bits Char = hex String . char At ( i + NUM ) ; int high Bits = hex Char To Int ( high Bits Char , hex String ) << NUM ; int low Bits = hex Char To Int ( low Bits Char , hex String ) ; binary [ i / NUM ] = ( byte ) ( high Bits + low Bits ) ; } return binary ; }
public void write Field ( final String name , final short value ) throws java . io . IO Exception { write Field ( name , Short . to String ( value ) ) ; }
public static Result Set select ( Connection conn , String sql ) throws SQL Exception { Statement stat = conn . create Statement ( Result Set . TYPE SCROLL INSENSITIVE , Result Set . CONCUR READ ONLY ) ; return stat . execute Query ( sql ) ; }
public static void write Set Of Longs ( Set set , boolean has Long I Ds , Data Output out ) throws IO Exception { if ( set == null ) { out . write Int ( - NUM ) ; } else { out . write Int ( set . size ( ) ) ; out . write Boolean ( has Long I Ds ) ; for ( Iterator it = set . iterator ( ) ; it . has Next ( ) ; ) { Long l = ( Long ) it . next ( ) ; if ( has Long I Ds ) { out . write Long ( l . long Value ( ) ) ; } else { out . write Int ( ( int ) l . long Value ( ) ) ; } } } }
private void restore Widget ( Key key , byte [ ] buffer , int data Size ) throws IO Exception { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base 64 . encode To String ( buffer , NUM , data Size , Base 64 . NO WRAP ) ) ; Widget widget = unpack Proto ( new Widget ( ) , buffer , data Size ) ; if ( DEBUG ) Log . d ( TAG , STRING + widget . provider ) ; if ( widget . icon . data != null ) { Bitmap icon = Bitmap Factory . decode Byte Array ( widget . icon . data , NUM , widget . icon . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } else { m Icon Cache . preload Icon ( Component Name . unflatten From String ( widget . provider ) , icon , widget . icon . dpi , widget . label , m User Serial , m Idp ) ; } } widget Sizes . add ( widget . provider + STRING + NUM + STRING + NUM ) ; }
private static boolean has Response Body ( int request Method , int response Code ) { return request Method != Request . Method . HEAD && ! ( Http Status . SC CONTINUE <= response Code && response Code < Http Status . SC OK ) && response Code != Http Status . SC NO CONTENT && response Code != Http Status . SC NOT MODIFIED ; }
public void consider Region X Region ( Geo Region r , Geo Region region ) { Geo Array r Boundary = r . get Points ( ) ; Geo r Point = r Boundary . get ( NUM , new Geo ( ) ) ; Geo Array region Boundary = region . get Points ( ) ; Geo region Point = region Boundary . get ( NUM , new Geo ( ) ) ; if ( Intersection . is Point In Polygon ( r Point , region Boundary ) || Intersection . is Point In Polygon ( region Point , r Boundary ) ) { collector . collect ( r , region ) ; } else { for ( Geo Path . Segment Iterator pit = r . segment Iterator ( ) ; pit . has Next ( ) ; ) { Geo Segment seg = pit . next Segment ( ) ; if ( filter . pre Consider ( seg , region ) && consider Segment X Region ( seg , region ) ) { collector . collect ( seg , region ) ; return ; } } } }
private X Path Factory load From Services File ( String uri , String resource Name , Input Stream in ) { if ( debug ) debug Println ( STRING + resource Name ) ; Buffered Reader rd ; try { rd = new Buffered Reader ( new Input Stream Reader ( in , STRING ) , DEFAULT LINE LENGTH ) ; } catch ( java . io . Unsupported Encoding Exception e ) { rd = new Buffered Reader ( new Input Stream Reader ( in ) , DEFAULT LINE LENGTH ) ; } String factory Class Name ; X Path Factory result Factory = null ; while ( BOOL ) { try { factory Class Name = rd . read Line ( ) ; } catch ( IO Exception x ) { break ; } if ( factory Class Name != null ) { int hash Index = factory Class Name . index Of ( STRING ) ; if ( hash Index != - NUM ) { factory Class Name = factory Class Name . substring ( NUM , hash Index ) ; } factory Class Name = factory Class Name . trim ( ) ; if ( factory Class Name . length ( ) == NUM ) { continue ; } try { X Path Factory found Factory = create Instance ( factory Class Name ) ; if ( found Factory . is Object Model Supported ( uri ) ) { result Factory = found Factory ; break ; } } catch ( Exception ignored ) { } } else { break ; } } Io Utils . close Quietly ( rd ) ; return result Factory ; }
private char fold Case ( char ch ) { if ( ch < NUM ) { if ( STRING <= ch && ch <= STRING ) { return ( char ) ( ch + ( STRING - STRING ) ) ; } return ch ; } return Character . to Lower Case ( Character . to Upper Case ( ch ) ) ; }
public Writable Raster create Compatible Writable Raster ( int w , int h ) { if ( w <= NUM || h <= NUM ) { throw new Raster Format Exception ( STRING + ( ( w <= NUM ) ? STRING : STRING ) ) ; } Sample Model sm = sample Model . create Compatible Sample Model ( w , h ) ; return new Byte Banded Raster ( sm , new Point ( NUM , NUM ) ) ; }
Configuration Error ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
@ Target Api ( VERSION CODES . LOLLIPOP ) public static void reveal ( final View view , int cx , int cy ) { if ( ! has Lollipop ( ) ) { view . set Visibility ( View . VISIBLE ) ; return ; } int final Radius = Math . max ( view . get Width ( ) , view . get Height ( ) ) ; Animator animator = View Animation Utils . create Circular Reveal ( view , cx , cy , NUM , final Radius ) ; view . set Visibility ( View . VISIBLE ) ; animator . start ( ) ; }
public Top N Metric ( Top N Metric Type type , String previous Stop , Sort Direction order ) { this ( type , previous Stop ) ; if ( order == Sort Direction . ASC ) { this . type = Top N Metric Type . INVERTED ; this . nested = Optional . of ( new Top N Metric ( type , previous Stop ) ) ; this . previous Stop = Optional . empty ( ) ; } }
public void remove Supported Options ( Set < String > unmatched Processor Options ) { unmatched Processor Options . remove All ( supported Option Names ) ; }
protected void subscribe ( ) { if ( sample Client Sub == null ) { try { sample Client Sub = new Sample Async Callback ( url , client Id Sub , clean Session , quiet Mode , user Name , password ) ; } catch ( Mqtt Exception e ) { e . print Stack Trace ( ) ; } } if ( sample Client Sub != null ) { String topic = STRING ; int qos = NUM ; try { sample Client Sub . subscribe ( topic , qos ) ; } catch ( Throwable e ) { e . print Stack Trace ( ) ; } } }
private boolean should Crop ( int width , int height ) { int pixel Error = NUM ; pixel Error += Math . round ( Math . max ( width , height ) / NUM ) ; return ( m Max Result Image Size X > NUM && m Max Result Image Size Y > NUM ) || Math . abs ( m Crop Rect . left - m Current Image Rect . left ) > pixel Error || Math . abs ( m Crop Rect . top - m Current Image Rect . top ) > pixel Error || Math . abs ( m Crop Rect . bottom - m Current Image Rect . bottom ) > pixel Error || Math . abs ( m Crop Rect . right - m Current Image Rect . right ) > pixel Error ; }
public boolean exists ( ) { return do Access ( F OK ) ; }
@ Deprecated public boolean is Fill Below Line ( ) { return m Fill Below Line . size ( ) > NUM ; }
public Shape Tile Box bounding box ( ) { if ( bounding box != null ) return bounding box ; Pla Point Float start corner = start point approx ( ) ; Pla Point Float end corner = end point approx ( ) ; double llx = Math . min ( start corner . v x , end corner . v x ) ; double lly = Math . min ( start corner . v y , end corner . v y ) ; double urx = Math . max ( start corner . v x , end corner . v x ) ; double ury = Math . max ( start corner . v y , end corner . v y ) ; Pla Point Int lower left = new Pla Point Int ( Math . floor ( llx ) , Math . floor ( lly ) ) ; Pla Point Int upper right = new Pla Point Int ( Math . ceil ( urx ) , Math . ceil ( ury ) ) ; bounding box = new Shape Tile Box ( lower left , upper right ) ; return bounding box ; }
public boolean is Valid Attachment Point ( Datapath Id switch DPID , OF Port switch Port ) { if ( topology . is Attachment Point Port ( switch DPID , switch Port ) == BOOL ) return BOOL ; if ( suppress A Ps . contains ( new Switch Port ( switch DPID , switch Port ) ) ) return BOOL ; return BOOL ; }
public void test Classpath War ( ) throws Exception { final URL url = new URL ( STRING + System . get Property ( STRING ) + STRING ) ; final String expected = STRING ; Ping Utils . assert Ping True ( url . get Path ( ) + STRING , expected , url , logger ) ; }
protected abstract boolean is Nullable ( ) ;
public vec 3 normalize ( ) { float x = this . m [ NUM ] ; float y = this . m [ NUM ] ; float z = this . m [ NUM ] ; float s = NUM / ( float ) Math . sqrt ( x * x + y * y + z * z ) ; this . m [ NUM ] = x * s ; this . m [ NUM ] = y * s ; this . m [ NUM ] = z * s ; return this ; }
@ Override public P read Page ( int page ID ) { try { count Read ( ) ; long offset = ( ( long ) ( header . get Reserved Pages ( ) + page ID ) ) * ( long ) page Size ; byte [ ] buffer = new byte [ page Size ] ; file . seek ( offset ) ; file . read ( buffer ) ; return byte Array To Page ( buffer ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING + page ID + STRING , e ) ; } }
public void add Action Listener ( Action Listener listener ) { forward Projection Button . add Action Listener ( listener ) ; back Projection Button . add Action Listener ( listener ) ; }
void write Data To File Locked ( Random Access File file , boolean add Mayo , boolean add Tomato , int which Filling ) throws IO Exception { file . set Length ( NUM ) ; file . write Int ( which Filling ) ; file . write Boolean ( add Mayo ) ; file . write Boolean ( add Tomato ) ; Log . v ( TAG , STRING + add Mayo + STRING + add Tomato + STRING + which Filling ) ; }
static Type [ ] map Key And Value Types ( Type context , Class < ? > context Raw Type ) { if ( context == Properties . class ) return new Type [ ] { String . class , String . class } ; Type map Type = get Supertype ( context , context Raw Type , Map . class ) ; if ( map Type instanceof Parameterized Type ) { Parameterized Type map Parameterized Type = ( Parameterized Type ) map Type ; return map Parameterized Type . get Actual Type Arguments ( ) ; } return new Type [ ] { Object . class , Object . class } ; }
static Aggregated Http Message of ( Http Headers headers , Http Data content , Http Headers trailing Headers ) { return of ( Collections . empty List ( ) , headers , content , trailing Headers ) ; }
public static boolean is Letter ( char c ) { return Character . is Letter ( c ) ; }
protected List < Tree Node > create Child List ( ) { Branch branch = get Xml Branch ( ) ; int size = branch . node Count ( ) ; List < Tree Node > child List = new Array List < Tree Node > ( size ) ; for ( int i = NUM ; i < size ; i ++ ) { Node node = branch . node ( i ) ; if ( node instanceof Character Data ) { String text = node . get Text ( ) ; if ( text == null ) { continue ; } text = text . trim ( ) ; if ( text . length ( ) <= NUM ) { continue ; } } child List . add ( create Child Tree Node ( node ) ) ; } return child List ; }
public Set < Value > may Aliases ( Value v , Unit u ) { Set < Value > res = new Hash Set < Value > ( ) ; Set < Set < Value > > flow = get Flow Before ( u ) ; for ( Set < Value > set : flow ) { if ( set . contains ( v ) ) res . add All ( set ) ; } return res ; }
@ Nullable private static String read ( @ Non Null Socket Channel socket , @ Non Null byte [ ] buffer ) throws IO Exception { Byte Buffer buf = Byte Buffer . wrap ( buffer , NUM , buffer . length ) ; while ( buf . position ( ) != buf . limit ( ) ) { int count ; count = socket . read ( buf ) ; if ( count < NUM ) { throw new IO Exception ( STRING ) ; } } try { return new String ( buffer , NUM , buf . position ( ) , Adb Helper . DEFAULT ENCODING ) ; } catch ( Unsupported Encoding Exception e ) { return null ; } }
public static Date Time Unit create Local Date Unit Instance ( Date date , org . hisp . dhis . calendar . Calendar calendar ) { return calendar . from Iso ( Date Time Unit . from Jdk Date ( date ) ) ; }
public static boolean equal ( double a , double b ) { return ( Math . abs ( a - b ) < EPSILON ) ; }
@ Override public void add Class Annotation ( char [ ] buffer , int offset , int length ) { String ann Type = new String ( buffer , offset , length ) ; if ( ann Types . contains ( ann Type ) ) { add Class ( class Name ) ; } }
public Process exec ( String [ ] tainted Command , String [ ] tainted Environment , File working Directory , boolean redirect Error Stream ) throws IO Exception { if ( tainted Command == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( tainted Command . length == NUM ) { throw new Index Out Of Bounds Exception ( STRING ) ; } String [ ] command = tainted Command . clone ( ) ; String [ ] environment = tainted Environment != null ? tainted Environment . clone ( ) : null ; for ( int i = NUM ; i < command . length ; i ++ ) { if ( command [ i ] == null ) { throw new Null Pointer Exception ( STRING + i + STRING ) ; } } if ( environment != null ) { for ( int i = NUM ; i < environment . length ; i ++ ) { if ( environment [ i ] == null ) { throw new Null Pointer Exception ( STRING + i + STRING ) ; } } } File Descriptor in = new File Descriptor ( ) ; File Descriptor out = new File Descriptor ( ) ; File Descriptor err = new File Descriptor ( ) ; String working Path = ( working Directory == null ) ? null : working Directory . get Path ( ) ; synchronized ( process References ) { int pid ; try { pid = exec ( command , environment , working Path , in , out , err , redirect Error Stream ) ; } catch ( IO Exception e ) { IO Exception wrapper = new IO Exception ( STRING + STRING + Arrays . to String ( command ) + STRING + working Directory + STRING + Arrays . to String ( environment ) ) ; wrapper . init Cause ( e ) ; throw wrapper ; } Process Impl process = new Process Impl ( pid , in , out , err ) ; Process Reference process Reference = new Process Reference ( process , reference Queue ) ; process References . put ( pid , process Reference ) ; process References . notify All ( ) ; return process ; } }
static Path Part make Absolute ( Path Part old Part ) { @ Suppress Warnings ( STRING ) boolean encoded Cached = old Part . encoded != NOT CACHED ; String old Path = encoded Cached ? old Part . encoded : old Part . decoded ; if ( old Path == null || old Path . length ( ) == NUM || old Path . starts With ( STRING ) ) { return old Part ; } String new Encoded = encoded Cached ? STRING + old Part . encoded : NOT CACHED ; @ Suppress Warnings ( STRING ) boolean decoded Cached = old Part . decoded != NOT CACHED ; String new Decoded = decoded Cached ? STRING + old Part . decoded : NOT CACHED ; return new Path Part ( new Encoded , new Decoded ) ; }
public static int [ ] split Gt ( String gt ) { final int gtlen = gt . length ( ) ; if ( gtlen == NUM ) { return new int [ ] { allele Id ( gt . char At ( NUM ) ) } ; } else { int [ ] result = new int [ NUM ] ; int ploid = NUM ; int allelestart = NUM ; for ( int i = NUM ; i < gtlen ; i ++ ) { final char c = gt . char At ( i ) ; if ( c == PHASED SEPARATOR || c == UNPHASED SEPARATOR ) { if ( ploid == result . length ) { result = Arrays . copy Of ( result , result . length + NUM ) ; } result [ ploid ++ ] = allele Id ( gt , allelestart , i - allelestart ) ; allelestart = i + NUM ; } } if ( allelestart < gtlen ) { if ( ploid == result . length ) { result = Arrays . copy Of ( result , result . length + NUM ) ; } result [ ploid ++ ] = allele Id ( gt , allelestart , gtlen - allelestart ) ; } if ( ploid < result . length ) { result = Arrays . copy Of ( result , ploid ) ; } if ( ploid == NUM ) { throw new Number Format Exception ( STRING + gt + STRING ) ; } return result ; } }
public void test Bug 18041 ( ) throws Exception { if ( version Meets Minimum ( NUM , NUM ) ) { create Table ( STRING , STRING ) ; Properties props = new Properties ( ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; Connection trunc Conn = null ; Prepared Statement stm = null ; try { trunc Conn = get Connection With Props ( props ) ; stm = trunc Conn . prepare Statement ( STRING ) ; stm . set Int ( NUM , NUM ) ; stm . set String ( NUM , STRING ) ; stm . execute Update ( ) ; fail ( STRING ) ; } catch ( Data Truncation trunc Ex ) { } finally { if ( trunc Conn != null ) { trunc Conn . close ( ) ; } } } }
public void delete Kernel ( String name ) { Kernel kernel = get Kernel By Name ( name ) ; if ( kernel != null ) { kernel . dispose ( ) ; Integer old Size = Integer . value Of ( kernel Hash Table . size ( ) ) ; kernel Hash Table . remove ( name ) ; set Dirty And Fire Property Change ( KERNEL LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( kernel Hash Table . size ( ) ) ) ; } }
protected boolean should Stop ( ) { return is Paused ( ) || is Killed ( ) ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
public Builder add Token Filter ( String name , Map < String , String > params ) throws IO Exception { Objects . require Non Null ( name , STRING ) ; token Filters . add ( apply Resource Loader ( Token Filter Factory . for Name ( name , apply Default Params ( params ) ) ) ) ; components Added = BOOL ; return this ; }
public Styled Tool Tip UI ( Style style ) { this . style = style ; border = Border Factory . create Line Border ( style . get Shadow Color ( ) ) ; }
public final void add Elements ( Object value , int number Of Elements ) { if ( ( m first Free + number Of Elements ) >= m map Size ) { m map Size += ( m blocksize + number Of Elements ) ; Object new Map [ ] = new Object [ m map Size ] ; System . arraycopy ( m map , NUM , new Map , NUM , m first Free + NUM ) ; m map = new Map ; } for ( int i = NUM ; i < number Of Elements ; i ++ ) { m map [ m first Free ] = value ; m first Free ++ ; } }
public void action Performed ( Action Event e ) { super . action Performed ( e ) ; String cmd = e . get Action Command ( ) ; if ( cmd == show Maps Command ) { J Check Box map Check = ( J Check Box ) e . get Source ( ) ; view Attributes . show Maps = map Check . is Selected ( ) ; repaint ( ) ; } else if ( cmd == show Info Command ) { J Check Box info Check = ( J Check Box ) e . get Source ( ) ; boolean show Info = info Check . is Selected ( ) ; view Attributes . show Info = show Info ; show Subframes ( show Info ) ; do Prepare ( ) ; } else if ( cmd == lock Series Command ) { J Check Box lock Check = ( J Check Box ) e . get Source ( ) ; boolean locked = lock Check . is Selected ( ) ; if ( locked ) { List < Rpf Coverage Box > coverage Boxes = get Coverage Boxes ( ) ; String series Name ; if ( coverage Boxes == null || coverage Boxes . is Empty ( ) ) { series Name = Rpf View Attributes . ANY ; } else { series Name = coverage Boxes . get ( NUM ) . chart Code ; } if ( series Name == null ) { series Name = Rpf View Attributes . ANY ; fire Request Message ( STRING + get Name ( ) + STRING ) ; } lock Check . set Text ( locked Button Title + STRING + series Name ) ; view Attributes . chart Series = series Name ; } else { lock Check . set Text ( unlocked Button Title ) ; view Attributes . chart Series = Rpf View Attributes . ANY ; } } else if ( cmd == show Coverage Command ) { if ( coverage != null ) { J Check Box coverage Check = ( J Check Box ) e . get Source ( ) ; coverage . set In Use ( coverage Check . is Selected ( ) ) ; do Prepare ( ) ; } } else { do Prepare ( ) ; } }
@ Override public void run ( ) { if ( m Delay > NUM ) { try { Thread . sleep ( m Delay ) ; } catch ( Interrupted Exception e ) { Log Impl . w ( TAG , get Name ( ) + STRING + e . get Message ( ) ) ; } } if ( m Parent Task != null ) { synchronized ( this ) { try { wait ( ) ; } catch ( Interrupted Exception e ) { Log Impl . w ( TAG , get Name ( ) + STRING + e . get Message ( ) ) ; } } } m Status = Status . STATUS EXECUTING ; long start Time = System . current Time Millis ( ) ; start ( ) ; long end Time = System . current Time Millis ( ) ; Log Impl . i ( TAG , get Name ( ) + STRING + ( end Time - start Time ) ) ; if ( m Done Signal != null ) { m Done Signal . count Down ( ) ; } if ( m Child Task != null ) { synchronized ( m Child Task ) { m Child Task . notify ( ) ; } } m Status = Status . STATUS DONE ; }
public boolean has ( final String name ) { return contents . contains Key ( name . to Lower Case ( ) ) ; }
public void stop ( ) { is Alive . set ( BOOL ) ; for ( Kafka Consumer < byte [ ] , byte [ ] > c : consumers . values ( ) ) { c . wakeup ( ) ; } kafka Consumer Executor . shutdown Now ( ) ; holding Buffer . clear ( ) ; IO Utils . close Quietly ( this ) ; }
protected final void refresh Loading Views Size ( ) { final int maximum Pull Scroll = ( int ) ( get Maximum Pull Scroll ( ) * NUM ) ; int p Left = get Padding Left ( ) ; int p Top = get Padding Top ( ) ; int p Right = get Padding Right ( ) ; int p Bottom = get Padding Bottom ( ) ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Width ( maximum Pull Scroll ) ; p Left = - maximum Pull Scroll ; } else { p Left = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Width ( maximum Pull Scroll ) ; p Right = - maximum Pull Scroll ; } else { p Right = NUM ; } break ; case VERTICAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Height ( maximum Pull Scroll ) ; p Top = - maximum Pull Scroll ; } else { p Top = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Height ( maximum Pull Scroll ) ; p Bottom = - maximum Pull Scroll ; } else { p Bottom = NUM ; } break ; } if ( DEBUG ) { Log . d ( LOG TAG , String . format ( STRING , p Left , p Top , p Right , p Bottom ) ) ; } set Padding ( p Left , p Top , p Right , p Bottom ) ; }
public String consume Element Selector ( ) { int start = pos ; while ( ! is Empty ( ) && ( matches Word ( ) || matches Any ( STRING , STRING , STRING ) ) ) pos ++ ; return queue . substring ( start , pos ) ; }
@ Suppress Warnings ( STRING ) public Long Map ( int initial Capacity , float load Factor ) { if ( initial Capacity < NUM ) throw new Illegal Argument Exception ( STRING + initial Capacity ) ; if ( initial Capacity > NUM << NUM ) throw new Illegal Argument Exception ( STRING + initial Capacity ) ; capacity = next Power Of Two ( initial Capacity ) ; if ( load Factor <= NUM ) throw new Illegal Argument Exception ( STRING + load Factor ) ; this . load Factor = load Factor ; threshold = ( int ) ( capacity * load Factor ) ; mask = capacity - NUM ; hash Shift = NUM - Long . number Of Trailing Zeros ( capacity ) ; stash Capacity = Math . max ( NUM , ( int ) Math . ceil ( Math . log ( capacity ) ) * NUM ) ; push Iterations = Math . max ( Math . min ( capacity , NUM ) , ( int ) Math . sqrt ( capacity ) / NUM ) ; key Table = new long [ capacity + stash Capacity ] ; value Table = ( V [ ] ) new Object [ key Table . length ] ; }
public void end Attributes ( ) throws SAX Exception { String uri = get Current Element Uri ( ) ; String local = get Current Element Local ( ) ; String prefix = ns Context . get Prefix ( uri ) ; assert ( prefix != null ) ; String qname ; if ( prefix . length ( ) != NUM ) qname = prefix + STRING + local ; else qname = local ; ns Context . iterate Declared Prefixes ( start Prefix Callback ) ; writer . start Element ( uri , local , qname , attributes ) ; attributes . clear ( ) ; text Buf . set Length ( NUM ) ; }
private String abbreviate Script ( String script ) { if ( script == null ) { return null ; } if ( script . length ( ) <= NUM ) { return script ; } return STRING + script . substring ( NUM , NUM ) ; }
public static void expand ID ( String number String , Word Relation word Relation , Item token Item ) { int number Digits = number String . length ( ) ; if ( ( number Digits == NUM ) && ( number String . char At ( NUM ) == STRING ) && ( number String . char At ( NUM ) == STRING ) ) { if ( number String . char At ( NUM ) == STRING ) { expand Number ( number String , word Relation , token Item ) ; } else { expand Number ( number String . substring ( NUM , NUM ) , word Relation , token Item ) ; word Relation . add Word ( token Item , STRING ) ; } } else if ( ( number Digits == NUM ) && ( number String . char At ( NUM ) == STRING ) ) { word Relation . add Word ( token Item , STRING ) ; expand Digits ( number String . substring ( NUM , NUM ) , word Relation , token Item ) ; } else if ( ( number Digits == NUM && number String . char At ( NUM ) == STRING ) || number Digits < NUM ) { expand Number ( number String , word Relation , token Item ) ; } else if ( number Digits % NUM == NUM ) { String first Digit = digit 2 num [ number String . char At ( NUM ) - STRING ] ; word Relation . add Word ( token Item , first Digit ) ; expand ID ( number String . substring ( NUM , number Digits ) , word Relation , token Item ) ; } else { expand Number ( number String . substring ( NUM , NUM ) , word Relation , token Item ) ; expand ID ( number String . substring ( NUM , number Digits ) , word Relation , token Item ) ; } }
private static void unregister Mbeans From Props File ( M Bean Server m Bean Server ) throws Exception { Jamon Properties Loader loader = new Jamon Properties Loader ( ) ; List < String > jamon Jmx Bean Properties = loader . get Mx Beans ( ) ; Iterator < String > iter = jamon Jmx Bean Properties . iterator ( ) ; while ( iter . has Next ( ) ) { String bean Info = iter . next ( ) ; Monitor MX Bean m Xbean = Monitor MX Bean Factory . create ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Object Name ( m Xbean ) ) ; Monitor MX Bean m Xbean Delta = Monitor MX Bean Factory . create Delta ( bean Info ) ; m Bean Server . unregister M Bean ( Monitor MX Bean Factory . get Delta Object Name ( m Xbean Delta ) ) ; } }
Source pop Import Source ( ) { return ( Source ) m import Source Stack . pop ( ) ; }
public static Date zero Time Date ( Date date ) { final Gregorian Calendar gregorian Calendar = new Gregorian Calendar ( ) ; gregorian Calendar . set Time ( date ) ; gregorian Calendar . set ( Calendar . HOUR OF DAY , NUM ) ; gregorian Calendar . set ( Calendar . MINUTE , NUM ) ; gregorian Calendar . set ( Calendar . SECOND , NUM ) ; gregorian Calendar . set ( Calendar . MILLISECOND , NUM ) ; return gregorian Calendar . get Time ( ) ; }
public static final void write Map Xml ( Map val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } Set s = val . entry Set ( ) ; Iterator i = s . iterator ( ) ; out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } while ( i . has Next ( ) ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; write Value Xml ( e . get Value ( ) , ( String ) e . get Key ( ) , out ) ; } out . end Tag ( null , STRING ) ; }
protected void export ( ) { int ret Val ; File file ; Abstract File Saver saver ; if ( m File Chooser == null ) m File Chooser = GUI Helper . new Converter File Chooser ( ) ; ret Val = m File Chooser . show Save Dialog ( this ) ; if ( ret Val != Converter File Chooser . APPROVE OPTION ) return ; file = m File Chooser . get Selected File ( ) ; saver = m File Chooser . get Saver ( ) ; try { saver . set Instances ( m Data Panel . get Instances ( ) ) ; saver . write Batch ( ) ; } catch ( Exception e ) { J Option Pane . show Message Dialog ( this , STRING + file + STRING + Utils . throwable To String ( e ) , STRING , J Option Pane . ERROR MESSAGE ) ; } }
public void sort ( int i ) { Arrays . sort ( vector [ i ] , NUM , sizes . get ( i ) ) ; }
private void create Map When Needed ( ) { if ( is Map Initialized ) { return ; } if ( resource Bundle != null ) { Set < String > set = resource Bundle . key Set ( ) ; top Level Map = new Hash Map < String , Object > ( set . size ( ) ) ; for ( String key : set ) { Object value = resource Bundle . get Object ( key ) ; top Level Map . put ( key , value ) ; } } else { top Level Map = new Hash Map < String , Object > ( NUM ) ; } top Level Map . put ( STRING , resource Bundle ) ; is Map Initialized = BOOL ; }
public static Vector Clock increment ( Vector Clock clock , int ... nodes ) { for ( int n : nodes ) clock = clock . incremented ( ( short ) n , System . current Time Millis ( ) ) ; return clock ; }
@ Override public String to String ( ) { return STRING + set . to String ( ) ; }
void create Heap Phi Instruction ( Basic Block bb , Heap Variable < Object > H ) { Instruction s = make Phi Instruction ( H , bb ) ; Array List < Instruction > heap Phis = heap Phi . get ( bb ) ; if ( heap Phis == null ) { heap Phis = new Array List < Instruction > ( NUM ) ; heap Phi . put ( bb , heap Phis ) ; } heap Phis . add ( s ) ; register Instruction ( s , bb ) ; }
protected void print Time ( String s ) { Simple Date Format date Format = new Simple Date Format ( STRING ) ; println ( date Format . format ( new java . util . Date ( ) ) + STRING + s ) ; }
public static int determine Sample Size ( Image Request image Request , Encoded Image encoded Image ) { if ( ! Encoded Image . is Meta Data Available ( encoded Image ) ) { return DEFAULT SAMPLE SIZE ; } float ratio = determine Downsample Ratio ( image Request , encoded Image ) ; int sample Size ; if ( encoded Image . get Image Format ( ) == Image Format . JPEG ) { sample Size = ratio To Sample Size JPEG ( ratio ) ; } else { sample Size = ratio To Sample Size ( ratio ) ; } int max Dimension = Math . max ( encoded Image . get Height ( ) , encoded Image . get Width ( ) ) ; while ( max Dimension / sample Size > MAX BITMAP SIZE ) { if ( encoded Image . get Image Format ( ) == Image Format . JPEG ) { sample Size *= NUM ; } else { sample Size ++ ; } } return sample Size ; }
public Skeleton ( Print Writer out ) { this . out = out ; }
public void disconnect ( ) { if ( conn != null ) { try { conn . close ( ) ; } catch ( SQL Exception e ) { logger . warn ( STRING , e ) ; } } try { close Binlog ( ) ; } catch ( IO Exception e ) { logger . warn ( STRING , e ) ; } }
@ Override public int read ( byte [ ] b , int off , int len ) throws IO Exception { int n = in . read ( b , off , len ) ; if ( n == - NUM ) { throw If False EOF ( ) ; } else { bytes Read += n ; } return n ; }
@ Override public Generator < I Line Segment > construct ( String [ ] args ) { return new Integer Generator ( Integer . value Of ( args [ NUM ] ) , Integer . value Of ( args [ NUM ] ) ) ; }
public Spatial Strategy ( Spatial Context ctx , String field Name ) { if ( ctx == null ) throw new Illegal Argument Exception ( STRING ) ; this . ctx = ctx ; if ( field Name == null || field Name . length ( ) == NUM ) throw new Illegal Argument Exception ( STRING ) ; this . field Name = field Name ; }
public void dispose ( ) { if ( keys != null ) { keys . clear ( ) ; keys = null ; } super . dispose ( ) ; }
public boolean is Fixed Disk ( String letter ) { if ( letter . length ( ) != NUM ) throw new Illegal Argument Exception ( STRING + letter ) ; char drive = Character . to Upper Case ( letter . char At ( NUM ) ) ; if ( drive < STRING || drive > STRING ) throw new Illegal Argument Exception ( STRING + drive ) ; return get Drive Type ( drive + STRING ) == NUM ; }
private void move Pos ( float delta Y ) { if ( ( delta Y < NUM && m Ptr Indicator . is In Start Position ( ) ) ) { if ( DEBUG ) { Ptr C Log . e ( LOG TAG , String . format ( STRING ) ) ; } return ; } int to = m Ptr Indicator . get Current Pos Y ( ) + ( int ) delta Y ; if ( m Ptr Indicator . will Over Top ( to ) ) { if ( DEBUG ) { Ptr C Log . e ( LOG TAG , String . format ( STRING ) ) ; } to = Ptr Indicator . POS START ; } m Ptr Indicator . set Current Pos ( to ) ; int change = to - m Ptr Indicator . get Last Pos Y ( ) ; update Pos ( change ) ; }
private Object [ ] compile ( String path ) { List list = new Array List ( ) ; if ( path == null ) { return list . to Array ( ) ; } String Tokenizer tok = new String Tokenizer ( path , STRING ) ; while ( tok . has More Tokens ( ) ) { String token = tok . next Token ( ) ; Op Enum op = Op Enum . get Instance ( token ) ; if ( op == null ) { throw new Error ( STRING + path ) ; } list . add ( op ) ; if ( op == Op Enum . RELATION ) { list . add ( tok . next Token ( ) ) ; } } return list . to Array ( ) ; }
private void split Chunk ( final Memory Chunk chunk , final long address ) { final byte [ ] old Data = chunk . get Bytes ( ) ; final byte [ ] new Data 1 = new byte [ ( int ) ( address - chunk . get Address ( ) ) ] ; final byte [ ] new Data 2 = new byte [ ( chunk . get Length ( ) - new Data 1 . length ) ] ; System . arraycopy ( old Data , NUM , new Data 1 , NUM , new Data 1 . length ) ; System . arraycopy ( old Data , old Data . length - new Data 2 . length , new Data 2 , NUM , new Data 2 . length ) ; final Memory Chunk new Chunk 1 = new Memory Chunk ( chunk . get Address ( ) , new Data 1 ) ; final Memory Chunk new Chunk 2 = new Memory Chunk ( ( chunk . get Address ( ) + chunk . get Length ( ) ) - new Data 2 . length , new Data 2 ) ; remove Chunk ( chunk ) ; insert Chunk ( new Chunk 1 ) ; insert Chunk ( new Chunk 2 ) ; }
public boolean is Dirty ( ) { return dirty ; }
private Vector show Text Fixed Width ( String text , int align ) { Vector comps = new Vector ( ) ; if ( ( text == null ) || ( text . equals ( STRING ) ) ) { return comps ; } int space W = width - x ; Vector words = get Words ( text , align , BOOL ) ; if ( words . size ( ) > NUM ) { int w = NUM ; String word Str = STRING ; if ( ( CSS Parser . is White Space ( text . char At ( NUM ) ) ) && ( cur Line . get Component Count ( ) != NUM ) ) { word Str = STRING ; } while ( w < words . size ( ) ) { String next Word = ( String ) words . element At ( w ) ; String space = STRING ; if ( ( ! word Str . equals ( STRING ) ) && ( ! word Str . equals ( STRING ) ) ) { space = STRING ; } if ( font . string Width ( word Str + space + next Word ) > space W - NUM ) { comps . add Element ( add String ( word Str , align ) ) ; new Line If Not Empty ( align ) ; space W = width - x ; word Str = next Word ; } else { word Str += space + next Word ; } w ++ ; } if ( CSS Parser . is White Space ( text . char At ( text . length ( ) - NUM ) ) ) { word Str += STRING ; } comps . add Element ( add String ( word Str , align ) ) ; } return comps ; }
private void calculate Slot Usage ( ) { num Entries = NUM ; for ( int i = NUM ; i < table . table . length ; i ++ ) { Linked List < V > list = ( Linked List < V > ) table . table [ i ] ; if ( list != null ) { num Entries += list . size ( ) ; int Hash Table [ i ] += list . size ( ) ; } } }
public Insert default Values ( ) { default Values = BOOL ; columns . clear ( ) ; values To Insert . clear ( ) ; query = null ; invalidate Compile Cache ( ) ; return this ; }
public C Filename Formatter ( final File directory ) { Preconditions . check Argument ( directory . exists ( ) , STRING ) ; m directory = directory ; }
public T pop ( ) { return list . remove Last ( ) ; }
public static String make Log Tag ( Class cls ) { return make Log Tag ( cls . get Simple Name ( ) ) ; }
public Timestamp recalculate Estimated Completion Date ( Long priority , Timestamp start Date ) { if ( exist ( ) ) { get Production Run Routing Tasks ( ) ; if ( quantity == null ) get Quantity ( ) ; Timestamp end Date = null ; for ( Iterator < Generic Value > iter = production Run Routing Tasks . iterator ( ) ; iter . has Next ( ) ; ) { Generic Value routing Task = iter . next ( ) ; if ( priority . compare To ( routing Task . get Long ( STRING ) ) <= NUM ) { long total Time = Production Run . get Estimated Task Time ( routing Task , quantity , dispatcher ) ; end Date = Tech Data Services . add Forward ( Tech Data Services . get Tech Data Calendar ( routing Task ) , start Date , total Time ) ; routing Task . set ( STRING , start Date ) ; routing Task . set ( STRING , end Date ) ; start Date = end Date ; } } return end Date ; } else { return null ; } }
protected Shopping Cart Item ( ) { }
public static String node List To String ( List < ? extends Node > list ) { String Buffer buf = new String Buffer ( ) ; buf . append ( STRING ) ; if ( list . size ( ) > NUM ) { buf . append ( STRING + dom To String ( list . get ( NUM ) ) + STRING ) ; for ( int i = NUM ; i < list . size ( ) ; ++ i ) { buf . append ( STRING + i + STRING + dom To String ( list . get ( NUM ) ) + STRING ) ; } buf . append ( STRING ) ; } buf . append ( STRING ) ; return buf . to String ( ) ; }
protected Element adapt ( Element source , Element Metadata < ? , ? > source Meta , String kind ) { Element Key < ? , ? > adaptor Key = source Meta . adapt ( kind ) ; if ( adaptor Key != null ) { try { return adapt ( adaptor Key , source ) ; } catch ( Content Creation Exception e ) { LOGGER . log ( Level . SEVERE , STRING + source . get Class ( ) + STRING + adaptor Key . get Element Type ( ) , e ) ; } } return source ; }
public String convert Alias To Number ( String alias Name ) { if ( ! alias Name . contains ( STRING ) && Alias Database . contains Alias ( alias Name ) ) { String [ ] res = Alias Database . get Alias ( alias Name ) ; return res [ NUM ] ; } return alias Name ; }
public Attr ( String name , @ Nullable Format format ) { this . name = name ; if ( format != null ) { formats = Collections . singleton List ( format ) ; } }
static Stream Tokenizer make Tokenizer ( String tag Value ) { Stream Tokenizer tokenizer = new Stream Tokenizer ( new String Reader ( tag Value ) ) ; tokenizer . reset Syntax ( ) ; tokenizer . word Chars ( STRING , STRING ) ; tokenizer . word Chars ( STRING , STRING ) ; tokenizer . word Chars ( STRING , STRING ) ; tokenizer . word Chars ( STRING , STRING ) ; tokenizer . word Chars ( STRING , STRING ) ; tokenizer . word Chars ( STRING , STRING ) ; tokenizer . word Chars ( STRING , STRING ) ; tokenizer . word Chars ( STRING , STRING ) ; tokenizer . quote Char ( STRING ) ; tokenizer . quote Char ( STRING ) ; tokenizer . whitespace Chars ( STRING , STRING ) ; tokenizer . whitespace Chars ( STRING , STRING ) ; tokenizer . whitespace Chars ( STRING , STRING ) ; tokenizer . whitespace Chars ( STRING , STRING ) ; tokenizer . eol Is Significant ( BOOL ) ; return tokenizer ; }
private void send Request ( ) { int i = tab Pane . get Selected Index ( ) ; String prompt = rb . get String ( STRING + i + STRING ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + prompt + STRING + i ) ; } if ( source == null ) { log . error ( STRING ) ; timer . stop ( ) ; return ; } source . send Bytes ( prompt . get Bytes ( ) ) ; }
public void remove ( Predicate filter ) { for ( Int Iterator ii = rows ( filter ) ; ii . has Next ( ) ; ) remove Row ( ii . next Int ( ) ) ; }
private void calculate Trim Area ( Rect bounds ) { float size = Math . min ( bounds . height ( ) , bounds . width ( ) ) ; float y Offset = ( bounds . height ( ) - size ) / NUM ; float x Offset = ( bounds . width ( ) - size ) / NUM ; float padding = m Padding + ( bounds . height ( ) - NUM * m Padding ) * NUM / NUM ; m Internal Bounds . set ( bounds . left + padding + x Offset , bounds . top + padding + y Offset , bounds . right - padding - x Offset , bounds . bottom - padding - y Offset ) ; m Center = m Internal Bounds . center X ( ) ; m Size = m Internal Bounds . width ( ) ; m Play Tip Offset = NUM / NUM * m Size ; m Play Base Offset = NUM * m Size ; set Transition State ( NUM , NUM ) ; }
protected void init Instances ( Operation post , Service Document ... states ) { init Instances ( post , BOOL , BOOL , states ) ; }
protected Instance merge Instances ( Instance source , Instance dest ) { Instances output Format = output Format Peek ( ) ; double [ ] vals = new double [ output Format . num Attributes ( ) ] ; for ( int i = NUM ; i < vals . length ; i ++ ) { if ( ( i != output Format . class Index ( ) ) && ( m Selected Cols . is In Range ( i ) ) ) { if ( ( source != null ) && ! source . is Missing ( i ) && ! dest . is Missing ( i ) ) { vals [ i ] = dest . value ( i ) - source . value ( i ) ; } else { vals [ i ] = Utils . missing Value ( ) ; } } else { vals [ i ] = dest . value ( i ) ; } } Instance inst = null ; if ( dest instanceof Sparse Instance ) { inst = new Sparse Instance ( dest . weight ( ) , vals ) ; } else { inst = new Dense Instance ( dest . weight ( ) , vals ) ; } inst . set Dataset ( dest . dataset ( ) ) ; return inst ; }
public Source Call Chain Builder ( int timeout , boolean process callbacks ) { this . timeout = timeout ; this . process callbacks = process callbacks ; }
public synchronized float recovered Bytes Percent ( ) { long total = NUM ; long recovered = NUM ; for ( File file : file Details . values ( ) ) { if ( file . reused ( ) == BOOL ) { total += file . length ( ) ; recovered += file . recovered ( ) ; } } if ( total == NUM && file Details . size ( ) == NUM ) { return NUM ; } if ( total == recovered ) { return NUM ; } else { return NUM * recovered / total ; } }
public < E extends T > Event Binder < E > on ( ) { return new Event Binder < > ( Optional . empty ( ) ) ; }
private boolean is Value Supported ( Object value ) { for ( int i = NUM ; i < values . length ; i ++ ) { if ( value . equals ( values [ i ] ) ) { return BOOL ; } } return BOOL ; }
public static Bit Set from Byte Array ( byte [ ] bytes ) { Bit Set bits = new Bit Set ( ) ; for ( int i = NUM ; i < bytes . length * NUM ; i ++ ) { if ( ( bytes [ bytes . length - i / NUM - NUM ] & ( NUM << ( i % NUM ) ) ) > NUM ) { bits . set ( i ) ; } } return bits ; }
public Repeat Time create Repeat Time ( int repeat Interval , int active Duration , int [ ] offsets ) { Repeat Field repeat Time Field = new Repeat Field ( ) ; try { repeat Time Field . set Repeat Interval ( repeat Interval ) ; repeat Time Field . set Active Duration ( active Duration ) ; repeat Time Field . set Offset Array ( offsets ) ; } catch ( Sdp Exception s ) { s . print Stack Trace ( ) ; } return repeat Time Field ; }
public void remove ( int i ) { if ( ( i >= array . length ) || ( i < NUM ) ) throw new Array Index Out Of Bounds Exception ( STRING + i + STRING + array . length ) ; NS Object [ ] new Array = new NS Object [ array . length - NUM ] ; System . arraycopy ( array , NUM , new Array , NUM , i ) ; System . arraycopy ( array , i + NUM , new Array , i , array . length - i - NUM ) ; array = new Array ; }
private Time parse Time ( String time String ) throws Parse Exception { java . util . Date parsed Date = Time Field . parse ( time String ) ; if ( parsed Date == null ) return null ; return new Time ( parsed Date . get Time ( ) ) ; }
public synchronized void delete Observers ( ) { observers . clear ( ) ; }
private void decrement Copy Field Target Count ( Schema Field dest ) { Integer count = copy Field Target Counts . get ( dest ) ; assert count != null ; if ( count <= NUM ) { copy Field Target Counts . remove ( dest ) ; } else { copy Field Target Counts . put ( dest , count - NUM ) ; } }
public synchronized int update Purchase ( String order Id , String product Id , Purchase State purchase State , long purchase Time , String developer Payload ) { insert Order ( order Id , product Id , purchase State , purchase Time , developer Payload ) ; Cursor cursor = m Db . query ( PURCHASE HISTORY TABLE NAME , HISTORY COLUMNS , HISTORY PRODUCT ID COL + STRING , new String [ ] { product Id } , null , null , null , null ) ; if ( cursor == null ) { return NUM ; } int quantity = NUM ; try { while ( cursor . move To Next ( ) ) { int state Index = cursor . get Int ( NUM ) ; Purchase State state = Purchase State . value Of ( state Index ) ; if ( state == Purchase State . PURCHASED || state == Purchase State . REFUNDED ) { quantity += NUM ; } } update Purchased Item ( product Id , quantity ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } return quantity ; }
public static Calendar from Unix Time ( long unix Time , Time Unit time Unit ) { Calendar calendar = get Calendar Instance ( ) ; calendar . set Time Zone ( Time Zone . get Default ( ) ) ; long millis = time Unit . to Millis ( unix Time ) ; calendar . set Time In Millis ( millis ) ; return calendar ; }
public boolean is Layout Id In Record ( int layout Id ) { return m Layout Ids != null && m Layout Ids . contains ( layout Id ) ; }
private void open board design action ( ) { Design File design file = open dialog ( stat , main options . design dir name ) ; if ( design file == null ) { stat . user Println ( resources . get String ( STRING ) ) ; return ; } String message = resources . get String ( STRING ) + STRING + design file . get name ( ) ; stat . user Println ( message ) ; Board Frame board frame = new Board Frame ( design file , stat ) ; Import Design d import = new Import Design ( board frame ) ; d import . execute ( ) ; }
public static String retrieve Display Name ( String id , boolean daylight , int style , Locale locale ) { String [ ] names = retrieve Display Names Impl ( id , locale ) ; if ( Objects . non Null ( names ) ) { return names [ ( daylight ? NUM : NUM ) - style ] ; } else { return null ; } }
protected Query new Fuzzy Query ( Term term , float minimum Similarity , int prefix Length ) { String text = term . text ( ) ; int num Edits = Fuzzy Query . float To Edits ( minimum Similarity , text . code Point Count ( NUM , text . length ( ) ) ) ; return new Fuzzy Query ( term , num Edits , prefix Length ) ; }
@ Override public void play Video ( Uri uri , String title ) { Camera Activity activity = m Activity . get ( ) ; if ( activity != null ) { Camera Util . play Video ( activity , uri , title ) ; } }
public void copy From ( Path other ) { grow ( other . length - NUM ) ; System . arraycopy ( other . block Id List , NUM , this . block Id List , NUM , other . length ) ; this . length = other . length ; this . cached Hash Code = other . cached Hash Code ; }
void recover Messages ( ) throws Rollback Failed Exception { if ( m is Queue ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING ) ; } unacked Messages . clear ( ) ; if ( ! is Auto Ack ( ) ) { rollback Local Transaction ( ) ; } } else { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING ) ; } unacked Messages . add All ( recover Messages ) ; Linked List < Message Queue Element > temp = unacked Messages ; recover Messages . clear ( ) ; unacked Messages = recover Messages ; recover Messages = temp ; } }
private void maybe Sample Sync Params ( ) { long playback Position Us = audio Track Util . get Playback Head Position Us ( ) ; if ( playback Position Us == NUM ) { return ; } long system Clock Us = System . nano Time ( ) / NUM ; if ( system Clock Us - last Playhead Sample Time Us >= MIN PLAYHEAD OFFSET SAMPLE INTERVAL US ) { playhead Offsets [ next Playhead Offset Index ] = playback Position Us - system Clock Us ; next Playhead Offset Index = ( next Playhead Offset Index + NUM ) % MAX PLAYHEAD OFFSET COUNT ; if ( playhead Offset Count < MAX PLAYHEAD OFFSET COUNT ) { playhead Offset Count ++ ; } last Playhead Sample Time Us = system Clock Us ; smoothed Playhead Offset Us = NUM ; for ( int i = NUM ; i < playhead Offset Count ; i ++ ) { smoothed Playhead Offset Us += playhead Offsets [ i ] / playhead Offset Count ; } } if ( ! is Passthrough ( ) && system Clock Us - last Timestamp Sample Time Us >= MIN TIMESTAMP SAMPLE INTERVAL US ) { audio Timestamp Set = audio Track Util . update Timestamp ( ) ; if ( audio Timestamp Set ) { long audio Timestamp Us = audio Track Util . get Timestamp Nano Time ( ) / NUM ; long audio Timestamp Frame Position = audio Track Util . get Timestamp Frame Position ( ) ; if ( audio Timestamp Us < resume System Time Us ) { audio Timestamp Set = BOOL ; } else if ( Math . abs ( audio Timestamp Us - system Clock Us ) > MAX AUDIO TIMESTAMP OFFSET US ) { String message = STRING + audio Timestamp Frame Position + STRING + audio Timestamp Us + STRING + system Clock Us + STRING + playback Position Us ; if ( fail On Spurious Audio Timestamp ) { throw new Invalid Audio Track Timestamp Exception ( message ) ; } Log . w ( TAG , message ) ; audio Timestamp Set = BOOL ; } else if ( Math . abs ( frames To Duration Us ( audio Timestamp Frame Position ) - playback Position Us ) > MAX AUDIO TIMESTAMP OFFSET US ) { String message = STRING + audio Timestamp Frame Position + STRING + audio Timestamp Us + STRING + system Clock Us + STRING + playback Position Us ; if ( fail On Spurious Audio Timestamp ) { throw new Invalid Audio Track Timestamp Exception ( message ) ; } Log . w ( TAG , message ) ; audio Timestamp Set = BOOL ; } } if ( get Latency Method != null ) { try { latency Us = ( Integer ) get Latency Method . invoke ( audio Track , ( Object [ ] ) null ) * NUM - frames To Duration Us ( bytes To Frames ( buffer Size ) ) ; latency Us = Math . max ( latency Us , NUM ) ; if ( latency Us > MAX LATENCY US ) { Log . w ( TAG , STRING + latency Us ) ; latency Us = NUM ; } } catch ( Exception e ) { get Latency Method = null ; } } last Timestamp Sample Time Us = system Clock Us ; } }
private Map < Key , Array > store ( Class clazz ) { Method [ ] methods = clazz . get Methods ( ) ; Map < Key , Array > methods Map = new Concurrent Hash Map < Key , Array > ( ) ; for ( int i = NUM ; i < methods . length ; i ++ ) { store Method ( methods [ i ] , methods Map ) ; } map . put ( clazz , methods Map ) ; return methods Map ; }
private void read Central Dir ( ) throws IO Exception { long scan Offset = raf . length ( ) - ENDHDR ; if ( scan Offset < NUM ) { throw new Zip Exception ( STRING + raf . length ( ) ) ; } raf . seek ( NUM ) ; final int header Magic = Integer . reverse Bytes ( raf . read Int ( ) ) ; if ( header Magic != LOCSIG ) { throw new Zip Exception ( STRING ) ; } long stop Offset = scan Offset - NUM ; if ( stop Offset < NUM ) { stop Offset = NUM ; } while ( BOOL ) { raf . seek ( scan Offset ) ; if ( Integer . reverse Bytes ( raf . read Int ( ) ) == ENDSIG ) { break ; } scan Offset -- ; if ( scan Offset < stop Offset ) { throw new Zip Exception ( STRING ) ; } } byte [ ] eocd = new byte [ ENDHDR - NUM ] ; raf . read Fully ( eocd ) ; Buffer Iterator it = Heap Buffer Iterator . iterator ( eocd , NUM , eocd . length , Byte Order . LITTLE ENDIAN ) ; int disk Number = it . read Short ( ) & NUM ; int disk With Central Dir = it . read Short ( ) & NUM ; int num Entries = it . read Short ( ) & NUM ; int total Num Entries = it . read Short ( ) & NUM ; it . skip ( NUM ) ; long central Dir Offset = ( ( long ) it . read Int ( ) ) & NUM ; int comment Length = it . read Short ( ) & NUM ; if ( num Entries != total Num Entries || disk Number != NUM || disk With Central Dir != NUM ) { throw new Zip Exception ( STRING ) ; } if ( comment Length > NUM ) { byte [ ] comment Bytes = new byte [ comment Length ] ; raf . read Fully ( comment Bytes ) ; comment = new String ( comment Bytes , NUM , comment Bytes . length , Standard Charsets . UTF 8 ) ; } RAF Stream raf Stream = new RAF Stream ( raf , central Dir Offset ) ; Buffered Input Stream buffered Stream = new Buffered Input Stream ( raf Stream , NUM ) ; byte [ ] hdr Buf = new byte [ CENHDR ] ; for ( int i = NUM ; i < num Entries ; ++ i ) { Zip Entry new Entry = new Zip Entry ( hdr Buf , buffered Stream ) ; if ( new Entry . local Header Rel Offset >= central Dir Offset ) { throw new Zip Exception ( STRING ) ; } String entry Name = new Entry . get Name ( ) ; if ( entries . put ( entry Name , new Entry ) != null ) { throw new Zip Exception ( STRING + entry Name ) ; } } }
protected int read Fully ( Input Stream in , byte buffer [ ] , int offset , int len ) throws IO Exception { for ( int i = NUM ; i < len ; i ++ ) { int q = in . read ( ) ; if ( q == - NUM ) return ( ( i == NUM ) ? - NUM : i ) ; buffer [ i + offset ] = ( byte ) q ; } return len ; }
private long renew Service Lease Do ( Service ID service ID , Uuid lease ID , long renew Duration ) throws Unknown Lease Exception { long now = System . current Time Millis ( ) ; long renew Expiration = renew Service Lease Int ( service ID , lease ID , renew Duration , now ) ; add Log Record ( new Service Lease Renewed Log Obj ( service ID , lease ID , renew Expiration ) ) ; return renew Expiration - now ; }
public Block Swapper ( World world , Entity Player player , Item Stack truncator , Block Pos orig Coords , int range , boolean leaves ) { this . world = world ; this . player = player ; this . truncator = truncator ; this . origin = orig Coords ; this . range = range ; this . treat Leaves Special = leaves ; this . candidate Queue = new Priority Queue < > ( ) ; this . completed Coords = new Hash Set < > ( ) ; candidate Queue . offer ( new Swap Candidate ( this . origin , this . range ) ) ; }
public static String [ ] to String Array ( Enumeration < String > enumeration ) { if ( enumeration == null ) { return null ; } List < String > list = Collections . list ( enumeration ) ; return list . to Array ( new String [ list . size ( ) ] ) ; }
public boolean overlap Save ( Sphere Cluster other ) { double min Dist = Math . sqrt ( NUM ) * ( get Radius ( ) + other . get Radius ( ) ) ; double diff = get Center Distance ( other ) - min Dist ; return diff > NUM ; }
@ PUT @ Consumes ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Path ( STRING ) @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Check Permission ( roles = { Role . SYSTEM ADMIN , Role . RESTRICTED SYSTEM ADMIN } ) public File Virtual Pool Rest Rep update File Virtual Pool With Assigned Pools ( @ Path Param ( STRING ) URI id , Virtual Pool Pool Update Param param ) { Virtual Pool v Pool = update Virtual Pool With Assigned Storage Pools ( id , param ) ; return to File Virtual Pool ( v Pool , Virtual Pool . get File Remote Protection Settings ( v Pool , db Client ) ) ; }
public static java . sql . Date to Sql Date ( int month , int day , int year ) { java . util . Date new Date = to Date ( month , day , year , NUM , NUM , NUM ) ; if ( new Date != null ) { return new java . sql . Date ( new Date . get Time ( ) ) ; } else { return null ; } }
public Object read Default List Model ( Element node ) throws Exception { Default List Model model ; Vector < Element > children ; Element child ; int i ; int index ; int curr Index ; if ( DEBUG ) { trace ( new Throwable ( ) , node . get Attribute ( ATT NAME ) ) ; } m Current Node = node ; children = XML Document . get Child Tags ( node ) ; model = new Default List Model ( ) ; index = children . size ( ) - NUM ; for ( i = NUM ; i < children . size ( ) ; i ++ ) { child = children . get ( i ) ; curr Index = Integer . parse Int ( child . get Attribute ( ATT NAME ) ) ; if ( curr Index > index ) { index = curr Index ; } } model . set Size ( index + NUM ) ; for ( i = NUM ; i < children . size ( ) ; i ++ ) { child = children . get ( i ) ; model . set ( Integer . parse Int ( child . get Attribute ( ATT NAME ) ) , invoke Read From XML ( child ) ) ; } return model ; }
private boolean results Identical ( String named Curve , Big Integer bad X , Big Integer bad Y , Big Integer secret , int iter ) throws Invalid Algorithm Parameter Exception , No Such Algorithm Exception , Invalid Key Spec Exception , Invalid Key Exception { for ( int i = NUM ; i < iter ; i ++ ) { secret = secret . add ( Big Integer . ONE ) ; Big Integer result Custom = compute Secret With Custom Algorithm ( named Curve , bad X , bad Y , secret ) ; Big Integer result Sun = compute Secret With Sun Algorithm ( named Curve , bad X , bad Y , secret ) ; if ( result Sun != null && ! result Sun . equals ( result Custom ) ) { return BOOL ; } } return BOOL ; }
public void enable Layers ( boolean enable ) { Texture State texture State = ( Texture State ) get Local Render State ( Render State . State Type . Texture ) ; texture State . set Enabled ( enable ) ; mark Dirty ( Dirty Type . Render State ) ; }
protected void starve Randomly ( int limit ) { while ( population . size ( ) > limit ) { int remove Pos = Randomness . next Int ( ) % population . size ( ) ; population . remove ( remove Pos ) ; } }
public void save Param ( ) throws Exception { Enumeration < Abstract Param Panel > en = table Panel . elements ( ) ; Abstract Param Panel panel = null ; while ( en . has More Elements ( ) ) { panel = en . next Element ( ) ; panel . save Param ( param Object ) ; } }
@ Suppress Warnings ( STRING ) public static Local Streaming Container wait For Activation ( Stram Local Cluster local Cluster , PT Operator operator ) throws Interrupted Exception { Local Streaming Container container ; long start Millis = System . current Time Millis ( ) ; while ( System . current Time Millis ( ) < ( start Millis + DEFAULT TIMEOUT MILLIS ) ) { if ( operator . get State ( ) == PT Operator . State . ACTIVE ) { if ( ( container = local Cluster . get Container ( operator ) ) != null ) { return container ; } } LOG . debug ( STRING , new Object [ ] { operator , operator . get State ( ) , operator . get Container ( ) } ) ; Thread . sleep ( NUM ) ; } Assert . fail ( STRING + operator ) ; return null ; }
private float interpolate ( ) { long curr Time = System . current Time Millis ( ) ; float elapsed = ( curr Time - start Time ) / ZOOM TIME ; elapsed = Math . min ( NUM , elapsed ) ; return interpolator . get Interpolation ( elapsed ) ; }
protected String to External Form ( URL url ) { return to External Form ( url , BOOL ) ; }
public Result Set execute Query ( String query ) throws SQL Exception , No Connection Exception { if ( connection != null ) { Statement st = connection . create Statement ( ) ; return st . execute Query ( query ) ; } throw new No Connection Exception ( ) ; }
private void reject Access And Terminate Process ( Radius Response response , Context Holder holder ) { response . set Response Packet ( new Access Reject ( ) ) ; response . set Universal Id ( holder . get Universal Id ( ) ) ; terminate Authn Process ( holder ) ; }
public Sc Volume create View Volume ( String name , String instance Id ) throws Storage Center API Exception { LOG . debug ( STRING , instance Id ) ; String error Message = STRING ; Parameters params = new Parameters ( ) ; params . add ( STRING , name ) ; params . add ( STRING , NOTES STRING ) ; try { Rest Result result = rest Client . post ( String . format ( STRING , instance Id ) , params . to Json ( ) ) ; if ( check Results ( result ) ) { return gson . from Json ( result . get Result ( ) , Sc Volume . class ) ; } } catch ( Exception e ) { error Message = String . format ( STRING , e ) ; LOG . warn ( error Message ) ; } if ( error Message . length ( ) == NUM ) { error Message = String . format ( STRING , name , instance Id ) ; } throw new Storage Center API Exception ( error Message ) ; }
@ Override public boolean contains ( Object object ) { return index Of ( object , NUM ) != - NUM ; }
public void sync ( ) throws Storage Fault { final String method Name = STRING ; log . debug ( method Name + STRING ) ; try { log . trace ( method Name + STRING ) ; sync Manager . sync All ( ) ; } catch ( SOS Failure e ) { log . error ( method Name + STRING , e ) ; throw Fault Util . Storage Fault ( e ) ; } log . debug ( method Name + STRING ) ; }
private void add Menu Item ( J Popup Menu menu , String title , MWF Node Next line ) { WF Popup Item item = new WF Popup Item ( title , line ) ; menu . add ( item ) ; item . add Action Listener ( this ) ; }
public static Matcher < Binding Set > binds ( String name , Class < ? > value ) { return new Binds Matcher < Object > ( name , instance Of ( value ) ) ; }
private void test Add ( ) throws Exception { LOG . info ( STRING ) ; long msg Count = message Mapper . count Messages In Mailbox ( MBOXES . get ( NUM ) ) ; LOG . info ( msg Count + STRING + MESSAGE NO . size ( ) ) ; assert Equals ( MESSAGE NO . size ( ) , msg Count ) ; }
public void cancel Task No Exception ( Task task ) { try { cancel Task ( task ) ; } catch ( Exception e ) { log . error ( STRING ) ; } }
public boolean is Layout Id In Record ( int layout Id ) { return m Layout Ids != null && m Layout Ids . contains ( layout Id ) ; }
public String to String ( ) { return to Indented String ( NUM ) ; }
public int read ( byte b [ ] , int off , int len ) throws IO Exception , Log Exception { if ( length < len ) bad Read ( len ) ; len = in . read ( b , off , len ) ; length -= len ; return len ; }
public static void migrate From 6 To 7 ( SQ Lite Database db ) { String select Query = STRING + Database Helper . TABLE GRIDITEMRELATIONS ; Cursor c = db . raw Query ( select Query , null ) ; if ( c . move To First ( ) ) { do { try { int grid Itemid = c . get Int ( c . get Column Index ( Database Helper . KEY ID ) ) ; int plugin Id = c . get Int ( c . get Column Index ( Database Helper . KEY GRIDITEMRELATIONS PLUGIN ) ) ; String pluginpage Url Query = STRING + Database Helper . KEY MUNINPLUGINS PLUGINPAGEURL + STRING + Database Helper . TABLE MUNINPLUGINS + STRING + Database Helper . KEY ID + STRING + plugin Id ; Cursor c2 = db . raw Query ( pluginpage Url Query , null ) ; if ( c2 . move To First ( ) ) { String pluginpage Url = c2 . get String ( c2 . get Column Index ( Database Helper . KEY MUNINPLUGINS PLUGINPAGEURL ) ) ; Content Values values = new Content Values ( ) ; values . put ( Database Helper . KEY GRIDITEMRELATIONS PLUGINPAGEURL , pluginpage Url ) ; db . update ( Database Helper . TABLE GRIDITEMRELATIONS , values , Database Helper . KEY ID + STRING , new String [ ] { String . value Of ( grid Itemid ) } ) ; } c2 . close ( ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; } } while ( c . move To Next ( ) ) ; } c . close ( ) ; }
public static Input Stream crop Image ( Input Stream input Stream , int image Width , int image Height , int out Width , int out Height ) throws Illegal Argument Exception { if ( input Stream == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( image Width <= NUM || image Height <= NUM ) { throw new Illegal Argument Exception ( String . format ( STRING + STRING , image Width , image Height ) ) ; } if ( out Width <= NUM || out Height <= NUM ) { throw new Illegal Argument Exception ( String . format ( STRING + STRING , image Width , out Height ) ) ; } int scale Down Sample Size = Math . min ( image Width / out Width , image Height / out Height ) ; if ( scale Down Sample Size > NUM ) { image Width /= scale Down Sample Size ; image Height /= scale Down Sample Size ; } else { float ratio = ( float ) out Width / out Height ; if ( image Width < image Height * ratio ) { out Width = image Width ; out Height = ( int ) ( out Width / ratio ) ; } else { out Height = image Height ; out Width = ( int ) ( out Height * ratio ) ; } } int left = ( image Width - out Width ) / NUM ; int top = ( image Height - out Height ) / NUM ; Input Stream compressed = null ; try { Bitmap Factory . Options options = new Bitmap Factory . Options ( ) ; if ( scale Down Sample Size > NUM ) { options . in Sample Size = scale Down Sample Size ; } Bitmap bitmap = Bitmap Factory . decode Stream ( input Stream , null , options ) ; if ( bitmap == null ) { return null ; } Bitmap cropped = Bitmap . create Bitmap ( bitmap , left , top , out Width , out Height ) ; Byte Array Output Stream tmp Out = new Byte Array Output Stream ( NUM ) ; if ( cropped . compress ( Bitmap . Compress Format . PNG , DEFAULT IMG QUALITY , tmp Out ) ) { byte [ ] out Byte Array = tmp Out . to Byte Array ( ) ; compressed = new Byte Array Input Stream ( out Byte Array ) ; } } catch ( Exception e ) { Log . e ( TAG , STRING + e ) ; } return compressed ; }
@ Override public void dataset Changed ( Dataset Change Event event ) { fire Dataset Changed ( ) ; }
public void drawing Complete ( OM Graphic omg , OM Action action ) { if ( timer Button . is Selected ( ) ) { timer . restart ( ) ; } if ( omg instanceof OM Point ) { OM Point p = ( OM Point ) omg ; GL Point mp = new GL Point ( p . get Lat ( ) , p . get Lon ( ) , p . get Radius ( ) , BOOL ) ; mp . set Name ( STRING + ( point Count ++ ) ) ; mp . set Stationary ( BOOL ) ; mp . show Palette ( ) ; points . put ( mp . get Name ( ) , mp ) ; manage Graphics ( ) ; } else if ( omg instanceof OM Poly ) { OM Poly poly = ( OM Poly ) omg ; Path GL Point pmp = new Path GL Point ( poly , NUM , BOOL ) ; pmp . set Name ( STRING + ( point Count ++ ) ) ; pmp . show Palette ( ) ; points . put ( pmp . get Name ( ) , pmp ) ; manage Graphics ( ) ; } add Node Button . set Enabled ( BOOL ) ; add Path Button . set Enabled ( BOOL ) ; }
public static String hash Key For Disk ( String key ) { String cache Key ; try { final Message Digest m Digest = Message Digest . get Instance ( STRING ) ; m Digest . update ( key . get Bytes ( ) ) ; cache Key = bytes To Hex String ( m Digest . digest ( ) ) ; } catch ( No Such Algorithm Exception e ) { cache Key = String . value Of ( key . hash Code ( ) ) ; } return cache Key ; }
static int first Illegal Character ( String source ) { for ( int i = NUM ; i < source . length ( ) ; i ++ ) { if ( is Legal ( source . char At ( i ) ) == BOOL ) { return i ; } } return - NUM ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return COOKIE ; case NUM : return USER ID ; default : return null ; } }
public Charset charset ( ) { return charset != null ? Charset . for Name ( charset ) : null ; }
public Driver Task delete Volume Mirror ( Volume Mirror mirror ) { LOG . info ( STRING , mirror ) ; Dell SC Driver Task task = new Dell SC Driver Task ( STRING ) ; try { Storage Center API api = connection Manager . get Connection ( mirror . get Storage System Id ( ) ) ; Sc Copy Mirror Migrate cmm = api . get Mirror ( mirror . get Native Id ( ) ) ; api . delete Mirror ( cmm . instance Id ) ; api . delete Volume ( cmm . destination Volume . instance Id ) ; task . set Status ( Task Status . READY ) ; } catch ( Storage Center API Exception | Dell SC Driver Exception dex ) { String error = String . format ( STRING , mirror . get Native Id ( ) , dex ) ; LOG . error ( error ) ; task . set Failed ( error ) ; } return task ; }
public void test Connect Block No Server ( ) throws IO Exception { connect Without Server ( ) ; disconnect After Connected ( ) ; }
public Byte Array Data Provider ( byte [ ] bytes ) { this . bytes = Arrays . copy Of ( bytes , bytes . length ) ; }
public static String generate Native Guid For Physical NAS ( String system Native Guid , String p Nas Name ) { return String . format ( STRING + PHYSICAL NAS + STRING , system Native Guid , p Nas Name ) ; }
private void expire ( ) { if ( m expire != NUM && m time Exp < System . current Time Millis ( ) ) { reset ( ) ; } }
private static int determine Consecutive Binary Count ( String msg , int startpos , Charset encoding ) throws Writer Exception { final Charset Encoder encoder = encoding . new Encoder ( ) ; int len = msg . length ( ) ; int idx = startpos ; while ( idx < len ) { char ch = msg . char At ( idx ) ; int numeric Count = NUM ; while ( numeric Count < NUM && is Digit ( ch ) ) { numeric Count ++ ; int i = idx + numeric Count ; if ( i >= len ) { break ; } ch = msg . char At ( i ) ; } if ( numeric Count >= NUM ) { return idx - startpos ; } ch = msg . char At ( idx ) ; if ( ! encoder . can Encode ( ch ) ) { throw new Writer Exception ( STRING + ch + STRING + ( int ) ch + STRING ) ; } idx ++ ; } return idx - startpos ; }
public void remove Swipe Listener ( Swipe Listener listener ) { if ( m Listeners == null ) { return ; } m Listeners . remove ( listener ) ; }
private boolean apply ( Grid Client Predicate < N > [ ] p , N n ) { if ( p != null ) { for ( Grid Client Predicate < ? super N > r : p ) { if ( r != null && ! r . apply ( n ) ) return BOOL ; } } return BOOL ; }
public boolean has Name ( final String name ) { for ( final String n : names ) { if ( n . equals Ignore Case ( name ) ) { return BOOL ; } } return BOOL ; }
static Method Handle make Spread Arguments ( Method Handle target , Class < ? > spread Arg Type , int spread Arg Pos , int spread Arg Count ) { Method Type target Type = target . type ( ) ; for ( int i = NUM ; i < spread Arg Count ; i ++ ) { Class < ? > arg = Verify Type . spread Arg Element Type ( spread Arg Type , i ) ; if ( arg == null ) arg = Object . class ; target Type = target Type . change Parameter Type ( spread Arg Pos + i , arg ) ; } target = target . as Type ( target Type ) ; Method Type src Type = target Type . replace Parameter Types ( spread Arg Pos , spread Arg Pos + spread Arg Count , spread Arg Type ) ; Method Type lambda Type = src Type . invoker Type ( ) ; Name [ ] names = arguments ( spread Arg Count + NUM , lambda Type ) ; int name Cursor = lambda Type . parameter Count ( ) ; int [ ] indexes = new int [ target Type . parameter Count ( ) ] ; for ( int i = NUM , arg Index = NUM ; i < target Type . parameter Count ( ) + NUM ; i ++ , arg Index ++ ) { Class < ? > src = lambda Type . parameter Type ( i ) ; if ( i == spread Arg Pos ) { Method Handle aload = Method Handles . array Element Getter ( spread Arg Type ) ; Name array = names [ arg Index ] ; names [ name Cursor ++ ] = new Name ( Lazy . NF check Spread Argument , array , spread Arg Count ) ; for ( int j = NUM ; j < spread Arg Count ; i ++ , j ++ ) { indexes [ i ] = name Cursor ; names [ name Cursor ++ ] = new Name ( aload , array , j ) ; } } else if ( i < indexes . length ) { indexes [ i ] = arg Index ; } } assert ( name Cursor == names . length - NUM ) ; Name [ ] target Args = new Name [ target Type . parameter Count ( ) ] ; for ( int i = NUM ; i < target Type . parameter Count ( ) ; i ++ ) { int idx = indexes [ i ] ; target Args [ i ] = names [ idx ] ; } names [ names . length - NUM ] = new Name ( target , ( Object [ ] ) target Args ) ; Lambda Form form = new Lambda Form ( STRING , lambda Type . parameter Count ( ) , names ) ; return Simple Method Handle . make ( src Type , form ) ; }
public void dup 2 X 2 ( ) { mv . visit Insn ( Opcodes . DUP 2 X2 ) ; }
@ Override public boolean contains ( Object key ) { if ( key == null ) return map . null Value != null ; K1 [ ] keys = map . keys ; for ( int i = keys . length - NUM ; i >= NUM ; i -- ) { K1 test Key = keys [ i ] ; if ( key . equals ( test Key ) ) return BOOL ; } return BOOL ; }
public Expression compile ( int op Pos ) throws Transformer Exception { int op = get Op ( op Pos ) ; Expression expr = null ; switch ( op ) { case Op Codes . OP XPATH : expr = compile ( op Pos + NUM ) ; break ; case Op Codes . OP OR : expr = or ( op Pos ) ; break ; case Op Codes . OP AND : expr = and ( op Pos ) ; break ; case Op Codes . OP NOTEQUALS : expr = notequals ( op Pos ) ; break ; case Op Codes . OP EQUALS : expr = equals ( op Pos ) ; break ; case Op Codes . OP LTE : expr = lte ( op Pos ) ; break ; case Op Codes . OP LT : expr = lt ( op Pos ) ; break ; case Op Codes . OP GTE : expr = gte ( op Pos ) ; break ; case Op Codes . OP GT : expr = gt ( op Pos ) ; break ; case Op Codes . OP PLUS : expr = plus ( op Pos ) ; break ; case Op Codes . OP MINUS : expr = minus ( op Pos ) ; break ; case Op Codes . OP MULT : expr = mult ( op Pos ) ; break ; case Op Codes . OP DIV : expr = div ( op Pos ) ; break ; case Op Codes . OP MOD : expr = mod ( op Pos ) ; break ; case Op Codes . OP NEG : expr = neg ( op Pos ) ; break ; case Op Codes . OP STRING : expr = string ( op Pos ) ; break ; case Op Codes . OP BOOL : expr = bool ( op Pos ) ; break ; case Op Codes . OP NUMBER : expr = number ( op Pos ) ; break ; case Op Codes . OP UNION : expr = union ( op Pos ) ; break ; case Op Codes . OP LITERAL : expr = literal ( op Pos ) ; break ; case Op Codes . OP VARIABLE : expr = variable ( op Pos ) ; break ; case Op Codes . OP GROUP : expr = group ( op Pos ) ; break ; case Op Codes . OP NUMBERLIT : expr = numberlit ( op Pos ) ; break ; case Op Codes . OP ARGUMENT : expr = arg ( op Pos ) ; break ; case Op Codes . OP EXTFUNCTION : expr = compile Extension ( op Pos ) ; break ; case Op Codes . OP FUNCTION : expr = compile Function ( op Pos ) ; break ; case Op Codes . OP LOCATIONPATH : expr = location Path ( op Pos ) ; break ; case Op Codes . OP PREDICATE : expr = null ; break ; case Op Codes . OP MATCHPATTERN : expr = match Pattern ( op Pos + NUM ) ; break ; case Op Codes . OP LOCATIONPATHPATTERN : expr = location Path Pattern ( op Pos ) ; break ; case Op Codes . OP QUO : error ( XPATH Error Resources . ER UNKNOWN OPCODE , new Object [ ] { STRING } ) ; break ; default : error ( XPATH Error Resources . ER UNKNOWN OPCODE , new Object [ ] { Integer . to String ( get Op ( op Pos ) ) } ) ; } return expr ; }
public static void replace Value ( Example Set example Set , Attribute attribute , String old Value , String new Value ) { if ( ! attribute . is Nominal ( ) ) { throw new Runtime Exception ( STRING ) ; } Nominal Mapping mapping = attribute . get Mapping ( ) ; if ( old Value . equals ( STRING ) ) { for ( Example example : example Set ) { if ( Double . is Na N ( example . get Value ( attribute ) ) ) { example . set Value ( attribute , mapping . map String ( new Value ) ) ; } } } else { int old Index = mapping . get Index ( old Value ) ; if ( old Index < NUM ) { throw new Runtime Exception ( STRING ) ; } if ( new Value . equals ( STRING ) ) { for ( Example example : example Set ) { int index = mapping . get Index ( example . get Value As String ( attribute ) ) ; if ( index == old Index ) { example . set Value ( attribute , Double . Na N ) ; } } return ; } int new Index = mapping . get Index ( new Value ) ; if ( new Index >= NUM ) { for ( Example example : example Set ) { int index = mapping . get Index ( example . get Value As String ( attribute ) ) ; if ( index == old Index ) { example . set Value ( attribute , new Index ) ; } } } else { mapping . set Mapping ( new Value , old Index ) ; } } }
protected void encode ( Byte Sequences Writer writer , Byte Array Data Output output , byte [ ] buffer , Bytes Ref spare , Bytes Ref payload , Set < Bytes Ref > contexts , long weight ) throws IO Exception { int required Length = spare . length + NUM + ( ( has Payloads ) ? NUM + payload . length : NUM ) ; if ( has Contexts ) { for ( Bytes Ref ctx : contexts ) { required Length += NUM + ctx . length ; } required Length += NUM ; } if ( required Length >= buffer . length ) { buffer = Array Util . grow ( buffer , required Length ) ; } output . reset ( buffer ) ; output . write Bytes ( spare . bytes , spare . offset , spare . length ) ; if ( has Contexts ) { for ( Bytes Ref ctx : contexts ) { output . write Bytes ( ctx . bytes , ctx . offset , ctx . length ) ; output . write Short ( ( short ) ctx . length ) ; } output . write Short ( ( short ) contexts . size ( ) ) ; } if ( has Payloads ) { output . write Bytes ( payload . bytes , payload . offset , payload . length ) ; output . write Short ( ( short ) payload . length ) ; } output . write Long ( weight ) ; writer . write ( buffer , NUM , output . get Position ( ) ) ; }
public void print Entry Details ( Writer w ) { int linesadded = - NUM ; String title ; try { Hardcopy Writer ww = ( Hardcopy Writer ) w ; int text Space = ww . get Characters Per Line ( ) - indent Width - NUM ; title = STRING ; if ( ( text Space With Icon != NUM ) && ( linesadded < blanks ) ) { linesadded = write Wrapped Comment ( w , id , title , text Space With Icon ) + linesadded ; } else { linesadded = write Wrapped Comment ( w , id , title , text Space ) + linesadded ; } title = STRING ; if ( ( text Space With Icon != NUM ) && ( linesadded < blanks ) ) { linesadded = write Wrapped Comment ( w , file Name != null ? file Name : STRING , title , text Space With Icon ) + linesadded ; } else { linesadded = write Wrapped Comment ( w , file Name != null ? file Name : STRING , title , text Space ) + linesadded ; } if ( ! ( road Name . is Empty ( ) ) ) { title = STRING ; if ( ( text Space With Icon != NUM ) && ( linesadded < blanks ) ) { linesadded = write Wrapped Comment ( w , road Name , title , text Space With Icon ) + linesadded ; } else { linesadded = write Wrapped Comment ( w , road Name , title , text Space ) + linesadded ; } } if ( ! ( road Number . is Empty ( ) ) ) { title = STRING ; if ( ( text Space With Icon != NUM ) && ( linesadded < blanks ) ) { linesadded = write Wrapped Comment ( w , road Number , title , text Space With Icon ) + linesadded ; } else { linesadded = write Wrapped Comment ( w , road Number , title , text Space ) + linesadded ; } } if ( ! ( mfg . is Empty ( ) ) ) { title = STRING ; if ( ( text Space With Icon != NUM ) && ( linesadded < blanks ) ) { linesadded = write Wrapped Comment ( w , mfg , title , text Space With Icon ) + linesadded ; } else { linesadded = write Wrapped Comment ( w , mfg , title , text Space ) + linesadded ; } } if ( ! ( owner . is Empty ( ) ) ) { title = STRING ; if ( ( text Space With Icon != NUM ) && ( linesadded < blanks ) ) { linesadded = write Wrapped Comment ( w , owner , title , text Space With Icon ) + linesadded ; } else { linesadded = write Wrapped Comment ( w , owner , title , text Space ) + linesadded ; } } if ( ! ( model . is Empty ( ) ) ) { title = STRING ; if ( ( text Space With Icon != NUM ) && ( linesadded < blanks ) ) { linesadded = write Wrapped Comment ( w , model , title , text Space With Icon ) + linesadded ; } else { linesadded = write Wrapped Comment ( w , model , title , text Space ) + linesadded ; } } if ( ! ( dcc Address . is Empty ( ) ) ) { w . write ( new Line , NUM , NUM ) ; String s = STRING + dcc Address ; w . write ( s , NUM , s . length ( ) ) ; linesadded ++ ; } if ( ! ( comment . is Empty ( ) ) ) { for ( int i = NUM ; i < ( blanks - linesadded ) ; i ++ ) { w . write ( new Line , NUM , NUM ) ; } if ( blanks != NUM ) { blanks = NUM ; } title = STRING ; linesadded = write Wrapped Comment ( w , comment , title , text Space ) + linesadded ; } if ( ! ( decoder Model . is Empty ( ) ) ) { title = STRING ; if ( ( text Space With Icon != NUM ) && ( linesadded < blanks ) ) { linesadded = write Wrapped Comment ( w , decoder Model , title , text Space With Icon ) + linesadded ; } else { linesadded = write Wrapped Comment ( w , decoder Model , title , text Space ) + linesadded ; } } if ( ! ( decoder Family . is Empty ( ) ) ) { title = STRING ; if ( ( text Space With Icon != NUM ) && ( linesadded < blanks ) ) { linesadded = write Wrapped Comment ( w , decoder Family , title , text Space With Icon ) + linesadded ; } else { linesadded = write Wrapped Comment ( w , decoder Family , title , text Space ) + linesadded ; } } if ( ! ( decoder Comment . is Empty ( ) ) ) { for ( int i = NUM ; i < ( blanks - linesadded ) ; i ++ ) { w . write ( new Line , NUM , NUM ) ; } if ( blanks != NUM ) { blanks = NUM ; } title = STRING ; linesadded = write Wrapped Comment ( w , decoder Comment , title , text Space ) + linesadded ; } w . write ( new Line , NUM , NUM ) ; for ( int i = - NUM ; i < ( blanks - linesadded ) ; i ++ ) { w . write ( new Line , NUM , NUM ) ; } } catch ( IO Exception e ) { log . error ( STRING + e ) ; } }
private int skip Quoted String ( String str , int pos ) { int n = str . length ( ) ; pos += NUM ; while ( pos < n ) { if ( str . char At ( pos ) == STRING ) { if ( pos + NUM < n && str . char At ( pos + NUM ) == STRING ) { pos += NUM ; continue ; } return pos + NUM ; } pos += NUM ; } return n ; }
private static void add New Segment ( Linked List < DNA Segment > segments , Event event , Hash Map < Integer , DNA Strand > strands , int first Julian Day , int min Start , int min Minutes ) { if ( event . start Day > event . end Day ) { Log . wtf ( TAG , STRING + event . to String ( ) ) ; } if ( event . start Day != event . end Day ) { Event lhs = new Event ( ) ; lhs . color = event . color ; lhs . start Day = event . start Day ; lhs . start Time = event . start Time ; lhs . end Day = lhs . start Day ; lhs . end Time = DAY IN MINUTES - NUM ; while ( lhs . start Day != event . end Day ) { add New Segment ( segments , lhs , strands , first Julian Day , min Start , min Minutes ) ; lhs . start Day ++ ; lhs . end Day = lhs . start Day ; lhs . start Time = NUM ; min Start = NUM ; } lhs . end Time = event . end Time ; event = lhs ; } DNA Segment segment = new DNA Segment ( ) ; int day Offset = ( event . start Day - first Julian Day ) * DAY IN MINUTES ; int end Of Day = day Offset + DAY IN MINUTES - NUM ; segment . start Minute = Math . max ( day Offset + event . start Time , min Start ) ; int min End = Math . min ( segment . start Minute + min Minutes , end Of Day ) ; segment . end Minute = Math . max ( day Offset + event . end Time , min End ) ; if ( segment . end Minute > end Of Day ) { segment . end Minute = end Of Day ; } segment . color = event . color ; segment . day = event . start Day ; segments . add ( segment ) ; DNA Strand strand = get Or Create Strand ( strands , segment . color ) ; strand . count ++ ; }
private Datagram Packet [ ] encode Multicast Request ( final Multicast Request req ) throws IO Exception { final Discovery disco = get Discovery ( multicast Request Constraints . choose Protocol Version ( ) ) ; final List packets = new Array List ( ) ; Encode Iterator ei = disco . encode Multicast Request ( req , multicast Request Constraints . get Multicast Max Packet Size ( DEFAULT MAX PACKET SIZE ) , multicast Request Constraints . get Unfulfilled Constraints ( ) ) ; while ( ei . has Next ( ) ) { try { packets . add All ( Arrays . as List ( ei . next ( ) ) ) ; } catch ( Exception e ) { logger . log ( ( e instanceof Unsupported Constraint Exception ) ? Levels . HANDLED : Level . INFO , STRING , e ) ; } } if ( packets . is Empty ( ) ) { throw new Discovery Protocol Exception ( STRING ) ; } return ( Datagram Packet [ ] ) packets . to Array ( new Datagram Packet [ packets . size ( ) ] ) ; }
public Feature Type Constraint Model ( Feature Type Constraint Model Update Interface parent ) { this . parent Obj = parent ; column List . add ( Localisation . get String ( Field Config Base . class , STRING ) ) ; column List . add ( Localisation . get String ( Field Config Base . class , STRING ) ) ; }
protected void delete Db ( String name ) { delete Db ( get Base Dir ( ) , name ) ; }
public void remove At Range ( int index , int size ) { final int end = Math . min ( m Size , index + size ) ; for ( int i = index ; i < end ; i ++ ) { remove At ( i ) ; } }
private void pull Event ( ) { final int new Scroll Value ; final int item Dimension ; final float initial Motion Value , last Motion Value ; switch ( get Filtered Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : initial Motion Value = m Initial Motion X ; last Motion Value = m Last Motion X ; break ; case VERTICAL : default : initial Motion Value = m Initial Motion Y ; last Motion Value = m Last Motion Y ; break ; } switch ( m Current Mode ) { case PULL FROM END : new Scroll Value = Math . round ( Math . max ( initial Motion Value - last Motion Value , NUM ) / m Friction ) ; item Dimension = get Footer Size ( ) ; break ; case GOOGLE STYLE : new Scroll Value = Math . round ( Math . min ( initial Motion Value - last Motion Value , NUM ) / m Friction ) ; item Dimension = get Google Style View Size ( ) ; break ; case PULL FROM START : default : new Scroll Value = Math . round ( Math . min ( initial Motion Value - last Motion Value , NUM ) / m Friction ) ; item Dimension = get Header Size ( ) ; break ; } set Header Scroll ( new Scroll Value ) ; if ( new Scroll Value != NUM && ! is Refreshing ( ) ) { float scale = Math . abs ( new Scroll Value ) / ( float ) item Dimension ; switch ( m Current Mode ) { case PULL FROM END : m Footer Layout . on Pull ( scale ) ; break ; case GOOGLE STYLE : m Google Style View Layout . on Pull ( scale ) ; m Google Style Progress Layout . on Pull ( scale ) ; break ; case PULL FROM START : default : m Header Layout . on Pull ( scale ) ; break ; } if ( m State != State . PULL TO REFRESH && item Dimension >= Math . abs ( new Scroll Value ) ) { set State ( State . PULL TO REFRESH ) ; } else if ( m State == State . PULL TO REFRESH && item Dimension < Math . abs ( new Scroll Value ) ) { set State ( State . RELEASE TO REFRESH ) ; } } }
public Stat Monitor Handler ( ) { }
public void add Elements ( final double [ ] values ) { final double [ ] temp Array = new double [ num Elements + values . length + NUM ] ; System . arraycopy ( internal Array , start Index , temp Array , NUM , num Elements ) ; System . arraycopy ( values , NUM , temp Array , num Elements , values . length ) ; internal Array = temp Array ; start Index = NUM ; num Elements += values . length ; }
public void register Unregistered Namespaces ( ) { for ( int i = NUM ; i < m unregistered Extensions . size ( ) ; i ++ ) { String ns = ( String ) m unregistered Extensions . get ( i ) ; Extension Namespace Support ext Ns Spt = define Java Namespace ( ns ) ; if ( ext Ns Spt != null ) m extensions . add ( ext Ns Spt ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public Map < URI , List < URI > > add Source Volume Snapshots ( ) { List < URI > block Snapshots = Lists . new Array List ( ) ; Map < URI , List < URI > > snapshots Map = new Hash Map < > ( ) ; for ( URI volume Id : uris ( volume Ids ) ) { List < URI > snapshots = get Snapshots ( volume Id ) ; block Snapshots . add All ( snapshots ) ; snapshots Map . put ( volume Id , snapshots ) ; } if ( ! block Snapshots . is Empty ( ) ) { Block Storage Utils . add Volumes To Consistency Group ( consistency Group , block Snapshots ) ; } return snapshots Map ; }
public static void log Initiator ( Initiator initiator , Network Lite network ) { String network Name = ( network != null ? network . get Label ( ) : STRING ) ; log . info ( String . format ( STRING , initiator . get Initiator Port ( ) , initiator . get Host Name ( ) , network Name ) ) ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
public static final Criterion and ( Criterion one , Criterion two ) { final List < Criterion > criteria = new Array List < Criterion > ( ) ; criteria . add ( one ) ; criteria . add ( two ) ; return new Conjunction Criterion ( Conjunction . AND , criteria ) ; }
public CC Menu Item ( Object rec , String cb ) { target Callback = rec ; selector = cb ; set Anchor Point ( CG Point . make ( NUM , NUM ) ) ; invocation = null ; if ( rec != null && cb != null ) { Class < ? > cls = rec . get Class ( ) ; try { invocation = cls . get Method ( cb , Object . class ) ; } catch ( Security Exception e ) { e . print Stack Trace ( ) ; } catch ( No Such Method Exception e ) { e . print Stack Trace ( ) ; } } is Enabled = BOOL ; is Selected = BOOL ; }
public void add Child Element ( XML Element child , boolean add After New Line ) throws Exception { add Child Element At ( child , - NUM , add After New Line ) ; }
public void edit Text ( Visual Item item , String attribute , Rectangle r ) { if ( m editing ) { stop Editing ( ) ; } String txt = item . get String ( attribute ) ; m edit Item = item ; m edit Attribute = attribute ; Color tc = Color Lib . get Color ( item . get Text Color ( ) ) ; Color fc = Color Lib . get Color ( item . get Fill Color ( ) ) ; m editor . set Foreground ( tc ) ; m editor . set Background ( fc ) ; edit Text ( txt , r ) ; }
public static Column column ( final String id , final String title , final int width , final int double Precision ) { return new Column ( id , title , Math . max ( width , title . length ( ) ) , double Precision ) ; }
public void print Count ( String kind , int count ) { if ( count != NUM ) { String key ; if ( count == NUM ) key = STRING + kind ; else key = STRING + kind + STRING ; log . print Lines ( Writer Kind . ERROR , key , String . value Of ( count ) ) ; log . flush ( Log . Writer Kind . ERROR ) ; } }
public static byte [ ] decode ( String str , int flags ) { return decode ( str . get Bytes ( ) , flags ) ; }
public static float screen To Scroll ( float x , float warp Size ) { if ( x <= NUM ) return NUM ; if ( x >= warp Size ) return x + warp Size ; return ( float ) Math . sqrt ( x * warp Size ) * NUM ; }
protected static final String add Escapes ( String str ) { String Buffer retval = new String Buffer ( ) ; char ch ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) { switch ( str . char At ( i ) ) { case NUM : continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; default : if ( ( ch = str . char At ( i ) ) < NUM || ch > NUM ) { String s = STRING + Integer . to String ( ch , NUM ) ; retval . append ( STRING + s . substring ( s . length ( ) - NUM , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . to String ( ) ; }
public synchronized void record Statistics ( Query Statistic statistic ) { query Statistics . add ( statistic ) ; }
protected double [ ] random Sub Range ( double bound Start , double bound Len ) { if ( bound Len >= NUM && usually ( ) ) { int int Bound Start = ( int ) Math . ceil ( bound Start ) ; int int Bound End = ( int ) ( bound Start + bound Len ) ; int int Bound Len = int Bound End - int Bound Start ; int new Len = ( int ) random Gaussian Mean Max ( int Bound Len / NUM , int Bound Len ) ; int new Start = int Bound Start + random Int ( int Bound Len - new Len ) ; return new double [ ] { new Start , new Len } ; } else { double new Len = random Gaussian Mean Max ( bound Len / NUM , bound Len ) ; double new Start = bound Start + ( bound Len - new Len == NUM ? NUM : ( random Double ( ) % ( bound Len - new Len ) ) ) ; return new double [ ] { new Start , new Len } ; } }
private Date Time Zone generate Time Zone ( String time Zone Id , Date Time Zone system Time Zone ) { if ( time Zone Id == null ) { return system Time Zone ; } try { return Date Time Zone . for ID ( time Zone Id ) ; } catch ( Illegal Argument Exception ignored ) { LOG . debug ( INVALID TIME ZONE . log Format ( time Zone Id ) ) ; throw new Bad Api Request Exception ( INVALID TIME ZONE . format ( time Zone Id ) ) ; } }
protected String to String ( String [ ] [ ] strings ) { int rows = strings . length ; int columns = strings . length <= NUM ? NUM : strings [ NUM ] . length ; String Buffer total = new String Buffer ( ) ; String Buffer s = new String Buffer ( ) ; for ( int row = NUM ; row < rows ; row ++ ) { s . set Length ( NUM ) ; for ( int column = NUM ; column < columns ; column ++ ) { s . append ( strings [ row ] [ column ] ) ; if ( column < columns - NUM ) s . append ( column Separator ) ; } total . append ( s ) ; if ( row < rows - NUM ) total . append ( row Separator ) ; } return total . to String ( ) ; }
public void check Warehouse ( boolean sbf ) { if ( warehouse == null ) { logger . fine ( STRING ) ; warehouse = new VPF Auto Feature Graphic Warehouse ( ) ; } }
public double max Dist ( Spatial Comparable mbr 1 , Spatial Comparable mbr 2 ) { final int dim 1 = mbr 1 . get Dimensionality ( ) , dim 2 = mbr 2 . get Dimensionality ( ) ; final int mindim = ( dim 1 < dim 2 ) ? dim 1 : dim 2 ; double agg = NUM ; for ( int d = NUM ; d < mindim ; d ++ ) { double d1 = mbr 1 . get Max ( d ) - mbr 2 . get Min ( d ) ; double d2 = mbr 2 . get Max ( d ) - mbr 1 . get Min ( d ) ; double delta = d1 > d2 ? d1 : d2 ; agg += delta * delta ; } for ( int d = mindim ; d < dim 1 ; d ++ ) { double d1 = Math . abs ( mbr 1 . get Min ( d ) ) , d2 = Math . abs ( mbr 1 . get Max ( d ) ) ; double delta = d1 > d2 ? d1 : d2 ; agg += delta * delta ; } for ( int d = mindim ; d < dim 2 ; d ++ ) { double d1 = Math . abs ( mbr 2 . get Min ( d ) ) , d2 = Math . abs ( mbr 2 . get Max ( d ) ) ; double delta = d1 > d2 ? d1 : d2 ; agg += delta * delta ; } return Math . sqrt ( agg ) ; }
public static void create Lesson ( @ Not Null final Lesson lesson , @ Not Null final Virtual File course Dir , @ Not Null final File resource Root , @ Not Null final Project project ) throws IO Exception { String lesson Dir Name = Edu Names . LESSON + Integer . to String ( lesson . get Index ( ) ) ; Virtual File lesson Dir = course Dir . create Child Directory ( project , lesson Dir Name ) ; final List < Task > task List = lesson . get Task List ( ) ; for ( int i = NUM ; i <= task List . size ( ) ; i ++ ) { Task task = task List . get ( i - NUM ) ; task . set Index ( i ) ; create Task ( task , lesson Dir , new File ( resource Root , lesson Dir . get Name ( ) ) , project ) ; } }
protected void rehash ( ) { int old Capacity = table . length ; Cache Entry old Table [ ] = table ; int new Capacity = old Capacity * NUM + NUM ; Cache Entry new Table [ ] = new Cache Entry [ new Capacity ] ; threshold = ( int ) ( new Capacity * load Factor ) ; table = new Table ; for ( int i = old Capacity ; i -- > NUM ; ) { for ( Cache Entry old = old Table [ i ] ; old != null ; ) { Cache Entry e = old ; old = old . next ; if ( e . check ( ) != null ) { int index = ( e . hash & NUM ) % new Capacity ; e . next = new Table [ index ] ; new Table [ index ] = e ; } else count -- ; } } }
public void append ( byte [ ] utf 8 , int start , int len ) { set Capacity ( length + len , BOOL ) ; System . arraycopy ( utf 8 , start , bytes , length , len ) ; length += len ; }
public static String make Log Tag ( Class cls ) { return make Log Tag ( cls . get Simple Name ( ) ) ; }
private void handle Error ( GCP Stats Data Holder stats Data , Throwable e ) { log Severe ( e ) ; stats Data . error = e ; stats Data . stage = Stats Collection Stage . ERROR ; handle Stats Request ( stats Data ) ; }
public java . lang . String Builder insert ( int offset , double d ) { return insert ( offset , Double . to String ( d ) ) ; }
public Object cast To Type ( int t , X Path Context support ) throws javax . xml . transform . Transformer Exception { Object result ; switch ( t ) { case CLASS STRING : result = str ( ) ; break ; case CLASS NUMBER : result = new Double ( num ( ) ) ; break ; case CLASS NODESET : result = iter ( ) ; break ; case CLASS BOOLEAN : result = new Boolean ( bool ( ) ) ; break ; case CLASS UNKNOWN : result = m obj ; break ; default : error ( XPATH Error Resources . ER CANT CONVERT TO TYPE , new Object [ ] { get Type String ( ) , Integer . to String ( t ) } ) ; result = null ; } return result ; }
public static boolean are Ms Capi Stores Supported ( ) { return Security . get Provider ( MS CAPI . jce ( ) ) != null ; }
public boolean is Critical ( ) { return BOOL ; }
public boolean is Passthrough Supported ( String mime Type ) { return audio Capabilities != null && audio Capabilities . supports Encoding ( get Encoding For Mime Type ( mime Type ) ) ; }
String internalsprintf ( final Object s ) { final String s2 ; if ( conversion Character == STRING || conversion Character == STRING ) { s2 = print S Format ( s . to String ( ) ) ; } else { throw new Illegal Argument Exception ( STRING + STRING + conversion Character + STRING ) ; } return s2 ; }
public T first Item ( ) { if ( m Data List == null || m Data List . size ( ) == NUM ) { return null ; } return m Data List . get ( NUM ) ; }
public void add Request Property ( String field , String new Value ) { check Not Connected ( ) ; if ( field == null ) { throw new Null Pointer Exception ( STRING ) ; } }
public double do Operation ( ) throws Operator Failed Exception { double [ ] mean = sccs . get Mode ( ) ; double [ ] current Value = parameter . get Parameter Values ( ) ; double [ ] new Value = new double [ dim ] ; Set < Integer > update Set = new Hash Set < Integer > ( ) ; if ( set Size Mean != - NUM ) { final int list Length = Poisson . next Poisson ( set Size Mean ) ; while ( update Set . size ( ) < list Length ) { int new Int = Math Utils . next Int ( parameter . get Dimension ( ) ) ; if ( ! update Set . contains ( new Int ) ) { update Set . add ( new Int ) ; } } } else { for ( int i = NUM ; i < dim ; ++ i ) { update Set . add ( i ) ; } } double logq = NUM ; for ( Integer i : update Set ) { new Value [ i ] = mean [ i ] + scale Factor * Math Utils . next Gaussian ( ) ; if ( UPDATE ALL ) { parameter . set Parameter Value Quietly ( i , new Value [ i ] ) ; } else { parameter . set Parameter Value ( i , new Value [ i ] ) ; } logq += ( Normal Distribution . log Pdf ( current Value [ i ] , mean [ i ] , scale Factor ) - Normal Distribution . log Pdf ( new Value [ i ] , mean [ i ] , scale Factor ) ) ; } if ( UPDATE ALL ) { parameter . set Parameter Value Notify Changed All ( NUM , parameter . get Parameter Value ( NUM ) ) ; } return logq ; }
public Object load ( URI uri ) throws IO Exception { Input Stream Reader src = null ; try { src = new File Reader ( new File ( uri ) ) ; return xstream . from XML ( src ) ; } finally { if ( null != src ) { src . close ( ) ; } } }
private synchronized void send Pending State ( ) { if ( ! m Pending Clients . is Empty ( ) ) { final Message [ ] messages = new Message [ ] { Santa Service Messages . get Begin Full State Message ( ) , Santa Service Messages . get Switch Off Message ( m Preferences . get Switch Off ( ) ) , get Time Update Message ( ) , Santa Service Messages . get Cast Disabled Message ( m Preferences . get Cast Disabled ( ) ) , Santa Service Messages . get Games Message ( m Preferences . get Gumball Disabled ( ) , m Preferences . get Jetpack Disabled ( ) , m Preferences . get Memory Disabled ( ) , m Preferences . get Rocket Disabled ( ) , m Preferences . get Dancer Disabled ( ) , m Preferences . get Snowdown Disabled ( ) ) , Santa Service Messages . get Destination Photo Message ( m Preferences . get Destination Photo Disabled ( ) ) , Santa Service Messages . get State Message ( m State ) , Santa Service Messages . get Videos Message ( m Preferences . get Videos ( ) ) } ; for ( int i = NUM ; i < m Pending Clients . size ( ) ; i ++ ) { final Messenger messenger = m Pending Clients . get ( i ) ; try { for ( Message msg : messages ) { messenger . send ( msg ) ; } m Clients . add ( messenger ) ; } catch ( Remote Exception e ) { } m Pending Clients . remove ( i ) ; } } }
private void fetch Chunk ( Bulk Id Param input , List < T > results ) { List < T > items = get Bulk Resources ( input ) ; for ( T item : items ) { results . add ( item ) ; } }
public static void move Directory To Directory ( File src , File dest Dir , boolean create Dest Dir ) throws IO Exception { if ( src == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( dest Dir == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ! dest Dir . exists ( ) && create Dest Dir ) { dest Dir . mkdirs ( ) ; } if ( ! dest Dir . exists ( ) ) { throw new File Not Found Exception ( STRING + dest Dir + STRING + create Dest Dir + STRING ) ; } if ( ! dest Dir . is Directory ( ) ) { throw new IO Exception ( STRING + dest Dir + STRING ) ; } move Directory ( src , new File ( dest Dir , src . get Name ( ) ) ) ; }
public Shape create Check Mark ( final int x , final int y , final int w , final int h ) { double xf = w / NUM ; double hf = h / NUM ; path . reset ( ) ; path . move To ( x , y + NUM * hf ) ; path . line To ( x + NUM * xf , y + NUM * hf ) ; path . line To ( x + NUM * xf , y + NUM * hf ) ; path . line To ( x + NUM * xf , y ) ; path . line To ( x + NUM * xf , y ) ; path . line To ( x + NUM * xf , y + NUM * hf ) ; path . close Path ( ) ; return path ; }
public static Response Data parse ( String response Data ) { int index = response Data . index Of ( STRING ) ; String main Data , extra Data ; if ( - NUM == index ) { main Data = response Data ; extra Data = STRING ; } else { main Data = response Data . substring ( NUM , index ) ; extra Data = index >= response Data . length ( ) ? STRING : response Data . substring ( index + NUM ) ; } String [ ] fields = Text Utils . split ( main Data , Pattern . quote ( STRING ) ) ; if ( fields . length < NUM ) { throw new Illegal Argument Exception ( ) ; } Response Data data = new Response Data ( ) ; data . extra = extra Data ; data . response Code = Integer . parse Int ( fields [ NUM ] ) ; data . nonce = Integer . parse Int ( fields [ NUM ] ) ; data . package Name = fields [ NUM ] ; data . version Code = fields [ NUM ] ; data . user Id = fields [ NUM ] ; data . timestamp = Long . parse Long ( fields [ NUM ] ) ; return data ; }
public int no Of Tabs ( ) { return m cur Win Tab . get Tab Count ( ) ; }
public void test Exceptionally exceptional Completion Action Failed ( ) { for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) { final Atomic Integer a = new Atomic Integer ( NUM ) ; final CF Exception ex 1 = new CF Exception ( ) ; final CF Exception ex 2 = new CF Exception ( ) ; final Completable Future < Integer > f = new Completable Future < > ( ) ; if ( ! create Incomplete ) f . complete Exceptionally ( ex 1 ) ; final Completable Future < Integer > g = f . exceptionally ( null ) ; if ( create Incomplete ) f . complete Exceptionally ( ex 1 ) ; check Completed With Wrapped Exception ( g , ex 2 ) ; check Completed Exceptionally ( f , ex 1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
private static void close ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( IO Exception e ) { } } }
public static String convert Timestamp To Date String Compact ( boolean use UTC , long milli ) { Date date = new Date ( milli ) ; Simple Date Format source Format = new Simple Date Format ( STRING ) ; source Format . set Time Zone ( use UTC ? Time Zone . get Time Zone ( STRING ) : Time Zone . get Default ( ) ) ; return source Format . format ( date ) ; }
protected synchronized void superpose Bit Set ( Fixed Bit Set incoming Bit Set , double weight ) { weight = ( int ) Math . round ( weight * Math . pow ( NUM , BINARY VECTOR DECIMAL PLACES ) ) ; if ( weight == NUM ) return ; total Number Of Votes . set ( total Number Of Votes . get ( ) + ( int ) weight ) ; int log Floor Of Weight = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( NUM ) ) ) ; if ( log Floor Of Weight < voting Record . size ( ) - NUM ) { while ( log Floor Of Weight > NUM ) { superpose Bit Set From Row Floor ( incoming Bit Set , log Floor Of Weight ) ; weight = weight - ( int ) Math . pow ( NUM , log Floor Of Weight ) ; log Floor Of Weight = ( int ) ( Math . floor ( Math . log ( weight ) / Math . log ( NUM ) ) ) ; } } for ( int x = NUM ; x < weight ; x ++ ) superpose Bit Set From Row Floor ( incoming Bit Set , NUM ) ; }
public final double tan Half Angle ( ) { return Math . tan ( NUM * this . radians ) ; }
abstract Future < Asynchronous Socket Channel > impl Accept ( Object attachment , Completion Handler < Asynchronous Socket Channel , Object > handler ) ;
public void parse Signatures File ( URL url ) throws IO Exception , Parse Exception { parse Signatures File ( url . open Stream ( ) , url . to String ( ) ) ; }
public void add Flare ( Flare flare ) { flares . add Element ( flare ) ; process Game Event ( new Game Board Change Event ( this ) ) ; }
public static void object String Non Recursive ( @ Unretained Object obj , String Builder sb ) { if ( obj instanceof Object [ ] ) { sb . append ( STRING ) ; boolean first = BOOL ; for ( Object o : ( Object [ ] ) obj ) { if ( ! first ) { sb . append ( STRING ) ; sb . append ( o ) ; } else { first = BOOL ; object String With Bytes ( o , sb ) ; } } sb . append ( STRING ) ; } else { object String With Bytes ( obj , sb ) ; } }
public void read OSM ( File file ) { if ( file . exists ( ) ) { street Layer . open OSM ( file ) ; } else { LOG . info ( STRING ) ; } }
public void start Element ( Stylesheet Handler handler , String uri , String local Name , String raw Name , Attributes attributes ) throws SAX Exception { String msg = STRING ; if ( ! ( handler . get Elem Template Element ( ) instanceof Stylesheet ) ) { msg = STRING ; handler . error ( msg , new SAX Exception ( msg ) ) ; } super . start Element ( handler , uri , local Name , raw Name , attributes ) ; String val = attributes . get Value ( STRING ) ; int index Of Colon = val . index Of ( STRING ) ; if ( index Of Colon > NUM ) { } else { msg = STRING ; handler . error ( msg , new SAX Exception ( msg ) ) ; } }
public void write ( byte [ ] buffer , int offset , int length ) throws IO Exception { file . write ( buffer , offset , length ) ; }
public static boolean can Interact ( Role issuer , Role target ) { if ( issuer . get Guild ( ) != target . get Guild ( ) ) throw new Illegal Argument Exception ( STRING ) ; return target . get Position ( ) < issuer . get Position ( ) ; }
public Webster ( ) throws Bind Exception { this . port = Integer . get Integer ( WEBSTER PORT , NUM ) ; initialize ( ) ; }
public boolean will Throw Exception If Key Was Not Found ( ) { return throwex ; }
public void test Compute Location When Uberwar Packaging ( ) throws Exception { Deployable deployable Element = new Deployable ( ) ; deployable Element . set Group Id ( STRING ) ; deployable Element . set Artifact Id ( STRING ) ; deployable Element . set Type ( STRING ) ; String location = deployable Element . compute Location ( create Default Project ( STRING , null ) ) ; assert True ( location . ends With ( STRING ) ) ; }
public Response create Response ( String response String ) throws java . text . Parse Exception { if ( response String == null ) return new SIP Response ( ) ; String Msg Parser smp = new String Msg Parser ( ) ; SIP Message sip Message = smp . parse SIP Message ( response String . get Bytes ( ) , BOOL , BOOL , null ) ; if ( ! ( sip Message instanceof SIP Response ) ) throw new Parse Exception ( response String , NUM ) ; return ( SIP Response ) sip Message ; }
private ODE State And Derivative state ( double t ) { return new ODE State And Derivative ( t , new double [ NUM ] , new double [ NUM ] ) ; }
public static Class < ? > find Common Element Type ( Collection collection ) { if ( is Empty ( collection ) ) { return null ; } Class < ? > candidate = null ; for ( Object val : collection ) { if ( val != null ) { if ( candidate == null ) { candidate = val . get Class ( ) ; } else if ( candidate != val . get Class ( ) ) { return null ; } } } return candidate ; }
private static void decode Hanzi Segment ( Bit Source bits , String Builder result , int count ) throws Format Exception { if ( count * NUM > bits . available ( ) ) { throw Format Exception . get Format Instance ( ) ; } byte [ ] buffer = new byte [ NUM * count ] ; int offset = NUM ; while ( count > NUM ) { int two Bytes = bits . read Bits ( NUM ) ; int assembled Two Bytes = ( ( two Bytes / NUM ) << NUM ) | ( two Bytes % NUM ) ; if ( assembled Two Bytes < NUM ) { assembled Two Bytes += NUM ; } else { assembled Two Bytes += NUM ; } buffer [ offset ] = ( byte ) ( ( assembled Two Bytes > > NUM ) & NUM ) ; buffer [ offset + NUM ] = ( byte ) ( assembled Two Bytes & NUM ) ; offset += NUM ; count -- ; } try { result . append ( new String ( buffer , String Utils . GB 2312 ) ) ; } catch ( Unsupported Encoding Exception uee ) { throw Format Exception . get Format Instance ( ) ; } }
protected void init Ping Interval Milli ( ) { String ping Interval Milli Param = get Init Parameter ( STRING ) ; set Ping Interval Milli ( ( ping Interval Milli Param == null ) ? DEFAULT PING INTERVAL MILLI : Integer . parse Int ( ping Interval Milli Param ) ) ; if ( is Debug ( ) ) { log ( STRING + get Ping Interval Milli ( ) ) ; } }
public boolean ask ( final String query Str , String external Query Id ) throws Exception { final Repository Connection cxn = cxn ( ) ; UUID query Id = null ; try { final Boolean Query query = ( Boolean Query ) cxn . prepare Boolean Query ( Query Language . SPARQL , query Str ) ; set Max Query Time ( query ) ; if ( query instanceof Bigdata Sail Boolean Query && cxn instanceof Bigdata Sail Repository Connection ) { final Bigdata Sail Boolean Query bdtq = ( Bigdata Sail Boolean Query ) query ; query Id = setup Query ( ( Bigdata Sail Repository Connection ) cxn , bdtq . get AST Container ( ) , Query Type . ASK , external Query Id ) ; } final boolean result = query . evaluate ( ) ; return result ; } finally { if ( query Id != null ) { finalize Query ( query Id ) ; } } }
@ Suppress Warnings ( STRING ) private static int find ( Object [ ] arr , net . sourceforge . retroweaver . harmony . runtime . java . lang . Comparable val , int bnd , int l , int r ) { int m = l ; int d = NUM ; while ( m <= r ) { if ( val . compare To ( arr [ m ] ) > bnd ) { l = m + NUM ; } else { r = m - NUM ; break ; } m += d ; d <<= NUM ; } while ( l <= r ) { m = ( l + r ) > > > NUM ; if ( val . compare To ( arr [ m ] ) > bnd ) { l = m + NUM ; } else { r = m - NUM ; } } return l - NUM ; }
Configuration Error ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
public static String as Hex ( byte [ ] bytes , String separator ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < bytes . length ; i ++ ) { String code = Integer . to Hex String ( bytes [ i ] & NUM ) ; if ( ( bytes [ i ] & NUM ) < NUM ) { sb . append ( STRING ) ; } sb . append ( code ) ; if ( separator != null && i < bytes . length - NUM ) { sb . append ( separator ) ; } } return sb . to String ( ) ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String bad String ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; { boolean success = BOOL ; try { bad String = child . substring Data ( NUM , NUM ) ; } catch ( DOM Exception ex ) { success = ( ex . code == DOM Exception . INDEX SIZE ERR ) ; } assert True ( STRING , success ) ; } }
public String to String ( ) { return String . value Of ( val ) ; }
private static void Call Static Void Method V ( JNI Environment env , int class JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { JNI Helpers . invoke With Var Arg ( method ID , arg Address , Type Reference . Void ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; } }
public static Connection create Connection ( boolean auto Commit , int trx Level ) { Connection conn = s cc . get Connection ( auto Commit , trx Level ) ; if ( C Log Mgt . is Level Finest ( ) ) { } try { if ( conn != null && conn . get Auto Commit ( ) != auto Commit ) { throw new Illegal State Exception ( STRING + auto Commit + STRING ) ; } } catch ( SQL Exception e ) { } return conn ; }
private boolean update Statement Data ( Statement Data sdata , Matcher matcher , String to Regex ) { if ( transform Tables ) return BOOL ; if ( matcher == null ) return BOOL ; String schema = sdata . get Default Schema ( ) ; if ( schema == null ) return BOOL ; matcher . reset ( schema ) ; if ( matcher . matches ( ) ) { String old Schema = schema ; sdata . set Default Schema ( matcher . replace All ( to Regex ) ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + old Schema + STRING + sdata . get Default Schema ( ) ) ; return BOOL ; } return BOOL ; }
public void test Shift Left 1 ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = NUM ; int number = NUM ; byte r Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . shift Left ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public void stop If Required ( ) { if ( System . current Time Millis ( ) > stop At ) { throw new Illegal State Exception ( ) ; } }
private void link Account ( final String principal Id , final Name ID name Id ) throws SAML 2 Meta Exception , Authentication Exception { final String sp Entity Id = meta Manager . get Entity By Meta Alias ( meta Alias ) ; try { Name ID Info info = new Name ID Info ( sp Entity Id , entity Name , name Id , SAML 2 Constants . SP ROLE , BOOL ) ; DEBUG . message ( STRING , principal Id , name Id . get Value ( ) ) ; if ( should Persist Name ID ( sp Entity Id ) ) { Account Utils . set Account Federation ( info , principal Id ) ; } principal = new SAML 2 Principal ( principal Id ) ; } catch ( SAML 2 Exception e ) { throw new Authentication Exception ( BUNDLE NAME , STRING , new Object [ NUM ] ) ; } }
private void enable Actions ( ) { restore Action . set Enabled ( frame . is Maximum ( ) || frame . is Icon ( ) ) ; maximize Action . set Enabled ( ( frame . is Maximizable ( ) && ! frame . is Maximum ( ) && ! frame . is Icon ( ) ) || ( frame . is Maximizable ( ) && frame . is Icon ( ) ) ) ; iconify Action . set Enabled ( frame . is Iconifiable ( ) && ! frame . is Icon ( ) ) ; close Action . set Enabled ( frame . is Closable ( ) ) ; size Action . set Enabled ( BOOL ) ; move Action . set Enabled ( BOOL ) ; }
private List < String > add Rules ( int filter Id , List < String > rules , boolean use Cosmetics ) { Input Stream input Stream = null ; Input Stream Reader input Stream Reader = null ; Buffered Reader reader = null ; try { String file Name = get Or Create Filter File ( filter Id ) ; input Stream = context . open File Input ( file Name ) ; input Stream Reader = new Input Stream Reader ( input Stream ) ; reader = new Buffered Reader ( input Stream Reader ) ; String line = reader . read Line ( ) ; while ( line != null ) { if ( use Cosmetics || ! Filter Rule . is Cosmetic Rule ( line ) ) { rules . add ( line ) ; } line = reader . read Line ( ) ; } return rules ; } catch ( Exception ex ) { log . error ( STRING , filter Id , ex ) ; throw new Runtime Exception ( STRING + filter Id , ex ) ; } finally { IO Utils . close Quietly ( input Stream ) ; IO Utils . close Quietly ( input Stream Reader ) ; IO Utils . close Quietly ( reader ) ; } }
public static String convert To Hex String ( byte [ ] bytes ) { int size = bytes . length ; String Buffer buffer = new String Buffer ( size * NUM ) ; for ( int i = NUM ; i < size ; i ++ ) { int x = bytes [ i ] ; if ( x < NUM ) x += NUM ; String tmp = Integer . to Hex String ( x ) ; if ( tmp . length ( ) == NUM ) buffer . append ( STRING ) ; buffer . append ( tmp ) ; } return buffer . to String ( ) ; }
public Ordered Task ( String identifier , Step ... steps ) { this ( identifier , Arrays . as List ( steps ) ) ; }
public void randomize ( List < Cell Index > cell Indices ) { Random rand = new Random ( ) ; int range = get Upper Bound ( ) - get Lower Bound ( ) ; for ( Cell Index cell Index : cell Indices ) { int row = cell Index . row ; int col = cell Index . col ; double value = ( rand . next Double ( ) * range ) + get Lower Bound ( ) ; set Logical Value ( row , col , value , BOOL ) ; } fire Table Data Changed ( ) ; }
private void read Response Headers ( State state , Inner State inner State , Http Response response ) throws Stop Request { Header header = response . get First Header ( STRING ) ; if ( header != null ) { inner State . m Header Content Disposition = header . get Value ( ) ; } header = response . get First Header ( STRING ) ; if ( header != null ) { inner State . m Header Content Location = header . get Value ( ) ; } header = response . get First Header ( STRING ) ; if ( header != null ) { inner State . m Header E Tag = header . get Value ( ) ; } String header Transfer Encoding = null ; header = response . get First Header ( STRING ) ; if ( header != null ) { header Transfer Encoding = header . get Value ( ) ; } String header Content Type = null ; header = response . get First Header ( STRING ) ; if ( header != null ) { header Content Type = header . get Value ( ) ; if ( ! header Content Type . equals ( STRING ) ) { throw new Stop Request ( Downloader Service . STATUS FILE DELIVERED INCORRECTLY , STRING ) ; } } if ( header Transfer Encoding == null ) { header = response . get First Header ( STRING ) ; if ( header != null ) { inner State . m Header Content Length = header . get Value ( ) ; long content Length = Long . parse Long ( inner State . m Header Content Length ) ; if ( content Length != - NUM && content Length != m Info . m Total Bytes ) { Log . e ( Constants . TAG , STRING ) ; } } } else { if ( Constants . LOGVV ) { Log . v ( Constants . TAG , STRING ) ; } } if ( Constants . LOGVV ) { Log . v ( Constants . TAG , STRING + inner State . m Header Content Disposition ) ; Log . v ( Constants . TAG , STRING + inner State . m Header Content Length ) ; Log . v ( Constants . TAG , STRING + inner State . m Header Content Location ) ; Log . v ( Constants . TAG , STRING + inner State . m Header E Tag ) ; Log . v ( Constants . TAG , STRING + header Transfer Encoding ) ; } boolean no Size Info = inner State . m Header Content Length == null && ( header Transfer Encoding == null || ! header Transfer Encoding . equals Ignore Case ( STRING ) ) ; if ( no Size Info ) { throw new Stop Request ( Downloader Service . STATUS HTTP DATA ERROR , STRING ) ; } }
public void add Auditory ( int id ) { m Auditory Feedback . add ( id ) ; }
public String wrap ( String path ) { return uri Prefix + path ; }
public static void constant Attributes ( Simple Method method , Element element , String ... attribute Names ) throws Validation Exception { for ( String name : attribute Names ) { String attribute Value = element . get Attribute ( name ) ; if ( ! Mini Lang Util . is Constant Attribute ( attribute Value ) ) { handle Error ( STRING + name + STRING , method , element ) ; } } }
private void bind View Type ( WX Component component ) { int id = generate View Type ( component ) ; if ( m View Types == null ) { m View Types = new Sparse Array < > ( ) ; } Array List < WX Component > m Types = m View Types . get ( id ) ; if ( m Types == null ) { m Types = new Array List < > ( ) ; m View Types . put ( id , m Types ) ; } m Types . add ( component ) ; }
protected boolean is Empty Value ( Object raw Value ) { return raw Value == null || String Utils . is Blank ( String . value Of ( raw Value ) ) ; }
public Cipher Text Iv Mac ( byte [ ] c , byte [ ] i , byte [ ] h ) { cipher Text = new byte [ c . length ] ; System . arraycopy ( c , NUM , cipher Text , NUM , c . length ) ; iv = new byte [ i . length ] ; System . arraycopy ( i , NUM , iv , NUM , i . length ) ; mac = new byte [ h . length ] ; System . arraycopy ( h , NUM , mac , NUM , h . length ) ; }
public static Master Private Key create From Encrypted Seed ( String passphrase , byte [ ] encrypted Seed ) throws Hyper Ledger Exception { try { byte [ ] key = S Crypt . generate ( passphrase . get Bytes ( STRING ) , BITCOIN SEED , NUM , NUM , NUM , NUM ) ; Secret Key Spec keyspec = new Secret Key Spec ( key , STRING ) ; if ( encrypted Seed . length != NUM ) { throw new Hyper Ledger Exception ( STRING ) ; } Cipher cipher = Cipher . get Instance ( STRING , STRING ) ; cipher . init ( Cipher . DECRYPT MODE , keyspec ) ; return create ( cipher . do Final ( encrypted Seed ) ) ; } catch ( Unsupported Encoding Exception | No Such Padding Exception | No Such Provider Exception | No Such Algorithm Exception | Invalid Key Exception | Bad Padding Exception | Illegal Block Size Exception e ) { throw new Hyper Ledger Exception ( e ) ; } }
public static List < Json Pointer > filter ( final String ... fields ) { final List < Json Pointer > result = new Array List < > ( fields . length ) ; for ( final String field : fields ) { result . add ( new Json Pointer ( field ) ) ; } return result ; }
public boolean apply Ft Proxy ( ) { return method . is Annotation Present ( Astrix Fault Tolerance Proxy . class ) ; }
private void notify Change ( int previous , int current ) { m Sound Player . play ( m Sound Id , NUM , NUM , NUM , NUM , NUM ) ; if ( m On Value Change Listener != null ) { m On Value Change Listener . on Value Change ( this , previous , m Value ) ; } }
public static double atan 2 ( double y , double x ) { if ( Double . is Na N ( x ) || Double . is Na N ( y ) ) { return Double . Na N ; } if ( y == NUM ) { final double result = x * y ; final double invx = NUM / x ; final double invy = NUM / y ; if ( invx == NUM ) { if ( x > NUM ) { return y ; } else { return copy Sign ( Math . PI , y ) ; } } if ( x < NUM || invx < NUM ) { if ( y < NUM || invy < NUM ) { return - Math . PI ; } else { return Math . PI ; } } else { return result ; } } if ( y == Double . POSITIVE INFINITY ) { if ( x == Double . POSITIVE INFINITY ) { return Math . PI * F 1 4 ; } if ( x == Double . NEGATIVE INFINITY ) { return Math . PI * F 3 4 ; } return Math . PI * F 1 2 ; } if ( y == Double . NEGATIVE INFINITY ) { if ( x == Double . POSITIVE INFINITY ) { return - Math . PI * F 1 4 ; } if ( x == Double . NEGATIVE INFINITY ) { return - Math . PI * F 3 4 ; } return - Math . PI * F 1 2 ; } if ( x == Double . POSITIVE INFINITY ) { if ( y > NUM || NUM / y > NUM ) { return NUM ; } if ( y < NUM || NUM / y < NUM ) { return - NUM ; } } if ( x == Double . NEGATIVE INFINITY ) { if ( y > NUM || NUM / y > NUM ) { return Math . PI ; } if ( y < NUM || NUM / y < NUM ) { return - Math . PI ; } } if ( x == NUM ) { if ( y > NUM || NUM / y > NUM ) { return Math . PI * F 1 2 ; } if ( y < NUM || NUM / y < NUM ) { return - Math . PI * F 1 2 ; } } final double r = y / x ; if ( Double . is Infinite ( r ) ) { return atan ( r , NUM , x < NUM ) ; } double ra = double High Part ( r ) ; double rb = r - ra ; final double xa = double High Part ( x ) ; final double xb = x - xa ; rb += ( y - ra * xa - ra * xb - rb * xa - rb * xb ) / x ; final double temp = ra + rb ; rb = - ( temp - ra - rb ) ; ra = temp ; if ( ra == NUM ) { ra = copy Sign ( NUM , y ) ; } final double result = atan ( ra , rb , x < NUM ) ; return result ; }
public int count ( ) { return comments == null ? NUM : comments . size ( ) ; }
private boolean is Any Package From List Installed ( List < String > packages ) { boolean result = BOOL ; Package Manager pm = m Context . get Package Manager ( ) ; for ( String package Name : packages ) { try { pm . get Package Info ( package Name , NUM ) ; Q Log . e ( package Name + STRING ) ; result = BOOL ; } catch ( Package Manager . Name Not Found Exception e ) { continue ; } } return result ; }
public static String make System Name ( String type , int bit Num ) { String n Name = STRING ; if ( ( ! type . equals ( STRING ) ) && ( ! type . equals ( STRING ) ) && ( ! type . equals ( STRING ) ) ) { log . error ( STRING + type ) ; return ( n Name ) ; } if ( ( bit Num < NUM ) || ( ( type . equals ( STRING ) ) && ( bit Num > NUM ) ) || ( bit Num > NUM ) ) { log . error ( STRING + bit Num ) ; return ( n Name ) ; } n Name = STRING + type + Integer . to String ( bit Num ) ; return ( n Name ) ; }
public static void remove ( ) { AUTH TOKEN . remove ( ) ; }
public abstract boolean conflicts ( Copy Job other ) ;
public Tree Node deserialize ( String data ) { Deque < String > nodes = new Linked List < > ( ) ; nodes . add All ( Arrays . as List ( data . split ( SPLITER ) ) ) ; return build Tree ( nodes ) ; }
public void fill ( int from Index , int to Index , short val ) { if ( to Index > pos ) { ensure Capacity ( to Index ) ; pos = to Index ; } Arrays . fill ( data , from Index , to Index , val ) ; }
private void run Pending Requests ( ) { int max Start Id = - NUM ; Billing Request request ; while ( ( request = m Pending Requests . peek ( ) ) != null ) { if ( request . run If Connected ( ) ) { m Pending Requests . remove ( ) ; if ( max Start Id < request . get Start Id ( ) ) { max Start Id = request . get Start Id ( ) ; } } else { bind To Market Billing Service ( ) ; return ; } } if ( max Start Id >= NUM ) { if ( Consts . DEBUG ) { Log . i ( TAG , STRING + max Start Id ) ; } stop Self ( max Start Id ) ; } }
public static void remove Attribute Default Values ( String service Name , String schema Type , String attr Name , Set default Values , boolean is Org Attr Schema ) throws Upgrade Exception { String class Method = STRING ; Service Schema ss = null ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING + service Name ) ; debug . message ( class Method + STRING + schema Type ) ; debug . message ( class Method + STRING + attr Name ) ; debug . message ( class Method + STRING + default Values ) ; debug . message ( class Method + STRING + is Org Attr Schema ) ; } try { if ( is Org Attr Schema ) { Service Schema Manager sm = get Service Schema Manager ( service Name ) ; ss = sm . get Organization Creation Schema ( ) ; } else { ss = get Service Schema ( service Name , null , schema Type ) ; } if ( ss != null ) { Attribute Schema attr Schema = ss . get Attribute Schema ( attr Name ) ; for ( Iterator i = default Values . iterator ( ) ; i . has Next ( ) ; ) { String default Value = ( String ) i . next ( ) ; attr Schema . remove Default Value ( default Value ) ; } } } catch ( SMS Exception sme ) { debug . error ( class Method + STRING , sme ) ; } catch ( SSO Exception ssoe ) { debug . error ( class Method + STRING , ssoe ) ; } }
public void unlock ( final T tx ) { if ( DEBUG ) log . debug ( STRING ) ; lock . lock ( ) ; if ( DEBUG ) log . debug ( STRING ) ; try { assert Not Dead ( ) ; assert Owns Lock ( tx ) ; if ( queue . remove ( ) != tx ) { throw new Assertion Error ( ) ; } if ( waits For != null ) { final Iterator < T > itr = queue . iterator ( ) ; synchronized ( waits For ) { while ( itr . has Next ( ) ) { final T pending Tx = itr . next ( ) ; try { waits For . remove Edge ( pending Tx , tx ) ; } catch ( Throwable t ) { log . warn ( t . get Message ( ) , t ) ; } } } } if ( queue . is Empty ( ) ) { if ( INFO ) log . info ( STRING ) ; return ; } if ( INFO ) log . info ( STRING ) ; available . signal All ( ) ; } finally { lock . unlock ( ) ; if ( DEBUG ) log . debug ( STRING ) ; } }
public boolean is Update Available ( ) { return available Update != null ; }
@ Override public String to String Summary ( ) { String result ; String titles ; int resultset Length ; int i ; int j ; if ( m Non Sig Wins == null ) { return STRING ; } result = STRING ; titles = STRING ; resultset Length = NUM + Math . max ( ( int ) ( Math . log ( get Col Count ( ) ) / Math . log ( NUM ) ) , ( int ) ( Math . log ( get Row Count ( ) ) / Math . log ( NUM ) ) ) ; for ( i = NUM ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) { continue ; } titles += STRING + Utils . pad Left ( STRING + get Summary Title ( i ) , resultset Length * NUM + NUM ) ; } result += titles + STRING ; for ( i = NUM ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) { continue ; } for ( j = NUM ; j < get Col Count ( ) ; j ++ ) { if ( get Col Hidden ( j ) ) { continue ; } result += STRING ; if ( j == i ) { result += Utils . pad Left ( STRING , resultset Length * NUM + NUM ) ; } else { result += Utils . pad Left ( STRING + m Non Sig Wins [ i ] [ j ] + STRING + m Wins [ i ] [ j ] + STRING , resultset Length * NUM + NUM ) ; } } result += STRING + get Summary Title ( i ) + STRING + get Col Name ( i ) + STRING ; } return result ; }
public int read ( Buffered Input Stream is ) { init ( ) ; if ( is != null ) { in = is ; read Header ( ) ; if ( ! err ( ) ) { read Contents ( ) ; if ( frame Count < NUM ) { status = STATUS FORMAT ERROR ; } } } else { status = STATUS OPEN ERROR ; } try { is . close ( ) ; } catch ( IO Exception e ) { } return status ; }
private static int determine Type ( byte [ ] bytes ) { int offset = NUM ; if ( bytes . length >= NUM && ( bytes [ NUM ] & NUM ) == NUM && ( bytes [ NUM ] & NUM ) == NUM && ( bytes [ NUM ] & NUM ) == NUM ) { offset += NUM ; } while ( offset < bytes . length && bytes [ offset ] == STRING || bytes [ offset ] == STRING || bytes [ offset ] == STRING || bytes [ offset ] == STRING || bytes [ offset ] == STRING ) { offset ++ ; } return determine Type ( new String ( bytes , offset , Math . min ( NUM , bytes . length - offset ) ) ) ; }
public void fix Https URL Connection ( ) { Https URL Connection . set Default SSL Socket Factory ( ssl Context . get Socket Factory ( ) ) ; }
@ Override public Data Table sample ( int new Size ) { int row Count = get Row Number ( ) ; if ( row Count <= new Size ) { return this ; } int [ ] sampled Selected Indices = new int [ row Count ] ; for ( int i = NUM ; i < row Count ; ++ i ) { sampled Selected Indices [ i ] = i ; } Random rng = new Random ( NUM ) ; int swap Idx ; int tmp Value ; for ( int i = NUM ; i < row Count ; ++ i ) { swap Idx = rng . next Int ( row Count ) ; tmp Value = sampled Selected Indices [ swap Idx ] ; sampled Selected Indices [ swap Idx ] = sampled Selected Indices [ i ] ; sampled Selected Indices [ i ] = tmp Value ; } Data Table View sampled Data Table = new Data Table View ( this ) ; Vector < Integer > sampled Selected Indices Vector = new Vector < Integer > ( new Size ) ; for ( int i = NUM ; i < new Size ; ++ i ) { sampled Selected Indices Vector . add ( sampled Selected Indices [ i ] ) ; } sampled Data Table . set Selected Indices ( sampled Selected Indices Vector ) ; return sampled Data Table ; }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m filter Thread . is Alive ( ) && m state != IDLE ) { wait ( ) ; } } catch ( Interrupted Exception ex ) { } } else { notify All ( ) ; } }
public void cancel ( ) { if ( m Upload Operation == null ) { if ( m Upload Started . get ( ) ) { Log OC . d ( TAG , STRING ) ; m Cancellation Requested . set ( BOOL ) ; } else { Log OC . e ( TAG , STRING ) ; } } else { Log OC . d ( TAG , STRING ) ; m Upload Operation . cancel ( ) ; } }
public void test Neg Neg First Shorter ( ) { byte a Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { - NUM , NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , - NUM } ; int a Sign = - NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { - NUM , NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , - NUM , NUM , - NUM , - NUM , NUM , - NUM , - NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . and ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
public static void merge Files ( final File file 1 , final File file 2 , final File output File ) { if ( ! is Readable ( file 1 ) || ! is Readable ( file 2 ) || ! output File . exists ( ) && ! make Dirs For File ( output File ) ) { return ; } try { File Input Stream fis 1 = new File Input Stream ( file 1 ) ; File Input Stream fis 2 = new File Input Stream ( file 2 ) ; Sequence Input Stream sis = new Sequence Input Stream ( fis 1 , fis 2 ) ; File Output Stream fos = new File Output Stream ( output File ) ; int count ; byte [ ] temp = new byte [ NUM ] ; while ( ( count = sis . read ( temp ) ) != - NUM ) { fos . write ( temp , NUM , count ) ; } File Utils . sync ( fos ) ; fos . close ( ) ; sis . close ( ) ; fis 1 . close ( ) ; fis 2 . close ( ) ; } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
public static Snippet Set parse ( final File file ) throws Parse Exception { return parse ( file Input Supplier ( file . get Parent File ( ) ) , file . get Name ( ) ) ; }
public static String read File ( Class < ? > context , String name ) throws IO Exception { try ( Input Stream in = context . get Resource As Stream ( name ) ) { if ( in == null ) { return null ; } return new String ( Byte Streams . to Byte Array ( in ) , ENC ) ; } catch ( IO Exception e ) { throw new IO Exception ( STRING + name , e ) ; } }
long pts To Time Us ( long pts ) { if ( last Pts != Long . MIN VALUE ) { long closest Wrap Count = ( last Pts + ( MAX PTS / NUM ) ) / MAX PTS ; long pts Wrap Below = pts + ( MAX PTS * ( closest Wrap Count - NUM ) ) ; long pts Wrap Above = pts + ( MAX PTS * closest Wrap Count ) ; pts = Math . abs ( pts Wrap Below - last Pts ) < Math . abs ( pts Wrap Above - last Pts ) ? pts Wrap Below : pts Wrap Above ; } long time Us = ( pts * C . MICROS PER SECOND ) / NUM ; if ( last Pts == Long . MIN VALUE ) { timestamp Offset Us = first Sample Timestamp - time Us ; } last Pts = pts ; return time Us + timestamp Offset Us ; }
public int remove ( Object key ) { Entry e = remove Entry For Key ( key ) ; return ( e == null ? NUM : e . value ) ; }
public boolean verify Challenge Token ( Inet Socket Address address , int token ) { return Objects . equals ( challenge Tokens . get ( address ) , token ) ; }
@ Override public void handle Key ( int virtual Key Code , int transition State , char key Char ) { switch Control Keys ( virtual Key Code , transition State ) ; input Buffer . add ( new Global Key Event ( this , virtual Key Code , transition State , key Char , menu Pressed , shift Pressed , control Pressed , extended Key ) ) ; }
protected void draw Triangle ( int x , int y , int w , int h , Color fill Color , Paint fill Paint , Color pen Color , boolean shadow , String direction ) { Polygon triangle = new Polygon ( ) ; if ( direction . equals ( mx Constants . DIRECTION NORTH ) ) { triangle . add Point ( x , y + h ) ; triangle . add Point ( x + w / NUM , y ) ; triangle . add Point ( x + w , y + h ) ; } else if ( direction . equals ( mx Constants . DIRECTION SOUTH ) ) { triangle . add Point ( x , y ) ; triangle . add Point ( x + w / NUM , y + h ) ; triangle . add Point ( x + w , y ) ; } else if ( direction . equals ( mx Constants . DIRECTION WEST ) ) { triangle . add Point ( x + w , y ) ; triangle . add Point ( x , y + h / NUM ) ; triangle . add Point ( x + w , y + h ) ; } else { triangle . add Point ( x , y ) ; triangle . add Point ( x + w , y + h / NUM ) ; triangle . add Point ( x , y + h ) ; } draw Polygon ( triangle , fill Color , fill Paint , pen Color , shadow ) ; }
private static Map < String , String > resource Bundle Map ( Resource Bundle bundle ) { final Hash Map < String , String > map = new Hash Map < String , String > ( ) ; final Enumeration < String > e = bundle . get Keys ( ) ; while ( e . has More Elements ( ) ) { final String key = e . next Element ( ) ; map . put ( key , ( String ) bundle . get Object ( key ) ) ; } return Collections . unmodifiable Map ( map ) ; }
public int compare To ( Int Buffer other Buffer ) { int compare Remaining = ( remaining ( ) < other Buffer . remaining ( ) ) ? remaining ( ) : other Buffer . remaining ( ) ; int this Pos = position ; int other Pos = other Buffer . position ; int this Int , other Int ; while ( compare Remaining > NUM ) { this Int = get ( this Pos ) ; other Int = other Buffer . get ( other Pos ) ; if ( this Int != other Int ) { return this Int < other Int ? - NUM : NUM ; } this Pos ++ ; other Pos ++ ; compare Remaining -- ; } return remaining ( ) - other Buffer . remaining ( ) ; }
private static Size Pair select Size Pair ( Camera camera , int desired Width , int desired Height ) { List < Size Pair > valid Preview Sizes = generate Valid Preview Size List ( camera ) ; Size Pair selected Pair = null ; int min Diff = Integer . MAX VALUE ; for ( Size Pair size Pair : valid Preview Sizes ) { Size size = size Pair . preview Size ( ) ; int diff = Math . abs ( size . get Width ( ) - desired Width ) + Math . abs ( size . get Height ( ) - desired Height ) ; if ( diff < min Diff ) { selected Pair = size Pair ; min Diff = diff ; } } return selected Pair ; }
public void test Divide Round Half Up Pos ( ) { String a = STRING ; int a Scale = - NUM ; String b = STRING ; int b Scale = NUM ; String c = STRING ; int res Scale = - NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; Big Decimal result = a Number . divide ( b Number , res Scale , Big Decimal . ROUND HALF UP ) ; assert Equals ( STRING , c , result . to String ( ) ) ; assert Equals ( STRING , res Scale , result . scale ( ) ) ; }
private boolean is Black ( final int x , final int y ) { if ( ! in Bounds ( x , y ) ) { return BOOL ; } return ( m buffered Image . get RGB ( x , y ) & NUM ) == NUM ; }
public void add Job ( Runnable job ) { m Jobs . add ( job ) ; }
public PKCS 10 Certification Request ( String signature Algorithm , X509 Name subject , Public Key key , ASN 1 Set attributes , Private Key signing Key , String provider ) throws No Such Algorithm Exception , No Such Provider Exception , Invalid Key Exception , Signature Exception { String algorithm Name = Strings . to Upper Case ( signature Algorithm ) ; DER Object Identifier sig OID = ( DER Object Identifier ) algorithms . get ( algorithm Name ) ; if ( sig OID == null ) { try { sig OID = new DER Object Identifier ( algorithm Name ) ; } catch ( Exception e ) { throw new Illegal Argument Exception ( STRING ) ; } } if ( subject == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( key == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( no Params . contains ( sig OID ) ) { this . sig Alg Id = new Algorithm Identifier ( sig OID ) ; } else if ( params . contains Key ( algorithm Name ) ) { this . sig Alg Id = new Algorithm Identifier ( sig OID , ( ASN 1 Encodable ) params . get ( algorithm Name ) ) ; } else { this . sig Alg Id = new Algorithm Identifier ( sig OID , DER Null . INSTANCE ) ; } try { ASN 1 Sequence seq = ( ASN 1 Sequence ) ASN 1 Primitive . from Byte Array ( key . get Encoded ( ) ) ; this . req Info = new Certification Request Info ( subject , new Subject Public Key Info ( seq ) , attributes ) ; } catch ( IO Exception e ) { throw new Illegal Argument Exception ( STRING ) ; } Signature sig ; if ( provider == null ) { sig = Signature . get Instance ( signature Algorithm ) ; } else { sig = Signature . get Instance ( signature Algorithm , provider ) ; } sig . init Sign ( signing Key ) ; try { sig . update ( req Info . get Encoded ( ASN 1 Encoding . DER ) ) ; } catch ( Exception e ) { throw new Illegal Argument Exception ( STRING + e ) ; } this . sig Bits = new DER Bit String ( sig . sign ( ) ) ; }
@ Override public void close ( ) throws IO Exception { if ( in != null ) { in . close ( ) ; in = null ; buf = null ; } }
public static Collection < Vector 2 D > reduce Points ( final Collection < Vector 2 D > points ) { int size = NUM ; Vector 2 D min X = null ; Vector 2 D max X = null ; Vector 2 D min Y = null ; Vector 2 D max Y = null ; for ( Vector 2 D p : points ) { if ( min X == null || p . get X ( ) < min X . get X ( ) ) { min X = p ; } if ( max X == null || p . get X ( ) > max X . get X ( ) ) { max X = p ; } if ( min Y == null || p . get Y ( ) < min Y . get Y ( ) ) { min Y = p ; } if ( max Y == null || p . get Y ( ) > max Y . get Y ( ) ) { max Y = p ; } size ++ ; } if ( size < NUM ) { return points ; } final List < Vector 2 D > quadrilateral = build Quadrilateral ( min Y , max X , max Y , min X ) ; if ( quadrilateral . size ( ) < NUM ) { return points ; } final List < Vector 2 D > reduced Points = new Array List < Vector 2 D > ( quadrilateral ) ; for ( final Vector 2 D p : points ) { if ( ! inside Quadrilateral ( p , quadrilateral ) ) { reduced Points . add ( p ) ; } } return reduced Points ; }
int update Bookmarks In Transaction ( Content Values values , String selection , String [ ] selection Args , boolean caller Is Sync Adapter ) { int count = NUM ; final SQ Lite Database db = m Open Helper . get Writable Database ( ) ; final String [ ] bookmarks Projection = new String [ ] { Bookmarks . ID , Bookmarks . VERSION , Bookmarks . URL , Bookmarks . TITLE , Bookmarks . IS FOLDER , Bookmarks . ACCOUNT NAME , Bookmarks . ACCOUNT TYPE } ; Cursor cursor = db . query ( TABLE BOOKMARKS , bookmarks Projection , selection , selection Args , null , null , null ) ; boolean updating Parent = values . contains Key ( Bookmarks . PARENT ) ; String parent Account Name = null ; String parent Account Type = null ; if ( updating Parent ) { long parent = values . get As Long ( Bookmarks . PARENT ) ; Cursor c = db . query ( TABLE BOOKMARKS , new String [ ] { Bookmarks . ACCOUNT NAME , Bookmarks . ACCOUNT TYPE } , STRING , new String [ ] { Long . to String ( parent ) } , null , null , null ) ; if ( c . move To First ( ) ) { parent Account Name = c . get String ( NUM ) ; parent Account Type = c . get String ( NUM ) ; } c . close ( ) ; } else if ( values . contains Key ( Bookmarks . ACCOUNT NAME ) || values . contains Key ( Bookmarks . ACCOUNT TYPE ) ) { } try { String [ ] args = new String [ NUM ] ; if ( ! caller Is Sync Adapter ) { values . put ( Bookmarks . DATE MODIFIED , System . current Time Millis ( ) ) ; values . put ( Bookmarks . DIRTY , NUM ) ; } boolean updating Url = values . contains Key ( Bookmarks . URL ) ; String url = null ; if ( updating Url ) { url = values . get As String ( Bookmarks . URL ) ; } Content Values image Values = extract Image Values ( values , url ) ; while ( cursor . move To Next ( ) ) { long id = cursor . get Long ( NUM ) ; args [ NUM ] = Long . to String ( id ) ; String account Name = cursor . get String ( NUM ) ; String account Type = cursor . get String ( NUM ) ; if ( updating Parent && ( ! Text Utils . equals ( account Name , parent Account Name ) || ! Text Utils . equals ( account Type , parent Account Type ) ) ) { Content Values new Values = values From Cursor ( cursor ) ; new Values . put All ( values ) ; new Values . remove ( Bookmarks . ID ) ; new Values . remove ( Bookmarks . VERSION ) ; new Values . put ( Bookmarks . ACCOUNT NAME , parent Account Name ) ; new Values . put ( Bookmarks . ACCOUNT TYPE , parent Account Type ) ; Uri insert Uri = insert In Transaction ( Bookmarks . CONTENT URI , new Values , caller Is Sync Adapter ) ; long new Id = Content Uris . parse Id ( insert Uri ) ; if ( cursor . get Int ( NUM ) != NUM ) { Content Values update Children = new Content Values ( NUM ) ; update Children . put ( Bookmarks . PARENT , new Id ) ; count += update Bookmarks In Transaction ( update Children , Bookmarks . PARENT + STRING , new String [ ] { Long . to String ( id ) } , caller Is Sync Adapter ) ; } Uri uri = Content Uris . with Appended Id ( Bookmarks . CONTENT URI , id ) ; delete In Transaction ( uri , null , null , caller Is Sync Adapter ) ; count += NUM ; } else { if ( ! caller Is Sync Adapter ) { values . put ( Bookmarks . VERSION , cursor . get Long ( NUM ) + NUM ) ; } count += db . update ( TABLE BOOKMARKS , values , STRING , args ) ; } if ( image Values != null ) { if ( ! updating Url ) { url = cursor . get String ( NUM ) ; image Values . put ( Images . URL , url ) ; } if ( ! Text Utils . is Empty ( url ) ) { args [ NUM ] = url ; if ( db . update ( TABLE IMAGES , image Values , Images . URL + STRING , args ) == NUM ) { db . insert ( TABLE IMAGES , Images . FAVICON , image Values ) ; } } } } } finally { if ( cursor != null ) cursor . close ( ) ; } return count ; }
private Ignite Bi Tuple < String , Integer > host Port ( String conn Str , String host Port Str ) throws Ignite Checked Exception { String [ ] tokens = host Port Str . split ( STRING , - NUM ) ; String host = tokens [ NUM ] ; if ( F . is Empty ( host ) ) host = LOCALHOST ; int port ; if ( tokens . length == NUM ) port = Igfs Ipc Endpoint Configuration . DFLT PORT ; else if ( tokens . length == NUM ) { String port Str = tokens [ NUM ] ; try { port = Integer . value Of ( port Str ) ; if ( port < NUM || port > NUM ) throw new Ignite Checked Exception ( STRING + conn Str ) ; } catch ( Number Format Exception e ) { throw new Ignite Checked Exception ( STRING + conn Str ) ; } } else throw new Ignite Checked Exception ( STRING + conn Str ) ; return F . t ( host , port ) ; }
public boolean is Missile Going To Hit ( Entity Missile missile ) { if ( missile == null || missile . target Vector == null ) { return BOOL ; } return ( Vector 2 . distance ( new Vector 2 ( new Pos 3 D ( missile ) ) , new Vector 2 ( x Coord , z Coord ) ) < alarm Range && Vector 2 . distance ( new Vector 2 ( missile . target Vector ) , new Vector 2 ( x Coord , z Coord ) ) < safety Range ) ; }
public static Usericon parse Mod Icon ( String json ) { try { JSON Parser parser = new JSON Parser ( ) ; JSON Object o = ( JSON Object ) parser . parse ( json ) ; JSON Object room = ( JSON Object ) o . get ( STRING ) ; String room Id = ( String ) room . get ( STRING ) ; String mod Badge Url = ( String ) room . get ( STRING ) ; if ( mod Badge Url == null ) { return null ; } return Usericon Factory . create Twitch Like Icon ( Usericon . Type . MOD , room Id , mod Badge Url , Usericon . SOURCE FFZ , STRING ) ; } catch ( Parse Exception | Class Cast Exception | Null Pointer Exception ex ) { } return null ; }
public static long length ( URL url ) throws IO Exception { HTTP Response http = HTTP Engine . head ( url , null , null , - NUM , BOOL , null , Constants . NAME , null , null ) ; return http . get Content Length ( ) ; }
@ Override public Request < List < Workspace > > all ( ) { List < Workspace > workspaces To Return = new Array List < > ( ) ; for ( Workspace dummy Workspace : workspaces . values ( ) ) { workspaces To Return . add ( dummy Workspace ) ; } return new Dummy Request < > ( workspaces To Return ) ; }
public void subscribe ( Event Subscriber < ? > subscriber ) { final Class < ? > event Type = get Event Type ( subscriber ) ; do Subscribe ( subscriber , event Type ) ; }
public static String reader To String ( final Reader file Reader ) throws IO Exception { final String Builder sb = new String Builder ( ) ; try ( Buffered Reader br = new Buffered Reader ( file Reader ) ) { final char [ ] buffer = File Utils . make Buffer ( ) ; final int eof = - NUM ; for ( int len = br . read ( buffer ) ; len > eof ; len = br . read ( buffer ) ) { for ( int i = NUM ; i < len ; i ++ ) { sb . append ( buffer [ i ] ) ; } } } return sb . to String ( ) ; }
public static String bytes To Hex ( byte [ ] bytes , boolean with Spaces ) { String Builder sb = new String Builder ( ) ; for ( byte hash Byte : bytes ) { int int Val = NUM & hash Byte ; if ( int Val < NUM ) { sb . append ( STRING ) ; } sb . append ( Integer . to Hex String ( int Val ) ) ; if ( with Spaces ) { sb . append ( STRING ) ; } } return sb . to String ( ) ; }
public static byte [ ] string To Utf 8 Bytes ( String string ) { int len = string . length ( ) ; byte [ ] bytes = new byte [ len * NUM ] ; int out At = NUM ; for ( int i = NUM ; i < len ; i ++ ) { char c = string . char At ( i ) ; if ( ( c != NUM ) && ( c < NUM ) ) { bytes [ out At ] = ( byte ) c ; out At ++ ; } else if ( c < NUM ) { bytes [ out At ] = ( byte ) ( ( ( c > > NUM ) & NUM ) | NUM ) ; bytes [ out At + NUM ] = ( byte ) ( ( c & NUM ) | NUM ) ; out At += NUM ; } else { bytes [ out At ] = ( byte ) ( ( ( c > > NUM ) & NUM ) | NUM ) ; bytes [ out At + NUM ] = ( byte ) ( ( ( c > > NUM ) & NUM ) | NUM ) ; bytes [ out At + NUM ] = ( byte ) ( ( c & NUM ) | NUM ) ; out At += NUM ; } } byte [ ] result = new byte [ out At ] ; System . arraycopy ( bytes , NUM , result , NUM , out At ) ; return result ; }
private boolean is Interleaved ( Component Sample Model sm ) { int num Bands = sample Model . get Num Bands ( ) ; if ( num Bands == NUM ) { return BOOL ; } int [ ] bank Indices = sm . get Bank Indices ( ) ; for ( int i = NUM ; i < num Bands ; i ++ ) { if ( bank Indices [ i ] != NUM ) { return BOOL ; } } int [ ] band Offsets = sm . get Band Offsets ( ) ; int min Offset = band Offsets [ NUM ] ; int max Offset = min Offset ; for ( int i = NUM ; i < num Bands ; i ++ ) { int offset = band Offsets [ i ] ; if ( offset < min Offset ) { min Offset = offset ; } if ( offset > max Offset ) { max Offset = offset ; } } if ( max Offset - min Offset >= sm . get Pixel Stride ( ) ) { return BOOL ; } return BOOL ; }
private int decode Size ( byte [ ] buffer ) { Big Integer bi = new Big Integer ( buffer ) ; int tmp Size = bi . int Value ( ) ; if ( tmp Size < NUM ) { logger . warning ( STRING + tmp Size + STRING + Integer . to Binary String ( tmp Size ) + STRING + Integer . to Hex String ( tmp Size ) ) ; } return tmp Size ; }
public Certificate Issuer Extension ( Boolean critical , Object value ) throws IO Exception { this . extension Id = PKIX Extensions . Certificate Issuer Id ; this . critical = critical . boolean Value ( ) ; this . extension Value = ( byte [ ] ) value ; Der Value val = new Der Value ( this . extension Value ) ; this . names = new General Names ( val ) ; }
@ Override public void on Sensor Selection Closed ( Dialog Fragment dialog ) { Log . d ( TAG , STRING ) ; sensor Selection Dialog = null ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String child Data ; String child Value ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; child . set Node Value ( STRING ) ; child Data = child . get Data ( ) ; assert Equals ( STRING , STRING , child Data ) ; child Value = child . get Node Value ( ) ; assert Equals ( STRING , STRING , child Value ) ; }
public String to XML ( ) { String Buffer str = new String Buffer ( ) ; str . append ( STRING ) ; str . append ( XML ROOT ELEMENT ) ; str . append ( STRING ) ; str . append ( STRING ) ; str . append ( XML ELEMENT QUALITY CODE ) ; str . append ( STRING ) ; str . append ( quality Code ) ; str . append ( STRING ) ; str . append ( XML ELEMENT QUALITY CODE ) ; str . append ( STRING ) ; if ( description != null ) { str . append ( STRING ) ; str . append ( XML ELEMENT QUALITY DESC ) ; str . append ( STRING ) ; str . append ( description ) ; str . append ( STRING ) ; str . append ( XML ELEMENT QUALITY DESC ) ; str . append ( STRING ) ; } str . append ( STRING ) ; str . append ( XML ROOT ELEMENT ) ; str . append ( STRING ) ; return str . to String ( ) ; }
public byte [ ] decrypt ( Faces Context context , byte [ ] securedata ) { try { byte [ ] mac Bytes = new byte [ mac Length ] ; System . arraycopy ( securedata , NUM , mac Bytes , NUM , mac Bytes . length ) ; byte [ ] iv = new byte [ iv Length ] ; System . arraycopy ( securedata , mac Bytes . length , iv , NUM , iv . length ) ; byte [ ] encdata = new byte [ securedata . length - mac Bytes . length - iv . length ] ; System . arraycopy ( securedata , mac Bytes . length + iv . length , encdata , NUM , encdata . length ) ; byte [ ] raw Key = convert Password To Key ( get Password To Secure State ( context ) ) ; Mac mac = get Mac ( raw Key ) ; mac . update ( iv ) ; mac . update ( encdata ) ; byte [ ] mac Bytes Calculated = mac . do Final ( ) ; if ( Arrays . equals ( mac Bytes , mac Bytes Calculated ) ) { Cipher cipher = get Block Cipher For Decryption ( raw Key , iv ) ; byte [ ] plaindata = cipher . do Final ( encdata ) ; return plaindata ; } else { if ( logger . is Loggable ( Level . WARNING ) ) { logger . warning ( STRING ) ; } return null ; } } catch ( Exception e ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , e . get Message ( ) , e . get Cause ( ) ) ; } throw new Runtime Exception ( e ) ; } }
public static Set < String > comma Delimited List To Set ( String str ) { Set < String > set = new Tree Set < > ( ) ; String [ ] tokens = comma Delimited List To String Array ( str ) ; set . add All ( Arrays . as List ( tokens ) ) ; return set ; }
public int hash Code ( ) { return Objects . hash ( file , princ , bound ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
protected void tag ( String tag , String name , String value , boolean close ) { spacing ( ) ; m out . print ( STRING ) ; m out . print ( tag ) ; m out . print ( STRING ) ; m out . print ( name ) ; m out . print ( STRING ) ; m out . print ( STRING ) ; escape String ( value ) ; m out . print ( STRING ) ; if ( close ) m out . print ( STRING ) ; m out . print ( STRING ) ; println ( ) ; if ( ! close ) { m tag Stack . add ( tag ) ; } }
public V remove ( Object key ) { int hash = hash ( key . hash Code ( ) ) ; Segment < K , V > s = segment For Hash ( hash ) ; return s == null ? null : s . remove ( key , hash , null ) ; }
public void add Attribute ( Attribute Info info ) { Attribute Info . remove ( attributes , info . get Name ( ) ) ; attributes . add ( info ) ; }
public static Result evaluate Model ( Multi Label Classifier h , Instances D ) throws Exception { return evaluate Model Prequential Basic ( h , D , NUM , NUM , STRING , STRING ) ; }
protected boolean is Valid State ( mx Cell State state ) { return BOOL ; }
public void test Find Spring Sun Directory Server With Limit ( ) { Ldap Proxy proxy = get Ldap Sun Directory Server ( ) ; List result = null ; int limit = NUM ; try { result = proxy . find ( get Ldap Search VO ( STRING , limit , STRING , STRING , null , Ldap Scope Constants . SCOPE SUBTREE ) ) ; } catch ( Exception e ) { } assert Not Null ( result ) ; if ( result != null ) { assert Equals ( limit , result . size ( ) ) ; } }
public static boolean delete Dir ( File dir ) { if ( dir == null ) { return BOOL ; } if ( dir . is Directory ( ) ) { String [ ] children = dir . list ( ) ; for ( String child : children ) { boolean success = delete Dir ( new File ( dir , child ) ) ; if ( ! success ) { return BOOL ; } } } return dir . delete ( ) ; }
private CIM Object Path create Filter ( Cim Managed Filter Info filter Info ) throws WBEM Exception { String Builder filter Name Builder = new String Builder ( ) ; filter Name Builder . append ( subscriptions Identifier ) ; filter Name Builder . append ( Cim Constants . PATH NAME DELIMITER ) ; filter Name Builder . append ( filter Info . get Name ( ) ) ; String filter Name = filter Name Builder . to String ( ) ; String impl NS = connection . get Impl Namespace ( ) ; CIM Property < ? > name Property = new CIM Property < String > ( Cim Constants . NAME KEY , CIM Data Type . STRING T , filter Name ) ; CIM Property < ? > src Namespace Prop = new CIM Property < String > ( Cim Constants . FILTER PROP SRC NAMESPACE , CIM Data Type . STRING T , impl NS ) ; CIM Property < ? > src Namespaces Prop = new CIM Property < String [ ] > ( Cim Constants . FILTER PROP SRC NAMESPACES , CIM Data Type . STRING ARRAY T , new String [ ] { impl NS } ) ; CIM Property < ? > query Lang Prop = new CIM Property < String > ( Cim Constants . FILTER PROP QUERY LANGUAGE , CIM Data Type . STRING T , filter Info . get Query Language ( ) ) ; CIM Property < ? > query Prop = new CIM Property < String > ( Cim Constants . FILTER PROP QUERY , CIM Data Type . STRING T , filter Info . get Query ( ) ) ; CIM Property < ? > [ ] filter Properties = new CIM Property [ ] { name Property , src Namespace Prop , src Namespaces Prop , query Lang Prop , query Prop } ; CIM Object Path filter Path = create Instance ( Cim Constants . CIM FILTER NAME , filter Name , filter Properties ) ; filter Paths . add ( filter Path ) ; return filter Path ; }
public static Array List < Array List < String > > file Tokenizer ( String fin ) { File file = new File ( fin ) ; Buffered Reader br ; File Reader fr ; Array List < String > lines = new Array List < String > ( ) ; try { fr = new File Reader ( file ) ; br = new Buffered Reader ( fr ) ; String line ; try { while ( ( line = br . read Line ( ) ) != null ) { if ( line . length ( ) > NUM ) { lines . add ( line ) ; } } } catch ( IO Exception ex ) { } } catch ( File Not Found Exception ex ) { } Array List < Array List < String > > tokenized list = new Array List < Array List < String > > ( ) ; for ( String s : lines ) { Array List < String > tokens = new Array List < String > ( ) ; String Tokenizer st = new String Tokenizer ( s , STRING ) ; while ( st . has More Tokens ( ) ) { tokens . add ( st . next Token ( ) ) ; } tokenized list . add ( tokens ) ; } return tokenized list ; }
public Activation Group Impl ( Activation Group ID id , Marshalled Object < ? > data ) throws Remote Exception { super ( id ) ; group ID = id ; unexport Object ( this , BOOL ) ; RMI Server Socket Factory ssf = new Server Socket Factory Impl ( ) ; Unicast Remote Object . export Object ( this , NUM , null , ssf ) ; if ( System . get Security Manager ( ) == null ) { try { System . set Security Manager ( new Security Manager ( ) ) ; } catch ( Exception e ) { throw new Remote Exception ( STRING , e ) ; } } }
static byte [ ] hash df ( Digest digest , byte [ ] seed Material , int seed Length ) { byte [ ] temp = new byte [ ( seed Length + NUM ) / NUM ] ; int len = temp . length / digest . get Digest Size ( ) ; int counter = NUM ; byte [ ] dig = new byte [ digest . get Digest Size ( ) ] ; for ( int i = NUM ; i <= len ; i ++ ) { digest . update ( ( byte ) counter ) ; digest . update ( ( byte ) ( seed Length > > NUM ) ) ; digest . update ( ( byte ) ( seed Length > > NUM ) ) ; digest . update ( ( byte ) ( seed Length > > NUM ) ) ; digest . update ( ( byte ) seed Length ) ; digest . update ( seed Material , NUM , seed Material . length ) ; digest . do Final ( dig , NUM ) ; int bytes To Copy = ( ( temp . length - i * dig . length ) > dig . length ) ? dig . length : ( temp . length - i * dig . length ) ; System . arraycopy ( dig , NUM , temp , i * dig . length , bytes To Copy ) ; counter ++ ; } if ( seed Length % NUM != NUM ) { int shift = NUM - ( seed Length % NUM ) ; int carry = NUM ; for ( int i = NUM ; i != temp . length ; i ++ ) { int b = temp [ i ] & NUM ; temp [ i ] = ( byte ) ( ( b > > > shift ) | ( carry << ( NUM - shift ) ) ) ; carry = b ; } } return temp ; }
protected boolean drop Message ( RTMP rtmp , int channel Id , IRTMP Event message ) { boolean drop = BOOL ; if ( rtmp . get Mode ( ) == RTMP . MODE SERVER ) { boolean is Video = BOOL ; if ( message instanceof Ping ) { final Ping ping Message = ( Ping ) message ; if ( ping Message . get Event Type ( ) == Ping . STREAM PLAYBUFFER CLEAR ) { final int channel = ( NUM + ( ( ping Message . get Value 2 ( ) - NUM ) * NUM ) ) ; rtmp . set Last Timestamp Mapping ( channel , null ) ; rtmp . set Last Timestamp Mapping ( channel + NUM , null ) ; rtmp . set Last Timestamp Mapping ( channel + NUM , null ) ; } return BOOL ; } if ( ( is Video = message instanceof Video Data ) || message instanceof Audio Data ) { if ( message . get Timestamp ( ) == NUM ) { return BOOL ; } boolean is Live = message . get Source Type ( ) == Constants . SOURCE TYPE LIVE ; long timestamp = ( message . get Timestamp ( ) & NUM ) ; Live Timestamp Mapping mapping = rtmp . get Last Timestamp Mapping ( channel Id ) ; long now = System . current Time Millis ( ) ; if ( mapping == null || timestamp < mapping . get Last Stream Time ( ) ) { log . debug ( STRING , now , timestamp ) ; mapping = new Live Timestamp Mapping ( now , timestamp ) ; rtmp . set Last Timestamp Mapping ( channel Id , mapping ) ; } mapping . set Last Stream Time ( timestamp ) ; long clock Time Of Message = mapping . get Clock Start Time ( ) + timestamp - mapping . get Stream Start Time ( ) ; long tardiness = clock Time Of Message - now ; if ( is Live && drop Live Future ) { tardiness = Math . abs ( tardiness ) ; } I Connection conn = Red 5 . get Connection Local ( ) ; if ( conn != null ) { tardiness -= conn . get Last Ping Time ( ) ; } else { log . debug ( STRING ) ; } if ( tardiness < base Tolerance ) { } else if ( tardiness > highest Tolerance ) { log . debug ( STRING , message ) ; if ( is Video ) { mapping . set Key Frame Needed ( BOOL ) ; } drop = BOOL ; } else { if ( is Video ) { Video Data video = ( Video Data ) message ; if ( video . get Frame Type ( ) == Frame Type . KEYFRAME ) { mapping . set Key Frame Needed ( BOOL ) ; } else if ( tardiness >= base Tolerance && tardiness < mid Tolerance ) { if ( video . get Frame Type ( ) == Frame Type . DISPOSABLE INTERFRAME ) { log . debug ( STRING , message ) ; drop = BOOL ; } } else if ( tardiness >= mid Tolerance && tardiness <= highest Tolerance ) { log . debug ( STRING , message ) ; drop = BOOL ; } } } } log . debug ( STRING , drop ) ; } return drop ; }
public static double vector Length ( double [ ] vector ) { double ret = NUM ; if ( vector == null ) return ret ; else { for ( double a Vector : vector ) { ret += Math . pow ( a Vector , NUM ) ; } } return ret ; }
public static String encode Query ( String url ) { Uri uri = Uri . parse ( url ) ; try { String query = uri . get Query ( ) ; String encoded Query = query != null ? URL Encoder . encode ( query , STRING ) : null ; URI tmp = new URI ( uri . get Scheme ( ) , uri . get Authority ( ) , uri . get Path ( ) , null , uri . get Fragment ( ) ) ; return tmp + ( encoded Query != null && encoded Query . length ( ) > NUM ? STRING + encoded Query : STRING ) ; } catch ( Unsupported Encoding Exception ignore ) { } catch ( URI Syntax Exception ignore ) { } return uri . to String ( ) ; }
public void define Fill Style ( int bitmap Id , Matrix matrix , boolean clipped ) throws IO Exception { fill Styles . add ( new Fill Style ( bitmap Id , matrix , clipped ) ) ; outstanding Changes = BOOL ; }
private static long write File ( String path , byte [ ] data ) { File Output Stream out = null ; try { out = new File Output Stream ( path ) ; out . write ( data ) ; return data . length ; } catch ( Exception e ) { Log . e ( TAG , STRING , e ) ; } finally { try { out . close ( ) ; } catch ( Exception e ) { Log . e ( TAG , STRING , e ) ; } } return - NUM ; }
public void fire Palette Event ( Component Event event ) { if ( local Hack List == null ) { return ; } palette = ( Container ) event . get Source ( ) ; int event Type = event . get ID ( ) ; for ( Component Listener listener : local Hack List ) { if ( event Type == Component Event . COMPONENT HIDDEN ) { listener . component Hidden ( event ) ; } else if ( event Type == Component Event . COMPONENT SHOWN ) { listener . component Shown ( event ) ; } } if ( event Type == Component Event . COMPONENT HIDDEN ) { palette = null ; } }
public void remove Entry ( Roster Entry e ) { log . debug ( STRING , e ) ; list . remove ( e ) ; e . remove Property Change Listener ( this ) ; set Dirty ( BOOL ) ; fire Property Change ( REMOVE , e , null ) ; }
protected void log Diagnostic ( String msg ) { if ( is Diagnostics Enabled ( ) ) { log Raw Diagnostic ( diagnostic Prefix + msg ) ; } }
public void add URL ( final String url ) { while ( current Index < history . size ( ) - NUM ) { history . remove ( current Index + NUM ) ; } history . add ( url ) ; current Index = history . size ( ) - NUM ; }
public static Value Timestamp convert Timestamp ( Timestamp x , Calendar calendar ) { if ( calendar == null ) { throw Db Exception . get Invalid Value Exception ( STRING , null ) ; } Calendar cal = ( Calendar ) calendar . clone ( ) ; cal . set Time In Millis ( x . get Time ( ) ) ; long date Value = date Value From Calendar ( cal ) ; long nanos = nanos From Calendar ( cal ) ; nanos += x . get Nanos ( ) % NUM ; return Value Timestamp . from Date Value And Nanos ( date Value , nanos ) ; }
private void process ( ) { Array List < Point 2 D > p List = new Array List < Point 2 D > ( ) ; Array List < Color > c List = new Array List < Color > ( ) ; while ( reader . get Pointer ( ) < reader . get Total Bit Len ( ) ) { Point 2 D p = get Point Coords ( ) ; p List . add ( p ) ; float [ ] cc = { NUM , NUM , NUM , NUM } ; for ( int z = NUM ; z < col Comp Count ; z ++ ) { cc [ z ] = reader . get Float ( bits Per Component ) ; } Color c = new Color ( cc [ NUM ] , cc [ NUM ] , cc [ NUM ] , cc [ NUM ] ) ; c List . add ( c ) ; } int total Rows = p List . size ( ) / vertices Per Row ; for ( int mm = NUM ; mm < ( total Rows - NUM ) ; mm ++ ) { int m Rows = mm * total Rows ; for ( int nn = NUM ; nn < ( vertices Per Row - NUM ) ; nn ++ ) { int nm = nn + m Rows ; int [ ] t = new int [ NUM ] ; t [ NUM ] = nm ; t [ NUM ] = t [ NUM ] = nm + NUM ; t [ NUM ] = t [ NUM ] = nm + vertices Per Row ; t [ NUM ] = nm + vertices Per Row + NUM ; for ( int z = NUM ; z < t . length ; z ++ ) { triangles . add ( p List . get ( t [ z ] ) ) ; tri Colors . add ( c List . get ( t [ z ] ) ) ; } } } }
private void element ( String segment ) { int index = segment . index Of ( STRING ) ; String prefix = null ; if ( index > NUM ) { prefix = segment . substring ( NUM , index ) ; segment = segment . substring ( index + NUM ) ; } String element = style . get Element ( segment ) ; prefixes . add ( prefix ) ; names . add ( element ) ; }
private void cleanup Handler ( Content Handler vh ) throws SAX Exception { for ( Prefix Mapping pm = prefix Mapping ; pm != null ; pm = pm . parent ) vh . end Prefix Mapping ( pm . prefix ) ; vh . end Document ( ) ; }
public Input Stream open Classfile ( String classname ) { try { URL Connection con = open Classfile 0 ( classname ) ; if ( con != null ) return con . get Input Stream ( ) ; } catch ( IO Exception e ) { } return null ; }
public void remove Ignored View ( View v ) { m Ignored Views . remove ( v ) ; }
private double fitness ( Solution solution , double [ ] weights ) { double max = Double . NEGATIVE INFINITY ; for ( int i = NUM ; i < solution . get Number Of Objectives ( ) ; i ++ ) { max = Math . max ( max , Math . max ( weights [ i ] , NUM ) * Math . abs ( solution . get Objective ( i ) - ideal Point [ i ] ) ) ; } if ( solution . violates Constraints ( ) ) { max += NUM ; } return max ; }
private boolean select Item By Name ( C Combo combo , String name , String [ ] c String ) { for ( int i = NUM ; i < c String . length ; i ++ ) { String prop Name = c String [ i ] ; if ( name . equals Ignore Case ( prop Name ) ) { combo . select ( i ) ; return BOOL ; } } return BOOL ; }
public void add File ( String path ) throws IO Exception { File new File = new File ( path ) ; if ( ! new File . exists ( ) ) { throw new IO Exception ( STRING + new File . get Absolute Path ( ) ) ; } if ( Delphi Utils . accept File ( new File . get Absolute Path ( ) ) ) { files . add ( new File ) ; } }
public void remove Limit Line ( Limit Line l ) { m Limit Lines . remove ( l ) ; }
public boolean is Content ( ) { return state . equals ( CONTENT ) ; }
protected boolean columns Differ ( Column current Column , Column desired Column ) { String desired Default = desired Column . get Default Value ( ) ; String current Default = current Column . get Default Value ( ) ; boolean defaults Equal = ( desired Default == null ) || desired Default . equals ( current Default ) ; boolean size Matters = database Info . has Size ( current Column . get Mapped Type Code ( ) ) && ( desired Column . get Size ( ) != null ) ; if ( ( database Info . get Target Jdbc Type ( desired Column . get Mapped Type Code ( ) ) != current Column . get Mapped Type Code ( ) ) || ( desired Column . is Required ( ) != current Column . is Required ( ) ) || ( size Matters && ! String Utils . equals ( desired Column . get Size ( ) , current Column . get Size ( ) ) ) || ! defaults Equal ) { return BOOL ; } else { return BOOL ; } }
public static int read UINT 16 ( Input Stream stream ) throws IO Exception { int result = stream . read ( ) ; result |= stream . read ( ) << NUM ; return result ; }
private void prepare Metadata Connection ( ) throws SQL Exception , Replicator Exception { if ( metadata Connection == null ) metadata Connection = data Source Impl . get Connection ( ) ; long current Time = System . current Time Millis ( ) ; if ( last Connection Time == NUM ) { last Connection Time = current Time ; } else if ( reconnect Timeout In Seconds > NUM && current Time - last Connection Time > reconnect Timeout In Seconds * NUM ) { data Source Impl . release Connection ( metadata Connection ) ; metadata Connection = data Source Impl . get Connection ( ) ; } }
public static String identify Line Delimiter ( String file Content ) { if ( file Content . matches ( STRING ) ) { return STRING ; } else if ( file Content . matches ( STRING ) ) { return STRING ; } else if ( file Content . matches ( STRING ) ) { return STRING ; } else { return STRING ; } }
public void add Item ( Force Item item ) { items . add ( item ) ; }
public static List < String > make Best Trail Elements For Trail ( Http Servlet Request request , Delegator delegator , String category Id , String product Id ) { List < String > trail = Category Worker . get Trail ( request ) ; List < String > trail Elements = null ; if ( category Id != null ) { if ( trail == null || trail . size ( ) < NUM ) { ; } else { List Iterator < String > li = trail . list Iterator ( trail . size ( ) ) ; while ( li . has Previous ( ) ) { String trail Cat Id = li . previous ( ) ; if ( category Id . equals ( trail Cat Id ) ) { trail Elements = Fast List . new Instance ( ) ; trail Elements . add ( category Id ) ; break ; } } if ( trail Elements == null ) { li = trail . list Iterator ( trail . size ( ) ) ; while ( li . has Previous ( ) ) { String trail Cat Id = li . previous ( ) ; if ( Category Worker . is Category Child Of ( request , trail Cat Id , category Id ) ) { trail Elements = Fast List . new Instance ( ) ; trail Elements . add ( trail Cat Id ) ; trail Elements . add ( category Id ) ; break ; } } } } } else { if ( trail == null || trail . size ( ) < NUM ) { ; } else { List Iterator < String > li = trail . list Iterator ( trail . size ( ) ) ; while ( li . has Previous ( ) ) { String trail Cat Id = li . previous ( ) ; if ( Category Worker . is Category Contains Product ( request , trail Cat Id , product Id ) ) { trail Elements = Fast List . new Instance ( ) ; trail Elements . add ( trail Cat Id ) ; break ; } } } } return trail Elements ; }
public boolean delete Attachment Point ( Datapath Id sw , OF Port port ) { Attachment Point ap = new Attachment Point ( sw , port , new Date ( NUM ) ) ; if ( this . old A Ps != null ) { Array List < Attachment Point > ap List = new Array List < Attachment Point > ( ) ; ap List . add All ( this . old A Ps ) ; int index = ap List . index Of ( ap ) ; if ( index > NUM ) { ap List . remove ( index ) ; this . old A Ps = ap List ; } } if ( this . attachment Points != null ) { Array List < Attachment Point > ap List = new Array List < Attachment Point > ( ) ; ap List . add All ( this . attachment Points ) ; int index = ap List . index Of ( ap ) ; if ( index > NUM ) { ap List . remove ( index ) ; this . attachment Points = ap List ; return BOOL ; } } return BOOL ; }
public void or ( Criteria criteria ) { ored Criteria . add ( criteria ) ; }
public void test Constructor 2 ( ) { Executor e = Executors . new Fixed Thread Pool ( NUM ) ; Submission Publisher < Integer > p = new Submission Publisher < Integer > ( e , NUM ) ; check Initial State ( p ) ; assert Same ( p . get Executor ( ) , e ) ; assert Equals ( NUM , p . get Max Buffer Capacity ( ) ) ; }
protected void parse Container And Screen ( Xml Resource Parser parser , long [ ] out ) { if ( HOTSEAT CONTAINER NAME . equals ( get Attribute Value ( parser , ATTR CONTAINER ) ) ) { out [ NUM ] = Launcher Settings . Favorites . CONTAINER HOTSEAT ; long rank = Long . parse Long ( get Attribute Value ( parser , ATTR RANK ) ) ; out [ NUM ] = ( rank < m Hotseat All Apps Rank ) ? rank : ( rank + NUM ) ; } else { out [ NUM ] = Launcher Settings . Favorites . CONTAINER DESKTOP ; out [ NUM ] = Long . parse Long ( get Attribute Value ( parser , ATTR SCREEN ) ) ; } }
public Default Tree Colouring sample Tree Colouring ( Tree tree , Colour Change Matrix colour Change Matrix , Meta Population mp ) { Default Tree Colouring colouring = new Default Tree Colouring ( NUM , tree ) ; double [ ] N = mp . get Population Sizes ( NUM ) ; double [ ] root Partials = prune ( tree , tree . get Root ( ) , colour Change Matrix , N ) ; double normalization = NUM ; for ( int i = NUM ; i < root Partials . length ; i ++ ) { normalization += colour Change Matrix . get Equilibrium ( i ) * root Partials [ i ] ; } sample Internal Nodes ( tree , tree . get Root ( ) , colour Change Matrix ) ; sample Branch Colourings ( colouring , tree , tree . get Root ( ) , colour Change Matrix ) ; double log P = calculate Log Probability Density ( colouring , tree , tree . get Root ( ) , colour Change Matrix , N ) - Math . log ( normalization ) ; colouring . set Log Probability Density ( log P ) ; return colouring ; }
public Stored List Iterator < T > establish List Scan ( boolean random scan ) { if ( is Empty ( ) ) return null ; Stored List Iterator < T > slh = SL Holder Pool . get ( ) ; Stored List Iterator < T > res = establish Pos ( random scan , slh ) ; if ( res == null ) slh . release ( ) ; return res ; }
public void drag ( long time , float x , float y , float delta X , float delta Y , float total X , float total Y ) { reset Resize Timeout ( BOOL ) ; delta X = Math Utils . flip Sign If ( delta X , Localization Utils . is Layout Rtl ( ) ) ; m New Tab Button . drag ( x , y ) ; if ( m Last Pressed Close Button != null ) { if ( ! m Last Pressed Close Button . drag ( x , y ) ) m Last Pressed Close Button = null ; } if ( m In Reorder Mode ) { float accumulated Delta X = x - m Last Reorder X ; if ( Math . abs ( accumulated Delta X ) >= NUM ) { if ( ! Localization Utils . is Layout Rtl ( ) ) { if ( delta X >= NUM ) { m Reorder State |= REORDER SCROLL RIGHT ; } else if ( delta X <= - NUM ) { m Reorder State |= REORDER SCROLL LEFT ; } } else { if ( delta X >= NUM ) { m Reorder State |= REORDER SCROLL LEFT ; } else if ( delta X <= - NUM ) { m Reorder State |= REORDER SCROLL RIGHT ; } } m Last Reorder X = x ; update Reorder Position ( accumulated Delta X ) ; } } else if ( ! m Scroller . is Finished ( ) ) { m Scroller . set Final X ( ( int ) ( m Scroller . get Final X ( ) + delta X ) ) ; } else { float fast Expand Delta = calculate Offset To Make Tab Visible ( m Interacting Tab , BOOL , BOOL , BOOL ) ; if ( m Interacting Tab != null && fast Expand Delta != NUM ) { if ( ( fast Expand Delta > NUM && delta X > NUM ) || ( fast Expand Delta < NUM && delta X < NUM ) ) { m Scroller . start Scroll ( m Scroll Offset , NUM , ( int ) fast Expand Delta , NUM , time , EXPAND DURATION MS ) ; } } else { update Scroll Offset Position ( ( int ) ( m Scroll Offset + delta X ) ) ; } } if ( ! m In Reorder Mode ) { final float abs Total X = Math . abs ( total X ) ; final float abs Total Y = Math . abs ( total Y ) ; if ( total Y > m Reorder Move Start Threshold && abs Total X < m Reorder Move Start Threshold * NUM && ( abs Total X > EPSILON && ( abs Total Y / abs Total X ) > TAN OF REORDER ANGLE START THRESHOLD ) ) { start Reorder Mode ( time , x , x - total X ) ; } } if ( ! m In Reorder Mode ) m Interacting Tab = null ; m Update Host . request Update ( ) ; }
public static String decode ( final String str , final String charset Name ) throws Unsupported Encoding Exception { return decode ( new String ( str . get Bytes ( charset Name ) , STRING ) ) ; }
public Server Commit acquire ( Operation Entry entry , Server Session Context session , long timestamp ) { Server Commit commit = pool . poll ( ) ; if ( commit == null ) { commit = new Server Commit ( this , log ) ; } commit . reset ( entry , session , timestamp ) ; return commit ; }
public static synchronized double make Noise ( double mean , double standard Diviation ) { return random . next Gaussian ( ) * Math . sqrt ( standard Diviation ) + mean ; }
void shutdown ( ) { try { ssl Engine . close Inbound ( ) ; } catch ( SSL Exception e ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + e . get Message ( ) + STRING + ses + STRING ) ; } }
@ Override public synchronized void remove Instance Listener ( Instance Listener tsl ) { m instance Listeners . remove ( tsl ) ; }
public Map < String , Map < String , Flt > > retrieve Terms ( int doc Num ) throws IO Exception { return retrieve Terms ( doc Num , null ) ; }
boolean alias ( String src , String target ) { if ( src == null ) return BOOL ; Plugin Holder < T > a = registry . get ( src ) ; if ( a == null ) return BOOL ; Plugin Holder < T > b = registry . get ( target ) ; if ( b != null ) return BOOL ; registry . put ( target , a ) ; return BOOL ; }
public static < T extends Char Sequence > T each Match ( T self , Pattern pattern , @ Closure Params ( value = From String . class , options = { STRING , STRING } ) Closure closure ) { each Match ( self . to String ( ) , pattern , closure ) ; return self ; }
public void switch Single Row ( ) { if ( m only Multi Row ) return ; card Layout . first ( card Panel ) ; m single Row = BOOL ; dynamic Display ( NUM ) ; }
private boolean is String Continuation ( int offset ) { int next Non WS Char Position = f Scanner . find Non Whitespace Backward In Any Partition ( offset - NUM , Java Heuristic Scanner . UNBOUND ) ; try { if ( next Non WS Char Position != Java Heuristic Scanner . NOT FOUND && f Document . get Char ( next Non WS Char Position ) == STRING ) return BOOL ; else return BOOL ; } catch ( Bad Location Exception e ) { Log . error ( Java Indenter . class , e ) ; return BOOL ; } }
final void push ( final Object object ) { stack . add ( object ) ; }
public void make Immutable ( ) { mutable = BOOL ; }
public static < K , V > V atomic Get Or Create ( Concurrent Map < K , V > map , K key , Callable < V > ctor ) { V value = map . get ( key ) ; if ( value == null ) { try { value = ctor . call ( ) ; } catch ( Exception e ) { throw new Runtime Exception ( STRING , e ) ; } V existing = map . put If Absent ( key , value ) ; if ( existing != null ) { return existing ; } } return value ; }
public void test Mixed ( ) { Argument Parser parser = new Argument Parser ( new String [ ] { STRING , STRING , STRING , STRING , STRING } , BOOL ) ; Iterator < String > iter = parser . iterator ( ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Iterator At End ( iter ) ; parser = new Argument Parser ( new String [ ] { STRING , STRING , STRING , STRING , STRING } , BOOL ) ; iter = parser . iterator ( ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Iterator At End ( iter ) ; parser = new Argument Parser ( new String [ ] { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } , BOOL ) ; iter = parser . iterator ( ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Equals ( STRING , iter . next ( ) ) ; assert Iterator At End ( iter ) ; }
private void create Metric Chart Panel ( int metric , Dataset Generator dataset Generator , List < GC Stats Chart Panel > list ) { Changing Category Dataset With TTG dataset = dataset Generator . new Category Dataset With TTG ( metric , BOOL ) ; GC Stats Chart Panel panel = new Metric Chart Panel ( CHART PREFIX + Dataset Generator . get Metric Name ( metric ) , Dataset Generator . get Unit Name ( metric ) , dataset , locker ) ; list . add ( panel ) ; }
public void test Constr String With Exponent Without Point 2 ( ) { String a = STRING ; int a Scale = NUM ; Big Integer bA = new Big Integer ( STRING ) ; Big Decimal a Number = new Big Decimal ( a ) ; assert Equals ( STRING , bA , a Number . unscaled Value ( ) ) ; assert Equals ( STRING , a Scale , a Number . scale ( ) ) ; }
public Default Client Web Request Builder cookie ( String name , String value ) { return cookie ( new Http Cookie ( name , value ) ) ; }
private void add New Tilesets ( Map map ) throws IO Exception { for ( Tile Set set : map . get Tile Sets ( ) ) { set By Name . put ( set . get Tilebmp File ( ) , set ) ; } for ( String name : mapping . get New Sets ( ) ) { if ( name . equals ( STRING ) ) { continue ; } if ( ! set By Name . contains Key ( name ) ) { Tile Set set = new Tile Set ( ) ; set . set Name ( construct Tileset Name ( name ) ) ; Basic Tile Cutter cutter = new Basic Tile Cutter ( NUM , NUM , NUM , NUM ) ; set . import Tile Bitmap ( name , cutter ) ; set By Name . put ( name , set ) ; map . add Tileset ( set ) ; } } }
public static List < Css Meta Data < ? extends Styleable , ? > > create Css Meta Data List ( List < Css Meta Data < ? extends Styleable , ? > > base List , Css Meta Data < ? extends Styleable , ? > ... meta Data ) { List < Css Meta Data < ? extends Styleable , ? > > styleables = new Array List < > ( base List ) ; styleables . add All ( Arrays . as List ( meta Data ) ) ; return Collections . unmodifiable List ( styleables ) ; }
private String diff lines To Chars Munge ( String text , List < String > line Array , Map < String , Integer > line Hash ) { int line Start = NUM ; int line End = - NUM ; String line ; String Builder chars = new String Builder ( ) ; while ( line End < text . length ( ) - NUM ) { line End = text . index Of ( STRING , line Start ) ; if ( line End == - NUM ) { line End = text . length ( ) - NUM ; } line = text . substring ( line Start , line End + NUM ) ; line Start = line End + NUM ; if ( line Hash . contains Key ( line ) ) { chars . append ( String . value Of ( ( char ) ( int ) line Hash . get ( line ) ) ) ; } else { line Array . add ( line ) ; line Hash . put ( line , line Array . size ( ) - NUM ) ; chars . append ( String . value Of ( ( char ) ( line Array . size ( ) - NUM ) ) ) ; } } return chars . to String ( ) ; }
public void add Extension ( ASN 1 Object Identifier oid , boolean critical , byte [ ] value ) { if ( extensions . contains Key ( oid ) ) { throw new Illegal Argument Exception ( STRING + oid + STRING ) ; } ext Ordering . add Element ( oid ) ; extensions . put ( oid , new Extension ( oid , critical , new DER Octet String ( value ) ) ) ; }
public void update Client Cookies ( Boolean client Cookies ) throws Security Exception { check Write Access ( ) ; boolean has Access = Config Web Util . has Access ( config , Security Manager . TYPE SETTING ) ; if ( ! has Access ) throw new Security Exception ( STRING ) ; Element scope = get Root Element ( STRING ) ; scope . set Attribute ( STRING , Caster . to String ( client Cookies , STRING ) ) ; }
public double [ ] subseries By Copy ( double [ ] series , int start , int end ) throws Index Out Of Bounds Exception { if ( ( start > end ) || ( start < NUM ) || ( end > series . length ) ) { throw new Index Out Of Bounds Exception ( STRING + series . length + STRING + start + STRING + String . value Of ( end - start ) ) ; } return Arrays . copy Of Range ( series , start , end ) ; }
public static String create Temp File ( final String ... lines ) throws Exception { final File f = File . create Temp File ( STRING , STRING ) ; f . delete On Exit ( ) ; try ( final File Writer w = new File Writer ( f ) ) { for ( final String s : lines ) { w . write ( s + System . get Property ( STRING ) ) ; } } return f . get Absolute Path ( ) ; }
public static void read Skel ( Buffered Reader reader ) throws IO Exception { Vector lines = new Vector ( ) ; String Buffer section = new String Buffer ( ) ; String ln ; while ( ( ln = reader . read Line ( ) ) != null ) { if ( ln . starts With ( STRING ) ) { lines . add Element ( section . to String ( ) ) ; section . set Length ( NUM ) ; } else { section . append ( ln ) ; section . append ( NL ) ; } } if ( section . length ( ) > NUM ) lines . add Element ( section . to String ( ) ) ; if ( lines . size ( ) != size ) { Out . error ( Error Messages . WRONG SKELETON ) ; throw new Generator Exception ( ) ; } line = new String [ size ] ; for ( int i = NUM ; i < size ; i ++ ) line [ i ] = ( String ) lines . element At ( i ) ; }
@ Override public long read Double ( String file Path , long offset ) { File Channel file Channel = update Cache ( file Path ) ; Byte Buffer byte Bffer = read ( file Channel , Carbon Common Constants . LONG SIZE IN BYTE , offset ) ; return byte Bffer . get Long ( ) ; }
public Lua Compiler ( Compiler Settings settings ) { this . settings = Objects . require Non Null ( settings ) ; }
@ Suppress Warnings ( STRING ) public void test put Get 3 ( ) { final List < I Binding Set [ ] > in = new Linked List < I Binding Set [ ] > ( ) ; { final I Variable < ? > x = Var . var ( STRING ) ; final I Variable < ? > y = Var . var ( STRING ) ; final I Variable < ? > z = Var . var ( STRING ) ; { final List < I Binding Set > t = new Linked List < I Binding Set > ( ) ; { final List Binding Set b = new List Binding Set ( ) ; b . set ( x , new Constant < IV > ( term Id ) ) ; b . set ( y , new Constant < IV > ( term Id 2 ) ) ; t . add ( b ) ; } { final List Binding Set b = new List Binding Set ( ) ; b . set ( x , new Constant < IV > ( term Id 2 ) ) ; b . set ( y , new Constant < IV > ( inline IV ) ) ; b . set ( z , new Constant < IV > ( blob IV ) ) ; t . add ( b ) ; } in . add ( t . to Array ( new I Binding Set [ NUM ] ) ) ; } } final String solution Set = get Name ( ) ; try { solution Sets Manager . get Solutions ( solution Set ) ; fail ( STRING + Illegal State Exception . class ) ; } catch ( Illegal State Exception ex ) { if ( log . is Info Enabled ( ) ) log . info ( STRING + ex ) ; } solution Sets Manager . put Solutions ( solution Set , new Closeable Iterator Wrapper < I Binding Set [ ] > ( in . iterator ( ) ) ) ; final I Closeable Iterator < I Binding Set [ ] > out = solution Sets Manager . get Solutions ( solution Set ) ; assert Same Solutions Any Order ( flatten ( in . iterator ( ) ) , out ) ; }
public static void show Address On Map ( Context m Context , String address ) { address = address . replace ( STRING , STRING ) ; Intent geo Intent = new Intent ( Intent . ACTION VIEW , Uri . parse ( STRING + address ) ) ; m Context . start Activity ( geo Intent ) ; }
public Criteria create Criteria ( ) { Criteria criteria = create Criteria Internal ( ) ; if ( ored Criteria . size ( ) == NUM ) { ored Criteria . add ( criteria ) ; } return criteria ; }
public void test Copy Map ( ) { Serializer serializer = new Serializer ( ) ; Map < String , String > map = new Hash Map < > ( ) ; map . put ( STRING , STRING ) ; map . put ( STRING , STRING ) ; Map < String , String > result = serializer . copy ( map ) ; assert Equals ( map , result ) ; assert Equals ( map . get ( STRING ) , STRING ) ; assert Equals ( map . get ( STRING ) , STRING ) ; }
private void find Bounced Instrument ( ) { for ( final Receipt Instrument Info instrument Info : instrument Details ) if ( instrument Info . is Bounced ( ) ) bounced Instruments . add ( instrument Info ) ; }
public static Set < String > convert Array To Set ( String [ ] array ) { Set < String > result Set = new Hash Set < String > ( array . length ) ; Collections . add All ( result Set , array ) ; return result Set ; }
public Parse File ( byte [ ] data ) { this ( null , data , null ) ; }
private Storage Policy Entity create Storage Policy Entity ( Namespace Entity namespace Entity , String storage Policy Name , Storage Entity storage Entity , Storage Entity destination Storage Entity , Storage Policy Rule Type Entity storage Policy Rule Type Entity , Integer storage Policy Rule Value , Business Object Definition Entity business Object Definition Entity , String business Object Format Usage , File Type Entity file Type Entity , Storage Policy Status Entity storage Policy Status Entity , Integer storage Policy Version , Boolean storage Policy Latest Version ) { Storage Policy Entity storage Policy Entity = new Storage Policy Entity ( ) ; storage Policy Entity . set Namespace ( namespace Entity ) ; storage Policy Entity . set Name ( storage Policy Name ) ; storage Policy Entity . set Storage ( storage Entity ) ; storage Policy Entity . set Destination Storage ( destination Storage Entity ) ; storage Policy Entity . set Storage Policy Rule Type ( storage Policy Rule Type Entity ) ; storage Policy Entity . set Storage Policy Rule Value ( storage Policy Rule Value ) ; storage Policy Entity . set Business Object Definition ( business Object Definition Entity ) ; if ( String Utils . is Not Blank ( business Object Format Usage ) ) { storage Policy Entity . set Usage ( business Object Format Usage ) ; } storage Policy Entity . set File Type ( file Type Entity ) ; storage Policy Entity . set Status ( storage Policy Status Entity ) ; storage Policy Entity . set Version ( storage Policy Version ) ; storage Policy Entity . set Latest Version ( storage Policy Latest Version ) ; return storage Policy Dao . save And Refresh ( storage Policy Entity ) ; }
public void draw Std Dev Line ( Graphics 2 D g2 d , Long std Dev Val , long y Max Mark , Color color ) { float std Dev Perc = std Dev Val / ( float ) y Max Mark ; g2 d . set Color ( color ) ; int y Pos Of Line = this . graph Bottom - Math . round ( this . graph Height * std Dev Perc ) ; g2 d . draw Line ( this . graph Left , y Pos Of Line , this . graph Right , y Pos Of Line ) ; }
public Sample Vcpc ( Independence Test independence Test ) { if ( independence Test == null ) { throw new Null Pointer Exception ( ) ; } if ( ! ( independence Test instanceof Ind Test Fisher Z ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . independence Test = independence Test ; this . data Set = ( Data Set ) independence Test . get Data ( ) ; this . variables = data Set . get Variables ( ) ; this . cov Matrix = new Covariance Matrix ( data Set ) ; List < Node > nodes = cov Matrix . get Variables ( ) ; this . index Map = index Map ( variables ) ; this . name Map = map Names ( variables ) ; this . nodes To Variables = new Hash Map < > ( ) ; this . variables To Nodes = new Hash Map < > ( ) ; }
private int next Available Idx ( Collection < Integer > started Grids , int max Top Size , Random rnd ) { while ( BOOL ) { int idx = rnd . next Int ( max Top Size ) ; if ( ! started Grids . contains ( idx ) ) return idx ; } }
public boolean has Color ( ) { return type String . contains ( COLOR ) ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
public Clearance Matrix ( int p class count , Brd Layer Structure p layer structure , String [ ] p name arr ) { class count = Math . max ( p class count , NUM ) ; layer structure = p layer structure ; clearance rows = new Clearance Matrix Row [ class count ] ; for ( int index = NUM ; index < class count ; ++ index ) { clearance rows [ index ] = new Clearance Matrix Row ( this , p name arr [ index ] ) ; } max value on layer = new int [ layer structure . size ( ) ] ; }
public static char [ ] concat ( char [ ] base , char [ ] other , int append Count ) { final int length = base . length ; char [ ] new Array = copy From ( base , base . length + append Count ) ; System . arraycopy ( other , NUM , new Array , length , append Count ) ; return new Array ; }
public Array Real Vector ( Array Real Vector v1 , Array Real Vector v2 ) { data = new double [ v1 . data . length + v2 . data . length ] ; System . arraycopy ( v1 . data , NUM , data , NUM , v1 . data . length ) ; System . arraycopy ( v2 . data , NUM , data , v1 . data . length , v2 . data . length ) ; }
void add Class List ( String class List Filename ) { if ( class List Filename . length ( ) > NUM ) { set Option ( STRING , class List Filename ) ; load Class Names ( class List Filename ) ; } else { throw new Illegal Argument Exception ( STRING ) ; } }
private Start build ( Start event ) { Named Node Map list = event . get Attributes ( ) ; int length = list . get Length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { Node node = list . item ( i ) ; Attribute value = attribute ( node ) ; if ( ! value . is Reserved ( ) ) { event . add ( value ) ; } } return event ; }
public Bytes To Name Canonicalizer make Child ( boolean canonicalize , boolean intern ) { return new Bytes To Name Canonicalizer ( this , intern , hash Seed , table Info . get ( ) ) ; }
public static String encode String ( String s ) { return new String ( encode ( s . get Bytes ( ) ) ) ; }
public Instances retrieve Instances ( ) throws Exception { return retrieve Instances ( m Query ) ; }
void extract ( Input Stream in , String files [ ] ) throws IO Exception { Zip Input Stream zis = new Zip Input Stream ( in ) ; Zip Entry e ; Set < Zip Entry > dirs = new Dir Set ( ) ; while ( ( e = zis . get Next Entry ( ) ) != null ) { if ( files == null ) { dirs . add ( extract File ( zis , e ) ) ; } else { String name = e . get Name ( ) ; for ( String file : files ) { if ( name . starts With ( file ) ) { dirs . add ( extract File ( zis , e ) ) ; break ; } } } } update Last Modified Time ( dirs ) ; }
private int clamp Mag ( int value , int abs Min , int abs Max ) { final int abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }
public void test Get Accent Colors By Name ( ) { try { for ( String name : Material Palettes . COLORS WITH ACCENT NAMES ) { List < Integer > color List = Material Palettes . get Accent Colors By Name ( name ) ; assert Equals ( Material Palettes . ACCENT COLOR LEVELS . length , color List . size ( ) ) ; } } catch ( Illegal Access Exception iae ) { fail ( ) ; } }
private static void draw Chunk ( Image image , Graphics g , boolean stretch , int dx 1 , int dy 1 , int dx 2 , int dy 2 , int sx 1 , int sy 1 , int sx 2 , int sy 2 , boolean x Direction ) { if ( dx 2 - dx 1 <= NUM || dy 2 - dy 1 <= NUM || sx 2 - sx 1 <= NUM || sy 2 - sy 1 <= NUM ) { return ; } if ( stretch ) { g . draw Image ( image , dx 1 , dy 1 , dx 2 , dy 2 , sx 1 , sy 1 , sx 2 , sy 2 , null ) ; } else { int x Size = sx 2 - sx 1 ; int y Size = sy 2 - sy 1 ; int delta X ; int delta Y ; if ( x Direction ) { delta X = x Size ; delta Y = NUM ; } else { delta X = NUM ; delta Y = y Size ; } while ( dx 1 < dx 2 && dy 1 < dy 2 ) { int new DX 2 = Math . min ( dx 2 , dx 1 + x Size ) ; int new DY 2 = Math . min ( dy 2 , dy 1 + y Size ) ; g . draw Image ( image , dx 1 , dy 1 , new DX 2 , new DY 2 , sx 1 , sy 1 , sx 1 + new DX 2 - dx 1 , sy 1 + new DY 2 - dy 1 , null ) ; dx 1 += delta X ; dy 1 += delta Y ; } } }
private void init Sign ( ) { mess Digest Trees . reset ( ) ; GMSS Private Key Parameters gmss Private Key = ( GMSS Private Key Parameters ) key ; if ( gmss Private Key . is Used ( ) ) { throw new Illegal State Exception ( STRING ) ; } if ( gmss Private Key . get Index ( NUM ) >= gmss Private Key . get Num Leafs ( NUM ) ) { throw new Illegal State Exception ( STRING ) ; } this . gmss PS = gmss Private Key . get Parameters ( ) ; this . num Layer = gmss PS . get Num Of Layers ( ) ; byte [ ] seed = gmss Private Key . get Current Seeds ( ) [ num Layer - NUM ] ; byte [ ] OTS Seed = new byte [ md Length ] ; byte [ ] dummy = new byte [ md Length ] ; System . arraycopy ( seed , NUM , dummy , NUM , md Length ) ; OTS Seed = gmss Random . next Seed ( dummy ) ; this . ots = new Winternitz OT Signature ( OTS Seed , digest Provider . get ( ) , gmss PS . get Winternitz Parameter ( ) [ num Layer - NUM ] ) ; byte [ ] [ ] [ ] help Current Auth Paths = gmss Private Key . get Current Auth Paths ( ) ; current Auth Paths = new byte [ num Layer ] [ ] [ ] ; for ( int j = NUM ; j < num Layer ; j ++ ) { current Auth Paths [ j ] = new byte [ help Current Auth Paths [ j ] . length ] [ md Length ] ; for ( int i = NUM ; i < help Current Auth Paths [ j ] . length ; i ++ ) { System . arraycopy ( help Current Auth Paths [ j ] [ i ] , NUM , current Auth Paths [ j ] [ i ] , NUM , md Length ) ; } } index = new int [ num Layer ] ; System . arraycopy ( gmss Private Key . get Index ( ) , NUM , index , NUM , num Layer ) ; byte [ ] help Subtree Root Sig ; subtree Root Sig = new byte [ num Layer - NUM ] [ ] ; for ( int i = NUM ; i < num Layer - NUM ; i ++ ) { help Subtree Root Sig = gmss Private Key . get Subtree Root Sig ( i ) ; subtree Root Sig [ i ] = new byte [ help Subtree Root Sig . length ] ; System . arraycopy ( help Subtree Root Sig , NUM , subtree Root Sig [ i ] , NUM , help Subtree Root Sig . length ) ; } gmss Private Key . mark Used ( ) ; }
private static void decode Edifact Segment ( Bit Source bits , String Builder result ) { do { if ( bits . available ( ) <= NUM ) { return ; } for ( int i = NUM ; i < NUM ; i ++ ) { int edifact Value = bits . read Bits ( NUM ) ; if ( edifact Value == NUM ) { int bits Left = NUM - bits . get Bit Offset ( ) ; if ( bits Left != NUM ) { bits . read Bits ( bits Left ) ; } return ; } if ( ( edifact Value & NUM ) == NUM ) { edifact Value |= NUM ; } result . append ( ( char ) edifact Value ) ; } } while ( bits . available ( ) > NUM ) ; }
public void write ( byte [ ] b , int offset , int length ) throws IO Exception { out . write ( b , offset , length ) ; }
public Sample Set ( Data Input Stream is ) throws IO Exception { int num Samples ; sample Info = new Sample Info ( is ) ; num Samples = is . read Int ( ) ; this . samples = new Sample [ num Samples ] ; for ( int i = NUM ; i < num Samples ; i ++ ) { samples [ i ] = Sample . load Binary ( is ) ; } }
public void close ( ) { running = BOOL ; synchronized ( hist Data ) { hist Data . notify ( ) ; } }
public SQ Lite Database Configuration ( String path , @ SQ Lite Database . Open Flags int open Flags ) { if ( path == null ) { throw new Illegal Argument Exception ( STRING ) ; } this . path = path ; label = strip Path For Logs ( path ) ; this . open Flags = open Flags ; max Sql Cache Size = NUM ; locale = Locale . get Default ( ) ; }
private void print Properties ( Properties properties ) throws IO Exception { String Writer string Buffer = new String Writer ( ) ; Buffered Reader reader = null ; properties . store ( string Buffer , null ) ; try { reader = new Buffered Reader ( new String Reader ( string Buffer . to String ( ) ) ) ; reader . read Line ( ) ; String line = null ; while ( ( line = reader . read Line ( ) ) != null ) { writer . print ( STRING ) ; writer . println ( line ) ; } } finally { if ( reader != null ) { reader . close ( ) ; } } }
public static < T > Range < T > value Of ( String s , Class < T > clazz ) { char lbm = s . char At ( NUM ) ; if ( lbm != STRING && lbm != STRING ) throw new Illegal Argument Exception ( s ) ; char ubm = s . char At ( s . length ( ) - NUM ) ; if ( ubm != STRING && ubm != STRING ) throw new Illegal Argument Exception ( s ) ; Bound Type lbt = lbm == STRING ? Bound Type . CLOSED : Bound Type . OPEN ; Bound Type ubt = ubm == STRING ? Bound Type . CLOSED : Bound Type . OPEN ; s = s . substring ( NUM , s . length ( ) - NUM ) ; String [ ] parts = s . split ( STRING ) ; String lbs = parts [ NUM ] ; String ubs = parts [ NUM ] ; T lower Bound = lbs . equals ( STRING ) ? null : bound Value ( lbs , clazz ) ; T upper Bound = ubs . equals ( STRING ) ? null : bound Value ( ubs , clazz ) ; return range ( lower Bound , lbt , upper Bound , ubt ) ; }
public static Double Vector dchisq ( double x , Double Vector ncp ) { int n = ncp . size ( ) ; Double Vector d = new Double Vector ( n ) ; double xh = Math . sqrt ( x ) ; double mean ; for ( int i = NUM ; i < n ; i ++ ) { mean = Math . sqrt ( ncp . get ( i ) ) ; if ( ncp . get ( i ) == NUM ) d . set ( i , dchisq ( x ) ) ; else d . set ( i , ( dnorm ( xh - mean ) + dnorm ( - xh - mean ) ) / ( NUM * xh ) ) ; } return d ; }
@ Override public void add Property Change Listener ( Property Change Listener listener ) { property Change Support . add Property Change Listener ( listener ) ; }
public void remove All Baud Rate Query Callbacks ( ) { baud Rate Query Callbacks . clear ( ) ; }
public void add ( Abstract Option option ) { add ( options . size ( ) , option ) ; }
private void load Vertices And Relatives ( ) { List < Cn A Tree Element > element List = new Linked List < Cn A Tree Element > ( ) ; for ( I Graph Element Loader loader : get Loader List ( ) ) { loader . set Cna Tree Element Dao ( get Cna Tree Element Dao ( ) ) ; element List . add All ( loader . load Elements ( ) ) ; } for ( Cn A Tree Element element : element List ) { graph . add Vertex ( element ) ; if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING + element . get Title ( ) ) ; } uuid Map . put ( element . get Uuid ( ) , element ) ; } for ( Cn A Tree Element parent : element List ) { Set < Cn A Tree Element > children = parent . get Children ( ) ; for ( Cn A Tree Element child : children ) { create Parent Child Edge ( parent , child ) ; } } }
private boolean has Non Special Attribute ( Collection < String > keys ) { for ( String attr : keys ) { if ( ! attr . starts With ( STRING ) ) { return BOOL ; } } return BOOL ; }
public static final void shuffle ( double [ ] a , int start , int len , Random r ) { for ( int i = start + len ; i > NUM ; -- i ) { double t = a [ i ] ; int j = r . next Int ( i ) ; a [ i ] = a [ j ] ; a [ j ] = t ; } }
public boolean is Parity Correct ( byte [ ] [ ] shards , int first Byte , int byte Count , byte [ ] temp Buffer ) { check Buffers And Sizes ( shards , first Byte , byte Count ) ; if ( temp Buffer . length < first Byte + byte Count ) { throw new Illegal Argument Exception ( STRING ) ; } byte [ ] [ ] to Check = new byte [ parity Shard Count ] [ ] ; System . arraycopy ( shards , data Shard Count , to Check , NUM , parity Shard Count ) ; return coding Loop . check Some Shards ( parity Rows , shards , data Shard Count , to Check , parity Shard Count , first Byte , byte Count , temp Buffer ) ; }
public static void write Stream ( Input Stream in , File file ) throws IO Exception { File Output Stream out = new File Output Stream ( file ) ; try { transfer ( in , out ) ; } finally { try { out . flush ( ) ; } finally { out . close ( ) ; } } }
private static native long create Entity Parser ( long parent Pointer , String context ) ;
public void fire Property Change ( String property Name , byte old Value , byte new Value ) { if ( change Support == null || old Value == new Value ) { return ; } fire Property Change ( property Name , Byte . value Of ( old Value ) , Byte . value Of ( new Value ) ) ; }
private int adjust Offset For Unit Tests ( int offset ) { if ( System . get Property ( STRING ) == null ) return offset ; else return NUM ; }
private boolean check Touch Slop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL ; } final boolean check Horizontal = m Callback . get View Horizontal Drag Range ( child ) > NUM ; final boolean check Vertical = m Callback . get View Vertical Drag Range ( child ) > NUM ; if ( check Horizontal && check Vertical ) { return dx * dx + dy * dy > m Touch Slop * m Touch Slop ; } else if ( check Horizontal ) { return Math . abs ( dx ) > m Touch Slop ; } else if ( check Vertical ) { return Math . abs ( dy ) > m Touch Slop ; } return BOOL ; }
public static boolean is Aix ( ) { return os Name . index Of ( STRING ) > - NUM ; }
private double test Fit ( double [ ] x , double [ ] test , Distribution dist ) throws Arithmetic Exception { for ( int i = NUM ; i < test . length ; i ++ ) { test [ i ] = dist . cdf ( x [ i ] ) ; if ( test [ i ] > NUM ) { test [ i ] = NUM ; } if ( test [ i ] < NUM ) { test [ i ] = NUM ; } if ( Double . is Na N ( test [ i ] ) ) { throw new Arithmetic Exception ( STRING + dist . to String ( ) ) ; } } Arrays . sort ( test ) ; return Kolmogorov Smirnov Test . simple Test ( test ) ; }
public boolean supports SQL ( ) { return BOOL ; }
private static Boolean is Valid IPV 4 ( final String ip Address ) { boolean status = BOOL ; if ( String Utils . is Not Empty ( ip Address ) ) { status = Inet Address Utils . is I Pv 4 Address ( ip Address ) ; } return status ; }
private int decrypt Block With IV ( byte [ ] in , int in Off , byte [ ] out , int out Off ) throws Data Length Exception , Illegal State Exception { if ( ( in Off + block Size ) > in . length ) { throw new Data Length Exception ( STRING ) ; } if ( ( out Off + block Size ) > out . length ) { throw new Data Length Exception ( STRING ) ; } if ( count == NUM ) { for ( int n = NUM ; n < block Size ; n ++ ) { FR [ n ] = in [ in Off + n ] ; } cipher . process Block ( FR , NUM , FRE , NUM ) ; count += block Size ; return NUM ; } else if ( count == block Size ) { System . arraycopy ( in , in Off , tmp , NUM , block Size ) ; System . arraycopy ( FR , NUM , FR , NUM , block Size - NUM ) ; FR [ block Size - NUM ] = tmp [ NUM ] ; FR [ block Size - NUM ] = tmp [ NUM ] ; cipher . process Block ( FR , NUM , FRE , NUM ) ; for ( int n = NUM ; n < block Size - NUM ; n ++ ) { out [ out Off + n ] = encrypt Byte ( tmp [ n + NUM ] , n ) ; } System . arraycopy ( tmp , NUM , FR , NUM , block Size - NUM ) ; count += NUM ; return block Size - NUM ; } else if ( count >= block Size + NUM ) { System . arraycopy ( in , in Off , tmp , NUM , block Size ) ; out [ out Off + NUM ] = encrypt Byte ( tmp [ NUM ] , block Size - NUM ) ; out [ out Off + NUM ] = encrypt Byte ( tmp [ NUM ] , block Size - NUM ) ; System . arraycopy ( tmp , NUM , FR , block Size - NUM , NUM ) ; cipher . process Block ( FR , NUM , FRE , NUM ) ; for ( int n = NUM ; n < block Size - NUM ; n ++ ) { out [ out Off + n + NUM ] = encrypt Byte ( tmp [ n + NUM ] , n ) ; } System . arraycopy ( tmp , NUM , FR , NUM , block Size - NUM ) ; } return block Size ; }
public static PTA Bridge v ( ) { return v ; }
public void register Cache Update Period Change Listener ( final Property Change Listener listener ) { cache Update Period Listeners . add ( listener ) ; }
public void make Immutable ( ) { }
public void test Null Stored Field ( ) throws Exception { Directory dir = new Directory ( ) ; Analyzer analyzer = new Mock Analyzer ( random ( ) ) ; Index Writer iw = new Index Writer ( dir , new Index Writer Config ( analyzer ) ) ; Document doc = new Document ( ) ; iw . add Document ( doc ) ; expect Throws ( Illegal Argument Exception . class , null ) ; assert Null ( iw . get Tragic Exception ( ) ) ; iw . close ( ) ; Directory Reader r = Directory Reader . open ( dir ) ; assert Equals ( NUM , r . num Docs ( ) ) ; r . close ( ) ; dir . close ( ) ; }
public void add Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners == null ) { m Update Listeners = new Array List < Animator Update Listener > ( ) ; } m Update Listeners . add ( listener ) ; }
public String encode ( ) { String Buffer sb = new String Buffer ( ) ; encode ( sb ) ; return sb . to String ( ) ; }
public static Document read Document ( String file Name ) throws SAX Exception , IO Exception { Document Builder doc Builder ; Document result = null ; Document Builder Factory doc Builder Factory = Document Builder Factory . new Instance ( ) ; doc Builder Factory . set Ignoring Element Content Whitespace ( BOOL ) ; try { doc Builder = doc Builder Factory . new Document Builder ( ) ; } catch ( Parser Configuration Exception e ) { throw new Error ( e ) ; } File source File = new File ( file Name ) ; result = doc Builder . parse ( source File ) ; return result ; }
@ Override public double [ ] analyse ( double [ ] a Frame ) { if ( a Frame . length != frame Length ) throw new Illegal Argument Exception ( STRING + frame Length + STRING + a Frame . length ) ; double [ ] real = new double [ fft Size ] ; double [ ] imag = new double [ fft Size ] ; System . arraycopy ( a Frame , NUM , real , NUM , a Frame . length ) ; FFT . transform ( real , imag , BOOL ) ; Math Utils . to Polar Coordinates ( real , imag ) ; real = Math Utils . log ( real ) ; Arrays . fill ( imag , NUM ) ; double b = NUM ; int b Index = ( int ) ( b / frequency Resolution ) ; double [ ] inv Real ; double [ ] inv Imag ; if ( inv Fft Size == fft Size ) { inv Real = real ; inv Imag = imag ; } else { inv Real = new double [ inv Fft Size ] ; System . arraycopy ( real , NUM , inv Real , NUM , b Index + NUM ) ; inv Imag = new double [ inv Fft Size ] ; } for ( int i = b Index + NUM ; i < inv Fft Size / NUM ; i ++ ) { inv Real [ i ] = inv Real [ b Index ] ; } for ( int i = NUM ; i < inv Fft Size / NUM ; i ++ ) { inv Real [ inv Fft Size - i - NUM ] = inv Real [ i ] ; } FFT . transform ( inv Real , inv Imag , BOOL ) ; return inv Real ; }
public Search Source Builder script Field ( String name , Script script ) { if ( script Fields == null ) { script Fields = new Array List < > ( ) ; } script Fields . add ( new Script Field ( name , script ) ) ; return this ; }
public void fixed Aspect Resize Inner ( Rect F new Inner ) { Matrix m = get Rot Matrix ( ) ; Matrix m0 = get Inverse Rot Matrix ( ) ; float aspect W = inner . width ( ) ; float aspect H = inner . height ( ) ; float asp Ratio = aspect W / aspect H ; float [ ] corners = Crop Math . get Corners From Rect ( outer ) ; m . map Points ( corners ) ; float [ ] old Inner Corners = Crop Math . get Corners From Rect ( inner ) ; float [ ] new Inner Corners = Crop Math . get Corners From Rect ( new Inner ) ; int fixed = - NUM ; if ( inner . top == new Inner . top ) { if ( inner . left == new Inner . left ) fixed = NUM ; else if ( inner . right == new Inner . right ) fixed = NUM ; } else if ( inner . bottom == new Inner . bottom ) { if ( inner . right == new Inner . right ) fixed = NUM ; else if ( inner . left == new Inner . left ) fixed = NUM ; } if ( fixed == - NUM ) return ; float width So Far = new Inner . width ( ) ; int moved = - NUM ; for ( int i = NUM ; i < new Inner Corners . length ; i += NUM ) { float [ ] c = { new Inner Corners [ i ] , new Inner Corners [ i + NUM ] } ; float [ ] c0 = Arrays . copy Of ( c , NUM ) ; m0 . map Points ( c0 ) ; if ( ! Crop Math . inclusive Contains ( outer , c0 [ NUM ] , c0 [ NUM ] ) ) { moved = i ; if ( moved == fixed ) continue ; float [ ] l2 = Crop Math . closest Side ( c , corners ) ; float [ ] l1 = { new Inner Corners [ i ] , new Inner Corners [ i + NUM ] , old Inner Corners [ i ] , old Inner Corners [ i + NUM ] } ; float [ ] p = Geometry Math Utils . line Intersect ( l1 , l2 ) ; if ( p == null ) { p = new float [ NUM ] ; p [ NUM ] = old Inner Corners [ i ] ; p [ NUM ] = old Inner Corners [ i + NUM ] ; } float fixed x = old Inner Corners [ fixed ] ; float fixed y = old Inner Corners [ fixed + NUM ] ; float new Width = Math . abs ( fixed x - p [ NUM ] ) ; float new Height = Math . abs ( fixed y - p [ NUM ] ) ; new Width = Math . max ( new Width , asp Ratio * new Height ) ; if ( new Width < width So Far ) width So Far = new Width ; } } float height So Far = width So Far / asp Ratio ; Rect F ret = new Rect F ( inner ) ; if ( fixed == NUM ) { ret . right = ret . left + width So Far ; ret . bottom = ret . top + height So Far ; } else if ( fixed == NUM ) { ret . left = ret . right - width So Far ; ret . bottom = ret . top + height So Far ; } else if ( fixed == NUM ) { ret . left = ret . right - width So Far ; ret . top = ret . bottom - height So Far ; } else if ( fixed == NUM ) { ret . right = ret . left + width So Far ; ret . top = ret . bottom - height So Far ; } float [ ] ret Corners = Crop Math . get Corners From Rect ( ret ) ; m0 . map Points ( ret Corners ) ; inner Rotated = ret Corners ; reconstrain ( ) ; }
public static < T > T with Object Streams ( Socket socket , @ Closure Params ( value = Simple Type . class , options = { STRING , STRING } ) Closure < T > closure ) throws IO Exception { Input Stream input = socket . get Input Stream ( ) ; Output Stream output = socket . get Output Stream ( ) ; Object Output Stream oos = new Object Output Stream ( output ) ; Object Input Stream ois = new Object Input Stream ( input ) ; try { T result = closure . call ( new Object [ ] { ois , oos } ) ; Input Stream temp 1 = ois ; ois = null ; temp 1 . close ( ) ; temp 1 = input ; input = null ; temp 1 . close ( ) ; Output Stream temp 2 = oos ; oos = null ; temp 2 . close ( ) ; temp 2 = output ; output = null ; temp 2 . close ( ) ; return result ; } finally { close With Warning ( ois ) ; close With Warning ( input ) ; close With Warning ( oos ) ; close With Warning ( output ) ; } }
public J File Data Store Chooser ( Shell parent , int style , final String [ ] extensions ) { this ( parent , style , associations ( Arrays . as List ( extensions ) ) ) ; }
private void adjust Alignment ( int align , int cur Align ) { if ( ( ! FIXED WIDTH ) && ( align != cur Align ) ) { if ( cur Line . get Component Count ( ) == NUM ) { cur Line . set Layout ( new Flow Layout ( cur Align ) ) ; } } }
public boolean write Header ( Output Stream os ) { try { write Int ( os , CACHE MAGIC ) ; write String ( os , key ) ; write String ( os , etag == null ? STRING : etag ) ; write Long ( os , server Date ) ; write Long ( os , last Modified ) ; write Long ( os , ttl ) ; write Long ( os , soft Ttl ) ; write String String Map ( response Headers , os ) ; os . flush ( ) ; return BOOL ; } catch ( IO Exception e ) { Volley Log . d ( STRING , e . to String ( ) ) ; return BOOL ; } }
public void remove Listener ( Tracking Listener listener ) { listeners . remove ( listener ) ; }
void create Impl ( boolean stream ) throws Socket Exception { if ( impl == null ) set Impl ( ) ; try { impl . create ( stream ) ; created = BOOL ; } catch ( IO Exception e ) { throw new Socket Exception ( e . get Message ( ) ) ; } }
public synchronized byte [ ] to Byte Array ( ) { int remaining = count ; if ( remaining == NUM ) { return EMPTY BYTE ARRAY ; } byte newbuf [ ] = new byte [ remaining ] ; int pos = NUM ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; System . arraycopy ( buf , NUM , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == NUM ) { break ; } } return newbuf ; }
public boolean sh Exp Match ( String str , String shexp ) { String Tokenizer tokenizer = new String Tokenizer ( shexp , STRING ) ; int start Pos = NUM ; while ( tokenizer . has More Tokens ( ) ) { String token = tokenizer . next Token ( ) ; int temp = str . index Of ( token , start Pos ) ; if ( start Pos == NUM && ! shexp . starts With ( STRING ) && temp != NUM ) { return BOOL ; } if ( ! tokenizer . has More Tokens ( ) && ! shexp . ends With ( STRING ) && ! str . ends With ( token ) ) { return BOOL ; } if ( temp == - NUM ) { return BOOL ; } else { start Pos = temp + token . length ( ) ; } } return BOOL ; }
public char peek ( ) { return is Empty ( ) ? NUM : queue . char At ( pos ) ; }
private String [ ] parent Key ( String name , int idx ) { String [ ] parts = name . split ( STRING ) ; if ( idx > parts . length ) return null ; String parent = STRING ; String key = null ; if ( idx < parts . length ) key = parts [ idx ] ; for ( int i = NUM ; i < idx ; i ++ ) { parent = parent . length ( ) > NUM ? parent + STRING + parts [ i ] : parts [ i ] ; } return new String [ ] { parent , key } ; }
public Diphone Unit Database ( URL url , boolean is Binary ) throws IO Exception { if ( ! use Indexing || use Cache ) { diphone Map = new Linked Hash Map ( ) ; } Input Stream is = Utilities . get Input Stream ( url ) ; index Name = get Index Name ( url . to String ( ) ) ; if ( is Binary ) { load Binary ( is ) ; } else { load Text ( is ) ; } is . close ( ) ; sample Info = new Sample Info ( sample Rate , num Channels , residual Fold , lpc Min , lpc Range , NUM ) ; }
public static List < Notification Dto > transform To Dto ( List < Notification > notifications ) { if ( notifications == null ) { throw new Web Application Exception ( STRING , Status . INTERNAL SERVER ERROR ) ; } List < Notification Dto > result = new Array List < Notification Dto > ( ) ; for ( Notification notification : notifications ) { result . add ( transform To Dto ( notification ) ) ; } return result ; }
public void write To ( final Packet Output Stream os ) { os . write ( Parameter Writer . QUOTE ) ; os . write ( date To Byte ( ) ) ; Parameter Writer . format Microseconds ( os , ts . get Nanos ( ) / NUM , fractional Seconds ) ; os . write ( Parameter Writer . QUOTE ) ; }
public long skip ( long n ) throws IO Exception , Log Exception { if ( length < n ) bad Read ( ( int ) n ) ; n = in . skip ( n ) ; length -= ( int ) n ; return n ; }
public Driver Task discover Storage Provider ( Storage Provider storage Provider , List < Storage System > storage Systems ) { Dell SC Driver Task task = new Dell SC Driver Task ( STRING ) ; try { LOG . info ( STRING , storage Provider . get Provider Host ( ) , storage Provider . get Port Number ( ) , storage Provider . get Username ( ) ) ; Storage Center API api = connection Manager . get Connection ( storage Provider . get Provider Host ( ) , storage Provider . get Port Number ( ) , storage Provider . get Username ( ) , storage Provider . get Password ( ) , BOOL ) ; LOG . info ( STRING , storage Provider . get Provider Host ( ) , storage Provider . get Username ( ) ) ; storage Provider . set Access Status ( Access Status . READ WRITE ) ; storage Provider . set Manufacturer ( STRING ) ; storage Provider . set Provider Version ( driver Version ) ; storage Provider . set Is Supported Version ( BOOL ) ; Em Data Collector em = api . get DSM Info ( ) ; if ( em != null ) { LOG . info ( STRING , em . type , em . version , em . java Version ) ; storage Provider . set Provider Version ( em . version ) ; } Storage Center [ ] scs = api . get Storage Center Info ( ) ; for ( Storage Center sc : scs ) { Storage System storage System = util . get Storage System From Storage Center ( api , sc , null ) ; storage System . set System Type ( driver Name ) ; storage Systems . add ( storage System ) ; } task . set Status ( Driver Task . Task Status . READY ) ; } catch ( Exception e ) { String msg = String . format ( STRING , e ) ; LOG . error ( msg ) ; task . set Failed ( msg ) ; } return task ; }
public void zoom In ( ) { zoom In ( null ) ; }
public void remove Response Code Listener ( Action Listener a ) { response Code Listeners . remove Element ( a ) ; }
public Input Field Dialog ( final String CAPTION KEY , final String LABEL KEY ) { String caption = I18 n . tr ( CAPTION KEY ) ; Frame frame = GUI Mediator . get App Frame ( ) ; dialog = new J Dialog ( frame , caption , BOOL ) ; dialog . set Size ( NUM , NUM ) ; Labeled Component component = new Labeled Component ( LABEL KEY , TEXT FIELD , Labeled Component . LEFT GLUE ) ; String [ ] button Label Keys = { I18 n . tr ( STRING ) , I18 n . tr ( STRING ) } ; String [ ] button Label Tips = { I18 n . tr ( STRING ) , I18 n . tr ( STRING ) } ; Action Listener [ ] button Listeners = { new OK Listener ( ) , new Cancel Listener ( ) } ; Button Row buttons = new Button Row ( button Label Keys , button Label Tips , button Listeners , Button Row . X AXIS , Button Row . LEFT GLUE ) ; Container content Pane = dialog . get Content Pane ( ) ; Box Panel component Panel = new Box Panel ( Box Panel . Y AXIS ) ; component Panel . add ( Box . create Vertical Glue ( ) ) ; component Panel . add ( component . get Component ( ) ) ; component Panel . add ( Box . create Vertical Glue ( ) ) ; MAIN PANEL . add ( component Panel ) ; MAIN PANEL . add ( Box . create Vertical Glue ( ) ) ; MAIN PANEL . add ( buttons ) ; content Pane . add ( MAIN PANEL ) ; }
public Entity Load Info create ( Entity entity ) { return create ( entity , null ) ; }
public Float ( Point 2 D pt 2 D ) { set Lat Lon ( pt 2 D . get Y ( ) , pt 2 D . get X ( ) , BOOL ) ; }
public final static boolean is Potential Zip Archive ( String name ) { int last Dot = name . last Index Of ( STRING ) ; if ( last Dot == - NUM ) return BOOL ; if ( name . last Index Of ( File . separator Char ) > last Dot ) return BOOL ; int length = name . length ( ) ; int extension Length = length - last Dot - NUM ; if ( extension Length == EXTENSION java . length ( ) ) { for ( int i = extension Length - NUM ; i >= NUM ; i -- ) { if ( Character . to Lower Case ( name . char At ( length - extension Length + i ) ) != EXTENSION java . char At ( i ) ) { break ; } if ( i == NUM ) { return BOOL ; } } } if ( extension Length == EXTENSION class . length ( ) ) { for ( int i = extension Length - NUM ; i >= NUM ; i -- ) { if ( Character . to Lower Case ( name . char At ( length - extension Length + i ) ) != EXTENSION class . char At ( i ) ) { return BOOL ; } } return BOOL ; } return BOOL ; }
public void open ( ) throws IO Exception { connection = new Datagram Socket ( ) ; connection . set So Timeout ( timeout ) ; }
@ Override protected int size Of ( String key , Bitmap Drawable value ) { final int bitmap Size = get Bitmap Size ( value ) / NUM ; return bitmap Size == NUM ? NUM : bitmap Size ; }
default void for Each Remaining ( Int Consumer action ) { Objects . require Non Null ( action ) ; while ( has Next ( ) ) action . accept ( next Int ( ) ) ; }
private boolean is CI ( ) { return Objects . equals ( System . getenv ( STRING ) , STRING ) ; }
public Dock Node ( Node contents , String title ) { this ( contents , title , null ) ; }
public void test 2033092 ( ) { Relative Date Format rdf = new Relative Date Format ( ) ; rdf . set Show Zero Days ( BOOL ) ; rdf . set Show Zero Hours ( BOOL ) ; rdf . set Minute Suffix ( STRING ) ; rdf . set Hour Suffix ( STRING ) ; rdf . set Second Suffix ( STRING ) ; Decimal Format hours Formatter = new Decimal Format ( ) ; hours Formatter . set Maximum Fraction Digits ( NUM ) ; hours Formatter . set Maximum Integer Digits ( NUM ) ; hours Formatter . set Minimum Integer Digits ( NUM ) ; rdf . set Hour Formatter ( hours Formatter ) ; Decimal Format mins Formatter = new Decimal Format ( ) ; mins Formatter . set Maximum Fraction Digits ( NUM ) ; mins Formatter . set Maximum Integer Digits ( NUM ) ; mins Formatter . set Minimum Integer Digits ( NUM ) ; rdf . set Minute Formatter ( mins Formatter ) ; Decimal Format seconds Formatter = new Decimal Format ( ) ; seconds Formatter . set Maximum Fraction Digits ( NUM ) ; seconds Formatter . set Maximum Integer Digits ( NUM ) ; seconds Formatter . set Minimum Integer Digits ( NUM ) ; rdf . set Second Formatter ( seconds Formatter ) ; String s = rdf . format ( new Date ( NUM * NUM * NUM * NUM + NUM ) ) ; assert Equals ( STRING , s ) ; }
public static int read Single Byte ( Input Stream in ) throws IO Exception { byte [ ] buffer = new byte [ NUM ] ; int result = in . read ( buffer , NUM , NUM ) ; return ( result != - NUM ) ? buffer [ NUM ] & NUM : - NUM ; }
public static long parse Id ( Uri content Uri ) { String last = content Uri . get Last Path Segment ( ) ; return last == null ? - NUM : Long . parse Long ( last ) ; }
public void disable VM ( String hostname , long duration Millis ) throws Illegal State Exception { logger . info ( STRING + hostname + STRING + duration Millis + STRING ) ; assignable V Ms . disable Until ( hostname , System . current Time Millis ( ) + duration Millis ) ; }
protected final void end Of Input ( ) throws IO Exception { if ( cache Request != null ) { cache Body . close ( ) ; } http Engine . release ( BOOL ) ; }
public int left ( ) { return data . length ( ) - pos ; }
public Feature Set combine ( final Feature Set other ) { final Set < Feature > enabled = new Hash Set < > ( this . enabled ) ; enabled . add All ( other . enabled ) ; final Set < Feature > disabled = new Hash Set < > ( this . disabled ) ; disabled . add All ( other . disabled ) ; return new Feature Set ( enabled , disabled ) ; }
public void remove Interval ( final Batch Writer writer , final Temporal Interval interval , final Statement statement ) throws Mutations Rejected Exception { final Text cf = new Text ( Statement Serializer . write Context ( statement ) ) ; final Text cq Begin = new Text ( Key Parts . CQ BEGIN ) ; final Text cq End = new Text ( Key Parts . CQ END ) ; Text key Text = new Text ( interval . get As Key Beginning ( ) ) ; Key Parts . append Uniqueness ( statement , key Text ) ; Mutation m = new Mutation ( key Text ) ; m . put Delete ( cf , cq Begin ) ; writer . add Mutation ( m ) ; key Text = new Text ( interval . get As Key End ( ) ) ; Key Parts . append Uniqueness ( statement , key Text ) ; m = new Mutation ( key Text ) ; m . put Delete ( cf , cq End ) ; writer . add Mutation ( m ) ; }
public static final String remove Data Folder Path ( String full Path ) { File sd Card = Environment . get External Storage Directory ( ) ; String data Folder Path = sd Card . get Absolute Path ( ) + STRING + Main App . get Data Folder ( ) + STRING ; if ( full Path . index Of ( data Folder Path ) == NUM ) { return full Path . substring ( data Folder Path . length ( ) ) ; } return full Path ; }
protected Character is WFXML Char ( String chardata ) { Character ref Invalid Char ; if ( chardata == null || ( chardata . length ( ) == NUM ) ) { return null ; } char [ ] dataarray = chardata . to Char Array ( ) ; int datalength = dataarray . length ; if ( f Is XML Version 11 ) { int i = NUM ; while ( i < datalength ) { if ( XML 11 Char . is XML 11 Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM ] ; if ( XML Char . is High Surrogate ( ch ) && i < datalength ) { char ch 2 = dataarray [ i ++ ] ; if ( XML Char . is Low Surrogate ( ch 2 ) && XML Char . is Supplemental ( XML Char . supplemental ( ch , ch 2 ) ) ) { continue ; } } ref Invalid Char = new Character ( ch ) ; return ref Invalid Char ; } } } else { int i = NUM ; while ( i < datalength ) { if ( XML Char . is Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM ] ; if ( XML Char . is High Surrogate ( ch ) && i < datalength ) { char ch 2 = dataarray [ i ++ ] ; if ( XML Char . is Low Surrogate ( ch 2 ) && XML Char . is Supplemental ( XML Char . supplemental ( ch , ch 2 ) ) ) { continue ; } } ref Invalid Char = new Character ( ch ) ; return ref Invalid Char ; } } } return null ; }
default Completable Future < Optional < R > > match Async ( final Executor executor , final T value ) { return Completable Future . supply Async ( null , executor ) ; }
public static void main ( String [ ] args ) throws Format Exception { Debug . init ( ) ; if ( args . length == NUM ) { Debug . output ( STRING ) ; System . exit ( NUM ) ; } for ( int argsi = NUM ; argsi < args . length ; argsi ++ ) { rootpath = args [ argsi ] ; Library Selection Table lst = new Library Selection Table ( rootpath ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + rootpath ) ; Debug . output ( STRING + lst . get Database Name ( ) ) ; } println ( STRING ) ; println ( STRING + rootpath ) ; println ( STRING + lst . get Database Description ( ) ) ; List < String > libraries = lst . get Library Names ( ) ; if ( Debug . debugging ( STRING ) ) { print ( STRING ) ; for ( String library Name : libraries ) { print ( library Name , STRING ) ; } println ( ) ; println ( ) ; } for ( String library Name : libraries ) { String prefix = lst . get Database Name ( ) + STRING + library Name ; println ( STRING + prefix ) ; print Library ( prefix , lst . get CAT ( library Name ) ) ; println ( ) ; } } }
private static String wildcard To Regex ( String pattern ) { return STRING + String Utils . replace Each ( escape Regexp ( pattern ) , new String [ ] { STRING , STRING } , new String [ ] { STRING , STRING } ) + STRING ; }
protected void clear Cache ( ) { if ( cache != null ) { cache . clear ( ) ; cache = null ; } }
public String sql AD get Custom Entity Types ( String vendor Name , String catalog Name , String schema Name ) { String table Name = STRING ; Array List < String > column Names = new Array List < String > ( ) ; column Names . add ( STRING ) ; Array List < String > alias Names = new Array List < String > ( ) ; alias Names . add ( STRING ) ; Array List < String > conditions = new Array List < String > ( ) ; conditions . add ( STRING ) ; Array List < String > sort Columns = new Array List < String > ( ) ; sort Columns . add ( STRING ) ; return sql select ( vendor Name , catalog Name , schema Name , table Name , null , column Names , alias Names , conditions , sort Columns , BOOL ) ; }
public void paint Component ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . draw Image ( picture , x , y , scale W , scale H , null ) ; x += scale W + PADDING ; g . draw Image ( picture , x , y , x + scale W , y + scale H , NUM , NUM , picture . get Width ( ) , picture . get Height ( ) , null ) ; x += scale W + PADDING ; Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; g2 d . translate ( x , y ) ; g2 d . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , NUM , NUM , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; g2 d = ( Graphics 2 D ) g . create ( ) ; Affine Transform at = new Affine Transform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE FACTOR , SCALE FACTOR ) ; g2 d . draw Image ( picture , at , null ) ; g2 d . dispose ( ) ; x += scale W + PADDING ; Image scaled Img = picture . get Scaled Instance ( scale W , scale H , Image . SCALE DEFAULT ) ; g . draw Image ( scaled Img , x , y , null ) ; }
public int hash Code ( ) { return id Type . hash Code ( ) ; }
private static void backup Audio Config ( ) { if ( null != m Restore Audio Config Timer ) { m Restore Audio Config Timer . cancel ( ) ; m Restore Audio Config Timer = null ; m Restore Audio Config Timer Mask = null ; } else if ( null == m Audio Mode ) { Audio Manager audio Manager = get Audio Manager ( ) ; m Audio Mode = audio Manager . get Mode ( ) ; m Is Speaker On = audio Manager . is Speakerphone On ( ) ; } }
public static String build Imdn Delivery Report ( String msg Id , Imdn Document . Delivery Status status , long timestamp ) { String method ; switch ( status ) { case DISPLAYED : method = STRING ; break ; case DELIVERED : method = STRING ; break ; default : method = STRING ; break ; } return STRING + UTF 8 STR + STRING + CRLF + STRING + CRLF + STRING + msg Id + STRING + CRLF + STRING + Date Utils . encode Date ( timestamp ) + STRING + CRLF + STRING + method + STRING + status + STRING + method + STRING + CRLF + STRING ; }
private Speedruns Live Request ( ) { super ( URL ) ; }
public static Bitmap decode Resource With Backouts ( Resources res , Bitmap Factory . Options options , int id ) { boolean no Bitmap = BOOL ; int num tries = NUM ; if ( options . in Sample Size < NUM ) { options . in Sample Size = NUM ; } Bitmap bmap = null ; while ( no Bitmap ) { try { bmap = Bitmap Factory . decode Resource ( res , id , options ) ; no Bitmap = BOOL ; } catch ( java . lang . Out Of Memory Error e ) { if ( ++ num tries >= BITMAP LOAD BACKOUT ATTEMPTS ) { throw e ; } bmap = null ; System . gc ( ) ; options . in Sample Size *= NUM ; } } return bmap ; }
public void clear ( ) { ored Criteria . clear ( ) ; order By Clause = null ; distinct = BOOL ; }
public void read Data File ( String content ) throws Data File Exception { if ( content == null || content . length ( ) <= NUM ) throw new Illegal State Exception ( STRING ) ; Byte Array Input Stream bis = new Byte Array Input Stream ( content . get Bytes ( ) ) ; read Data File ( bis , null ) ; }
public static String read UTF ( Data Input in ) throws IO Exception { return Data Input Stream . read UTF ( in ) ; }
protected Object lazily Load Desktop Property ( String name ) { if ( name . starts With ( STRING ) ) { return lazily Load GTK Icon ( name ) ; } return super . lazily Load Desktop Property ( name ) ; }
public O Auth Rsa Sha 1 Signer ( String private Key String ) throws O Auth Exception { if ( private Key String == null ) { throw new O Auth Exception ( STRING ) ; } else if ( private Key String . length ( ) == NUM ) { throw new O Auth Exception ( STRING ) ; } try { set Private Key ( Rsa Sha 1 Private Key Helper . get Private Key ( private Key String ) ) ; } catch ( Base 64 Decoder Exception e ) { throw new O Auth Exception ( STRING , e ) ; } catch ( No Such Algorithm Exception e ) { throw new O Auth Exception ( STRING , e ) ; } catch ( Invalid Key Spec Exception e ) { throw new O Auth Exception ( STRING , e ) ; } }
private Map < String , Volume > group Volumes By Replication Group ( List < Volume > volume List ) { Map < String , Volume > rep Group To Volume Map = new Hash Map < String , Volume > ( ) ; for ( Volume volume : volume List ) { String rep Group Name = volume . get Replication Group Instance ( ) ; if ( volume . is V Plex Volume ( db Client ) ) { Volume backed Vol = V Plex Util . get VPLEX Backend Volume ( volume , BOOL , db Client ) ; if ( backed Vol != null ) { rep Group Name = backed Vol . get Replication Group Instance ( ) ; } } rep Group To Volume Map . put ( rep Group Name , volume ) ; } return rep Group To Volume Map ; }
public Default File Filter ( String extension , String description ) { ext = extension . to Lower Case ( ) ; desc = description ; }
public void append Cell ( boolean value ) { append Cell ( String . value Of ( value ) ) ; }
public String name ( ) { return System . get Property ( STRING ) ; }
protected void add URL ( URL url ) { try { original Urls . add ( url ) ; search List . add ( create Search URL ( url ) ) ; } catch ( Malformed URL Exception e ) { } }
public void init Structure ( ) throws Exception { int n Attribute = NUM ; for ( int i Order = NUM ; i Order < m Instances . num Attributes ( ) ; i Order ++ ) { if ( n Attribute == m Instances . class Index ( ) ) { n Attribute ++ ; } } m Parent Sets = new Parent Set [ m Instances . num Attributes ( ) ] ; for ( int i Attribute = NUM ; i Attribute < m Instances . num Attributes ( ) ; i Attribute ++ ) { m Parent Sets [ i Attribute ] = new Parent Set ( m Instances . num Attributes ( ) ) ; } }
@ Override public synchronized Completable Future < Void > disconnect ( ) { close Future = new Completable Future < > ( ) ; if ( ! consumers . is Empty ( ) ) { consumers . for Each ( null ) ; if ( have Pending Read && cursor . cancel Pending Read Request ( ) ) { have Pending Read = BOOL ; } } else { close Future . complete ( null ) ; } return close Future ; }
public static String read Ascii Line ( Input Stream in ) throws IO Exception { String Builder result = new String Builder ( NUM ) ; while ( BOOL ) { int c = in . read ( ) ; if ( c == - NUM ) { throw new EOF Exception ( ) ; } else if ( c == STRING ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > NUM && result . char At ( length - NUM ) == STRING ) { result . set Length ( length - NUM ) ; } return result . to String ( ) ; }
public static String read Ascii Line ( Input Stream in ) throws IO Exception { String Builder result = new String Builder ( NUM ) ; while ( BOOL ) { int c = in . read ( ) ; if ( c == - NUM ) { throw new EOF Exception ( ) ; } else if ( c == STRING ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > NUM && result . char At ( length - NUM ) == STRING ) { result . set Length ( length - NUM ) ; } return result . to String ( ) ; }
protected boolean IP Is Broadcast ( int IP Address ) { int inv subnet mask = ~ this . subnet mask ; return ( ( IP Address & inv subnet mask ) == inv subnet mask ) ; }
public void add Cell Appearances To Work List ( DF Lattice Cell cell ) { for ( Enumeration < DF Equation > e = get Equations ( ) ; e . has More Elements ( ) ; ) { DF Equation eq = e . next Element ( ) ; if ( eq . has Cell ( cell ) ) { add To Work List ( eq ) ; } } }
public void remove ( Constraint Widget widget ) { Element to Unselect = null ; for ( Element selection : m Selected Widgets ) { if ( selection . widget == widget ) { to Unselect = selection ; break ; } } if ( to Unselect != null ) { m Selected Widgets . remove ( to Unselect ) ; } selection Has Changed ( ) ; }
public static long hex String To Long ( final String hex String ) { Preconditions . check Not Null ( hex String , STRING ) ; Preconditions . check Argument ( is Hex String ( hex String ) , String . format ( STRING , hex String ) ) ; if ( ( hex String . length ( ) == NUM ) && ( hex String . char At ( NUM ) >= NUM ) ) { final String str Addr 1 = hex String . substring ( NUM , hex String . length ( ) - NUM ) ; final String str Addr 2 = hex String . substring ( hex String . length ( ) - NUM ) ; return ( Long . parse Long ( str Addr 1 , NUM ) << NUM ) + Long . parse Long ( str Addr 2 , NUM ) ; } return Long . parse Long ( hex String , NUM ) ; }
public static boolean contains File ( @ Not Null Source Provider provider , @ Not Null File file ) { Collection < File > src Directories = get All Source Folders ( provider ) ; if ( files Equal ( provider . get Manifest File ( ) , file ) ) { return BOOL ; } for ( File container : src Directories ) { File parent = container . get Parent File ( ) ; if ( parent != null && parent . is Directory ( ) && files Equal ( parent , file ) ) { return BOOL ; } if ( ! container . exists ( ) ) { continue ; } if ( is Ancestor ( container , file , BOOL ) ) { return BOOL ; } } return BOOL ; }
public static String check Not Empty ( String string , Object error Message ) { if ( Exo Player Library Info . ASSERTIONS ENABLED && Text Utils . is Empty ( string ) ) { throw new Illegal Argument Exception ( String . value Of ( error Message ) ) ; } return string ; }
void run Post Search ( int cnt Items ) ;
private SSL Engine Result unwrap ( ) throws SSL Exception { if ( app Buffer == null ) { app Buffer = Io Buffer . allocate ( in Net Buffer . remaining ( ) ) ; } else { app Buffer . expand ( in Net Buffer . remaining ( ) ) ; } SSL Engine Result res ; Status status = null ; Handshake Status handshake Status = null ; do { res = ssl Engine . unwrap ( in Net Buffer . buf ( ) , app Buffer . buf ( ) ) ; status = res . get Status ( ) ; handshake Status = res . get Handshake Status ( ) ; if ( status == SSL Engine Result . Status . BUFFER OVERFLOW ) { app Buffer . capacity ( app Buffer . capacity ( ) << NUM ) ; app Buffer . limit ( app Buffer . capacity ( ) ) ; continue ; } } while ( ( ( status == SSL Engine Result . Status . OK ) || ( status == SSL Engine Result . Status . BUFFER OVERFLOW ) ) && ( ( handshake Status == SSL Engine Result . Handshake Status . NOT HANDSHAKING ) || ( handshake Status == SSL Engine Result . Handshake Status . NEED UNWRAP ) ) ) ; return res ; }
public Certificate request Certificate ( byte [ ] csr ) throws Acme Exception { return request Certificate ( csr , null , null ) ; }
public void clear ( ) { m Strings . clear ( ) ; notify Data Set Changed ( ) ; }
@ Suppress Warnings ( { STRING } ) private static Grid Uri Deployment File Processor Result process With Descriptor File ( Grid Uri Deployment Spring Document doc , File file , String uri , Ignite Logger log ) throws Ignite Spi Exception { Class Loader cls Ldr = Grid Uri Deployment Class Loader Factory . create ( U . grid Class Loader ( ) , file , log ) ; List < Class < ? extends Compute Task < ? , ? > > > tasks = doc . get Tasks ( cls Ldr ) ; List < Class < ? extends Compute Task < ? , ? > > > valid Tasks = null ; if ( ! F . is Empty ( tasks ) ) { valid Tasks = new Array List < > ( ) ; for ( Class < ? extends Compute Task < ? , ? > > task : tasks ) { if ( ! is Allowed Task Class ( task ) ) { U . warn ( log , STRING + STRING + task + STRING ) ; } else { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + task . get Name ( ) ) ; valid Tasks . add ( task ) ; } } } Grid Uri Deployment File Processor Result res = new Grid Uri Deployment File Processor Result ( ) ; res . set File ( file ) ; res . set Class Loader ( cls Ldr ) ; if ( ! F . is Empty ( valid Tasks ) ) res . set Task Classes ( valid Tasks ) ; else if ( log . is Debug Enabled ( ) ) log . debug ( STRING + file . get Absolute Path ( ) + STRING + U . hide Password ( uri ) + STRING ) ; return res ; }
private < T extends Data Object > boolean test Selections ( J Class jc , T dobj ) { List < J Selection > list = jc . get Selections ( ) ; for ( J Selection js : list ) { if ( test Selection ( jc , js , dobj ) == BOOL ) { return BOOL ; } } return BOOL ; }
public void truncate ( ) { calculate Ideal Point ( ) ; translate By Ideal Point ( ) ; List < List < Solution > > members = associate To Reference Point ( this ) ; clear ( ) ; for ( int i = NUM ; i < members . size ( ) ; i ++ ) { List < Solution > associations = members . get ( i ) ; if ( associations . size ( ) > NUM ) { add ( select ( associations , i ) ) ; } } }
protected void on Downloading ( ) { if ( Log Configuration . logging Is Enabled ( ) ) { logger . log ( Level . INFO , messages . downloading Resources ( ) ) ; } updating = BOOL ; fire Application Cache Event ( Cache Event . on Downloading ) ; }
protected synchronized void add Transition Listener ( Hashtable < Tx State , Hashtable < Tx State , Set < Event Listener > > > listeners , Event Listener lstnr , Tx State from , Tx State to ) { Hashtable < Tx State , Set < Event Listener > > lstnrs = listeners . get ( from ) ; if ( lstnrs == null ) lstnrs = new Hashtable < Tx State , Set < Event Listener > > ( ) ; Set < Event Listener > tolstnrs = lstnrs . get ( to ) ; if ( tolstnrs == null ) tolstnrs = new Hash Set < Event Listener > ( ) ; if ( ! tolstnrs . contains ( lstnr ) ) tolstnrs . add ( lstnr ) ; lstnrs . put ( to , tolstnrs ) ; listeners . put ( from , lstnrs ) ; }
public boolean has Exclusion ( ) { return ! m Excluded Classes . is Empty ( ) || ! m Excluded Tests . is Empty ( ) ; }
private int ensure Baseline On Grid ( ) { float baseline = get Baseline ( ) ; float grid Align = baseline % FOUR DIP ; if ( grid Align != NUM ) { extra Top Padding = ( int ) ( FOUR DIP - Math . ceil ( grid Align ) ) ; } return extra Top Padding ; }
@ Override public void compute ( ) { Spliterator < P IN > rs = spliterator , ls ; long size Estimate = rs . estimate Size ( ) ; long size Threshold = get Target Size ( size Estimate ) ; boolean fork Right = BOOL ; @ Suppress Warnings ( STRING ) K task = ( K ) this ; Atomic Reference < R > sr = shared Result ; R result ; while ( ( result = sr . get ( ) ) == null ) { if ( task . task Canceled ( ) ) { result = task . get Empty Result ( ) ; break ; } if ( size Estimate <= size Threshold || ( ls = rs . try Split ( ) ) == null ) { result = task . do Leaf ( ) ; break ; } K left Child , right Child , task To Fork ; task . left Child = left Child = task . make Child ( ls ) ; task . right Child = right Child = task . make Child ( rs ) ; task . set Pending Count ( NUM ) ; if ( fork Right ) { fork Right = BOOL ; rs = ls ; task = left Child ; task To Fork = right Child ; } else { fork Right = BOOL ; task = right Child ; task To Fork = left Child ; } task To Fork . fork ( ) ; size Estimate = rs . estimate Size ( ) ; } task . set Local Result ( result ) ; task . try Complete ( ) ; }
public static Map < String , Object > create Content Assoc ( Dispatch Context dctx , Map < String , ? extends Object > rcontext ) { Map < String , Object > context = Util Misc . make Map Writable ( rcontext ) ; context . put ( STRING , STRING ) ; List < String > target Operation List = Content Worker . prep Target Operation List ( context , STRING ) ; List < String > content Purpose List = Content Worker . prep Content Purpose List ( context ) ; context . put ( STRING , target Operation List ) ; context . put ( STRING , content Purpose List ) ; context . put ( STRING , null ) ; Map < String , Object > result = null ; try { result = create Content Assoc Method ( dctx , context ) ; } catch ( Generic Service Exception e ) { return Service Util . return Error ( e . get Message ( ) ) ; } catch ( Generic Entity Exception e2 ) { return Service Util . return Error ( e2 . get Message ( ) ) ; } catch ( Exception e3 ) { return Service Util . return Error ( e3 . get Message ( ) ) ; } return result ; }
public String format With Locale ( Locale locale , String ... args ) { return String . format ( locale , this . content , ( Object [ ] ) args ) ; }
private static < T extends Abstract Block Base < T > > T add Path To Linear Scan Order ( T block , List < T > order , Priority Queue < T > worklist , Bit Set visited Blocks ) { block . set Linear Scan Number ( order . size ( ) ) ; order . add ( block ) ; T most Likely Successor = find And Mark Most Likely Successor ( block , visited Blocks ) ; enqueue Successors ( block , worklist , visited Blocks ) ; if ( most Likely Successor != null ) { if ( ! most Likely Successor . is Loop Header ( ) && most Likely Successor . get Predecessor Count ( ) > NUM ) { double unscheduled Sum = NUM ; for ( T pred : most Likely Successor . get Predecessors ( ) ) { if ( pred . get Linear Scan Number ( ) == - NUM ) { unscheduled Sum += pred . probability ( ) ; } } if ( unscheduled Sum > block . probability ( ) / PENALTY VERSUS UNSCHEDULED ) { visited Blocks . clear ( most Likely Successor . get Id ( ) ) ; return null ; } } return most Likely Successor ; } return null ; }
private static Dimension create Thumb Dimension ( final Buffered Image image , final int max Width , final int max Height ) { Dimension dimension = new Dimension ( ) ; if ( image . get Width ( ) >= image . get Height ( ) ) { if ( image . get Width ( ) >= max Width ) { dimension . width = max Width ; dimension . height = Math . round ( ( ( float ) max Width / image . get Width ( ) ) * image . get Height ( ) ) ; } else { dimension . height = image . get Height ( ) ; dimension . width = image . get Width ( ) ; } } else { if ( image . get Height ( ) >= max Height ) { dimension . height = max Height ; dimension . width = Math . round ( ( ( ( float ) max Height / image . get Height ( ) ) * image . get Width ( ) ) ) ; } else { dimension . height = image . get Height ( ) ; dimension . width = image . get Width ( ) ; } } return dimension ; }
private boolean has Current Account Changed ( ) { Account account = Account Utils . get Current Own Cloud Account ( this ) ; if ( account == null ) { return BOOL ; } else { return ! m Original Current Account . equals ( account . name ) ; } }
public int next Clear Bit ( int index ) { int i = index > > NUM ; if ( i >= wlen ) return - NUM ; int sub Index = index & NUM ; long word = ~ bits . get ( i ) > > sub Index ; if ( word != NUM ) { return ( i << NUM ) + sub Index + Long . number Of Trailing Zeros ( word ) ; } while ( ++ i < wlen ) { word = ~ bits . get ( i ) ; if ( word != NUM ) { return ( i << NUM ) + Long . number Of Trailing Zeros ( word ) ; } } return - NUM ; }
private static synchronized void append Message ( Context c , final String msg ) { if ( msg . length ( ) == NUM ) return ; String out = msg ; boolean timestamp = Pref Store . is Timestamp ( c ) ; int max Lines = Pref Store . get Max Lines ( c ) ; int protocol Size = protocol . size ( ) ; if ( protocol Size > NUM && last Char != STRING ) { protocol . remove ( protocol Size - NUM ) ; out = last Line + out ; } last Char = out . char At ( out . length ( ) - NUM ) ; String [ ] lines = out . split ( STRING ) ; for ( int i = NUM , l = lines . length ; i < l ; i ++ ) { last Line = lines [ i ] ; if ( timestamp ) protocol . add ( get Time Stamp ( ) + last Line ) ; else protocol . add ( last Line ) ; if ( protocol Size + i >= max Lines ) { protocol . remove ( NUM ) ; } } show ( ) ; if ( Pref Store . is Logger ( c ) ) write ( c , msg ) ; }
public Object [ ] import Cells ( Object [ ] cells , double dx , double dy , Object target , Point location ) { if ( target == null && cells . length == NUM && location != null ) { target = get Cell At ( location . x , location . y ) ; if ( target instanceof mx I Cell && cells [ NUM ] instanceof mx I Cell ) { mx I Cell target Cell = ( mx I Cell ) target ; mx I Cell drop Cell = ( mx I Cell ) cells [ NUM ] ; if ( target Cell . is Vertex ( ) == drop Cell . is Vertex ( ) || target Cell . is Edge ( ) == drop Cell . is Edge ( ) ) { mx I Graph Model model = graph . get Model ( ) ; model . set Style ( target , model . get Style ( cells [ NUM ] ) ) ; graph . set Selection Cell ( target ) ; return null ; } } } return super . import Cells ( cells , dx , dy , target , location ) ; }
private void cancel Search ( ) { entrant To Search = null ; }
public void on Prepared ( Media Player player ) { m State = State . PLAYING ; update Notification ( String . format ( get String ( R . string . media state playing ) , m File . get File Name ( ) ) ) ; if ( m Media Controller != null ) { m Media Controller . set Enabled ( BOOL ) ; } player . seek To ( m Start Position ) ; config And Start Media Player ( ) ; if ( ! m Play On Prepared ) { process Pause Request ( ) ; } if ( m Media Controller != null ) { m Media Controller . update Pause Play ( ) ; } }
public static Result Set polar 2 Cartesian ( Double r , Double alpha ) { Simple Result Set rs = new Simple Result Set ( ) ; rs . add Column ( STRING , Types . DOUBLE , NUM , NUM ) ; rs . add Column ( STRING , Types . DOUBLE , NUM , NUM ) ; if ( r != null && alpha != null ) { double x = r . double Value ( ) * Math . cos ( alpha . double Value ( ) ) ; double y = r . double Value ( ) * Math . sin ( alpha . double Value ( ) ) ; rs . add Row ( x , y ) ; } return rs ; }
private List < View > add View ( View view , List < View > cache ) { if ( cache == null ) { cache = new Linked List < View > ( ) ; } cache . add ( view ) ; return cache ; }
public void thread Fail ( String reason ) { try { fail ( reason ) ; } catch ( Assertion Failed Error t ) { thread Record Failure ( t ) ; throw t ; } }
@ Override public void connection Lost ( Throwable cause ) { on Disconnect ( BOOL ) ; }
private boolean is Typed Time Fully Legal ( ) { if ( m Is 24 Hour Mode ) { int [ ] values = get Entered Time ( null ) ; return ( values [ NUM ] >= NUM && values [ NUM ] >= NUM && values [ NUM ] < NUM && values [ NUM ] >= NUM && values [ NUM ] < NUM ) ; } else { return ( m Typed Times . contains ( get Am Or Pm Key Code ( AM ) ) || m Typed Times . contains ( get Am Or Pm Key Code ( PM ) ) ) ; } }
public synchronized void clear Annotations ( ) { m Annotations . clear ( ) ; m String XY . clear ( ) ; }
public Table sample ( double proportion ) { int table Count = ( int ) Math . round ( row Count ( ) * proportion ) ; Selection table 1 Selection = new Bitmap Backed Selection ( ) ; int [ ] selected Records = generate Uniform Bitmap ( table Count , row Count ( ) ) ; for ( int selected Record : selected Records ) { table 1 Selection . add ( selected Record ) ; } return select Where ( table 1 Selection ) ; }
public void clear ( ) { ored Criteria . clear ( ) ; order By Clause = null ; distinct = BOOL ; }
public static Message Digest new Digest ( ) { try { return Message Digest . get Instance ( STRING ) ; } catch ( No Such Algorithm Exception e ) { throw new Runtime Exception ( e ) ; } }
public Container add Child At ( int location , @ Non Null Display Object Display Object ) { if ( m Fps != DEFAULT FPS ) { Display Object . set Up ( m Fps ) ; } m Display List . add ( location , Display Object ) ; return this ; }
private void add ( Dimension Index index ) { flatten . add ( index ) ; lookup . put ( index . get Axis ( ) , index ) ; }
public static Recipe Petals register Petal Recipe ( Item Stack output , Object ... inputs ) { Preconditions . check Argument ( inputs . length <= NUM ) ; Recipe Petals recipe = new Recipe Petals ( output , inputs ) ; petal Recipes . add ( recipe ) ; return recipe ; }
private void build First Line ( Line Path path , Rect r ) { int [ ] range = new int [ ] { - r . left , - r . top , r . right , r . bottom } ; int max = - NUM ; int max Id = NUM ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( range [ i ] > max ) { max = range [ i ] ; max Id = i ; } } switch ( max Id ) { case NUM : path . set End Point ( r . left , Utils . next Int ( r . height ( ) ) + r . top ) ; break ; case NUM : path . set End Point ( Utils . next Int ( r . width ( ) ) + r . left , r . top ) ; break ; case NUM : path . set End Point ( r . right , Utils . next Int ( r . height ( ) ) + r . top ) ; break ; case NUM : path . set End Point ( Utils . next Int ( r . width ( ) ) + r . left , r . bottom ) ; break ; } path . line To End ( ) ; }
public static boolean is Extension ( String filename , String extension ) { if ( filename == null ) { return BOOL ; } if ( extension == null || extension . length ( ) == NUM ) { return index Of Extension ( filename ) == - NUM ; } String file Ext = get Extension ( filename ) ; return file Ext . equals ( extension ) ; }
public void test Value Of Double Neg ( ) { double a = - NUM ; Big Decimal result = Big Decimal . value Of ( a ) ; String res = STRING ; int res Scale = NUM ; assert Equals ( STRING , res , result . to String ( ) ) ; assert Equals ( STRING , res Scale , result . scale ( ) ) ; }
public void test Huge Term ( ) throws IO Exception { String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { sb . append ( STRING ) ; } String input = sb . to String ( ) ; char token [ ] = new char [ NUM ] ; Arrays . fill ( token , STRING ) ; String expected Token = new String ( token ) ; String expected [ ] = { expected Token , expected Token , expected Token , expected Token , expected Token , expected Token , expected Token , expected Token , expected Token , expected Token } ; assert Analyzes To ( sentence , input , expected ) ; }
private String [ ] combine Results From Multiple Reads ( String [ ] buffer , String [ ] last Read ) { String [ ] t = new String [ buffer . length + last Read . length ] ; System . arraycopy ( buffer , NUM , t , NUM , buffer . length ) ; System . arraycopy ( last Read , NUM , t , buffer . length , last Read . length ) ; return t ; }
public double calc Distance ( final double x , final double y ) { double distance X ; double distance Y ; if ( this . min X <= x && x <= this . max X ) { distance X = NUM ; } else { distance X = Math . min ( Math . abs ( this . min X - x ) , Math . abs ( this . max X - x ) ) ; } if ( this . min Y <= y && y <= this . max Y ) { distance Y = NUM ; } else { distance Y = Math . min ( Math . abs ( this . min Y - y ) , Math . abs ( this . max Y - y ) ) ; } return Math . sqrt ( distance X * distance X + distance Y * distance Y ) ; }
@ Override public Matches Type marshal ( Set < Match > matches ) { Set < RPS Blast Match > rps Blast Matches = new Linked Hash Set < RPS Blast Match > ( ) ; Set < Hmmer 2 Match > hmmer 2 Matches = new Linked Hash Set < Hmmer 2 Match > ( ) ; Set < Hmmer 3 Match > hmmer 3 Matches = new Linked Hash Set < Hmmer 3 Match > ( ) ; Set < Super Family Hmmer 3 Match > super Family Hmmer 3 Matches = new Linked Hash Set < Super Family Hmmer 3 Match > ( ) ; Set < Finger Prints Match > finger Prints Matches = new Linked Hash Set < Finger Prints Match > ( ) ; Set < Blast Pro Dom Match > pro Dom Matches = new Linked Hash Set < Blast Pro Dom Match > ( ) ; Set < Pattern Scan Match > pattern Scan Matches = new Linked Hash Set < Pattern Scan Match > ( ) ; Set < Profile Scan Match > profile Scan Matches = new Linked Hash Set < Profile Scan Match > ( ) ; Set < Phobius Match > phobius Matches = new Linked Hash Set < Phobius Match > ( ) ; Set < Coils Match > coils Matches = new Linked Hash Set < Coils Match > ( ) ; Set < Panther Match > panther Matches = new Linked Hash Set < Panther Match > ( ) ; Set < Signal P Match > signal P Matches = new Linked Hash Set < Signal P Match > ( ) ; Set < TMHMM Match > tmhmm P Matches = new Linked Hash Set < TMHMM Match > ( ) ; for ( Match m : matches ) { if ( m instanceof RPS Blast Match ) { rps Blast Matches . add ( ( RPS Blast Match ) m ) ; } else if ( m instanceof Hmmer 2 Match ) { hmmer 2 Matches . add ( ( Hmmer 2 Match ) m ) ; } else if ( m instanceof Hmmer 3 Match ) { hmmer 3 Matches . add ( ( Hmmer 3 Match ) m ) ; } else if ( m instanceof Super Family Hmmer 3 Match ) { super Family Hmmer 3 Matches . add ( ( Super Family Hmmer 3 Match ) m ) ; } else if ( m instanceof Finger Prints Match ) { finger Prints Matches . add ( ( Finger Prints Match ) m ) ; } else if ( m instanceof Blast Pro Dom Match ) { pro Dom Matches . add ( ( Blast Pro Dom Match ) m ) ; } else if ( m instanceof Pattern Scan Match ) { pattern Scan Matches . add ( ( Pattern Scan Match ) m ) ; } else if ( m instanceof Profile Scan Match ) { profile Scan Matches . add ( ( Profile Scan Match ) m ) ; } else if ( m instanceof Phobius Match ) { phobius Matches . add ( ( Phobius Match ) m ) ; } else if ( m instanceof Coils Match ) { coils Matches . add ( ( Coils Match ) m ) ; } else if ( m instanceof Panther Match ) { panther Matches . add ( ( Panther Match ) m ) ; } else if ( m instanceof Signal P Match ) { signal P Matches . add ( ( Signal P Match ) m ) ; } else if ( m instanceof TMHMM Match ) { tmhmm P Matches . add ( ( TMHMM Match ) m ) ; } else { throw new Illegal Argument Exception ( STRING + m ) ; } } return new Matches Type ( rps Blast Matches , hmmer 2 Matches , hmmer 3 Matches , super Family Hmmer 3 Matches , finger Prints Matches , pro Dom Matches , pattern Scan Matches , profile Scan Matches , phobius Matches , coils Matches , panther Matches , signal P Matches , tmhmm P Matches ) ; }
public synchronized void ensure Capacity ( int minimum Capacity ) { if ( element Data . length < minimum Capacity ) { int next = ( capacity Increment <= NUM ? element Data . length : capacity Increment ) + element Data . length ; grow ( minimum Capacity > next ? minimum Capacity : next ) ; } }
public static void reverse ( final char [ ] buffer , final int start , final int len ) { if ( len < NUM ) return ; int end = ( start + len ) - NUM ; char front High = buffer [ start ] ; char end Low = buffer [ end ] ; boolean allow Front Sur = BOOL , allow End Sur = BOOL ; final int mid = start + ( len > > NUM ) ; for ( int i = start ; i < mid ; ++ i , -- end ) { final char front Low = buffer [ i + NUM ] ; final char end High = buffer [ end - NUM ] ; final boolean sur At Front = allow Front Sur && Character . is Surrogate Pair ( front High , front Low ) ; if ( sur At Front && ( len < NUM ) ) { return ; } final boolean sur At End = allow End Sur && Character . is Surrogate Pair ( end High , end Low ) ; allow Front Sur = allow End Sur = BOOL ; if ( sur At Front == sur At End ) { if ( sur At Front ) { buffer [ end ] = front Low ; buffer [ -- end ] = front High ; buffer [ i ] = end High ; buffer [ ++ i ] = end Low ; front High = buffer [ i + NUM ] ; end Low = buffer [ end - NUM ] ; } else { buffer [ end ] = front High ; buffer [ i ] = end Low ; front High = front Low ; end Low = end High ; } } else { if ( sur At Front ) { buffer [ end ] = front Low ; buffer [ i ] = end Low ; end Low = end High ; allow Front Sur = BOOL ; } else { buffer [ end ] = front High ; buffer [ i ] = end High ; front High = front Low ; allow End Sur = BOOL ; } } } if ( ( len & NUM ) == NUM && ! ( allow Front Sur && allow End Sur ) ) { buffer [ end ] = allow Front Sur ? end Low : front High ; } }
@ Override public String to String ( ) { return String . format ( STRING , ledger Id , entry Id ) ; }
public void clear ( ) { ored Criteria . clear ( ) ; order By Clause = null ; distinct = BOOL ; }
public void trigger ( Date time ) { task List . remove ( time ) ; }
private boolean check Touch Slop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL ; } final boolean check Horizontal = m Callback . get View Horizontal Drag Range ( child ) > NUM ; final boolean check Vertical = m Callback . get View Vertical Drag Range ( child ) > NUM ; if ( check Horizontal && check Vertical ) { return dx * dx + dy * dy > m Touch Slop * m Touch Slop ; } else if ( check Horizontal ) { return Math . abs ( dx ) > m Touch Slop ; } else if ( check Vertical ) { return Math . abs ( dy ) > m Touch Slop ; } return BOOL ; }
Cipher ( Cipher Spi cipher Spi , String transformation ) { this . spi = cipher Spi ; this . transformation = transformation ; this . crypto Perm = Crypto All Permission . INSTANCE ; this . lock = null ; }
public void test Flip Bit Positive Outside 1 ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = NUM ; int number = NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . flip Bit ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
private void write Object ( Object Output Stream a Output Stream ) throws IO Exception { a Output Stream . default Write Object ( ) ; }
@ Override public boolean is Panel Enabled ( ) { return multi Option Group Enabled ; }
public synchronized void add ( String name , long thread Id ) { if ( m Finished ) { throw new Illegal State Exception ( STRING ) ; } m Markers . add ( new Marker ( name , thread Id , System Clock . elapsed Realtime ( ) ) ) ; }
public static String to Unix Newline ( String input ) { return input . replace ( STRING , STRING ) ; }
private void output Indentation ( ) { for ( int i = NUM ; i < m indent ; i ++ ) { m out . print ( m basic Indent ) ; } }
protected Bucket < T > create Bucket ( long bucket Key ) { return new Bucket < T > ( bucket Key ) ; }
public Abstract Site Map parse Site Map ( byte [ ] content , URL url ) throws Unknown Format Exception , IO Exception { if ( url == null ) { return null ; } String filename = Filename Utils . get Name ( url . get Path ( ) ) ; String content Type = TIKA . detect ( content , filename ) ; return parse Site Map ( content Type , content , url ) ; }
private void pull Event ( ) { final int new Scroll Value ; final int item Dimension ; final float initial Motion Value , last Motion Value ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : initial Motion Value = m Initial Motion X ; last Motion Value = m Last Motion X ; break ; case VERTICAL : default : initial Motion Value = m Initial Motion Y ; last Motion Value = m Last Motion Y ; break ; } switch ( m Current Mode ) { case PULL FROM END : new Scroll Value = Math . round ( Math . max ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Footer Size ( ) ; break ; case PULL FROM START : default : new Scroll Value = Math . round ( Math . min ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Header Size ( ) ; break ; } set Header Scroll ( new Scroll Value ) ; if ( new Scroll Value != NUM && ! is Refreshing ( ) ) { float scale = Math . abs ( new Scroll Value ) / ( float ) item Dimension ; switch ( m Current Mode ) { case PULL FROM END : m Footer Layout . on Pull ( scale ) ; break ; case PULL FROM START : default : m Header Layout . on Pull ( scale ) ; break ; } if ( m State != State . PULL TO REFRESH && item Dimension >= Math . abs ( new Scroll Value ) ) { set State ( State . PULL TO REFRESH ) ; } else if ( m State == State . PULL TO REFRESH && item Dimension < Math . abs ( new Scroll Value ) ) { set State ( State . RELEASE TO REFRESH ) ; } } }
public Application Meta Data ( final Deserializer deserializer ) { this . app Name = deserializer . read String ( STRING ) ; this . version = deserializer . read String ( STRING ) ; this . certificate Signer = deserializer . read Optional String ( STRING ) ; this . start Time = Time Instant . read From ( deserializer , STRING ) ; this . current Time = Time Instant . read From ( deserializer , STRING ) ; this . time Provider = null ; }
public static Constraints Parameters load Policy Data ( Input Stream policy Data Stream ) { if ( policy Data Stream != null ) { return load ( policy Data Stream ) ; } if ( ( default Policy Constraints Location != null ) && ! default Policy Constraints Location . is Empty ( ) ) { return load ( default Policy Constraints Location ) ; } return null ; }
public static void close ( Output Stream out ) { try { if ( out != null ) { out . close ( ) ; } } catch ( IO Exception io E ) { } }
@ Override public boolean is Cell Editable ( int row , int col ) { if ( is Connected To Data Source ) { if ( col != FIELD COLUMN ID ) { return BOOL ; } else { return BOOL ; } } else { return BOOL ; } }
@ Override public boolean is Factory For Type ( Object type ) { return supported Types . contains ( type ) || super . is Factory For Type ( type ) ; }
private void save Sorted Pom File ( final String sorted Xml ) { file Util . save Pom File ( sorted Xml ) ; log . info ( STRING + pom File . get Absolute Path ( ) ) ; }
private void append Statements ( Policy Type policy , String prefix ) { List < Statement > append Statements = new Statements ( policy , prefix ) ; for ( Statement statement : append Statements ) { append Statement ( statement ) ; } }
private void validate TOTP Parameters ( ) throws Auth Login Exception { String Builder error Messages = new String Builder ( ) ; if ( String Utils . is Empty ( login Time Attr Name ) ) { error Messages . append ( STRING ) ; } if ( clock Drift Check Enabled && String Utils . is Empty ( observed Clock Drift Attr Name ) ) { error Messages . append ( STRING ) ; } if ( totp Time Step <= NUM ) { error Messages . append ( STRING + totp Time Step + STRING ) ; } if ( totp Steps In Window < NUM ) { error Messages . append ( STRING + totp Steps In Window ) ; } if ( error Messages . length ( ) > NUM ) { debug . error ( STRING + error Messages . to String ( ) ) ; throw new Auth Login Exception ( am Auth OATH , STRING , null ) ; } }
public static String remove Uri Fragment ( String url ) { if ( url == null || url . length ( ) == NUM ) { return null ; } String [ ] arr = url . split ( STRING ) ; if ( arr . length == NUM ) { return arr [ NUM ] ; } else { return url ; } }
public static void write Receipts To Files ( List < byte [ ] > printed Receipts , String prefix , File base Dir ) { try { int index = NUM ; for ( byte [ ] printed Receipt : printed Receipts ) { Byte Array Input Stream b In = new Byte Array Input Stream ( printed Receipt ) ; File receipt File = new File ( base Dir , prefix + STRING + index + STRING ) ; Buffered Output Stream buffered Output Stream = new Buffered Output Stream ( new File Output Stream ( receipt File ) ) ; IO Utils . copy ( b In , buffered Output Stream ) ; buffered Output Stream . close ( ) ; index ++ ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
public synchronized void render Data For Projection ( Projection proj , java . awt . Graphics g ) { fire Status Update ( Layer Status Event . FINISH WORKING ) ; if ( proj == null ) { logger . info ( STRING ) ; return ; } else { set Target Index ( proj . get Scale ( ) ) ; Layer layer = get Appropriate Layer ( ) ; layer . render Data For Projection ( proj , g ) ; } }
public void write Exif ( Input Stream jpeg Stream , Output Stream exif Out Stream ) throws IO Exception { if ( jpeg Stream == null || exif Out Stream == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Output Stream s = get Exif Writer Stream ( exif Out Stream ) ; do Exif Stream IO ( jpeg Stream , s ) ; s . flush ( ) ; }
private Container Panel create Container Panel ( ) { Container Panel container Panel = new Container Panel ( ) ; container Panel . set Animated ( BOOL ) ; container Panel . set Minimum Size ( new Dimension ( NUM , NUM ) ) ; character = new Character ( ) ; container Panel . add Repaintable ( character ) ; inventory = new Slot Window ( STRING , NUM , NUM ) ; inventory . set Accepted Types ( Entity Map . get Class ( STRING , null , null ) ) ; inventory . set Closeable ( BOOL ) ; container Panel . add Repaintable ( inventory ) ; keyring = new Key Ring ( ) ; keyring . set Accepted Types ( Entity Map . get Class ( STRING , null , null ) ) ; container Panel . add Repaintable ( keyring ) ; user Context . add Feature Change Listener ( keyring ) ; spells = new Spells ( ) ; spells . set Accepted Types ( Entity Map . get Class ( STRING , null , null ) ) ; container Panel . add Repaintable ( spells ) ; user Context . add Feature Change Listener ( spells ) ; return container Panel ; }
public void copy From Geometry 3 D ( Geometry 3 D geom ) { this . m Num Indices = geom . get Num Indices ( ) ; this . m Num Vertices = geom . get Num Vertices ( ) ; this . m Vertex Buffer Info = geom . get Vertex Buffer Info ( ) ; this . m Index Buffer Info = geom . get Index Buffer Info ( ) ; this . m Tex Coord Buffer Info = geom . get Tex Coord Buffer Info ( ) ; this . m Only Short Buffer Supported = geom . are Only Short Buffers Supported ( ) ; if ( m Colors == null ) this . m Color Buffer Info = geom . get Color Buffer Info ( ) ; this . m Normal Buffer Info = geom . get Normal Buffer Info ( ) ; this . m Original Geometry = geom ; this . m Has Normals = geom . has Normals ( ) ; this . m Has Texture Coordinates = geom . has Texture Coordinates ( ) ; }
@ Override public void add Property Change Listener ( Property Change Listener pcl ) { m pc Support . add Property Change Listener ( pcl ) ; }
public static Intent implicit 2 Explicit Intent ( Context context , Intent implicit Intent ) { Package Manager pm = context . get Package Manager ( ) ; List < Resolve Info > resolve Info = pm . query Intent Services ( implicit Intent , NUM ) ; if ( resolve Info == null || resolve Info . size ( ) != NUM ) { return null ; } Resolve Info service Info = resolve Info . get ( NUM ) ; String package Name = service Info . service Info . package Name ; String class Name = service Info . service Info . name ; Component Name component = new Component Name ( package Name , class Name ) ; Intent explicit Intent = new Intent ( implicit Intent ) ; explicit Intent . set Component ( component ) ; return explicit Intent ; }
private synchronized void garbage Collect Peer ( Peer peer ) { log . debug ( STRING + peer ) ; m Current Peers . remove ( peer ) ; }
public void reset ( ) { synchronized ( this ) { queue . clear ( ) ; set Bridge Mode ( - NUM ) ; } }
@ Post Construct public void init Application ( ) throws IO Exception { if ( env . get Active Profiles ( ) . length == NUM ) { log . warn ( STRING ) ; } else { log . info ( STRING , Arrays . to String ( env . get Active Profiles ( ) ) ) ; } }
private void indent ( ) { out . print ( current Indention ) ; }
private void compute Implicit Forward Dependences Use ( Register r , Dep Graph Node dest Node ) { Dep Graph Node source Node = get Dep Graph Node ( r ) ; if ( source Node != null ) { for ( Enumeration < Register > e = Generic Physical Def Use . enumerate ( Generic Physical Def Use . get Mask TSP Defs ( ) , ir ) ; e . has More Elements ( ) ; ) { Register r2 = e . next Element ( ) ; if ( r == r2 ) { source Node . insert Out Edge ( dest Node , REG MAY DEF ) ; return ; } } source Node . insert Out Edge ( dest Node , REG TRUE ) ; } }
public String description ( ) { synchronized ( this ) { if ( messages == null ) { messages = Resource Bundle . get Bundle ( STRING ) ; } } return messages . get String ( STRING ) ; }
Set find Removable Aci List ( Set aci List ) throws AM Exception , SSO Exception { Set result Set = new Hash Set ( ) ; if ( aci List == null ) { return result Set ; } Iterator iter = aci List . iterator ( ) ; while ( iter . has Next ( ) ) { String aci = ( String ) iter . next ( ) ; Set objs = ds Services . search ( token , AM Store Connection . get AM Sdk Base DN ( ) , STRING + AM Search Filter Manager . get Global Search Filter ( AM Object . GROUP ) + STRING + aci + STRING , AM Constants . SCOPE SUB ) ; if ( objs . size ( ) < NUM ) { result Set . add ( aci ) ; } } return result Set ; }
protected final void unregister Data Source ( Data Source removed ) { unregister Data Sources ( Collections . singleton ( removed ) ) ; }
public String dump ( byte [ ] der ) throws Asn 1 Exception , IO Exception { try { ASN 1 Primitive der Object = ASN 1 Primitive . from Byte Array ( der ) ; if ( der Object . get Encoded ( ) . length < der . length ) { throw new Asn 1 Exception ( res . get String ( STRING ) ) ; } return dump ( der Object ) ; } catch ( IO Exception ex ) { throw new Asn 1 Exception ( res . get String ( STRING ) , ex ) ; } }
private static void assert Change Events ( Collection < Port Change Event > early Events , Collection < Port Change Event > late Events , Collection < Port Change Event > anytime Events , Collection < Port Change Event > actual Events ) { String input Desc = String . format ( STRING + STRING , early Events . to String ( ) , late Events . to String ( ) , anytime Events . to String ( ) , actual Events . to String ( ) ) ; Collection < Port Change Event > early = new Array List < Port Change Event > ( early Events ) ; Collection < Port Change Event > late = new Array List < Port Change Event > ( late Events ) ; Collection < Port Change Event > any = new Array List < Port Change Event > ( anytime Events ) ; for ( Port Change Event ev : early ) { assert False ( STRING , late . contains ( ev ) ) ; assert False ( STRING , any . contains ( ev ) ) ; } for ( Port Change Event ev : late ) { assert False ( STRING , early . contains ( ev ) ) ; assert False ( STRING , any . contains ( ev ) ) ; } for ( Port Change Event ev : any ) { assert False ( STRING , early . contains ( ev ) ) ; assert False ( STRING , late . contains ( ev ) ) ; } for ( Port Change Event a : actual Events ) { if ( early . remove ( a ) ) { continue ; } if ( any . remove ( a ) ) { continue ; } if ( late . remove ( a ) ) { if ( ! early . is Empty ( ) ) { fail ( a + STRING + STRING + input Desc ) ; } else { continue ; } } fail ( a + STRING + input Desc ) ; } if ( ! early . is Empty ( ) ) fail ( STRING + early + STRING + input Desc ) ; if ( ! late . is Empty ( ) ) fail ( STRING + late + STRING + input Desc ) ; if ( ! any . is Empty ( ) ) fail ( STRING + any + STRING + input Desc ) ; }
public static Class need Class ( String property ) throws No Such Property Exception { String value = need Property ( property ) ; Class c = null ; try { c = Class . for Name ( value ) ; } catch ( Class Not Found Exception e ) { throw new No Such Property Exception ( STRING + value + STRING + property + STRING ) ; } return c ; }
Dependency Spec create Module Dependency ( Artifact Result i , boolean force Export ) { if ( JDK MODULE NAMES . contains ( i . name ( ) ) ) return JDK DEPENDENCY ; final Module Identifier mi = create Module Identifier ( i ) ; final boolean export = force Export || ( i . import Type ( ) == Import Type . EXPORT ) ; return Dependency Spec . create Module Dependency Spec ( Path Filters . get Meta Inf Subdirectories Without Meta Inf Filter ( ) , ( export ? Path Filters . accept All ( ) : Path Filters . reject All ( ) ) , this , mi , i . import Type ( ) == Import Type . OPTIONAL ) ; }
public void append Nodes ( Node Set nodes ) { int n Nodes = nodes . size ( ) ; if ( null == m map ) { m map Size = n Nodes + m blocksize ; m map = new Node [ m map Size ] ; } else if ( ( m first Free + n Nodes ) >= m map Size ) { m map Size += ( n Nodes + m blocksize ) ; Node new Map [ ] = new Node [ m map Size ] ; System . arraycopy ( m map , NUM , new Map , NUM , m first Free + n Nodes ) ; m map = new Map ; } System . arraycopy ( nodes . m map , NUM , m map , m first Free , n Nodes ) ; m first Free += n Nodes ; }
public void make Immutable ( ) { if ( is Mutable ) { is Mutable = BOOL ; } }
private int read Epoch ( File epoch File ) { int epoch = - NUM ; if ( ! epoch File . exists ( ) ) { return epoch ; } try { Scanner scanner = new Scanner ( epoch File ) ; epoch = scanner . next Int ( ) ; log . debug ( STRING , epoch , epoch File . get Name ( ) ) ; } catch ( IO Exception e ) { log . error ( STRING , epoch File . get Name ( ) , e ) ; } return epoch ; }
private int fast Match ( String sha 1 ) { Integer idx = indexes . get ( sha 1 ) ; if ( idx == null ) return - NUM ; else return idx . int Value ( ) ; }
public void or ( Criteria criteria ) { ored Criteria . add ( criteria ) ; }
public static void format ( String format , Object ... args ) { if ( ! is Disabled ( ) ) { print ( String . format ( format , args ) ) ; } }
public void concatenate ( SIP Object List other List ) { super . concatenate ( other List ) ; }
@ Override @ Transactional protected void persist ( Collection < Raw Protein < Prints Raw Match > > filtered Proteins , Map < String , Signature > model Id To Signature Map , Map < String , Protein > protein Id To Protein Map ) { for ( Raw Protein < Prints Raw Match > raw Protein : filtered Proteins ) { Protein protein = protein Id To Protein Map . get ( raw Protein . get Protein Identifier ( ) ) ; if ( protein == null ) { throw new Illegal State Exception ( STRING + STRING + raw Protein . get Protein Identifier ( ) + STRING ) ; } Set < Finger Prints Match . Finger Prints Location > locations = null ; String current Signature Ac = null ; Signature current Signature = null ; Prints Raw Match last Raw Match = null ; final Tree Set < Prints Raw Match > sorted Matches = new Tree Set < Prints Raw Match > ( PRINTS RAW MATCH COMPARATOR ) ; sorted Matches . add All ( raw Protein . get Matches ( ) ) ; Finger Prints Match match = null ; for ( Prints Raw Match raw Match : sorted Matches ) { if ( raw Match == null ) { continue ; } if ( current Signature Ac == null || ! current Signature Ac . equals ( raw Match . get Model Id ( ) ) ) { if ( current Signature Ac != null ) { if ( match != null ) { entity Manager . persist ( match ) ; } match = new Finger Prints Match ( current Signature , last Raw Match . get Evalue ( ) , last Raw Match . get Graphscan ( ) , locations ) ; protein . add Match ( match ) ; } locations = new Hash Set < Finger Prints Match . Finger Prints Location > ( ) ; current Signature Ac = raw Match . get Model Id ( ) ; current Signature = model Id To Signature Map . get ( current Signature Ac ) ; if ( current Signature == null ) { throw new Illegal State Exception ( STRING + current Signature Ac + STRING ) ; } } locations . add ( new Finger Prints Match . Finger Prints Location ( raw Match . get Location Start ( ) , bounded Location End ( protein , raw Match ) , raw Match . get Pvalue ( ) , raw Match . get Score ( ) , raw Match . get Motif Number ( ) ) ) ; last Raw Match = raw Match ; } if ( last Raw Match != null ) { match = new Finger Prints Match ( current Signature , last Raw Match . get Evalue ( ) , last Raw Match . get Graphscan ( ) , locations ) ; protein . add Match ( match ) ; entity Manager . persist ( match ) ; } } }
public Builder with Key Store Password ( String trust Store Password ) { properties . set Property ( Netty Options . SSL KEY STORE PASSWORD , Assert . not Null ( trust Store Password , STRING ) ) ; return this ; }
public static String suffix ( String string , String suffix ) { if ( string . ends With ( suffix ) == BOOL ) { string += suffix ; } return string ; }
public Point 2 D ( double x , double y ) { if ( Double . is Infinite ( x ) || Double . is Infinite ( y ) ) throw new Illegal Argument Exception ( STRING ) ; if ( Double . is Na N ( x ) || Double . is Na N ( y ) ) throw new Illegal Argument Exception ( STRING ) ; if ( x == NUM ) this . x = NUM ; else this . x = x ; if ( y == NUM ) this . y = NUM ; else this . y = y ; }
public static void server Failed ( String service Name ) { if ( service Name . starts With ( valid Remote URL ) ) { server Failed = BOOL ; } else { remote Stubs . remove ( service Name ) ; } }
public Request Handler ( Pokemon Go api , Ok Http Client client ) { this . api = api ; this . client = client ; api Endpoint = Api Settings . API ENDPOINT ; async Http Thread = new Thread ( this , STRING ) ; async Http Thread . set Daemon ( BOOL ) ; async Http Thread . start ( ) ; }
public String to String ( ) { String s = STRING ; Enumeration names = get Attribute Names ( ) ; while ( names . has More Elements ( ) ) { Object key = names . next Element ( ) ; Object value = get Attribute ( key ) ; if ( value instanceof Attribute Set ) { s = s + key + STRING ; } else { s = s + key + STRING + value + STRING ; } } return s ; }
public VN Xe Command Result remove Luns From Consistency Group ( String cg Id , List < String > luns ) { Lun Group Modify Param param = new Lun Group Modify Param ( ) ; List < Lun Add Param > lun Removes = new Array List < Lun Add Param > ( ) ; for ( String lun Id : luns ) { VN Xe Base lun = new VN Xe Base ( lun Id ) ; Lun Add Param lun Add = new Lun Add Param ( ) ; lun Add . set Lun ( lun ) ; lun Removes . add ( lun Add ) ; } param . set Lun Remove ( lun Removes ) ; Consistency Group Requests req = new Consistency Group Requests ( kh Client ) ; return req . modify Consistency Group Sync ( cg Id , param ) ; }
private static boolean not Instance Available ( ) { if ( s Instance == null ) { if ( ! s Training Task Future . is Done ( ) ) { try { s Instance = s Training Task Future . get ( ) ; return BOOL ; } catch ( Interrupted Exception | Execution Exception e ) { e . print Stack Trace ( ) ; return BOOL ; } } else { return BOOL ; } } return BOOL ; }
public void read Data ( Data Input din ) throws IO Exception { status = din . read Unsigned Short ( ) ; events = din . read Unsigned Short ( ) ; }
private boolean check Touch Slop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL ; } final boolean check Horizontal = m Callback . get View Horizontal Drag Range ( child ) > NUM ; final boolean check Vertical = m Callback . get View Vertical Drag Range ( child ) > NUM ; if ( check Horizontal && check Vertical ) { return dx * dx + dy * dy > m Touch Slop * m Touch Slop ; } else if ( check Horizontal ) { return Math . abs ( dx ) > m Touch Slop ; } else if ( check Vertical ) { return Math . abs ( dy ) > m Touch Slop ; } return BOOL ; }
public void remove ( String identifier , Active Connection Record record ) { synchronized ( records ) { Set < Active Connection Record > connections = records . get ( identifier ) ; assert ( connections != null ) ; connections . remove ( record ) ; if ( connections . is Empty ( ) ) records . remove ( identifier ) ; } }
private String build Metro Proint Placement Status String ( ) { String Buffer placement Status Buf = new String Buffer ( ) ; if ( placement Status != null ) { placement Status Buf . append ( String . format ( STRING ) ) ; placement Status Buf . append ( placement Status . to String ( db Client ) ) ; } if ( secondary Placement Status != null ) { placement Status Buf . append ( String . format ( STRING ) ) ; placement Status Buf . append ( secondary Placement Status . to String ( db Client ) ) ; } return placement Status Buf . to String ( ) ; }
private boolean has Sequence ( Subgraph graph ) { int odd Degree Count = NUM ; for ( Iterator i = graph . node Iterator ( ) ; i . has Next ( ) ; ) { Node node = ( Node ) i . next ( ) ; if ( node . get Degree ( ) % NUM == NUM ) odd Degree Count ++ ; } return odd Degree Count <= NUM ; }
public void ensure Additional Capacity ( final int size ) { final int new Count = visible . position ( ) + size ; if ( new Count > visible . capacity ( ) ) { final Byte Buffer new Byte Buffer = Byte Buffer . allocate ( Math . max ( visible . capacity ( ) << NUM , new Count ) ) ; visible . flip ( ) ; visible = new Byte Buffer . put ( visible ) ; } }
public void force Reload ( File file ) { f Files To Reoad . add ( file ) ; }
private static long long Multiply Power Ten ( long val , int n ) { if ( val == NUM || n <= NUM ) return val ; long [ ] tab = LONG TEN POWERS TABLE ; long [ ] bounds = THRESHOLDS TABLE ; if ( n < tab . length && n < bounds . length ) { long tenpower = tab [ n ] ; if ( val == NUM ) return tenpower ; if ( Math . abs ( val ) <= bounds [ n ] ) return val * tenpower ; } return INFLATED ; }
public static int wild Compare ( String search In , String search For Wildcard ) { if ( ( search In == null ) || ( search For Wildcard == null ) ) { return WILD COMPARE NO MATCH ; } if ( search For Wildcard . equals ( STRING ) ) { return WILD COMPARE MATCH WITH WILD ; } int result = WILD COMPARE NO MATCH ; char wildcard Many = STRING ; char wildcard One = STRING ; char wildcard Escape = STRING ; int search For Pos = NUM ; int search For End = search For Wildcard . length ( ) ; int search In Pos = NUM ; int search In End = search In . length ( ) ; while ( search For Pos != search For End ) { char wildstr Char = search For Wildcard . char At ( search For Pos ) ; while ( ( search For Wildcard . char At ( search For Pos ) != wildcard Many ) && ( wildstr Char != wildcard One ) ) { if ( ( search For Wildcard . char At ( search For Pos ) == wildcard Escape ) && ( ( search For Pos + NUM ) != search For End ) ) { search For Pos ++ ; } if ( ( search In Pos == search In End ) || ( Character . to Upper Case ( search For Wildcard . char At ( search For Pos ++ ) ) != Character . to Upper Case ( search In . char At ( search In Pos ++ ) ) ) ) { return WILD COMPARE MATCH WITH WILD ; } if ( search For Pos == search For End ) { return ( ( search In Pos != search In End ) ? WILD COMPARE MATCH WITH WILD : WILD COMPARE MATCH NO WILD ) ; } result = WILD COMPARE MATCH WITH WILD ; } if ( search For Wildcard . char At ( search For Pos ) == wildcard One ) { do { if ( search In Pos == search In End ) { return ( result ) ; } search In Pos ++ ; } while ( ( ++ search For Pos < search For End ) && ( search For Wildcard . char At ( search For Pos ) == wildcard One ) ) ; if ( search For Pos == search For End ) { break ; } } if ( search For Wildcard . char At ( search For Pos ) == wildcard Many ) { char cmp ; search For Pos ++ ; for ( ; search For Pos != search For End ; search For Pos ++ ) { if ( search For Wildcard . char At ( search For Pos ) == wildcard Many ) { continue ; } if ( search For Wildcard . char At ( search For Pos ) == wildcard One ) { if ( search In Pos == search In End ) { return ( WILD COMPARE NO MATCH ) ; } search In Pos ++ ; continue ; } break ; } if ( search For Pos == search For End ) { return WILD COMPARE MATCH NO WILD ; } if ( search In Pos == search In End ) { return WILD COMPARE NO MATCH ; } if ( ( ( cmp = search For Wildcard . char At ( search For Pos ) ) == wildcard Escape ) && ( ( search For Pos + NUM ) != search For End ) ) { cmp = search For Wildcard . char At ( ++ search For Pos ) ; } search For Pos ++ ; do { while ( ( search In Pos != search In End ) && ( Character . to Upper Case ( search In . char At ( search In Pos ) ) != Character . to Upper Case ( cmp ) ) ) { search In Pos ++ ; } if ( search In Pos ++ == search In End ) { return WILD COMPARE NO MATCH ; } { int tmp = wild Compare ( search In , search For Wildcard ) ; if ( tmp <= NUM ) { return ( tmp ) ; } } } while ( ( search In Pos != search In End ) && ( search For Wildcard . char At ( NUM ) != wildcard Many ) ) ; return WILD COMPARE NO MATCH ; } } return ( ( search In Pos != search In End ) ? WILD COMPARE MATCH WITH WILD : WILD COMPARE MATCH NO WILD ) ; }
boolean compare Methods ( @ Nullable Method a , @ Nullable Method b ) { if ( ( a == null ) != ( b == null ) ) { return BOOL ; } if ( a != null && b != null ) { if ( ! a . equals ( b ) ) { return BOOL ; } } return BOOL ; }
public Object remove ( String markername ) { return prefix Librarian . remove ( markername ) ; }
String format Last Modified ( String file Name ) { synchronized ( date Format ) { return date Format . format ( new Date ( File Utils . last Modified ( file Name ) ) ) ; } }
public True Type Font ( String platname , Object native Names , int f Index , boolean java Rasterizer , boolean use File Pool ) throws Font Format Exception { super ( platname , native Names ) ; use Java Rasterizer = java Rasterizer ; font Rank = Font 2 D . TTF RANK ; try { verify ( use File Pool ) ; init ( f Index ) ; if ( ! use File Pool ) { close ( ) ; } } catch ( Throwable t ) { close ( ) ; if ( t instanceof Font Format Exception ) { throw ( Font Format Exception ) t ; } else { throw new Font Format Exception ( STRING ) ; } } Disposer . add Object Record ( this , disposer Record ) ; }
public void calc Min Max ( ) { if ( m Data Sets == null ) return ; mY Max = - Float . MAX VALUE ; mY Min = Float . MAX VALUE ; mX Max = - Float . MAX VALUE ; mX Min = Float . MAX VALUE ; for ( int i = NUM , size = m Data Sets . size ( ) ; i < size ; i ++ ) { T set = m Data Sets . get ( i ) ; calc Min Max ( set ) ; } m Left Axis Max = - Float . MAX VALUE ; m Left Axis Min = Float . MAX VALUE ; m Right Axis Max = - Float . MAX VALUE ; m Right Axis Min = Float . MAX VALUE ; T first Left = get First Left ( m Data Sets ) ; if ( first Left != null ) { m Left Axis Max = first Left . get Y Max ( ) ; m Left Axis Min = first Left . get Y Min ( ) ; for ( int i = NUM ; i < m Data Sets . size ( ) ; i ++ ) { T data Set = m Data Sets . get ( i ) ; if ( data Set . get Axis Dependency ( ) == Axis Dependency . LEFT ) { if ( data Set . get Y Min ( ) < m Left Axis Min ) m Left Axis Min = data Set . get Y Min ( ) ; if ( data Set . get Y Max ( ) > m Left Axis Max ) m Left Axis Max = data Set . get Y Max ( ) ; } } } T first Right = get First Right ( m Data Sets ) ; if ( first Right != null ) { m Right Axis Max = first Right . get Y Max ( ) ; m Right Axis Min = first Right . get Y Min ( ) ; for ( int i = NUM ; i < m Data Sets . size ( ) ; i ++ ) { T data Set = m Data Sets . get ( i ) ; if ( data Set . get Axis Dependency ( ) == Axis Dependency . RIGHT ) { if ( data Set . get Y Min ( ) < m Right Axis Min ) m Right Axis Min = data Set . get Y Min ( ) ; if ( data Set . get Y Max ( ) > m Right Axis Max ) m Right Axis Max = data Set . get Y Max ( ) ; } } } }
public Logarithmic Axis ( String label ) { super ( label ) ; setup Number Fmt Obj ( ) ; }
protected final boolean has cycle recu ( Set < Brd Item > p visited items , Brd Item p search item , Brd Item p come from item , boolean p ignore areas ) { if ( p ignore areas && ( this instanceof Brd Area Conduction ) ) return BOOL ; Collection < Brd Item > contact list = get normal contacts ( ) ; if ( contact list == null ) return BOOL ; for ( Brd Item curr contact : contact list ) { if ( curr contact == p come from item ) continue ; if ( curr contact == p search item ) return BOOL ; if ( ! p visited items . add ( curr contact ) ) continue ; if ( curr contact . has cycle recu ( p visited items , p search item , this , p ignore areas ) ) return BOOL ; } return BOOL ; }
public static boolean is Calling Class Reflection Available ( ) { return BOOL ; }
@ Override public void add Table Model Listener ( Table Model Listener l ) { m Listeners . add ( l ) ; }
public Process exec ( String [ ] tainted Command , String [ ] tainted Environment , File working Directory , boolean redirect Error Stream ) throws IO Exception { if ( tainted Command == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( tainted Command . length == NUM ) { throw new Index Out Of Bounds Exception ( STRING ) ; } String [ ] command = tainted Command . clone ( ) ; String [ ] environment = tainted Environment != null ? tainted Environment . clone ( ) : null ; for ( int i = NUM ; i < command . length ; i ++ ) { if ( command [ i ] == null ) { throw new Null Pointer Exception ( STRING + i + STRING ) ; } } if ( environment != null ) { for ( int i = NUM ; i < environment . length ; i ++ ) { if ( environment [ i ] == null ) { throw new Null Pointer Exception ( STRING + i + STRING ) ; } } } File Descriptor in = new File Descriptor ( ) ; File Descriptor out = new File Descriptor ( ) ; File Descriptor err = new File Descriptor ( ) ; String working Path = ( working Directory == null ) ? null : working Directory . get Path ( ) ; synchronized ( process References ) { int pid ; try { pid = exec ( command , environment , working Path , in , out , err , redirect Error Stream ) ; } catch ( IO Exception e ) { IO Exception wrapper = new IO Exception ( STRING + STRING + Arrays . to String ( command ) + STRING + working Directory + STRING + Arrays . to String ( environment ) ) ; wrapper . init Cause ( e ) ; throw wrapper ; } Process Impl process = new Process Impl ( pid , in , out , err ) ; Process Reference process Reference = new Process Reference ( process , reference Queue ) ; process References . put ( pid , process Reference ) ; process References . notify All ( ) ; return process ; } }
private static String [ ] form Grams ( String text , int ng ) { int len = text . length ( ) ; String [ ] res = new String [ len - ng + NUM ] ; for ( int i = NUM ; i < len - ng + NUM ; i ++ ) { res [ i ] = text . substring ( i , i + ng ) ; } return res ; }
public void load Settings From Json ( ) { synchronized ( LOCK ) { load Settings From Json ( default File ) ; for ( String file Name : files ) { load Settings From Json ( file Name ) ; } } }
public void test Flush ( ) throws Exception { byte [ ] data = new byte [ ] { - NUM , - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM } ; Test Output Stream tos = new Test Output Stream ( ) ; Cipher Output Stream cos = new Cipher Output Stream ( tos ) { } ; cos . write ( data ) ; cos . flush ( ) ; byte [ ] result = tos . to Byte Array ( ) ; if ( ! Arrays . equals ( result , data ) ) { fail ( STRING ) ; } }
public void load Train Icons ( ) { for ( Train train : get Trains By Id List ( ) ) { train . load Train Icon ( ) ; } }
public final String translate ( final Char Sequence input ) { if ( input == null ) { return null ; } try { final String Writer writer = new String Writer ( input . length ( ) * NUM ) ; translate ( input , writer ) ; return writer . to String ( ) ; } catch ( final IO Exception ioe ) { throw new Runtime Exception ( ioe ) ; } }
public void insert Reverse Sorted ( final int idx , final double distance ) { int i = NUM ; for ( List Node temp : m List ) { if ( temp . distance < distance ) { break ; } i ++ ; } m List . add ( i , new List Node ( idx , distance ) ) ; }
public double normal Distance ( final double x , final double y , final double z , final Membership ... bounds ) { final double dist = evaluate ( x , y , z ) ; final double perp X = x - dist * this . x ; final double perp Y = y - dist * this . y ; final double perp Z = z - dist * this . z ; if ( ! meets All Bounds ( perp X , perp Y , perp Z , bounds ) ) { return Double . POSITIVE INFINITY ; } return Math . abs ( dist ) ; }
public void test B Aand B Cbroker Network With Selectors Send First ( ) throws Exception { bridge Brokers ( STRING , STRING , BOOL , NUM , BOOL ) ; bridge Brokers ( STRING , STRING , BOOL , NUM , BOOL ) ; start All Brokers ( ) ; wait For Bridge Formation ( ) ; Destination dest = create Destination ( STRING , BOOL ) ; Hash Map < String , Object > props = new Hash Map < > ( ) ; props . put ( STRING , STRING ) ; send Messages ( STRING , dest , MESSAGE COUNT , props ) ; props . clear ( ) ; props . put ( STRING , STRING ) ; send Messages ( STRING , dest , MESSAGE COUNT , props ) ; Message Consumer client A = create Consumer ( STRING , dest , STRING ) ; Message Consumer client C = create Consumer ( STRING , dest , STRING ) ; Thread . sleep ( NUM ) ; Message Id List msgs A = get Consumer Messages ( STRING , client A ) ; Message Id List msgs C = get Consumer Messages ( STRING , client C ) ; assert Equals ( MESSAGE COUNT , msgs A . get Message Count ( ) ) ; assert Equals ( MESSAGE COUNT , msgs C . get Message Count ( ) ) ; }
private void generate Vector Drawable Result ( Vector Drawable vector , String next Vector Name , boolean is Last , boolean is First ) throws IO Exception { Custom Logger . log Error ( STRING + vector . get File Name ( ) + STRING + is Last ) ; if ( ! vector Already Defined . contains ( vector . get File Name ( ) ) ) { current Vector File Name = vector . get File Name ( ) ; Custom Logger . log Error ( STRING + current Vector File Name ) ; File vector File = new File ( drawable Folder , current Vector File Name + STRING ) ; Buffered Writer vector BW = create It ( vector File ) ; Custom Logger . log ( STRING + vector File . get Absolute Path ( ) ) ; generate Vector Drawable ( vector , vector BW , is Last ) ; vector Already Defined . add ( vector . get File Name ( ) ) ; vector BW . flush ( ) ; vector BW . close ( ) ; } if ( ! is Last ) { File animated Vector File = new File ( drawable Folder , animated Vector . replace ( STRING , current Vector File Name ) ) ; Buffered Writer animated Vector BW = create It ( animated Vector File ) ; Custom Logger . log ( STRING + animated Vector File . get Absolute Path ( ) ) ; Custom Logger . log Error ( STRING + animated Vector File . get Absolute Path ( ) + STRING + next Vector Name ) ; generate Animated Vector ( vector , animated Vector BW , next Vector Name , BOOL ) ; generate Animator Set ( vector , BOOL ) ; animated Vector BW . flush ( ) ; animated Vector BW . close ( ) ; } if ( ! is Last ) { File animated Vector File = new File ( drawable Folder , animated Vector . replace ( STRING , current Vector File Name + reverse ) ) ; Buffered Writer animated Vector BW = create It ( animated Vector File ) ; Custom Logger . log ( STRING + animated Vector File . get Absolute Path ( ) ) ; Custom Logger . log Error ( STRING + animated Vector File . get Absolute Path ( ) + STRING + next Vector Name ) ; generate Animated Vector ( vector , animated Vector BW , next Vector Name , BOOL ) ; generate Animator Set ( vector , BOOL ) ; animated Vector BW . flush ( ) ; animated Vector BW . close ( ) ; } }
public void access ( ) { last Accessed Time = System . current Time Millis ( ) ; }
public void write To Object ( Object object ) { try { Method method = Bean Utils . get Write Method ( object . get Class ( ) , get Name ( ) , get Type ( ) ) ; if ( method != null ) { method . invoke ( object , new Object [ ] { get Value ( ) } ) ; } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
private Http URL Connection do HTTP Post Request ( String location , String client Session Id , Map < String , String > metadata , String post Body ) throws Communication Exception { Output Stream Writer writer = null ; try { URL url = new URL ( location ) ; Http URL Connection connection = ( Http URL Connection ) url . open Connection ( ) ; connection . set Request Method ( STRING ) ; connection . add Request Property ( STRING , STRING ) ; if ( client Session Id != null ) { connection . add Request Property ( HTTP HEADER SESSION ID , STRING + client Session Id ) ; } if ( metadata != null ) { connection . add Request Property ( HTTP HEADER METADATA , Gc Util . get Base 64 Encoded Metadata ( metadata ) ) ; } if ( Constants . ENABLE REQUEST LOGGING ) { log Request ( connection , post Body ) ; } connection . set Do Output ( BOOL ) ; writer = new Output Stream Writer ( connection . get Output Stream ( ) , STRING ) ; writer . write ( post Body ) ; writer . flush ( ) ; if ( connection . get Response Code ( ) != NUM ) { throw new Communication Exception ( STRING + connection . get Response Code ( ) ) ; } return connection ; } catch ( Malformed URL Exception e ) { Log . e ( TAG , STRING + location ) ; throw new Communication Exception ( STRING + location ) ; } catch ( IO Exception e ) { Log . e ( TAG , STRING + e . get Message ( ) ) ; throw new Communication Exception ( STRING + e . get Message ( ) , e ) ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( IO Exception e ) { Log . i ( TAG , STRING + e . get Message ( ) ) ; } } } }
void io Message ( Throwable ex ) { log . print Lines ( Prefix Kind . JAVAC , STRING ) ; ex . print Stack Trace ( log . get Writer ( Writer Kind . NOTICE ) ) ; }
Object Animator animate Bound Scroll ( ) { float cur Scroll = get Stack Scroll ( ) ; float new Scroll = get Bounded Stack Scroll ( cur Scroll ) ; if ( Float . compare ( new Scroll , cur Scroll ) != NUM ) { animate Scroll ( cur Scroll , new Scroll , null ) ; } return m Scroll Animator ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String substring ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; substring = child . substring Data ( NUM , NUM ) ; assert Equals ( STRING , STRING , substring ) ; }
public static Collection < UUID > node Ids ( @ Nullable Collection < ? extends Cluster Node > nodes ) { if ( nodes == null || nodes . is Empty ( ) ) return Collections . empty List ( ) ; return F . view Read Only ( nodes , node 2 id ( ) ) ; }
public static Input Stream to Input Stream ( final Char Sequence input , final Charset encoding ) { return IO Utils . to Input Stream ( input . to String ( ) , encoding ) ; }
public static boolean matches XML String ( char [ ] buf , int off , int end , String str ) { int len = str . length ( ) ; if ( len != end - off ) return BOOL ; for ( int i = NUM ; i < len ; off += NUM , i ++ ) { if ( buf [ off ] != str . char At ( i ) ) return BOOL ; } return BOOL ; }
public double r ( ) { return Math . sqrt ( x * x + y * y ) ; }
public void sign ( Key Pair keypair ) throws IO Exception { if ( namelist . is Empty ( ) ) { throw new Illegal State Exception ( STRING ) ; } if ( keypair == null ) { throw new Illegal Argument Exception ( STRING ) ; } try { General Name [ ] gns = new General Name [ namelist . size ( ) ] ; for ( int ix = NUM ; ix < namelist . size ( ) ; ix ++ ) { gns [ ix ] = new General Name ( General Name . dNS Name , namelist . get ( ix ) ) ; } General Names subject Alt Name = new General Names ( gns ) ; PKCS 10 Certification Request Builder p10 Builder = new Jca PKCS 10 Certification Request Builder ( namebuilder . build ( ) , keypair . get Public ( ) ) ; Extensions Generator extensions Generator = new Extensions Generator ( ) ; extensions Generator . add Extension ( Extension . subject Alternative Name , BOOL , subject Alt Name ) ; p10 Builder . add Attribute ( PKCS Object Identifiers . pkcs 9 at extension Request , extensions Generator . generate ( ) ) ; Private Key pk = keypair . get Private ( ) ; Jca Content Signer Builder cs Builder = new Jca Content Signer Builder ( pk instanceof EC Key ? EC SIGNATURE ALG : SIGNATURE ALG ) ; Content Signer signer = cs Builder . build ( pk ) ; csr = p10 Builder . build ( signer ) ; } catch ( Operator Creation Exception ex ) { throw new IO Exception ( STRING , ex ) ; } }
void remove Empty Rows ( final List list ) { for ( final Iterator < Receipt Detail Info > detail = list . iterator ( ) ; detail . has Next ( ) ; ) if ( detail . next ( ) == null ) detail . remove ( ) ; }
private void add ( String text , Text text Node ) { int start Index = builder . length ( ) ; builder . append ( text ) ; int end Index = builder . length ( ) ; text Runs . add ( new Text Run ( text Node , start Index , end Index ) ) ; }
public D Netscape Base Url ( J Dialog parent ) { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; init ( get Name ( ) ) ; }
public void append Row ( Row Spec row Spec ) { check Not Null ( row Spec , STRING ) ; row Specs . add ( row Spec ) ; }
public static < T > Reactive Seq < T > from Publisher ( final Publisher < ? extends T > publisher ) { Objects . require Non Null ( publisher ) ; final Seq Subscriber < T > sub = Seq Subscriber . subscriber ( ) ; publisher . subscribe ( sub ) ; return sub . stream ( ) ; }
public void multiply All Values By ( final double multiply By , final int Round Type ) { for ( final T t : key Set ( ) ) { double val = m values . get ( t ) ; switch ( Round Type ) { case NUM : val = Math . floor ( val * multiply By ) ; break ; case NUM : val = Math . round ( val * multiply By ) ; break ; case NUM : val = Math . ceil ( val * multiply By ) ; break ; default : val = val * multiply By ; break ; } put ( t , ( int ) val ) ; } }
public void on Tabs All Closing ( long time , boolean incognito ) { }
public final Test Subscriber < T > await ( Duration timeout ) { if ( cdl . get Count ( ) == NUM ) { return this ; } try { if ( ! cdl . await ( timeout . to Millis ( ) , Time Unit . MILLISECONDS ) ) { throw new Assertion Error ( STRING ) ; } return this ; } catch ( Interrupted Exception ex ) { throw new Assertion Error ( STRING , ex ) ; } }
protected void paint Content Border Bottom Edge ( Graphics g , int tab Placement , int selected Index , int x , int y , int w , int h ) { boolean left To Right = Compiere Utils . is Left To Right ( tab Pane ) ; int bottom = y + h - NUM ; int right = x + w - NUM ; Rectangle sel Rect = selected Index < NUM ? null : get Tab Bounds ( selected Index , calc Rect ) ; g . set Color ( shadow ) ; if ( tab Placement != BOTTOM || selected Index < NUM || ( sel Rect . x < x || sel Rect . x > x + w ) ) { g . set Color ( dark Shadow ) ; g . draw Line ( x , y + h - NUM , x + w - NUM , y + h - NUM ) ; } else { boolean last In Run = is Last In Run ( selected Index ) ; g . set Color ( dark Shadow ) ; if ( left To Right || last In Run ) g . draw Line ( x , bottom , sel Rect . x , bottom ) ; else g . draw Line ( x , bottom , sel Rect . x - NUM , bottom ) ; if ( sel Rect . x + sel Rect . width < x + w - NUM ) { if ( left To Right && ! last In Run ) g . draw Line ( sel Rect . x + sel Rect . width , bottom , right , bottom ) ; else g . draw Line ( sel Rect . x + sel Rect . width - NUM , bottom , right , bottom ) ; } } }
public static void upto ( double self , Number to , @ Closure Params ( First Param . class ) Closure closure ) { double to 1 = to . double Value ( ) ; if ( self <= to 1 ) { for ( double i = self ; i <= to 1 ; i ++ ) { closure . call ( i ) ; } } else throw new Groovy Runtime Exception ( STRING + to + STRING + self + STRING ) ; }
public void save ( String type , List < Elastic Search Doc > docs ) { if ( docs != null && ! docs . is Empty ( ) ) { List < List < Elastic Search Doc > > partitioned Docs = Lists . partition ( docs , NUM ) ; partitioned Docs . for Each ( null ) ; } }
public void error ( Source Locator src Lctr , String msg ) throws Transformer Exception { error ( src Lctr , null , null , msg , null ) ; }
void remove Listener ( String listener ID ) { if ( listener Objects != null ) { synchronized ( listener Objects ) { listener Objects . remove ( listener ID ) ; if ( listener Objects . is Empty ( ) ) { deregister Listener ( ) ; } } if ( debug . message Enabled ( ) ) { debug . message ( STRING + service Name + STRING + listener ID ) ; } } }
@ Deprecated public void register Credentials ( User Credential authentication ) { wallet . put ( authentication . get URL ( ) , authentication ) ; }
public void test Database Driver Properties User And Password Property Override DS User And Password ( ) { String driver Property String = STRING ; Properties props = new Properties ( ) ; props . set Property ( Datasource Property Set . USERNAME , STRING ) ; props . set Property ( Datasource Property Set . PASSWORD , STRING ) ; props . set Property ( Datasource Property Set . CONNECTION PROPERTIES , driver Property String ) ; Data Source ds = data Source Converter . from Properties ( props ) ; assert Equals ( STRING , ds . get Username ( ) ) ; assert Equals ( STRING , ds . get Password ( ) ) ; }
public boolean is AGC Enabled ( ) { return mAGC Enabled . get ( ) ; }
protected Linked List < String > split Into Allophones ( String phone String ) { Linked List < String > phone List = new Linked List < String > ( ) ; for ( int i = NUM ; i < phone String . length ( ) ; i ++ ) { String name = null ; for ( int j = NUM ; j >= NUM ; j -- ) { if ( i + j <= phone String . length ( ) ) { String candidate = phone String . substring ( i , i + j ) ; if ( get Allophone ( candidate ) != null ) { name = candidate ; i += j - NUM ; break ; } } } if ( name != null ) { phone List . add ( name ) ; } } return phone List ; }
protected void add To Maintenance Queue ( Node Port Tuple npt ) { if ( maintenance Queue . contains ( npt ) == BOOL ) { maintenance Queue . add ( npt ) ; } }
private boolean execute ( boolean read Response ) throws IO Exception { try { http Engine . send Request ( ) ; if ( read Response ) { http Engine . read Response ( ) ; } return BOOL ; } catch ( IO Exception e ) { if ( handle Failure ( e ) ) { return BOOL ; } else { throw e ; } } }
public Bigdata Sail ( final Properties properties ) { this ( properties . get Property ( Options . NAMESPACE , Options . DEFAULT NAMESPACE ) , new Journal ( properties ) ) ; close On Shutdown = BOOL ; if ( ! exists ( ) ) { try { create ( properties ) ; } catch ( Interrupted Exception | Execution Exception e ) { throw new Runtime Exception ( e ) ; } } }
public float convert ( ) { return Float . int Bits To Float ( ( int ) bytes ) ; }
protected int add Node ( Node node , int parent Index , int previous Sibling , int force Node Type ) { int node Index = m nodes . size ( ) ; if ( m dtm Ident . size ( ) == ( node Index > > > DTM Manager . IDENT DTM NODE BITS ) ) { try { if ( m mgr == null ) throw new Class Cast Exception ( ) ; DTM Manager Default mgr D = ( DTM Manager Default ) m mgr ; int id = mgr D . get First Free DTMID ( ) ; mgr D . add DTM ( this , id , node Index ) ; m dtm Ident . add Element ( id << DTM Manager . IDENT DTM NODE BITS ) ; } catch ( Class Cast Exception e ) { error ( XML Messages . create XML Message ( XML Error Resources . ER NO DTMIDS AVAIL , null ) ) ; } } m size ++ ; int type ; if ( NULL == force Node Type ) type = node . get Node Type ( ) ; else type = force Node Type ; if ( Node . ATTRIBUTE NODE == type ) { String name = node . get Node Name ( ) ; if ( name . starts With ( STRING ) || name . equals ( STRING ) ) { type = DTM . NAMESPACE NODE ; } } m nodes . add Element ( node ) ; m firstch . set Element At ( NOTPROCESSED , node Index ) ; m nextsib . set Element At ( NOTPROCESSED , node Index ) ; m prevsib . set Element At ( previous Sibling , node Index ) ; m parent . set Element At ( parent Index , node Index ) ; if ( DTM . NULL != parent Index && type != DTM . ATTRIBUTE NODE && type != DTM . NAMESPACE NODE ) { if ( NOTPROCESSED == m firstch . element At ( parent Index ) ) m firstch . set Element At ( node Index , parent Index ) ; } String ns URI = node . get Namespace URI ( ) ; String local Name = ( type == Node . PROCESSING INSTRUCTION NODE ) ? node . get Node Name ( ) : node . get Local Name ( ) ; if ( ( ( type == Node . ELEMENT NODE ) || ( type == Node . ATTRIBUTE NODE ) ) && null == local Name ) local Name = node . get Node Name ( ) ; Expanded Name Table exnt = m expanded Name Table ; if ( node . get Local Name ( ) == null && ( type == Node . ELEMENT NODE || type == Node . ATTRIBUTE NODE ) ) { } int expanded Name ID = ( null != local Name ) ? exnt . get Expanded Type ID ( ns URI , local Name , type ) : exnt . get Expanded Type ID ( type ) ; m exptype . set Element At ( expanded Name ID , node Index ) ; index Node ( expanded Name ID , node Index ) ; if ( DTM . NULL != previous Sibling ) m nextsib . set Element At ( node Index , previous Sibling ) ; if ( type == DTM . NAMESPACE NODE ) declare Namespace In Context ( parent Index , node Index ) ; return node Index ; }
public File Process Controller ( final File Controller Parameters arguments , final int pid ) { this ( arguments , pid , Long . get Long ( STATUS TIMEOUT PROPERTY , NUM * NUM ) , Time Unit . MILLISECONDS ) ; }
public void test Add Certificate 2 ( ) throws Exception { Identity i = new Identity Stub ( STRING ) ; Public Key Stub pk 1 = new Public Key Stub ( STRING , STRING , null ) ; Certificate Stub c1 = new Certificate Stub ( STRING , null , null , pk 1 ) ; i . add Certificate ( c1 ) ; assert Same ( c1 , i . certificates ( ) [ NUM ] ) ; assert Same ( pk 1 , i . get Public Key ( ) ) ; }
protected static final String add Escapes ( String str ) { String Buffer retval = new String Buffer ( ) ; char ch ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) { switch ( str . char At ( i ) ) { case NUM : continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; default : if ( ( ch = str . char At ( i ) ) < NUM || ch > NUM ) { String s = STRING + Integer . to String ( ch , NUM ) ; retval . append ( STRING + s . substring ( s . length ( ) - NUM , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . to String ( ) ; }
protected Set < Future < Void > > send ( String channel Id , Object message ) { Collection < Session > sessions = ( channel Id != null ) ? socket Sessions . get ( channel Id ) : null ; if ( sessions != null && ! sessions . is Empty ( ) ) { Set < Future < Void > > results = new Hash Set < > ( sessions . size ( ) ) ; String json = Json . encode ( message ) ; for ( Session session : sessions ) { if ( session . is Open ( ) ) { send ( session , json , results ) ; } } return results ; } return empty Set ( ) ; }
public Object attribute ( Object key ) { return ( attributes != null ) ? attributes . get ( key ) : null ; }
public Response do Put ( String url ) { return do Put ( url , null ) ; }
private static Pair < String , String > offset RRX ( final long offset , final I Translation Environment environment , final List < Reil Instruction > instructions , final String register Node Value 1 , final String register Node Value 2 ) { final String address = environment . get Next Variable String ( ) ; final String index = environment . get Next Variable String ( ) ; final String tmp Var = environment . get Next Variable String ( ) ; final String tmp Var 1 = environment . get Next Variable String ( ) ; final String tmp Var 2 = environment . get Next Variable String ( ) ; final String tmp Var 3 = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , bt , STRING , wd , String . value Of ( NUM ) , dw , tmp Var 1 ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value 2 , bt , String . value Of ( - NUM ) , dw , tmp Var 2 ) ) ; instructions . add ( Reil Helpers . create Or ( base Offset ++ , dw , tmp Var 1 , dw , tmp Var 2 , dw , tmp Var 3 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , dw , tmp Var 3 , dw , d Word Bit Mask , dw , index ) ) ; instructions . add ( Reil Helpers . create Add ( base Offset ++ , dw , register Node Value 1 , dw , index , dw , tmp Var ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , dw , tmp Var , dw , d Word Bit Mask , dw , address ) ) ; return new Pair < String , String > ( address , register Node Value 1 ) ; }
public void unregister Drop Controllers ( ) { drop Controller List . clear ( ) ; }
private static long Call Static Long Method V ( JNI Environment env , int class JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object return Obj = JNI Helpers . invoke With Var Arg ( method ID , arg Address , Type Reference . Long ) ; return Reflection . unwrap Long ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
public static String create Link ( String uri , String label ) { return STRING + uri + STRING + label + STRING ; }
public int size ( ) { return segments . size ( ) ; }
public void add Operand ( int start Tick , int end Tick , String text , Lifeline constraint Lifeline ) throws Sequence Diagram Checked Exception { if ( operands . size ( ) == NUM && this . start Tick != start Tick ) { throw new Illegal Argument Exception ( STRING ) ; } operands . add ( new Operand ( start Tick , end Tick , text , constraint Lifeline ) ) ; }
public static Number asin ( Number a ) { return Math . asin ( a . double Value ( ) ) ; }
private void create And Attach Event ( long ov ) throws Windows Exception { long h Event = Create Event ( BOOL , BOOL ) ; UNSAFE . put Address ( ov + OFFSETOF HEVENT , h Event ) ; }
public String to String ( ) { String Buffer result = new String Buffer ( ) ; result . append ( STRING ) ; int s1 = sizes . size ( ) ; for ( int i = NUM ; i < s1 ; ++ i ) { int s2 = sizes . get ( i ) ; result . append ( STRING ) ; for ( int j = NUM ; j < s2 ; ++ j ) { result . append ( vector [ i ] [ j ] ) ; if ( j + NUM < s2 ) result . append ( STRING ) ; } result . append ( STRING ) ; if ( i + NUM < s1 ) result . append ( STRING ) ; } result . append ( STRING ) ; return result . to String ( ) ; }
@ Override public int compare To ( String o ) { int result ; int major ; int minor ; int revision ; int pnt ; int [ ] maj = new int [ NUM ] ; int [ ] min = new int [ NUM ] ; int [ ] rev = new int [ NUM ] ; int [ ] point = new int [ NUM ] ; parse Version ( o , maj , min , rev , point ) ; major = maj [ NUM ] ; minor = min [ NUM ] ; revision = rev [ NUM ] ; pnt = point [ NUM ] ; if ( MAJOR < major ) { result = - NUM ; } else if ( MAJOR == major ) { if ( MINOR < minor ) { result = - NUM ; } else if ( MINOR == minor ) { if ( REVISION < revision ) { result = - NUM ; } else if ( REVISION == revision ) { if ( POINT < pnt ) { result = - NUM ; } else if ( POINT == pnt ) { result = NUM ; } else { result = NUM ; } } else { result = NUM ; } } else { result = NUM ; } } else { result = NUM ; } return result ; }
private void generate Integrity Key Pair ( boolean client Mode ) throws Unsupported Encoding Exception , IO Exception , No Such Algorithm Exception { byte [ ] cimagic = CLIENT INT MAGIC . get Bytes ( encoding ) ; byte [ ] simagic = SVR INT MAGIC . get Bytes ( encoding ) ; Message Digest md 5 = Message Digest . get Instance ( STRING ) ; byte [ ] key Buffer = new byte [ H A1 . length + cimagic . length ] ; System . arraycopy ( H A1 , NUM , key Buffer , NUM , H A1 . length ) ; System . arraycopy ( cimagic , NUM , key Buffer , H A1 . length , cimagic . length ) ; md 5 . update ( key Buffer ) ; byte [ ] Kic = md 5 . digest ( ) ; System . arraycopy ( simagic , NUM , key Buffer , H A1 . length , simagic . length ) ; md 5 . update ( key Buffer ) ; byte [ ] Kis = md 5 . digest ( ) ; if ( logger . is Loggable ( Level . FINER ) ) { trace Output ( DI CLASS NAME , STRING , STRING , Kic ) ; trace Output ( DI CLASS NAME , STRING , STRING , Kis ) ; } if ( client Mode ) { my Ki = Kic ; peer Ki = Kis ; } else { my Ki = Kis ; peer Ki = Kic ; } }
public static boolean is Local File Uri ( Uri uri ) { final String scheme = get Scheme Or Null ( uri ) ; return LOCAL FILE SCHEME . equals ( scheme ) ; }
Completable Future < Write Response > write ( List < Write Value > write Values ) ;
public static < V > boolean add Distinct Entry ( List < V > source List , V entry ) { return ( source List != null && ! source List . contains ( entry ) ) ? source List . add ( entry ) : BOOL ; }
public static boolean valid System Name Config ( String system Name , char type ) { if ( ! valid System Name Format ( system Name , type ) ) { return BOOL ; } int bit = get Bit From System Name ( system Name ) ; if ( ( type == STRING ) || ( type == STRING ) ) { if ( ( bit <= NUM ) || ( bit > Output Bits . get Num Output Bits ( ) ) ) { return BOOL ; } } else if ( type == STRING ) { if ( ( bit <= NUM ) || ( bit > Input Bits . get Num Input Bits ( ) ) ) { return BOOL ; } } else { log . error ( STRING ) ; return BOOL ; } return BOOL ; }
public boolean mouse Moved ( Mouse Event e ) { Esri Graphic List list = get Esri Graphic List ( ) ; boolean ret = BOOL ; if ( list != null ) { OM Graphic omg = list . find Closest ( e . get X ( ) , e . get Y ( ) , NUM ) ; if ( omg != null ) { int index ; Integer I = ( ( Integer ) omg . get Attribute ( SHAPE INDEX ATTRIBUTE ) ) ; if ( I != null ) { index = I . int Value ( ) ; } else { index = list . index Of ( omg ) ; } if ( parent Layer == null ) { Component comp = get Component ( ) ; if ( comp instanceof Layer ) { parent Layer = ( Layer ) comp ; } } if ( parent Layer != null ) { parent Layer . fire Request Tool Tip ( get Description ( index ) ) ; } ret = BOOL ; } else if ( parent Layer != null ) { parent Layer . fire Hide Tool Tip ( ) ; } } return ret ; }
private void push ( final int type ) { if ( output Stack == null ) { output Stack = new int [ NUM ] ; } int n = output Stack . length ; if ( output Stack Top >= n ) { int [ ] t = new int [ Math . max ( output Stack Top + NUM , NUM * n ) ] ; System . arraycopy ( output Stack , NUM , t , NUM , n ) ; output Stack = t ; } output Stack [ output Stack Top ++ ] = type ; int top = owner . input Stack Top + output Stack Top ; if ( top > owner . output Stack Max ) { owner . output Stack Max = top ; } }
public void create Database Entities For Business Object Data Notification Registration Testing ( String namespace , List < String > notification Event Types , String business Object Definition Namespace , String business Object Definition Name , List < String > file Types , List < String > storage Names , List < String > business Object Data Statuses , List < Job Action > job Actions ) { Namespace Entity namespace Entity = namespace Dao . get Namespace By Cd ( namespace ) ; if ( namespace Entity == null ) { namespace Dao Test Helper . create Namespace Entity ( namespace ) ; } if ( ! Collection Utils . is Empty ( notification Event Types ) ) { for ( String notification Event Type : notification Event Types ) { Notification Event Type Entity notification Event Type Entity = notification Event Type Dao . get Notification Event Type By Code ( notification Event Type ) ; if ( notification Event Type Entity == null ) { notification Registration Dao Test Helper . create Notification Event Type Entity ( notification Event Type ) ; } } } Business Object Definition Entity business Object Definition Entity = business Object Definition Dao . get Business Object Definition By Key ( new Business Object Definition Key ( business Object Definition Namespace , business Object Definition Name ) ) ; if ( business Object Definition Entity == null ) { business Object Definition Dao Test Helper . create Business Object Definition Entity ( business Object Definition Namespace , business Object Definition Name , Abstract Service Test . DATA PROVIDER NAME , Abstract Service Test . BDEF DESCRIPTION ) ; } if ( ! Collection Utils . is Empty ( file Types ) ) { for ( String business Object Format File Type : file Types ) { file Type Dao Test Helper . create File Type Entity ( business Object Format File Type ) ; } } if ( ! Collection Utils . is Empty ( storage Names ) ) { for ( String storage Name : storage Names ) { storage Dao Test Helper . create Storage Entity ( storage Name , Storage Platform Entity . S3 ) ; } } if ( ! Collection Utils . is Empty ( business Object Data Statuses ) ) { for ( String business Object Data Status : business Object Data Statuses ) { Business Object Data Status Entity business Object Data Status Entity = business Object Data Status Dao . get Business Object Data Status By Code ( business Object Data Status ) ; if ( business Object Data Status Entity == null ) { business Object Data Status Dao Test Helper . create Business Object Data Status Entity ( business Object Data Status ) ; } } } if ( ! Collection Utils . is Empty ( job Actions ) ) { for ( Job Action job Action : job Actions ) { job Definition Dao Test Helper . create Job Definition Entity ( job Action . get Namespace ( ) , job Action . get Job Name ( ) , String . format ( STRING , job Action . get Namespace ( ) , job Action . get Job Name ( ) ) , String . format ( STRING , job Action . get Namespace ( ) , job Action . get Job Name ( ) , Abstract Service Test . ACTIVITI ID ) ) ; } } }
public boolean post Data ( Input Stream data , Long length , Output Stream output , String type , URL url ) { if ( mock Mode ) return BOOL ; boolean success = BOOL ; if ( type == null ) type = DEFAULT CONTENT TYPE ; Http URL Connection urlc = null ; try { try { urlc = ( Http URL Connection ) url . open Connection ( ) ; try { urlc . set Request Method ( STRING ) ; } catch ( Protocol Exception e ) { fatal ( STRING + e ) ; } urlc . set Do Output ( BOOL ) ; urlc . set Do Input ( BOOL ) ; urlc . set Use Caches ( BOOL ) ; urlc . set Allow User Interaction ( BOOL ) ; urlc . set Request Property ( STRING , type ) ; basic Auth ( urlc ) ; if ( null != length ) { urlc . set Fixed Length Streaming Mode ( length ) ; } else { urlc . set Chunked Streaming Mode ( - NUM ) ; } urlc . connect ( ) ; } catch ( IO Exception e ) { fatal ( STRING + solr Url + STRING + e ) ; success = BOOL ; } catch ( Exception e ) { fatal ( STRING + e . get Message ( ) ) ; } try ( final Output Stream out = urlc . get Output Stream ( ) ) { pipe ( data , out ) ; } catch ( IO Exception e ) { fatal ( STRING + e ) ; } try { success &= check Response Code ( urlc ) ; try ( final Input Stream in = urlc . get Input Stream ( ) ) { pipe ( in , output ) ; } } catch ( IO Exception e ) { warn ( STRING + e ) ; success = BOOL ; } catch ( General Security Exception e ) { fatal ( STRING ) ; } } finally { if ( urlc != null ) urlc . disconnect ( ) ; } return success ; }
public Format Exception ( String s , Throwable root Cause ) { super ( s + STRING + root Cause . get Localized Message ( ) ) ; this . root Cause = root Cause ; }
private Pair < Big Decimal , Big Decimal > fill Payment ( final Customer Order order , final Customer Order Delivery delivery , final Payment payment , final boolean single Pay , final Big Decimal running Total , final Big Decimal running Total Tax , final boolean last Delivery ) { if ( payment . get Transaction Reference Id ( ) == null ) { payment . set Transaction Reference Id ( delivery . get Delivery Num ( ) ) ; } payment . set Order Shipment ( single Pay ? order . get Ordernum ( ) : delivery . get Delivery Num ( ) ) ; fill Payment Items ( delivery , payment ) ; fill Payment Shipment ( order , delivery , payment ) ; return fill Payment Amount ( order , delivery , payment , single Pay , running Total , running Total Tax , last Delivery ) ; }
public static double angle ( Number Vector v1 , Number Vector v2 , Number Vector o ) { final int dim 1 = v1 . get Dimensionality ( ) , dim 2 = v2 . get Dimensionality ( ) , dimo = o . get Dimensionality ( ) ; final int mindim = ( dim 1 <= dim 2 ) ? dim 1 : dim 2 ; double cross = NUM , l1 = NUM , l2 = NUM ; for ( int k = NUM ; k < mindim ; k ++ ) { final double ok = k < dimo ? o . double Value ( k ) : NUM ; final double r1 = v1 . double Value ( k ) - ok ; final double r2 = v2 . double Value ( k ) - ok ; cross += r1 * r2 ; l1 += r1 * r1 ; l2 += r2 * r2 ; } for ( int k = mindim ; k < dim 1 ; k ++ ) { final double ok = k < dimo ? o . double Value ( k ) : NUM ; final double r1 = v1 . double Value ( k ) - ok ; l1 += r1 * r1 ; } for ( int k = mindim ; k < dim 2 ; k ++ ) { final double ok = k < dimo ? o . double Value ( k ) : NUM ; final double r2 = v2 . double Value ( k ) - ok ; l2 += r2 * r2 ; } final double a = ( cross == NUM ) ? NUM : ( l1 == NUM || l2 == NUM ) ? NUM : Math . sqrt ( ( cross / l1 ) * ( cross / l2 ) ) ; return ( a < NUM ) ? a : NUM ; }
void materialize ( ) { if ( cachefill < NUM ) { return ; } double min = Double . MAX VALUE , max = Double . MIN VALUE ; for ( int i = NUM ; i < cachefill ; i ++ ) { min = Math . min ( min , cachec [ i ] ) ; max = Math . max ( max , cachec [ i ] ) ; } Linear Scale scale = new Linear Scale ( min , max ) ; min = scale . get Min ( ) ; max = scale . get Max ( ) ; this . base = min ; this . max = max ; this . binsize = ( max - min ) / this . destsize ; this . data = new float [ this . destsize << NUM ] ; size = destsize ; final int end = cachefill ; cachefill = - NUM ; for ( int i = NUM ; i < end ; i ++ ) { increment ( cachec [ i ] , cachev [ i ] ) ; } cachec = null ; cachev = null ; }
public boolean build Host Part ( Appendable buffer , String url , Boolean use SSL ) throws Web App Configuration Exception , IO Exception { return build Host Part ( buffer , url , use SSL , BOOL ) ; }
public static < T > List < T > shift Elements To End ( final List < T > source , final int count ) { final Array List < T > r Val = new Array List < > ( source . size ( ) ) ; for ( int i = count ; i < source . size ( ) ; i ++ ) { r Val . add ( source . get ( i ) ) ; } for ( int i = NUM ; i < count ; i ++ ) { r Val . add ( source . get ( i ) ) ; } if ( source . size ( ) != r Val . size ( ) ) { throw new Illegal State Exception ( STRING + count + STRING + source + STRING + r Val ) ; } return r Val ; }
private boolean is Leaf Page ( Byte Buffer buffer ) throws IO Exception { byte page Type = buffer . get ( NUM ) ; if ( page Type == Page Types . INDEX LEAF ) { return BOOL ; } else if ( page Type == Page Types . INDEX NODE ) { return BOOL ; } throw new IO Exception ( with Error Context ( STRING + page Type ) ) ; }
public void add Js Lib Files ( File ... files ) { js Lib Files . add All ( Arrays . as List ( files ) ) ; }
public void test Write Offset ( ) { int len = NUM ; int data Len = NUM ; byte [ ] src Data = get W Data ( data Len ) ; byte [ ] data = new byte [ data Len ] ; int n Offset = NUM ; Byte Fifo Buffer instance = new Byte Fifo Buffer ( len ) ; int result = instance . write Offset ( src Data , data Len , n Offset ) ; int read Count = instance . read Offset ( data , NUM , data Len , n Offset ) ; assert Equals ( result , read Count ) ; assert Array Equals ( src Data , data ) ; byte [ ] half Filled = new byte [ data Len * NUM ] ; System . arraycopy ( src Data , NUM , half Filled , data Len , data Len ) ; byte [ ] half Filled Read = new byte [ data Len * NUM ] ; instance . read Offset ( half Filled Read , data Len , data Len , n Offset ) ; assert Array Equals ( half Filled , half Filled Read ) ; instance = new Byte Fifo Buffer ( len ) ; instance . write ( src Data , data Len ) ; instance . write ( src Data , data Len / NUM ) ; instance . read ( data , data Len ) ; instance . write Offset ( src Data , data Len , NUM ) ; instance = new Byte Fifo Buffer ( NUM ) ; instance . write Offset ( get W Data ( NUM ) , NUM , NUM ) ; }
private void init Properties If Necessary ( ) { if ( timer == null ) { Toolkit t = Toolkit . get Default Toolkit ( ) ; Integer prop ; prop = ( Integer ) t . get Desktop Property ( STRING ) ; timer = new Timer ( prop == null ? NUM : prop . int Value ( ) , this ) ; prop = ( Integer ) t . get Desktop Property ( STRING ) ; timer . set Initial Delay ( prop == null ? NUM : prop . int Value ( ) ) ; prop = ( Integer ) t . get Desktop Property ( STRING ) ; if ( prop != null ) { hysteresis = prop . int Value ( ) ; } } }
public E Object load Model ( String filename , String cwd ) { URI file URI = normalize URI ( URI . create URI ( filename ) ) ; URI cwd URI = normalize URI ( URI . create URI ( cwd ) ) ; return load Model ( file URI , cwd URI ) ; }
static boolean path Is Windows ( String path ) { if ( path != null && path . length ( ) > NUM ) { return ( Character . is Letter ( path . char At ( NUM ) ) && path . char At ( NUM ) == STRING ) || ( path . starts With ( STRING ) || path . starts With ( STRING ) ) ; } return BOOL ; }
public static boolean is Test Server ( ) { return System . get Property ( Test Server Only . TEST SERVER PROPERTY ) != null ; }
@ Suppress Warnings ( STRING ) private < T > String generate Test File ( String filename , List < T > elems , Avro Coder < T > coder , String codec ) throws IO Exception { File tmp File = tmp Folder . new File ( filename ) ; String path = tmp File . to String ( ) ; File Output Stream os = new File Output Stream ( tmp File ) ; Datum Writer < T > datum Writer = coder . create Datum Writer ( ) ; try ( Data File Writer < T > writer = new Data File Writer < > ( datum Writer ) ) { writer . set Codec ( Codec Factory . from String ( codec ) ) ; writer . create ( coder . get Schema ( ) , os ) ; for ( T elem : elems ) { writer . append ( elem ) ; } } return path ; }
public void notify Returned ( Notify Context notify Context , I Template Holder template ) { if ( notify Context == null ) return ; if ( filter Manager . is Filter [ Filter Operation Codes . AFTER NOTIFY TRIGGER ] ) { Object [ ] entries = new Object [ NUM ] ; entries [ NUM ] = notify Context . get Entry ( ) ; entries [ NUM ] = template ; try { filter Manager . invoke Filters ( Filter Operation Codes . AFTER NOTIFY TRIGGER , null , entries ) ; } catch ( Exception e ) { if ( logger . is Loggable ( Level . FINE ) ) logger . log ( Level . FINE , STRING , e ) ; } } decrease Counter ( notify Context ) ; }
public static String normalize Slashes ( String path ) { return path . replace All ( STRING , STRING ) ; }
protected Point 2 D correct ( Point 2 D anchor , Rectangle 2 D bounds ) { if ( anchor == null ) return anchor ; double x = anchor . get X ( ) , y = anchor . get Y ( ) ; double x1 = bounds . get Min X ( ) , y1 = bounds . get Min Y ( ) ; double x2 = bounds . get Max X ( ) , y2 = bounds . get Max Y ( ) ; x = ( x < x1 ? x1 : ( x > x2 ? x2 : x ) ) ; y = ( y < y1 ? y1 : ( y > y2 ? y2 : y ) ) ; m tmp . set Location ( x , y ) ; return m tmp ; }
private String save Parameters ( Set user Session , String user ID , boolean is SOAP Initiated , boolean is IDP Initiated , String protocol , String realm , String idp Entity ID , String sp Entity ID , String relay State , String single Logout Request XML , String single Logout Response XML , int current Status ) { String tmp Relay State = SAML 2 Utils . generate ID With Server ID ( ) ; relay State Map . put ( tmp Relay State , relay State ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + user ID + STRING + user Session + STRING + relay State + STRING + tmp Relay State + STRING + is SOAP Initiated + STRING + is IDP Initiated + STRING + protocol + STRING + realm + STRING + idp Entity ID + STRING + sp Entity ID + STRING + current Status + STRING + single Logout Request XML + STRING + single Logout Response XML ) ; } if ( user Session != null ) { user Session Map . put ( tmp Relay State , user Session ) ; } if ( user ID != null ) { user ID Map . put ( tmp Relay State , user ID ) ; } if ( is SOAP Initiated ) { is SOAP Initiated Map . put ( tmp Relay State , Boolean . TRUE ) ; } else { is SOAP Initiated Map . put ( tmp Relay State , Boolean . FALSE ) ; } if ( is IDP Initiated ) { is IDP Initiated Map . put ( tmp Relay State , Boolean . TRUE ) ; } else { is IDP Initiated Map . put ( tmp Relay State , Boolean . FALSE ) ; } if ( protocol != null ) { orig Protocol Map . put ( tmp Relay State , protocol ) ; int list Size = protocol List . size ( ) ; List list = new Array List ( list Size - NUM ) ; for ( int i = NUM ; i < list Size ; i ++ ) { String proto = ( String ) protocol List . get ( i ) ; if ( ! proto . equals ( protocol ) ) { list . add ( proto ) ; } } protocol List Map . put ( tmp Relay State , list ) ; } if ( realm != null ) { realm Map . put ( tmp Relay State , realm ) ; } if ( idp Entity ID != null ) { idp Entity ID Map . put ( tmp Relay State , idp Entity ID ) ; } if ( sp Entity ID != null ) { sp Entity ID Map . put ( tmp Relay State , sp Entity ID ) ; } if ( single Logout Request XML != null ) { slo Request XML Map . put ( tmp Relay State , single Logout Request XML ) ; } if ( single Logout Response XML != null ) { slo Response XML Map . put ( tmp Relay State , single Logout Response XML ) ; } current Status Map . put ( tmp Relay State , new Integer ( current Status ) ) ; return tmp Relay State ; }
private void next Packet ( ) throws IO Exception { int off = NUM ; int remaining = NUM ; do { int count = base Stream . read ( header , off , remaining ) ; if ( count <= NUM ) { throw new EOF Exception ( STRING + ( NUM - remaining ) + STRING + NUM ) ; } remaining -= count ; off += count ; } while ( remaining > NUM ) ; int compressed Length = ( header [ NUM ] & NUM ) + ( ( header [ NUM ] & NUM ) << NUM ) + ( ( header [ NUM ] & NUM ) << NUM ) ; last Packet Seq = header [ NUM ] & NUM ; int decompressed Length = ( header [ NUM ] & NUM ) + ( ( header [ NUM ] & NUM ) << NUM ) + ( ( header [ NUM ] & NUM ) << NUM ) ; if ( decompressed Length != NUM ) { do Decompress = BOOL ; remaining Bytes += decompressed Length ; byte [ ] compressed Buffer = new byte [ compressed Length ] ; byte [ ] decompressed Buffer = new byte [ decompressed Length ] ; off = NUM ; remaining = compressed Buffer . length ; do { int count = base Stream . read ( compressed Buffer , off , remaining ) ; if ( count <= NUM ) { throw new EOF Exception ( STRING + ( NUM - remaining ) + STRING + NUM ) ; } remaining -= count ; off += count ; } while ( remaining > NUM ) ; Inflater inflater = new Inflater ( ) ; inflater . set Input ( compressed Buffer ) ; try { int actual Uncompress Bytes = inflater . inflate ( decompressed Buffer ) ; if ( actual Uncompress Bytes != decompressed Length ) { throw new IO Exception ( STRING + actual Uncompress Bytes + STRING + decompressed Length ) ; } } catch ( Data Format Exception dfe ) { throw new IO Exception ( dfe ) ; } inflater . end ( ) ; decompressed Byte Stream = new Byte Array Input Stream ( decompressed Buffer ) ; } else { do Decompress = BOOL ; remaining Bytes += compressed Length ; decompressed Byte Stream = null ; } logger . trace ( STRING + last Packet Seq + STRING + remaining Bytes ) ; }
protected boolean load Field ( DDF Record record , String tag Name , int field Index ) { if ( fields . get ( tag Name ) == null ) { DDF Field ddf = record . find Field ( tag Name , field Index ) ; if ( ddf != null ) { fields . put ( tag Name , ddf ) ; ddf . to String ( ) ; return BOOL ; } } return BOOL ; }
public Http Request ( final Char Sequence url , final String method ) throws Http Request Exception { try { this . url = new URL ( url . to String ( ) ) ; } catch ( Malformed URL Exception e ) { throw new Http Request Exception ( e ) ; } this . request Method = method ; }
private boolean is Error ( I Problem problem , Type type ) { return BOOL ; }
private static void add Process Parameters ( int AD P Instance ID , Map < String , Object > params , String trx Name ) { final String sql = STRING + STRING + X AD P Instance Para . COLUMNNAME Parameter Name + STRING + X AD P Instance Para . COLUMNNAME P String + STRING + X AD P Instance Para . COLUMNNAME P String To + STRING + X AD P Instance Para . COLUMNNAME P Number + STRING + X AD P Instance Para . COLUMNNAME P Number To + STRING + X AD P Instance Para . COLUMNNAME P Date + STRING + X AD P Instance Para . COLUMNNAME P Date To + STRING + X AD P Instance Para . COLUMNNAME Info + STRING + X AD P Instance Para . COLUMNNAME Info To + STRING + X AD P Instance Para . Table Name + STRING + X AD P Instance Para . COLUMNNAME AD P Instance ID + STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , Result Set . TYPE FORWARD ONLY , Result Set . CONCUR READ ONLY , trx Name ) ; pstmt . set Int ( NUM , AD P Instance ID ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { String name = rs . get String ( NUM ) ; String p Str = rs . get String ( NUM ) ; String p Str To = rs . get String ( NUM ) ; Big Decimal p Num = rs . get Big Decimal ( NUM ) ; Big Decimal p Num To = rs . get Big Decimal ( NUM ) ; Timestamp p Date = rs . get Timestamp ( NUM ) ; Timestamp p Date To = rs . get Timestamp ( NUM ) ; if ( p Str != null ) { if ( p Str To != null ) { params . put ( name + STRING , p Str ) ; params . put ( name + STRING , p Str To ) ; } else { params . put ( name , p Str ) ; } } else if ( p Date != null ) { if ( p Date To != null ) { params . put ( name + STRING , p Date ) ; params . put ( name + STRING , p Date To ) ; } else { params . put ( name , p Date ) ; } } else if ( p Num != null ) { if ( p Num To != null ) { params . put ( name + STRING , p Num ) ; params . put ( name + STRING , p Num To ) ; } else { params . put ( name , p Num ) ; } } String info = rs . get String ( NUM ) ; String info To = rs . get String ( NUM ) ; params . put ( name + STRING , ( info != null ? info : STRING ) ) ; params . put ( name + STRING , ( info To != null ? info To : STRING ) ) ; } } catch ( SQL Exception e ) { throw new DB Exception ( e , sql ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } }
@ Suppress Warnings ( { STRING , STRING } ) public Record Set Page ( Input input ) { Deserializer deserizalizer = new Deserializer ( ) ; Map map Result = deserizalizer . deserialize ( input , Map . class ) ; cursor = ( Integer ) map Result . get ( STRING ) ; data = ( List < List < Object > > ) map Result . get ( STRING ) ; }
public Optional < String > endpoint ( ) { return Optional . of Nullable ( endpoint Arg ) ; }
public void test Collisions ( ) throws Exception { Map < Integer , Set < UUID > > map = new Hash Map < > ( ) ; Collection < UUID > nodes = new Linked Hash Set < > ( ) ; while ( nodes . size ( ) < NUM ) { UUID uuid = UUID . random UUID ( ) ; int hash Code = uuid . hash Code ( ) ; Set < UUID > set = map . get ( hash Code ) ; if ( set == null ) map . put ( hash Code , set = new Linked Hash Set < > ( ) ) ; set . add ( uuid ) ; if ( set . size ( ) > NUM ) nodes . add All ( set ) ; } map . clear ( ) ; Grid Client Consistent Hash < UUID > hash = new Grid Client Consistent Hash < > ( ) ; hash . add Nodes ( nodes , REPLICAS ) ; boolean fail = BOOL ; for ( UUID exp : nodes ) { UUID act = hash . node ( NUM , Arrays . as List ( exp ) ) ; if ( exp . equals ( act ) ) info ( STRING + exp + STRING + act + STRING ) ; else { info ( STRING + exp + STRING + act + STRING ) ; fail = BOOL ; } } if ( fail ) fail ( STRING + nodes ) ; }
void send Message To Handler With Controller Reset ( List < OF Message > messages ) throws Exception { send Message To Handler No Controller Reset ( messages ) ; }
public boolean is Redeploy Mode ( ) { return scenario . equals ( Property Constants . REDEPLOY MODE ) ? BOOL : BOOL ; }
public static RSA Private Key load From Key Store ( URL keystore Url , String password ) throws IO Exception , No Such Algorithm Exception , Certificate Exception , Key Store Exception , Unrecoverable Key Exception { logger . debug ( STRING , keystore Url ) ; URL Connection connection = keystore Url . open Connection ( ) ; Input Stream is = connection . get Input Stream ( ) ; try { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING , Arrays . to String ( Security . get Providers ( ) ) ) ; Key Store key Store ; try { try { key Store = Key Store . get Instance ( STRING , STRING ) ; } catch ( No Such Provider Exception e ) { key Store = Key Store . get Instance ( STRING , Crypto Util . get Security Provider Name ( Key Store . class ) ) ; } } catch ( No Such Provider Exception e ) { key Store = Key Store . get Instance ( STRING ) ; } logger . debug ( STRING , key Store . get Provider ( ) ) ; key Store . load ( is , password == null ? null : password . to Char Array ( ) ) ; Enumeration < String > aliases = key Store . aliases ( ) ; Key key = null ; while ( aliases . has More Elements ( ) ) { String a = ( String ) aliases . next Element ( ) ; key = key Store . get Key ( a , password == null ? null : password . to Char Array ( ) ) ; } return ( RSA Private Key ) key ; } finally { is . close ( ) ; } }
@ Override public double conf Small M ( double total Example Weight , double delta ) { double term = Math . log ( NUM / delta ) / ( NUM * total Example Weight ) ; return Math . sqrt ( term ) + Math . pow ( term , NUM ) + Math . pow ( term , NUM ) ; }
public static < T > boolean contains ( Iterator < T > iterator , T element ) { if ( iterator != null ) { while ( iterator . has Next ( ) ) { T candidate = iterator . next ( ) ; if ( Object Utils . null Safe Equals ( candidate , element ) ) return BOOL ; } } return BOOL ; }
public void test Constructor 6 ( ) { Integer [ ] ints = new Integer [ SIZE ] ; for ( int i = NUM ; i < SIZE ; ++ i ) ints [ i ] = new Integer ( i ) ; Linked Blocking Queue q = new Linked Blocking Queue ( Arrays . as List ( ints ) ) ; for ( int i = NUM ; i < SIZE ; ++ i ) assert Equals ( ints [ i ] , q . poll ( ) ) ; }
@ Override public void draw Domain Gridline ( Graphics 2 D g2 , Category Plot plot , Rectangle 2 D data Area , double value ) { Line 2 D line = null ; Plot Orientation orientation = plot . get Orientation ( ) ; if ( orientation == Plot Orientation . HORIZONTAL ) { line = new Line 2 D . Double ( data Area . get Min X ( ) , value , data Area . get Max X ( ) , value ) ; } else if ( orientation == Plot Orientation . VERTICAL ) { line = new Line 2 D . Double ( value , data Area . get Min Y ( ) , value , data Area . get Max Y ( ) ) ; } Paint paint = plot . get Domain Gridline Paint ( ) ; if ( paint == null ) { paint = Category Plot . DEFAULT GRIDLINE PAINT ; } g2 . set Paint ( paint ) ; Stroke stroke = plot . get Domain Gridline Stroke ( ) ; if ( stroke == null ) { stroke = Category Plot . DEFAULT GRIDLINE STROKE ; } g2 . set Stroke ( stroke ) ; g2 . draw ( line ) ; }
public void add Pre Built Classifier ( Classifier c ) { m pre Built Classifiers . add ( c ) ; }
@ Override public Insn List generate ( ) { return merge ( generated Instructions . to Array ( ) ) ; }
public static void put Java Variables Into Engine ( final Script Engine engine , final Map < String , Object > variables ) { final Bindings bindings = new Simple Bindings ( ) ; for ( String key : variables . key Set ( ) ) { bindings . put ( key , variables . get ( key ) ) ; } engine . set Bindings ( bindings , Script Context . ENGINE SCOPE ) ; }
private Point 2 D calculate Label Point ( Line 2 D line , Rectangle Anchor anchor , double delta X , double delta Y ) { double x , y ; boolean left = ( anchor == Rectangle Anchor . BOTTOM LEFT || anchor == Rectangle Anchor . LEFT || anchor == Rectangle Anchor . TOP LEFT ) ; boolean right = ( anchor == Rectangle Anchor . BOTTOM RIGHT || anchor == Rectangle Anchor . RIGHT || anchor == Rectangle Anchor . TOP RIGHT ) ; boolean top = ( anchor == Rectangle Anchor . TOP LEFT || anchor == Rectangle Anchor . TOP || anchor == Rectangle Anchor . TOP RIGHT ) ; boolean bottom = ( anchor == Rectangle Anchor . BOTTOM LEFT || anchor == Rectangle Anchor . BOTTOM || anchor == Rectangle Anchor . BOTTOM RIGHT ) ; Rectangle rect = line . get Bounds ( ) ; if ( line . get X 1 ( ) == line . get X 2 ( ) ) { x = line . get X 1 ( ) ; y = ( line . get Y 1 ( ) + line . get Y 2 ( ) ) / NUM ; if ( left ) { x = x - delta X ; } if ( right ) { x = x + delta X ; } if ( top ) { y = Math . min ( line . get Y 1 ( ) , line . get Y 2 ( ) ) + delta Y ; } if ( bottom ) { y = Math . max ( line . get Y 1 ( ) , line . get Y 2 ( ) ) - delta Y ; } } else { x = ( line . get X 1 ( ) + line . get X 2 ( ) ) / NUM ; y = line . get Y 1 ( ) ; if ( left ) { x = Math . min ( line . get X 1 ( ) , line . get X 2 ( ) ) + delta X ; } if ( right ) { x = Math . max ( line . get X 1 ( ) , line . get X 2 ( ) ) - delta X ; } if ( top ) { y = y - delta Y ; } if ( bottom ) { y = y + delta Y ; } } return new Point 2 D . Double ( x , y ) ; }
public void fling ( int start X , int start Y , int velocity X , int velocity Y , int min X , int max X , int min Y , int max Y ) { if ( m Flywheel && ! m Finished ) { float old Vel = get Curr Velocity ( ) ; float dx = ( float ) ( m Final X - m Start X ) ; float dy = ( float ) ( m Final Y - m Start Y ) ; float hyp = ( float ) Math . hypot ( dx , dy ) ; float ndx = dx / hyp ; float ndy = dy / hyp ; float old Velocity X = ndx * old Vel ; float old Velocity Y = ndy * old Vel ; if ( Math . signum ( velocity X ) == Math . signum ( old Velocity X ) && Math . signum ( velocity Y ) == Math . signum ( old Velocity Y ) ) { velocity X += old Velocity X ; velocity Y += old Velocity Y ; } } m Mode = FLING MODE ; m Finished = BOOL ; float velocity = ( float ) Math . hypot ( velocity X , velocity Y ) ; m Velocity = velocity ; m Duration = get Spline Fling Duration ( velocity ) ; m Start Time = Animation Utils . current Animation Time Millis ( ) ; m Start X = start X ; m Start Y = start Y ; float coeff X = velocity == NUM ? NUM : velocity X / velocity ; float coeff Y = velocity == NUM ? NUM : velocity Y / velocity ; double total Distance = get Spline Fling Distance ( velocity ) ; m Distance = ( int ) ( total Distance * Math . signum ( velocity ) ) ; m Min X = min X ; m Max X = max X ; m Min Y = min Y ; m Max Y = max Y ; m Final X = start X + ( int ) Math . round ( total Distance * coeff X ) ; m Final X = Math . min ( m Final X , m Max X ) ; m Final X = Math . max ( m Final X , m Min X ) ; m Final Y = start Y + ( int ) Math . round ( total Distance * coeff Y ) ; m Final Y = Math . min ( m Final Y , m Max Y ) ; m Final Y = Math . max ( m Final Y , m Min Y ) ; }
public void delete With Missing ( Attribute att ) { delete With Missing ( att . index ( ) ) ; }
protected void sprint ( String a ) { if ( a == null ) { string Representation += get Indentation ( ) ; string Representation += STRING ; return ; } if ( a . compare To ( STRING ) == NUM || a . compare To ( STRING ) == NUM ) { indentation -- ; } string Representation += get Indentation ( ) ; string Representation += a ; string Representation += STRING ; if ( a . compare To ( STRING ) == NUM || a . compare To ( STRING ) == NUM ) { indentation ++ ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( sem Ims == null ) { throw new Null Pointer Exception ( ) ; } }
private static Pair < Long , Long > load ( Byte Array a , Input Stream stream , long memory Offset , long count , Common Index positions , CRC 32 checksum , Byte Array checksums , Preread Hash Function hf , boolean checksums Loaded , long current Seq ) throws IO Exception { long tmp Current Seq = current Seq ; final byte [ ] buffer = new byte [ NUM * NUM ] ; long total Read = NUM ; int bytes Read ; long pos = memory Offset ; while ( total Read < count && ( bytes Read = stream . read ( buffer , NUM , ( int ) Math . min ( count - total Read , buffer . length ) ) ) != - NUM ) { a . set ( pos , buffer , bytes Read ) ; pos += bytes Read ; int j = NUM ; while ( j < bytes Read ) { if ( positions . get ( tmp Current Seq + NUM ) == positions . get ( tmp Current Seq ) ) { hf . irvine Hash ( NUM ) ; tmp Current Seq ++ ; continue ; } final int len = ( int ) ( positions . get ( tmp Current Seq + NUM ) - ( memory Offset + total Read + j ) ) ; if ( j + len <= bytes Read ) { checksum . update ( buffer , j , len ) ; hf . irvine Hash ( buffer , j , len ) ; hf . irvine Hash ( positions . get ( tmp Current Seq + NUM ) - positions . get ( tmp Current Seq ) ) ; if ( checksums Loaded ) { if ( ( byte ) checksum . get Value ( ) != checksums . get ( tmp Current Seq ) ) { throw new Corrupt Sdf Exception ( STRING + tmp Current Seq + STRING ) ; } } else { checksums . set ( tmp Current Seq , ( byte ) checksum . get Value ( ) ) ; } tmp Current Seq ++ ; checksum . reset ( ) ; } else { hf . irvine Hash ( buffer , j , bytes Read - j ) ; checksum . update ( buffer , j , bytes Read - j ) ; } j += len ; } total Read += bytes Read ; } return new Pair < > ( total Read , tmp Current Seq ) ; }
public static java . sql . Date to Sql Date ( String month Str , String day Str , String year Str ) { java . util . Date new Date = to Date ( month Str , day Str , year Str , STRING , STRING , STRING ) ; if ( new Date != null ) { return new java . sql . Date ( new Date . get Time ( ) ) ; } else { return null ; } }
public void remove Swipe Listener ( Swipe Listener listener ) { if ( m Listeners == null ) { return ; } m Listeners . remove ( listener ) ; }
protected void save PNG Image ( String filename , Buffered Image image ) throws IO Exception { File file = new File ( filename ) ; Image IO . write ( image , STRING , file ) ; }
public void unset Permission ( String name ) { permissions . remove ( name . to Lower Case ( java . util . Locale . ENGLISH ) ) ; permissible . recalculate Permissions ( ) ; }
public void before Insert ( int index , byte element ) { if ( index > size || index < NUM ) throw new Index Out Of Bounds Exception ( STRING + index + STRING + size ) ; ensure Capacity ( size + NUM ) ; System . arraycopy ( elements , index , elements , index + NUM , size - index ) ; elements [ index ] = element ; size ++ ; }
public OM Graphic List read Cached Graphics ( URL url ) throws java . io . IO Exception { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING ) ; } OM Graphic List omgraphics = new OM Graphic List ( ) ; if ( url != null ) { omgraphics . read Graphics ( url ) ; } return omgraphics ; }
int size ( ) { return nox Items . size ( ) ; }
public < V > Future < V > invoke ( String method , String path , Map < String , ? > arguments , Result Handler < V > result Handler ) { if ( method == null ) { throw new Illegal Argument Exception ( ) ; } if ( path == null ) { throw new Illegal Argument Exception ( ) ; } if ( arguments == null ) { throw new Illegal Argument Exception ( ) ; } return executor Service . submit ( new Invocation Callback < > ( method , path , arguments , result Handler ) ) ; }
@ Override public String replace Path ( String input URI ) { if ( input URI . contains ( Temporary Directory Manager . DIRECTORY TEMPLATE ) ) { return input URI . replace ( Temporary Directory Manager . DIRECTORY TEMPLATE , TEMPLATE DIRECTORY NAME ) ; } return input URI ; }
@ Override public void create ( ) { assert Writable ( ) ; final String name = get Namespace ( ) + STRING + NAME SEARCH ; final I Index Manager index Manager = get Index Manager ( ) ; final Properties p = get Properties ( ) ; final Index Metadata index Metadata = new Index Metadata ( index Manager , p , name , UUID . random UUID ( ) , Index Type Enum . B Tree ) ; final I Key Builder Factory key Builder Factory ; { final Properties tmp = new Properties ( p ) ; tmp . set Property ( Key Builder . Options . STRENGTH , p . get Property ( Options . INDEXER COLLATOR STRENGTH , Options . DEFAULT INDEXER COLLATOR STRENGTH ) ) ; key Builder Factory = new Default Key Builder Factory ( tmp ) ; } final boolean fields Enabled = Boolean . parse Boolean ( p . get Property ( Options . FIELDS ENABLED , Options . DEFAULT FIELDS ENABLED ) ) ; if ( log . is Info Enabled ( ) ) log . info ( Options . FIELDS ENABLED + STRING + fields Enabled ) ; index Metadata . set Tuple Serializer ( new Full Text Index Tuple Serializer < V > ( key Builder Factory , Default Tuple Serializer . get Default Leaf Keys Coder ( ) , Empty Raba Value Coder . INSTANCE , fields Enabled ) ) ; index Manager . register Index ( index Metadata ) ; if ( log . is Info Enabled ( ) ) log . info ( STRING + name ) ; }
public static PGP Public Key merge Signatures ( PGP Public Key target Key , PGP Public Key source Key ) throws PGP Exception { if ( ! Objects . deep Equals ( target Key . get Fingerprint ( ) , source Key . get Fingerprint ( ) ) ) { throw new Illegal Argument Exception ( STRING ) ; } return copy Signatures ( target Key , source Key ) ; }
private static boolean has Specialized Handler Intents ( Context context , Intent intent ) { try { Package Manager pm = context . get Package Manager ( ) ; List < Resolve Info > handlers = pm . query Intent Activities ( intent , Package Manager . GET RESOLVED FILTER ) ; if ( handlers == null || handlers . size ( ) == NUM ) { return BOOL ; } for ( Resolve Info resolve Info : handlers ) { Intent Filter filter = resolve Info . filter ; if ( filter == null ) continue ; if ( filter . count Data Authorities ( ) == NUM || filter . count Data Paths ( ) == NUM ) continue ; if ( resolve Info . activity Info == null ) continue ; return BOOL ; } } catch ( Runtime Exception e ) { Log . e ( TAG , STRING ) ; } return BOOL ; }
public void draw Background ( Graphics g ) { g . fill Rect ( NUM , NUM , get Width ( ) , get Height ( ) ) ; }
public static double info ( int counts [ ] ) { int total = NUM ; double x = NUM ; for ( int j = NUM ; j < counts . length ; j ++ ) { x -= xlogx ( counts [ j ] ) ; total += counts [ j ] ; } return x + xlogx ( total ) ; }
public Compute Job Failover Exception ( Throwable cause ) { this ( cause . get Message ( ) , cause ) ; }
public boolean has Newer Version ( ) { return latest Stable . compare To ( current Version ) > NUM ; }
@ Override public String format ( Date Time Formatter formatter ) { Objects . require Non Null ( formatter , STRING ) ; return formatter . format ( this ) ; }
@ Override public void read NBT ( NBT Tag Compound compound ) { super . read NBT ( compound ) ; if ( compound . has Key ( STRING ) ) { this . exhaustion Timer = compound . get Integer ( STRING ) ; } if ( ! compound . has Key ( STRING ) ) { set Food Level ( get Food Level ( ) * NUM ) ; set Saturation ( NUM ) ; } if ( get Food Level ( ) > NUM ) set Food Level ( NUM ) ; if ( get Saturation Level ( ) > NUM ) set Saturation ( NUM ) ; }
private static boolean verify XML ( String file Name ) { Schema Factory sf = Schema Factory . new Instance ( W3 C XML SCHEMA ) ; Source xsd File = new Stream Source ( new File ( XSD FILE PATH ) ) ; Source xml File = new Stream Source ( new File ( file Name ) ) ; boolean valid XML = BOOL ; try { Schema schema = sf . new Schema ( xsd File ) ; Validator validator = schema . new Validator ( ) ; try { validator . validate ( xml File ) ; valid XML = BOOL ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } if ( ! valid XML ) { new IO Exception ( STRING ) ; } } catch ( SAX Exception e ) { e . print Stack Trace ( ) ; } return valid XML ; }
private void need New Buffer ( int newcount ) { if ( current Buffer Index < buffers . size ( ) - NUM ) { filled Buffer Sum += current Buffer . length ; current Buffer Index ++ ; current Buffer = buffers . get ( current Buffer Index ) ; } else { int new Buffer Size ; if ( current Buffer == null ) { new Buffer Size = newcount ; filled Buffer Sum = NUM ; } else { new Buffer Size = Math . max ( current Buffer . length << NUM , newcount - filled Buffer Sum ) ; filled Buffer Sum += current Buffer . length ; } current Buffer Index ++ ; current Buffer = new byte [ new Buffer Size ] ; buffers . add ( current Buffer ) ; } }
private static void dual Pivot Quicksort ( byte [ ] a , int left , int right ) { int sixth = ( right - left + NUM ) / NUM ; int e1 = left + sixth ; int e5 = right - sixth ; int e3 = ( left + right ) > > > NUM ; int e4 = e3 + sixth ; int e2 = e3 - sixth ; byte ae 1 = a [ e1 ] , ae 2 = a [ e2 ] , ae 3 = a [ e3 ] , ae 4 = a [ e4 ] , ae 5 = a [ e5 ] ; if ( ae 1 > ae 2 ) { byte t = ae 1 ; ae 1 = ae 2 ; ae 2 = t ; } if ( ae 4 > ae 5 ) { byte t = ae 4 ; ae 4 = ae 5 ; ae 5 = t ; } if ( ae 1 > ae 3 ) { byte t = ae 1 ; ae 1 = ae 3 ; ae 3 = t ; } if ( ae 2 > ae 3 ) { byte t = ae 2 ; ae 2 = ae 3 ; ae 3 = t ; } if ( ae 1 > ae 4 ) { byte t = ae 1 ; ae 1 = ae 4 ; ae 4 = t ; } if ( ae 3 > ae 4 ) { byte t = ae 3 ; ae 3 = ae 4 ; ae 4 = t ; } if ( ae 2 > ae 5 ) { byte t = ae 2 ; ae 2 = ae 5 ; ae 5 = t ; } if ( ae 2 > ae 3 ) { byte t = ae 2 ; ae 2 = ae 3 ; ae 3 = t ; } if ( ae 4 > ae 5 ) { byte t = ae 4 ; ae 4 = ae 5 ; ae 5 = t ; } a [ e1 ] = ae 1 ; a [ e3 ] = ae 3 ; a [ e5 ] = ae 5 ; byte pivot 1 = ae 2 ; a [ e2 ] = a [ left ] ; byte pivot 2 = ae 4 ; a [ e4 ] = a [ right ] ; int less = left + NUM ; int great = right - NUM ; boolean pivots Differ = ( pivot 1 != pivot 2 ) ; if ( pivots Differ ) { outer : for ( int k = less ; k <= great ; k ++ ) { byte ak = a [ k ] ; if ( ak < pivot 1 ) { if ( k != less ) { a [ k ] = a [ less ] ; a [ less ] = ak ; } less ++ ; } else if ( ak > pivot 2 ) { while ( a [ great ] > pivot 2 ) { if ( great -- == k ) { break outer ; } } if ( a [ great ] < pivot 1 ) { a [ k ] = a [ less ] ; a [ less ++ ] = a [ great ] ; a [ great -- ] = ak ; } else { a [ k ] = a [ great ] ; a [ great -- ] = ak ; } } } } else { for ( int k = less ; k <= great ; k ++ ) { byte ak = a [ k ] ; if ( ak == pivot 1 ) { continue ; } if ( ak < pivot 1 ) { if ( k != less ) { a [ k ] = a [ less ] ; a [ less ] = ak ; } less ++ ; } else { while ( a [ great ] > pivot 1 ) { great -- ; } if ( a [ great ] < pivot 1 ) { a [ k ] = a [ less ] ; a [ less ++ ] = a [ great ] ; a [ great -- ] = ak ; } else { a [ k ] = pivot 1 ; a [ great -- ] = ak ; } } } } a [ left ] = a [ less - NUM ] ; a [ less - NUM ] = pivot 1 ; a [ right ] = a [ great + NUM ] ; a [ great + NUM ] = pivot 2 ; do Sort ( a , left , less - NUM ) ; do Sort ( a , great + NUM , right ) ; if ( ! pivots Differ ) { return ; } if ( less < e1 && great > e5 ) { while ( a [ less ] == pivot 1 ) { less ++ ; } while ( a [ great ] == pivot 2 ) { great -- ; } outer : for ( int k = less ; k <= great ; k ++ ) { byte ak = a [ k ] ; if ( ak == pivot 2 ) { while ( a [ great ] == pivot 2 ) { if ( great -- == k ) { break outer ; } } if ( a [ great ] == pivot 1 ) { a [ k ] = a [ less ] ; a [ less ++ ] = pivot 1 ; } else { a [ k ] = a [ great ] ; } a [ great -- ] = pivot 2 ; } else if ( ak == pivot 1 ) { a [ k ] = a [ less ] ; a [ less ++ ] = pivot 1 ; } } } do Sort ( a , less , great ) ; }
@ Nullable public N node ( @ Nullable Object key , @ Nullable Collection < N > inc ) { return node ( key , inc , null ) ; }
public void increment ( ) { counter . get And Increment ( ) ; }
public Default Deployment Cache ( ) { this . cache = Collections . synchronized Map ( new Hash Map < String , T > ( ) ) ; }
private int find Insertion Point ( Sorted List Entry entry ) { int insertion Point = sorted Model . size ( ) ; if ( sort Order != Sort Order . UNORDERED ) { insertion Point = Collections . binary Search ( ( List ) sorted Model , entry ) ; if ( insertion Point < NUM ) { insertion Point = - ( insertion Point + NUM ) ; } } return insertion Point ; }
private boolean have Shown Message Before ( Update Message msg ) { if ( ! msg . is Shown Once ( ) ) return BOOL ; load Seen Messages ( ) ; if ( seen Messages == null || seen Messages . size ( ) == NUM || ! seen Messages . contains ( msg ) ) { if ( seen Messages == null ) seen Messages = new Hash Set < > ( ) ; seen Messages . add ( msg ) ; save Seen Messages ( ) ; return BOOL ; } return BOOL ; }
public void data Source Added ( int index ) { update ( ) ; update Coordinate Projection Combo Boxes ( ) ; }
public boolean field Is Static ( ) { return Modifier . is Static ( field . get Modifiers ( ) ) ; }
void new Equation ( DF Lattice Cell lhs , DF Operator operator , DF Lattice Cell op 1 , DF Lattice Cell op 2 , DF Lattice Cell op 3 ) { DF Equation eq = new DF Equation ( lhs , operator , op 1 , op 2 , op 3 ) ; equations . add Graph Node ( eq ) ; equations . add Graph Node ( lhs ) ; equations . add Graph Node ( op 1 ) ; equations . add Graph Node ( op 2 ) ; equations . add Graph Node ( op 3 ) ; new Equations . add ( eq ) ; op 1 . add Use ( eq ) ; op 2 . add Use ( eq ) ; op 3 . add Use ( eq ) ; lhs . add Def ( eq ) ; if ( EAGER && eq . evaluate ( ) ) changed Cell ( lhs ) ; }
@ Override public void stop ( ) { if ( stopping . compare And Set ( BOOL , BOOL ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + cache Name + STRING ) ; wake Up ( ) ; boolean graceful = BOOL ; for ( Grid Worker worker : flush Threads ) graceful &= U . join ( worker , log ) ; if ( ! graceful ) log . warning ( STRING ) ; } }
private Set < Storage Port > and Storage Port Sets ( Set < Storage Port > a , Set < Storage Port > b ) { Set < Storage Port > result = new Hash Set < Storage Port > ( ) ; for ( Storage Port port : a ) { if ( b . contains ( port ) ) { result . add ( port ) ; } } return result ; }
public static void add Attribute To Schema ( String service Name , String sub Schema Name , String schema Type , Node attribute Schema Node , SSO Token admin Token ) throws Upgrade Exception { Service Schema ss = get Service Schema ( service Name , sub Schema Name , schema Type , admin Token ) ; add Attribute To Schema ( ss , attribute Schema Node ) ; }
public int next ( int current ) { for ( int i = current + NUM ; i < ( arguments != null ? arguments . size ( ) : NUM ) ; i ++ ) { if ( get Argument ( i ) instanceof Math Container ) { return i ; } } throw new Array Index Out Of Bounds Exception ( STRING ) ; }
@ Override public boolean supports Authentication ( ) { if ( DEBUG . message Enabled ( ) ) { DEBUG . message ( STRING ) ; } return BOOL ; }
protected void reorder App Deployments After Configuration Version ( Element domain ) { List < Element > app Deployments = xml Tool . select Elements Matching X Path ( STRING , domain ) ; for ( Element app Deployment : app Deployments ) { domain . remove Child ( app Deployment ) ; } Element configuration Version = xml Tool . select Element Matching X Path ( STRING , domain ) ; Node before = null ; Node List children = domain . get Child Nodes ( ) ; for ( int i = NUM ; i < children . get Length ( ) ; i ++ ) { if ( configuration Version . equals ( children . item ( i ) ) && i < children . get Length ( ) - NUM ) { before = children . item ( i + NUM ) ; } } if ( before != null ) { for ( Element app Deployment : app Deployments ) { domain . insert Before ( app Deployment , before ) ; } } else { for ( Element app Deployment : app Deployments ) { domain . append Child ( app Deployment ) ; } } }
public URI ( String scheme , String scheme Specific Part , String fragment ) throws URI Syntax Exception { String Builder uri = new String Builder ( ) ; if ( scheme != null ) { uri . append ( scheme ) ; uri . append ( STRING ) ; } if ( scheme Specific Part != null ) { ALL LEGAL ENCODER . append Encoded ( uri , scheme Specific Part ) ; } if ( fragment != null ) { uri . append ( STRING ) ; ALL LEGAL ENCODER . append Encoded ( uri , fragment ) ; } parse URI ( uri . to String ( ) , BOOL ) ; }
static Facet Method select Facet Method ( Schema Field field , Facet Method method , Integer mincount ) { Field Type type = field . get Type ( ) ; if ( method == null ) { if ( type instanceof Bool Field && ( field . indexed ( ) == BOOL || field . has Doc Values ( ) == BOOL ) ) { method = Facet Method . ENUM ; } else if ( type . get Numeric Type ( ) != null && ! field . multi Valued ( ) ) { method = Facet Method . FCS ; } else { method = Facet Method . FC ; } } if ( method == Facet Method . FC && type . get Numeric Type ( ) != null && ! field . multi Valued ( ) ) { method = Facet Method . FCS ; } if ( method == Facet Method . UIF && ! field . has Doc Values ( ) && mincount == NUM ) { method = field . multi Valued ( ) ? Facet Method . FC : Facet Method . FCS ; } if ( method == Facet Method . ENUM && Trie Field . get Main Value Prefix ( type ) != null ) { method = field . multi Valued ( ) ? Facet Method . FC : Facet Method . FCS ; } final boolean multi Token = field . multi Valued ( ) || type . multi Valued Field Cache ( ) ; if ( method == Facet Method . FCS && multi Token ) { method = Facet Method . FC ; } return method ; }
public void on Tabs All Closing ( long time , boolean incognito ) { }
public List < Hash Map < String , Object > > clear Overall Chat ( ) { try { List < Hash Map < String , Object > > my Chat List = my Chats . get ( overall Chat Room Name ) ; my Chat List = new Linked List < Hash Map < String , Object > > ( ) ; my Chats . put ( overall Chat Room Name , my Chat List ) ; Map < Integer , String > new Message = new Hash Map < Integer , String > ( ) ; new Message . put ( NUM , STRING ) ; scope Application Adapter . send Message To Members ( new Message ) ; return my Chat List ; } catch ( Exception err ) { log . error ( STRING , err ) ; return null ; } }
public Db Schema Changer begin Change ( ) throws Exception { backup File = File . create Temp File ( STRING , STRING ) ; log . info ( STRING , class File . get Absolute Path ( ) , backup File . get Absolute Path ( ) ) ; copy File ( class File , backup File ) ; cc . defrost ( ) ; return this ; }
void animate Challenge To ( int y , int velocity ) { if ( m Challenge View == null ) { return ; } cancel Transitions In Progress ( ) ; m Challenge Interactive Internal = BOOL ; m Challenge View . set Layer Type ( LAYER TYPE HARDWARE , null ) ; final int sy = m Challenge View . get Bottom ( ) ; final int dy = y - sy ; if ( dy == NUM ) { complete Challenge Scroll ( ) ; return ; } set Scroll State ( SCROLL STATE SETTLING ) ; final int child Height = m Challenge View . get Height ( ) ; final int half Height = child Height / NUM ; final float distance Ratio = Math . min ( NUM , NUM * Math . abs ( dy ) / child Height ) ; final float distance = half Height + half Height * distance Influence For Snap Duration ( distance Ratio ) ; int duration = NUM ; velocity = Math . abs ( velocity ) ; if ( velocity > NUM ) { duration = NUM * Math . round ( NUM * Math . abs ( distance / velocity ) ) ; } else { final float child Delta = ( float ) Math . abs ( dy ) / child Height ; duration = ( int ) ( ( child Delta + NUM ) * NUM ) ; } duration = Math . min ( duration , MAX SETTLE DURATION ) ; m Scroller . start Scroll ( NUM , sy , NUM , dy , duration ) ; post Invalidate On Animation ( ) ; }
public Jca X 509 v 3 Certificate Builder ( X500 Principal issuer , Big Integer serial , Date not Before , Date not After , X500 Principal subject , Public Key public Key ) { super ( X500 Name . get Instance ( issuer . get Encoded ( ) ) , serial , not Before , not After , X500 Name . get Instance ( subject . get Encoded ( ) ) , Subject Public Key Info . get Instance ( public Key . get Encoded ( ) ) ) ; }
private void write GUID Value ( Byte Buffer buffer , Object value ) throws IO Exception { Matcher m = GUID PATTERN . matcher ( to Char Sequence ( value ) ) ; if ( ! m . matches ( ) ) { throw new IO Exception ( with Error Context ( STRING + value ) ) ; } Byte Buffer orig Buffer = null ; byte [ ] tmp Buf = null ; if ( buffer . order ( ) != Byte Order . BIG ENDIAN ) { orig Buffer = buffer ; tmp Buf = new byte [ NUM ] ; buffer = Byte Buffer . wrap ( tmp Buf ) ; } Byte Util . write Hex String ( buffer , m . group ( NUM ) ) ; Byte Util . write Hex String ( buffer , m . group ( NUM ) ) ; Byte Util . write Hex String ( buffer , m . group ( NUM ) ) ; Byte Util . write Hex String ( buffer , m . group ( NUM ) ) ; Byte Util . write Hex String ( buffer , m . group ( NUM ) ) ; if ( tmp Buf != null ) { Byte Util . swap 4 Bytes ( tmp Buf , NUM ) ; Byte Util . swap 2 Bytes ( tmp Buf , NUM ) ; Byte Util . swap 2 Bytes ( tmp Buf , NUM ) ; orig Buffer . put ( tmp Buf ) ; } }
public Neuron Group ( final Network net , final List < Neuron > neurons ) { super ( net ) ; neuron List = new Array List < Neuron > ( neurons . size ( ) ) ; for ( Neuron neuron : neurons ) { add Neuron ( neuron ) ; } neuron List = new Copy On Write Array List < Neuron > ( neuron List ) ; update Rule = get Neuron Type ( ) ; reset Subsampling Indices ( ) ; }
@ Log Message Doc ( level = STRING , message = STRING , explanation = STRING , recommendation = Log Message Doc . REPORT CONTROLLER BUG ) public List < LD Update > apply Updates ( ) { List < LD Update > applied Updates = new Array List < LD Update > ( ) ; LD Update update = null ; while ( ld Updates . peek ( ) != null ) { try { update = ld Updates . take ( ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; } if ( log . is Trace Enabled ( ) ) { log . trace ( STRING , update ) ; } switch ( update . get Operation ( ) ) { case LINK UPDATED : add Or Update Link ( update . get Src ( ) , update . get Src Port ( ) , update . get Dst ( ) , update . get Dst Port ( ) , update . get Type ( ) ) ; break ; case LINK REMOVED : remove Link ( update . get Src ( ) , update . get Src Port ( ) , update . get Dst ( ) , update . get Dst Port ( ) ) ; break ; case SWITCH UPDATED : add Or Update Switch ( update . get Src ( ) ) ; break ; case SWITCH REMOVED : remove Switch ( update . get Src ( ) ) ; break ; case TUNNEL PORT ADDED : add Tunnel Port ( update . get Src ( ) , update . get Src Port ( ) ) ; break ; case TUNNEL PORT REMOVED : remove Tunnel Port ( update . get Src ( ) , update . get Src Port ( ) ) ; break ; case PORT UP : case PORT DOWN : break ; } applied Updates . add ( update ) ; } return ( Collections . unmodifiable List ( applied Updates ) ) ; }
boolean is Empty ( ) { return m Description . is Empty ( ) && m Types . is Empty ( ) ; }
public Star ( int points , float rotation , float insideness ) { float x = NUM ; float y = NUM ; float radius = NUM ; points = points < NUM ? NUM : points ; rotation = rotation + ( float ) ( Math . PI / NUM ) ; boolean flat = insideness >= NUM ; set Control Point Size ( flat ? points : NUM * points ) ; final float pi 2 = NUM * ( float ) Math . PI ; float inside Radius = radius * insideness ; Point 2 D . Float pt ; for ( int p = NUM ; p < points ; ++ p ) { double vertex = p ; double angle = vertex * pi 2 / points + rotation ; pt = new Point 2 D . Float ( ( float ) ( x + Math . cos ( angle ) * radius ) , ( float ) ( y + Math . sin ( angle ) * radius ) ) ; push Point ( pt ) ; if ( ! flat ) { double angle 2 = ( vertex + NUM ) * pi 2 / points + rotation ; pt = new Point 2 D . Float ( ( float ) ( x + Math . cos ( angle 2 ) * inside Radius ) , ( float ) ( y + Math . sin ( angle 2 ) * inside Radius ) ) ; push Point ( pt ) ; } } }
private static boolean is Static ( Method m ) { int mods = m . get Modifiers ( ) ; return ( mods & Modifier . STATIC ) != NUM ; }
public synchronized boolean try Lock ( ) { try { lock = file . try Lock ( ) ; return lock != null ; } catch ( Exception e ) { return BOOL ; } }
@ Override public void node Down ( Topology topology , long event UID , String node ID ) { if ( target Server ID . equals ( node ID ) ) { decide On Action ( topology ) ; } }
public boolean is Valid ( ) { return BOOL ; }
private void rollover Log Task ( ) { try { if ( is Init ) { flush ( ) ; } } catch ( Exception e ) { log . log ( Level . WARNING , e . to String ( ) , e ) ; } is Rolling Over = BOOL ; try { if ( ! is Init ) return ; Path saved Path = null ; long now = Current Time . current Time ( ) ; long last Period End = next Period End ; next Period End = next Rollover Time ( now ) ; Path path = get Path ( ) ; synchronized ( log Lock ) { flush Temp Stream ( ) ; long length = Files . size ( path ) ; if ( last Period End <= now && last Period End > NUM ) { close Log Stream ( ) ; saved Path = get Saved Path ( last Period End - NUM ) ; } else if ( path != null && get Rollover Size ( ) <= length ) { close Log Stream ( ) ; saved Path = get Saved Path ( now ) ; } } if ( saved Path != null ) { move Path To Archive ( saved Path ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } finally { synchronized ( log Lock ) { is Rolling Over = BOOL ; flush Temp Stream ( ) ; } rollover Listener . requeue ( rollover Alarm ) ; } }
@ Override public void on Update Scrollbar ( int dy ) { List < Alphabetical Apps List . Adapter Item > items = m Apps . get Adapter Items ( ) ; if ( items . is Empty ( ) || m Num Apps Per Row == NUM ) { m Scrollbar . set Thumb Offset ( - NUM , - NUM ) ; return ; } int row Count = m Apps . get Num App Rows ( ) ; get Cur Scroll State ( m Scroll Pos State , - NUM ) ; if ( m Scroll Pos State . row Index < NUM ) { m Scrollbar . set Thumb Offset ( - NUM , - NUM ) ; return ; } int available Scroll Bar Height = get Available Scroll Bar Height ( ) ; int available Scroll Height = get Available Scroll Height ( m Apps . get Num App Rows ( ) ) ; if ( available Scroll Height <= NUM ) { m Scrollbar . set Thumb Offset ( - NUM , - NUM ) ; return ; } int scroll Y = get Scroll Top ( m Scroll Pos State ) ; int scroll Bar Y = m Background Padding . top + ( int ) ( ( ( float ) scroll Y / available Scroll Height ) * available Scroll Bar Height ) ; if ( m Scrollbar . is Thumb Detached ( ) ) { int scroll Bar X ; if ( Utilities . is Rtl ( get Resources ( ) ) ) { scroll Bar X = m Background Padding . left ; } else { scroll Bar X = get Width ( ) - m Background Padding . right - m Scrollbar . get Thumb Width ( ) ; } if ( m Scrollbar . is Dragging Thumb ( ) ) { m Scrollbar . set Thumb Offset ( scroll Bar X , ( int ) m Scrollbar . get Last Touch Y ( ) ) ; } else { int thumb Scroll Y = m Scrollbar . get Thumb Offset ( ) . y ; int diff Scroll Y = scroll Bar Y - thumb Scroll Y ; if ( diff Scroll Y * dy > NUM ) { if ( dy < NUM ) { int offset = ( int ) ( ( dy * thumb Scroll Y ) / ( float ) scroll Bar Y ) ; thumb Scroll Y += Math . max ( offset , diff Scroll Y ) ; } else { int offset = ( int ) ( ( dy * ( available Scroll Bar Height - thumb Scroll Y ) ) / ( float ) ( available Scroll Bar Height - scroll Bar Y ) ) ; thumb Scroll Y += Math . min ( offset , diff Scroll Y ) ; } thumb Scroll Y = Math . max ( NUM , Math . min ( available Scroll Bar Height , thumb Scroll Y ) ) ; m Scrollbar . set Thumb Offset ( scroll Bar X , thumb Scroll Y ) ; if ( scroll Bar Y == thumb Scroll Y ) { m Scrollbar . reattach Thumb To Scroll ( ) ; } } else { m Scrollbar . set Thumb Offset ( scroll Bar X , thumb Scroll Y ) ; } } } else { synchronize Scroll Bar Thumb Offset To View Scroll ( m Scroll Pos State , row Count ) ; } }
private void emit List Add ( Method method , String field Name , String Builder builder ) { builder . append ( STRING ) ; builder . append ( get List Adder Name ( field Name ) ) ; builder . append ( STRING ) ; builder . append ( get Type Argument Impl Name ( ( Parameterized Type ) method . get Generic Return Type ( ) , NUM ) ) ; builder . append ( STRING ) ; builder . append ( get Ensure Name ( field Name ) ) ; builder . append ( STRING ) ; builder . append ( field Name ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; }
public boolean on Scroll Changed ( int scroll Y ) { boolean is Pulling Down Now = scroll Y < last Scroll Y ; latest Pulling Down . offer ( is Pulling Down Now ) ; if ( latest Pulling Down . size ( ) > PULLING DOWN TIME MAX ) { latest Pulling Down . poll ( ) ; } last Scroll Y = scroll Y ; return get Pulling Down Time ( ) >= PULLING DOWN TIME THRESHOLD ; }
@ Exception Handler ( Constraint Violation Exception . class ) @ Response Status ( value = Http Status . BAD REQUEST ) public Map < String , Object > handle Constraint Violation Exception ( Constraint Violation Exception ex ) { Collection < Field Error > errors = Field Error . get Errors ( ex . get Constraint Violations ( ) ) ; log . warn ( STRING + errors . to String ( ) ) ; return Lemon Util . map Of ( STRING , STRING , STRING , errors ) ; }
@ Override public void read External ( Object Input in ) throws IO Exception { b = new double [ in . read Int ( ) ] ; for ( int p = NUM ; p < b . length ; p ++ ) { b [ p ] = in . read Double ( ) ; } }
private synchronized void add Tracker ( String path , Object marker , File Delete Strategy delete Strategy ) { if ( exit When Finished ) { throw new Illegal State Exception ( STRING ) ; } if ( reaper == null ) { reaper = new Reaper ( ) ; reaper . start ( ) ; } trackers . add ( new Tracker ( path , delete Strategy , marker , q ) ) ; }
List < Issue > errors ( ) { return errors ; }
public Audio Wife add On Completion Listener ( On Completion Listener listener ) { m Completion Listeners . add ( NUM , listener ) ; return this ; }
public void add Volume To Consistency Group ( String instance Id , String cg ID ) throws Storage Center API Exception { Rest Result rr = rest Client . get ( String . format ( STRING , instance Id ) ) ; if ( ! check Results ( rr ) ) { throw new Storage Center API Exception ( String . format ( STRING , rr . get Error Msg ( ) ) ) ; } Sc Volume Configuration vol Config = gson . from Json ( rr . get Result ( ) , Sc Volume Configuration . class ) ; List < String > profiles = new Array List < > ( ) ; for ( Sc Object profile : vol Config . replay Profile List ) { if ( ! cg ID . equals ( profile . instance Id ) ) { profiles . add ( profile . instance Id ) ; } } profiles . add ( cg ID ) ; Parameters params = new Parameters ( ) ; params . add ( STRING , profiles . to Array ( new String [ NUM ] ) ) ; rr = rest Client . put ( String . format ( STRING , instance Id ) , params . to Json ( ) ) ; if ( ! check Results ( rr ) ) { throw new Storage Center API Exception ( String . format ( STRING , rr . get Error Msg ( ) ) ) ; } }
public static boolean is Implements Interface ( Class clazz , Class interface Class ) { if ( ! ( interface Class . is Interface ( ) ) ) { throw new Illegal Argument Exception ( STRING ) ; } boolean result This Class = recursive Is Implements Interface ( clazz , interface Class ) ; if ( result This Class ) { return BOOL ; } return recursive Superclass Implements Interface ( clazz , interface Class ) ; }
private static String replace Chars ( String str ) { String Buffer buf = new String Buffer ( str ) ; int length = buf . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char current Char = buf . char At ( i ) ; if ( current Char == STRING ) { buf . set Char At ( i , STRING ) ; buf . insert ( i + NUM , STRING ) ; length = length + NUM ; i = i + NUM ; } else if ( current Char == STRING ) { buf . set Char At ( i , STRING ) ; } } return buf . to String ( ) ; }
private void add Binding ( final String key , final Object value ) { m bindings . put ( key , value ) ; }
public static < T extends Enum < T > > T for Key ( String key , Map < String , T > mapping , Class < T > enumeration ) { T t = mapping . get ( key ) ; if ( t != null ) { return t ; } throw new Illegal Argument Exception ( STRING + enumeration . to String ( ) + STRING + key ) ; }
private Exchange Rate direct Lookup ( final Currency source , final Currency target , final Date date ) { if ( System . get Property ( STRING ) == null ) throw new Unsupported Operation Exception ( STRING ) ; Exchange Rate rate = null ; QL . require ( ( ( rate = fetch ( source , target , date ) ) != null ) , STRING ) ; return rate ; }
protected static int find Next New Line Char ( Char Sequence s , int start ) { for ( int i = start ; i < s . length ( ) ; i ++ ) { if ( s . char At ( i ) == STRING ) { return i ; } } return - NUM ; }
public Skype Builder with Chat ( String id ) { if ( ! id . starts With ( STRING ) ) throw new Illegal Argument Exception ( STRING ) ; if ( password != null ) throw new Illegal Argument Exception ( STRING ) ; this . chat Id = id ; return this ; }
public static int compare To ( Object left , Object right ) { return compare To With Equality Check ( left , right , BOOL ) ; }
public static X509 CRL Impl to Impl ( X509 CRL crl ) throws CRL Exception { if ( crl instanceof X509 CRL Impl ) { return ( X509 CRL Impl ) crl ; } else { return X509 Factory . intern ( crl ) ; } }
public final void test ROUNDTRIP Get Key Spec Key Provider 02 ( ) { boolean performed = BOOL ; for ( int i = NUM ; i < alg Name . length ; i ++ ) { for ( int l = NUM ; l < provider . length ; l ++ ) { if ( provider [ l ] == null ) { continue ; } Test Data Generator g ; try { g = new Test Data Generator ( alg Name [ i ] [ NUM ] , alg Name [ i ] [ NUM ] , private Key Info Damaged , provider [ l ] ) ; } catch ( Test Data Generator . Allowed Failure allowed Failure ) { continue ; } try { Encrypted Private Key Info epki ; if ( g . ap ( ) == null ) { epki = new Encrypted Private Key Info ( alg Name [ i ] [ NUM ] , g . ct ( ) ) ; } else { epki = new Encrypted Private Key Info ( g . ap ( ) , g . ct ( ) ) ; } try { epki . get Key Spec ( g . pub K ( ) == null ? g . k ( ) : g . pub K ( ) , provider [ l ] ) ; fail ( alg Name [ i ] [ NUM ] + STRING + alg Name [ i ] [ NUM ] ) ; } catch ( Invalid Key Exception e ) { } performed = BOOL ; } catch ( No Such Algorithm Exception allowed Failure ) { } } } assert True ( STRING , performed ) ; }
public final synchronized void close All ( ) { if ( on Close All ( ) ) { Log . w ( TAG , STRING ) ; return ; } Linked List < Integer > ids = new Linked List < Integer > ( ) ; for ( int id : get Existing Ids ( ) ) { ids . add ( id ) ; } for ( int id : ids ) { close ( id ) ; } }
private static Pair < Character , Integer > normalize Codepoint ( String orig String , Charset encoding , int offset ) { char normalized Char = STRING ; boolean is Ok = BOOL ; final int codepoint = orig String . code Point At ( offset ) ; if ( encoding . equals ( Charset . for Name ( STRING ) ) ) { if ( codepoint < NUM ) is Ok = BOOL ; } else if ( encoding . equals ( Charset . for Name ( STRING ) ) ) { if ( codepoint < NUM ) is Ok = BOOL ; } else if ( encoding . equals ( Charset . for Name ( STRING ) ) ) { if ( codepoint < NUM ) is Ok = BOOL ; } if ( is Ok ) { normalized Char = ( char ) codepoint ; } else { is Ok = BOOL ; final int type = Character . get Type ( codepoint ) ; if ( type == Character . CURRENCY SYMBOL ) normalized Char = STRING ; else if ( type == Character . DASH PUNCTUATION ) normalized Char = STRING ; else if ( type == Character . FINAL QUOTE PUNCTUATION ) { normalized Char = STRING ; } else if ( type == Character . INITIAL QUOTE PUNCTUATION ) { normalized Char = STRING ; } else if ( type == Character . END PUNCTUATION ) normalized Char = STRING ; else if ( type == Character . DASH PUNCTUATION ) normalized Char = STRING ; else if ( type == Character . OTHER LETTER ) normalized Char = STRING ; else if ( type == Character . OTHER NUMBER ) normalized Char = STRING ; else if ( type == Character . OTHER PUNCTUATION ) normalized Char = STRING ; else if ( type == Character . OTHER SYMBOL ) normalized Char = STRING ; else is Ok = BOOL ; } Character new Char = null ; if ( is Ok ) new Char = normalized Char ; return new Pair < > ( new Char , codepoint ) ; }
public void test Pos Neg First Shorter ( ) { byte a Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { - NUM , NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , - NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { - NUM , NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , NUM , - NUM , - NUM , NUM , - NUM , - NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
private boolean start Random Game ( ) { Abstract Launch [ ] pins = m Card Adapter . get Launchers ( ) ; List < Abstract Launch > games = new Array List < Abstract Launch > ( pins . length ) ; for ( Abstract Launch pin : pins ) { if ( pin . is Game ( ) ) { if ( pin . m State == Abstract Launch . STATE READY ) { games . add ( pin ) ; } } } if ( games . size ( ) > NUM ) { Random r = new Random ( ) ; int index = r . next Int ( games . size ( ) ) ; Abstract Launch game = games . get ( index ) ; Log . d ( TAG , String . format ( STRING , game . m Content Description ) ) ; game . on Click ( game . get Click Target ( ) ) ; Measurement Manager . record Custom Event ( m Measurement , get String ( R . string . analytics event category launch ) , get String ( R . string . analytics launch action voice ) , game . m Content Description ) ; Analytics Manager . send Event ( R . string . analytics event category launch , R . string . analytics launch action voice , game . m Content Description ) ; return BOOL ; } else { return BOOL ; } }
public void init Disk Cache ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache == null || m Disk Lru Cache . is Closed ( ) ) { File disk Cache Dir = m Cache Params . disk Cache Dir ; if ( m Cache Params . disk Cache Enabled && disk Cache Dir != null ) { if ( ! disk Cache Dir . exists ( ) ) { disk Cache Dir . mkdirs ( ) ; } if ( get Usable Space ( disk Cache Dir ) > m Cache Params . disk Cache Size ) { try { m Disk Lru Cache = Disk Lru Cache . open ( disk Cache Dir , NUM , NUM , m Cache Params . disk Cache Size ) ; if ( Build Config . DEBUG ) { Log . d ( TAG , STRING ) ; } } catch ( final IO Exception e ) { m Cache Params . disk Cache Dir = null ; Log . e ( TAG , STRING + e ) ; } } } } m Disk Cache Starting = BOOL ; m Disk Cache Lock . notify All ( ) ; } }
boolean is Registered Permission ( Permission permission ) ;
public static int compare ( String id 1 , String id 2 ) { int result = - NUM ; String seed 1 = Id Generator . get Seed From Id ( id 1 ) ; String seed 2 = Id Generator . get Seed From Id ( id 2 ) ; if ( seed 1 != null && seed 2 != null ) { result = seed 1 . compare To ( seed 2 ) ; if ( result == NUM ) { long count 1 = Id Generator . get Sequence From Id ( id 1 ) ; long count 2 = Id Generator . get Sequence From Id ( id 2 ) ; result = ( int ) ( count 1 - count 2 ) ; } } return result ; }
public static Element add Child Element NS Element ( Element element , String child Element Name , Document document , String name Space Url ) { Element new Element = document . create Element NS ( name Space Url , child Element Name ) ; element . append Child ( new Element ) ; return element ; }
public VN Xe Command Result modify Consistency Group Sync ( String id , Lun Group Modify Param param ) { String Builder url Bld = new String Builder ( URL MODIFY 1 ) ; url Bld . append ( id ) ; url Bld . append ( URL MODIFY 2 ) ; url = url Bld . to String ( ) ; return post Request Sync ( param ) ; }
protected Query finish Query ( Boolean Query . Builder in , boolean all Terms Required ) { return in . build ( ) ; }
public long sum ( ) { long sum = NUM ; for ( Atomic Long value : map . values ( ) ) { sum = sum + value . get ( ) ; } return sum ; }
public void test Neg Pos First Shorter ( ) { byte a Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { - NUM , NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , - NUM } ; int a Sign = - NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . and ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
private void pull Event ( ) { final int new Scroll Value ; final int item Dimension ; final float initial Motion Value , last Motion Value ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : initial Motion Value = m Initial Motion X ; last Motion Value = m Last Motion X ; break ; case VERTICAL : default : initial Motion Value = m Initial Motion Y ; last Motion Value = m Last Motion Y ; break ; } switch ( m Current Mode ) { case PULL FROM END : new Scroll Value = Math . round ( Math . max ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Footer Size ( ) ; break ; case PULL FROM START : default : new Scroll Value = Math . round ( Math . min ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Header Size ( ) ; break ; } set Header Scroll ( new Scroll Value ) ; if ( new Scroll Value != NUM && ! is Refreshing ( ) ) { float scale = Math . abs ( new Scroll Value ) / ( float ) item Dimension ; switch ( m Current Mode ) { case PULL FROM END : m Footer Layout . on Pull ( scale ) ; break ; case PULL FROM START : default : m Header Layout . on Pull ( scale ) ; break ; } if ( m State != State . PULL TO REFRESH && item Dimension >= Math . abs ( new Scroll Value ) ) { set State ( State . PULL TO REFRESH ) ; } else if ( m State == State . PULL TO REFRESH && item Dimension < Math . abs ( new Scroll Value ) ) { set State ( State . RELEASE TO REFRESH ) ; } } }
public static String extract Full Stack Trace ( Throwable e ) { String Writer string Writer = new String Writer ( ) ; Print Writer print Writer = new Print Writer ( string Writer ) ; e . print Stack Trace ( print Writer ) ; return string Writer . to String ( ) ; }
public Empty Tile Factory ( Tile Factory Info info ) { super ( info ) ; int tile Size = info . get Tile Size ( info . get Minimum Zoom Level ( ) ) ; empty Tile = new Buffered Image ( tile Size , tile Size , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D g = empty Tile . create Graphics ( ) ; g . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; g . set Color ( Color . GRAY ) ; g . fill Rect ( NUM , NUM , tile Size , tile Size ) ; g . set Color ( Color . WHITE ) ; g . draw Oval ( NUM , NUM , tile Size - NUM , tile Size - NUM ) ; g . fill Oval ( NUM , NUM , NUM , NUM ) ; g . fill Oval ( tile Size - NUM , NUM , NUM , NUM ) ; g . fill Oval ( tile Size / NUM - NUM , tile Size / NUM - NUM , NUM , NUM ) ; g . dispose ( ) ; }
public static void i ( String tag , String msg , Object ... args ) { if ( s Level > LEVEL INFO ) { return ; } if ( args . length > NUM ) { msg = String . format ( msg , args ) ; } Log . i ( tag , msg ) ; }
public void close ( ) throws IO Exception { guard . close ( ) ; Random Access File local Raf = raf ; if ( local Raf != null ) { synchronized ( local Raf ) { raf = null ; local Raf . close ( ) ; } if ( file To Delete On Close != null ) { file To Delete On Close . delete ( ) ; file To Delete On Close = null ; } } }
public boolean match With Reg Ex ( String a Reg Ex ) { if ( Text Utils . is Empty ( a Reg Ex ) ) { return BOOL ; } boolean matched = BOOL ; if ( ! Text Utils . is Empty ( m Display Name ) ) { matched = m Display Name . matches ( a Reg Ex ) ; } if ( ! matched ) { for ( String email : m Emails ) { matched |= email . matches ( a Reg Ex ) ; } } return matched ; }
public String stem String ( String str ) { String Buffer result = new String Buffer ( ) ; int start = - NUM ; for ( int j = NUM ; j < str . length ( ) ; j ++ ) { char c = str . char At ( j ) ; if ( Character . is Letter Or Digit ( c ) ) { if ( start == - NUM ) { start = j ; } } else if ( c == STRING ) { if ( start == - NUM ) { result . append ( c ) ; } } else { if ( start != - NUM ) { result . append ( stem ( str . substring ( start , j ) ) ) ; start = - NUM ; } result . append ( c ) ; } } if ( start != - NUM ) { result . append ( stem ( str . substring ( start , str . length ( ) ) ) ) ; } return result . to String ( ) ; }
public static List < Integer > parse Numeric List ( String string ) { Array List < Integer > list = new Array List < > ( ) ; Pattern ranges = Pattern . compile ( STRING ) ; Matcher m = ranges . matcher ( string ) ; while ( m . find ( ) ) { String range = m . group ( STRING ) ; string = string . replace ( range , STRING ) ; parse Numeric Range ( range , list ) ; } String [ ] numbers = string . split ( STRING ) ; for ( int i = NUM ; i < numbers . length ; ++ i ) { String number = numbers [ i ] ; if ( ! number . is Empty ( ) ) { list . add ( Integer . value Of ( number ) ) ; } } Collections . sort ( list ) ; return list ; }
protected void save Pass Code And Exit ( ) { Intent result Intent = new Intent ( ) ; result Intent . put Extra ( KEY PASSCODE , m Pass Code Digits [ NUM ] + m Pass Code Digits [ NUM ] + m Pass Code Digits [ NUM ] + m Pass Code Digits [ NUM ] ) ; set Result ( RESULT OK , result Intent ) ; finish ( ) ; }
public static void read Fully ( File Channel file , long pos , Byte Buffer dst ) { try { do { int len = file . read ( dst , pos ) ; if ( len < NUM ) { throw new EOF Exception ( ) ; } pos += len ; } while ( dst . remaining ( ) > NUM ) ; dst . rewind ( ) ; } catch ( IO Exception e ) { long size ; try { size = file . size ( ) ; } catch ( IO Exception e2 ) { size = - NUM ; } throw new Illegal State Exception ( ERROR READING FAILED , STRING + STRING , file , size , dst . remaining ( ) , pos , e ) ; } }
private static void sparse Full Representation Test ( final I Schema Version schema Version ) throws IO Exception { final Writer output = open Output ( schema Version , STRING , Test Type . UNION ) ; final HLL empty HLL 1 = new HLL ( HLL Type . EMPTY ) ; final HLL empty HLL 2 = new HLL ( HLL Type . EMPTY ) ; cumulative Union Line ( output , empty HLL 1 , empty HLL 2 , schema Version ) ; final HLL full HLL = new HLL ( HLL Type . FULL ) ; full HLL . add Raw ( construct HLL Value ( LOG 2 M , NUM , NUM ) ) ; final HLL sparse HLL = new HLL ( HLL Type . SPARSE ) ; sparse HLL . add Raw ( construct HLL Value ( LOG 2 M , NUM , NUM ) ) ; output . write ( string Cardinality ( full HLL ) + STRING + to Byte A ( full HLL , schema Version ) + STRING + string Cardinality ( sparse HLL ) + STRING + to Byte A ( sparse HLL , schema Version ) + STRING ) ; output . flush ( ) ; final HLL full HLL 2 = new HLL ( HLL Type . FULL ) ; full HLL 2 . add Raw ( construct HLL Value ( LOG 2 M , NUM , NUM ) ) ; sparse HLL . add Raw ( construct HLL Value ( LOG 2 M , NUM , NUM ) ) ; output . write ( string Cardinality ( full HLL 2 ) + STRING + to Byte A ( full HLL 2 , schema Version ) + STRING + string Cardinality ( sparse HLL ) + STRING + to Byte A ( sparse HLL , schema Version ) + STRING ) ; output . flush ( ) ; final HLL full HLL 3 = new HLL ( HLL Type . FULL ) ; for ( int i = NUM ; i < ( SPARSE THRESHOLD + NUM ) ; i ++ ) { full HLL 3 . add Raw ( construct HLL Value ( LOG 2 M , i , NUM ) ) ; sparse HLL . add Raw ( construct HLL Value ( LOG 2 M , i , NUM ) ) ; } output . write ( string Cardinality ( full HLL 3 ) + STRING + to Byte A ( full HLL 3 , schema Version ) + STRING + string Cardinality ( sparse HLL ) + STRING + to Byte A ( sparse HLL , schema Version ) + STRING ) ; output . flush ( ) ; }
public void trigger Cycle ( ) { lock . lock ( ) ; trigger Count ++ ; contexts Parked = NUM ; lock . broadcast ( ) ; lock . unlock ( ) ; }
protected boolean heapify Down Comparator ( final int ipos , Object cur ) { int pos = ipos ; final int half = size > > > NUM ; while ( pos < half ) { int min = pos ; Object best = cur ; final int lchild = ( pos << NUM ) + NUM ; Object left = queue [ lchild ] ; if ( comparator . compare ( best , left ) > NUM ) { min = lchild ; best = left ; } final int rchild = lchild + NUM ; if ( rchild < size ) { Object right = queue [ rchild ] ; if ( comparator . compare ( best , right ) > NUM ) { min = rchild ; best = right ; } } if ( min == pos ) { break ; } queue [ pos ] = best ; pos = min ; } queue [ pos ] = cur ; return ( pos != ipos ) ; }
public static boolean is String ( String str ) { return ( ( str . starts With ( STRING ) && str . ends With ( STRING ) ) || ( str . starts With ( STRING ) && str . ends With ( STRING ) ) ) && str . length ( ) > NUM ; }
static public boolean has Photo ( Tweet tweet ) { return get Photo Entity ( tweet ) != null ; }
public void test Case 19 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = Big Integer . ZERO ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public static String Builder format To ( String Builder buf , long [ ] d , String sep ) { if ( d == null ) { return buf . append ( STRING ) ; } if ( d . length == NUM ) { return buf ; } buf . append ( d [ NUM ] ) ; for ( int i = NUM ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( d [ i ] ) ; } return buf ; }
public static < T > int upper Bound ( final List < T > value List , int from Idx , int to Idx , final Comparable < T > value ) { int len = to Idx - from Idx + ( to Idx > from Idx ? NUM : NUM ) ; int from = from Idx ; int half ; int middle ; while ( len > NUM ) { half = len > > NUM ; middle = from ; middle = middle + half ; if ( value . compare To ( value List . get ( middle ) ) == - NUM ) { len = half ; } else { from = middle ; from ++ ; len = len - half - NUM ; } } return from ; }
public int size ( ) { return data . size ( ) ; }
public static synchronized void register Additional Hyphenation File Directory ( String directory ) { if ( additional Hyphenation File Directories == null ) { additional Hyphenation File Directories = new Array List < > ( ) ; } additional Hyphenation File Directories . add ( directory ) ; }
private void insert New Drive Files ( ) throws IO Exception { Cursor cursor = null ; try { cursor = my Tracks Provider Utils . get Track Cursor ( Sync Utils . NO DRIVE ID TRACKS QUERY , null , null ) ; long recording Track Id = Preferences Utils . get Long ( context , R . string . recording track id key ) ; if ( cursor != null && cursor . move To First ( ) ) { do { Track track = my Tracks Provider Utils . create Track ( cursor ) ; if ( track . get Id ( ) == recording Track Id ) { continue ; } Sync Utils . insert Drive File ( drive , folder Id , context , my Tracks Provider Utils , track , BOOL , BOOL ) ; } while ( cursor . move To Next ( ) ) ; } } finally { if ( cursor != null ) { cursor . close ( ) ; } } }
public void test Handle normal Completion ( ) { for ( Execution Mode m : Execution Mode . values ( ) ) for ( boolean create Incomplete : new boolean [ ] { BOOL , BOOL } ) for ( Integer v1 : new Integer [ ] { NUM , null } ) { final Completable Future < Integer > f = new Completable Future < > ( ) ; final Atomic Integer a = new Atomic Integer ( NUM ) ; if ( ! create Incomplete ) assert True ( f . complete ( v1 ) ) ; final Completable Future < Integer > g = m . handle ( f , null ) ; if ( create Incomplete ) assert True ( f . complete ( v1 ) ) ; check Completed Normally ( g , inc ( v1 ) ) ; check Completed Normally ( f , v1 ) ; assert Equals ( NUM , a . get ( ) ) ; } }
private static String unescape ( String s ) { int len = s . length ( ) , base = NUM , idx ; String escapes = STRING ; String chars = STRING ; String Buffer sbuf = null ; while ( ( idx = s . index Of ( STRING , base ) ) != - NUM ) { if ( sbuf != null ) sbuf . append ( s . substring ( base , idx ) ) ; if ( idx + NUM == len ) break ; char c = s . char At ( idx + NUM ) ; int cidx = escapes . index Of ( c ) ; if ( cidx == - NUM ) { sbuf . append ( STRING ) ; sbuf . append ( c ) ; } else { if ( sbuf == null ) sbuf = new String Buffer ( s . substring ( base , idx ) ) ; sbuf . append ( chars . char At ( cidx ) ) ; } base = idx + NUM ; } if ( sbuf != null && base < len ) sbuf . append ( s . substring ( base ) ) ; return ( sbuf == null ? s : sbuf . to String ( ) ) ; }
public static void put ( String dbg Token ) { dbg Table . put ( dbg Token , Boolean . TRUE ) ; }
public boolean remove Data Set ( T d ) { if ( d == null ) return BOOL ; boolean removed = m Data Sets . remove ( d ) ; if ( removed ) { mY Val Count -= d . get Entry Count ( ) ; mY Value Sum -= d . get Y Value Sum ( ) ; calc Min Max ( m Data Sets ) ; } return removed ; }
public long reserved Store ( ) { return m size * m total Slots ; }
public Transfer write String ( String s ) throws IO Exception { if ( s == null ) { out . write Int ( - NUM ) ; } else { int len = s . length ( ) ; out . write Int ( len ) ; for ( int i = NUM ; i < len ; i ++ ) { out . write Char ( s . char At ( i ) ) ; } } return this ; }
private void fill Inside Draw ( Graphics g , int x , int y , int w , int h ) { g . set Color ( Color . BLACK ) ; g . draw Rect ( x , y , w , h ) ; g . set Color ( Color . LIGHT GRAY ) ; g . fill Rect ( x + NUM , y + NUM , w - NUM , h - NUM ) ; }
public Drawer Builder add Sticky Drawer Items ( @ Non Null I Drawer Item ... sticky Drawer Items ) { if ( this . m Sticky Drawer Items == null ) { this . m Sticky Drawer Items = new Array List < > ( ) ; } Collections . add All ( this . m Sticky Drawer Items , sticky Drawer Items ) ; return this ; }
public void append To Buffer ( String Builder buf ) { Iterator < Polygon > iter = polygons . iterator ( ) ; while ( iter . has Next ( ) ) { Polygon poly = iter . next ( ) ; poly . append To Buffer ( buf ) ; if ( iter . has Next ( ) ) { buf . append ( STRING ) ; } } }
public void add Function ( Function Interface active Function ) { functions . add ( active Function ) ; }
public static Charset to Charset ( Charset charset ) { return charset == null ? Charset . default Charset ( ) : charset ; }
public < T extends Data Object > Joiner join ( Class < T > clazz , String alias ) { if ( ! j Classes . is Empty ( ) ) { throw new Joiner Exception ( STRING ) ; } J Class jc = new J Class ( clazz , alias , j Classes . size ( ) ) ; j Classes . add ( jc ) ; last J Class = jc ; alias Map . put ( alias , jc ) ; return this ; }
public Byte Vector put Byte Array ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b != null ) { System . arraycopy ( b , off , data , length , len ) ; } length += len ; return this ; }
public static void show Progress Bar ( int status , int i ) { if ( m Root View != null ) { Progress Bar pb = ( Progress Bar ) m Root View . find View By Id ( R . id . progress slice ) ; Text View tv = ( Text View ) m Root View . find View By Id ( R . id . viewer text progress slice ) ; Text View tve = ( Text View ) m Root View . find View By Id ( R . id . viewer text estimated time ) ; Text View tve title = ( Text View ) m Root View . find View By Id ( R . id . viewer estimated time textview ) ; if ( m Slicing Handler . get Last Reference ( ) != null ) { tve title . set Visibility ( View . VISIBLE ) ; pb . set Visibility ( View . VISIBLE ) ; switch ( status ) { case State Utils . SLICER HIDE : if ( i < NUM ) { tv . set Text ( R . string . error ) ; } else { tv . set Text ( R . string . viewer text downloaded ) ; } pb . set Visibility ( View . INVISIBLE ) ; break ; case State Utils . SLICER UPLOAD : String upload Text = m Context . get String ( R . string . viewer text uploading ) ; if ( i == NUM ) pb . set Indeterminate ( BOOL ) ; else { pb . set Progress ( i ) ; pb . set Indeterminate ( BOOL ) ; upload Text += STRING + i + STRING ; } tv . set Text ( upload Text ) ; tve . set Text ( null ) ; break ; case State Utils . SLICER SLICE : String slicing Text = m Context . get String ( R . string . viewer text slicing ) ; if ( i == NUM ) { pb . set Indeterminate ( BOOL ) ; } else if ( i == NUM ) { pb . set Indeterminate ( BOOL ) ; pb . set Progress ( NUM ) ; slicing Text += STRING + m Context . get String ( R . string . viewer text done ) ; } else { pb . set Progress ( i ) ; pb . set Indeterminate ( BOOL ) ; slicing Text += STRING + i + STRING ; } tv . set Text ( slicing Text ) ; tve . set Text ( null ) ; m Root View . invalidate ( ) ; break ; case State Utils . SLICER DOWNLOAD : if ( i > NUM ) { tve . set Text ( Octoprint Connection . Convert Second To HHMM String ( String . value Of ( i ) ) ) ; } tv . set Text ( R . string . viewer text downloading ) ; pb . set Indeterminate ( BOOL ) ; break ; default : break ; } } else { pb . set Visibility ( View . INVISIBLE ) ; tve title . set Visibility ( View . INVISIBLE ) ; tv . set Text ( null ) ; tve . set Text ( null ) ; m Root View . invalidate ( ) ; } } }
public Launch Option ( Version version , Authenticator authenticator , Minecraft Directory minecraft Dir ) { Objects . require Non Null ( version ) ; Objects . require Non Null ( authenticator ) ; Objects . require Non Null ( minecraft Dir ) ; this . version = version ; this . authenticator = authenticator ; this . minecraft Directory = minecraft Dir ; this . runtime Directory = minecraft Dir ; this . java Environment = Java Environment . current ( ) ; }
protected boolean is Stoppable ( ) { return ( is Running ( ) && get Locator ( ) != null ) ; }
public void load ( String file Name ) throws Exception { if ( ! file Name . ends With ( STRING ) && ! file Name . ends With ( STRING ) ) { throw new Exception ( STRING + STRING ) ; } if ( file Name . ends With ( STRING ) ) { load Binary ( file Name ) ; } else if ( file Name . ends With ( STRING ) ) { load XML ( file Name ) ; } }
public Bindings add Opt Component ( String property , Class clazz , J Toggle Button c , boolean enabled By Default ) { Binding b = new Opt Component Binding ( this , property , clazz , c , enabled By Default ) ; if ( opt Components . contains Key ( property ) ) { throw new Binding Exception ( Messages . get String ( STRING ) ) ; } opt Components . put ( property , b ) ; return this ; }
public static boolean copy File ( File file , File copy ) { if ( file == null || copy == null ) throw new Null Pointer Exception ( STRING ) ; if ( ! file . is File ( ) || copy . is Directory ( ) ) throw new Illegal Argument Exception ( STRING ) ; File Input Stream fis = null ; File Output Stream fos = null ; try { fis = new File Input Stream ( file ) ; fos = new File Output Stream ( copy ) ; int bytes ; byte [ ] packet = new byte [ COPY PACKET SIZE ] ; while ( ( bytes = fis . read ( packet , NUM , COPY PACKET SIZE ) ) != - NUM ) fos . write ( packet , NUM , bytes ) ; return BOOL ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , STRING , e ) ; return BOOL ; } finally { try { if ( fos != null ) fos . close ( ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , STRING , e ) ; } try { if ( fis != null ) fis . close ( ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , STRING , e ) ; } } }
public static byte [ ] encrypt My SQL Password ( String password , byte [ ] seed ) { if ( password == null || password . equals ( STRING ) ) { return new byte [ NUM ] ; } Message Digest digest = null ; try { digest = Message Digest . get Instance ( STRING ) ; } catch ( No Such Algorithm Exception e ) { logger . error ( STRING , e ) ; return new byte [ NUM ] ; } byte [ ] stage 1 hash = digest . digest ( password . get Bytes ( ) ) ; digest . reset ( ) ; byte [ ] sha 1 stage 1 = digest . digest ( stage 1 hash ) ; digest . reset ( ) ; digest . update ( seed ) ; digest . update ( sha 1 stage 1 ) ; byte [ ] final Sha 1 = digest . digest ( ) ; byte [ ] token = new byte [ final Sha 1 . length ] ; for ( int i = NUM ; i < final Sha 1 . length ; i ++ ) { token [ i ] = ( byte ) ( stage 1 hash [ i ] ^ final Sha 1 [ i ] ) ; } return token ; }
protected void add Url ( URL url ) { if ( urls . contains ( url ) ) { LOGGER . info ( STRING + url ) ; return ; } urls . add ( url ) ; LOGGER . info ( STRING + url ) ; }
private int [ ] define Numeric ( Random random ) { int [ ] num = new int [ get Num Attributes ( ) ] ; for ( int i = NUM ; i < num . length ; i ++ ) { num [ i ] = Attribute . NOMINAL ; } int num Num = NUM ; for ( int i = NUM ; ( num Num < get Num Numeric ( ) ) && ( i < get Num Attributes ( ) * NUM ) ; i ++ ) { int maybe Next = ( int ) ( random . next Double ( ) * num . length ) ; if ( num [ maybe Next ] != Attribute . NUMERIC ) { num [ maybe Next ] = Attribute . NUMERIC ; num Num ++ ; } } return num ; }
public static boolean is Favorite Station ( Context context , int i Station ) { return is Station Exist ( context , i Station , STATION TYPE FAVORITE ) ; }
protected void paint Caption ( Graphics g , Rectangle rect ) { String s = get Target Label ( ) ; if ( s . equals ( STRING ) ) { return ; } g . set Font ( get Target Font ( ) ) ; Font Metrics fm = g . get Font Metrics ( ) ; String str = get Target Label ( ) ; int width = fm . string Width ( str ) ; int textx = rect . x + ( rect . width - width ) / NUM ; int texty = rect . y + CAPTION MARGIN TOP + fm . get Ascent ( ) ; int sepy = rect . y + rect . height - CAPTION SEPARATOR HEIGHT / NUM ; g . set Color ( is Target Enabled ( ) ? get Foreground Color ( ) : get Disabled Color ( ) ) ; g . draw String ( s , textx , texty ) ; draw 3 D Rect ( g , rect . x , sepy , rect . width , NUM , BOOL ) ; }
private static boolean has Specialized Handler Intents ( Context context , Intent intent ) { try { Package Manager pm = context . get Package Manager ( ) ; List < Resolve Info > handlers = pm . query Intent Activities ( intent , Package Manager . GET RESOLVED FILTER ) ; if ( handlers == null || handlers . size ( ) == NUM ) { return BOOL ; } for ( Resolve Info resolve Info : handlers ) { Intent Filter filter = resolve Info . filter ; if ( filter == null ) continue ; if ( filter . count Data Authorities ( ) == NUM || filter . count Data Paths ( ) == NUM ) continue ; if ( resolve Info . activity Info == null ) continue ; return BOOL ; } } catch ( Runtime Exception e ) { Log . e ( TAG , STRING ) ; } return BOOL ; }
public void put Float ( float x ) { bb . put Float ( space -= NUM , x ) ; }
final void put Int ( int offset , int value ) { unsafe . put Int ( offset + address , value ) ; }
private static boolean is Unreserved Character ( char p char ) { return ( is Alphanum ( p char ) || MARK CHARACTERS . index Of ( p char ) != - NUM ) ; }
public static Inet Socket Address parse Socket Address ( String addr ) { String [ ] parts = addr . split ( COLON ) ; Preconditions . check Argument ( parts . length == NUM ) ; String hostname = parts [ NUM ] ; int port = Integer . parse Int ( parts [ NUM ] ) ; return new Inet Socket Address ( hostname , port ) ; }
@ Override public void write External ( Object Output out ) throws IO Exception { super . write External ( out ) ; out . write Object ( approximation ) ; }
public Object [ ] to Array ( ) { final Object [ ] items = this . items ; final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { final int count = this . count ; Object [ ] a = new Object [ count ] ; int n = items . length - take Index ; if ( count <= n ) { System . arraycopy ( items , take Index , a , NUM , count ) ; } else { System . arraycopy ( items , take Index , a , NUM , n ) ; System . arraycopy ( items , NUM , a , n , count - n ) ; } return a ; } finally { lock . unlock ( ) ; } }
public void message Arrived ( Mqtt Publish send Message ) { final String method Name = STRING ; if ( mqtt Callback != null || callbacks . size ( ) > NUM ) { synchronized ( space Available ) { while ( running && ! quiescing && message Queue . size ( ) >= INBOUND QUEUE SIZE ) { try { log . fine ( CLASS NAME , method Name , STRING ) ; space Available . wait ( NUM ) ; } catch ( Interrupted Exception ex ) { } } } if ( ! quiescing ) { message Queue . add Element ( send Message ) ; synchronized ( work Available ) { log . fine ( CLASS NAME , method Name , STRING ) ; work Available . notify All ( ) ; } } } }
private void find Home ( ) { String home = System . get Property ( STRING ) ; if ( home == null ) home = System . get Property ( STRING ) ; if ( home == null ) home = System . get Property ( STRING ) ; if ( home == null ) home = System . get Property ( STRING ) ; if ( home != null ) manifest Path = home + File . separator + STRING + File . separator + manifest File Name ; else manifest Path = manifest File Name ; }
public static final int [ ] to Int Array ( String s [ ] ) { int u [ ] = new int [ s . length ] ; for ( int j = NUM ; j < s . length ; j ++ ) { u [ j ] = Integer . parse Int ( s [ j ] ) ; } return u ; }
private List < String > check All Columns In Cube ( Cube Instance cube , Table Desc table , Map < String , Hive Table Meta . Hive Table Column Meta > fields Map ) { Set < Column Desc > used Columns = Sets . new Hash Set ( ) ; for ( Tbl Col Ref col : cube . get All Columns ( ) ) { used Columns . add ( col . get Column Desc ( ) ) ; } List < String > violate Columns = Lists . new Array List ( ) ; for ( Column Desc column : table . get Columns ( ) ) { if ( used Columns . contains ( column ) ) { Hive Table Meta . Hive Table Column Meta field = fields Map . get ( column . get Name ( ) ) ; if ( field == null || ! is Column Compatible ( column , field ) ) { violate Columns . add ( column . get Name ( ) ) ; } } } return violate Columns ; }
public static String make Unified Line Feeds ( String query ) { if ( query . index Of ( STRING ) == - NUM ) { return query ; } String Builder result = new String Builder ( query . length ( ) ) ; for ( int i = NUM ; i < query . length ( ) ; i ++ ) { char c = query . char At ( i ) ; if ( c == STRING ) { continue ; } result . append ( c ) ; } return result . to String ( ) ; }
private void reflect Member Variables In Left Button ( ) { final boolean last Page Reached = ( view Pager . get Current Item ( ) + NUM ) == pages . size ( ) ; final boolean button Should Be Invisible = ( last Page Reached && disable Left Button On Last Page ) || left Button Disabled ; final boolean button Is Currently Invisible = left Button . get Visibility ( ) == View . INVISIBLE ; final boolean should Update Button = button Should Be Invisible != button Is Currently Invisible ; if ( should Update Button ) { final Animator button Animator = button Should Be Invisible ? button Animator Factory . new Left Button Disappear Animator ( left Button ) : button Animator Factory . new Left Button Appear Animator ( left Button ) ; if ( button Should Be Invisible ) { disable Button ( button Animator , left Button ) ; } else { enable Button ( button Animator , left Button ) ; } } }
public static void register Semi Disposable Block ( String ore Dict Name ) { semi Disposable Blocks . add ( ore Dict Name ) ; }
public boolean accepts Type Name ( String type ) { return type List . contains ( type ) ; }
public void delete Async ( final String id , final Future Callback < Task > response Callback ) throws IO Exception { delete Object Async ( id , response Callback ) ; }
private boolean continue After Accept Failure ( Throwable t ) { RMI Failure Handler fh = RMI Socket Factory . get Failure Handler ( ) ; if ( fh != null ) { return fh . failure ( t instanceof Exception ? ( Exception ) t : new Invocation Target Exception ( t ) ) ; } else { throttle Loop On Exception ( ) ; return BOOL ; } }
private static void process Package ( String tb Name , Packages pkg ) { String class Name Prefix = String Util . parse Hump Name ( tb Name , BOOL , is Hump Model Class ) ; pkg . set Dao ( package Prefix + ( String Util . is Empty ( package Prefix ) || String Util . is Empty ( package Dao ) ? STRING : STRING ) + package Dao ) ; pkg . set Dao Name ( class Name Prefix + dao Suffix ) ; pkg . set Model ( package Prefix + ( String Util . is Empty ( package Prefix ) || String Util . is Empty ( package Model ) ? STRING : STRING ) + package Model ) ; pkg . set Model Name ( class Name Prefix + model Suffix ) ; pkg . set Mapper Xml ( package Prefix + ( String Util . is Empty ( package Prefix ) || String Util . is Empty ( package Mapper Xml ) ? STRING : STRING ) + package Mapper Xml ) ; pkg . set Mapper Xml Name ( class Name Prefix + mapper Xml Suffix ) ; pkg . set Model Name Lower First ( String Util . lower First ( pkg . get Model Name ( ) ) ) ; }
public void add On Central Position Changed Listener ( On Central Position Changed Listener listener ) { m On Central Position Changed Listeners . add ( listener ) ; }
public boolean add Call ( String source Class , String source Method , String target Class , String target Method ) { Call Graph Entry from = new Call Graph Entry ( target Class , target Method ) ; Call Graph Entry to = new Call Graph Entry ( source Class , source Method ) ; if ( source Class . equals ( class Name ) ) cut Nodes . add ( to ) ; if ( ! graph . contains Edge ( from , to ) ) { graph . add Edge ( from , to ) ; call Graph Classes . add ( target Class . replace All ( STRING , STRING ) ) ; return BOOL ; } return BOOL ; }
private static void do Thread Dump ( final Http Servlet Request req , final Http Servlet Response resp ) throws IO Exception { resp . set Status ( HTTP OK ) ; resp . add Header ( STRING , STRING ) ; resp . set Content Type ( MIME TEXT PLAIN ) ; final Print Writer w = resp . get Writer ( ) ; try { Bigdata Statics . thread Dump ( w ) ; w . flush ( ) ; } catch ( Throwable t ) { launder Throwable ( t , resp , STRING ) ; } finally { w . close ( ) ; } }
public static boolean is Valid Nmtoken ( String nmtoken ) { final int length = nmtoken . length ( ) ; if ( length == NUM ) { return BOOL ; } for ( int i = NUM ; i < length ; ++ i ) { char ch = nmtoken . char At ( i ) ; if ( ! is Name ( ch ) ) { return BOOL ; } } return BOOL ; }
public MM Roll ( MM Random rng ) { super ( NUM , NUM ) ; this . total = rng . random Int ( this . faces ) + this . min ; all . add Element ( this . total ) ; }
public void handle Button 3 Request ( Request Invocation Event event ) throws Model Control Exception { return To Home Page ( ) ; }
static < T > Unix Stream < T > unixify ( final Stream < T > stream ) { Objects . require Non Null ( stream , STRING ) ; return new Unix Stream Impl < > ( stream ) ; }
@ Deprecated public Media File ( File f ) { this ( f . to Path ( ) , null ) ; }
public static Key Store load ( File key Store File , Password password , Key Store Type key Store Type ) throws Crypto Exception , File Not Found Exception { if ( ! key Store Type . is File Based ( ) ) { throw new Crypto Exception ( Message Format . format ( res . get String ( STRING ) , key Store Type . jce ( ) ) ) ; } File Input Stream fis = new File Input Stream ( key Store File ) ; Key Store key Store = get Key Store Instance ( key Store Type ) ; try { key Store . load ( fis , password . to Char Array ( ) ) ; } catch ( Certificate Exception ex ) { throw new Key Store Load Exception ( Message Format . format ( res . get String ( STRING ) , key Store Type ) , ex , key Store Type ) ; } catch ( No Such Algorithm Exception ex ) { throw new Key Store Load Exception ( Message Format . format ( res . get String ( STRING ) , key Store Type ) , ex , key Store Type ) ; } catch ( File Not Found Exception ex ) { throw ex ; } catch ( IO Exception ex ) { throw new Key Store Load Exception ( Message Format . format ( res . get String ( STRING ) , key Store Type ) , ex , key Store Type ) ; } finally { IO Utils . close Quietly ( fis ) ; } return key Store ; }
public static String add To Cart Bulk ( Http Servlet Request request , Http Servlet Response response ) { String category Id = request . get Parameter ( STRING ) ; Shopping Cart cart = get Cart Object ( request ) ; Delegator delegator = ( Delegator ) request . get Attribute ( STRING ) ; Local Dispatcher dispatcher = ( Local Dispatcher ) request . get Attribute ( STRING ) ; Shopping Cart Helper cart Helper = new Shopping Cart Helper ( delegator , dispatcher , cart ) ; String control Directive ; Map < String , Object > result ; Map < String , Object > param Map = Util Http . get Parameter Map ( request ) ; String catalog Id = Catalog Worker . get Current Catalog Id ( request ) ; result = cart Helper . add To Cart Bulk ( catalog Id , category Id , param Map ) ; control Directive = process Result ( result , request ) ; if ( control Directive . equals ( ERROR ) ) { return STRING ; } else { return STRING ; } }
public void dump Log ( String container Id , File log File ) throws Docker Exception , Interrupted Exception { Log Stream error Stream = null ; File Channel file Channel = null ; File Output Stream file Output Stream = null ; try { if ( log File . exists ( ) ) { log File . delete ( ) ; } log File . create New File ( ) ; file Output Stream = new File Output Stream ( log File ) ; file Channel = file Output Stream . get Channel ( ) ; error Stream = docker Client . logs ( container Id , Logs Param . stderr ( ) ) ; while ( error Stream . has Next ( ) ) { Log Message message = error Stream . next ( ) ; Byte Buffer buffer = message . content ( ) ; file Channel . write ( buffer ) ; } } catch ( File Not Found Exception e ) { throw new Docker Exception ( STRING + log File + STRING ) ; } catch ( IO Exception e ) { throw new Docker Exception ( e ) ; } finally { if ( error Stream != null ) { error Stream . close ( ) ; } if ( file Channel != null ) { try { file Channel . close ( ) ; } catch ( IO Exception e ) { logger . error ( STRING , e ) ; } } if ( file Output Stream != null ) { try { file Output Stream . close ( ) ; } catch ( IO Exception e ) { logger . error ( STRING , e ) ; } } } }
public static final void warning ( String message , Throwable e ) { if ( message == null && e != null ) { message = e . get Message ( ) ; } log Expensive ( Level . WARNING , message , e ) ; }
public static Indexed Image pack ( int [ ] rgb , int width , int height ) { int array Length = width * height ; int [ ] temp Palette = new int [ NUM ] ; int palette Location = NUM ; for ( int iter = NUM ; iter < array Length ; iter ++ ) { int current = rgb [ iter ] ; if ( ! contains ( temp Palette , palette Location , current ) ) { if ( palette Location > NUM ) { return null ; } temp Palette [ palette Location ] = current ; palette Location ++ ; } } if ( palette Location != temp Palette . length ) { int [ ] new Array = new int [ palette Location ] ; System . arraycopy ( temp Palette , NUM , new Array , NUM , palette Location ) ; temp Palette = new Array ; } Indexed Image i = new Indexed Image ( width , height , temp Palette , rgb ) ; return i ; }
public void add Hint ( Component hint Component , Component destination Component , String position ) { hint Component . put Client Property ( POS , position ) ; hint Component . put Client Property ( DEST , destination Component ) ; vec . add Element ( hint Component ) ; }
public static int convert SRG Bto Linear RGB ( int color ) { float input , output ; input = color / NUM ; if ( input <= NUM ) { output = input / NUM ; } else { output = ( float ) Math . pow ( ( input + NUM ) / NUM , NUM ) ; } return Math . round ( output * NUM ) ; }
public void vetoable Change ( Property Change Event evt ) throws Property Veto Exception { log . info ( evt . to String ( ) ) ; throw new Property Veto Exception ( STRING , evt ) ; }
private void write Attribute ( java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( namespace . equals ( STRING ) ) { xml Writer . write Attribute ( att Name , att Value ) ; } else { register Prefix ( xml Writer , namespace ) ; xml Writer . write Attribute ( namespace , att Name , att Value ) ; } }
public void finish ( ) throws SQL Exception { Statement statement = connection . create Statement ( ) ; statement . execute ( STRING ) ; statement . close ( ) ; statement = connection . create Statement ( ) ; statement . execute ( STRING ) ; statement . close ( ) ; statement = connection . create Statement ( ) ; statement . execute ( STRING ) ; statement . close ( ) ; statement = connection . create Statement ( ) ; statement . execute ( STRING ) ; statement . close ( ) ; }
@ Override public boolean contains ( Object object ) { return index Of ( object , NUM ) != - NUM ; }
public void put ( E item ) throws Interrupted Exception { if ( ! done . get ( ) ) { queue . put ( item ) ; } }
public Authorization Code ( String code , String resource Owner Id , String client Id , String redirect Uri , Set < String > scope , String claims , long expiry Time , String nonce , String realm , String auth Modules , String acr , String sso Token Id , String code Challenge , String code Challenge Method , String auth Grant Id , String audit Id ) { super ( new Hash Map < String , Object > ( ) ) ; set String Property ( ID , code ) ; set String Property ( USERNAME , resource Owner Id ) ; set String Property ( CLIENT ID , client Id ) ; set String Property ( REDIRECT URI , redirect Uri ) ; set String Property ( EXPIRE TIME , String . value Of ( expiry Time ) ) ; put ( SCOPE , new List ( scope ) ) ; set String Property ( TOKEN TYPE , STRING ) ; set String Property ( TOKEN NAME , OAUTH CODE TYPE ) ; set String Property ( NONCE , nonce ) ; set String Property ( AUTH MODULES , auth Modules ) ; set String Property ( ACR , acr ) ; set String Property ( CODE CHALLENGE , code Challenge ) ; set String Property ( CODE CHALLENGE METHOD , code Challenge Method ) ; set String Property ( AUTH GRANT ID , auth Grant Id ) ; set String Property ( REALM , realm == null || realm . is Empty ( ) ? STRING : realm ) ; set String Property ( SSO TOKEN ID , sso Token Id ) ; put ( CLAIMS , Collection Utils . as List ( claims ) ) ; set String Property ( AUDIT TRACKING ID , audit Id ) ; }
@ Override public Object draw ( Graphics 2 D g2 , Rectangle 2 D area , Object params ) { draw ( g2 , area ) ; return null ; }
public void test Set Bit Positive Inside 3 ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = NUM ; int number = NUM ; byte r Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . set Bit ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public boolean is Row Visible ( int row ) { if ( row != - NUM ) { Rectangle cell Rect = get Cell Rect ( row , NUM , BOOL ) ; Rectangle visible Rect = get Visible Rect ( ) ; return visible Rect . intersects ( cell Rect ) ; } else return BOOL ; }
public void signal Event ( ) { Collection < Semaphore > semaphores = semaphores . values ( ) ; for ( Semaphore semaphore : semaphores ) { semaphore . release ( ) ; semaphores . remove ( semaphore ) ; } }
public static int file In Time Range ( File f , Date start , Date end ) { long time = get File Time ( f ) ; if ( start != null && time < start . get Time ( ) ) { return - NUM ; } if ( end != null && time > end . get Time ( ) ) { return NUM ; } return NUM ; }
private float interpolate ( ) { long curr Time = System . current Time Millis ( ) ; float elapsed = ( curr Time - start Time ) / ZOOM TIME ; elapsed = Math . min ( NUM , elapsed ) ; return interpolator . get Interpolation ( elapsed ) ; }
public Object ext Function ( String ns , String func Name , Vector arg Vec , Object method Key , Expression Context expr Context ) throws javax . xml . transform . Transformer Exception { Object result = null ; if ( null != ns ) { Extension Handler ext NS = ( Extension Handler ) m extension Function Namespaces . get ( ns ) ; if ( null != ext NS ) { try { result = ext NS . call Function ( func Name , arg Vec , method Key , expr Context ) ; } catch ( javax . xml . transform . Transformer Exception e ) { throw e ; } catch ( Exception e ) { throw new javax . xml . transform . Transformer Exception ( e ) ; } } else { throw new X Path Processor Exception ( XSL Messages . create Message ( XSLT Error Resources . ER EXTENSION FUNC UNKNOWN , new Object [ ] { ns , func Name } ) ) ; } } return result ; }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m build Thread . is Alive ( ) && m state != IDLE ) { wait ( ) ; } } catch ( Interrupted Exception ex ) { } } else { notify All ( ) ; } }
public Set < Resource > on Class ( ) { Set < Resource > targets = new Hash Set < > ( ) ; for ( Owl Class c : qc Classes ) { targets . add ( c . get URI ( ) ) ; } return targets ; }
public static int index Of Chars ( String str , String chars , int from Index ) { final int len = str . length ( ) ; for ( int pos = from Index ; pos < len ; pos ++ ) { if ( chars . index Of ( str . char At ( pos ) ) >= NUM ) { return pos ; } } return - NUM ; }
private synchronized void notify Zoom Listeners ( Zoom Event e ) { for ( Zoom Listener listener : m Zoom Listeners ) { listener . zoom Applied ( e ) ; } }
public static String build String From Lines ( String ... lines ) { int num Chars = lines . length ; for ( String line : lines ) { num Chars += line . length ( ) ; } String Builder builder = new String Builder ( num Chars ) ; for ( String line : lines ) { builder . append ( line ) ; builder . append ( STRING ) ; } return builder . to String ( ) ; }
public void init ( ) { if ( m Context == null ) { return ; } if ( m Name . is Empty ( ) ) { m Name = m Context . get Package Name ( ) ; } if ( m Mode == INVALID VALUE || ( m Mode != MODE PRIVATE && m Mode != MODE WORLD READABLE && m Mode != MODE WORLD WRITEABLE ) ) { m Mode = MODE PRIVATE ; } m Shared Preferences = m Context . get Shared Preferences ( m Name , m Mode ) ; }
@ Override public void merge And Output Transformation Metadata ( Iterator < Distinct Value > values , String output Dir , int col ID , File System fs , Tf Utils agents ) throws IO Exception { double min = Double . MAX VALUE ; double max = - Double . MAX VALUE ; int nbins = NUM ; Distinct Value val = new Distinct Value ( ) ; String w = null ; double d ; while ( values . has Next ( ) ) { val . reset ( ) ; val = values . next ( ) ; w = val . get Word ( ) ; if ( w . starts With ( MIN PREFIX ) ) { d = Util Functions . parse To Double ( w . substring ( MIN PREFIX . length ( ) ) ) ; if ( d < min ) min = d ; } else if ( w . starts With ( MAX PREFIX ) ) { d = Util Functions . parse To Double ( w . substring ( MAX PREFIX . length ( ) ) ) ; if ( d > max ) max = d ; } else if ( w . starts With ( NBINS PREFIX ) ) { nbins = ( int ) Util Functions . parse To Long ( w . substring ( NBINS PREFIX . length ( ) ) ) ; } else throw new Runtime Exception ( STRING + w ) ; } double binwidth = ( max - min ) / nbins ; write Tf Mtd ( col ID , Double . to String ( min ) , Double . to String ( max ) , Double . to String ( binwidth ) , Integer . to String ( nbins ) , output Dir , fs , agents ) ; }
static SQL Warning convert Show Warnings To SQL Warnings ( Connection connection ) throws SQL Exception { return convert Show Warnings To SQL Warnings ( connection , NUM , BOOL ) ; }
public boolean has Empty Row ( ) { if ( m data Vector . size ( ) == NUM ) { return BOOL ; } List < String > data Row = m data Vector . get ( m data Vector . size ( ) - NUM ) ; for ( String s : data Row ) { if ( s . length ( ) != NUM ) { return BOOL ; } } return BOOL ; }
public synchronized byte [ ] to Byte Array ( ) { int remaining = count ; if ( remaining == NUM ) { return EMPTY BYTE ARRAY ; } byte newbuf [ ] = new byte [ remaining ] ; int pos = NUM ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; System . arraycopy ( buf , NUM , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == NUM ) { break ; } } return newbuf ; }
public Node select Single Node ( Node context Node , String str , Node namespace Node ) throws Transformer Exception { Node Iterator nl = select Node Iterator ( context Node , str , namespace Node ) ; return nl . next Node ( ) ; }
private static String java Script Escape Helper ( String s , boolean escape To Ascii ) { String Builder sb = new String Builder ( s . length ( ) * NUM / NUM ) ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; switch ( c ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : append Hex Java Script Representation ( sb , c ) ; break ; case STRING : case STRING : boolean is Unsafe = BOOL ; for ( String tag : UNSAFE TAGS ) { if ( s . region Matches ( BOOL , i + NUM , tag , NUM , tag . length ( ) ) ) { is Unsafe = BOOL ; break ; } } if ( is Unsafe ) { append Hex Java Script Representation ( sb , c ) ; } else { sb . append ( c ) ; } break ; case STRING : if ( sb . length ( ) > NUM && sb . char At ( sb . length ( ) - NUM ) == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; default : if ( c >= NUM && escape To Ascii ) { append Hex Java Script Representation ( sb , c ) ; } else { sb . append ( c ) ; } } } return sb . to String ( ) ; }
public synchronized void add ( String category , double value ) { m Categories . add ( category ) ; m Values . add ( value ) ; }
public final void walk Graph ( Hashtable sem Nodes Table ) { Integer uid = new Integer ( my UID ) ; if ( sem Nodes Table . get ( uid ) != null ) return ; sem Nodes Table . put ( uid , this ) ; if ( assume Expr != null ) { assume Expr . walk Graph ( sem Nodes Table ) ; } ; }
private List < Value Combo Box Data Group > populate Symbol List ( Class < ? > panel Details ) { List < Value Combo Box Data Group > combined Symbol List = new Array List < Value Combo Box Data Group > ( ) ; for ( Field State panel : symbol Type Field List ) { panel . populate Symbol List ( panel Details , combined Symbol List ) ; } return combined Symbol List ; }
@ Override public int hash Code ( ) { long value = NUM ; value += NUM * value + Double . double To Long Bits ( Math . abs ( x ) ) ; value += NUM * value + Double . double To Long Bits ( Math . abs ( y ) ) ; return ( int ) ( value ^ ( value > > > NUM ) ) ; }
public void disconnect ( ) { socket . disconnect ( ) ; }
protected void init Component Defaults ( UI Defaults table ) { super . init Component Defaults ( table ) ; Color c = table . get Color ( STRING ) ; table . put ( STRING , c ) ; table . put ( STRING , c ) ; }
public int index Of Column Name ( String column Name ) { return column Name List . index Of ( column Name . to Lower Case ( ) ) ; }
public boolean clear ( T expect , boolean allow Reset ) { sync . lock ( ) ; try { if ( expect != value ) { return BOOL ; } Value State prev = state ; clear ( allow Reset ) ; return prev == Value State . SET ; } finally { sync . unlock ( ) ; } }
public void copy Stream ( Input Stream is ) throws IO Exception { super . set Content Encoding ( null ) ; Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; while ( BOOL ) { int b = is . read ( ) ; if ( b == - NUM ) { content = baos . to Byte Array ( ) ; is . close ( ) ; return ; } } }
public void test read Resolve ( ) { Mock Attributed Character Iterator Attribute mac 1 = new Mock Attributed Character Iterator Attribute ( STRING ) ; try { mac 1 . read Resolve ( ) ; fail ( STRING ) ; } catch ( Invalid Object Exception e ) { } Object Output Stream out = null ; Object Input Stream in = null ; try { Byte Array Output Stream bytes = new Byte Array Output Stream ( ) ; out = new Object Output Stream ( bytes ) ; Attributed Character Iterator . Attribute attr 1 , attr 2 ; attr 1 = Attributed Character Iterator . Attribute . LANGUAGE ; out . write Object ( attr 1 ) ; in = new Object Input Stream ( new Byte Array Input Stream ( bytes . to Byte Array ( ) ) ) ; try { attr 2 = ( Attributed Character Iterator . Attribute ) in . read Object ( ) ; assert Same ( STRING , attr 1 , attr 2 ) ; } catch ( Illegal Argument Exception e ) { fail ( STRING + e ) ; } } catch ( IO Exception e ) { fail ( STRING + e ) ; } catch ( Class Not Found Exception e ) { fail ( STRING + e ) ; } finally { try { if ( out != null ) out . close ( ) ; if ( in != null ) in . close ( ) ; } catch ( IO Exception e ) { } } }
public void interrupt ( ) { Thread t = thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } thread Var . clear ( ) ; }
public final boolean is Secure ( Socket sock ) throws Illegal Argument Exception { if ( sock == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( sock . get Class ( ) != Socket . class ) { throw new Illegal Argument Exception ( STRING ) ; } if ( sock . is Closed ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } return BOOL ; }
protected boolean check List ( String current Val , String token Value ) { if ( current Val == null || token Value == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ! current Val . starts With ( STRING ) && ! current Val . starts With ( STRING ) ) { throw new Illegal Argument Exception ( STRING ) ; } boolean negation = current Val . starts With ( STRING ) ; String list Name = current Val . substring ( current Val . index Of ( STRING ) + NUM ) ; Object list Obj = list Map . get ( list Name ) ; if ( list Obj == null ) return BOOL ; boolean contains ; if ( list Obj instanceof Set ) { Set < String > set = ( Set ) list Obj ; contains = set . contains ( token Value ) ; } else { throw new Illegal Argument Exception ( STRING + list Obj ) ; } return ! ( contains && negation || ! contains && ! negation ) ; }
public static synchronized void add Native Library Dependencies ( String name , String ... dependency Names ) { List < String > list = library Dependencies . get ( name ) ; if ( list == null ) { library Dependencies . put ( name , list = new Array List < String > ( ) ) ; } for ( String dependency Name : dependency Names ) { if ( ! list . contains ( dependency Name ) ) { list . add ( dependency Name ) ; } } }
@ Override protected boolean has Overflow ( Flat R Star Tree Node node ) { if ( node . is Leaf ( ) ) { return node . get Num Entries ( ) == leaf Capacity ; } else if ( node . get Num Entries ( ) == node . get Capacity ( ) ) { node . increase Entries ( ) ; } return BOOL ; }
public void process Volume Expansion ( Storage System storage System , URI storage Pool URI , URI volume Id , CIM Argument [ ] out Args ) throws Exception { String Builder log Msg Builder = new String Builder ( String . format ( STRING ) ) ; Cim Connection connection = cim Connection . get Connection ( storage System ) ; WBEM Client client = connection . get Cim Client ( ) ; Storage Pool storage Pool = db Client . query Object ( Storage Pool . class , storage Pool URI ) ; String Map reservation Map = storage Pool . get Reserved Capacity Map ( ) ; reservation Map . remove ( volume Id . to String ( ) ) ; update Storage Pool Capacity ( client , storage Pool ) ; db Client . persist Object ( storage Pool ) ; Volume volume = db Client . query Object ( Volume . class , volume Id ) ; CIM Object Path volume Path = ( CIM Object Path ) cim Path . get From Output Args ( out Args , IBM Smis Constants . CP THE ELEMENT ) ; boolean is Success = BOOL ; if ( volume Path != null ) { CIM Instance volume Instance = client . get Instance ( volume Path , BOOL , BOOL , null ) ; if ( volume Instance != null ) { is Success = BOOL ; volume . set Provisioned Capacity ( get Provisioned Capacity Information ( volume Instance ) ) ; volume . set Allocated Capacity ( get Allocated Capacity Information ( client , volume Instance ) ) ; db Client . persist Object ( volume ) ; log Msg Builder . append ( String . format ( STRING , volume . get Capacity ( ) , volume . get Provisioned Capacity ( ) , volume . get Allocated Capacity ( ) ) ) ; } } if ( ! is Success ) { Unsigned Integer 32 return Coede = ( Unsigned Integer 32 ) cim Path . get From Output Args ( out Args , IBM Smis Constants . CP RETURN CODE ) ; log Msg Builder . append ( STRING ) ; log Msg Builder . append ( String . format ( STRING , volume . get Id ( ) , return Coede . to String ( ) ) ) ; } log . info ( log Msg Builder . to String ( ) ) ; }
void update From Native Node ( Node node , boolean from Scratch ) throws IIO Invalid Tree Exception { Named Node Map attrs = node . get Attributes ( ) ; if ( attrs . get Length ( ) > NUM ) { int value = get Attribute Value ( node , attrs , STRING , NUM , NUM , BOOL ) ; major Version = ( value != - NUM ) ? value : major Version ; value = get Attribute Value ( node , attrs , STRING , NUM , NUM , BOOL ) ; minor Version = ( value != - NUM ) ? value : minor Version ; value = get Attribute Value ( node , attrs , STRING , NUM , NUM , BOOL ) ; res Units = ( value != - NUM ) ? value : res Units ; value = get Attribute Value ( node , attrs , STRING , NUM , NUM , BOOL ) ; Xdensity = ( value != - NUM ) ? value : Xdensity ; value = get Attribute Value ( node , attrs , STRING , NUM , NUM , BOOL ) ; Ydensity = ( value != - NUM ) ? value : Ydensity ; value = get Attribute Value ( node , attrs , STRING , NUM , NUM , BOOL ) ; thumb Width = ( value != - NUM ) ? value : thumb Width ; value = get Attribute Value ( node , attrs , STRING , NUM , NUM , BOOL ) ; thumb Height = ( value != - NUM ) ? value : thumb Height ; } if ( node . has Child Nodes ( ) ) { Node List children = node . get Child Nodes ( ) ; int count = children . get Length ( ) ; if ( count > NUM ) { throw new IIO Invalid Tree Exception ( STRING , node ) ; } for ( int i = NUM ; i < count ; i ++ ) { Node child = children . item ( i ) ; String name = child . get Node Name ( ) ; if ( name . equals ( STRING ) ) { if ( ( ! ext Segments . is Empty ( ) ) && from Scratch ) { throw new IIO Invalid Tree Exception ( STRING , node ) ; } Node List exts = child . get Child Nodes ( ) ; int ext Count = exts . get Length ( ) ; for ( int j = NUM ; j < ext Count ; j ++ ) { Node ext = exts . item ( j ) ; ext Segments . add ( new JFIF Extension Marker Segment ( ext ) ) ; } } if ( name . equals ( STRING ) ) { if ( ( icc Segment != null ) && from Scratch ) { throw new IIO Invalid Tree Exception ( STRING , node ) ; } icc Segment = new ICC Marker Segment ( child ) ; } } } }
private void add Best Test Suite ( File newly Generated Test Suite ) { String test Name = extract Class Name ( tmp Tests , newly Generated Test Suite ) ; String path = test Name . replace ( STRING , File . separator ) + STRING ; File file = new File ( get Best Test Folder ( ) + File . separator + path ) ; file . delete ( ) ; try { File Utils . copy File ( newly Generated Test Suite , file ) ; } catch ( IO Exception e ) { logger . error ( STRING + e . get Message ( ) , e ) ; } }
@ Override public void create Connection Factory ( String name , boolean ha , boolean use Discovery , int cf Type , String connectors , String bindings ) throws Exception { create Connection Factory ( name , ha , use Discovery , cf Type , to Array ( connectors ) , to Array ( bindings ) ) ; }
protected Object evaluate Single ( List elements , String expr ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Single ( ( Structured Content ) o , expr ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM ) { return ( Structured Content ) array . get ( NUM ) ; } return array ; }
protected void on Close ( ) { }
private int do Scale ( int number , double factor ) { return ( int ) Strict Math . round ( number * factor ) ; }
private int parse Message Id ( final byte [ ] b , final int off ) throws Parse Exception { final int message Id Len = Constants . MESSAGE ID LEN ; final int len = b . length - off ; if ( len >= message Id Len ) { message Id = Arrays . copy Of Range ( b , off , off + message Id Len ) ; return message Id Len ; } else { throw new Parse Exception ( STRING ) ; } }
static void generate Character Class ( String the Template File Name , String the Output File Name ) throws File Not Found Exception , IO Exception { Buffered Reader in = new Buffered Reader ( new File Reader ( the Template File Name ) ) ; Print Writer out = new Print Writer ( new Buffered Writer ( new File Writer ( the Output File Name ) ) ) ; out . println ( comment Start + STRING + new java . util . Date ( ) + comment End ) ; int marklen = command Marker . length ( ) ; LOOP : while ( BOOL ) { try { String line = in . read Line ( ) ; if ( line == null ) break LOOP ; int pos = NUM ; int depth = NUM ; while ( ( pos = line . index Of ( command Marker , pos ) ) >= NUM ) { int newpos = pos + marklen ; char ch = STRING ; SCAN : while ( newpos < line . length ( ) && ( Character . is Java Identifier Start ( ch = line . char At ( newpos ) ) || ch == STRING || ( ch == STRING && depth > NUM ) ) ) { ++ newpos ; if ( ch == STRING ) { ++ depth ; } else if ( ch == STRING ) { -- depth ; if ( depth == NUM ) break SCAN ; } } String replacement = replace Command ( line . substring ( pos + marklen , newpos ) ) ; line = line . substring ( NUM , pos ) + replacement + line . substring ( newpos ) ; pos += replacement . length ( ) ; } out . println ( line ) ; } catch ( IO Exception e ) { break LOOP ; } } in . close ( ) ; out . close ( ) ; }
public static String combine Extensions ( final String [ ] extensions ) { Check . not Null ( extensions , STRING ) ; final String Buffer ret = new String Buffer ( ) ; for ( int i = NUM ; i < extensions . length ; i ++ ) { if ( i > NUM ) { ret . append ( STRING ) ; } ret . append ( extensions [ i ] ) ; } return ret . to String ( ) ; }
public static void initialize Properties ( String file ) throws Missing Resource Exception { Properties props = new Properties ( ) ; Resource Bundle bundle = Resource Bundle . get Bundle ( file ) ; for ( String key : bundle . key Set ( ) ) { props . put ( key , bundle . get String ( key ) ) ; } initialize Properties ( props , BOOL , BOOL ) ; }
private E unlink First ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; not Full . signal ( ) ; return item ; }
private String tweak Native Launch Uri ( String uri , boolean for Debugging , Launch Info launch Info ) throws IO Exception , File Not Found Exception { if ( launch Info . is Http Or About ( ) ) { boolean modify = ( get Preference ( PREF URI MODIFICATION ) != NUM ) ; if ( modify && for Debugging && ! launch Info . is About ( ) ) { uri = URL Helper . escape Space ( uri ) ; URL Helper url Helper = new URL Helper ( uri ) ; Map < String , String > params = url Helper . get Parameter Map ( ) ; params . put ( STRING , STRING ) ; url Helper . set Parameter Map ( params ) ; uri = url Helper . get URL ( ) ; } } else { File f = null ; if ( uri . starts With ( STRING ) ) { try { f = new File ( new URI ( uri ) ) ; } catch ( URI Syntax Exception e ) { IO Exception ioe = new IO Exception ( e . get Message ( ) ) ; ioe . init Cause ( e ) ; throw ioe ; } } else { f = new File ( uri ) ; } if ( f != null && f . exists ( ) ) { uri = f . get Absolute Path ( ) ; } else { throw new File Not Found Exception ( uri ) ; } } return uri ; }
public void add Listener ( final Listener listener ) { listeners . add ( listener ) ; }
public List < T > query As List ( ) { Quantum Flux Cursor < T > cursor = query As Cursor ( ) ; try { List < T > result List = new Array List < > ( cursor . get Count ( ) ) ; while ( cursor . move To Next ( ) ) { result List . add ( cursor . inflate ( ) ) ; } return result List ; } finally { if ( cursor != null ) cursor . close ( ) ; } }
@ Override public void profile ( ) { record Stats ( ) ; }
public static void touch ( File file ) throws IO Exception { if ( ! file . exists ( ) ) { Output Stream out = open Output Stream ( file ) ; IO Utils . close Quietly ( out ) ; } boolean success = file . set Last Modified ( System . current Time Millis ( ) ) ; if ( ! success ) { throw new IO Exception ( STRING + file ) ; } }
public boolean is Empty ( ) { return ext Ordering . is Empty ( ) ; }
public static byte [ ] iv Cipher Concat ( byte [ ] iv , byte [ ] cipher Text ) { byte [ ] combined = new byte [ iv . length + cipher Text . length ] ; System . arraycopy ( iv , NUM , combined , NUM , iv . length ) ; System . arraycopy ( cipher Text , NUM , combined , iv . length , cipher Text . length ) ; return combined ; }
public static final void save Instance Identifier ( String conf Path , String instance Identifier ) throws Exception { Path file = Paths . get ( conf Path , INSTANCE IDENTIFIER FILE ) ; log . trace ( STRING , file ) ; Atomic Save . execute ( file . to String ( ) , STRING , instance Identifier . get Bytes ( Standard Charsets . UTF 8 ) ) ; }
Part ( String contents , String property ) throws Exception { this . contents = STRING + contents ; this . property = property ; simplify ( ) ; }
public static boolean is Same ( Object s1 , Object s2 ) { if ( s1 == s2 ) return BOOL ; if ( X . is Empty ( s1 ) && X . is Empty ( s2 ) ) return BOOL ; if ( s1 != null ) { return s1 . equals ( s2 ) ; } return BOOL ; }
public static double standard Deviation ( double variance ) { return Math . sqrt ( variance ) ; }
public static int frequency To MIDI Note ( double a Frequency ) { double r = NUM ; double ref = NUM ; int supinf = NUM ; int i = NUM ; double hautnb = NUM ; double ref 1 = NUM ; double ref 2 = NUM ; double flag = NUM ; int nmidi = NUM ; while ( a Frequency < ref ) { ref = Math . floor ( NUM * ref / r ) / NUM ; i = i + NUM ; supinf = - NUM ; flag = NUM ; ref 1 = ref ; } while ( a Frequency > ref ) { ref = Math . floor ( NUM * ref * r ) / NUM ; i = i - NUM ; supinf = NUM ; ref 2 = ref ; } if ( Math . abs ( a Frequency - ref 1 ) < Math . abs ( a Frequency - ref 2 ) ) { supinf = - NUM ; i = i + NUM ; } else { if ( flag == NUM ) supinf = - NUM ; } if ( ref 1 == NUM ) { ref 1 = Math . floor ( NUM * ref / r ) / NUM ; if ( Math . abs ( a Frequency - ref 1 ) < Math . abs ( a Frequency - ref 2 ) ) { i = i + NUM ; supinf = NUM ; } } i = Math . abs ( i ) ; while ( i -- != NUM ) { if ( ( hautnb == NUM && supinf == - NUM ) || ( hautnb == NUM && supinf == NUM ) ) { if ( supinf == NUM ) hautnb = NUM ; if ( supinf == - NUM ) hautnb = NUM ; } hautnb = hautnb + supinf ; nmidi = nmidi + supinf ; } return nmidi ; }
private void write Attribute ( java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( namespace . equals ( STRING ) ) { xml Writer . write Attribute ( att Name , att Value ) ; } else { register Prefix ( xml Writer , namespace ) ; xml Writer . write Attribute ( namespace , att Name , att Value ) ; } }
public void record GC Versions ( Region Version Vector < T > other ) { assert other . member To GC Version != null : STRING ; record GC Version ( other . my Id , other . local GC Version . get ( ) ) ; for ( Map . Entry < T , Long > entry : other . member To GC Version . entry Set ( ) ) { record GC Version ( entry . get Key ( ) , entry . get Value ( ) . long Value ( ) ) ; } }
boolean wait For State ( Processor p , int state ) { synchronized ( wait Sync ) { try { while ( p . get State ( ) < state && state Transition OK ) wait Sync . wait ( ) ; } catch ( Exception e ) { } } return state Transition OK ; }
private static boolean extract File ( Context c , String root Asset , String path ) { Asset Manager asset Manager = c . get Assets ( ) ; Input Stream in = null ; Output Stream out = null ; try { in = asset Manager . open ( root Asset + path ) ; String full Path = Pref Store . get Env Dir ( c ) + path ; out = new File Output Stream ( full Path ) ; byte [ ] buffer = new byte [ NUM ] ; int read ; while ( ( read = in . read ( buffer ) ) != - NUM ) { out . write ( buffer , NUM , read ) ; } out . flush ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; return BOOL ; } finally { close ( in ) ; close ( out ) ; } return BOOL ; }
protected int never ( ) { synchronized ( sleep Lock ) { while ( running ) { try { sleep Lock . wait ( NUM * NUM * NUM ) ; } catch ( Interrupted Exception e ) { continue ; } } return NUM ; } }
public boolean verify ( X509 Certificate cert , Provider sig Provider ) throws No Such Algorithm Exception , Certificate Expired Exception , Certificate Not Yet Valid Exception , CMS Exception { Time signing Time = get Signing Time ( ) ; if ( signing Time != null ) { cert . check Validity ( signing Time . get Date ( ) ) ; } return do Verify ( cert . get Public Key ( ) , sig Provider ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return MESSAGE TYPE ; case NUM : return REQUEST INFO ; case NUM : return RESPONSE INFO ; case NUM : return TRACE INFO ; case NUM : return GLOBAL CONTEXT ; case NUM : return LOCAL CONTEXT ; case NUM : return HEARTBEAT INFO ; default : return null ; } }
protected void load History ( boolean set ) { Buffered Input Stream str ; File file ; int width ; int height ; try { file = new File ( get History Filename ( ) ) ; if ( file . exists ( ) ) { str = new Buffered Input Stream ( new File Input Stream ( get History Filename ( ) ) ) ; m History . load ( str ) ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; } if ( set ) { m Connection Panel . set History ( string To Model ( m History . get Property ( Connection Panel . HISTORY NAME , STRING ) ) ) ; m Query Panel . set History ( string To Model ( m History . get Property ( Query Panel . HISTORY NAME , STRING ) ) ) ; m Query Panel . set Max Rows ( Integer . parse Int ( m History . get Property ( Query Panel . MAX ROWS , STRING ) ) ) ; width = Integer . parse Int ( m History . get Property ( WIDTH , STRING ) ) ; height = Integer . parse Int ( m History . get Property ( HEIGHT , STRING ) ) ; if ( ( width != NUM ) && ( height != NUM ) ) { set Preferred Size ( new Dimension ( width , height ) ) ; } } }
private void update Panel For Expansion ( float percentage ) { update Promo Visibility ( NUM ) ; float base Base Y = Math Utils . interpolate ( NUM , get Base Page Target Y ( ) , percentage ) ; m Base Page Y = base Base Y ; float brightness = Math Utils . interpolate ( BASE PAGE BRIGHTNESS STATE PEEKED , BASE PAGE BRIGHTNESS STATE EXPANDED , percentage ) ; m Base Page Brightness = brightness ; float search Bar Height = Math . round ( Math Utils . interpolate ( m Search Bar Height Peeking , get Search Bar Height Expanded ( ) , percentage ) ) ; m Search Bar Height = search Bar Height ; m Search Bar Text Opacity = NUM ; m Is Search Bar Border Visible = BOOL ; m Search Bar Border Y = search Bar Height - SEARCH BAR BORDER HEIGHT DP + NUM ; m Search Icon Opacity = SEARCH ICON OPACITY STATE EXPANDED ; m Arrow Icon Opacity = ARROW ICON OPACITY STATE EXPANDED ; m Arrow Icon Rotation = Math . round ( Math Utils . interpolate ( ARROW ICON ROTATION STATE PEEKED , ARROW ICON ROTATION STATE EXPANDED , percentage ) ) ; m Close Icon Opacity = CLOSE ICON OPACITY STATE EXPANDED ; float peeked Height = get Panel Height From State ( Panel State . PEEKED ) ; float threshold = PROGRESS BAR VISIBILITY THRESHOLD DP / m Px To Dp ; float diff = Math . min ( m Height - peeked Height , threshold ) ; float progress Bar Opacity = Math Utils . interpolate ( NUM , NUM , diff / threshold ) ; m Progress Bar Opacity = progress Bar Opacity ; m Progress Bar Y = search Bar Height - PROGRESS BAR HEIGHT DP + NUM ; update Search Bar Shadow ( ) ; }
protected boolean [ ] updateable Clusterer ( ) { boolean [ ] result = new boolean [ NUM ] ; print ( STRING ) ; if ( m Clusterer instanceof Updateable Clusterer ) { println ( STRING ) ; result [ NUM ] = BOOL ; } else { println ( STRING ) ; result [ NUM ] = BOOL ; } return result ; }
@ Override protected int size Of ( String key , Bitmap Drawable value ) { final int bitmap Size = get Bitmap Size ( value ) / NUM ; return bitmap Size == NUM ? NUM : bitmap Size ; }
public void add Field ( Mapped Member mm ) { fields . add ( mm ) ; }
public static List < Base Mqtt Message > read And Convert Message Log ( final File selected File ) throws Spy Exception { final List < String > lines = File Utils . read File As Lines ( selected File ) ; logger . info ( STRING , lines . size ( ) , selected File . get Absolute File ( ) ) ; return process Message Log ( parse Message Log ( lines , null , NUM , NUM ) , null , NUM , NUM ) ; }
void read Stream ( Input Stream is ) throws Exception { String line ; Date start = new Date ( ) ; Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( is ) ) ; while ( ( line = reader . read Line ( ) ) != null && ! m Stop ) { m Results . append ( line ) ; m Results . append ( Tools . Line Sep ) ; Date end = new Date ( ) ; if ( ( end . get Time ( ) - start . get Time ( ) ) / NUM > NUM || m Results . length ( ) > NUM ) { start = end ; int last = m Results . last Index Of ( STRING ) ; if ( last != - NUM ) { Xmpp Msg msg = new Xmpp Msg ( font ) ; msg . append ( m Results . substring ( NUM , last + NUM ) ) ; m Cmd Base . send ( m Shell Id , msg ) ; m Results . set Length ( NUM ) ; } } } }
public static boolean is Valid Name ( String name ) { if ( name == null ) { return BOOL ; } return name . length ( ) > NUM ; }
public void remove Parent Relation ( long osm Id ) { if ( parent Relations != null ) { Array List < Relation > temp Rel List = new Array List < Relation > ( parent Relations ) ; for ( Relation r : temp Rel List ) { if ( osm Id == r . get Osm Id ( ) ) parent Relations . remove ( r ) ; } } }
public final void test ROUNDTRIP Get Key Spec Cipher 01 ( ) { boolean performed = BOOL ; for ( int i = NUM ; i < alg Name . length ; i ++ ) { try { Test Data Generator g = new Test Data Generator ( alg Name [ i ] [ NUM ] , alg Name [ i ] [ NUM ] , private Key Info , null ) ; Encrypted Private Key Info epki ; if ( g . ap ( ) == null ) { epki = new Encrypted Private Key Info ( alg Name [ i ] [ NUM ] , g . ct ( ) ) ; } else { epki = new Encrypted Private Key Info ( g . ap ( ) , g . ct ( ) ) ; } try { PKCS 8 Encoded Key Spec eks = epki . get Key Spec ( g . c ( ) ) ; if ( ! Arrays . equals ( private Key Info , eks . get Encoded ( ) ) ) { fail ( alg Name [ i ] [ NUM ] + STRING + alg Name [ i ] [ NUM ] ) ; } } catch ( Invalid Key Spec Exception e ) { fail ( alg Name [ i ] [ NUM ] + STRING + alg Name [ i ] [ NUM ] + e + STRING ) ; } performed = BOOL ; } catch ( Test Data Generator . Allowed Failure allowed Failure ) { } catch ( No Such Algorithm Exception allowed ) { } } assert True ( STRING , performed ) ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
void insert ( V val , K key ) { Array List < K > list = map . get ( val ) ; if ( list == null ) { list = new Array List < K > ( NUM ) ; map . put ( clone Value ( val ) , list ) ; } list . add ( key ) ; }
public Server Socket create Server Socket ( int nport , int backlog ) throws IO Exception { return create Server Socket ( nport , backlog , null ) ; }
public static Array List < Integer > convert String Array To Integer Array ( List < String > array List ) { Array List < Integer > integers = new Array List < > ( ) ; for ( String str : array List ) { integers . add ( Integer . value Of ( str ) ) ; } return integers ; }
@ Override public void unwrap SS Lv 2 ( byte [ ] bytes ) { unexpected Message ( ) ; }
public static String build Selector From Class ( String class Value ) { String Builder strb = new String Builder ( ) ; strb . append ( CLASS SELECTOR PREFIX ) ; strb . append ( class Value ) ; return strb . to String ( ) ; }
public void ensure Capacity ( int minimum Capacity ) { if ( minimum Capacity > value . length ) { int our Min = value . length * NUM + NUM ; enlarge Buffer ( Math . max ( our Min , minimum Capacity ) ) ; } }
public String pool Footer Statements ( ) { String Builder sb = new String Builder ( ) ; for ( String footer Statement : footer Statements ) { sb . append ( STRING ) ; sb . append ( footer Statement ) ; sb . append ( STRING ) ; } footer Statements . clear ( ) ; return sb . to String ( ) ; }
private void handle Node Queue ( Serial Message incoming Message ) { if ( current Stage == Z Wave Node Init Stage . DONE ) { return ; } logger . debug ( STRING , node . get Node Id ( ) , msg Queue . size ( ) ) ; if ( msg Queue . contains ( incoming Message ) ) { msg Queue . remove ( incoming Message ) ; logger . debug ( STRING , node . get Node Id ( ) , msg Queue . size ( ) ) ; free To Send = BOOL ; advance Node Stage ( incoming Message . get Message Class ( ) ) ; } else if ( msg Queue . is Empty ( ) && current Stage == Z Wave Node Init Stage . SECURITY REPORT ) { logger . debug ( STRING , node . get Node Id ( ) ) ; advance Node Stage ( incoming Message . get Message Class ( ) ) ; } }
public static Predicate < String > matches ( final String regexp ) { Objects . require Non Null ( regexp , STRING ) ; return null ; }
public boolean has Set ( String name ) { return m map . contains Key ( name ) ; }
public void or ( Criteria criteria ) { ored Criteria . add ( criteria ) ; }
public void clear Parsers ( ) { timer . stop ( ) ; clear Parser Notice Highlights ( ) ; parsers . clear ( ) ; text Area . fire Parser Notices Change ( ) ; }
protected Property Definition ( Abstract Managed Object Definition < ? , ? > d , Class < T > the Class , String property Name , Enum Set < Property Option > options , Administrator Action admin Action , Default Behavior Provider < T > default Behavior ) { Reject . if Null ( d , the Class , property Name , options , admin Action , default Behavior ) ; this . definition = d ; this . the Class = the Class ; this . property Name = property Name ; this . options = Enum Set . copy Of ( options ) ; this . admin Action = admin Action ; this . default Behavior = default Behavior ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
private static I Multi Point [ ] random Points ( int n , int d , int scale ) { I Multi Point points [ ] = new I Multi Point [ n ] ; for ( int i = NUM ; i < n ; i ++ ) { String Builder sb = new String Builder ( ) ; for ( int j = NUM ; j < d ; j ++ ) { sb . append ( r Gen . next Double ( ) * scale ) ; if ( j < d - NUM ) { sb . append ( STRING ) ; } } points [ i ] = new Hyperpoint ( sb . to String ( ) ) ; } return points ; }
public Date Time Parse Exception ( String message , Char Sequence parsed Data , int error Index , Throwable cause ) { super ( message , cause ) ; this . parsed String = parsed Data . to String ( ) ; this . error Index = error Index ; }
public Configure Xml Attribute Count Dialog NB ( Xml Attribute Count xml Attribute Count ) { this . xml Attribute Count = xml Attribute Count ; init Components ( ) ; final Iterate Model number Of Tags Iterator = xml Attribute Count . get Number Of Attributes Iterator ( ) ; configure Iterate Model NB 2 . set Start At ( String . value Of ( number Of Tags Iterator . get Start At ( ) ) ) ; configure Iterate Model NB 2 . set Stop At ( String . value Of ( number Of Tags Iterator . get Stop At ( ) ) ) ; configure Iterate Model NB 2 . set Increment ( String . value Of ( number Of Tags Iterator . get Increment ( ) ) ) ; configure Iterate Model NB 2 . set Iterate Strategie ( number Of Tags Iterator . get Iterate Strategie ( ) ) ; List < String > names = Arrays . as List ( xml Attribute Count . get Names ( ) ) ; configure String List NB 1 . set String List ( names ) ; }
public static void check Argument ( boolean expression , @ Nullable Object error Message ) { if ( ! expression ) { throw new Illegal Argument Exception ( String . value Of ( error Message ) ) ; } }
public void on Menu Dismissed ( ) { m Reload Menu Item = null ; }
public static Thread consume Process Output Stream ( Process self , Output Stream output ) { Thread thread = new Thread ( new Byte Dumper ( self . get Input Stream ( ) , output ) ) ; thread . start ( ) ; return thread ; }
public static Angle great Circle Azimuth ( Lat Lon p1 , Lat Lon p2 ) { if ( ( p1 == null ) || ( p2 == null ) ) { throw new Illegal Argument Exception ( STRING ) ; } double lat 1 = p1 . get Latitude ( ) . radians ; double lon 1 = p1 . get Longitude ( ) . radians ; double lat 2 = p2 . get Latitude ( ) . radians ; double lon 2 = p2 . get Longitude ( ) . radians ; if ( lat 1 == lat 2 && lon 1 == lon 2 ) return Angle . ZERO ; if ( lon 1 == lon 2 ) return lat 1 > lat 2 ? Angle . POS 180 : Angle . ZERO ; double y = Math . cos ( lat 2 ) * Math . sin ( lon 2 - lon 1 ) ; double x = Math . cos ( lat 1 ) * Math . sin ( lat 2 ) - Math . sin ( lat 1 ) * Math . cos ( lat 2 ) * Math . cos ( lon 2 - lon 1 ) ; double azimuth Radians = Math . atan 2 ( y , x ) ; return Double . is Na N ( azimuth Radians ) ? Angle . ZERO : Angle . from Radians ( azimuth Radians ) ; }
public void delete ( ) throws IO Exception { close ( ) ; Util . delete Contents ( directory ) ; }
public void add All Tags Of ( Host h ) { List < Tag > tags = h . get Tags ( ) ; if ( tags . is Empty ( ) ) return ; if ( m Tag List == null ) { m Tag List = new Array List < Tag > ( tags . size ( ) ) ; } m Tag List . add All ( tags ) ; }
public static boolean is Numbers With Punctuation ( String token ) { boolean has Digit = BOOL ; int len = token . length ( ) ; for ( int i = NUM ; i < len ; ++ i ) { char c = token . char At ( i ) ; has Digit = has Digit || Character . is Digit ( c ) ; if ( ! ( Character . is Digit ( c ) || Characters . is Punctuation ( c ) ) ) { return BOOL ; } } return has Digit ; }
private boolean is Paint Line Seperators ( J Component c ) { boolean paint Lines = c instanceof J Text Area ; String global Override = System . get Property ( STRING ) ; if ( global Override != null && global Override . length ( ) > NUM ) { paint Lines = Boolean . value Of ( global Override ) ; } Boolean override Property = ( Boolean ) c . get Client Property ( STRING ) ; if ( override Property != null ) { paint Lines = override Property ; } return paint Lines ; }
public static Db open ( Data Source ds ) { try { return new Db ( ds . get Connection ( ) ) ; } catch ( SQL Exception e ) { throw convert ( e ) ; } }
@ Override public void basic Put Part 3 ( Entry Event Impl event , Region Entry entry , boolean is Initialized , long last Modified , boolean invoke Callbacks , boolean if New , boolean if Old , Object expected Old Value , boolean require Old Value ) { distribute Update ( event , last Modified , BOOL , BOOL , null , BOOL ) ; super . basic Put Part 3 ( event , entry , is Initialized , last Modified , invoke Callbacks , if New , if Old , expected Old Value , require Old Value ) ; }
public Language Range ( String range ) { this . range = range . split ( STRING ) ; full = range ; }
protected void remove Container ( ) throws Throwable { if ( container Id == null ) { return ; } send Delete Container Request ( ) ; wait For Property Value ( provisioning Task Link , Mock Task State . class , STRING , Task State . Task Stage . FINISHED ) ; if ( ! is Mock Target ( ) ) { Thread . sleep ( NUM ) ; } verify Container Does Not Exist ( container Id ) ; }
public int size ( ) { return list . size ( ) ; }
public Transformer Handler new Transformer Handler ( Templates templates ) throws Transformer Configuration Exception { try { Transformer Impl transformer = ( Transformer Impl ) templates . new Transformer ( ) ; transformer . set URI Resolver ( m uri Resolver ) ; Transformer Handler th = ( Transformer Handler ) transformer . get Input Content Handler ( BOOL ) ; return th ; } catch ( Transformer Configuration Exception ex ) { if ( m error Listener != null ) { try { m error Listener . fatal Error ( ex ) ; return null ; } catch ( Transformer Configuration Exception ex 1 ) { throw ex 1 ; } catch ( Transformer Exception ex 1 ) { throw new Transformer Configuration Exception ( ex 1 ) ; } } throw ex ; } }
public void add Field ( Field Ref fref ) { m Field Refs . add ( fref ) ; }
public String render ( Value Expr the Expr ) throws Exception { reset ( ) ; the Expr . visit ( this ) ; return m Buffer . to String ( ) ; }
public void add ( final Vector 2 D [ ] b Loop ) throws Math Illegal Argument Exception { add ( new Nested Loops ( b Loop , tolerance ) ) ; }
@ Not Null public static < T > List < T > as List ( @ Nullable final Collection < ? > expression , @ Not Null final Class < T > element Class ) { if ( ( expression == null ) || expression . is Empty ( ) ) { return Collections . empty List ( ) ; } final List < T > result = new Array List < T > ( ) ; for ( final Object element : expression ) { final T to Add = as ( element , element Class ) ; if ( to Add != null ) { result . add ( to Add ) ; } } return result ; }
public static String read Ascii Line ( Input Stream in ) throws IO Exception { String Builder result = new String Builder ( NUM ) ; while ( BOOL ) { int c = in . read ( ) ; if ( c == - NUM ) { throw new EOF Exception ( ) ; } else if ( c == STRING ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > NUM && result . char At ( length - NUM ) == STRING ) { result . set Length ( length - NUM ) ; } return result . to String ( ) ; }
private void start New Transition ( ) { if ( ! has Bounds ( ) ) { return ; } m Current Trans = m Trans Gen . generate Next Transition ( m Drawable Rect , m Viewport Rect ) ; m Elapsed Time = NUM ; m Last Frame Time = System . current Time Millis ( ) ; fire Transition Start ( m Current Trans ) ; }
@ Override protected void make Finished ( ) { byte [ ] verify data ; if ( server Hello . server version [ NUM ] == NUM ) { verify data = new byte [ NUM ] ; computer Verify Data TLS ( STRING , verify data ) ; } else { verify data = new byte [ NUM ] ; computer Verify Data SS Lv 3 ( SS Lv 3 Constants . client , verify data ) ; } client Finished = new Finished ( verify data ) ; send ( client Finished ) ; if ( is Resuming ) { session . last Accessed Time = System . current Time Millis ( ) ; status = FINISHED ; } else { if ( server Hello . server version [ NUM ] == NUM ) { computer Reference Verify Data TLS ( STRING ) ; } else { computer Reference Verify Data SS Lv 3 ( SS Lv 3 Constants . server ) ; } status = NEED UNWRAP ; } }
public static File remove Extension ( File file ) { String absolute Path = file . get Absolute Path ( ) ; if ( absolute Path . contains ( STRING ) ) { return new File ( absolute Path . substring ( NUM , absolute Path . last Index Of ( STRING ) ) ) ; } else { return file ; } }
public void update ( ) { if ( bg Is Opaque ) { int w = Math . max ( get Size ( ) . width , min Width ) ; int h = Math . max ( get Size ( ) . height , min Height ) ; off Scr = create Image ( w , h ) ; if ( off Scr == null ) return ; Graphics g = off Scr . get Graphics ( ) ; draw Into ( g ) ; repaint ( ) ; g . dispose ( ) ; } else { repaint ( ) ; } }
public static final int read Int ( Input Stream is ) throws IO Exception { return ( ( ( NUM & is . read ( ) ) << NUM ) | ( NUM & is . read ( ) ) ) ; }
private void save Dynamic Actions ( Faces Context context , State Context state Context , Map < String , Object > state Map ) { if ( LOGGER . is Loggable ( Level . FINEST ) ) { LOGGER . finest ( STRING ) ; } List < Component Struct > actions = state Context . get Dynamic Actions ( ) ; Hash Map < String , UI Component > component Map = state Context . get Dynamic Components ( ) ; if ( actions != null ) { List < Object > saved Actions = new Array List < > ( actions . size ( ) ) ; for ( Component Struct action : actions ) { UI Component component = component Map . get ( action . client Id ) ; if ( component == null && context . is Project Stage ( Project Stage . Development ) ) { LOGGER . log ( Level . WARNING , STRING , action . client Id ) ; } if ( component != null ) { saved Actions . add ( action . save State ( context ) ) ; } } state Map . put ( DYNAMIC ACTIONS , saved Actions ) ; } }
private Instance generate Example ( Instances format , Random random G , Subspace Cluster Definition cl , String c Name ) { boolean make Integer = cl . is Integer ( ) ; int num = - NUM ; Instance example = null ; int num Atts = m Num Attributes ; if ( get Class Flag ( ) ) { num Atts ++ ; } example = new Dense Instance ( num Atts ) ; example . set Dataset ( format ) ; boolean [ ] attributes = cl . get Attributes ( ) ; double [ ] min Value = cl . get Min Value ( ) ; double [ ] max Value = cl . get Max Value ( ) ; double value ; int cluster I = - NUM ; for ( int i = NUM ; i < m Num Attributes ; i ++ ) { if ( attributes [ i ] ) { cluster I ++ ; num ++ ; if ( is Boolean ( i ) || is Nominal ( i ) ) { if ( min Value [ cluster I ] == max Value [ cluster I ] ) { value = min Value [ cluster I ] ; } else { int num Values = ( int ) ( max Value [ cluster I ] - min Value [ cluster I ] + NUM ) ; value = random G . next Int ( num Values ) ; value += min Value [ cluster I ] ; } } else { value = random G . next Double ( ) * ( max Value [ num ] - min Value [ num ] ) + min Value [ num ] ; if ( make Integer ) { value = Math . round ( value ) ; } } example . set Value ( i , value ) ; } else { example . set Missing ( i ) ; } } if ( get Class Flag ( ) ) { example . set Class Value ( c Name ) ; } return example ; }
@ Override public long skip ( long n ) { if ( n < NUM ) { throw new Illegal Argument Exception ( STRING + n ) ; } if ( idx >= char Sequence . length ( ) ) { return - NUM ; } int dest = ( int ) Math . min ( char Sequence . length ( ) , idx + n ) ; int count = dest - idx ; idx = dest ; return count ; }
@ Override public void clear ( ) { if ( element Count > NUM ) { element Count = NUM ; Arrays . fill ( element Data , null ) ; mod Count ++ ; while ( reference Queue . poll ( ) != null ) { } } }
public Default Console Panel ( ) { set Layout ( new Border Layout ( NUM , NUM ) ) ; text Pane = new J Text Area ( ) ; text Pane . set Rows ( NUM ) ; text Pane . set Editable ( BOOL ) ; J Scroll Pane jp = new J Scroll Pane ( text Pane ) ; add ( jp , Border Layout . CENTER ) ; }
public void push ( ) { level . add ( null ) ; cloned = BOOL ; }
private static void load Plugins From Class Loader ( Class Loader class Loader ) { Service Loader < GDS Factory Plugin > plugin Loader = Service Loader . load ( GDS Factory Plugin . class , class Loader ) ; for ( GDS Factory Plugin plugin : plugin Loader ) { register Plugin ( plugin ) ; } }
private boolean check Touch Slop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL ; } final boolean check Horizontal = m Callback . get View Horizontal Drag Range ( child ) > NUM ; final boolean check Vertical = m Callback . get View Vertical Drag Range ( child ) > NUM ; if ( check Horizontal && check Vertical ) { return dx * dx + dy * dy > m Touch Slop * m Touch Slop ; } else if ( check Horizontal ) { return Math . abs ( dx ) > m Touch Slop ; } else if ( check Vertical ) { return Math . abs ( dy ) > m Touch Slop ; } return BOOL ; }
public String redo ( ) { if ( ! can Redo ( ) ) { return STRING ; } m n Current Edit Action ++ ; Undo Action undo Action = m undo Stack . get ( m n Current Edit Action ) ; m b Needs Undo Action = BOOL ; undo Action . redo ( ) ; m b Needs Undo Action = BOOL ; return undo Action . get Redo Msg ( ) ; }
private float interpolate ( ) { long curr Time = System . current Time Millis ( ) ; float elapsed = ( curr Time - start Time ) / ZOOM TIME ; elapsed = Math . min ( NUM , elapsed ) ; return interpolator . get Interpolation ( elapsed ) ; }
@ Override public Writer append ( Char Sequence value ) { builder . append ( value ) ; return this ; }
@ Override public Inet Socket Address ip Local ( ) { Socket Channel s = channel ; if ( s != null ) { try { return ( Inet Socket Address ) s . get Local Address ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } } else { return null ; } }
@ Nonnull private static Node Disk find Node Disk ( String disk Id , List < Node Disk > node Disks , String node Name ) throws IO Exception { Node Disk selected = null ; for ( Node Disk node Disk : node Disks ) { if ( disk Id . equals ( node Disk . get Disk Ref Id ( ) ) ) { selected = node Disk ; break ; } } if ( selected == null ) { String message = format ( STRING , node Name , disk Id ) ; throw new Abort Exception ( message ) ; } if ( selected . get Node Mount Point ( ) == null ) { String message = format ( STRING , node Name , disk Id ) ; throw new Abort Exception ( message ) ; } return selected ; }
private int strip Multipart Headers ( byte [ ] b , int offset ) { int i = NUM ; for ( i = offset ; i < b . length ; i ++ ) { if ( b [ i ] == STRING && b [ ++ i ] == STRING && b [ ++ i ] == STRING && b [ ++ i ] == STRING ) break ; } return i + NUM ; }
void seek ( int position ) throws IO Exception { m Dex File . seek ( position ) ; }
@ Override public List < Column > columns ( ) { return column List ; }
public static void write Float ( Data Output Stream dos , boolean is Big Endian , float val ) throws IO Exception { if ( ! is Big Endian ) { write Little Endian Float ( dos , val ) ; } else { dos . write Float ( val ) ; } }
public void test Flip Bit Positive Inside 1 ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = NUM ; int number = NUM ; byte r Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , - NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . flip Bit ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public static void main ( String [ ] args ) { Log . print Line ( STRING ) ; try { int num user = NUM ; Calendar calendar = Calendar . get Instance ( ) ; boolean trace flag = BOOL ; Cloud Sim . init ( num user , calendar , trace flag ) ; @ Suppress Warnings ( STRING ) Datacenter datacenter 0 = create Datacenter ( STRING ) ; Datacenter Broker broker = create Broker ( ) ; int broker Id = broker . get Id ( ) ; vmlist = new Array List < Vm > ( ) ; int vmid = NUM ; int mips = NUM ; long size = NUM ; int ram = NUM ; long bw = NUM ; int pes Number = NUM ; String vmm = STRING ; Vm vm 1 = new Vm ( vmid , broker Id , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; vmid ++ ; Vm vm 2 = new Vm ( vmid , broker Id , mips * NUM , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; vmlist . add ( vm 1 ) ; vmlist . add ( vm 2 ) ; broker . submit Vm List ( vmlist ) ; cloudlet List = new Array List < Cloudlet > ( ) ; int id = NUM ; long length = NUM ; long file Size = NUM ; long output Size = NUM ; Utilization Model utilization Model = new Utilization Model Full ( ) ; Cloudlet cloudlet 1 = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 1 . set User Id ( broker Id ) ; id ++ ; Cloudlet cloudlet 2 = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 2 . set User Id ( broker Id ) ; cloudlet List . add ( cloudlet 1 ) ; cloudlet List . add ( cloudlet 2 ) ; broker . submit Cloudlet List ( cloudlet List ) ; broker . bind Cloudlet To Vm ( cloudlet 1 . get Cloudlet Id ( ) , vm 1 . get Id ( ) ) ; broker . bind Cloudlet To Vm ( cloudlet 2 . get Cloudlet Id ( ) , vm 2 . get Id ( ) ) ; Cloud Sim . start Simulation ( ) ; List < Cloudlet > new List = broker . get Cloudlet Received List ( ) ; Cloud Sim . stop Simulation ( ) ; print Cloudlet List ( new List ) ; Log . print Line ( STRING ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; Log . print Line ( STRING ) ; } }
public static Instruction osr Helper ( Instruction barrier , Generation Context gc ) { Instruction inst = Osr Point . create ( YIELDPOINT OSR , null , NUM ) ; gc . save OSR Barrier For Inst ( barrier , inst ) ; return inst ; }
protected void initialize State ( S current ) { Initialization Utils . initialize ( current ) ; if ( current . document Expiration Time Micros <= NUM ) { current . document Expiration Time Micros = Service Utils . compute Expiration Time ( Service Utils . DEFAULT DOC EXPIRATION TIME MICROS ) ; } }
@ Suppress Warnings ( STRING ) public Input Stream fetch Volume Stats ( final Argument argument , final Map < String , Object > key Map , int index ) throws VNX File Plugin Exception { logger . info ( STRING ) ; Input Stream i Stream = null ; List < Query Stats > stat List = new Array List < Query Stats > ( ) ; try { Set < String > movers = ( Set < String > ) key Map . get ( VNX File Constants . MOVERLIST ) ; if ( null != movers && ! movers . is Empty ( ) ) { for ( String mover ID : movers ) { Query Stats query Stats = new Query Stats ( ) ; Volume Stats Set Query Params params = new Volume Stats Set Query Params ( ) ; params . set Stats Set ( Volume Stats Set Type . ALL ) ; params . set Mover ( mover ID ) ; query Stats . set Volume Stats ( params ) ; stat List . add ( query Stats ) ; } i Stream = vnx File Input Request Builder . get Multi Request Query Stats Packet ( stat List ) ; } else { logger . error ( STRING ) ; } } catch ( JAXB Exception jaxb Exception ) { throw new VNX File Plugin Exception ( STRING , jaxb Exception . get Cause ( ) ) ; } return i Stream ; }
private static boolean is Directory ( URL url ) { String file = url . get File ( ) ; return ( file . length ( ) > NUM && file . char At ( file . length ( ) - NUM ) == STRING ) ; }
@ Override public final String read UTF ( ) throws IO Exception { return dis . read UTF ( ) ; }
@ Nullable public static Network Parameters from ID ( String id ) { if ( id . equals ( ID MAINNET ) ) { return Main Net Params . get ( ) ; } else if ( id . equals ( ID TESTNET ) ) { return Test Net 3 Params . get ( ) ; } else if ( id . equals ( ID UNITTESTNET ) ) { return Unit Test Params . get ( ) ; } else { return null ; } }
final synchronized void release Socket ( ) { running = BOOL ; sender . interrupt ( ) ; outbound Messages . clear ( ) ; if ( socket != null ) { socket . close ( ) ; socket = null ; } maximum Transmission Unit = NUM ; }
public boolean add Part ( Pdu Part part ) { if ( null == part ) { throw new Null Pointer Exception ( ) ; } put Part To Maps ( part ) ; return m Parts . add ( part ) ; }
public String code Owner ( List < Code Owner > code Owners ) { long current Unix = System . current Time Millis ( ) / NUM ; double best = NUM ; String owner = STRING ; for ( Code Owner code Owner : code Owners ) { double age = ( current Unix - code Owner . get Most Recent Unix Commit Timestamp ( ) ) / NUM / NUM ; double calc = code Owner . get No Lines ( ) / Math . pow ( ( age ) , NUM ) ; if ( calc > best ) { best = calc ; owner = code Owner . get Name ( ) ; } } return owner ; }
private Array List < Cell Record > process Neighbors ( final Cell Record serving , final Position Record cell Pos ) { final Array List < Cell Record > neighbors = new Array List < > ( ) ; final Array List < Neighboring Cell Info > neighboring Cell Infos = ( Array List < Neighboring Cell Info > ) m Telephony Manager . get Neighboring Cell Info ( ) ; if ( serving == null ) { Log . e ( TAG , STRING ) ; return neighbors ; } if ( neighboring Cell Infos == null ) { Log . i ( TAG , STRING ) ; return neighbors ; } for ( final Neighboring Cell Info ci : neighboring Cell Infos ) { final boolean skip = ! is Valid Neigbor ( ci ) ; if ( ! skip ) { final Cell Record neighbor = new Cell Record ( m Session Id ) ; neighbor . set Open Bmap Timestamp ( cell Pos . get Open Bmap Timestamp ( ) ) ; neighbor . set Begin Position ( cell Pos ) ; neighbor . set End Position ( cell Pos ) ; neighbor . set Is Serving ( BOOL ) ; neighbor . set Is Neighbor ( BOOL ) ; neighbor . set Mnc ( serving . get Mnc ( ) ) ; neighbor . set Mcc ( serving . get Mcc ( ) ) ; neighbor . set Operator ( serving . get Operator ( ) ) ; neighbor . set Operator Name ( serving . get Operator Name ( ) ) ; final int network Type = ci . get Network Type ( ) ; neighbor . set Network Type ( network Type ) ; if ( network Type == Telephony Manager . NETWORK TYPE GPRS || network Type == Telephony Manager . NETWORK TYPE EDGE ) { neighbor . set Is Cdma ( BOOL ) ; neighbor . set Logical Cell Id ( ci . get Cid ( ) ) ; neighbor . set Area ( ci . get Lac ( ) ) ; neighbor . set Strengthd Bm ( - NUM + NUM * ci . get Rssi ( ) ) ; neighbor . set Strength Asu ( ci . get Rssi ( ) ) ; } else if ( network Type == Telephony Manager . NETWORK TYPE UMTS || network Type == Telephony Manager . NETWORK TYPE HSDPA || network Type == Telephony Manager . NETWORK TYPE HSUPA || network Type == Telephony Manager . NETWORK TYPE HSPA ) { neighbor . set Is Cdma ( BOOL ) ; neighbor . set Psc ( ci . get Psc ( ) ) ; neighbor . set Strengthd Bm ( ci . get Rssi ( ) ) ; final int asu = ( int ) Math . round ( ( ci . get Rssi ( ) + NUM ) / NUM ) ; neighbor . set Strength Asu ( asu ) ; } else if ( network Type == Telephony Manager . NETWORK TYPE CDMA ) { neighbor . set Is Cdma ( BOOL ) ; } neighbors . add ( neighbor ) ; } } return neighbors ; }
public Map read ( SSO Token token , String obj Name ) throws SMS Exception , SSO Exception { if ( obj Name == null || obj Name . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } String obj Key = obj Name . to Lower Case ( ) ; Map attr Map = null ; mRW Lock . read Request ( ) ; try { String filepath = m Name Map . get Property ( obj Key ) ; if ( filepath == null ) { if ( m Debug . message Enabled ( ) ) { m Debug . message ( STRING + obj Name + STRING ) ; } } else { File filehandle = new File ( filepath ) ; Properties props = null ; try { props = load Properties ( filehandle , obj Name ) ; } catch ( Service Not Found Exception e ) { } if ( props != null ) { attr Map = new Case Insensitive Hash Map ( ) ; Enumeration keys = props . property Names ( ) ; while ( keys . has More Elements ( ) ) { String key = ( String ) keys . next Element ( ) ; String vals = props . get Property ( key ) ; if ( ( vals != null ) && ( vals . length ( ) > NUM ) ) { attr Map . put ( key , to Val Set ( key , vals ) ) ; } } } } } finally { mRW Lock . read Done ( ) ; } return attr Map ; }
public static double parse Double ( String s ) { s = s . trim ( ) ; int length = s . length ( ) ; if ( length == NUM ) { throw invalid Real ( s , BOOL ) ; } char last = s . char At ( length - NUM ) ; if ( last == STRING || last == STRING ) { return parse Name ( s , BOOL ) ; } String Exponent Pair info = initial Parse ( s , length , BOOL ) ; if ( info . infinity || info . zero ) { return info . special Value ( ) ; } double result = parse Dbl Impl ( info . s , ( int ) info . e ) ; if ( Double . double To Long Bits ( result ) == NUM ) { throw invalid Real ( s , BOOL ) ; } return info . negative ? - result : result ; }
public byte read Byte ( ) throws IO Exception { byte v = data Input . read Byte ( ) ; offset += NUM ; available -= NUM ; return v ; }
public static I Multi Point [ ] random Points ( int n , int d ) { I Multi Point points [ ] = new I Multi Point [ n ] ; for ( int i = NUM ; i < n ; i ++ ) { String Builder sb = new String Builder ( ) ; for ( int j = NUM ; j < d ; j ++ ) { sb . append ( r Gen . next Double ( ) ) ; if ( j < d - NUM ) { sb . append ( STRING ) ; } } points [ i ] = new Hyperpoint ( sb . to String ( ) ) ; } return points ; }
private String verify Restore Code ( String restore Code , String code ) { if ( code == null ) { return STRING ; } if ( restore Code == null ) { return STRING ; } boolean valid Code = password Manager . matches ( code , restore Code ) ; return valid Code ? null : STRING + code + STRING + restore Code + STRING ; }
public static void append Padded Integer ( String Buffer buf , long value , int size ) { int int Value = ( int ) value ; if ( int Value == value ) { append Padded Integer ( buf , int Value , size ) ; } else if ( size <= NUM ) { buf . append ( Long . to String ( value ) ) ; } else { if ( value < NUM ) { buf . append ( STRING ) ; if ( value != Long . MIN VALUE ) { value = - value ; } else { for ( ; size > NUM ; size -- ) { buf . append ( STRING ) ; } buf . append ( STRING ) ; return ; } } int digits = ( int ) ( Math . log ( value ) / LOG 10 ) + NUM ; for ( ; size > digits ; size -- ) { buf . append ( STRING ) ; } buf . append ( Long . to String ( value ) ) ; } }
@ Override public void flush ( ) { if ( ! queue . is Empty ( ) ) { List < Alert Stream Event > events = new Array List < > ( ) ; queue . drain To ( events ) ; events . for Each ( null ) ; LOG . info ( STRING , events . size ( ) ) ; } last Flush Time . set ( System . current Time Millis ( ) ) ; }
@ Override public void add Undo Point ( ) { File temp File ; Object Output Stream oos ; if ( ! is Undo Enabled ( ) ) { return ; } if ( get Instances ( ) != null ) { try { temp File = File . create Temp File ( STRING , null ) ; temp File . delete On Exit ( ) ; oos = new Object Output Stream ( new Buffered Output Stream ( new File Output Stream ( temp File ) ) ) ; oos . write Object ( get Instances ( ) ) ; oos . flush ( ) ; oos . close ( ) ; m Undo List . add ( temp File ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } }
public final void add Child Node ( Row Regex Expr Node child Node ) { child Nodes . add ( child Node ) ; }
private List < String > make List ( final String ... strings ) { final List < String > result = new Array List < > ( ) ; for ( String string : strings ) { result . add ( string ) ; } return result ; }
protected boolean is Level Enabled ( int log Level ) { return ( log Level >= current Log Level ) ; }
public int number Of Shards With State ( Shard Routing State ... states ) { int count = NUM ; for ( Shard Routing shard Entry : this ) { for ( Shard Routing State state : states ) { if ( shard Entry . state ( ) == state ) { count ++ ; } } } return count ; }
@ Override public void notify Commit ( final long commit Time ) { lock . lock ( ) ; try { update Release Time For Bare Commit ( commit Time ) ; } finally { lock . unlock ( ) ; } }
public static int show Yes No Cancel Question ( final Component parent , final String msg ) { return J Option Pane . show Confirm Dialog ( is Iconified ( parent ) ? null : parent , msg , System . get Property ( DEFAULT WINDOW TITLE PROPERTY ) , J Option Pane . YES NO CANCEL OPTION , J Option Pane . QUESTION MESSAGE ) ; }
public static String quantityplnoun Creature ( final int quantity , final String noun ) { if ( noun . equals ( STRING ) ) { final String end = plnoun Creature ( quantity , noun ) ; return Integer . to String ( quantity ) + STRING + end ; } return quantityplnoun ( quantity , noun ) ; }
static int copy Bytes ( Output Stream os , Input Stream is , byte [ ] io Buffer , int max Size ) throws IO Exception { int total Size = NUM ; while ( total Size < max Size ) { int rc = is . read ( io Buffer , NUM , Math . min ( max Size - total Size , io Buffer . length ) ) ; if ( rc == - NUM ) { break ; } os . write ( io Buffer , NUM , rc ) ; total Size += rc ; } return total Size ; }
public int do Final ( byte [ ] out , int out Off ) throws Data Length Exception , Illegal State Exception , Invalid Cipher Text Exception { try { int result Len = NUM ; if ( out Off + buf Off > out . length ) { throw new Output Length Exception ( STRING ) ; } if ( buf Off != NUM ) { if ( ! partial Block Okay ) { throw new Data Length Exception ( STRING ) ; } cipher . process Block ( buf , NUM , buf , NUM ) ; result Len = buf Off ; buf Off = NUM ; System . arraycopy ( buf , NUM , out , out Off , result Len ) ; } return result Len ; } finally { reset ( ) ; } }
void compose Message ( final Mail mail , final String text Content , final String html Content , final Map < String , byte [ ] > attachments , final List < String > mail Template Chain , final String shop Code , final String locale , final String template Name ) throws Messaging Exception , Class Not Found Exception , IO Exception { if ( text Content == null || html Content == null ) { if ( text Content != null ) { mail . set Text Version ( text Content ) ; } if ( html Content != null ) { mail . set Html Version ( html Content ) ; inline Resources ( mail , html Content , mail Template Chain , shop Code , locale , template Name ) ; add Attachments ( mail , attachments ) ; } } else { mail . set Text Version ( text Content ) ; mail . set Html Version ( html Content ) ; inline Resources ( mail , html Content , mail Template Chain , shop Code , locale , template Name ) ; add Attachments ( mail , attachments ) ; } }
private void handle Launch Message Event ( Message Event message Event ) { Data Map data Map = Data Map . from Byte Array ( message Event . get Data ( ) ) ; boolean relaunch If Running = data Map . get Boolean ( KEY START ACTIVITY RELAUNCH , BOOL ) ; Data Map bundle Data = data Map . get Data Map ( KEY START ACTIVITY BUNDLE ) ; String activity Name = data Map . get String ( KEY START ACTIVITY NAME ) ; Bundle bundle = null ; if ( bundle Data != null ) { bundle = bundle Data . to Bundle ( ) ; } if ( activity Name == null ) { for ( Wear Consumer consumer : m Wear Consumers ) { consumer . on Wearable Application Launch Request Received ( bundle , relaunch If Running ) ; } } else { try { if ( ! Text Utils . is Empty ( activity Name ) ) { Class < ? > target Activity = Class . for Name ( activity Name ) ; Intent intent = new Intent ( m Context , target Activity ) ; intent . set Flags ( Intent . FLAG ACTIVITY NEW TASK ) ; if ( bundle != null ) { intent . put Extras ( bundle ) ; } if ( ! m App Foreground || relaunch If Running ) { m Context . start Activity ( intent ) ; } } else { Log . e ( TAG , STRING ) ; } } catch ( Class Not Found Exception e ) { Log . e ( TAG , STRING , e ) ; } } }
@ Override public void close ( ) throws IO Exception { closed = BOOL ; def . end ( ) ; in . close ( ) ; }
public static String escape Colon In String ( String str ) { if ( str != null ) { if ( str . index Of ( STRING ) >= NUM ) { str = str . replace All ( STRING , STRING ) ; } } return str ; }
protected void tear Down ( ) throws Exception { File file ; file = new File ( m Export Filename Data ) ; if ( file . exists ( ) ) file . delete ( ) ; m Export Filename Data = null ; super . tear Down ( ) ; }
private static SAX Parser Factory create SAX Parser Factory ( ) { try { SAX Parser Factory factory = SAX Parser Factory . new Instance ( ) ; try { SAX Parser Factory secure Factory = Secure Generic XML Factory . get SAX Parser Factory ( factory ) ; secure Factory . new SAX Parser ( ) ; factory = secure Factory ; } catch ( Parser Configuration Exception e ) { } factory . set Namespace Aware ( BOOL ) ; return factory ; } catch ( SAX Exception e ) { throw new Illegal State Exception ( STRING , e ) ; } }
private static void attempt Retry On Exception ( String log Prefix , Request < ? > request , Volley Error exception ) throws Volley Error { Retry Policy retry Policy = request . get Retry Policy ( ) ; int old Timeout = request . get Timeout Ms ( ) ; try { retry Policy . retry ( exception ) ; } catch ( Volley Error e ) { request . add Marker ( String . format ( STRING , log Prefix , old Timeout ) ) ; throw e ; } request . add Marker ( String . format ( STRING , log Prefix , old Timeout ) ) ; }
public static void save As XML ( NS Object root , File out ) throws IO Exception { File parent = out . get Parent File ( ) ; if ( ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new IO Exception ( STRING ) ; } File Output Stream fous = new File Output Stream ( out ) ; save As XML ( root , fous ) ; fous . close ( ) ; }
public static boolean contains Chroot ( String zk Host ) { return zk Host . contains ( STRING ) ; }
public final void lazy Set ( int new Value ) { unsafe . put Ordered Int ( this , value Offset , new Value ) ; }
public Feature ( String line , Map cp Str 2 Int , Map lb Str 2 Int , Map fmap ) { String Tokenizer str Tok = new String Tokenizer ( line , STRING ) ; int len = str Tok . count Tokens ( ) ; String str Id Str = str Tok . next Token ( ) ; int idx = Integer . parse Int ( str Tok . next Token ( ) ) ; float val = NUM ; double wgt = Double . parse Double ( str Tok . next Token ( ) ) ; String Tokenizer str Id Tok = new String Tokenizer ( str Id Str , STRING ) ; String prefix = str Id Tok . next Token ( ) ; if ( prefix . compare To Ignore Case ( STRING ) == NUM ) { Integer y Int = ( Integer ) lb Str 2 Int . get ( str Id Tok . next Token ( ) ) ; Integer yp Int = ( Integer ) lb Str 2 Int . get ( str Id Tok . next Token ( ) ) ; if ( y Int != null && yp Int != null ) { e Feature 1 Init ( y Int . int Value ( ) , yp Int . int Value ( ) ) ; } } else if ( prefix . compare To Ignore Case ( STRING ) == NUM ) { Integer y Int = ( Integer ) lb Str 2 Int . get ( str Id Tok . next Token ( ) ) ; Integer cp Int = ( Integer ) cp Str 2 Int . get ( str Id Tok . next Token ( ) ) ; if ( y Int != null && cp Int != null ) { s Feature 1 Init ( y Int . int Value ( ) , cp Int . int Value ( ) ) ; } } this . idx = idx ; this . val = val ; this . wgt = wgt ; str Id 2 Idx Add ( fmap ) ; }
public static int patch Fast ( Input Stream old Input Stream , Input Stream diff Input Stream , File new File ) throws IO Exception { if ( old Input Stream == null ) { return RETURN OLD FILE ERR ; } if ( new File == null ) { return RETURN NEW FILE ERR ; } if ( diff Input Stream == null ) { return RETURN DIFF FILE ERR ; } byte [ ] old Bytes = BS Util . input Stream To Byte ( old Input Stream ) ; byte [ ] diff Bytes = BS Util . input Stream To Byte ( diff Input Stream ) ; byte [ ] new Bytes = patch Fast ( old Bytes , old Bytes . length , diff Bytes , diff Bytes . length , NUM ) ; Output Stream new Output Stream = new File Output Stream ( new File ) ; try { new Output Stream . write ( new Bytes ) ; } finally { new Output Stream . close ( ) ; } return RETURN SUCCESS ; }
public static byte [ ] read Fully No Close ( Input Stream in ) throws IO Exception { Byte Array Output Stream bytes = new Byte Array Output Stream ( ) ; byte [ ] buffer = new byte [ NUM ] ; int count ; while ( ( count = in . read ( buffer ) ) != - NUM ) { bytes . write ( buffer , NUM , count ) ; } return bytes . to Byte Array ( ) ; }
public Content Storage ( Content Storage BO content Storage BO , List < Generic Package > generic Package List , List < Essence Container Data > essence Container Data List ) { this . content Storage BO = content Storage BO ; this . generic Package List = Collections . unmodifiable List ( generic Package List ) ; this . essence Container Data List = Collections . unmodifiable List ( essence Container Data List ) ; }
public static String decode ( byte [ ] utf 8 ) throws Character Coding Exception { return decode ( Byte Buffer . wrap ( utf 8 ) , BOOL ) ; }
public Scale IO Volume query Volume ( String vol Id ) throws Exception { Client Response response = get ( URI . create ( Scale IO Constants . get Volume URI ( vol Id ) ) ) ; return get Response Object ( Scale IO Volume . class , response ) ; }
public void remove Event Listener ( SIP Dialog Event Listener old Listener ) { event Listeners . remove ( old Listener ) ; }
protected static Object primitive Array Put ( Object self , int idx , Object new Value ) { Array . set ( self , normalise Index ( idx , Array . get Length ( self ) ) , new Value ) ; return new Value ; }
public void to Axis Angle ( Vector 4 f output ) { if ( get W ( ) > NUM ) { normalise ( ) ; } float angle = NUM * ( float ) Math . to Degrees ( Math . acos ( get W ( ) ) ) ; float x ; float y ; float z ; float s = ( float ) Math . sqrt ( NUM - get W ( ) * get W ( ) ) ; if ( s < NUM ) { x = points [ NUM ] ; y = points [ NUM ] ; z = points [ NUM ] ; } else { x = points [ NUM ] / s ; y = points [ NUM ] / s ; z = points [ NUM ] / s ; } output . points [ NUM ] = x ; output . points [ NUM ] = y ; output . points [ NUM ] = z ; output . points [ NUM ] = angle ; }
@ Override public synchronized void initialize ( ) { if ( ! m Root Directory . exists ( ) ) { if ( ! m Root Directory . mkdirs ( ) ) { Volley Log . e ( STRING , m Root Directory . get Absolute Path ( ) ) ; } return ; } File [ ] files = m Root Directory . list Files ( ) ; if ( files == null ) { return ; } for ( File file : files ) { File Input Stream fis = null ; try { fis = new File Input Stream ( file ) ; Cache Header entry = Cache Header . read Header ( fis ) ; entry . size = file . length ( ) ; put Entry ( entry . key , entry ) ; } catch ( IO Exception e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IO Exception ignored ) { } } } }
private Q Name Map < Binding Expression > process Binding Attributes ( Node node ) { Q Name Map < Binding Expression > attribute Bindings = null ; for ( Iterator < Q Name > i = node . get Attribute Names ( ) ; i != null && i . has Next ( ) ; ) { Q Name qname = i . next ( ) ; String value = ( String ) node . get Attribute Value ( qname ) ; Binding Expression be = text Parser . parse Binding Expression ( value , node . begin Line ) ; if ( be != null ) { if ( attribute Bindings == null ) { attribute Bindings = new Q Name Map < Binding Expression > ( ) ; } attribute Bindings . put ( qname , be ) ; i . remove ( ) ; } } return attribute Bindings ; }
public void load ( String file Name ) throws IO Exception { Buffered Reader bfr = new Buffered Reader ( new Input Stream Reader ( new File Input Stream ( file Name ) , STRING ) ) ; if ( b List == null ) b List = new Vector ( DEFAULT INCREMENT , DEFAULT INCREMENT ) ; String line = bfr . read Line ( ) ; if ( line . index Of ( STRING ) != - NUM ) { line = line . substring ( NUM ) ; String [ ] parts = new String [ NUM ] ; parts = line . split ( STRING , NUM ) ; from Dir = parts [ NUM ] ; from Ext = parts [ NUM ] ; } else if ( ! ( line . matches ( STRING ) ) ) add ( line ) ; while ( ( line = bfr . read Line ( ) ) != null ) { if ( ! ( line . matches ( STRING ) ) ) add ( line ) ; } }
private void verify Register Defs ( String where ) { Def Use . compute DU ( this ) ; for ( Register r = regpool . get First Symbolic Register ( ) ; r != null ; r = r . get Next ( ) ) { if ( r . is Physical ( ) ) continue ; if ( r . use List != null ) { if ( r . def List == null ) { print Instructions ( ) ; verror ( where , STRING + r + STRING ) ; } } } }
@ Suppress Warnings ( STRING ) public static Part Listing parse List Parts ( Input Stream response Body ) throws Response Parse Exception { try { Element root = get Xml Root Element ( response Body ) ; Part Listing part Listing = new Part Listing ( ) ; part Listing . set Bucket Name ( root . get Child Text ( STRING ) ) ; part Listing . set Key ( root . get Child Text ( STRING ) ) ; part Listing . set Upload Id ( root . get Child Text ( STRING ) ) ; part Listing . set Storage Class ( root . get Child Text ( STRING ) ) ; part Listing . set Max Parts ( Integer . value Of ( root . get Child Text ( STRING ) ) ) ; part Listing . set Truncated ( Boolean . value Of ( root . get Child Text ( STRING ) ) ) ; if ( root . get Child ( STRING ) != null ) { String part Number Marker = root . get Child Text ( STRING ) ; if ( ! is Null Or Empty ( part Number Marker ) ) { part Listing . set Part Number Marker ( Integer . value Of ( part Number Marker ) ) ; } } if ( root . get Child ( STRING ) != null ) { String next Part Number Marker = root . get Child Text ( STRING ) ; if ( ! is Null Or Empty ( next Part Number Marker ) ) { part Listing . set Next Part Number Marker ( Integer . value Of ( next Part Number Marker ) ) ; } } List < Element > part Elems = root . get Children ( STRING ) ; for ( Element elem : part Elems ) { Part Summary ps = new Part Summary ( ) ; ps . set Part Number ( Integer . value Of ( elem . get Child Text ( STRING ) ) ) ; ps . set Last Modified ( Date Util . parse Iso 8601 Date ( elem . get Child Text ( STRING ) ) ) ; ps . set E Tag ( trim Quotes ( elem . get Child Text ( STRING ) ) ) ; ps . set Size ( Integer . value Of ( elem . get Child Text ( STRING ) ) ) ; part Listing . add Part ( ps ) ; } return part Listing ; } catch ( Exception e ) { throw new Response Parse Exception ( e . get Message ( ) , e ) ; } }
private static void find Snap ( Collection < Constraint Widget > widgets , Constraint Widget widget , Snap Candidate candidate , boolean check Horizontal ) { Array List < Constraint Anchor > anchors Source = widget . get Anchors ( ) ; for ( Constraint Widget w : widgets ) { if ( w == widget ) { continue ; } Array List < Constraint Anchor > anchors Target = w . get Anchors ( ) ; for ( Constraint Anchor as : anchors Source ) { if ( check Horizontal && as . is Vertical Anchor ( ) ) { continue ; } else if ( ! check Horizontal && ! as . is Vertical Anchor ( ) ) { continue ; } for ( Constraint Anchor at : anchors Target ) { snap Check ( as , at , candidate , CONNECTION SLOPE ) ; } } } }
protected String pad String ( String s , int length , boolean left ) { String result ; int i ; result = s ; for ( i = s . length ( ) ; i < length ; i ++ ) { if ( left ) { result = STRING + result ; } else { result = result + STRING ; } } if ( ( length > NUM ) && ( result . length ( ) > length ) ) { result = result . substring ( NUM , length ) ; } return result ; }
public static < C extends Comparable < ? > > List < Range < C > > remove ( Range < C > self , Range < C > other ) { if ( other == null || ! self . is Connected ( other ) ) { return Collections . singleton List ( self ) ; } Range < C > share = self . intersection ( other ) ; if ( share . is Empty ( ) ) { return Collections . singleton List ( self ) ; } List < Range < C > > ret = Lists . new Array List ( ) ; if ( ! self . has Lower Bound ( ) ) { if ( share . has Lower Bound ( ) ) { if ( share . lower Bound Type ( ) == Bound Type . CLOSED ) { ret . add ( Range . less Than ( share . lower Endpoint ( ) ) ) ; } else { ret . add ( Range . at Most ( share . lower Endpoint ( ) ) ) ; } } } else { if ( self . lower Endpoint ( ) != share . lower Endpoint ( ) ) { if ( self . lower Bound Type ( ) == Bound Type . CLOSED ) { if ( share . lower Bound Type ( ) == Bound Type . CLOSED ) { ret . add ( Range . closed Open ( self . lower Endpoint ( ) , share . lower Endpoint ( ) ) ) ; } else { ret . add ( Range . closed ( self . lower Endpoint ( ) , share . lower Endpoint ( ) ) ) ; } } else { if ( share . lower Bound Type ( ) == Bound Type . CLOSED ) { ret . add ( Range . open ( self . lower Endpoint ( ) , share . lower Endpoint ( ) ) ) ; } else { ret . add ( Range . open Closed ( self . lower Endpoint ( ) , share . lower Endpoint ( ) ) ) ; } } } else { if ( self . lower Bound Type ( ) == Bound Type . CLOSED && share . lower Bound Type ( ) == Bound Type . OPEN ) { ret . add ( Range . closed ( self . lower Endpoint ( ) , share . lower Endpoint ( ) ) ) ; } } } if ( ! self . has Upper Bound ( ) ) { if ( share . has Upper Bound ( ) ) { if ( share . upper Bound Type ( ) == Bound Type . CLOSED ) { ret . add ( Range . greater Than ( share . upper Endpoint ( ) ) ) ; } else { ret . add ( Range . at Least ( share . upper Endpoint ( ) ) ) ; } } } else { if ( self . upper Endpoint ( ) != share . upper Endpoint ( ) ) { if ( self . upper Bound Type ( ) == Bound Type . CLOSED ) { if ( share . upper Bound Type ( ) == Bound Type . CLOSED ) { ret . add ( Range . open Closed ( share . upper Endpoint ( ) , self . upper Endpoint ( ) ) ) ; } else { ret . add ( Range . closed ( share . upper Endpoint ( ) , self . upper Endpoint ( ) ) ) ; } } else { if ( share . upper Bound Type ( ) == Bound Type . CLOSED ) { ret . add ( Range . open ( share . upper Endpoint ( ) , self . upper Endpoint ( ) ) ) ; } else { ret . add ( Range . closed Open ( share . upper Endpoint ( ) , self . upper Endpoint ( ) ) ) ; } } } else { if ( self . upper Bound Type ( ) == Bound Type . CLOSED && share . upper Bound Type ( ) == Bound Type . OPEN ) { ret . add ( Range . closed ( self . upper Endpoint ( ) , share . upper Endpoint ( ) ) ) ; } } } return ret ; }
void recompose Keys ( Key Declaration key Decl ) { m key Decls . add Element ( key Decl ) ; }
public < T > Json Array < T > create List Dto From Json ( Reader json , Class < T > dto Interface ) throws IO Exception { final Dto Provider < T > dto Provider = get Dto Provider ( dto Interface ) ; final List < Json Element > list ; try { list = gson . from Json ( json , list Type Cache . get ( Json Element . class ) ) ; } catch ( Json Syntax Exception e ) { final Throwable cause = e . get Cause ( ) ; if ( cause instanceof IO Exception ) { throw ( IO Exception ) cause ; } throw e ; } final List < T > result = new Array List < > ( list . size ( ) ) ; for ( Json Element e : list ) { result . add ( dto Provider . from Json ( e ) ) ; } return new Json Array Impl < > ( result ) ; }
private View fill From Top ( int next Top ) { m First Position = Math . min ( m First Position , - NUM ) ; m First Position = Math . min ( m First Position , m Item Count - NUM ) ; if ( m First Position < NUM ) { m First Position = NUM ; } return fill Down ( m First Position , next Top ) ; }
public void connection Open ( ) { lock . lock ( ) ; try { log . info ( STRING ) ; connection Open = BOOL ; } finally { lock . unlock ( ) ; } }
public static float rotate Y ( float pX , float pY , float cX , float cY , float angle In Degrees ) { double angle = Math . to Radians ( angle In Degrees ) ; return ( float ) ( Math . sin ( angle ) * ( pX - cX ) + Math . cos ( angle ) * ( pY - cY ) + cY ) ; }
public void list ( Print Stream out ) { properties . list ( out ) ; }
protected Layer Pane find Selected Pane ( ) { for ( Layer Pane pane : get Panes ( ) ) { if ( pane . is Selected ( ) ) { return pane ; } } return null ; }
private final void scale Noise Array ( final int sea Level ) { for ( int x = NUM ; x < X SECTIONS ; x ++ ) { for ( int z = NUM ; z < Z SECTIONS ; z ++ ) { for ( int y = NUM ; y < Y SECTIONS ; y ++ ) { this . raw Density [ x ] [ y ] [ z ] *= MAX ELEV ; this . raw Density [ x ] [ y ] [ z ] += sea Level ; } } } }
public Object [ ] to Array ( ) { Array List < E > al = new Array List < E > ( ) ; for ( Node < E > p = first ( ) ; p != null ; p = succ ( p ) ) { E item = p . item ; if ( item != null ) al . add ( item ) ; } return al . to Array ( ) ; }
public Microservices Runner ( int ... ports ) { configure Transport ( ports ) ; }
public static boolean delete Contents ( File directory ) { File [ ] files = directory . list Files ( ) ; boolean success = BOOL ; if ( files != null ) { for ( File file : files ) { success &= delete Recursively ( file ) ; } } return success ; }
private void handle Response ( Avs Response response ) { m Event Manager . post ( new Command Event ( Command Event . TYPE COMMAND SEARCHING , KEYWORD ALEXA ) ) ; if ( response != null ) { for ( int i = response . size ( ) - NUM ; i >= NUM ; i -- ) { if ( response . get ( i ) instanceof Avs Replace All Item || response . get ( i ) instanceof Avs Replace Enqueued Item ) { m Avs Queue . clear ( ) ; response . remove ( i ) ; } } Timber . i ( STRING , response . size ( ) ) ; m Avs Queue . add All ( response ) ; } check Queue ( ) ; }
void mergesort ( Vector a , Vector b , int l , int r , X Path Context support ) throws Transformer Exception { if ( ( r - l ) > NUM ) { int m = ( r + l ) / NUM ; mergesort ( a , b , l , m , support ) ; mergesort ( a , b , m + NUM , r , support ) ; int i , j , k ; for ( i = m ; i >= l ; i -- ) { if ( i >= b . size ( ) ) b . insert Element At ( a . element At ( i ) , i ) ; else b . set Element At ( a . element At ( i ) , i ) ; } i = l ; for ( j = ( m + NUM ) ; j <= r ; j ++ ) { if ( r + m + NUM - j >= b . size ( ) ) b . insert Element At ( a . element At ( j ) , r + m + NUM - j ) ; else b . set Element At ( a . element At ( j ) , r + m + NUM - j ) ; } j = r ; int comp Val ; for ( k = l ; k <= r ; k ++ ) { if ( i == j ) comp Val = - NUM ; else comp Val = compare ( ( Node Compare Elem ) b . element At ( i ) , ( Node Compare Elem ) b . element At ( j ) , NUM , support ) ; if ( comp Val < NUM ) { a . set Element At ( b . element At ( i ) , k ) ; i ++ ; } else if ( comp Val > NUM ) { a . set Element At ( b . element At ( j ) , k ) ; j -- ; } } } }
public static List < String > to List ( Char Sequence self ) { String s = self . to String ( ) ; int size = s . length ( ) ; List < String > answer = new Array List < String > ( size ) ; for ( int i = NUM ; i < size ; i ++ ) { answer . add ( s . substring ( i , i + NUM ) ) ; } return answer ; }
void append Array Generic Type ( String Builder sb , Type [ ] types ) { if ( types . length > NUM ) { append Generic Type ( sb , types [ NUM ] ) ; for ( int i = NUM ; i < types . length ; i ++ ) { sb . append ( STRING ) ; append Generic Type ( sb , types [ i ] ) ; } } }
public static int decode residual ( H264 Context h , Get Bit Context gb , short [ ] block base , int block offset , int n , int [ ] scantable base , int scantable offset , long [ ] qmul base , int qmul offset , int max coeff ) { final int [ ] coeff token table index = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int [ ] level = new int [ NUM ] ; int zeros left , coeff token , total coeff , i , trailing ones , run before ; if ( n >= H264 Context . CHROMA DC BLOCK INDEX ) { coeff token = gb . get vlc 2 ( chroma dc coeff token vlc . table base , chroma dc coeff token vlc . table offset , H264 Context . CHROMA DC COEFF TOKEN VLC BITS , NUM , STRING ) ; total coeff = coeff token > > NUM ; } else { if ( n == H264 Context . LUMA DC BLOCK INDEX ) { total coeff = pred non zero count ( h , NUM ) ; coeff token = gb . get vlc 2 ( coeff token vlc [ coeff token table index [ total coeff ] ] . table base , coeff token vlc [ coeff token table index [ total coeff ] ] . table offset , H264 Context . COEFF TOKEN VLC BITS , NUM , STRING ) ; total coeff = coeff token > > NUM ; } else { total coeff = pred non zero count ( h , n ) ; coeff token = gb . get vlc 2 ( coeff token vlc [ coeff token table index [ total coeff ] ] . table base , coeff token vlc [ coeff token table index [ total coeff ] ] . table offset , H264 Context . COEFF TOKEN VLC BITS , NUM , STRING ) ; total coeff = coeff token > > NUM ; } } h . non zero count cache [ H264 Context . scan 8 [ n ] ] = total coeff ; if ( total coeff == NUM ) return NUM ; if ( total coeff > max coeff ) { return - NUM ; } trailing ones = coeff token & NUM ; i = ( int ) gb . show bits ( NUM ) ; gb . skip bits ( trailing ones ) ; level [ NUM ] = NUM - ( ( i & NUM ) > > NUM ) ; level [ NUM ] = NUM - ( ( i & NUM ) ) ; level [ NUM ] = NUM - ( ( i & NUM ) << NUM ) ; if ( trailing ones < total coeff ) { int mask , prefix ; int suffix length = ( ( total coeff > NUM ) ? NUM : NUM ) & ( ( trailing ones < NUM ) ? NUM : NUM ) ; int bitsi = ( int ) gb . show bits ( LEVEL TAB BITS ) ; int level code = cavlc level tab [ suffix length ] [ bitsi ] [ NUM ] ; gb . skip bits ( cavlc level tab [ suffix length ] [ bitsi ] [ NUM ] ) ; if ( level code >= NUM ) { prefix = level code - NUM ; if ( prefix == LEVEL TAB BITS ) prefix += get level prefix ( gb ) ; if ( prefix < NUM ) { if ( suffix length != NUM ) level code = ( int ) ( ( prefix << NUM ) + gb . get bits 1 ( STRING ) ) ; else level code = prefix ; } else if ( prefix == NUM ) { if ( suffix length != NUM ) level code = ( int ) ( ( prefix << NUM ) + gb . get bits 1 ( STRING ) ) ; else level code = ( int ) ( prefix + gb . get bits ( NUM , STRING ) ) ; } else { level code = NUM + ( int ) ( gb . get bits ( prefix - NUM , STRING ) ) ; if ( prefix >= NUM ) { if ( prefix > NUM + NUM ) { return - NUM ; } level code += ( NUM << ( prefix - NUM ) ) - NUM ; } } if ( trailing ones < NUM ) level code += NUM ; suffix length = NUM ; mask = - ( level code & NUM ) ; level [ trailing ones ] = ( ( ( NUM + level code ) > > NUM ) ^ mask ) - mask ; } else { level code += ( ( level code > > NUM ) | NUM ) & - ( ( trailing ones < NUM ) ? NUM : NUM ) ; suffix length = NUM + ( ( ( NUM & ( level code + NUM ) ) > NUM ) ? NUM : NUM ) ; level [ trailing ones ] = level code ; } for ( i = trailing ones + NUM ; i < total coeff ; i ++ ) { final int [ ] suffix limit = { NUM , NUM , NUM , NUM , NUM , NUM , Integer . MAX VALUE } ; bitsi = ( int ) gb . show bits ( LEVEL TAB BITS ) ; level code = cavlc level tab [ suffix length ] [ bitsi ] [ NUM ] ; gb . skip bits ( cavlc level tab [ suffix length ] [ bitsi ] [ NUM ] ) ; if ( level code >= NUM ) { prefix = level code - NUM ; if ( prefix == LEVEL TAB BITS ) { prefix += get level prefix ( gb ) ; } if ( prefix < NUM ) { level code = ( int ) ( ( prefix << suffix length ) + gb . get bits ( suffix length , STRING ) ) ; } else { level code = ( int ) ( ( NUM << suffix length ) + gb . get bits ( prefix - NUM , STRING ) ) ; if ( prefix >= NUM ) level code += ( NUM << ( prefix - NUM ) ) - NUM ; } mask = - ( level code & NUM ) ; level code = ( ( ( NUM + level code ) > > NUM ) ^ mask ) - mask ; } level [ i ] = level code ; suffix length += ( ( ( NUM & ( suffix limit [ suffix length ] + level code ) ) > ( NUM * suffix limit [ suffix length ] ) ) ? NUM : NUM ) ; } } if ( total coeff == max coeff ) zeros left = NUM ; else { if ( n >= H264 Context . CHROMA DC BLOCK INDEX ) { zeros left = gb . get vlc 2 ( chroma dc total zeros vlc [ total coeff - NUM ] . table base , chroma dc total zeros vlc [ total coeff - NUM ] . table offset , H264 Context . CHROMA DC TOTAL ZEROS VLC BITS , NUM , STRING ) ; } else { zeros left = gb . get vlc 2 ( total zeros vlc [ total coeff - NUM ] . table base , total zeros vlc [ total coeff - NUM ] . table offset , H264 Context . TOTAL ZEROS VLC BITS , NUM , STRING ) ; } } scantable offset += zeros left + total coeff - NUM ; if ( scantable offset < NUM ) { int [ ] new scantable base = new int [ scantable base . length + ( - scantable offset ) ] ; System . arraycopy ( scantable base , NUM , new scantable base , - scantable offset , scantable base . length ) ; scantable base = new scantable base ; scantable offset = NUM ; } if ( n >= H264 Context . LUMA DC BLOCK INDEX ) { block base [ block offset + scantable base [ scantable offset ] ] = ( short ) level [ NUM ] ; for ( i = NUM ; i < total coeff && zeros left > NUM ; i ++ ) { if ( zeros left < NUM ) { run before = gb . get vlc 2 ( run vlc [ zeros left - NUM ] . table base , run vlc [ zeros left - NUM ] . table offset , H264 Context . RUN VLC BITS , NUM , STRING ) ; } else { run before = gb . get vlc 2 ( run 7 vlc . table base , run 7 vlc . table offset , H264 Context . RUN 7 VLC BITS , NUM , STRING ) ; } zeros left -= run before ; scantable offset -= NUM + run before ; block base [ block offset + scantable base [ scantable offset ] ] = ( short ) level [ i ] ; } for ( ; i < total coeff ; i ++ ) { scantable offset -- ; block base [ block offset + scantable base [ scantable offset ] ] = ( short ) level [ i ] ; } } else { block base [ block offset + scantable base [ scantable offset ] ] = ( short ) ( ( level [ NUM ] * qmul base [ qmul offset + scantable base [ scantable offset ] ] + NUM ) > > NUM ) ; for ( i = NUM ; i < total coeff && zeros left > NUM ; i ++ ) { if ( zeros left < NUM ) { run before = gb . get vlc 2 ( run vlc [ zeros left - NUM ] . table base , run vlc [ zeros left - NUM ] . table offset , H264 Context . RUN VLC BITS , NUM , STRING ) ; } else { run before = gb . get vlc 2 ( run 7 vlc . table base , run 7 vlc . table offset , H264 Context . RUN 7 VLC BITS , NUM , STRING ) ; } zeros left -= run before ; scantable offset -= ( NUM + run before ) ; block base [ block offset + scantable base [ scantable offset ] ] = ( short ) ( ( level [ i ] * qmul base [ qmul offset + scantable base [ scantable offset ] ] + NUM ) > > NUM ) ; } for ( ; i < total coeff ; i ++ ) { scantable offset -- ; block base [ block offset + scantable base [ scantable offset ] ] = ( short ) ( ( level [ i ] * qmul base [ qmul offset + scantable base [ scantable offset ] ] + NUM ) > > NUM ) ; } } if ( zeros left < NUM ) { return - NUM ; } return NUM ; }
public void check Reinit File ( final boolean need Reinit ) throws IO Exception { File boot Mode File = new File ( root Dir , Constants . STARTUPMODE ) ; if ( ! need Reinit ) { log . info ( STRING ) ; if ( boot Mode File . exists ( ) ) { boot Mode File . delete ( ) ; } return ; } if ( ! boot Mode File . exists ( ) ) { set Db Startup Mode As Restore Reinit ( root Dir ) ; } chown ( boot Mode File , Backup Constants . STORAGEOS USER , Backup Constants . STORAGEOS GROUP ) ; log . info ( STRING , boot Mode File . get Absolute Path ( ) ) ; }
private float clamp Mag ( float value , float abs Min , float abs Max ) { final float abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }
public void read DOT ( Reader input ) { Dot Parser dp = new Dot Parser ( input , m nodes , m edges ) ; graph ID = dp . parse ( ) ; set Appropriate Node Size ( ) ; if ( m le != null ) { m le . set Node Size ( padded Node Width , node Height ) ; j Bt Layout . set Enabled ( BOOL ) ; layout Graph ( ) ; } }
private void notify All Entity ( ) { Log . print Concat Line ( super . get Name ( ) , STRING ) ; signal Shutdown ( res List ) ; signal Shutdown ( gis List ) ; res List . clear ( ) ; gis List . clear ( ) ; }
protected Response calc Default SMTP Response ( Hook Result result ) { if ( result != null ) { int r Code = result . get Result ( ) ; String smtp Ret Code = result . get Smtp Ret Code ( ) ; String smtp Desc = result . get Smtp Description ( ) ; if ( ( r Code & Hook Return Code . DENY ) == Hook Return Code . DENY ) { if ( smtp Ret Code == null ) smtp Ret Code = SMTP Ret Code . AUTH FAILED ; if ( smtp Desc == null ) smtp Desc = STRING ; SMTP Response response = new SMTP Response ( smtp Ret Code , smtp Desc ) ; if ( ( r Code & Hook Return Code . DISCONNECT ) == Hook Return Code . DISCONNECT ) { response . set End Session ( BOOL ) ; } return response ; } else if ( ( r Code & Hook Return Code . DENYSOFT ) == Hook Return Code . DENYSOFT ) { if ( smtp Ret Code == null ) smtp Ret Code = SMTP Ret Code . LOCAL ERROR ; if ( smtp Desc == null ) smtp Desc = STRING ; SMTP Response response = new SMTP Response ( smtp Ret Code , smtp Desc ) ; if ( ( r Code & Hook Return Code . DISCONNECT ) == Hook Return Code . DISCONNECT ) { response . set End Session ( BOOL ) ; } return response ; } else if ( ( r Code & Hook Return Code . OK ) == Hook Return Code . OK ) { if ( smtp Ret Code == null ) smtp Ret Code = SMTP Ret Code . AUTH OK ; if ( smtp Desc == null ) smtp Desc = STRING ; SMTP Response response = new SMTP Response ( smtp Ret Code , smtp Desc ) ; if ( ( r Code & Hook Return Code . DISCONNECT ) == Hook Return Code . DISCONNECT ) { response . set End Session ( BOOL ) ; } return response ; } else if ( ( r Code & Hook Return Code . DISCONNECT ) == Hook Return Code . DISCONNECT ) { SMTP Response response = new SMTP Response ( STRING ) ; response . set End Session ( BOOL ) ; return response ; } else { return null ; } } else { return null ; } }
public synchronized boolean has Alerts ( ) { if ( alerts == null ) { return BOOL ; } return ! alerts . is Empty ( ) ; }
public void test Compare To Pos Pos 1 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; assert Equals ( NUM , a Number . compare To ( b Number ) ) ; }
protected Collection < ? extends Annotation Mirror > replace Poly All ( Collection < ? extends Annotation Mirror > annos ) { Set < Annotation Mirror > return Annos = Annotation Utils . create Annotation Set ( ) ; for ( Annotation Mirror top : get Top Annotations ( ) ) { Annotation Mirror annotation In Hierarchy = find Annotation In Hierarchy ( annos , top ) ; if ( annotation In Hierarchy != null ) { return Annos . add ( annotation In Hierarchy ) ; } } return return Annos ; }
public synchronized void reset Inputs ( ) throws IO Exception { source . print Statistics ( STRING ) ; set Config ( config , source ) ; source . reset Inputs ( ) ; num Docs Created . set ( NUM ) ; reset Leftovers ( ) ; }
public void remove Matching Coupling ( Coupling < ? > to Remove ) { for ( Coupling < ? > coupling : get Couplings ( ) ) { boolean consumers Match = attributes Match ( coupling . get Consumer ( ) , to Remove . get Consumer ( ) ) ; boolean producers Match = attributes Match ( coupling . get Producer ( ) , to Remove . get Producer ( ) ) ; if ( consumers Match && producers Match ) { remove Coupling ( coupling ) ; } } }
public String to Short String ( ) { String Builder sb = new String Builder ( ) ; if ( x Road Instance != null ) { sb . append ( x Road Instance ) ; } for ( String part : get Fields For String Format ( ) ) { if ( part != null ) { if ( sb . length ( ) > NUM ) { sb . append ( STRING ) ; } sb . append ( part ) ; } } return sb . to String ( ) ; }
private boolean check Pattern ( ) { if ( pattern == null ) { return BOOL ; } char left Separator = get Left Separator ( ) ; char right Separator = get Right Separator ( ) ; Stack < Character > separator Stack = new Stack < Character > ( ) ; for ( int i = NUM ; i < pattern . length ( ) ; i ++ ) { char cur = pattern . char At ( i ) ; if ( cur == left Separator ) { separator Stack . push ( cur ) ; } else if ( cur == right Separator ) { if ( ! separator Stack . is Empty ( ) && ( separator Stack . pop ( ) == left Separator ) ) { continue ; } else { return BOOL ; } } } return separator Stack . is Empty ( ) ; }
public static SQ Lite Database open Or Create Database ( File file , Cursor Factory factory ) { return open Or Create Database ( file . get Path ( ) , factory ) ; }
public String to String ( cp info constant pool [ ] ) { return Integer . to String ( ( int ) bytes ) ; }
private void clamp Starting Position ( ) { final float cX = m Bounds . exact Center X ( ) ; final float cY = m Bounds . exact Center Y ( ) ; final float dX = m Starting X - cX ; final float dY = m Starting Y - cY ; final float r = m Target Radius ; if ( dX * dX + dY * dY > r * r ) { final double angle = Math . atan 2 ( dY , dX ) ; m Clamped Starting X = cX + ( float ) ( Math . cos ( angle ) * r ) ; m Clamped Starting Y = cY + ( float ) ( Math . sin ( angle ) * r ) ; } else { m Clamped Starting X = m Starting X ; m Clamped Starting Y = m Starting Y ; } }
public Wildcard ( String pattern , int regexp Options ) { this . regexp Options = regexp Options ; regexp = Pattern . compile ( wildcard To Regex ( pattern ) , regexp Options ) ; shortcut = extract Shortcut ( pattern ) ; }
private boolean link Last ( Node < E > node ) { if ( count >= capacity ) return BOOL ; Node < E > l = last ; node . prev = l ; last = node ; if ( first == null ) first = node ; else l . next = node ; ++ count ; not Empty . signal ( ) ; return BOOL ; }
private String local number ( ) throws Parse Exception { String Buffer s = new String Buffer ( ) ; if ( debug ) dbg enter ( STRING ) ; try { int lc = NUM ; while ( lexer . has More Chars ( ) ) { char la = lexer . look Ahead ( NUM ) ; if ( la == STRING || la == STRING || la == STRING || la == STRING || la == STRING || la == STRING || Lexer . is Hex Digit ( la ) ) { lexer . consume ( NUM ) ; s . append ( la ) ; lc ++ ; } else if ( lc > NUM ) break ; else throw create Parse Exception ( STRING + la ) ; } return s . to String ( ) ; } finally { if ( debug ) dbg leave ( STRING ) ; } }
private static void append Default Value ( String Builder sb , Field Type field Type , Object default Value ) { if ( field Type . is Escaped Default Value ( ) ) { append Escaped Word ( sb , default Value . to String ( ) ) ; } else { sb . append ( default Value ) ; } }
public Metadata Block Data Picture ( Byte Buffer rawdata ) throws IO Exception , Invalid Frame Exception { init From Byte Buffer ( rawdata ) ; }
public void previous ( ) { if ( current ( ) == null ) { return ; } m current Search Index -- ; m is Before First = BOOL ; m is After Last = BOOL ; if ( m current Search Index < NUM ) { m current Search Index = m reduced Results . size ( ) - NUM ; m is Before First = BOOL ; } }
public void test Zero One ( ) { byte a Bytes [ ] = { NUM } ; byte b Bytes [ ] = { NUM } ; int a Sign = NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
@ Nullable public static Method find Method ( Class c , String name , Object ... params ) { Class [ ] param Types = get Param Types ( params ) ; Method method = null ; try { method = c . get Declared Method ( name , param Types ) ; } catch ( No Such Method Exception e ) { try { method = c . get Method ( name , param Types ) ; } catch ( No Such Method Exception e1 ) { } } if ( method != null ) method . set Accessible ( BOOL ) ; return method ; }
public void test Pos Zero ( ) { byte a Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM } ; int a Sign = NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM , - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public boolean close All Sessions ( ) { while ( exists Session ( ) ) { Session Editor session Editor = get Frontmost Session Editor ( ) ; Session Editor Workbench workbench = session Editor . get Session Workbench ( ) ; Session Wrapper wrapper = workbench . get Session Wrapper ( ) ; if ( ! wrapper . is Session Changed ( ) ) { close Frontmost Session ( ) ; continue ; } String name = session Editor . get Name ( ) ; int ret = J Option Pane . show Confirm Dialog ( J Option Utils . centering Comp ( ) , STRING + name + STRING , STRING , J Option Pane . YES NO CANCEL OPTION ) ; if ( ret == J Option Pane . NO OPTION ) { close Frontmost Session ( ) ; continue ; } else if ( ret == J Option Pane . CANCEL OPTION ) { return BOOL ; } Save Session As Action action = new Save Session As Action ( ) ; action . action Performed ( new Action Event ( this , Action Event . ACTION PERFORMED , STRING ) ) ; if ( ! action . is Saved ( ) ) { int ret 2 = J Option Pane . show Confirm Dialog ( J Option Utils . centering Comp ( ) , STRING , STRING , J Option Pane . OK CANCEL OPTION ) ; if ( ret 2 == J Option Pane . CANCEL OPTION ) { return BOOL ; } } close Frontmost Session ( ) ; } return BOOL ; }
private void remove Non Visible Views ( final int offset ) { int child Count = get Child Count ( ) ; if ( m Last Item Position != m Adapter . get Count ( ) - NUM && child Count > NUM ) { View first Child = get Child At ( NUM ) ; while ( first Child != null && get Child Bottom ( first Child ) + offset < NUM ) { remove View In Layout ( first Child ) ; child Count -- ; m Cached Item Views . add Last ( first Child ) ; m First Item Position ++ ; m List Top Offset += get Child Height ( first Child ) ; if ( child Count > NUM ) { first Child = get Child At ( NUM ) ; } else { first Child = null ; } } } if ( m First Item Position != NUM && child Count > NUM ) { View last Child = get Child At ( child Count - NUM ) ; while ( last Child != null && get Child Top ( last Child ) + offset > get Height ( ) ) { remove View In Layout ( last Child ) ; child Count -- ; m Cached Item Views . add Last ( last Child ) ; m Last Item Position -- ; if ( child Count > NUM ) { last Child = get Child At ( child Count - NUM ) ; } else { last Child = null ; } } } }
public Repeated Field Builder < M Type , B Type , I Type > add Message ( int index , M Type message ) { if ( message == null ) { throw new Null Pointer Exception ( ) ; } ensure Mutable Message List ( ) ; messages . add ( index , message ) ; if ( builders != null ) { builders . add ( index , null ) ; } on Changed ( ) ; increment Mod Counts ( ) ; return this ; }
void unlock ( Table t ) { locks . remove ( t ) ; }
public void on Exceeded Database Quota ( String url , String database Identifier , long current Quota , long estimated Size , long total Used Quota , Web Storage . Quota Updater quota Updater ) { if ( LOGV ENABLED ) { Log . v ( LOGTAG , STRING + url + STRING + database Identifier + STRING + current Quota + STRING + total Used Quota + STRING ) ; } long total Unused Quota = m Global Limit - total Used Quota - m App Cache Max Size ; if ( total Unused Quota <= NUM ) { if ( total Used Quota > NUM ) { schedule Out Of Space Notification ( ) ; } quota Updater . update Quota ( current Quota ) ; if ( LOGV ENABLED ) { Log . v ( LOGTAG , STRING ) ; } return ; } long new Origin Quota = current Quota ; if ( new Origin Quota == NUM ) { if ( total Unused Quota >= estimated Size ) { new Origin Quota = estimated Size ; } else { if ( LOGV ENABLED ) { Log . v ( LOGTAG , STRING + STRING + STRING + estimated Size + STRING + total Unused Quota ) ; } new Origin Quota = NUM ; } } else { long quota Increase = estimated Size == NUM ? Math . min ( QUOTA INCREASE STEP , total Unused Quota ) : estimated Size ; new Origin Quota += quota Increase ; if ( quota Increase > total Unused Quota ) { new Origin Quota = current Quota ; } } quota Updater . update Quota ( new Origin Quota ) ; if ( LOGV ENABLED ) { Log . v ( LOGTAG , STRING + new Origin Quota ) ; } }
protected String to Val String ( Set vals ) { String Builder sb = new String Builder ( ) ; boolean first = BOOL ; for ( Iterator i = vals . iterator ( ) ; i . has Next ( ) ; ) { String val = ( String ) i . next ( ) ; val = encode Val ( val ) ; if ( first ) { first = BOOL ; } else { sb . append ( STRING ) ; } sb . append ( val ) ; } return sb . to String ( ) ; }
private String print O Format ( short x ) { String sx = null ; if ( x == Short . MIN VALUE ) sx = STRING ; else if ( x < NUM ) { String t = Integer . to String ( ( ~ ( - x - NUM ) ) ^ Short . MIN VALUE , NUM ) ; switch ( t . length ( ) ) { case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; } } else sx = Integer . to String ( x , NUM ) ; return print O Format ( sx ) ; }
public static JSON Array read JSON Array ( final JSON Array json Array , final int index , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Array . get JSON Array ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT ARRAY , index ) ) ; } JSON Array value = null ; if ( ! json Array . is Null ( index ) ) { value = json Array . get JSON Array ( index ) ; } return value ; }
private static Bitmap resize Photo ( Bitmap real Image , float max Image Size , boolean filter ) { float ratio = Math . min ( ( float ) max Image Size / real Image . get Width ( ) , ( float ) max Image Size / real Image . get Height ( ) ) ; int width = Math . round ( ( float ) ratio * real Image . get Width ( ) ) ; int height = Math . round ( ( float ) ratio * real Image . get Height ( ) ) ; Bitmap new Bitmap = Bitmap . create Scaled Bitmap ( real Image , width , height , filter ) ; return new Bitmap ; }
private Element create Key Value ( ) throws Exception { Element key Value Ele = null ; Private Key key = idm Client . get Tenant Private Key ( tenant Name ) ; if ( key != null ) { RSA Private Key rsa Key = ( RSA Private Key ) key ; Element rsa Key Ele = create RSA Key Value ( rsa Key ) ; if ( rsa Key Ele != null ) { key Value Ele = doc . create Element ( SAML Names . DS KEYVALUE ) ; key Value Ele . append Child ( rsa Key Ele ) ; } } return key Value Ele ; }
static protected void expand Element ( Element el , List < Element > list ) { list . add All ( el . get Children ( STRING ) ) ; List < Element > children = el . get Children ( ) ; for ( int i = NUM ; i < children . size ( ) ; i ++ ) { expand Element ( children . get ( i ) , list ) ; } }
static void load ( ) { }
public static String dump ( Map < ? , ? > map ) { String Builder string Builder = new String Builder ( ) ; for ( Map . Entry < ? , ? > entry : map . entry Set ( ) ) { string Builder . append ( entry . get Key ( ) ) ; string Builder . append ( STRING ) ; string Builder . append ( entry . get Value ( ) ) ; } return string Builder . to String ( ) ; }
public void changed Update ( Document Event e ) { }
private void merge Collapse ( ) { while ( stack Size > NUM ) { int n = stack Size - NUM ; if ( n > NUM && run Len [ n - NUM ] <= run Len [ n ] + run Len [ n + NUM ] ) { if ( run Len [ n - NUM ] < run Len [ n + NUM ] ) n -- ; merge At ( n ) ; } else if ( run Len [ n ] <= run Len [ n + NUM ] ) { merge At ( n ) ; } else { break ; } } }
private File find File ( File directory , String name ) throws File Not Found Exception { File file = new File ( directory , name ) ; if ( file . exists ( ) ) { return file ; } for ( String child : directory . list ( ) ) { if ( child . equals Ignore Case ( name ) ) { return new File ( directory , child ) ; } } throw new File Not Found Exception ( STRING + file ) ; }
public void force Rewrite Exif ( String filename , Collection < Exif Tag > tags ) throws File Not Found Exception , IO Exception { if ( ! rewrite Exif ( filename , tags ) ) { Exif Data temp Data = m Data ; m Data = new Exif Data ( DEFAULT BYTE ORDER ) ; File Input Stream is = null ; Byte Array Output Stream bytes = null ; try { is = new File Input Stream ( filename ) ; bytes = new Byte Array Output Stream ( ) ; do Exif Stream IO ( is , bytes ) ; byte [ ] image Bytes = bytes . to Byte Array ( ) ; read Exif ( image Bytes ) ; set Tags ( tags ) ; write Exif ( image Bytes , filename ) ; } catch ( IO Exception e ) { close Silently ( is ) ; throw e ; } finally { is . close ( ) ; m Data = temp Data ; } } }
private boolean link Last ( Node < E > node ) { if ( count >= capacity ) return BOOL ; Node < E > l = last ; node . prev = l ; last = node ; if ( first == null ) first = node ; else l . next = node ; ++ count ; not Empty . signal ( ) ; return BOOL ; }
protected void remove From Maps ( String client Type ) { Client client = ( Client ) client Type Map . get ( client Type ) ; external Client Data . remove ( client Type ) ; Map map = ( Map ) internal Client Data . get ( client Type ) ; if ( map == null ) { remove From Client Map ( client Type , client ) ; } else { handle Parent Change ( client Type , map ) ; } unload Client ( client Type ) ; }
public String serialize ( Object object ) throws Converter Exception { deep = NUM ; String Builder sb = new String Builder ( ) ; serialize ( object , sb , new Hash Set < Object > ( ) ) ; return sb . to String ( ) ; }
private void end List ( boolean ordered List ) { if ( ! m Paragraph Styles . is Empty ( ) ) { Accumulated Paragraph Style style = m Paragraph Styles . peek ( ) ; Paragraph Type type = style . get Type ( ) ; if ( ( ordered List && ( type . is Numbering ( ) || type == Paragraph Type . INDENTATION OL ) ) || ( ! ordered List && ( type . is Bullet ( ) || type == Paragraph Type . INDENTATION UL ) ) ) { int indent = style . get Relative Indent ( ) ; if ( indent > NUM ) { style . set Relative Indent ( indent - NUM ) ; style . set Absolute Indent ( style . get Absolute Indent ( ) - NUM ) ; } else { m Paragraph Styles . pop ( ) ; } } else { m Paragraph Styles . pop ( ) ; end List ( ordered List ) ; } } }
private void display Verbose ( Console Application app , String category Name , String type Name , Tag tag , Set < String > property Names ) { Localizable Message c1 = build Line ( STRING , MAX LINE WIDTH ) ; Localizable Message c2 = build Line ( STRING , MAX LINE WIDTH ) ; boolean is First Managed Object = BOOL ; for ( String category : category Map . key Set ( ) ) { if ( category Name != null && ! category Name . equals ( category ) ) { continue ; } Map < String , Abstract Managed Object Definition < ? , ? > > sub Types = category Map . get ( category ) ; for ( String type : sub Types . key Set ( ) ) { if ( type Name != null && ! type Name . equals ( type ) ) { continue ; } Abstract Managed Object Definition < ? , ? > mod = sub Types . get ( type ) ; if ( cannot Display ( app , mod , tag ) ) { continue ; } boolean is First Property = BOOL ; Set < Property Definition < ? > > pds = get Property Definitions ( mod ) ; for ( Property Definition < ? > pd : pds ) { if ( cannot Display ( app , pd , property Names ) ) { continue ; } if ( is First Property ) { if ( ! is First Managed Object ) { app . println ( ) ; app . println ( c1 ) ; app . println ( ) ; } else { is First Managed Object = BOOL ; } app . println ( INFO DSCFG HELP HEADING COMPONENT . get ( mod . get User Friendly Name ( ) ) ) ; app . println ( ) ; app . println ( mod . get Synopsis ( ) ) ; if ( mod . get Description ( ) != null ) { app . println ( ) ; app . println ( mod . get Description ( ) ) ; } } app . println ( ) ; app . println ( c2 ) ; app . println ( ) ; display Verbose Single Property ( app , mod , pd . get Name ( ) ) ; is First Property = BOOL ; } } } }
private static < T > void find Unique Goals ( Map < Test Case , Set < T > > test To Goals ) { Map < Test Case , Set < T > > goal Map Copy = new Linked Hash Map < > ( ) ; for ( Map . Entry < Test Case , Set < T > > entry : test To Goals . entry Set ( ) ) { Set < T > goal Set = new Linked Hash Set < T > ( entry . get Value ( ) ) ; for ( Map . Entry < Test Case , Set < T > > other Entry : test To Goals . entry Set ( ) ) { if ( entry == other Entry ) continue ; goal Set . remove All ( other Entry . get Value ( ) ) ; } goal Map Copy . put ( entry . get Key ( ) , goal Set ) ; } test To Goals . clear ( ) ; test To Goals . put All ( goal Map Copy ) ; }
private static String form Head ( String hair , String face , String neck ) { return String . join ( STRING , hair , face , neck ) ; }
public void terminate ( ) { listeners . clear ( ) ; lookup Disc . terminate ( ) ; locator Disc . terminate ( ) ; if ( dynamic Locator Disc != null ) dynamic Locator Disc . terminate ( ) ; }
public void start ( ) { start = System . current Time Millis ( ) ; }
@ Nullable public static String extract Protocol ( @ Not Null String url ) { int index = url . index Of ( URL Util . SCHEME SEPARATOR ) ; if ( index < NUM ) return null ; return url . substring ( NUM , index ) ; }
protected void load Buffer ( ) { int res Idx = minute Spacing / NUM ; if ( res Idx < NUM ) res Idx = NUM ; else if ( res Idx > NUM ) res Idx = NUM ; String file Name = path + etopo File Names [ res Idx ] ; data Buffer = null ; try { Binary Buffered File bin File = new Binary Buffered File ( file Name ) ; bin File . byte Order ( BOOL ) ; buffer Width = etopo Widths [ res Idx ] ; buffer Height = etopo Heights [ res Idx ] ; int spacer = NUM ; switch ( minute Spacing ) { case ( NUM ) : spacer = NUM + this . spacer ; break ; case ( NUM ) : spacer = NUM + this . spacer ; break ; default : spacer = NUM + this . spacer ; } data Buffer = new short [ ( buffer Width + spacer ) * buffer Height ] ; for ( int i = NUM ; i < buffer Width * buffer Height ; i ++ ) data Buffer [ i ] = bin File . read Short ( ) ; bin File . close ( ) ; buffer Width += spacer ; } catch ( File Not Found Exception e ) { Debug . error ( STRING + file Name + STRING ) ; } catch ( IO Exception e ) { Debug . error ( STRING + e . to String ( ) ) ; } catch ( Format Exception e ) { Debug . error ( STRING + e . to String ( ) ) ; } }
protected Version Tag fetch Remote Version Tag ( Object key ) { Version Tag tag = null ; assert this . data Policy != Data Policy . REPLICATE ; Transaction Id tx Id = cache . get Cache Transaction Manager ( ) . suspend ( ) ; try { boolean retry = BOOL ; Internal Distributed Member member = get Random Replicate ( ) ; while ( retry ) { try { if ( member == null ) { break ; } Fetch Version Response response = Remote Fetch Version Message . send ( member , this , key ) ; tag = response . wait For Response ( ) ; retry = BOOL ; } catch ( Remote Operation Exception e ) { member = get Random Replicate ( ) ; if ( member != null ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING , member ) ; } } } } } finally { if ( tx Id != null ) { cache . get Cache Transaction Manager ( ) . resume ( tx Id ) ; } } return tag ; }
public Node replace Child ( Node new Child , Node old Child ) throws DOM Exception { if ( old Child == null || old Child . get Parent Node ( ) != this ) return null ; Elem Template Element new Child Elem = ( ( Elem Template Element ) new Child ) ; Elem Template Element old Child Elem = ( ( Elem Template Element ) old Child ) ; Elem Template Element prev = ( Elem Template Element ) old Child Elem . get Previous Sibling ( ) ; if ( null != prev ) prev . m next Sibling = new Child Elem ; if ( m first Child == old Child Elem ) m first Child = new Child Elem ; new Child Elem . m parent Node = this ; old Child Elem . m parent Node = null ; new Child Elem . m next Sibling = old Child Elem . m next Sibling ; old Child Elem . m next Sibling = null ; return new Child Elem ; }
public void paint Dirty ( ) { int size = NUM ; synchronized ( display Lock ) { size = paint Queue Fill ; Animation [ ] array = paint Queue ; paint Queue = paint Queue Temp ; paint Queue Temp = array ; paint Queue Fill = NUM ; } if ( size > NUM ) { Graphics wrapper = get Codename One Graphics ( ) ; int dwidth = get Display Width ( ) ; int dheight = get Display Height ( ) ; int top X = dwidth ; int top Y = dheight ; int bottom X = NUM ; int bottom Y = NUM ; for ( int iter = NUM ; iter < size ; iter ++ ) { Animation ani = paint Queue Temp [ iter ] ; if ( ani == null ) { continue ; } paint Queue Temp [ iter ] = null ; wrapper . translate ( - wrapper . get Translate X ( ) , - wrapper . get Translate Y ( ) ) ; wrapper . set Clip ( NUM , NUM , dwidth , dheight ) ; if ( ani instanceof Component ) { Component cmp = ( Component ) ani ; Rectangle dirty = cmp . get Dirty Region ( ) ; if ( dirty != null ) { Dimension d = dirty . get Size ( ) ; wrapper . set Clip ( dirty . get X ( ) , dirty . get Y ( ) , d . get Width ( ) , d . get Height ( ) ) ; cmp . set Dirty Region ( null ) ; } cmp . paint Component ( wrapper ) ; get Paintable Bounds ( cmp , paint Dirty Tmp Rect ) ; int cmp Abs X = paint Dirty Tmp Rect . get X ( ) ; top X = Math . min ( cmp Abs X , top X ) ; bottom X = Math . max ( cmp Abs X + paint Dirty Tmp Rect . get Width ( ) , bottom X ) ; int cmp Abs Y = paint Dirty Tmp Rect . get Y ( ) ; top Y = Math . min ( cmp Abs Y , top Y ) ; bottom Y = Math . max ( cmp Abs Y + paint Dirty Tmp Rect . get Height ( ) , bottom Y ) ; } else { bottom X = dwidth ; bottom Y = dheight ; top X = NUM ; top Y = NUM ; ani . paint ( wrapper ) ; } } paint Overlay ( wrapper ) ; flush Graphics ( top X , top Y , bottom X - top X , bottom Y - top Y ) ; } }
public static F Size calc Text Size ( Paint paint , String demo Text ) { Rect r = new Rect ( ) ; paint . get Text Bounds ( demo Text , NUM , demo Text . length ( ) , r ) ; return new F Size ( r . width ( ) , r . height ( ) ) ; }
private boolean parse Delimiters ( Delimiter Processor delimiter Processor , char delimiter Char ) { Delimiter Data res = scan Delimiters ( delimiter Processor , delimiter Char ) ; if ( res == null ) { return BOOL ; } int num Delims = res . count ; int start Index = index ; index += num Delims ; Text node = append Text ( input , start Index , index ) ; last Delimiter = new Delimiter ( node , delimiter Char , res . can Open , res . can Close , last Delimiter ) ; last Delimiter . num Delims = num Delims ; if ( last Delimiter . previous != null ) { last Delimiter . previous . next = last Delimiter ; } return BOOL ; }
private void clear Money ( ) { money . clear ( ) ; update Money ( ) ; }
private void multi Touch Controller ( ) { if ( DEBUG ) Log . i ( STRING , STRING + m Mode + STRING + m Curr Pt . get Num Touch Points ( ) + STRING + m Curr Pt . is Down ( ) + m Curr Pt . is Multi Touch ( ) ) ; switch ( m Mode ) { case MODE NOTHING : if ( DEBUG ) Log . i ( STRING , STRING ) ; if ( m Curr Pt . is Down ( ) ) { selected Object = object Canvas . get Draggable Object At Point ( m Curr Pt ) ; if ( selected Object != null ) { m Mode = MODE DRAG ; object Canvas . select Object ( selected Object , m Curr Pt ) ; anchor At This Position And Scale ( ) ; m Settle Start Time = m Settle End Time = m Curr Pt . get Event Time ( ) ; } } break ; case MODE DRAG : if ( DEBUG ) Log . i ( STRING , STRING ) ; if ( ! m Curr Pt . is Down ( ) ) { m Mode = MODE NOTHING ; object Canvas . select Object ( ( selected Object = null ) , m Curr Pt ) ; } else if ( m Curr Pt . is Multi Touch ( ) ) { m Mode = MODE PINCH ; anchor At This Position And Scale ( ) ; m Settle Start Time = m Curr Pt . get Event Time ( ) ; m Settle End Time = m Settle Start Time + EVENT SETTLE TIME INTERVAL ; } else { if ( m Curr Pt . get Event Time ( ) < m Settle End Time ) { anchor At This Position And Scale ( ) ; } else { perform Drag Or Pinch ( ) ; } } break ; case MODE PINCH : if ( DEBUG ) Log . i ( STRING , STRING ) ; if ( ! m Curr Pt . is Multi Touch ( ) || ! m Curr Pt . is Down ( ) ) { if ( ! m Curr Pt . is Down ( ) ) { m Mode = MODE NOTHING ; object Canvas . select Object ( ( selected Object = null ) , m Curr Pt ) ; } else { m Mode = MODE DRAG ; anchor At This Position And Scale ( ) ; m Settle Start Time = m Curr Pt . get Event Time ( ) ; m Settle End Time = m Settle Start Time + EVENT SETTLE TIME INTERVAL ; } } else { if ( Math . abs ( m Curr Pt . get X ( ) - m Prev Pt . get X ( ) ) > MAX MULTITOUCH POS JUMP SIZE || Math . abs ( m Curr Pt . get Y ( ) - m Prev Pt . get Y ( ) ) > MAX MULTITOUCH POS JUMP SIZE || Math . abs ( m Curr Pt . get Multi Touch Width ( ) - m Prev Pt . get Multi Touch Width ( ) ) * NUM > MAX MULTITOUCH DIM JUMP SIZE || Math . abs ( m Curr Pt . get Multi Touch Height ( ) - m Prev Pt . get Multi Touch Height ( ) ) * NUM > MAX MULTITOUCH DIM JUMP SIZE ) { anchor At This Position And Scale ( ) ; m Settle Start Time = m Curr Pt . get Event Time ( ) ; m Settle End Time = m Settle Start Time + EVENT SETTLE TIME INTERVAL ; } else if ( m Curr Pt . event Time < m Settle End Time ) { anchor At This Position And Scale ( ) ; } else { perform Drag Or Pinch ( ) ; } } break ; } if ( DEBUG ) Log . i ( STRING , STRING + m Mode + STRING + m Curr Pt . get Num Touch Points ( ) + STRING + m Curr Pt . is Down ( ) + m Curr Pt . is Multi Touch ( ) ) ; }
public void exec ( String [ ] args ) throws Throwable { URL Class Loader url Class Loader = new URL Class Loader ( class Path . to Array ( new URL [ class Path . size ( ) ] ) ) ; Class < ? > cls = url Class Loader . load Class ( main Class ) ; Method method = cls . get Declared Method ( STRING , String [ ] . class ) ; method . set Accessible ( BOOL ) ; try { method . invoke ( null , new Object [ ] { args } ) ; } catch ( Invocation Target Exception e ) { throw e . get Target Exception ( ) ; } }
public static String to String ( URI uri , Charset encoding ) throws IO Exception { return to String ( uri . to URL ( ) , Charsets . to Charset ( encoding ) ) ; }
void rollback Local Transaction ( ) throws Rollback Failed Exception { if ( tx == null ) { return ; } try { if ( logger . is Loggable ( Level . FINEST ) ) { logger . log ( Level . FINEST , STRING + tx ) ; } tx . abort ( ) ; } catch ( Exception e ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , STRING + tx , e ) ; } throw new Rollback Failed Exception ( e ) ; } }
public void write ( char c [ ] , int off , int len ) { if ( ( off < NUM ) || ( off > c . length ) || ( len < NUM ) || ( ( off + len ) > c . length ) || ( ( off + len ) < NUM ) ) { throw new Index Out Of Bounds Exception ( ) ; } else if ( len == NUM ) { return ; } synchronized ( lock ) { int newcount = count + len ; if ( newcount > buf . length ) { buf = Arrays . copy Of ( buf , Math . max ( buf . length << NUM , newcount ) ) ; } System . arraycopy ( c , off , buf , count , len ) ; count = newcount ; } }
private void write Jar Post Resource ( String Builder sb , String path ) { sb . append ( STRING + JAR RESOURCE SET + STRING ) ; sb . append ( path . replace ( STRING , STRING ) ) ; }
public static String normalize ( String value ) { if ( value == null ) return value ; value = value . trim ( ) ; if ( value . index Of ( STRING ) == - NUM ) return value ; boolean space = BOOL ; int len = value . length ( ) ; String Buffer b = new String Buffer ( len ) ; for ( int i = NUM ; i < len ; i ++ ) { char v = value . char At ( i ) ; if ( v == STRING ) { if ( ! space ) b . append ( v ) ; space = BOOL ; } else { b . append ( v ) ; space = BOOL ; } } return b . to String ( ) ; }
protected static void append Decorations ( int base Pos , String source Code , Create Simple Lexer lang Handler , List < Object > out ) { if ( source Code == null ) { throw new Null Pointer Exception ( STRING ) ; } Job job = new Job ( ) ; job . set Source Code ( source Code ) ; job . set Base Pos ( base Pos ) ; lang Handler . decorate ( job ) ; out . add All ( job . get Decorations ( ) ) ; }
protected Carbon Dictionary Column Meta Chunk read Last Chunk From Dictionary Metadata File ( Dictionary Column Unique Identifier dictionary Column Unique Identifier ) throws IO Exception { Dictionary Service dict Service = Carbon Common Factory . get Dictionary Service ( ) ; Carbon Dictionary Metadata Reader column Metadata Reader Impl = dict Service . get Dictionary Metadata Reader ( dictionary Column Unique Identifier . get Carbon Table Identifier ( ) , dictionary Column Unique Identifier . get Column Identifier ( ) , carbon Store Path ) ; Carbon Dictionary Column Meta Chunk carbon Dictionary Column Meta Chunk = null ; try { carbon Dictionary Column Meta Chunk = column Metadata Reader Impl . read Last Entry Of Dictionary Meta Chunk ( ) ; } finally { column Metadata Reader Impl . close ( ) ; } return carbon Dictionary Column Meta Chunk ; }
public static External App Id determine External Intent Source ( String package Name , Intent intent ) { String app Id = Intent Utils . safe Get String Extra ( intent , Browser . EXTRA APPLICATION ID ) ; External App Id external Id = External App Id . OTHER ; if ( app Id == null ) { String url = get Url From Intent ( intent ) ; if ( url != null && url . starts With ( TWITTER LINK PREFIX ) ) { external Id = External App Id . TWITTER ; } else if ( url != null && url . starts With ( FACEBOOK LINK PREFIX ) ) { external Id = External App Id . FACEBOOK ; } else if ( url != null && url . starts With ( NEWS LINK PREFIX ) ) { external Id = External App Id . NEWS ; } } else { if ( app Id . equals ( PACKAGE PLUS ) ) { external Id = External App Id . PLUS ; } else if ( app Id . equals ( PACKAGE GMAIL ) ) { external Id = External App Id . GMAIL ; } else if ( app Id . equals ( PACKAGE HANGOUTS ) ) { external Id = External App Id . HANGOUTS ; } else if ( app Id . equals ( PACKAGE MESSENGER ) ) { external Id = External App Id . MESSENGER ; } else if ( app Id . equals ( PACKAGE LINE ) ) { external Id = External App Id . LINE ; } else if ( app Id . equals ( PACKAGE WHATSAPP ) ) { external Id = External App Id . WHATSAPP ; } else if ( app Id . equals ( PACKAGE GSA ) ) { external Id = External App Id . GSA ; } else if ( app Id . equals ( package Name ) ) { external Id = External App Id . CHROME ; } } return external Id ; }
protected Table HDU ( Header hdr , T td ) { super ( hdr , td ) ; }
public void push Stylesheet ( Stylesheet s ) { if ( m stylesheets . size ( ) == NUM ) m stylesheet Root = ( Stylesheet Root ) s ; m stylesheets . push ( s ) ; }
public boolean is Blank ( final Char Sequence cs ) { int str Len ; if ( cs == null || ( str Len = cs . length ( ) ) == NUM ) { return BOOL ; } for ( int i = NUM ; i < str Len ; i ++ ) { if ( ! Character . is Whitespace ( cs . char At ( i ) ) ) { return BOOL ; } } return BOOL ; }
public void stop ( ) throws IO Exception , Interrupted Exception { thread . interrupt ( ) ; selector . wakeup ( ) ; }
private Document parse ( final String data , Document Builder doc Builder ) { if ( doc Builder == null || data == null ) { return null ; } Document document = null ; try { String Builder buf = new String Builder ( NUM ) ; if ( ! data . starts With ( STRING ) ) { buf . append ( BEGIN PART ) ; } buf . append ( data ) ; if ( ! data . ends With ( END PART ) ) { buf . append ( END PART ) ; } Input Source input Source = new Input Source ( new String Reader ( buf . to String ( ) ) ) ; document = doc Builder . parse ( input Source ) ; } catch ( Exception e ) { LOGGER . warn ( STRING + e . get Message ( ) ) ; } return document ; }
private X Net Reply load Chars ( java . io . Buffered Reader istream ) throws java . io . IO Exception { String s = STRING ; s = istream . read Line ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + s ) ; } if ( s == null ) { return null ; } else { return new X Net Reply ( s ) ; } }
public synchronized void remove Connection Manager ( final Http Connection Manager connection Manager ) { if ( shutdown ) { throw new Illegal State Exception ( STRING ) ; } connection Managers . remove ( connection Manager ) ; }
private boolean add State ( long state Number ) { if ( first State < NUM ) { first State = state Number ; } else if ( step Size < NUM ) { step Size = ( int ) ( state Number - first State ) ; } else { int step = ( int ) ( state Number - last State ) ; if ( step != step Size ) { return BOOL ; } } last State = state Number ; return BOOL ; }
public void reset ( ) { adler = NUM ; }
public static boolean is Library Resource Root ( @ Nullable Virtual File res ) { if ( res != null ) { Virtual File aar = res . get Parent ( ) ; if ( aar != null ) { Virtual File exploded = aar . get Parent ( ) ; if ( exploded != null ) { String name = exploded . get Name ( ) ; if ( name . equals ( EXPLODED BUNDLES ) || name . equals ( EXPLODED AAR ) ) { return BOOL ; } } } } return BOOL ; }
public void fail Engine ( String reason , @ Nullable Throwable failure ) { if ( fail Engine Lock . try Lock ( ) ) { store . inc Ref ( ) ; try { try { close No Lock ( STRING + reason + STRING ) ; } finally { if ( failed Engine != null ) { logger . debug ( STRING , reason , failure ) ; return ; } logger . warn ( STRING , failure , reason ) ; failed Engine = ( failure != null ) ? failure : new Illegal State Exception ( reason ) ; if ( Lucene . is Corruption Exception ( failure ) ) { try { store . mark Store Corrupted ( new IO Exception ( STRING + reason + STRING , Exceptions Helper . unwrap Corruption ( failure ) ) ) ; } catch ( IO Exception e ) { logger . warn ( STRING , e ) ; } } failed Engine Listener . on Failed Engine ( shard Id , reason , failure ) ; } } catch ( Throwable t ) { logger . warn ( STRING , t ) ; } finally { store . dec Ref ( ) ; } } else { logger . debug ( STRING , reason , failure ) ; } }
public void clear ( ) { values . clear ( ) ; }
@ Override default Completable Future < Optional Int > max Int ( final To Int Function < ? super T > fn ) { return Completable Future . supply Async ( null , get Exec ( ) ) ; }
private void add VNX File Storage System Into Cache ( String storage System URI , Distributed Queue Item Processed Callback call Back ) { if ( String Utils . is Not Empty ( storage System URI ) ) { VNXFILE CACHE . put ( storage System URI , call Back ) ; } }
void reset To Preferred Sizes ( int available Size ) { int [ ] test Sizes = get Preferred Sizes ( ) ; int total Size = NUM ; for ( int counter = NUM ; counter < NUM ; counter ++ ) { if ( test Sizes [ counter ] != - NUM ) { total Size += test Sizes [ counter ] ; } } if ( total Size > available Size ) { test Sizes = get Minimum Sizes ( ) ; total Size = NUM ; for ( int counter = NUM ; counter < NUM ; counter ++ ) { if ( test Sizes [ counter ] != - NUM ) { total Size += test Sizes [ counter ] ; } } } set Sizes ( test Sizes ) ; distribute Space ( available Size - total Size , BOOL ) ; }
@ Override public byte [ ] decode ( byte [ ] data ) throws Exception { if ( data [ NUM ] == NUM && data [ NUM ] == NUM && data [ NUM ] == NUM ) { return data ; } int buf Size = NUM ; Fast Byte Array Output Stream bos = null ; boolean failed = BOOL ; final int org Size = data . length ; if ( data != null ) { while ( failed ) { final Inflater inf = new Inflater ( ) ; inf . set Input ( data ) ; final int size = data . length ; bos = new Fast Byte Array Output Stream ( size ) ; if ( size < buf Size ) { buf Size = size ; } final byte [ ] buf = new byte [ buf Size ] ; int count ; try { while ( ! inf . finished ( ) ) { count = inf . inflate ( buf ) ; bos . write ( buf , NUM , count ) ; if ( inf . get Remaining ( ) == NUM ) { break ; } } failed = BOOL ; } catch ( final Exception ee ) { Log Writer . write Log ( STRING + ee ) ; failed = BOOL ; has Error = BOOL ; if ( data . length == org Size && data . length > NUM ) { failed = BOOL ; } else if ( data . length > NUM ) { final byte [ ] new Data = new byte [ data . length - NUM ] ; System . arraycopy ( data , NUM , new Data , NUM , data . length - NUM ) ; data = new Data ; } else { failed = BOOL ; } } } data = bos . to Byte Array ( ) ; return apply Predictor ( predictor , data , colors , bits Per Component , columns ) ; } return data ; }
public boolean is Processing ( ) { return m Running . get ( ) ; }
public Criteria or ( ) { Criteria criteria = create Criteria Internal ( ) ; ored Criteria . add ( criteria ) ; return criteria ; }
private static Input Stream Reader decompress With 7 Zip ( final String archive Path ) throws Configuration Exception { PATH PROGRAM 7ZIP = ( String ) config . get Config Parameter ( Configuration Keys . PATH PROGRAM 7ZIP ) ; if ( PATH PROGRAM 7ZIP == null ) { throw Error Factory . create Configuration Exception ( Error Keys . CONFIGURATION PARAMETER UNDEFINED ) ; } try { Runtime runtime = Runtime . get Runtime ( ) ; Process p = runtime . exec ( PATH PROGRAM 7ZIP + STRING + archive Path + STRING ) ; return new Input Stream Reader ( p . get Input Stream ( ) , WIKIPEDIA ENCODING ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
public void make Immutable ( ) { if ( is Mutable ) { is Mutable = BOOL ; } }
private final Object arena Exchange ( Object item , boolean timed , long ns ) { Node [ ] a = arena ; Node p = participant . get ( ) ; for ( int i = p . index ; ; ) { int b , m , c ; long j ; Node q = ( Node ) U . get Object Volatile ( a , j = ( i << ASHIFT ) + ABASE ) ; if ( q != null && U . compare And Swap Object ( a , j , q , null ) ) { Object v = q . item ; q . match = item ; Thread w = q . parked ; if ( w != null ) U . unpark ( w ) ; return v ; } else if ( i <= ( m = ( b = bound ) & MMASK ) && q == null ) { p . item = item ; if ( U . compare And Swap Object ( a , j , null , p ) ) { long end = ( timed && m == NUM ) ? System . nano Time ( ) + ns : NUM ; Thread t = Thread . current Thread ( ) ; for ( int h = p . hash , spins = SPINS ; ; ) { Object v = p . match ; if ( v != null ) { U . put Ordered Object ( p , MATCH , null ) ; p . item = null ; p . hash = h ; return v ; } else if ( spins > NUM ) { h ^= h << NUM ; h ^= h > > > NUM ; h ^= h << NUM ; if ( h == NUM ) h = SPINS | ( int ) t . get Id ( ) ; else if ( h < NUM && ( -- spins & ( ( SPINS > > > NUM ) - NUM ) ) == NUM ) Thread . yield ( ) ; } else if ( U . get Object Volatile ( a , j ) != p ) spins = SPINS ; else if ( ! t . is Interrupted ( ) && m == NUM && ( ! timed || ( ns = end - System . nano Time ( ) ) > NUM ) ) { U . put Object ( t , BLOCKER , this ) ; p . parked = t ; if ( U . get Object Volatile ( a , j ) == p ) U . park ( BOOL , ns ) ; p . parked = null ; U . put Object ( t , BLOCKER , null ) ; } else if ( U . get Object Volatile ( a , j ) == p && U . compare And Swap Object ( a , j , p , null ) ) { if ( m != NUM ) U . compare And Swap Int ( this , BOUND , b , b + SEQ - NUM ) ; p . item = null ; p . hash = h ; i = p . index >>>= NUM ; if ( Thread . interrupted ( ) ) return null ; if ( timed && m == NUM && ns <= NUM ) return TIMED OUT ; break ; } } } else p . item = null ; } else { if ( p . bound != b ) { p . bound = b ; p . collides = NUM ; i = ( i != m || m == NUM ) ? m : m - NUM ; } else if ( ( c = p . collides ) < m || m == FULL || ! U . compare And Swap Int ( this , BOUND , b , b + SEQ + NUM ) ) { p . collides = c + NUM ; i = ( i == NUM ) ? m : i - NUM ; } else i = m + NUM ; p . index = i ; } } }
public void send ( String data ) throws IO Exception { Datagram Packet dp = new Datagram Packet ( data . get Bytes ( ) , data . length ( ) , multicast Group ) ; datagram Socket . send ( dp ) ; }
private void remove Stale Range References ( ) { remove Stale References ( range Reference Queue , ranges ) ; }
private boolean is Exported ( URI id , List < URI > exported Volumes ) { return exported Volumes . contains ( id ) ; }
private String fix Monitor Links ( String fix String , String dump Name ) { if ( fix String . index Of ( STRING ) > NUM ) { fix String = fix String . replace All ( STRING , STRING + dump Name + STRING ) ; } return ( fix String ) ; }
protected static Test Dimension Config build Standard Dimension Config ( Test Api Dimension Name dimension Name ) { return new Test Dimension Config ( dimension Name , dimension Name . as Name ( ) , get Default Key Value Store ( dimension Name ) , get Default Search Provider ( ) , get Default Fields ( ) , get Default Fields ( ) ) ; }
public String to String ( ) { String Buffer sb = new String Buffer ( STRING ) ; if ( type != SET CONSTRAINTS ) { sb . append ( type == AS IS ? STRING : STRING ) ; } sb . append ( loader ) ; sb . append ( STRING ) ; for ( int i = NUM ; i < context Elements . length ; i ++ ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( context Elements [ i ] ) ; } if ( principals == null ) { sb . append ( STRING ) ; } else { sb . append ( STRING ) ; for ( int i = NUM ; i < principals . length ; i ++ ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( principals [ i ] ) ; } sb . append ( STRING ) ; } for ( int i = NUM ; i < permissions . length ; i ++ ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( permissions [ i ] ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public synchronized void cache Reposts ( List < Long > new Repost Ids ) { Tree Set < Long > reposts = new Tree Set < > ( ) ; reposts . add All ( Longs . as List ( repost Cache . get ( ) ) ) ; reposts . add All ( new Repost Ids ) ; repost Cache . set ( Longs . to Array ( reposts ) ) ; }
public boolean is Navigation At Bottom ( ) { return ( m Smallest Width Dp >= NUM || m In Portrait ) ; }
protected final Class < ? > define Class ( String class Name , byte [ ] class Rep , int offset , int length ) throws Class Format Error { return define Class ( class Name , class Rep , offset , length , null ) ; }
public boolean rewrite Exif ( Byte Buffer buf , Collection < Exif Tag > tags ) throws IO Exception { Exif Modifier mod = null ; try { mod = new Exif Modifier ( buf , this ) ; for ( Exif Tag t : tags ) { mod . modify Tag ( t ) ; } return mod . commit ( ) ; } catch ( Exif Invalid Format Exception e ) { throw new IO Exception ( STRING + e ) ; } }
private void write Newline On Debug ( XML Stream Writer out ) throws XML Stream Exception { if ( LOG . is Debugging ( ) ) { out . write Characters ( STRING ) ; } }
public Request Handle put ( String url , Response Handler Interface response Handler ) { return put ( null , url , null , response Handler ) ; }
public Discretize ( Element discretize , Field Meta Info . Optype op Type , Array List < Attribute > field Defs ) throws Exception { super ( op Type , field Defs ) ; m field Name = discretize . get Attribute ( STRING ) ; m map Missing To = discretize . get Attribute ( STRING ) ; if ( m map Missing To != null && m map Missing To . length ( ) > NUM ) { m map Missing Defined = BOOL ; } m default Value = discretize . get Attribute ( STRING ) ; if ( m default Value != null && m default Value . length ( ) > NUM ) { m default Value Defined = BOOL ; } Node List db L = discretize . get Elements By Tag Name ( STRING ) ; for ( int i = NUM ; i < db L . get Length ( ) ; i ++ ) { Node db N = db L . item ( i ) ; if ( db N . get Node Type ( ) == Node . ELEMENT NODE ) { Element db E = ( Element ) db N ; Discretize Bin db = new Discretize Bin ( db E , m op Type ) ; m bins . add ( db ) ; } } if ( field Defs != null ) { set Up Field ( ) ; } }
private static String quad Tree ( final Map Tile a Tile ) { String Builder quad Key = new String Builder ( ) ; for ( int i = a Tile . zoom Level ; i > NUM ; i -- ) { int digit = NUM ; int mask = NUM << ( i - NUM ) ; if ( ( a Tile . x & mask ) != NUM ) digit += NUM ; if ( ( a Tile . y & mask ) != NUM ) digit += NUM ; quad Key . append ( digit ) ; } return quad Key . to String ( ) ; }
public static int [ ] concat All Int ( int [ ] ... arrays ) { int total Length = NUM ; final int sub Array Count = arrays . length ; for ( int i = NUM ; i < sub Array Count ; ++ i ) { total Length += arrays [ i ] . length ; } int [ ] result = Arrays . copy Of ( arrays [ NUM ] , total Length ) ; int offset = arrays [ NUM ] . length ; for ( int i = NUM ; i < sub Array Count ; ++ i ) { System . arraycopy ( arrays [ i ] , NUM , result , offset , arrays [ i ] . length ) ; offset += arrays [ i ] . length ; } return result ; }
public static double log 1 p ( double value ) { if ( USE JDK MATH ) { return STRICT MATH ? Strict Math . log 1 p ( value ) : Math . log 1 p ( value ) ; } if ( BOOL ) { if ( value == Double . POSITIVE INFINITY ) { return Double . POSITIVE INFINITY ; } double value Plus One = NUM + value ; if ( value Plus One == NUM ) { return value ; } else { return Fast Math . log ( value Plus One ) * ( value / ( value Plus One - NUM ) ) ; } } if ( value > - NUM ) { if ( value == Double . POSITIVE INFINITY ) { return Double . POSITIVE INFINITY ; } double value Plus One = NUM + value ; if ( value Plus One == NUM ) { return value ; } else if ( Math . abs ( value ) < NUM ) { double z = value / ( value + NUM ) ; double z2 = z * z ; return z * ( NUM + z2 * ( ( NUM / NUM ) + z2 * ( ( NUM / NUM ) + z2 * ( ( NUM / NUM ) + z2 * ( ( NUM / NUM ) + z2 * ( ( NUM / NUM ) ) ) ) ) ) ) ; } int value Plus One Bits Hi = ( int ) ( Double . double To Raw Long Bits ( value Plus One ) > > NUM ) & NUM ; int value Plus One Exp = ( value Plus One Bits Hi > > NUM ) - MAX DOUBLE EXPONENT ; int x Index = ( ( value Plus One Bits Hi << NUM ) > > > ( NUM - LOG BITS ) ) ; double z = ( value Plus One * two Pow Tab [ - value Plus One Exp - MIN DOUBLE EXPONENT ] ) * log X Inv Tab [ x Index ] - NUM ; z *= ( NUM - z * ( ( NUM / NUM ) - z * ( NUM / NUM ) ) ) ; return value Plus One Exp * LOG 2 + log X Log Tab [ x Index ] + ( z + ( value - ( value Plus One - NUM ) ) / value Plus One ) ; } else if ( value == - NUM ) { return Double . NEGATIVE INFINITY ; } else { return Double . Na N ; } }
public static long [ ] ones ( int bits ) { long [ ] v = new long [ ( ( bits - NUM ) > > > LONG LOG 2 SIZE ) + NUM ] ; final int fill Words = bits > > > LONG LOG 2 SIZE ; final int fill Bits = bits & LONG LOG 2 MASK ; Arrays . fill ( v , NUM , fill Words , LONG ALL BITS ) ; if ( fill Words < v . length ) { v [ v . length - NUM ] = ( NUM << fill Bits ) - NUM ; } return v ; }
private boolean check Current Key Age ( ) throws Number Format Exception { long current Token Key TS = Long . parse Long ( cached Token Keys Bundle . get Current Key Entry ( ) ) ; long now = System . current Time Millis ( ) ; long diff = now - current Token Key TS ; if ( diff >= key Rotation Interval In Msecs ) { return BOOL ; } return BOOL ; }
public final void push Context Node List ( DTM Iterator nl ) { m context Node Lists . push ( nl ) ; }
public void note ( Element e , String msg ) { messager . print Message ( Diagnostic . Kind . NOTE , msg , e ) ; }
public static Public Key generate Public Key ( String encoded Public Key ) { try { byte [ ] decoded Key = Base 64 . decode ( encoded Public Key , Base 64 . DEFAULT ) ; Key Factory key Factory = Key Factory . get Instance ( KEY FACTORY ALGORITHM ) ; return key Factory . generate Public ( new X509 Encoded Key Spec ( decoded Key ) ) ; } catch ( No Such Algorithm Exception e ) { throw new Runtime Exception ( e ) ; } catch ( Invalid Key Spec Exception e ) { Log . e ( TAG , STRING ) ; throw new Illegal Argument Exception ( e ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
public Trust Source add ( File trusted CA Pem File ) { if ( trusted CA Pem File == null ) { throw new Illegal Argument Exception ( STRING ) ; } String pem File Contents ; try { pem File Contents = Files . to String ( trusted CA Pem File , Charset . for Name ( STRING ) ) ; } catch ( IO Exception e ) { throw new Unchecked IO Exception ( STRING + trusted CA Pem File . get Absolute Path ( ) , e ) ; } return add ( pem File Contents ) ; }
String Vector process STRINGLIST ( Stylesheet Handler handler , String uri , String name , String raw Name , String value ) { String Tokenizer tokenizer = new String Tokenizer ( value , STRING ) ; int n Strings = tokenizer . count Tokens ( ) ; String Vector strings = new String Vector ( n Strings ) ; for ( int i = NUM ; i < n Strings ; i ++ ) { strings . add Element ( tokenizer . next Token ( ) ) ; } return strings ; }
private String checkfor Regex ( String a Regex Fragment ) { final String Builder result = new String Builder ( ) ; final String Character Iterator iterator = new String Character Iterator ( a Regex Fragment ) ; char character = iterator . current ( ) ; while ( character != Character Iterator . DONE ) { if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else { result . append ( character ) ; } character = iterator . next ( ) ; } return result . to String ( ) ; }
protected void draw Value Label ( Drawing Context context , Slice slice , double radius , Row row , int row Index ) { Comparable < ? > value = slice . end - slice . start ; Format format = get Value Format ( ) ; if ( ( format == null ) && ( value instanceof Number ) ) { format = Number Format . get Instance ( ) ; } String text = ( format != null ) ? format . format ( value ) : value . to String ( ) ; Color Mapper colors = get Value Color ( ) ; Paint paint = colors . get ( row Index ) ; Font font = get Value Font ( ) ; double font Size = font . get Size 2 D ( ) ; Location location = get Value Location ( ) ; double align X = get Value Alignment X ( ) ; double align Y = get Value Alignment Y ( ) ; double rotation = get Value Rotation ( ) ; double distance = get Value Distance ( ) ; if ( Math Utils . is Calculatable ( distance ) ) { distance *= font Size ; } else { distance = NUM ; } double radius Rel Outer = get Outer Radius ( ) ; double radius Rel Inner = get Inner Radius ( ) ; double radius Outer = radius * radius Rel Outer ; double radius Inner = radius * radius Rel Inner ; double distance V = distance ; double label Pos V ; if ( location == Location . NORTH ) { label Pos V = radius Outer + distance V ; } else if ( location == Location . SOUTH ) { label Pos V = Math . max ( radius Inner - distance V , NUM ) ; } else { double slice Height = radius Outer - radius Inner ; if ( NUM * distance >= slice Height ) { align Y = NUM ; distance V = NUM ; } label Pos V = radius Inner + distance V + align Y * ( slice Height - NUM * distance V ) ; } double sum = plot . get Sum ( row . get Source ( ) ) ; if ( sum == NUM ) { return ; } double slice Start Rel = slice . start / sum ; double slice End Rel = slice . end / sum ; double circumference = NUM * label Pos V * Math . PI ; double distance Rel H = distance / circumference ; double slice Width Rel = slice End Rel - slice Start Rel ; if ( NUM * distance Rel H >= slice Width Rel ) { align X = NUM ; distance Rel H = NUM ; } double label Pos Rel H = slice Start Rel + distance Rel H + align X * ( slice Width Rel - NUM * distance Rel H ) ; double start = plot . get Start ( ) ; double angle Start = Math . to Radians ( - start ) ; double direction = NUM ; if ( ! plot . is Clockwise ( ) ) { direction = - NUM ; } double angle = angle Start + direction * label Pos Rel H * NUM * Math . PI ; double dir X = Math . cos ( angle ) ; double dir Y = Math . sin ( angle ) ; Label label = new Label ( text ) ; label . set Alignment X ( NUM - NUM * dir X - NUM ) ; label . set Alignment Y ( NUM * dir Y + NUM ) ; label . set Rotation ( rotation ) ; label . set Color ( paint ) ; label . set Font ( font ) ; Dimension 2 D size Label = label . get Preferred Size ( ) ; double anchor X = NUM ; double anchor Y = NUM ; if ( location == Location . NORTH || location == Location . SOUTH ) { anchor X = dir X * size Label . get Width ( ) / NUM ; anchor Y = dir Y * size Label . get Height ( ) / NUM ; if ( location == Location . SOUTH ) { anchor X = - anchor X ; anchor Y = - anchor Y ; } } double x = label Pos V * dir X + anchor X - size Label . get Width ( ) / NUM ; double y = label Pos V * dir Y + anchor Y - size Label . get Height ( ) / NUM ; double w = size Label . get Width ( ) ; double h = size Label . get Height ( ) ; label . set Bounds ( x , y , w , h ) ; label . draw ( context ) ; }
public static void downto ( Float self , Number to , @ Closure Params ( First Param . class ) Closure closure ) { float to 1 = to . float Value ( ) ; if ( self >= to 1 ) { for ( float i = self ; i >= to 1 ; i -- ) { closure . call ( i ) ; } } else throw new Groovy Runtime Exception ( STRING + to + STRING + self + STRING ) ; }
public static Attribute Description object Class ( ) { return OBJECT CLASS ; }
public void add Key Value Comment ( String key Name , String value ) { int key Index ; if ( ( key Index = find Key Comment Index ( key Name ) ) < NUM ) { key Val Comments . add ( STRING + key Name + STRING + value + STRING ) ; return ; } log . warn ( STRING + key Name + STRING ) ; key Val Comments . set ( key Index , STRING + key Name + STRING + value + STRING ) ; }
private String is Input Checked ( String data Set , String value ) { if ( data Set != null && data Set . equals ( value ) ) { return STRING ; } return STRING ; }
public final void pop Sub Context List ( ) { m axes Iterator Stack . pop ( ) ; }
private Driver Task create Driver Task ( String task Type ) { String task ID = String . format ( STRING , HP 3 PAR Constants . DRIVER NAME , task Type , UUID . random UUID ( ) ) ; Driver Task task = new HP 3 PAR Driver Task ( task ID ) ; return task ; }
public static void write ( File file , Char Sequence data , Charset encoding , boolean append ) throws IO Exception { String str = data == null ? null : data . to String ( ) ; write String To File ( file , str , encoding , append ) ; }
public void store ( Element cat , List < String > trees ) { Catalog Tree Manager manager = Instance Manager . get Default ( jmri . Catalog Tree Manager . class ) ; cat . set Attribute ( STRING , STRING ) ; Iterator < String > iter = trees . iterator ( ) ; while ( iter . has Next ( ) ) { String sname = iter . next ( ) ; if ( sname == null ) { log . error ( STRING ) ; continue ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + sname ) ; } if ( sname . char At ( NUM ) != Catalog Tree . XML ) { continue ; } Catalog Tree ct = manager . get By System Name ( sname ) ; Element elem = new Element ( STRING ) ; elem . set Attribute ( STRING , sname ) ; String uname = ct . get User Name ( ) ; if ( uname != null ) { elem . set Attribute ( STRING , uname ) ; } store Node ( elem , ct . get Root ( ) ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + sname ) ; } cat . add Content ( elem ) ; } }
public boolean is Enabled ( ) { return enabled ; }
public Criteria create Criteria ( ) { Criteria criteria = create Criteria Internal ( ) ; if ( ored Criteria . size ( ) == NUM ) { ored Criteria . add ( criteria ) ; } return criteria ; }
public static boolean load Texture ( int gl Id , int file ) { Input Stream is = Resource . get Res Input Stream ( file ) ; Bitmap bitmap = null ; try { Bitmap Factory . Options opts = new Bitmap Factory . Options ( ) ; opts . in Scaled = BOOL ; bitmap = Bitmap Factory . decode Stream ( is , null , opts ) ; } catch ( Exception e ) { Log . e ( TAG , STRING + file , e ) ; return BOOL ; } finally { try { is . close ( ) ; } catch ( Exception e ) { Log . e ( TAG , STRING , e ) ; } } return load Texture ( gl Id , bitmap ) ; }
public static int roll 1 D 100 ( ) { return rand . next Int ( NUM ) + NUM ; }
public Zipfian Generator ( long min , long max , double zipfianconstant , double zetan ) { items = max - min + NUM ; base = min ; zipfianconstant = zipfianconstant ; theta = zipfianconstant ; zeta 2 theta = zeta ( NUM , theta ) ; alpha = NUM / ( NUM - theta ) ; zetan = zetan ; countforzeta = items ; eta = ( NUM - Math . pow ( NUM / items , NUM - theta ) ) / ( NUM - zeta 2 theta / zetan ) ; next Int ( ) ; }
public void remove Role ( Role Entity role ) { roles . remove ( role ) ; }
final boolean transfer After Cancelled Wait ( Node node ) { if ( compare And Set Wait Status ( node , Node . CONDITION , NUM ) ) { enq ( node ) ; return BOOL ; } while ( ! is On Sync Queue ( node ) ) Thread . yield ( ) ; return BOOL ; }
private Map process Event ( Match Result result ) { Map map = new Hash Map ( ) ; for ( int i = NUM ; i < result . group Count ( ) + NUM ; i ++ ) { Object key = matching Keywords . get ( i - NUM ) ; Object value = result . group ( i ) ; map . put ( key , value ) ; } return map ; }
public void add Extension ( String ext ) { exts . add ( ext . to Lower Case ( ) ) ; }
private void display Simple ( Print Stream output ) { output . println ( STRING ) ; for ( int j = NUM ; j < P ; j ++ ) { double [ ] a0 = new double [ N ] ; double [ ] a1 = new double [ N ] ; double [ ] a2 = new double [ N ] ; for ( int i = NUM ; i < N ; i ++ ) { a0 [ i ] = A [ i ] ; a1 [ i ] = C A [ i ] [ j ] ; a2 [ i ] = B [ i ] ; } double value = compute First Order ( a0 , a1 , a2 , N ) ; output . print ( value < NUM ? NUM : value ) ; if ( j < P - NUM ) { output . print ( STRING ) ; } } output . println ( ) ; output . println ( STRING ) ; for ( int j = NUM ; j < P ; j ++ ) { double [ ] a0 = new double [ N ] ; double [ ] a1 = new double [ N ] ; double [ ] a2 = new double [ N ] ; for ( int i = NUM ; i < N ; i ++ ) { a0 [ i ] = A [ i ] ; a1 [ i ] = C A [ i ] [ j ] ; a2 [ i ] = B [ i ] ; } double value = compute Total Order ( a0 , a1 , a2 , N ) ; output . print ( value < NUM ? NUM : value ) ; if ( j < P - NUM ) { output . print ( STRING ) ; } } output . println ( ) ; }
public boolean equals ( Object o ) { if ( o == this ) return BOOL ; if ( ! ( o instanceof M Bean Attribute Info ) ) return BOOL ; M Bean Attribute Info p = ( M Bean Attribute Info ) o ; return ( Objects . equals ( p . get Name ( ) , get Name ( ) ) && Objects . equals ( p . get Type ( ) , get Type ( ) ) && Objects . equals ( p . get Description ( ) , get Description ( ) ) && Objects . equals ( p . get Descriptor ( ) , get Descriptor ( ) ) && p . is Readable ( ) == is Readable ( ) && p . is Writable ( ) == is Writable ( ) && p . is Is ( ) == is Is ( ) ) ; }
protected boolean handle Directory ( File directory , String [ ] content Names ) throws Security Exception { boolean continue Wandering = BOOL ; for ( String child : content Names ) { boolean keep Going = handle Entry ( new File ( directory . get Absolute Path ( ) + File . separator , child ) ) ; if ( ! keep Going ) { continue Wandering = exhaustive Search ; if ( ! continue Wandering ) { break ; } } } return continue Wandering ; }
int size ( ) { return Integer . bit Count ( set ) ; }
public boolean has Next ( ) { return iterator . has Next ( ) ; }
public static double vector Distance ( double [ ] vec 1 , double [ ] vec 2 , double power , double one Over Power ) { double result = NUM ; if ( power == NUM ) { for ( int i = NUM ; i < vec 1 . length ; i ++ ) { result += vec 1 [ i ] - vec 2 [ i ] == NUM ? NUM : NUM ; } } else if ( power == NUM ) { for ( int i = NUM ; i < vec 1 . length ; i ++ ) { result += Math . abs ( vec 1 [ i ] - vec 2 [ i ] ) ; } } else if ( power == NUM ) { result = Math . sqrt ( dist Squared Cartesian ( vec 1 , vec 2 ) ) ; } else if ( power == Integer . MAX VALUE || Double . is Infinite ( power ) ) { for ( int i = NUM ; i < vec 1 . length ; i ++ ) { result = Math . max ( result , Math . max ( vec 1 [ i ] , vec 2 [ i ] ) ) ; } } else { for ( int i = NUM ; i < vec 1 . length ; i ++ ) { result += Math . pow ( vec 1 [ i ] - vec 2 [ i ] , power ) ; } result = Math . pow ( result , one Over Power ) ; } return result ; }
public static String format Number ( final long number ) { long divided = number ; final String Buffer sb = new String Buffer ( ) ; while ( divided > NUM ) { long rest = divided % NUM ; sb . insert ( NUM , STRING + String . format ( STRING , rest ) ) ; divided = divided / NUM ; } long rest = divided % NUM ; sb . insert ( NUM , rest ) ; return sb . to String ( ) ; }
private boolean is Subsumed ( String selector , Iterable < String > others ) { for ( String other : others ) { if ( subsumes ( other , selector ) ) { return BOOL ; } } return BOOL ; }
private void display Values ( ) { log ( STRING , Project . MSG INFO ) ; log ( STRING + this . spec ) ; log ( STRING + get Spec Absolute Path ( ) ) ; log ( STRING + get Serialized Spec Absolute Path ( ) ) ; log ( STRING + this . specdir ) ; log ( STRING + this . cup 2 srcdir ) ; log ( STRING + this . classpath ) ; log ( STRING + this . algorithm ) ; log ( STRING + this . verbose ) ; log ( STRING + this . parsetable ) ; log ( STRING ) ; }
private List < View > add View ( View view , List < View > cache ) { if ( cache == null ) { cache = new Linked List < View > ( ) ; } cache . add ( view ) ; return cache ; }
private boolean check Touching Min Target ( int index , Motion Event event ) { if ( is Touching Min Target ( index , event ) ) { last Touched Min = BOOL ; is Touching Min Target . add ( event . get Pointer Id ( index ) ) ; if ( ! min Animator . is Running ( ) ) { min Animator = get Min Target Animator ( BOOL ) ; min Animator . start ( ) ; } return BOOL ; } return BOOL ; }
public boolean is Canceled ( ) { if ( pane == null ) return BOOL ; Object v = pane . get Value ( ) ; return ( ( v != null ) && ( cancel Option . length == NUM ) && ( v . equals ( cancel Option [ NUM ] ) ) ) ; }
public int available Processors ( ) { return RVM Thread . available Processors ; }
public void update Debug ( Boolean debug , Boolean database , Boolean exception , Boolean tracing , Boolean dump , Boolean timer , Boolean implicit Access , Boolean query Usage ) throws Security Exception { check Write Access ( ) ; boolean has Access = Config Web Util . has Access ( config , Security Manager . TYPE DEBUGGING ) ; if ( ! has Access ) throw new Security Exception ( STRING ) ; Element debugging = get Root Element ( STRING ) ; if ( debug != null ) debugging . set Attribute ( STRING , Caster . to String ( debug . boolean Value ( ) ) ) ; else debugging . remove Attribute ( STRING ) ; if ( database != null ) debugging . set Attribute ( STRING , Caster . to String ( database . boolean Value ( ) ) ) ; else debugging . remove Attribute ( STRING ) ; if ( exception != null ) debugging . set Attribute ( STRING , Caster . to String ( exception . boolean Value ( ) ) ) ; else debugging . remove Attribute ( STRING ) ; if ( tracing != null ) debugging . set Attribute ( STRING , Caster . to String ( tracing . boolean Value ( ) ) ) ; else debugging . remove Attribute ( STRING ) ; if ( dump != null ) debugging . set Attribute ( STRING , Caster . to String ( dump . boolean Value ( ) ) ) ; else debugging . remove Attribute ( STRING ) ; if ( timer != null ) debugging . set Attribute ( STRING , Caster . to String ( timer . boolean Value ( ) ) ) ; else debugging . remove Attribute ( STRING ) ; if ( implicit Access != null ) debugging . set Attribute ( STRING , Caster . to String ( implicit Access . boolean Value ( ) ) ) ; else debugging . remove Attribute ( STRING ) ; if ( query Usage != null ) debugging . set Attribute ( STRING , Caster . to String ( query Usage . boolean Value ( ) ) ) ; else debugging . remove Attribute ( STRING ) ; }
public final static void debug ( String s ) { if ( DEBUG ) debug . println ( STRING + s ) ; }
public static final void write Long Array Xml ( long [ ] val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . to String ( N ) ) ; for ( int i = NUM ; i < N ; i ++ ) { out . start Tag ( null , STRING ) ; out . attribute ( null , STRING , Long . to String ( val [ i ] ) ) ; out . end Tag ( null , STRING ) ; } out . end Tag ( null , STRING ) ; }
public static < T extends Generic Entity > List < T > filter By Or ( List < T > values , List < ? extends Entity Condition > exprs ) { if ( values == null ) return null ; if ( Util Validate . is Empty ( exprs ) ) { return values ; } List < T > result = new Linked List < T > ( ) ; for ( T value : values ) { boolean include = BOOL ; for ( Entity Condition condition : exprs ) { include = condition . entity Matches ( value ) ; if ( include ) break ; } if ( include ) { result . add ( value ) ; } } return result ; }
private boolean check Touch Slop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL ; } final boolean check Horizontal = m Callback . get View Horizontal Drag Range ( child ) > NUM ; final boolean check Vertical = m Callback . get View Vertical Drag Range ( child ) > NUM ; if ( check Horizontal && check Vertical ) { return dx * dx + dy * dy > m Touch Slop * m Touch Slop ; } else if ( check Horizontal ) { return Math . abs ( dx ) > m Touch Slop ; } else if ( check Vertical ) { return Math . abs ( dy ) > m Touch Slop ; } return BOOL ; }
@ Override public RES next ( REQ req ) { write Trace Log ( req , middleware Name ) ; if ( predicate . test ( req ) ) { RES res = middleware . handle ( req , next ) ; write Trace Log ( res , middleware Name ) ; return res ; } else if ( next != null ) { RES res = ( RES ) next . next ( req ) ; write Trace Log ( res , middleware Name ) ; return res ; } else { return null ; } }
protected void read ( long offset , byte [ ] b ) throws IO Exception { rafile . seek ( offset ) ; if ( rafile . read ( b ) != b . length ) { throw new IO Exception ( STRING + get Path ( ) ) ; } }
public void run ( ) { final Fetcher Info info = Fetcher Info . get Fetcher Info ( ) ; try { fetchloop ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } finally { synchronized ( info . wait List ) { Thread me = Thread . current Thread ( ) ; for ( int i = NUM ; i < info . fetchers . length ; i ++ ) { if ( info . fetchers [ i ] == me ) { info . fetchers [ i ] = null ; info . num Fetchers -- ; } } } } }
public Ct Class make Annotation ( String name ) throws Runtime Exception { try { Ct Class cc = make Interface ( name , get ( STRING ) ) ; cc . set Modifiers ( cc . get Modifiers ( ) | Modifier . ANNOTATION ) ; return cc ; } catch ( Not Found Exception e ) { throw new Runtime Exception ( e . get Message ( ) , e ) ; } }
public void test Negate Math Context Negative ( ) { String a = STRING ; int a Scale = NUM ; int precision = NUM ; Rounding Mode rm = Rounding Mode . CEILING ; Math Context mc = new Math Context ( precision , rm ) ; String c = STRING ; int c Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal res = a Number . negate ( mc ) ; assert Equals ( STRING , c , res . to String ( ) ) ; assert Equals ( STRING , c Scale , res . scale ( ) ) ; }
public void add ( Node node ) { available Nodes . add ( node ) ; }
public void write ( Output Stream out ) throws IO Exception { Data Output Stream data Out = new Data Output Stream ( out ) ; data Out . write Short ( pool . size ( ) + NUM ) ; for ( Entry e : pool ) { e . write ( data Out ) ; } }
protected Foreign Key Constraint build Foreign Key Constraint ( List < String > fk Field Names , List < String > pk Field Names , Table Definition target Table , Database Platform platform ) { assert fk Field Names . size ( ) > NUM && fk Field Names . size ( ) == pk Field Names . size ( ) ; Foreign Key Constraint fk Constraint = new Foreign Key Constraint ( ) ; for ( int i = NUM ; i < fk Field Names . size ( ) ; i ++ ) { fk Constraint . get Source Fields ( ) . add ( fk Field Names . get ( i ) ) ; fk Constraint . get Target Fields ( ) . add ( pk Field Names . get ( i ) ) ; } fk Constraint . set Target Table ( target Table . get Full Name ( ) ) ; String fk Field Name = fk Field Names . get ( NUM ) ; String name = build Foreign Key Constraint Name ( this . get Name ( ) , fk Field Name , platform . get Max Foreign Key Name Size ( ) , platform ) ; fk Constraint . set Name ( name ) ; return fk Constraint ; }
public static boolean is Rewritable Batch ( String query String , boolean no Backslash Escapes ) { Lex State state = Lex State . Normal ; char last Char = STRING ; boolean single Quotes = BOOL ; boolean ending Semicolon = BOOL ; char [ ] query = query String . to Char Array ( ) ; int query Length = query . length ; for ( int i = NUM ; i < query Length ; i ++ ) { if ( state == Lex State . Escape ) state = Lex State . String ; char car = query [ i ] ; switch ( car ) { case STRING : if ( state == Lex State . Normal && last Char == STRING ) state = Lex State . Slash Star Comment ; break ; case STRING : if ( state == Lex State . Slash Star Comment && last Char == STRING ) { state = Lex State . Normal ; } else if ( state == Lex State . Normal && last Char == STRING ) { state = Lex State . EOL Comment ; } break ; case STRING : if ( state == Lex State . Normal ) state = Lex State . EOL Comment ; break ; case STRING : if ( state == Lex State . Normal && last Char == STRING ) { state = Lex State . EOL Comment ; } break ; case STRING : if ( state == Lex State . Normal ) { ending Semicolon = BOOL ; } break ; case STRING : if ( state == Lex State . EOL Comment ) { state = Lex State . Normal ; } break ; case STRING : if ( state == Lex State . Normal ) { state = Lex State . String ; single Quotes = BOOL ; } else if ( state == Lex State . String && ! single Quotes ) { state = Lex State . Normal ; } break ; case STRING : if ( state == Lex State . Normal ) { state = Lex State . String ; single Quotes = BOOL ; } else if ( state == Lex State . String && single Quotes ) { state = Lex State . Normal ; } break ; case STRING : if ( no Backslash Escapes ) { break ; } if ( state == Lex State . String ) state = Lex State . Escape ; break ; case STRING : if ( state == Lex State . Backtick ) { state = Lex State . Normal ; } else if ( state == Lex State . Normal ) { state = Lex State . Backtick ; } break ; default : if ( state == Lex State . Normal && ending Semicolon && ( ( byte ) car >= NUM ) ) { ending Semicolon = BOOL ; } break ; } last Char = car ; } return state != Lex State . EOL Comment && ! ending Semicolon ; }
private boolean zz Refill ( ) throws java . io . IO Exception { if ( zz Start Read > NUM ) { System . arraycopy ( zz Buffer , zz Start Read , zz Buffer , NUM , zz End Read - zz Start Read ) ; zz End Read -= zz Start Read ; zz Current Pos -= zz Start Read ; zz Marked Pos -= zz Start Read ; zz Pushback Pos -= zz Start Read ; zz Start Read = NUM ; } if ( zz Current Pos >= zz Buffer . length ) { char new Buffer [ ] = new char [ zz Current Pos * NUM ] ; System . arraycopy ( zz Buffer , NUM , new Buffer , NUM , zz Buffer . length ) ; zz Buffer = new Buffer ; } int num Read = zz Reader . read ( zz Buffer , zz End Read , zz Buffer . length - zz End Read ) ; if ( num Read < NUM ) { return BOOL ; } else { zz End Read += num Read ; return BOOL ; } }
public Server Builder ( Config config ) { Objects . require Non Null ( config ) ; config = config ; }
private static LDAP Filter create Substring Filter ( Substring Filter sf ) throws LDAP Exception , IO Exception { List < Object > anyo = sf . get Any ( ) ; Array List < Byte String > sub Any Elements = new Array List < > ( anyo . size ( ) ) ; for ( Object o : anyo ) { sub Any Elements . add ( Byte String Utility . convert Value ( o ) ) ; } if ( sf . get Initial ( ) == null && sub Any Elements . is Empty ( ) && sf . get Final ( ) == null ) { Localizable Message message = ERR LDAP FILTER DECODE NULL . get ( ) ; throw new LDAP Exception ( LDAP Result Code . PROTOCOL ERROR , message ) ; } return LDAP Filter . create Substring Filter ( sf . get Name ( ) , sf . get Initial ( ) == null ? null : Byte String Utility . convert Value ( sf . get Initial ( ) ) , sub Any Elements , sf . get Final ( ) == null ? null : Byte String Utility . convert Value ( sf . get Final ( ) ) ) ; }
public void test Compare Neg Neg 2 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; int b Sign = - NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; assert Equals ( NUM , a Number . compare To ( b Number ) ) ; }
@ Override protected void on Size Changed ( int w , int h , int oldw , int oldh ) { if ( ready Sent ) { set Scale And Center ( get Scale ( ) , get Center ( ) ) ; } }
protected void disown ( Abstract Node child ) throws Illegal State Exception { ensure Parentage ( child ) ; child . parent = null ; }
public String q Name 2 String ( Q Name q Name , boolean write NS ) { String prefix = null ; String namespace URI = q Name . get Namespace ( ) ; String local Part = q Name . get Local Part ( ) ; if ( local Part != null && local Part . length ( ) > NUM ) { int index = local Part . index Of ( STRING ) ; if ( index != - NUM ) { prefix = local Part . substring ( NUM , index ) ; if ( prefix . length ( ) > NUM && ! prefix . equals ( STRING ) ) { register Prefix For URI ( prefix , namespace URI ) ; local Part = local Part . substring ( index + NUM ) ; } else { prefix = null ; } } local Part = get Last Local Part ( local Part ) ; } if ( namespace URI . length ( ) == NUM ) { if ( write NS ) { String default NS = ns Stack . get Namespace URI ( STRING ) ; if ( default NS != null && default NS . length ( ) > NUM ) { register Prefix For URI ( STRING , STRING ) ; } } } else { prefix = get Prefix For URI ( namespace URI , q Name . get Preferred Prefix ( ) ) ; } if ( ( prefix == null ) || ( prefix . length ( ) == NUM ) ) return local Part ; return prefix + STRING + local Part ; }
public JSON Exception ( Throwable cause ) { super ( cause . get Message ( ) ) ; this . cause = cause ; }
@ Override public void close ( ) throws XML Stream Exception { log . log ( Level . FINE , STRING ) ; stream . close ( ) ; }
public void test Divide Round Half Up Neg 2 ( ) { String a = STRING ; int a Scale = NUM ; String b = STRING ; int b Scale = NUM ; String c = STRING ; int res Scale = - NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; Big Decimal result = a Number . divide ( b Number , res Scale , Big Decimal . ROUND HALF UP ) ; assert Equals ( STRING , c , result . to String ( ) ) ; assert Equals ( STRING , res Scale , result . scale ( ) ) ; }
@ Override public String read Line ( ) throws IO Exception { if ( this . pointer >= this . data . length - NUM ) { return null ; } else { final String Builder buf = new String Builder ( ) ; int c ; while ( ( c = read ( ) ) >= NUM ) { if ( ( c == NUM ) || ( c == NUM ) ) { if ( ( ( peek ( ) == NUM ) || ( peek ( ) == NUM ) ) && ( peek ( ) != c ) ) { read ( ) ; } break ; } buf . append ( ( char ) c ) ; } return buf . to String ( ) ; } }
protected static Map attr Set To Map ( Attr Set attr Set , boolean fetch Byte Values ) { Map attributes Map = new AM Hash Map ( fetch Byte Values ) ; if ( attr Set == null ) { return attributes Map ; } int attr Set Size = attr Set . size ( ) ; if ( ! fetch Byte Values ) { for ( int i = NUM ; i < attr Set Size ; i ++ ) { Attr attr = attr Set . element At ( i ) ; String values [ ] = attr . get String Values ( ) ; attributes Map . put ( attr . get Name ( ) , string Array To Set ( values ) ) ; } } else { for ( int i = NUM ; i < attr Set Size ; i ++ ) { Attr attr = attr Set . element At ( i ) ; attributes Map . put ( attr . get Name ( ) , attr . get Byte Values ( ) ) ; } } return attributes Map ; }
public void test Get Min CRL ( ) { X509 CRL Selector selector = new X509 CRL Selector ( ) ; assert Null ( STRING , selector . get Min CRL ( ) ) ; Big Integer min CRL = new Big Integer ( STRING ) ; selector . set Min CRL Number ( min CRL ) ; assert True ( STRING , min CRL . equals ( selector . get Min CRL ( ) ) ) ; }
public < E > E parse Response Data ( G Data Request req , Class < E > result Type ) throws IO Exception , Service Exception { Input Properties input Properties = new Client Input Properties ( req , result Type ) ; return parse Response Data ( req . get Parse Source ( ) , input Properties , result Type ) ; }
public void add Rtp Stream Listener ( Rtp Stream Listener rtp Stream Listener ) { m Rtp Stream Listener = rtp Stream Listener ; }
public synchronized byte [ ] to Byte Array ( ) { int remaining = count ; if ( remaining == NUM ) { return EMPTY BYTE ARRAY ; } byte [ ] newbuf = new byte [ remaining ] ; int pos = NUM ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; System . arraycopy ( buf , NUM , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == NUM ) { break ; } } return newbuf ; }
public void add Volumes To Consistency Group ( String cg Name , List < String > virtual Volume Names ) throws V Plex Api Exception { s logger . info ( STRING , base URI ) ; cg Mgr . add Volumes To Consistency Group ( cg Name , virtual Volume Names ) ; }
public void test Constructor Sign Bytes Positive 6 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , - NUM } ; int a Sign = NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public static boolean looks Like A Font Style ( String val ) { return FONT STYLES . index Of ( val ) >= NUM ; }
public static void dump Cursor ( I Cursor cursor , int max Column Width ) { String Builder builder = new String Builder ( STRING ) ; dump Cursor ( cursor , max Column Width , builder ) ; Logger . d ( Logger . LOG TAG , builder . to String ( ) ) ; }
static int compute Valid Levels ( long bit Pattern ) { return Long . bit Count ( bit Pattern ) ; }
public static void run Under Lock ( Reentrant Lock lock , Runnable runnable ) { lock . lock ( ) ; try { runnable . run ( ) ; } finally { lock . unlock ( ) ; } }
private static boolean date By Month ( Date Time Formatter Builder bld , Collection < Date Time Field Type > fields , boolean extended , boolean strict ISO ) { boolean reduced Prec = BOOL ; if ( fields . remove ( Date Time Field Type . year ( ) ) ) { bld . append ( year Element ( ) ) ; if ( fields . remove ( Date Time Field Type . month Of Year ( ) ) ) { if ( fields . remove ( Date Time Field Type . day Of Month ( ) ) ) { append Separator ( bld , extended ) ; bld . append Month Of Year ( NUM ) ; append Separator ( bld , extended ) ; bld . append Day Of Month ( NUM ) ; } else { bld . append Literal ( STRING ) ; bld . append Month Of Year ( NUM ) ; reduced Prec = BOOL ; } } else { if ( fields . remove ( Date Time Field Type . day Of Month ( ) ) ) { check Not Strict ISO ( fields , strict ISO ) ; bld . append Literal ( STRING ) ; bld . append Literal ( STRING ) ; bld . append Day Of Month ( NUM ) ; } else { reduced Prec = BOOL ; } } } else if ( fields . remove ( Date Time Field Type . month Of Year ( ) ) ) { bld . append Literal ( STRING ) ; bld . append Literal ( STRING ) ; bld . append Month Of Year ( NUM ) ; if ( fields . remove ( Date Time Field Type . day Of Month ( ) ) ) { append Separator ( bld , extended ) ; bld . append Day Of Month ( NUM ) ; } else { reduced Prec = BOOL ; } } else if ( fields . remove ( Date Time Field Type . day Of Month ( ) ) ) { bld . append Literal ( STRING ) ; bld . append Literal ( STRING ) ; bld . append Literal ( STRING ) ; bld . append Day Of Month ( NUM ) ; } return reduced Prec ; }
@ Override public int insert ( String elem ) { int first Index = ( int ) ( elem . char At ( NUM ) - STRING ) ; int last Index = ( int ) ( elem . char At ( elem . length ( ) - NUM ) - STRING ) ; storage [ first Index * NUM + last Index ] = elem ; return NUM ; }
public void clear Movement Data ( ) { path Sprites = new Array List < Step Sprite > ( ) ; movement Target = null ; check Fo V Hex Image Cache Clear ( ) ; repaint ( ) ; refresh Move Vectors ( ) ; }
public void thread Record Failure ( Throwable t ) { thread Failure . compare And Set ( null , t ) ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
protected Boolean replay Completion ( Participant participant ) throws Illegal State Exception { if ( ! replay Stack . contains ( participant ) ) { replay Stack . push ( participant ) ; } return committed ; }
public static < V > boolean add Distinct Entry ( List < V > source List , V entry ) { return ( source List != null && ! source List . contains ( entry ) ) ? source List . add ( entry ) : BOOL ; }
public void test Decoder 7 ( ) { boolean res ; String original App Id Name = m App Id Name ; int original Content Type Value = m Content Type Value ; Random rd = new Random ( ) ; for ( int i = NUM ; i < OMA CONTENT TYPE NAMES . length ; i ++ ) { m Content Type Name = OMA CONTENT TYPE NAMES [ i ] ; byte [ ] pdu = create PDU ( NUM ) ; Wsp Type Decoder pdu Decoder = new Wsp Type Decoder ( pdu ) ; res = pdu Decoder . decode Content Type ( m Wsp Content Type Start ) ; assert True ( res ) ; Log . d ( LOG TAG , STRING + m Content Type Name + STRING + pdu Decoder . get Value String ( ) + STRING ) ; assert True ( m Content Type Name . equals ( pdu Decoder . get Value String ( ) ) ) ; } m App Id Name = original App Id Name ; m Content Type Value = original Content Type Value ; }
public void shutdown Now ( ) { shutdown = BOOL ; final Future < ? > f = engine Future . get ( ) ; if ( f != null ) { if ( log . is Info Enabled ( ) ) log . info ( STRING + this ) ; f . cancel ( BOOL ) ; } final Executor Service s = engine Service . get ( ) ; if ( s != null ) { if ( log . is Info Enabled ( ) ) log . info ( STRING + this ) ; s . shutdown Now ( ) ; } final Http Client cm = client Connection Manager Ref . get ( ) ; if ( cm != null ) { if ( log . is Info Enabled ( ) ) log . info ( STRING + this ) ; try { cm . stop ( ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; } } for ( Abstract Running Query q : running Queries . values ( ) ) { q . cancel ( BOOL ) ; } priority Queue . clear ( ) ; deadline Queue . clear ( ) ; engine Future . set ( null ) ; engine Service . set ( null ) ; client Connection Manager Ref . set ( null ) ; }
static public void add Notification Listener ( JMX Connector jmx Connector , Class < ? > mbean Class , Notification Listener notification Listener ) throws Instance Not Found Exception , Exception { M Bean Server Connection mbsc = jmx Connector . get M Bean Server Connection ( ) ; Object Name object Name = generate M Bean Object Name ( mbean Class ) ; mbsc . add Notification Listener ( object Name , notification Listener , null , null ) ; }
protected String to HTML ( String s ) { String result ; result = s ; result = result . replace All ( STRING , STRING ) ; result = result . replace All ( STRING , STRING ) ; result = result . replace All ( STRING , STRING ) ; result = result . replace All ( STRING , STRING ) ; result = result . replace All ( STRING , STRING ) ; return result ; }
@ Override public synchronized void clear ( ) { File [ ] files = m Root Directory . list Files ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } m Entries . clear ( ) ; m Total Size = NUM ; Volley Log . d ( STRING ) ; }
protected void normalize Scores ( ) { double hub ssum = NUM ; double auth ssum = NUM ; for ( V v : graph . get Vertices ( ) ) { double hub val = get Output Value ( v ) . hub ; double auth val = get Output Value ( v ) . authority ; hub ssum += ( hub val * hub val ) ; auth ssum += ( auth val * auth val ) ; } hub ssum = Math . sqrt ( hub ssum ) ; auth ssum = Math . sqrt ( auth ssum ) ; for ( V v : graph . get Vertices ( ) ) { HITS . Scores values = get Output Value ( v ) ; set Output Value ( v , new HITS . Scores ( values . hub / hub ssum , values . authority / auth ssum ) ) ; } }
public static int absolute Max ( int [ ] int Array ) { int max = Integer . MIN VALUE ; for ( int i = NUM ; i < int Array . length ; i ++ ) { if ( Math . abs ( int Array [ i ] ) > max && int Array [ i ] != NUM ) { max = int Array [ i ] ; } } return max == Integer . MIN VALUE ? NUM : max ; }
private boolean do Acquire Nanos ( long arg , long nanos Timeout ) throws Interrupted Exception { if ( nanos Timeout <= NUM ) return BOOL ; final long deadline = System . nano Time ( ) + nanos Timeout ; final Node node = add Waiter ( Node . EXCLUSIVE ) ; boolean failed = BOOL ; try { for ( ; ; ) { final Node p = node . predecessor ( ) ; if ( p == head && try Acquire ( arg ) ) { set Head ( node ) ; p . next = null ; failed = BOOL ; return BOOL ; } nanos Timeout = deadline - System . nano Time ( ) ; if ( nanos Timeout <= NUM ) return BOOL ; if ( should Park After Failed Acquire ( p , node ) && nanos Timeout > spin For Timeout Threshold ) Lock Support . park Nanos ( this , nanos Timeout ) ; if ( Thread . interrupted ( ) ) throw new Interrupted Exception ( ) ; } } finally { if ( failed ) cancel Acquire ( node ) ; } }
boolean has Min Feature Count ( String feature ) { if ( min Feature Count == NUM ) return BOOL ; Set < Integer > ids = clipped Feature Index . get ( feature ) ; if ( ids == null ) return BOOL ; return ids . size ( ) >= min Feature Count ; }
void mutate ( ) { do { int i Bit ; do { i Bit = m random . next Int ( m n Nodes * m n Nodes ) ; } while ( is Square ( i Bit ) ) ; m bits [ i Bit ] = ! m bits [ i Bit ] ; } while ( has Cycles ( ) ) ; calc Score ( ) ; }
public void put ( E e ) throws Interrupted Exception { check Not Null ( e ) ; final Reentrant Lock lock = this . lock ; lock . lock Interruptibly ( ) ; try { while ( count == items . length ) not Full . await ( ) ; enqueue ( e ) ; } finally { lock . unlock ( ) ; } }
private void delete Comments ( Span Manager sm ) { int start = NUM ; while ( ( start = sm . index Of ( STRING , start ) ) != - NUM ) { int end = sm . index Of ( STRING , start + NUM ) + NUM ; if ( end == - NUM + NUM ) { end = sm . length ( ) ; } try { if ( line Separator . equals ( sm . substring ( start - line Separator . length ( ) , start ) ) && line Separator . equals ( sm . substring ( end , end + line Separator . length ( ) ) ) ) { end += line Separator . length ( ) ; } } catch ( Index Out Of Bounds Exception e ) { } sm . delete ( start , end ) ; } }
Date Time Parse Context ( Date Time Formatter formatter ) { super ( ) ; this . formatter = formatter ; parsed . add ( new Parsed ( ) ) ; }
public static boolean is Network Type Cellular ( String network Type ) { return network Type . equals ( STRING ) ; }
private void define Internal Frame Close Buttons ( UI Defaults d ) { String p = STRING ; String c = PAINTER PREFIX + STRING ; d . put ( p + STRING , STRING ) ; d . put ( p + STRING , new Title Pane Close Button Window Not Focused State ( ) ) ; d . put ( p + STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Close Button Painter . Which . BACKGROUND DISABLED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Close Button Painter . Which . BACKGROUND ENABLED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Close Button Painter . Which . BACKGROUND MOUSEOVER ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Close Button Painter . Which . BACKGROUND PRESSED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Close Button Painter . Which . BACKGROUND ENABLED WINDOWNOTFOCUSED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Close Button Painter . Which . BACKGROUND MOUSEOVER ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Close Button Painter . Which . BACKGROUND PRESSED WINDOWNOTFOCUSED ) ) ; d . put ( p + STRING , new Sea Glass Icon ( p , STRING , NUM , NUM ) ) ; }
private void modify ( Storage Port port , String port Network Id ) { port . set Port Network Id ( port Network Id ) ; db Client . persist Object ( port ) ; modified Storage Ports List . add ( port ) ; }
public boolean is ( String word ) { return m Words . contains ( word . to Lower Case ( ) ) ; }
public static final String remove Multiple Spaces And Returns ( final String data ) { final String Builder all data = new String Builder ( data ) ; int i = NUM ; while ( i < all data . length ( ) ) { if ( ( ( all data . char At ( i ) == STRING ) && ( all data . char At ( i - NUM ) == STRING ) ) || ( ( all data . char At ( i ) == Character . LINE SEPARATOR ) && ( all data . char At ( i - NUM ) == Character . LINE SEPARATOR ) ) ) { all data . delete Char At ( i ) ; } else { i ++ ; } } return all data . to String ( ) ; }
public void remove Listener ( Connectable Device Listener listener ) { listeners . remove ( listener ) ; }
protected boolean read Attributes ( Data Input Stream d , int attributes count , attribute info [ ] ai ) throws IO Exception { attribute info a = null ; int i ; int j ; long len ; String s ; for ( i = NUM ; i < attributes count ; i ++ ) { j = d . read Unsigned Short ( ) ; len = d . read Int ( ) & NUM ; s = ( ( CONSTANT Utf 8 info ) ( constant pool [ j ] ) ) . convert ( ) ; if ( s . compare To ( attribute info . Source File ) == NUM ) { Source File attribute sa = new Source File attribute ( ) ; sa . sourcefile index = d . read Unsigned Short ( ) ; a = ( attribute info ) sa ; } else if ( s . compare To ( attribute info . Constant Value ) == NUM ) { Constant Value attribute ca = new Constant Value attribute ( ) ; ca . constantvalue index = d . read Unsigned Short ( ) ; a = ( attribute info ) ca ; } else if ( s . compare To ( attribute info . Code ) == NUM ) { Code attribute ca = new Code attribute ( ) ; ca . max stack = d . read Unsigned Short ( ) ; ca . max locals = d . read Unsigned Short ( ) ; ca . code length = d . read Int ( ) & NUM ; ca . code = new byte [ ( int ) ca . code length ] ; d . read ( ca . code ) ; ca . exception table length = d . read Unsigned Short ( ) ; ca . exception table = new exception table entry [ ca . exception table length ] ; int k ; exception table entry e ; for ( k = NUM ; k < ca . exception table length ; k ++ ) { e = new exception table entry ( ) ; e . start pc = d . read Unsigned Short ( ) ; e . end pc = d . read Unsigned Short ( ) ; e . handler pc = d . read Unsigned Short ( ) ; e . catch type = d . read Unsigned Short ( ) ; ca . exception table [ k ] = e ; } ca . attributes count = d . read Unsigned Short ( ) ; ca . attributes = new attribute info [ ca . attributes count ] ; read Attributes ( d , ca . attributes count , ca . attributes ) ; a = ( attribute info ) ca ; } else if ( s . compare To ( attribute info . Exceptions ) == NUM ) { Exception attribute ea = new Exception attribute ( ) ; ea . number of exceptions = d . read Unsigned Short ( ) ; if ( ea . number of exceptions > NUM ) { int k ; ea . exception index table = new int [ ea . number of exceptions ] ; for ( k = NUM ; k < ea . number of exceptions ; k ++ ) ea . exception index table [ k ] = d . read Unsigned Short ( ) ; } a = ( attribute info ) ea ; } else if ( s . compare To ( attribute info . Line Number Table ) == NUM ) { Line Number Table attribute la = new Line Number Table attribute ( ) ; la . line number table length = d . read Unsigned Short ( ) ; int k ; line number table entry e ; la . line number table = new line number table entry [ la . line number table length ] ; for ( k = NUM ; k < la . line number table length ; k ++ ) { e = new line number table entry ( ) ; e . start pc = d . read Unsigned Short ( ) ; e . line number = d . read Unsigned Short ( ) ; la . line number table [ k ] = e ; } a = ( attribute info ) la ; } else if ( s . compare To ( attribute info . Local Variable Table ) == NUM ) { Local Variable Table attribute la = new Local Variable Table attribute ( ) ; la . local variable table length = d . read Unsigned Short ( ) ; int k ; local variable table entry e ; la . local variable table = new local variable table entry [ la . local variable table length ] ; for ( k = NUM ; k < la . local variable table length ; k ++ ) { e = new local variable table entry ( ) ; e . start pc = d . read Unsigned Short ( ) ; e . length = d . read Unsigned Short ( ) ; e . name index = d . read Unsigned Short ( ) ; e . descriptor index = d . read Unsigned Short ( ) ; e . index = d . read Unsigned Short ( ) ; la . local variable table [ k ] = e ; } a = ( attribute info ) la ; } else if ( s . compare To ( attribute info . Local Variable Type Table ) == NUM ) { Local Variable Type Table attribute la = new Local Variable Type Table attribute ( ) ; la . local variable type table length = d . read Unsigned Short ( ) ; int k ; local variable type table entry e ; la . local variable type table = new local variable type table entry [ la . local variable type table length ] ; for ( k = NUM ; k < la . local variable type table length ; k ++ ) { e = new local variable type table entry ( ) ; e . start pc = d . read Unsigned Short ( ) ; e . length = d . read Unsigned Short ( ) ; e . name index = d . read Unsigned Short ( ) ; e . signature index = d . read Unsigned Short ( ) ; e . index = d . read Unsigned Short ( ) ; la . local variable type table [ k ] = e ; } a = ( attribute info ) la ; } else if ( s . compare To ( attribute info . Synthetic ) == NUM ) { Synthetic attribute ia = new Synthetic attribute ( ) ; a = ( attribute info ) ia ; } else if ( s . compare To ( attribute info . Signature ) == NUM ) { Signature attribute ia = new Signature attribute ( ) ; ia . signature index = d . read Unsigned Short ( ) ; a = ( attribute info ) ia ; } else if ( s . compare To ( attribute info . Deprecated ) == NUM ) { Deprecated attribute da = new Deprecated attribute ( ) ; a = ( attribute info ) da ; } else if ( s . compare To ( attribute info . Enclosing Method ) == NUM ) { Enclosing Method attribute ea = new Enclosing Method attribute ( ) ; ea . class index = d . read Unsigned Short ( ) ; ea . method index = d . read Unsigned Short ( ) ; a = ( attribute info ) ea ; } else if ( s . compare To ( attribute info . Inner Classes ) == NUM ) { Inner Classes attribute ia = new Inner Classes attribute ( ) ; ia . inner classes length = d . read Unsigned Short ( ) ; ia . inner classes = new inner class entry [ ia . inner classes length ] ; for ( int k = NUM ; k < ia . inner classes length ; k ++ ) { inner class entry e = new inner class entry ( ) ; e . inner class index = d . read Unsigned Short ( ) ; e . outer class index = d . read Unsigned Short ( ) ; e . name index = d . read Unsigned Short ( ) ; e . access flags = d . read Unsigned Short ( ) ; ia . inner classes [ k ] = e ; } a = ( attribute info ) ia ; } else if ( s . compare To ( attribute info . Runtime Visible Annotations ) == NUM ) { Runtime Visible Annotations attribute ra = new Runtime Visible Annotations attribute ( ) ; ra . number of annotations = d . read Unsigned Short ( ) ; ra . annotations = new annotation [ ra . number of annotations ] ; for ( int k = NUM ; k < ra . number of annotations ; k ++ ) { annotation annot = new annotation ( ) ; annot . type index = d . read Unsigned Short ( ) ; annot . num element value pairs = d . read Unsigned Short ( ) ; annot . element value pairs = read Element Values ( annot . num element value pairs , d , BOOL , NUM ) ; ra . annotations [ k ] = annot ; } a = ( attribute info ) ra ; } else if ( s . compare To ( attribute info . Runtime Invisible Annotations ) == NUM ) { Runtime Invisible Annotations attribute ra = new Runtime Invisible Annotations attribute ( ) ; ra . number of annotations = d . read Unsigned Short ( ) ; ra . annotations = new annotation [ ra . number of annotations ] ; for ( int k = NUM ; k < ra . number of annotations ; k ++ ) { annotation annot = new annotation ( ) ; annot . type index = d . read Unsigned Short ( ) ; annot . num element value pairs = d . read Unsigned Short ( ) ; annot . element value pairs = read Element Values ( annot . num element value pairs , d , BOOL , NUM ) ; ra . annotations [ k ] = annot ; } a = ( attribute info ) ra ; } else if ( s . compare To ( attribute info . Runtime Visible Parameter Annotations ) == NUM ) { Runtime Visible Parameter Annotations attribute ra = new Runtime Visible Parameter Annotations attribute ( ) ; ra . num parameters = d . read Unsigned Byte ( ) ; ra . parameter annotations = new parameter annotation [ ra . num parameters ] ; for ( int x = NUM ; x < ra . num parameters ; x ++ ) { parameter annotation p Annot = new parameter annotation ( ) ; p Annot . num annotations = d . read Unsigned Short ( ) ; p Annot . annotations = new annotation [ p Annot . num annotations ] ; for ( int k = NUM ; k < p Annot . num annotations ; k ++ ) { annotation annot = new annotation ( ) ; annot . type index = d . read Unsigned Short ( ) ; annot . num element value pairs = d . read Unsigned Short ( ) ; annot . element value pairs = read Element Values ( annot . num element value pairs , d , BOOL , NUM ) ; p Annot . annotations [ k ] = annot ; } ra . parameter annotations [ x ] = p Annot ; } a = ( attribute info ) ra ; } else if ( s . compare To ( attribute info . Runtime Invisible Parameter Annotations ) == NUM ) { Runtime Invisible Parameter Annotations attribute ra = new Runtime Invisible Parameter Annotations attribute ( ) ; ra . num parameters = d . read Unsigned Byte ( ) ; ra . parameter annotations = new parameter annotation [ ra . num parameters ] ; for ( int x = NUM ; x < ra . num parameters ; x ++ ) { parameter annotation p Annot = new parameter annotation ( ) ; p Annot . num annotations = d . read Unsigned Short ( ) ; p Annot . annotations = new annotation [ p Annot . num annotations ] ; for ( int k = NUM ; k < p Annot . num annotations ; k ++ ) { annotation annot = new annotation ( ) ; annot . type index = d . read Unsigned Short ( ) ; annot . num element value pairs = d . read Unsigned Short ( ) ; annot . element value pairs = read Element Values ( annot . num element value pairs , d , BOOL , NUM ) ; p Annot . annotations [ k ] = annot ; } ra . parameter annotations [ x ] = p Annot ; } a = ( attribute info ) ra ; } else if ( s . compare To ( attribute info . Annotation Default ) == NUM ) { Annotation Default attribute da = new Annotation Default attribute ( ) ; element value [ ] result = read Element Values ( NUM , d , BOOL , NUM ) ; da . default value = result [ NUM ] ; a = ( attribute info ) da ; } else if ( s . equals ( attribute info . Bootstrap Methods ) ) { Bootstrap Methods attribute bsma = new Bootstrap Methods attribute ( ) ; int count = d . read Unsigned Short ( ) ; bsma . method handles = new short [ count ] ; bsma . arg indices = new short [ count ] [ ] ; for ( int num = NUM ; num < count ; num ++ ) { short index = ( short ) d . read Unsigned Short ( ) ; bsma . method handles [ num ] = index ; int arg Count = d . read Unsigned Short ( ) ; bsma . arg indices [ num ] = new short [ arg Count ] ; for ( int num Arg = NUM ; num Arg < arg Count ; num Arg ++ ) { short index Arg = ( short ) d . read Unsigned Short ( ) ; bsma . arg indices [ num ] [ num Arg ] = index Arg ; } } assert bootstrap methods attribute == null : STRING ; a = bootstrap methods attribute = bsma ; } else { Generic attribute ga = new Generic attribute ( ) ; if ( len > NUM ) { ga . info = new byte [ ( int ) len ] ; d . read ( ga . info ) ; } a = ( attribute info ) ga ; } a . attribute name = j ; a . attribute length = len ; ai [ i ] = a ; } return BOOL ; }
private void notifiy Download State ( ) { synchronized ( m Download Monitor ) { Log . v ( LOG TAG , STRING ) ; m Download Monitor . notify ( ) ; } }
private PKIX Builder Parameters Create PKIX Builder Parameters ( X509 Certificate end Cert ) throws Certificate Path Building Exception { X509 Cert Selector target Constraints = new X509 Cert Selector ( ) ; target Constraints . set Certificate ( end Cert ) ; PKIX Builder Parameters params ; try { params = new PKIX Builder Parameters ( trust Store , target Constraints ) ; params . set Revocation Enabled ( BOOL ) ; } catch ( Key Store Exception e ) { throw new Certificate Path Building Exception ( STRING + e . get Message ( ) , e ) ; } catch ( Invalid Algorithm Parameter Exception e ) { throw new Certificate Path Building Exception ( STRING + e . get Message ( ) , e ) ; } catch ( Throwable e ) { throw new Certificate Path Building Exception ( STRING + e . get Message ( ) , e ) ; } Collection < Object > cert Collection = new Array List < Object > ( ) ; add Certificate Candidates ( end Cert , cert Collection ) ; if ( ! cert Collection . is Empty ( ) ) { try { Cert Store cert Store = Cert Store . get Instance ( STRING , new Collection Cert Store Parameters ( cert Collection ) ) ; params . add Cert Store ( cert Store ) ; } catch ( Invalid Algorithm Parameter Exception e ) { throw new Certificate Path Building Exception ( STRING + e . get Message ( ) , e ) ; } catch ( No Such Algorithm Exception e ) { throw new Certificate Path Building Exception ( STRING + e . get Message ( ) , e ) ; } } else { logger . debug ( STRING ) ; } return params ; }
public synchronized void add Series ( XY Series series ) { m Series . add ( series ) ; }
public static String value Of ( long value ) { return Long . to String ( value ) ; }
public void print Stack Trace ( ) { Throwable t ; String Writer writer ; writer = new String Writer ( ) ; t = new Throwable ( ) ; t . fill In Stack Trace ( ) ; t . print Stack Trace ( new Print Writer ( writer ) ) ; println ( writer . to String ( ) ) ; }
protected int effective Band Size ( final int dim 1 , final int dim 2 ) { if ( band Size == Double . POSITIVE INFINITY ) { return ( dim 1 > dim 2 ) ? dim 1 : dim 2 ; } if ( band Size >= NUM ) { return ( int ) band Size ; } return ( int ) Math . ceil ( ( dim 1 >= dim 2 ? dim 1 : dim 2 ) * band Size ) ; }
private final Object arena Exchange ( Object item , boolean timed , long ns ) { Node [ ] a = arena ; Node p = participant . get ( ) ; for ( int i = p . index ; ; ) { int b , m , c ; long j ; Node q = ( Node ) U . get Object Volatile ( a , j = ( i << ASHIFT ) + ABASE ) ; if ( q != null && U . compare And Swap Object ( a , j , q , null ) ) { Object v = q . item ; q . match = item ; Thread w = q . parked ; if ( w != null ) U . unpark ( w ) ; return v ; } else if ( i <= ( m = ( b = bound ) & MMASK ) && q == null ) { p . item = item ; if ( U . compare And Swap Object ( a , j , null , p ) ) { long end = ( timed && m == NUM ) ? System . nano Time ( ) + ns : NUM ; Thread t = Thread . current Thread ( ) ; for ( int h = p . hash , spins = SPINS ; ; ) { Object v = p . match ; if ( v != null ) { U . put Ordered Object ( p , MATCH , null ) ; p . item = null ; p . hash = h ; return v ; } else if ( spins > NUM ) { h ^= h << NUM ; h ^= h > > > NUM ; h ^= h << NUM ; if ( h == NUM ) h = SPINS | ( int ) t . get Id ( ) ; else if ( h < NUM && ( -- spins & ( ( SPINS > > > NUM ) - NUM ) ) == NUM ) Thread . yield ( ) ; } else if ( U . get Object Volatile ( a , j ) != p ) spins = SPINS ; else if ( ! t . is Interrupted ( ) && m == NUM && ( ! timed || ( ns = end - System . nano Time ( ) ) > NUM ) ) { U . put Object ( t , BLOCKER , this ) ; p . parked = t ; if ( U . get Object Volatile ( a , j ) == p ) U . park ( BOOL , ns ) ; p . parked = null ; U . put Object ( t , BLOCKER , null ) ; } else if ( U . get Object Volatile ( a , j ) == p && U . compare And Swap Object ( a , j , p , null ) ) { if ( m != NUM ) U . compare And Swap Int ( this , BOUND , b , b + SEQ - NUM ) ; p . item = null ; p . hash = h ; i = p . index >>>= NUM ; if ( Thread . interrupted ( ) ) return null ; if ( timed && m == NUM && ns <= NUM ) return TIMED OUT ; break ; } } } else p . item = null ; } else { if ( p . bound != b ) { p . bound = b ; p . collides = NUM ; i = ( i != m || m == NUM ) ? m : m - NUM ; } else if ( ( c = p . collides ) < m || m == FULL || ! U . compare And Swap Int ( this , BOUND , b , b + SEQ + NUM ) ) { p . collides = c + NUM ; i = ( i == NUM ) ? m : i - NUM ; } else i = m + NUM ; p . index = i ; } } }
public static int encode Longitude Ceil ( double longitude ) { Geo Utils . check Longitude ( longitude ) ; if ( longitude == NUM ) { longitude = Math . next Down ( longitude ) ; } return ( int ) Math . ceil ( longitude / LON DECODE ) ; }
private Linked List < Diff > diff line Mode ( String text 1 , String text 2 , long deadline ) { Lines To Chars Result b = diff lines To Chars ( text 1 , text 2 ) ; text 1 = b . chars 1 ; text 2 = b . chars 2 ; List < String > linearray = b . line Array ; Linked List < Diff > diffs = diff main ( text 1 , text 2 , BOOL , deadline ) ; diff chars To Lines ( diffs , linearray ) ; diff cleanup Semantic ( diffs ) ; diffs . add ( new Diff ( Operation . EQUAL , STRING ) ) ; int count delete = NUM ; int count insert = NUM ; String text delete = STRING ; String text insert = STRING ; List Iterator < Diff > pointer = diffs . list Iterator ( ) ; Diff this Diff = pointer . next ( ) ; while ( this Diff != null ) { switch ( this Diff . operation ) { case INSERT : count insert ++ ; text insert += this Diff . text ; break ; case DELETE : count delete ++ ; text delete += this Diff . text ; break ; case EQUAL : if ( count delete >= NUM && count insert >= NUM ) { pointer . previous ( ) ; for ( int j = NUM ; j < count delete + count insert ; j ++ ) { pointer . previous ( ) ; pointer . remove ( ) ; } for ( Diff new Diff : diff main ( text delete , text insert , BOOL , deadline ) ) { pointer . add ( new Diff ) ; } } count insert = NUM ; count delete = NUM ; text delete = STRING ; text insert = STRING ; break ; } this Diff = pointer . has Next ( ) ? pointer . next ( ) : null ; } diffs . remove Last ( ) ; return diffs ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return ID ; case NUM : return CREATE TIME ; case NUM : return UPDATE TIME ; case NUM : return OPERATION ; case NUM : return STATUS ; case NUM : return SRC PATH ; case NUM : return SRC CLUSTER ; case NUM : return SRC DB ; case NUM : return SRC TABLE ; case NUM : return SRC PARTITIONS ; case NUM : return SRC MODIFIED TIME ; case NUM : return RENAME TO DB ; case NUM : return RENAME TO TABLE ; case NUM : return RENAME TO PATH ; case NUM : return EXTRAS ; case NUM : return WAITING ON JOBS ; default : return null ; } }
public JSON Buffer append Key Hash ( Object key ) { if ( stack . empty ( ) || stack . peek ( ) != Operand . HASH ) { throw new JSON Exception ( STRING ) ; } add Quoted String ( key ) ; buffer . append ( STRING ) ; buffer . append ( STRING ) ; stack . push ( Operand . HASH ) ; return this ; }
static Replay Promise < Void > any Replay ( final Duration timeout , final Promise < ? > ... promises ) { return any Replay ( timeout , System . current Time Millis ( ) , promises ) ; }
public static Policy Service send PLL Request ( URL policy Service Url , Policy Request preq ) throws Send Request Exception , Policy Exception { String lbcookie = null ; try { lbcookie = get LB Cookie ( preq ) ; } catch ( Exception e ) { throw new Send Request Exception ( e ) ; } Policy Service policy Service = new Policy Service ( ) ; policy Service . set Method ID ( Policy Service . POLICY REQUEST ID ) ; policy Service . set Policy Request ( preq ) ; String xml String = policy Service . to XML String ( ) ; Request request = new Request ( xml String ) ; Request Set request Set = new Request Set ( Policy Service . POLICY SERVICE ) ; request Set . add Request ( request ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + policy Service Url + STRING + xml String ) ; } Vector responses = PLL Client . send ( policy Service Url , lbcookie , request Set ) ; Response response = ( Response ) responses . element At ( NUM ) ; Policy Service ps = Policy Service . parse XML ( response . get Content ( ) ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + ps . to XML String ( ) ) ; } return ps ; }
public static URI create Id ( Class < ? extends Data Object > clazz ) { return new Id ( clazz , get Location ( clazz ) ) ; }
public static double log 2 ( double x ) { return Math . log ( x ) * ONE BY LOG 2 ; }
private void need New Buffer ( int newcount ) { if ( current Buffer Index < buffers . size ( ) - NUM ) { filled Buffer Sum += current Buffer . length ; current Buffer Index ++ ; current Buffer = buffers . get ( current Buffer Index ) ; } else { int new Buffer Size ; if ( current Buffer == null ) { new Buffer Size = newcount ; filled Buffer Sum = NUM ; } else { new Buffer Size = Math . max ( current Buffer . length << NUM , newcount - filled Buffer Sum ) ; filled Buffer Sum += current Buffer . length ; } current Buffer Index ++ ; current Buffer = new byte [ new Buffer Size ] ; buffers . add ( current Buffer ) ; } }
@ Override public void add Focusables ( Array List < View > views , int direction , int focusable Mode ) { final int focusable Count = views . size ( ) ; final int descendant Focusability = get Descendant Focusability ( ) ; if ( descendant Focusability != FOCUS BLOCK DESCENDANTS ) { for ( int i = NUM ; i < get Child Count ( ) ; i ++ ) { final View child = get Child At ( i ) ; if ( child . get Visibility ( ) == VISIBLE ) { Item Info ii = info For Child ( child ) ; if ( ii != null && ii . position == m Cur Item ) { child . add Focusables ( views , direction , focusable Mode ) ; } } } } if ( descendant Focusability != FOCUS AFTER DESCENDANTS || ( focusable Count == views . size ( ) ) ) { if ( ! is Focusable ( ) ) { return ; } if ( ( focusable Mode & FOCUSABLES TOUCH MODE ) == FOCUSABLES TOUCH MODE && is In Touch Mode ( ) && ! is Focusable In Touch Mode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }
public void insert Element At ( Node value , int at ) { if ( ! m mutable ) throw new Runtime Exception ( XSL Messages . create XPATH Message ( XPATH Error Resources . ER NODESET NOT MUTABLE , null ) ) ; if ( null == m map ) { m map = new Node [ m blocksize ] ; m map Size = m blocksize ; } else if ( ( m first Free + NUM ) >= m map Size ) { m map Size += m blocksize ; Node new Map [ ] = new Node [ m map Size ] ; System . arraycopy ( m map , NUM , new Map , NUM , m first Free + NUM ) ; m map = new Map ; } if ( at <= ( m first Free - NUM ) ) { System . arraycopy ( m map , at , m map , at + NUM , m first Free - at ) ; } m map [ at ] = value ; m first Free ++ ; }
public Result regress ( Discrete Variable x , List < Node > regressors ) { if ( ! binary ( x ) ) { throw new Illegal Argument Exception ( STRING ) ; } for ( Node node : regressors ) { if ( ! ( node instanceof Continuous Variable || binary ( node ) ) ) { throw new Illegal Argument Exception ( STRING ) ; } } double [ ] [ ] regressors = new double [ regressors . size ( ) ] [ get Rows ( ) . length ] ; for ( int j = NUM ; j < regressors . size ( ) ; j ++ ) { int col = data Set . get Column ( regressors . get ( j ) ) ; double [ ] data Col = data Cols [ col ] ; for ( int i = NUM ; i < get Rows ( ) . length ; i ++ ) { regressors [ j ] [ i ] = data Col [ get Rows ( ) [ i ] ] ; } } int [ ] target = new int [ get Rows ( ) . length ] ; int col = data Set . get Column ( data Set . get Variable ( x . get Name ( ) ) ) ; for ( int i = NUM ; i < get Rows ( ) . length ; i ++ ) { target [ i ] = data Set . get Int ( get Rows ( ) [ i ] , col ) ; } List < String > regressor Names = new Array List < > ( ) ; for ( Node node : regressors ) { regressor Names . add ( node . get Name ( ) ) ; } return regress ( target , x . get Name ( ) , regressors , regressor Names ) ; }
void copy File ( String source , String target ) ;
static public List < Sequence < I String > > tokenize File ( String filename , boolean do NIST ) { List < Sequence < I String > > sequences = new Array List < > ( ) ; Line Number Reader reader = IO Tools . get Reader From File ( filename ) ; try { for ( String line ; ( line = reader . read Line ( ) ) != null ; ) { if ( do NIST ) line = NIST Tokenizer . tokenize ( line ) ; sequences . add ( I Strings . tokenize ( line ) ) ; } reader . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } return sequences ; }
public Statement like ( String expr ) { statement . append ( STRING ) ; append Escaped SQL String ( statement , expr ) ; return this ; }
public static Kdbx Header read Kdbx Header ( Kdbx Header kdbx Header , Input Stream input Stream ) throws IO Exception { Message Digest digest = Encryption . get Message Digest Instance ( ) ; Digest Input Stream digest Input Stream = new Digest Input Stream ( input Stream , digest ) ; Little Endian Data Input Stream ledis = new Little Endian Data Input Stream ( digest Input Stream ) ; if ( ! verify Magic Number ( ledis ) ) { throw new Illegal State Exception ( STRING ) ; } if ( ! verify File Version ( ledis ) ) { throw new Illegal State Exception ( STRING ) ; } byte header Type ; while ( ( header Type = ledis . read Byte ( ) ) != Header Type . END ) { switch ( header Type ) { case Header Type . COMMENT : get Byte Array ( ledis ) ; break ; case Header Type . CIPHER ID : kdbx Header . set Cipher Uuid ( get Byte Array ( ledis ) ) ; break ; case Header Type . COMPRESSION FLAGS : kdbx Header . set Compression Flags ( get Int ( ledis ) ) ; break ; case Header Type . MASTER SEED : kdbx Header . set Master Seed ( get Byte Array ( ledis ) ) ; break ; case Header Type . TRANSFORM SEED : kdbx Header . set Transform Seed ( get Byte Array ( ledis ) ) ; break ; case Header Type . TRANSFORM ROUNDS : kdbx Header . set Transform Rounds ( get Long ( ledis ) ) ; break ; case Header Type . ENCRYPTION IV : kdbx Header . set Encryption Iv ( get Byte Array ( ledis ) ) ; break ; case Header Type . PROTECTED STREAM KEY : kdbx Header . set Protected Stream Key ( get Byte Array ( ledis ) ) ; break ; case Header Type . STREAM START BYTES : kdbx Header . set Stream Start Bytes ( get Byte Array ( ledis ) ) ; break ; case Header Type . INNER RANDOM STREAM ID : kdbx Header . set Inner Random Stream Id ( get Int ( ledis ) ) ; break ; default : throw new Illegal State Exception ( STRING ) ; } } get Byte Array ( ledis ) ; kdbx Header . set Header Hash ( digest . digest ( ) ) ; return kdbx Header ; }
public static byte [ ] copy To Byte Array ( Input Stream in ) throws IO Exception { Byte Array Output Stream out = new Byte Array Output Stream ( BUFFER SIZE ) ; copy ( in , out ) ; return out . to Byte Array ( ) ; }
public boolean is Enum Constant ( ) { return ( get Modifiers ( ) & Modifier . ENUM ) != NUM ; }
public boolean contains Any ( Collection < Taxon > taxa ) { for ( Taxon taxon : taxa ) { if ( taxa . contains ( taxon ) ) { return BOOL ; } } return BOOL ; }
@ Suppress Warnings ( STRING ) public synchronized T dequeue Task ( ) throws Interrupted Exception { while ( data . is Empty ( ) ) { if ( ! closed Input ) wait ( ) ; else return ( T ) NO MORE TASKS ; } T t = data . remove First ( ) ; notify ( ) ; return t ; }
@ Override public void read External ( Object Input in ) throws IO Exception , Class Not Found Exception { super . read External ( in ) ; this . facet Name = in . read UTF ( ) ; }
private boolean string To Boolean ( String condition ) { boolean result = BOOL ; if ( condition != null && condition . length ( ) > NUM ) { String s = condition . substring ( NUM , NUM ) ; if ( s . equals Ignore Case ( STRING ) || s . equals ( STRING ) || s . equals Ignore Case ( STRING ) ) result = BOOL ; } return result ; }
public static void write UINT 32 ( long number , Output Stream out ) throws IO Exception { if ( number < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } byte [ ] to Write = new byte [ NUM ] ; for ( int i = NUM ; i <= NUM ; i += NUM ) { to Write [ i / NUM ] = ( byte ) ( ( number > > i ) & NUM ) ; } out . write ( to Write ) ; }
public Remote Meta Data Impl ( Schema schema ) throws Remote Exception { this . schema = schema ; fields . add All ( schema . fields ( ) ) ; }
private void check Server Response Code ( Http URL Connection url Connection ) throws Request Failure Exception { try { if ( url Connection . get Response Code ( ) != NUM ) { throw new Request Failure Exception ( STRING + url Connection . get Response Code ( ) + STRING ) ; } } catch ( IO Exception e ) { throw new Request Failure Exception ( STRING , e ) ; } }
public void add Switch With Optional Extra Part ( String option , String option Extra Part Synopsis , String description ) { option List . add ( option ) ; option Extra Part Synopsis Map . put ( option , option Extra Part Synopsis ) ; option Description Map . put ( option , description ) ; int length = option . length ( ) + option Extra Part Synopsis . length ( ) + NUM ; if ( length > max Width ) { max Width = length ; } }
public static Object detect Linux Default File Browser ( Map < String , Object > file Browsers ) { Array List < String > command = new Array List < String > ( ) ; command . add ( STRING ) ; command . add ( STRING ) ; command . add ( STRING ) ; command . add ( STRING ) ; if ( file Browsers == null ) { file Browsers = new Hash Map < String , Object > ( ) ; file Browsers . put ( STRING , STRING ) ; } return Utils . is Expected Command Output ( command , file Browsers ) ; }
public void updated ( ) { current Color = Html Colors . decode ( get Setting Value ( ) ) ; secondary Color = Html Colors . decode ( base Color ) ; Color foreground Color ; Color background Color ; if ( type == FOREGROUND ) { foreground Color = current Color ; background Color = secondary Color ; } else { foreground Color = secondary Color ; background Color = current Color ; } preview . set Foreground ( foreground Color ) ; preview . set Background ( background Color ) ; }
public Collection < ? extends Immutable Class Type > remove Instrumentation Points ( final Collection < ? extends Immutable Type > types ) { return remove Instrumentation Points ( types , Collections . < I Instrumentation Applier > singleton ( Remove All Instrumentation Applier . get Instance ( ) ) ) ; }
private Record create Record ( Record Properties record Properties ) throws Record Exception { String debug Directory ; if ( is Recording ( ) ) { debug Directory = previous Debug Directory ; } else { debug Directory = System Properties Manager . get ( Debug Constants . CONFIG DEBUG DIRECTORY ) ; } String record Directory = debug Directory + File . separator + Record Constants . RECORD FOLDER NAME + File . separator + record Properties . get Issue ID ( ) + File . separator + record Properties . get Reference ID ( ) ; Record record = new Record ( record Properties , record Directory ) ; try { create Folder ( record . get Folder Path ( ) ) ; Print Writer print Writer Info = get Print Writer For File ( record , Record Constants . INFO FILE NAME ) ; Json Value info = record Report . info Report ( record ) ; try { JSON Object json = new JSON Object ( info . to String ( ) ) ; print Writer Info . println ( json . to String ( NUM ) ) ; } catch ( JSON Exception e ) { debug . warning ( STRING , info , e ) ; print Writer Info . println ( info ) ; } print Writer Info . flush ( ) ; return record ; } catch ( IO Exception e ) { debug . error ( STRING , record Properties , e ) ; throw new Record Exception ( STRING + record Properties . get Issue ID ( ) + STRING , e ) ; } }
public static Lagged Edge serializable Instance ( ) { return new Lagged Edge ( STRING , Lagged Factor . serializable Instance ( ) ) ; }
public final void dispatch Characters Events ( int node Handle , Content Handler ch , boolean normalize ) throws SAX Exception { int identity = make Node Identity ( node Handle ) ; if ( identity == DTM . NULL ) return ; int type = type 2 ( identity ) ; if ( type == DTM . ELEMENT NODE || type == DTM . DOCUMENT NODE ) { int start Node = identity ; identity = firstch 2 ( identity ) ; if ( DTM . NULL != identity ) { int offset = - NUM ; int length = NUM ; do { type = exptype 2 ( identity ) ; if ( type == DTM . TEXT NODE || type == DTM . CDATA SECTION NODE ) { int data Index = m data Or Q Name . element At ( identity ) ; if ( data Index >= NUM ) { if ( - NUM == offset ) { offset = data Index > > > TEXT LENGTH BITS ; } length += data Index & TEXT LENGTH MAX ; } else { if ( - NUM == offset ) { offset = m data . element At ( - data Index ) ; } length += m data . element At ( - data Index + NUM ) ; } } identity ++ ; } while ( parent 2 ( identity ) >= start Node ) ; if ( length > NUM ) { if ( normalize ) m chars . send Normalized SA Xcharacters ( ch , offset , length ) ; else m chars . send SA Xcharacters ( ch , offset , length ) ; } } } else if ( DTM . TEXT NODE == type || DTM . CDATA SECTION NODE == type ) { int data Index = m data Or Q Name . element At ( identity ) ; if ( data Index >= NUM ) { if ( normalize ) m chars . send Normalized SA Xcharacters ( ch , data Index > > > TEXT LENGTH BITS , data Index & TEXT LENGTH MAX ) ; else m chars . send SA Xcharacters ( ch , data Index > > > TEXT LENGTH BITS , data Index & TEXT LENGTH MAX ) ; } else { if ( normalize ) m chars . send Normalized SA Xcharacters ( ch , m data . element At ( - data Index ) , m data . element At ( - data Index + NUM ) ) ; else m chars . send SA Xcharacters ( ch , m data . element At ( - data Index ) , m data . element At ( - data Index + NUM ) ) ; } } else { int data Index = m data Or Q Name . element At ( identity ) ; if ( data Index < NUM ) { data Index = - data Index ; data Index = m data . element At ( data Index + NUM ) ; } String str = ( String ) m values . element At ( data Index ) ; if ( normalize ) Fast String Buffer . send Normalized SA Xcharacters ( str . to Char Array ( ) , NUM , str . length ( ) , ch ) ; else ch . characters ( str . to Char Array ( ) , NUM , str . length ( ) ) ; } }
private int clamp Mag ( int value , int abs Min , int abs Max ) { final int abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }
private static int length Of Mime Names ( String val ) { int len = val . index Of ( STRING ) ; if ( len < NUM ) len = val . length ( ) ; return len ; }
private char read Escape Character ( ) throws JSON Exception { char escaped = in . char At ( pos ++ ) ; switch ( escaped ) { case STRING : if ( pos + NUM > in . length ( ) ) { throw syntax Error ( STRING ) ; } String hex = in . substring ( pos , pos + NUM ) ; pos += NUM ; return ( char ) Integer . parse Int ( hex , NUM ) ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
public static boolean is Sha 1 String ( final String string ) { Preconditions . check Not Null ( string , STRING ) ; return ( string . length ( ) == NUM ) && is Hex String ( string ) ; }
public boolean is Watched ( ) { return watched ; }
public void add Date Change Listener ( Date Change Listener listener ) { date Change Listeners . add ( listener ) ; }
public static String strip File Protocol ( String uri String ) { if ( uri String . starts With ( STRING ) ) { uri String = uri String . substring ( NUM ) ; } return uri String ; }
public void replace Template ( Elem Template v , int i ) throws Transformer Exception { if ( null == m templates ) throw new Array Index Out Of Bounds Exception ( ) ; replace Child ( v , ( Elem Template Element ) m templates . element At ( i ) ) ; m templates . set Element At ( v , i ) ; v . set Stylesheet ( this ) ; }
public Rotated Problem ( Problem problem , Real Matrix rotation ) { super ( ) ; this . problem = problem ; this . rotation = rotation ; Solution solution = problem . new Solution ( ) ; center = new double [ get Number Of Variables ( ) ] ; lower Bounds = new double [ get Number Of Variables ( ) ] ; upper Bounds = new double [ get Number Of Variables ( ) ] ; for ( int i = NUM ; i < get Number Of Variables ( ) ; i ++ ) { Real Variable variable = ( Real Variable ) solution . get Variable ( i ) ; center [ i ] = ( variable . get Lower Bound ( ) + variable . get Upper Bound ( ) ) / NUM ; lower Bounds [ i ] = Math . sqrt ( NUM ) * ( variable . get Lower Bound ( ) - center [ i ] ) ; upper Bounds [ i ] = Math . sqrt ( NUM ) * ( variable . get Upper Bound ( ) - center [ i ] ) ; } }
public static byte [ ] decode ( String data ) { int len = data . length ( ) / NUM * NUM ; Byte Array Output Stream b Out = new Byte Array Output Stream ( len ) ; try { encoder . decode ( data , b Out ) ; } catch ( Exception e ) { throw new Decoder Exception ( STRING + e . get Message ( ) , e ) ; } return b Out . to Byte Array ( ) ; }
public void characters ( char ch [ ] , int start , int length ) throws SAX Exception { m cur Value . append ( ch , start , length ) ; }
public boolean regenerate ( Projection proj ) { boolean ret = super . regenerate ( proj ) ; if ( proj != null && ! ret ) { ret = generate ( proj ) ; } return ret ; }
@ Override public byte [ ] unwrap ( final byte [ ] incoming , final int offset , final int len ) throws Ldap Exception { final byte [ ] copy = new byte [ len ] ; System . arraycopy ( incoming , offset , copy , NUM , len ) ; return copy ; }
private int sequential Forward Selection ( String data File , String [ ] features , int ind Var Col Number , int X [ ] , int Y [ ] , double J [ ] , int row Ini , int row End ) { double sig [ ] = new double [ Y . length ] ; int sig Index [ ] = new int [ Y . length ] ; double cor Xplusy [ ] = new double [ Y . length ] ; double cor X ; if ( X . length > NUM ) { Regression reg = new Regression ( ) ; reg . multiple Linear Regression ( data File , ind Var Col Number , X , features , intercept Term , row Ini , row End ) ; cor X = reg . get Correlation ( ) ; } else cor X = NUM ; for ( int i = NUM ; i < Y . length ; i ++ ) { cor Xplusy [ i ] = correlation Of New Feature ( data File , features , ind Var Col Number , X , Y [ i ] , row Ini , row End ) ; sig [ i ] = cor Xplusy [ i ] - cor X ; sig Index [ i ] = Y [ i ] ; } int min Sig = Math Utils . get Min Index ( sig ) ; J [ NUM ] = cor Xplusy [ min Sig ] ; J [ NUM ] = cor X ; int max Sig = Math Utils . get Max Index ( sig ) ; J [ NUM ] = cor Xplusy [ max Sig ] ; return sig Index [ max Sig ] ; }
private static byte [ ] codes To Bytes ( String codes , boolean required ) { if ( codes . length ( ) == NUM ) { if ( required ) { throw new Illegal State Exception ( STRING ) ; } return null ; } if ( ( codes . length ( ) % NUM ) != NUM ) { codes = STRING + codes ; } byte [ ] bytes = new byte [ codes . length ( ) / NUM ] ; for ( int i = NUM ; i < bytes . length ; ++ i ) { int char Idx = i * NUM ; bytes [ i ] = ( byte ) ( Integer . parse Int ( codes . substring ( char Idx , char Idx + NUM ) , NUM ) ) ; } return bytes ; }
public Drag Entry drag Selected Entry ( ) { try { Key Store History history = get Active Key Store History ( ) ; if ( history == null ) { return null ; } Key Store State current State = history . get Current State ( ) ; Key Store key Store = current State . get Key Store ( ) ; String alias = get Selected Entry Alias ( ) ; if ( alias == null ) { return null ; } if ( Key Store Util . is Key Entry ( alias , key Store ) ) { J Option Pane . show Message Dialog ( frame , res . get String ( STRING ) , KSE . get Application Name ( ) , J Option Pane . WARNING MESSAGE ) ; return null ; } if ( Key Store Util . is Key Pair Entry ( alias , key Store ) ) { Password password = current State . get Entry Password ( alias ) ; Key Store Type type = Key Store Type . resolve Jce ( key Store . get Type ( ) ) ; if ( password == null && type . has Entry Passwords ( ) ) { J Option Pane . show Message Dialog ( frame , res . get String ( STRING ) , KSE . get Application Name ( ) , J Option Pane . WARNING MESSAGE ) ; return null ; } Private Key private Key = ( Private Key ) key Store . get Key ( alias , password . to Char Array ( ) ) ; Certificate [ ] certificate Chain = key Store . get Certificate Chain ( alias ) ; return new Drag Key Pair Entry ( alias , private Key , password , certificate Chain ) ; } else { Certificate trusted Certificate = key Store . get Certificate ( alias ) ; return new Drag Trusted Certificate Entry ( alias , trusted Certificate ) ; } } catch ( Exception ex ) { D Error . display Error ( frame , ex ) ; return null ; } }
public void insert ( T object , int index ) { synchronized ( m Lock ) { if ( m Original Values != null ) { m Original Values . add ( index , object ) ; } else { m Objects . add ( index , object ) ; } } if ( m Notify On Change ) notify Data Set Changed ( ) ; }
public static Document create Document ( boolean is Secure Processing ) { try { Document Builder Factory dfactory = Document Builder Factory . new Instance ( ) ; dfactory . set Namespace Aware ( BOOL ) ; Document Builder doc Builder = dfactory . new Document Builder ( ) ; Document out Node = doc Builder . new Document ( ) ; return out Node ; } catch ( Parser Configuration Exception pce ) { throw new Runtime Exception ( XML Messages . create XML Message ( XML Error Resources . ER CREATEDOCUMENT NOT SUPPORTED , null ) ) ; } }
public double reduce ( String numeric Column Name , Numeric Reduce Function function ) { Column column = column ( numeric Column Name ) ; return function . reduce ( column . to Double Array ( ) ) ; }
public void test Set Bit Negative Outside 1 ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = - NUM ; int number = NUM ; byte r Bytes [ ] = { - NUM , NUM , - NUM , - NUM , NUM , NUM , - NUM , - NUM , - NUM , - NUM , NUM , - NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . set Bit ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
static public String format U Int 8 Char ( byte b ) { String ch = new String ( new byte [ ] { b } ) ; ch = ch . replace All ( STRING , STRING ) ; return format U Int 8 ( b ) + STRING + ch ; }
public static final Array List < Move > remove Illegal ( Position pos , Array List < Move > move List ) { Array List < Move > ret = new Array List < Move > ( ) ; Undo Info ui = new Undo Info ( ) ; int ml Size = move List . size ( ) ; for ( int mi = NUM ; mi < ml Size ; mi ++ ) { Move m = move List . get ( mi ) ; pos . make Move ( m , ui ) ; pos . set White Move ( ! pos . white Move ) ; if ( ! in Check ( pos ) ) ret . add ( m ) ; pos . set White Move ( ! pos . white Move ) ; pos . un Make Move ( m , ui ) ; } return ret ; }
public static int apply Mask Penalty Rule 4 ( Byte Matrix matrix ) { int num Dark Cells = NUM ; byte [ ] [ ] array = matrix . get Array ( ) ; int width = matrix . get Width ( ) ; int height = matrix . get Height ( ) ; for ( int y = NUM ; y < height ; ++ y ) { for ( int x = NUM ; x < width ; ++ x ) { if ( array [ y ] [ x ] == NUM ) { num Dark Cells += NUM ; } } } int num Total Cells = matrix . get Height ( ) * matrix . get Width ( ) ; double dark Ratio = ( double ) num Dark Cells / num Total Cells ; return Math . abs ( ( int ) ( dark Ratio * NUM - NUM ) ) / NUM * NUM ; }
private void check State ( ) { if ( diagram Retrieved ) { throw new Illegal State Exception ( STRING ) ; } }
static Hashtable convert To Hash ( Map m ) { Hashtable ret Hash = new Hashtable ( ) ; Set s = m . key Set ( ) ; Iterator iter = s . iterator ( ) ; while ( iter . has Next ( ) ) { String key = ( String ) iter . next ( ) ; Set val = ( Set ) m . get ( key ) ; ret Hash . put ( key , set To String ( val ) ) ; } return ret Hash ; }
public void action Performed ( Action Event evt ) { }
public boolean equal at start ( Pla Point Int p point ) { if ( p point == null ) return BOOL ; Pla Point first = corner first ( ) ; return first . equals ( p point ) ; }
public void for Each Block Depth First ( boolean reverse , Ssa Basic Block . Visitor v ) { Bit Set visited = new Bit Set ( blocks . size ( ) ) ; Stack < Ssa Basic Block > stack = new Stack < Ssa Basic Block > ( ) ; Ssa Basic Block root Block = reverse ? get Exit Block ( ) : get Entry Block ( ) ; if ( root Block == null ) { return ; } stack . add ( null ) ; stack . add ( root Block ) ; while ( stack . size ( ) > NUM ) { Ssa Basic Block cur = stack . pop ( ) ; Ssa Basic Block parent = stack . pop ( ) ; if ( ! visited . get ( cur . get Index ( ) ) ) { Bit Set children = reverse ? cur . get Predecessors ( ) : cur . get Successors ( ) ; for ( int i = children . next Set Bit ( NUM ) ; i >= NUM ; i = children . next Set Bit ( i + NUM ) ) { stack . add ( cur ) ; stack . add ( blocks . get ( i ) ) ; } visited . set ( cur . get Index ( ) ) ; v . visit Block ( cur , parent ) ; } } }
protected void fill Path ( ) { mPS Stream . println ( m Fill Op Str ) ; }
public static byte [ ] decode ( String encoded ) { if ( encoded == null ) { return null ; } char [ ] base 64 Data = encoded . to Char Array ( ) ; int len = remove White Space ( base 64 Data ) ; if ( len % FOURBYTE != NUM ) { return null ; } int number Quadruple = ( len / FOURBYTE ) ; if ( number Quadruple == NUM ) { return new byte [ NUM ] ; } byte decoded Data [ ] = null ; byte b1 = NUM , b2 = NUM , b3 = NUM , b4 = NUM ; char d1 = NUM , d2 = NUM , d3 = NUM , d4 = NUM ; int i = NUM ; int encoded Index = NUM ; int data Index = NUM ; decoded Data = new byte [ ( number Quadruple ) * NUM ] ; for ( ; i < number Quadruple - NUM ; i ++ ) { if ( ! is Data ( ( d1 = base 64 Data [ data Index ++ ] ) ) || ! is Data ( ( d2 = base 64 Data [ data Index ++ ] ) ) || ! is Data ( ( d3 = base 64 Data [ data Index ++ ] ) ) || ! is Data ( ( d4 = base 64 Data [ data Index ++ ] ) ) ) { return null ; } b1 = base 64 Alphabet [ d1 ] ; b2 = base 64 Alphabet [ d2 ] ; b3 = base 64 Alphabet [ d3 ] ; b4 = base 64 Alphabet [ d4 ] ; decoded Data [ encoded Index ++ ] = ( byte ) ( b1 << NUM | b2 > > NUM ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( b3 << NUM | b4 ) ; } if ( ! is Data ( ( d1 = base 64 Data [ data Index ++ ] ) ) || ! is Data ( ( d2 = base 64 Data [ data Index ++ ] ) ) ) { return null ; } b1 = base 64 Alphabet [ d1 ] ; b2 = base 64 Alphabet [ d2 ] ; d3 = base 64 Data [ data Index ++ ] ; d4 = base 64 Data [ data Index ++ ] ; if ( ! is Data ( ( d3 ) ) || ! is Data ( ( d4 ) ) ) { if ( is Pad ( d3 ) && is Pad ( d4 ) ) { if ( ( b2 & NUM ) != NUM ) { return null ; } byte [ ] tmp = new byte [ i * NUM + NUM ] ; System . arraycopy ( decoded Data , NUM , tmp , NUM , i * NUM ) ; tmp [ encoded Index ] = ( byte ) ( b1 << NUM | b2 > > NUM ) ; return tmp ; } else if ( ! is Pad ( d3 ) && is Pad ( d4 ) ) { b3 = base 64 Alphabet [ d3 ] ; if ( ( b3 & NUM ) != NUM ) { return null ; } byte [ ] tmp = new byte [ i * NUM + NUM ] ; System . arraycopy ( decoded Data , NUM , tmp , NUM , i * NUM ) ; tmp [ encoded Index ++ ] = ( byte ) ( b1 << NUM | b2 > > NUM ) ; tmp [ encoded Index ] = ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ; return tmp ; } else { return null ; } } else { b3 = base 64 Alphabet [ d3 ] ; b4 = base 64 Alphabet [ d4 ] ; decoded Data [ encoded Index ++ ] = ( byte ) ( b1 << NUM | b2 > > NUM ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( b3 << NUM | b4 ) ; } return decoded Data ; }
public boolean is Last Window ( Accessibility Window Info base Window , int window Type ) { int index = get Window Index ( base Window ) ; if ( index == WRONG INDEX ) { return BOOL ; } int count = m Windows . size ( ) ; for ( int i = index + NUM ; i < count ; i ++ ) { Accessibility Window Info window = m Windows . get ( i ) ; if ( window != null && window . get Type ( ) == window Type ) { return BOOL ; } } return BOOL ; }
public void pass Pg Session Map Ex ( View Bean other ) { Map attributes = get Page Session Attributes ( ) ; for ( Iterator i = retain Page Sessions Btw Tabs . iterator ( ) ; i . has Next ( ) ; ) { String key = ( String ) i . next ( ) ; other . set Page Session Attribute ( key , ( Serializable ) attributes . get ( key ) ) ; } other . set Page Session Attribute ( get Tracking Tab ID Name ( ) , ( Serializable ) attributes . get ( get Tracking Tab ID Name ( ) ) ) ; }
public long time ( ) { return heartbeat Time ; }
public boolean hit Clip ( int x , int y , int width , int height ) { return g . hit Clip ( x , y , width , height ) ; }
public static Close Watcher poll Unclosed ( ) { Reference Queue < Object > q = queue ; if ( q == null ) { return null ; } while ( BOOL ) { Close Watcher cw = ( Close Watcher ) q . poll ( ) ; if ( cw == null ) { return null ; } if ( refs != null ) { refs . remove ( cw ) ; } if ( cw . closeable != null ) { return cw ; } } }
private static boolean append Odexes To Class Path ( Context cxt , File dex Dir , String [ ] names ) { String str Dex Dir = dex Dir . get Absolute Path ( ) ; Array List < String > jar Paths = new Array List < String > ( ) ; for ( int i = NUM ; i < names . length ; i ++ ) { String jar Path = str Dex Dir + STRING + names [ i ] ; File f = new File ( jar Path ) ; if ( f . is File ( ) ) { jar Paths . add ( jar Path ) ; } } String [ ] jars Of Dex = new String [ jar Paths . size ( ) ] ; jar Paths . to Array ( jars Of Dex ) ; Path Class Loader pcl = ( Path Class Loader ) cxt . get Class Loader ( ) ; try { if ( Build . VERSION . SDK INT < SDK INT ICS ) { Framework Hack . append Dex List Impl Under ICS ( jars Of Dex , pcl , dex Dir ) ; } else { boolean kitkat Plus = Build . VERSION . SDK INT >= SDK INT KITKAT ; boolean marshmallow Plus = Build . VERSION . SDK INT >= SDK INT MARSHMALLOW ; Array List < File > jar Files = Dex Dex . strings 2 Files ( jars Of Dex ) ; Framework Hack . append Dex List Impl ICS ( jar Files , pcl , dex Dir , kitkat Plus , marshmallow Plus ) ; } for ( String jar Name : names ) { the Appended . add ( jar Name ) ; } if ( debug ) { Log . d ( TAG , STRING + pcl ) ; Log . d ( TAG , STRING + the Appended ) ; } } catch ( Exception ex ) { throw new Runtime Exception ( ex ) ; } return BOOL ; }
@ Override public final int read Int ( ) throws IO Exception { dis . read Fully ( work , NUM , NUM ) ; return ( work [ NUM ] ) << NUM | ( work [ NUM ] & NUM ) << NUM | ( work [ NUM ] & NUM ) << NUM | ( work [ NUM ] & NUM ) ; }
private void assert Serialize And Des Date Time ( String date Time String ) throws Rya Type Resolver Exception { assert Serialize And Des Date Time ( date Time String , date Time String ) ; }
public boolean is Hard Mode ( ) { return is Hard Mode ; }
protected String do It ( ) throws Exception { setup ( ) ; for ( M Warehouse warehouse : warehouses ) for ( M Cost Type cost Type : cost Types ) for ( M Cost Element cost Element : cost Elements ) for ( int product Id : products ) generate Inventory Value ( product Id , cost Type . get M Cost Type ID ( ) , cost Element . get M Cost Element ID ( ) , warehouse . get M Warehouse ID ( ) ) ; pstmt . execute Batch ( ) ; commit Ex ( ) ; DB . close ( pstmt ) ; DB . execute Update ( STRING + DB . TO DATE ( p Date Value ) + STRING , get AD P Instance ID ( ) , get Trx Name ( ) ) ; return STRING + count ; }
public void run ( ) { setup ( ) ; log . info ( STRING ) ; for ( Task Storage Manager task Storage Manager : task Storage Managers ) { task Storage Manager . init ( ) ; task Storage Manager . stop Stores ( ) ; log . debug ( STRING + task Storage Manager . to String ( ) ) ; } log . info ( STRING + store Base Dir . to String ( ) ) ; }
public Criteria create Criteria ( ) { Criteria criteria = create Criteria Internal ( ) ; if ( ored Criteria . size ( ) == NUM ) { ored Criteria . add ( criteria ) ; } return criteria ; }
public static int [ ] shuffle ( int [ ] input ) { List < Integer > vals = new Array List < Integer > ( input . length ) ; for ( int i = NUM ; i < input . length ; i ++ ) vals . add ( input [ i ] ) ; Collections . shuffle ( vals , SEEDED RANDOM ) ; int [ ] copy = new int [ input . length ] ; for ( int i = NUM ; i < input . length ; i ++ ) copy [ i ] = vals . get ( i ) ; return copy ; }
public void read ( int i ) { Variable Value v = row Vector . element At ( i ) ; v . read All ( ) ; }
protected List < Expression > transform Expressions ( List < ? extends Expression > expressions , Expression Transformer transformer ) { List < Expression > list = new Array List < Expression > ( expressions . size ( ) ) ; for ( Expression expr : expressions ) { list . add ( transformer . transform ( expr ) ) ; } return list ; }
public String prefix Forward ( int length ) { final String prefix = prefix ( length ) ; this . pointer += length ; this . index += length ; this . column += length ; return prefix ; }
private boolean can Add Task ( ) { return t Cur == null ; }
public void flush ( ) throws IO Exception { if ( print Writer != null ) { print Writer . flush ( ) ; } if ( gzip Output Stream != null ) { gzip Output Stream . flush ( ) ; } }
public int start ( ) { started . compare And Set ( BOOL , BOOL ) ; server . start ( ) ; return server . get Server Port ( ) ; }
public static double angle ( Tuple 3 d a , Tuple 3 d b ) { double dx = b . x - a . x ; double dy = b . y - a . y ; double angle = NUM ; if ( dx == NUM ) { if ( dy == NUM ) angle = NUM ; else if ( dy > NUM ) angle = Math . PI / NUM ; else angle = ( Math . PI * NUM ) / NUM ; } else if ( dy == NUM ) { if ( dx > NUM ) angle = NUM ; else angle = Math . PI ; } else { if ( dx < NUM ) angle = Math . atan ( dy / dx ) + Math . PI ; else if ( dy < NUM ) angle = Math . atan ( dy / dx ) + ( NUM * Math . PI ) ; else angle = Math . atan ( dy / dx ) ; } return angle ; }
public void add String To Table ( byte [ ] old String , byte new String ) { int length = old String . length ; byte [ ] str = new byte [ length + NUM ] ; System . arraycopy ( old String , NUM , str , NUM , length ) ; str [ length ] = new String ; string Table [ table Index ++ ] = str ; if ( table Index == NUM ) { bits To Get = NUM ; } else if ( table Index == NUM ) { bits To Get = NUM ; } else if ( table Index == NUM ) { bits To Get = NUM ; } }
public static boolean identical ( URI first , URI second ) { if ( ( first != null ) && ( second != null ) ) { return first . equals ( second ) ; } return BOOL ; }
default < ST > Xor < ST , T > to Xor ( final ST secondary ) { final Optional < T > o = to Optional ( ) ; return o . is Present ( ) ? Xor . primary ( o . get ( ) ) : Xor . secondary ( secondary ) ; }
public void process Invite ( Request Event request Event , Server Transaction server Transaction ) { Sip Provider sip Provider = ( Sip Provider ) request Event . get Source ( ) ; Request request = request Event . get Request ( ) ; logger . info ( STRING + request ) ; timer . schedule ( new Delayed Invite Responses Task ( request Event , sip Provider ) , NUM ) ; }
Configuration Error ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; }
protected Instances data From XML ( Instances header ) throws Exception { Instances result ; Element node ; Vector < Element > list ; list = get Child Tags ( m Document . get Document Element ( ) , TAG BODY ) ; node = list . get ( NUM ) ; list = get Child Tags ( node , TAG INSTANCES ) ; node = list . get ( NUM ) ; result = create Instances ( header , node ) ; return result ; }
private static String prepend If Missing ( final String str , final Char Sequence prefix , final boolean ignore Case , final Char Sequence ... prefixes ) { if ( str == null || is Empty ( prefix ) || starts With ( str , prefix , ignore Case ) ) { return str ; } if ( prefixes != null && prefixes . length > NUM ) { for ( final Char Sequence p : prefixes ) { if ( starts With ( str , p , ignore Case ) ) { return str ; } } } return prefix . to String ( ) + str ; }
protected Cache Distribution Advisor create Distribution Advisor ( Internal Region Arguments internal Region Args ) { return Cache Distribution Advisor . create Cache Distribution Advisor ( this ) ; }
public Object [ ] to Array ( ) { Array List < E > al = new Array List < E > ( ) ; for ( Node < E > p = first ( ) ; p != null ; p = succ ( p ) ) { E item = p . item ; if ( item != null ) al . add ( item ) ; } return al . to Array ( ) ; }
public void add Mouse Listener ( Global Mouse Listener listener ) { listeners . add ( listener ) ; }
private Vector 1 D finite Or Null Point ( final double x ) { return Double . is Infinite ( x ) ? null : new Vector 1 D ( x ) ; }
public void load PDF ( final File input ) { if ( input == null ) { return ; } scale = NUM ; PD Ffile = input . get Absolute Path ( ) ; file Loc . set Text ( PD Ffile ) ; open File ( input , null , BOOL ) ; }
public Char Buffer append ( Object obj ) { return append ( String . value Of ( obj ) ) ; }
public void test Intby Int 1 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . multiply ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
public abstract void initialize Constraints ( Step step , Settings settings ) ;
private static void check File Validation ( File file ) { if ( file == null ) throw new Null Pointer Exception ( STRING ) ; if ( ! file . exists ( ) ) { throw new Illegal Argument Exception ( STRING + file . get Path ( ) + STRING ) ; } file . can Read ( ) ; }
public < Result T > Set < Result T > to Set ( Converter < Result T > converter ) { try { if ( is Empty ( cursor ) ) { return Collections . empty Set ( ) ; } return populate ( converter , new Hash Set < Result T > ( cursor . get Count ( ) ) ) ; } finally { close ( ) ; } }
public static Builder new Builder ( ) { return new Builder ( ) ; }
public static void stash Disable Assertion Arg ( String arg ) { if ( arg == null || arg . equals ( STRING ) ) { assertions Enabled = BOOL ; } else { disabled Assertion Strings = arg . split ( STRING ) ; } }
private static void attempt Retry On Exception ( String log Prefix , Request < ? > request , Volley Error exception ) throws Volley Error { Retry Policy retry Policy = request . get Retry Policy ( ) ; int old Timeout = request . get Timeout Ms ( ) ; try { retry Policy . retry ( exception ) ; } catch ( Volley Error e ) { request . add Marker ( String . format ( STRING , log Prefix , old Timeout ) ) ; throw e ; } request . add Marker ( String . format ( STRING , log Prefix , old Timeout ) ) ; }
public Iterator < Stream > member Iterator ( ) { return member Set . iterator ( ) ; }
private void clean Mapping ( ) { Array List < Integer > to Remove = new Array List < Integer > ( ) ; int size = m List Mapping . size ( ) ; for ( int i = NUM ; i < size ; ++ i ) { if ( m List Mapping . key At ( i ) == m List Mapping . value At ( i ) ) { to Remove . add ( m List Mapping . key At ( i ) ) ; } } size = to Remove . size ( ) ; for ( int i = NUM ; i < size ; ++ i ) { m List Mapping . delete ( to Remove . get ( i ) ) ; } }
public static String time Until ( final int seconds , final boolean force Seconds ) { final String Builder sbuf = new String Builder ( ) ; time Until ( sbuf , seconds , force Seconds ) ; return sbuf . to String ( ) ; }
public void remove ( T item ) { if ( set . remove ( item ) ) { fire Contents Changed ( this , NUM , get Size ( ) - NUM ) ; } }
public static void append ( File file , Reader reader , String charset ) throws IO Exception { append ( file , reader , charset , BOOL ) ; }
void parse Ignored Section ( ) throws IO Exception { int depth = NUM ; in . replace ++ ; while ( BOOL ) { switch ( ch ) { case STRING : if ( ( ch = in . read ( ) ) == STRING ) { if ( ( ch = in . read ( ) ) == STRING ) { ch = in . read ( ) ; depth ++ ; } } break ; case STRING : if ( ( ch = in . read ( ) ) == STRING ) { if ( ( ch = in . read ( ) ) == STRING ) { ch = in . read ( ) ; if ( -- depth == NUM ) { in . replace -- ; return ; } } } break ; case - NUM : error ( STRING ) ; in . replace -- ; return ; default : ch = in . read ( ) ; break ; } } }
private synchronized int read Record Length ( ) throws IO Exception { if ( in . get Pos ( ) >= end ) { return - NUM ; } int length = in . read Int ( ) ; if ( sync != null && length == SYNC ESCAPE ) { in . read Fully ( sync Check ) ; if ( ! Arrays . equals ( sync , sync Check ) ) { throw new IO Exception ( STRING ) ; } sync Seen = BOOL ; if ( in . get Pos ( ) >= end ) { return - NUM ; } length = in . read Int ( ) ; } else { sync Seen = BOOL ; } return length ; }
public void add Slide ( @ Non Null Fragment fragment ) { fragments . add ( fragment ) ; if ( is Wizard Mode ) { set Off Screen Page Limit ( fragments . size ( ) ) ; } m Pager Adapter . notify Data Set Changed ( ) ; }
public Default Interval Category Dataset ( Comparable [ ] series Keys , Comparable [ ] category Keys , Number [ ] [ ] starts , Number [ ] [ ] ends ) { this . start Data = starts ; this . end Data = ends ; if ( starts != null && ends != null ) { String base Name = STRING ; Resource Bundle resources = Resource Bundle Wrapper . get Bundle ( base Name ) ; int series Count = starts . length ; if ( series Count != ends . length ) { String err Msg = STRING + STRING + STRING + STRING ; throw new Illegal Argument Exception ( err Msg ) ; } if ( series Count > NUM ) { if ( series Keys != null ) { if ( series Keys . length != series Count ) { throw new Illegal Argument Exception ( STRING + STRING ) ; } this . series Keys = series Keys ; } else { String prefix = resources . get String ( STRING ) + STRING ; this . series Keys = generate Keys ( series Count , prefix ) ; } int category Count = starts [ NUM ] . length ; if ( category Count != ends [ NUM ] . length ) { String err Msg = STRING + STRING + STRING + STRING ; throw new Illegal Argument Exception ( err Msg ) ; } if ( category Keys != null ) { if ( category Keys . length != category Count ) { throw new Illegal Argument Exception ( STRING + STRING ) ; } this . category Keys = category Keys ; } else { String prefix = resources . get String ( STRING ) + STRING ; this . category Keys = generate Keys ( category Count , prefix ) ; } } else { this . series Keys = new Comparable [ NUM ] ; this . category Keys = new Comparable [ NUM ] ; } } }
public void translate ( double dx , double dy ) { if ( ! is Relative ( ) ) { x += dx ; y += dy ; } if ( source Point != null ) { source Point . set X ( source Point . get X ( ) + dx ) ; source Point . set Y ( source Point . get Y ( ) + dy ) ; } if ( target Point != null ) { target Point . set X ( target Point . get X ( ) + dx ) ; target Point . set Y ( target Point . get Y ( ) + dy ) ; } if ( TRANSLATE CONTROL POINTS && points != null ) { int count = points . size ( ) ; for ( int i = NUM ; i < count ; i ++ ) { mx Point pt = ( mx Point ) points . get ( i ) ; pt . set X ( pt . get X ( ) + dx ) ; pt . set Y ( pt . get Y ( ) + dy ) ; } } }
public abstract void fill ( Byte Buffer buffer , long id ) ;
private String anonymize Password ( String password ) { if ( password == null ) { return STRING ; } String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < password . length ( ) ; i ++ ) { sb . append ( STRING ) ; } return sb . to String ( ) ; }
public final void write ( final byte [ ] data ) { byte Buffer . put ( data ) ; }
public RR Database ( File file ) throws IO Exception { name = file . get Name ( ) ; rrd File = new RRD File ( file ) ; header = new Header ( rrd File ) ; nameindex = new Hash Map < String , Integer > ( header . ds Count ) ; data Sources = new Array List < Data Source > ( header . ds Count ) ; for ( int i = NUM ; i < header . ds Count ; i ++ ) { Data Source ds = new Data Source ( rrd File ) ; nameindex . put ( ds . get Name ( ) , i ) ; data Sources . add ( ds ) ; } archives = new Array List < Archive > ( header . rra Count ) ; for ( int i = NUM ; i < header . rra Count ; i ++ ) { Archive archive = new Archive ( this ) ; archives . add ( archive ) ; } long last up = ( long ) rrd File . read Long ( ) * NUM ; if ( header . get Version As Int ( ) >= Constants . VERSION WITH LAST UPDATE SEC ) { long last up usec = rrd File . read Long ( ) ; last up += last up usec / NUM ; } last Update = new Date ( last up ) ; for ( int i = NUM ; i < header . ds Count ; i ++ ) { Data Source ds = data Sources . get ( i ) ; ds . load PDP Status Block ( rrd File ) ; } for ( int i = NUM ; i < header . rra Count ; i ++ ) { Archive archive = archives . get ( i ) ; archive . load CDP Status Blocks ( rrd File , header . ds Count ) ; } for ( int i = NUM ; i < header . rra Count ; i ++ ) { Archive archive = archives . get ( i ) ; archive . load Current Row ( rrd File ) ; } for ( int i = NUM ; i < header . rra Count ; i ++ ) { Archive archive = archives . get ( i ) ; archive . load Data ( rrd File , header . ds Count ) ; } }
public void close ( ) throws IO Exception { input Stream . close ( ) ; }
public Address malloc ( int size , int howmany ) { int result = next Reservable Address ; next Reservable Address += size * howmany ; if ( next Reservable Address > ( MEMSIZE + mem Address Start ) ) { address Out Of Range = BOOL ; return null ; } return new Address ( Op . MEM , size , result ) ; }
public static String mask Left ( String s , int len , char mask ch ) { if ( len <= NUM ) { return s ; } len = Math . min ( len , s . length ( ) ) ; String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < len ; i ++ ) { sb . append ( mask ch ) ; } sb . append ( s . substring ( len ) ) ; return sb . to String ( ) ; }
public static double pdf ( double x , double mu , double sigma , double skew ) { x = ( x - mu ) / sigma ; if ( Math . abs ( skew ) > NUM ) { x = - Math . log ( NUM - skew * x ) / skew ; } return Math Util . SQRTHALF * Math . exp ( - NUM * x * x ) / sigma / ( NUM - skew * x ) ; }
public Composer to ( long anim Duration , float x , float y , int alpha , float scale X , float scale Y , float rotation , Ease ease ) { m Tween Parameter List . add ( new Tween Parameter ( x , y , alpha , scale X , scale Y , rotation , anim Duration , ease ) ) ; return this ; }
@ Override public String to String ( ) { String Builder buffer = new String Builder ( NUM ) ; try { print ( buffer ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING , e ) ; } return buffer . to String ( ) ; }
@ Override public Mem Chunk Holder < Big Data Mem Allocator > create Chunk ( long size , boolean autoreclaim ) { Mem Chunk Holder < Big Data Mem Allocator > ret = null ; Long addr = m vmasvc . allocate ( m nid , size , BOOL ) ; if ( NUM == addr && m activegc ) { force GC ( ) ; addr = m vmasvc . allocate ( m nid , size , BOOL ) ; } if ( NUM != addr ) { ret = new Mem Chunk Holder < Big Data Mem Allocator > ( this , addr , size ) ; ret . set Collector ( m chunkcollector ) ; if ( autoreclaim ) { m chunkcollector . register ( ret ) ; } } return ret ; }
protected void draw Label ( Canvas canvas , String label Text , Default Renderer renderer , List < Rect F > prev Labels Bounds , int center X , int center Y , float short Radius , float long Radius , float current Angle , float angle , int left , int right , int color , Paint paint , boolean line , boolean display ) { if ( renderer . is Show Labels ( ) || display ) { paint . set Color ( color ) ; double r Angle = Math . to Radians ( NUM - ( current Angle + angle / NUM ) ) ; double sin Value = Math . sin ( r Angle ) ; double cos Value = Math . cos ( r Angle ) ; int x1 = Math . round ( center X + ( float ) ( short Radius * sin Value ) ) ; int y1 = Math . round ( center Y + ( float ) ( short Radius * cos Value ) ) ; int x2 = Math . round ( center X + ( float ) ( long Radius * sin Value ) ) ; int y2 = Math . round ( center Y + ( float ) ( long Radius * cos Value ) ) ; float size = renderer . get Labels Text Size ( ) ; float extra = Math . max ( size / NUM , NUM ) ; paint . set Text Align ( Align . LEFT ) ; if ( x1 > x2 ) { extra = - extra ; paint . set Text Align ( Align . RIGHT ) ; } float x Label = x2 + extra ; float y Label = y2 ; float width = right - x Label ; if ( x1 > x2 ) { width = x Label - left ; } label Text = get Fit Text ( label Text , width , paint ) ; float width Label = paint . measure Text ( label Text ) ; boolean ok Bounds = BOOL ; while ( ! ok Bounds && line ) { boolean intersects = BOOL ; int length = prev Labels Bounds . size ( ) ; for ( int j = NUM ; j < length && ! intersects ; j ++ ) { Rect F prev Label Bounds = prev Labels Bounds . get ( j ) ; if ( prev Label Bounds . intersects ( x Label , y Label , x Label + width Label , y Label + size ) ) { intersects = BOOL ; y Label = Math . max ( y Label , prev Label Bounds . bottom ) ; } } ok Bounds = ! intersects ; } if ( line ) { y2 = ( int ) ( y Label - size / NUM ) ; canvas . draw Line ( x1 , y1 , x2 , y2 , paint ) ; canvas . draw Line ( x2 , y2 , x2 + extra , y2 , paint ) ; } else { paint . set Text Align ( Align . CENTER ) ; } canvas . draw Text ( label Text , x Label , y Label , paint ) ; if ( line ) { prev Labels Bounds . add ( new Rect F ( x Label , y Label , x Label + width Label , y Label + size ) ) ; } } }
protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > NUM ) { final int scroll X = get Scroll X ( ) ; int padding Left = get Padding Left ( ) ; int padding Right = get Padding Right ( ) ; final int width = get Width ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL GRAVITY MASK ; int child Left = NUM ; switch ( hgrav ) { default : child Left = padding Left ; break ; case Gravity . LEFT : child Left = padding Left ; padding Left += child . get Width ( ) ; break ; case Gravity . CENTER HORIZONTAL : child Left = Math . max ( ( width - child . get Measured Width ( ) ) / NUM , padding Left ) ; break ; case Gravity . RIGHT : child Left = width - padding Right - child . get Measured Width ( ) ; padding Right += child . get Measured Width ( ) ; break ; } child Left += scroll X ; final int child Offset = child Left - child . get Left ( ) ; if ( child Offset != NUM ) { child . offset Left And Right ( child Offset ) ; } } } if ( m On Page Change Listener != null ) { m On Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Internal Page Change Listener != null ) { m Internal Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Page Transformer != null ) { final int scroll X = get Scroll X ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Left ( ) - scroll X ) / get Client Width ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = BOOL ; }
public void Draw Semivariogram Surface ( double Radius , boolean An Isotropic ) { double [ ] [ ] data = new double [ NUM ] [ Bin Surface . length * Bin Surface [ NUM ] . length ] ; int n = NUM ; double max = Double . MIN VALUE ; for ( int i = NUM ; i < Bin Surface . length ; i ++ ) { for ( int j = NUM ; j < Bin Surface [ i ] . length ; j ++ ) { data [ NUM ] [ n ] = Bin Surface [ i ] [ j ] . Grid Hor Distance ; data [ NUM ] [ n ] = Bin Surface [ i ] [ j ] . Grid Ver Distance ; if ( ( Math . pow ( data [ NUM ] [ n ] , NUM ) + Math . pow ( data [ NUM ] [ n ] , NUM ) ) <= Radius * Radius && ! Double . is Na N ( Bin Surface [ i ] [ j ] . Value ) ) { data [ NUM ] [ n ] = Bin Surface [ i ] [ j ] . Value ; if ( max < data [ NUM ] [ n ] ) { max = data [ NUM ] [ n ] ; } } else { data [ NUM ] [ n ] = - NUM ; } n ++ ; } } Default XYZ Dataset dataset = new Default XYZ Dataset ( ) ; dataset . add Series ( STRING , data ) ; Number Axis x Axis = new Number Axis ( ) ; x Axis . set Standard Tick Units ( Number Axis . create Integer Tick Units ( ) ) ; x Axis . set Lower Margin ( NUM ) ; x Axis . set Upper Margin ( NUM ) ; Number Axis y Axis = new Number Axis ( ) ; y Axis . set Standard Tick Units ( Number Axis . create Integer Tick Units ( ) ) ; y Axis . set Lower Margin ( NUM ) ; y Axis . set Upper Margin ( NUM ) ; XY Block Renderer renderer = new XY Block Renderer ( ) ; renderer . set Block Width ( Lag Size ) ; renderer . set Block Height ( Lag Size ) ; renderer . set Block Anchor ( Rectangle Anchor . CENTER ) ; Lookup Paint Scale paint Scale = new Lookup Paint Scale ( NUM , max , Color . white ) ; double color Range = max / NUM ; paint Scale . add ( NUM , Color . blue ) ; paint Scale . add ( NUM * color Range , Color . green ) ; paint Scale . add ( NUM * color Range , Color . cyan ) ; paint Scale . add ( NUM * color Range , Color . yellow ) ; paint Scale . add ( NUM * color Range , Color . ORANGE ) ; paint Scale . add ( NUM * color Range , Color . red ) ; renderer . set Paint Scale ( paint Scale ) ; XY Plot plot = new XY Plot ( dataset , x Axis , y Axis , renderer ) ; plot . set Background Paint ( Color . light Gray ) ; plot . set Domain Gridlines Visible ( BOOL ) ; plot . set Range Gridline Paint ( Color . white ) ; if ( An Isotropic ) { Combined Range XY Plot combinedrangexyplot = new Combined Range XY Plot ( ) ; XY Series series T 1 = new XY Series ( STRING ) ; XY Series Collection Angle Collct = new XY Series Collection ( ) ; double bw = Band Width ; double r = bw / Math . sin ( Tolerance ) ; if ( r > Radius ) { bw = Radius * Math . sin ( Tolerance ) ; r = Radius ; } series T 1 . add ( r * Math . cos ( Angle + Tolerance ) , r * Math . sin ( Angle + Tolerance ) ) ; if ( ( double ) Math . round ( Math . sin ( Angle ) * NUM ) / NUM != NUM ) { if ( ( double ) Math . round ( Math . cos ( Angle ) * NUM ) / NUM != NUM ) { double a = ( NUM + Math . pow ( Math . tan ( Angle ) , NUM ) ) ; double b = NUM * bw / Math . sin ( Angle ) * Math . pow ( Math . tan ( Angle ) , NUM ) ; double c = Math . pow ( Math . tan ( Angle ) , NUM ) * Math . pow ( bw / Math . sin ( Angle ) , NUM ) - Math . pow ( Radius , NUM ) ; double x1 = ( - b + Math . sqrt ( Math . pow ( b , NUM ) - NUM * a * c ) ) / ( NUM * a ) ; double y1 = Math . tan ( Angle ) * ( x1 + bw / Math . sin ( Angle ) ) ; double x2 = ( - b - Math . sqrt ( Math . pow ( b , NUM ) - NUM * a * c ) ) / ( NUM * a ) ; double y2 = Math . tan ( Angle ) * ( x2 + bw / Math . sin ( Angle ) ) ; double d1 = Math . sqrt ( ( Math . pow ( ( Radius * Math . cos ( Angle ) - x1 ) , NUM ) ) + ( Math . pow ( ( Radius * Math . sin ( Angle ) - y1 ) , NUM ) ) ) ; double d2 = Math . sqrt ( ( Math . pow ( ( Radius * Math . cos ( Angle ) - x2 ) , NUM ) ) + ( Math . pow ( ( Radius * Math . sin ( Angle ) - y2 ) , NUM ) ) ) ; if ( d1 < d2 ) { series T 1 . add ( x1 , y1 ) ; } else { series T 1 . add ( x2 , y2 ) ; } } else { double x1 = - bw * Math . sin ( Angle ) ; double y1 = Math . sqrt ( Math . pow ( Radius , NUM ) - Math . pow ( x1 , NUM ) ) ; double y2 = - Math . sqrt ( Math . pow ( Radius , NUM ) - Math . pow ( x1 , NUM ) ) ; double d1 = Math . sqrt ( ( Math . pow ( ( Radius * Math . cos ( Angle ) - x1 ) , NUM ) ) + ( Math . pow ( ( Radius * Math . sin ( Angle ) - y1 ) , NUM ) ) ) ; double d2 = Math . sqrt ( ( Math . pow ( ( Radius * Math . cos ( Angle ) - x1 ) , NUM ) ) + ( Math . pow ( ( Radius * Math . sin ( Angle ) - y2 ) , NUM ) ) ) ; if ( d1 < d2 ) { series T 1 . add ( x1 , y1 ) ; } else { series T 1 . add ( x1 , y2 ) ; } } } else { double y1 = bw * Math . cos ( Angle ) ; double x1 = Math . sqrt ( Math . pow ( Radius , NUM ) - Math . pow ( y1 , NUM ) ) ; double x2 = - Math . sqrt ( Math . pow ( Radius , NUM ) - Math . pow ( y1 , NUM ) ) ; double d1 = Math . sqrt ( ( Math . pow ( ( Radius * Math . cos ( Angle ) - x1 ) , NUM ) ) + ( Math . pow ( ( Radius * Math . sin ( Angle ) - y1 ) , NUM ) ) ) ; double d2 = Math . sqrt ( ( Math . pow ( ( Radius * Math . cos ( Angle ) - x2 ) , NUM ) ) + ( Math . pow ( ( Radius * Math . sin ( Angle ) - y1 ) , NUM ) ) ) ; if ( d1 < d2 ) { series T 1 . add ( x1 , y1 ) ; } else { series T 1 . add ( x2 , y1 ) ; } } Angle Collct . add Series ( series T 1 ) ; XY Series series T 2 = new XY Series ( STRING ) ; series T 2 . add ( r * Math . cos ( Angle + Tolerance ) , r * Math . sin ( Angle + Tolerance ) ) ; series T 2 . add ( NUM , NUM ) ; Angle Collct . add Series ( series T 2 ) ; XY Series series T 3 = new XY Series ( STRING ) ; series T 3 . add ( Radius * Math . cos ( Angle ) , Radius * Math . sin ( Angle ) ) ; series T 3 . add ( NUM , NUM ) ; Angle Collct . add Series ( series T 3 ) ; XY Series series T 4 = new XY Series ( STRING ) ; series T 4 . add ( r * Math . cos ( Angle - Tolerance ) , r * Math . sin ( Angle - Tolerance ) ) ; series T 4 . add ( NUM , NUM ) ; Angle Collct . add Series ( series T 4 ) ; XY Series series T 5 = new XY Series ( STRING ) ; series T 5 . add ( r * Math . cos ( Angle - Tolerance ) , r * Math . sin ( Angle - Tolerance ) ) ; if ( ( double ) Math . round ( Math . sin ( Angle ) * NUM ) / NUM != NUM ) { if ( ( double ) Math . round ( Math . cos ( Angle ) * NUM ) / NUM != NUM ) { double a = ( NUM + Math . pow ( Math . tan ( Angle ) , NUM ) ) ; double b = - NUM * bw / Math . sin ( Angle ) * Math . pow ( Math . tan ( Angle ) , NUM ) ; double c = Math . pow ( Math . tan ( Angle ) , NUM ) * Math . pow ( bw / Math . sin ( Angle ) , NUM ) - Math . pow ( Radius , NUM ) ; double x1 = ( - b + Math . sqrt ( Math . pow ( b , NUM ) - NUM * a * c ) ) / ( NUM * a ) ; double y1 = Math . tan ( Angle ) * ( x1 - bw / Math . sin ( Angle ) ) ; double x2 = ( - b - Math . sqrt ( Math . pow ( b , NUM ) - NUM * a * c ) ) / ( NUM * a ) ; double y2 = Math . tan ( Angle ) * ( x2 - bw / Math . sin ( Angle ) ) ; double d1 = Math . sqrt ( ( Math . pow ( ( Radius * Math . cos ( Angle ) - x1 ) , NUM ) ) + ( Math . pow ( ( Radius * Math . sin ( Angle ) - y1 ) , NUM ) ) ) ; double d2 = Math . sqrt ( ( Math . pow ( ( Radius * Math . cos ( Angle ) - x2 ) , NUM ) ) + ( Math . pow ( ( Radius * Math . sin ( Angle ) - y2 ) , NUM ) ) ) ; if ( d1 < d2 ) { series T 5 . add ( x1 , y1 ) ; } else { series T 5 . add ( x2 , y2 ) ; } } else { double x1 = bw * Math . sin ( Angle ) ; double y1 = Math . sqrt ( Math . pow ( Radius , NUM ) - Math . pow ( x1 , NUM ) ) ; double y2 = - Math . sqrt ( Math . pow ( Radius , NUM ) - Math . pow ( x1 , NUM ) ) ; double d1 = Math . sqrt ( ( Math . pow ( ( Radius * Math . cos ( Angle ) - x1 ) , NUM ) ) + ( Math . pow ( ( Radius * Math . sin ( Angle ) - y1 ) , NUM ) ) ) ; double d2 = Math . sqrt ( ( Math . pow ( ( Radius * Math . cos ( Angle ) - x1 ) , NUM ) ) + ( Math . pow ( ( Radius * Math . sin ( Angle ) - y2 ) , NUM ) ) ) ; if ( d1 < d2 ) { series T 5 . add ( x1 , y1 ) ; } else { series T 5 . add ( x1 , y2 ) ; } } } else { double y1 = - bw * Math . cos ( Angle ) ; double x1 = Math . sqrt ( Math . pow ( Radius , NUM ) - Math . pow ( y1 , NUM ) ) ; double x2 = - Math . sqrt ( Math . pow ( Radius , NUM ) - Math . pow ( y1 , NUM ) ) ; double d1 = Math . sqrt ( ( Math . pow ( ( Radius * Math . cos ( Angle ) - x1 ) , NUM ) ) + ( Math . pow ( ( Radius * Math . sin ( Angle ) - y1 ) , NUM ) ) ) ; double d2 = Math . sqrt ( ( Math . pow ( ( Radius * Math . cos ( Angle ) - x2 ) , NUM ) ) + ( Math . pow ( ( Radius * Math . sin ( Angle ) - y1 ) , NUM ) ) ) ; if ( d1 < d2 ) { series T 5 . add ( x1 , y1 ) ; } else { series T 5 . add ( x2 , y1 ) ; } } Angle Collct . add Series ( series T 5 ) ; plot . set Dataset ( NUM , Angle Collct ) ; XY Line And Shape Renderer lineshap Rend = new XY Line And Shape Renderer ( BOOL , BOOL ) ; for ( int i = NUM ; i < Angle Collct . get Series Count ( ) ; i ++ ) { lineshap Rend . set Series Paint ( i , Color . BLACK ) ; } plot . set Renderer ( NUM , lineshap Rend ) ; combinedrangexyplot . add ( plot ) ; } plot . set Dataset Rendering Order ( Dataset Rendering Order . FORWARD ) ; J Free Chart chart = new J Free Chart ( STRING , plot ) ; chart . remove Legend ( ) ; chart . set Background Paint ( Color . white ) ; Chart Frame frame = new Chart Frame ( STRING , chart ) ; frame . pack ( ) ; frame . set Visible ( BOOL ) ; }
public static void over Scroll By ( final Pull To Refresh Base < ? > view , final int delta X , final int scroll X , final int delta Y , final int scroll Y , final int scroll Range , final int fuzzy Threshold , final float scale Factor , final boolean is Touch Event ) { final int delta Value , current Scroll Value , scroll Value ; switch ( view . get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : delta Value = delta X ; scroll Value = scroll X ; current Scroll Value = view . get Scroll X ( ) ; break ; case VERTICAL : default : delta Value = delta Y ; scroll Value = scroll Y ; current Scroll Value = view . get Scroll Y ( ) ; break ; } if ( view . is Pull To Refresh Over Scroll Enabled ( ) && ! view . is Refreshing ( ) ) { final Mode mode = view . get Mode ( ) ; if ( mode . permits Pull To Refresh ( ) && ! is Touch Event && delta Value != NUM ) { final int new Scroll Value = ( delta Value + scroll Value ) ; if ( Pull To Refresh Base . DEBUG ) { Log . d ( LOG TAG , STRING + delta X + STRING + scroll X + STRING + delta Y + STRING + scroll Y + STRING + new Scroll Value + STRING + scroll Range + STRING + current Scroll Value ) ; } if ( new Scroll Value < ( NUM - fuzzy Threshold ) ) { if ( mode . show Header Loading Layout ( ) ) { if ( current Scroll Value == NUM ) { view . set State ( State . OVERSCROLLING ) ; } view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value ) ) ) ; } } else if ( new Scroll Value > ( scroll Range + fuzzy Threshold ) ) { if ( mode . show Footer Loading Layout ( ) ) { if ( current Scroll Value == NUM ) { view . set State ( State . OVERSCROLLING ) ; } view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value - scroll Range ) ) ) ; } } else if ( Math . abs ( new Scroll Value ) <= fuzzy Threshold || Math . abs ( new Scroll Value - scroll Range ) <= fuzzy Threshold ) { view . set State ( State . RESET ) ; } } else if ( is Touch Event && State . OVERSCROLLING == view . get State ( ) ) { view . set State ( State . RESET ) ; } } }
public Single < T Access Token > grant New Access Token ( O Auth 2 Grant < T Access Token > grant ) { return grant New Access Token ( grant , Calendar . get Instance ( ) ) ; }
public static Number floor ( Number a ) { if ( is Floating Point ( a ) ) { return Math . floor ( a . double Value ( ) ) ; } else { return a . long Value ( ) ; } }
private void read Defs Element ( IXML Element elem ) throws IO Exception { for ( IXML Element child : elem . get Children ( ) ) { Figure child Figure = read Element ( child ) ; } }
@ Nullable private static Activity Wrapper find Launcher Activity For Device ( @ Not Null List < Activity Wrapper > launchable Activities , @ Not Null I Device device ) { if ( device . supports Feature ( I Device . Hardware Feature . TV ) ) { return find Leanback Launcher ( launchable Activities ) ; } return null ; }
public boolean is Query Running ( final Bound Entity song ) { synchronized ( m Running Queries ) { return m Running Queries . contains ( song ) ; } }
public synchronized void flush ( ) throws IO Exception { check Not Closed ( ) ; trim To Size ( ) ; trim To File Count ( ) ; journal Writer . flush ( ) ; }
private Response < Bitmap > do Parse ( Network Response response ) { byte [ ] data = response . data ; Bitmap Factory . Options decode Options = new Bitmap Factory . Options ( ) ; Bitmap bitmap = null ; if ( m Max Width == NUM && m Max Height == NUM ) { decode Options . in Preferred Config = m Decode Config ; bitmap = Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; } else { decode Options . in Just Decode Bounds = BOOL ; Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; int actual Width = decode Options . out Width ; int actual Height = decode Options . out Height ; int desired Width = get Resized Dimension ( m Max Width , m Max Height , actual Width , actual Height ) ; int desired Height = get Resized Dimension ( m Max Height , m Max Width , actual Height , actual Width ) ; decode Options . in Just Decode Bounds = BOOL ; decode Options . in Sample Size = find Best Sample Size ( actual Width , actual Height , desired Width , desired Height ) ; Bitmap temp Bitmap = Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; if ( temp Bitmap != null && ( temp Bitmap . get Width ( ) > desired Width || temp Bitmap . get Height ( ) > desired Height ) ) { bitmap = Bitmap . create Scaled Bitmap ( temp Bitmap , desired Width , desired Height , BOOL ) ; temp Bitmap . recycle ( ) ; } else { bitmap = temp Bitmap ; } } if ( bitmap == null ) { return Response . error ( new Parse Error ( response ) ) ; } else { return Response . success ( bitmap , Http Header Parser . parse Cache Headers ( response ) ) ; } }
private Map < String , Extension File Filter > add Extensions ( J File Chooser chooser ) { Map < String , Extension File Filter > filters = new Hash Map < String , Extension File Filter > ( ) ; for ( Map . Entry < String , String > entry : exts . entry Set ( ) ) { Extension File Filter filter = new Extension File Filter ( entry . get Key ( ) , entry . get Value ( ) ) ; filters . put ( entry . get Key ( ) , filter ) ; chooser . add Choosable File Filter ( filter ) ; } return filters ; }
public static String with Node Info ( Accessibility Node Info node Info ) { if ( node Info == null ) { return null ; } return String . format ( STRING , node Info . get Text ( ) , node Info . get Content Description ( ) ) ; }
static int all Parameters And Arguments Match With Default Params ( Parameter [ ] params , Class Node [ ] args ) { int dist = NUM ; Class Node ptype = null ; for ( int i = NUM , j = NUM ; i < params . length ; i ++ ) { Parameter param = params [ i ] ; Class Node param Type = param . get Type ( ) ; Class Node arg = j >= args . length ? null : args [ j ] ; if ( arg == null || ! is Assignable To ( arg , param Type ) ) { if ( ! param . has Initial Expression ( ) && ( ptype == null || ! ptype . equals ( param Type ) ) ) { return - NUM ; } ptype = null ; } else { j ++ ; if ( ! param Type . equals ( arg ) ) dist += get Distance ( arg , param Type ) ; if ( param . has Initial Expression ( ) ) { ptype = arg ; } else { ptype = null ; } } } return dist ; }
private void expect ( char expected Symbol ) throws Parse Exception { if ( ! accept ( expected Symbol ) ) throw new Parse Exception ( STRING + expected Symbol + STRING + ( char ) data [ index ] + STRING , index ) ; }
public static byte [ ] string To Utf 8 Bytes ( String string ) { int len = string . length ( ) ; byte [ ] bytes = new byte [ len * NUM ] ; int out At = NUM ; for ( int i = NUM ; i < len ; i ++ ) { char c = string . char At ( i ) ; if ( ( c != NUM ) && ( c < NUM ) ) { bytes [ out At ] = ( byte ) c ; out At ++ ; } else if ( c < NUM ) { bytes [ out At ] = ( byte ) ( ( ( c > > NUM ) & NUM ) | NUM ) ; bytes [ out At + NUM ] = ( byte ) ( ( c & NUM ) | NUM ) ; out At += NUM ; } else { bytes [ out At ] = ( byte ) ( ( ( c > > NUM ) & NUM ) | NUM ) ; bytes [ out At + NUM ] = ( byte ) ( ( ( c > > NUM ) & NUM ) | NUM ) ; bytes [ out At + NUM ] = ( byte ) ( ( c & NUM ) | NUM ) ; out At += NUM ; } } byte [ ] result = new byte [ out At ] ; System . arraycopy ( bytes , NUM , result , NUM , out At ) ; return result ; }
public abstract void init Parameters ( int [ ] a Circuit Data , I Redstone Circuit Block a Redstone Circuit Block ) ;
public Contentlet execute Safe First ( ) { List < Contentlet > result = execute Safe ( ) ; if ( result . size ( ) > NUM ) { return result . get ( NUM ) ; } return null ; }
public void clear ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { for ( Node < E > f = first ; f != null ; ) { f . item = null ; Node < E > n = f . next ; f . prev = null ; f . next = null ; f = n ; } first = last = null ; count = NUM ; not Full . signal All ( ) ; } finally { lock . unlock ( ) ; } }
public void clear ( ) { ored Criteria . clear ( ) ; order By Clause = null ; distinct = BOOL ; }
private static int determine Consecutive Digit Count ( Char Sequence msg , int startpos ) { int count = NUM ; int len = msg . length ( ) ; int idx = startpos ; if ( idx < len ) { char ch = msg . char At ( idx ) ; while ( is Digit ( ch ) && idx < len ) { count ++ ; idx ++ ; if ( idx < len ) { ch = msg . char At ( idx ) ; } } } return count ; }
public static boolean is File Exist ( String file Path , File Type file Type , boolean perform File Check ) throws IO Exception { file Path = file Path . replace ( STRING , STRING ) ; switch ( file Type ) { case HDFS : case VIEWFS : Path path = new Path ( file Path ) ; File System fs = path . get File System ( configuration ) ; if ( perform File Check ) { return fs . exists ( path ) && fs . is File ( path ) ; } else { return fs . exists ( path ) ; } case LOCAL : default : File default File = new File ( file Path ) ; if ( perform File Check ) { return default File . exists ( ) && default File . is File ( ) ; } else { return default File . exists ( ) ; } } }
private Double Factor pointwise Product ( List < Double Factor > factors ) { if ( factors . is Empty ( ) ) { Double Factor factor = new Double Factor ( ) ; factor . add Entry ( new Assignment ( ) , NUM , NUM ) ; return factor ; } else if ( factors . size ( ) == NUM ) { return factors . get ( NUM ) ; } Double Factor factor = factors . get ( NUM ) ; factors . remove ( NUM ) ; for ( Double Factor f : factors ) { Double Factor temp Factor = new Double Factor ( ) ; Set < String > shared Vars = new Hash Set < String > ( f . get Variables ( ) ) ; shared Vars . retain All ( factor . get Variables ( ) ) ; for ( Assignment a : f . get Values ( ) ) { double [ ] entry = f . get Entry ( a ) ; double prob = entry [ NUM ] ; double util = entry [ NUM ] ; for ( Assignment b : factor . get Values ( ) ) { if ( b . consistent With ( a , shared Vars ) ) { double [ ] entry 2 = factor . get Entry ( b ) ; double prob 2 = entry 2 [ NUM ] ; double util 2 = entry 2 [ NUM ] ; double product = prob * prob 2 ; double sum = util + util 2 ; temp Factor . add Entry ( new Assignment ( a , b ) , product , sum ) ; } } } factor = temp Factor ; } return factor ; }
public Class Path ( ) { String syscp = System . get Property ( STRING ) ; String envcp = System . get Property ( STRING ) ; if ( envcp == null ) envcp = STRING ; String cp = syscp + File . path Separator + envcp ; init ( cp ) ; }
protected static boolean uninstall Add On Extension ( Add On add On , Extension extension , Add On Uninstallation Progress Callback callback ) { boolean uninstalled Without Errors = BOOL ; if ( extension . is Enabled ( ) ) { String ext Ui Name = extension . get UI Name ( ) ; if ( extension . can Unload ( ) ) { logger . debug ( STRING + extension . get Name ( ) ) ; try { extension . unload ( ) ; Extension Factory . unload Add On Extension ( extension ) ; } catch ( Exception e ) { logger . error ( STRING + extension . get Name ( ) + STRING + add On . get Id ( ) + STRING , e ) ; uninstalled Without Errors = BOOL ; } } else { logger . debug ( STRING + extension . get Name ( ) ) ; uninstalled Without Errors = BOOL ; } callback . extension Removed ( ext Ui Name ) ; } add On . remove Loaded Extension ( extension ) ; return uninstalled Without Errors ; }
private static String pick Random Stats Fields ( String [ ] field Names ) { String field Name ; do { field Name = field Names [ Test Util . next Int ( random ( ) , NUM , field Names . length - NUM ) ] ; } while ( field Name . ends With ( STRING ) || field Name . ends With ( STRING ) ) ; return field Name ; }
@ Override public synchronized void do Delete Child ( Base Solr Resource endpoint , String child Id ) { String key = get Ignore Case ( ) ? child Id . to Lower Case ( Locale . ROOT ) : child Id ; if ( ! managed Words . contains ( key ) ) throw new Solr Exception ( Error Code . NOT FOUND , String . format ( Locale . ROOT , STRING , child Id , get Resource Id ( ) ) ) ; managed Words . remove ( key ) ; store Managed Data ( managed Words ) ; log . info ( STRING , key ) ; }
public static final String write Time ( double seconds , final String timeformat , final char separator ) { if ( seconds < NUM ) { if ( seconds == UNDEFINED TIME ) return STRING ; return STRING + write Time ( Math . abs ( seconds ) , timeformat , separator ) ; } int day = ( int ) ( seconds / MIDNIGHT ) ; seconds %= MIDNIGHT ; if ( TIMEFORMAT EEESSSS . equals ( timeformat ) ) return Week . get Day Name ( day ) + STRING + Long . to String ( ( long ) ( seconds ) ) ; double s = seconds ; long h = ( long ) ( s / NUM ) ; s = s % NUM ; int m = ( int ) ( s / NUM ) ; s = s % NUM ; String Builder str = new String Builder ( NUM ) ; if ( h < time Elements . length ) { str . append ( time Elements [ ( int ) h ] ) ; } else { str . append ( Long . to String ( h ) ) ; } str . append ( separator ) ; str . append ( time Elements [ m ] ) ; if ( TIMEFORMAT EEEHHMM . equals ( timeformat ) ) { return Week . get Day Name ( day ) + STRING + str . to String ( ) ; } if ( TIMEFORMAT EEEHHMMSS . equals ( timeformat ) ) { str . append ( separator ) ; str . append ( time Elements [ ( int ) s ] ) ; return Week . get Day Name ( day ) + STRING + str . to String ( ) ; } if ( TIMEFORMAT HHMMSSDOTSS . equals ( timeformat ) ) { str . append ( separator ) ; if ( s < NUM ) { str . append ( STRING ) ; } str . append ( s ) ; return Week . get Day Name ( day ) + STRING + str . to String ( ) ; } throw new Illegal Argument Exception ( STRING + timeformat + STRING ) ; }
public D Export Private Key Type ( J Frame parent ) { super ( parent , Dialog . Modality Type . DOCUMENT MODAL ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; }
public static I Point [ ] copy Of ( I Point [ ] original , int new Length ) { I Point [ ] copy = new I Point [ new Length ] ; System . arraycopy ( original , NUM , copy , NUM , Math . min ( original . length , new Length ) ) ; return copy ; }
public void write Footer ( ) { ps . println ( STRING ) ; ps . println ( STRING ) ; ps . println ( STRING ) ; }
protected void save Object ( Object object ) { if ( m File Chooser == null ) { create File Chooser ( ) ; } int return Val = m File Chooser . show Save Dialog ( this ) ; if ( return Val == J File Chooser . APPROVE OPTION ) { File s File = m File Chooser . get Selected File ( ) ; try { Object Output Stream oo = new Object Output Stream ( new Buffered Output Stream ( new File Output Stream ( s File ) ) ) ; oo . write Object ( object ) ; oo . close ( ) ; } catch ( Exception ex ) { J Option Pane . show Message Dialog ( this , STRING + s File . get Name ( ) + STRING + ex . get Message ( ) , STRING , J Option Pane . ERROR MESSAGE ) ; } } }
@ Override public void write ( Data Output out ) throws IO Exception { if ( USE HADOOP TEXT ) Text . write String ( out , term ) ; else out . write UTF ( term ) ; Writable Utils . write V Int ( out , splitno ) ; Writable Utils . write V Int ( out , flushno ) ; }
public static String strip Non Digits ( String str ) { String Buffer result = new String Buffer ( str . length ( ) ) ; for ( char candidate : str . to Char Array ( ) ) { if ( Character . is Digit ( candidate ) ) { result . append ( candidate ) ; } } return result . to String ( ) ; }
protected Collection < Communication Summary Statistics > do Get Communication Summary Statistics ( String tenant Id , Criteria criteria ) { String index = client . get Index ( tenant Id ) ; Map < String , Communication Summary Statistics > stats = new Hash Map < > ( ) ; if ( ! criteria . transaction Wide ( ) ) { Criteria txn Wide Criteria = criteria . derive Transaction Wide ( ) ; build Communication Summary Statistics ( stats , index , txn Wide Criteria , BOOL ) ; } build Communication Summary Statistics ( stats , index , criteria , BOOL ) ; return stats . values ( ) ; }
public void remove Content ( String variable Id ) { if ( ! paused ) { cur State . remove From State ( variable Id ) ; update ( ) ; } else { log . info ( STRING + variable Id ) ; } }
public void add Command Listener ( Action Listener l ) { if ( global Command Listeners == null ) { global Command Listeners = new Event Dispatcher ( ) ; } global Command Listeners . add Listener ( l ) ; }
public static void complete Background Tasks ( long timeout Millis ) { boolean fifo Empty = BOOL ; boolean async Threads Completed = BOOL ; long abs Timeout = System . current Time Millis ( ) + timeout Millis ; while ( System . current Time Millis ( ) < abs Timeout ) { synchronized ( fifo ) { fifo Empty = fifo . size ( ) == NUM ; } synchronized ( J Google Analytics Tracker . class ) { async Threads Completed = async Threads Running == NUM ; } if ( fifo Empty && async Threads Completed ) break ; try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { break ; } } }
private synchronized void write Object ( java . io . Object Output Stream s ) throws IO Exception { if ( actions == null ) get Actions ( ) ; s . default Write Object ( ) ; }
public static final byte [ ] decode ( Buffered Reader reader ) throws IO Exception , Base 64 Decoding Exception { byte [ ] ret Bytes = null ; Unsync Byte Array Output Stream baos = null ; try { baos = new Unsync Byte Array Output Stream ( ) ; String line ; while ( null != ( line = reader . read Line ( ) ) ) { byte [ ] bytes = decode ( line ) ; baos . write ( bytes ) ; } ret Bytes = baos . to Byte Array ( ) ; } finally { baos . close ( ) ; } return ret Bytes ; }
public boolean is Defined In Env ( ) { if ( env Vars == null || param Names . length == NUM ) { return BOOL ; } for ( String var : env Vars ) { if ( System . getenv ( var ) == null ) { return BOOL ; } } return BOOL ; }
public void apply ( Animator animator , float curr Value , float end Value , float velocity ) { apply ( animator , curr Value , end Value , velocity , Math . abs ( end Value - curr Value ) ) ; }
public void add Notice ( Parser Notice notice ) { notices . add ( notice ) ; }
@ Override public String to String ( ) { int len = session Id . length ; String Buffer s = new String Buffer ( NUM + NUM * len ) ; s . append ( STRING ) ; for ( int i = NUM ; i < len ; i ++ ) { s . append ( NUM & session Id [ i ] ) ; if ( i != ( len - NUM ) ) s . append ( STRING ) ; } s . append ( STRING ) ; return s . to String ( ) ; }
public Event Binder < E > after ( String name ) { after . add ( name ) ; return this ; }
public Point 2 D forward ( Point 2 D llp , Point 2 D pt ) { return forward ( llp . get Y ( ) , llp . get X ( ) , pt , BOOL ) ; }
private static int max Num Arcs For Dedup Byte ( int current Num Dedup Bytes ) { int max Arcs = NUM + ( NUM * current Num Dedup Bytes ) ; if ( current Num Dedup Bytes > NUM ) { max Arcs *= current Num Dedup Bytes ; } return Math . min ( max Arcs , NUM ) ; }
public Job Create Request create Job Create Request ( String namespace Cd , String job Name ) { List < Parameter > parameters = new Array List < > ( ) ; Parameter parameter = new Parameter ( Abstract Service Test . ATTRIBUTE NAME 2 MIXED CASE , Abstract Service Test . ATTRIBUTE VALUE 2 ) ; parameters . add ( parameter ) ; parameter = new Parameter ( STRING , null ) ; parameters . add ( parameter ) ; return create Job Create Request ( namespace Cd , job Name , parameters ) ; }
private void load ( ) throws Repository Exception , RDF Parse Exception , IO Exception { final Repository Connection conn = repository . get Connection ( ) ; String ttl String = MODEL TTL ; Input Stream string Input = new Byte Array Input Stream ( ttl String . get Bytes ( ) ) ; conn . add ( string Input , STRING , RDF Format . TURTLE , new Resource [ ] { } ) ; ttl String = BUCKET TTL ; string Input = new Byte Array Input Stream ( ttl String . get Bytes ( ) ) ; conn . add ( string Input , STRING , RDF Format . TURTLE , new Resource [ ] { } ) ; conn . commit ( ) ; conn . close ( ) ; }
public boolean is Tax Included ( ) { if ( m M Price List ID == NUM ) { m M Price List ID = DB . get SQL Value ( get Trx Name ( ) , STRING , get C Order ID ( ) ) ; } M Price List pl = M Price List . get ( get Ctx ( ) , m M Price List ID , get Trx Name ( ) ) ; return pl . is Tax Included ( ) ; }
protected Web Resource create Request ( String uri Path ) { ensure Initialization ( ) ; return client Request Helper . create Request ( client , service URI , URI . create ( uri Path ) ) ; }
public static void init ( Context context ) { if ( camera Manager == null ) { camera Manager = new Camera Manager ( context ) ; } }
public void next Table ( ) throws SQL Exception { if ( tables . has Next ( ) ) { current Table = tables . next ( ) ; open Rows ( ) ; } }
public D Distinguished Name Chooser ( J Frame parent , String title , X500 Name distinguished Name , boolean editable ) { super ( parent , title , Dialog . Modality Type . DOCUMENT MODAL ) ; this . distinguished Name = distinguished Name ; this . editable = editable ; init Components ( ) ; }
public static boolean delete File ( String file Path And Name ) { if ( ( file Path And Name == null ) || file Path And Name . is Empty ( ) ) { return BOOL ; } boolean is Successful Delete = BOOL ; try { File file To Delete = new File ( file Path And Name ) ; is Successful Delete = file To Delete . delete ( ) ; } catch ( Exception e ) { logger . debug ( e . to String ( ) + System . line Separator ( ) + Stack Trace . get String From Stack Trace ( e ) ) ; is Successful Delete = BOOL ; } return is Successful Delete ; }
public Tungsten Properties IO ( File path ) { this ( new Java File IO ( ) , new File Path ( path . get Absolute Path ( ) ) ) ; }
private void compute Tab Offset Helper ( Rect F stack Rect ) { final boolean portrait = m Current Mode == Orientation . PORTRAIT ; final float parent Width = stack Rect . width ( ) ; final float parent Height = stack Rect . height ( ) ; final float overscroll Percent = compute Overscroll Percent ( ) ; final float scroll Offset = Math Utils . clamp ( m Scroll Offset , get Min Scroll ( BOOL ) , get Max Scroll ( BOOL ) ) ; final float stack Scale = get Stack Scale ( stack Rect ) ; int stacked Count = NUM ; float min Stacked Position = NUM ; for ( int i = NUM ; i < m Stack Tabs . length ; ++ i ) { assert m Stack Tabs [ i ] != null ; Stack Tab stack Tab = m Stack Tabs [ i ] ; Layout Tab layout Tab = stack Tab . get Layout Tab ( ) ; final float stack Scroll Offset = stack Tab . is Dying ( ) ? m Scroll Offset For Dying Tabs : scroll Offset ; float screen Scroll Offset = approx Screen ( stack Tab , stack Scroll Offset ) ; screen Scroll Offset = Math . max ( min Stacked Position , screen Scroll Offset ) ; if ( stacked Count < MAX NUMBER OF STACKED TABS TOP ) { final float tilt Xcos = ( float ) Math . cos ( Math . to Radians ( layout Tab . get Tilt X ( ) ) ) ; final float tilt Ycos = ( float ) Math . cos ( Math . to Radians ( layout Tab . get Tilt Y ( ) ) ) ; float collapse = Math . min ( Math . abs ( tilt Xcos ) , Math . abs ( tilt Ycos ) ) ; collapse *= layout Tab . get Alpha ( ) ; min Stacked Position += Stack Tab . s Stacked Tab Visible Size * collapse ; } stacked Count += stack Tab . is Dying ( ) ? NUM : NUM ; if ( overscroll Percent < NUM ) { screen Scroll Offset += ( overscroll Percent / OVERSCROLL TOP SLIDE PCTG ) * screen Scroll Offset ; screen Scroll Offset = Math . max ( NUM , screen Scroll Offset ) ; } float x In = ( parent Width - layout Tab . get Scaled Content Width ( ) ) / NUM ; float y In = ( parent Height - layout Tab . get Scaled Content Height ( ) ) / NUM ; final float horizontal Padding = ( parent Width - layout Tab . get Original Content Width ( ) * Stack Animation . SCALE AMOUNT * stack Scale ) / NUM ; final float vertical Padding = ( parent Height - layout Tab . get Original Content Height ( ) * Stack Animation . SCALE AMOUNT * stack Scale ) / NUM ; if ( portrait ) { y In += STACK PORTRAIT Y OFFSET PROPORTION * vertical Padding ; y In += screen Scroll Offset ; } else { if ( Localization Utils . is Layout Rtl ( ) ) { x In -= STACK LANDSCAPE START OFFSET PROPORTION * horizontal Padding ; x In -= screen Scroll Offset ; } else { x In += STACK LANDSCAPE START OFFSET PROPORTION * horizontal Padding ; x In += screen Scroll Offset ; } y In += STACK LANDSCAPE Y OFFSET PROPORTION * vertical Padding ; } layout Tab . set X ( x In ) ; layout Tab . set Y ( y In ) ; } stacked Count = NUM ; float max Stacked Position = portrait ? m Layout . get Height Minus Top Controls ( ) : m Layout . get Width ( ) ; for ( int i = m Stack Tabs . length - NUM ; i >= NUM ; i -- ) { assert m Stack Tabs [ i ] != null ; Stack Tab stack Tab = m Stack Tabs [ i ] ; Layout Tab layout Tab = stack Tab . get Layout Tab ( ) ; if ( stack Tab . is Dying ( ) ) continue ; float pos ; if ( portrait ) { pos = layout Tab . get Y ( ) ; layout Tab . set Y ( Math . min ( pos , max Stacked Position ) ) ; } else if ( Localization Utils . is Layout Rtl ( ) ) { float pos Offset = m Layout . get Width ( ) - layout Tab . get Original Content Width ( ) * Stack Animation . SCALE AMOUNT * stack Scale ; pos = - layout Tab . get X ( ) + pos Offset ; layout Tab . set X ( - Math . min ( pos , max Stacked Position ) + pos Offset ) ; } else { pos = layout Tab . get X ( ) ; layout Tab . set X ( Math . min ( pos , max Stacked Position ) ) ; } if ( pos >= max Stacked Position && stacked Count < MAX NUMBER OF STACKED TABS BOTTOM ) { max Stacked Position -= Stack Tab . s Stacked Tab Visible Size ; stacked Count ++ ; } } final float discard Range = get Discard Range ( ) ; for ( int i = NUM ; i < m Stack Tabs . length ; ++ i ) { assert m Stack Tabs [ i ] != null ; Stack Tab stack Tab = m Stack Tabs [ i ] ; Layout Tab layout Tab = stack Tab . get Layout Tab ( ) ; final float x In = layout Tab . get X ( ) + stack Tab . get X In Stack Offset ( ) ; final float y In = layout Tab . get Y ( ) + stack Tab . get Y In Stack Offset ( ) ; final float x Out = stack Tab . get X Out Of Stack ( ) ; final float y Out = stack Tab . get Y Out Of Stack ( ) ; float x = Math Utils . interpolate ( x Out , x In , stack Tab . get X In Stack Influence ( ) ) ; float y = Math Utils . interpolate ( y Out , y In , stack Tab . get Y In Stack Influence ( ) ) ; if ( stack Tab . get Discard Amount ( ) != NUM ) { float discard = stack Tab . get Discard Amount ( ) ; boolean from Click = stack Tab . get Discard From Click ( ) ; float scale = compute Discard Scale ( discard , discard Range , from Click ) ; float delta X = stack Tab . get Discard Origin X ( ) - stack Tab . get Layout Tab ( ) . get Original Content Width ( ) / NUM ; float delta Y = stack Tab . get Discard Origin Y ( ) - stack Tab . get Layout Tab ( ) . get Original Content Height ( ) / NUM ; float discard Offset = from Click ? NUM : discard ; if ( portrait ) { x += discard Offset + delta X * ( NUM - scale ) ; y += delta Y * ( NUM - scale ) ; } else { x += delta X * ( NUM - scale ) ; y += discard Offset + delta Y * ( NUM - scale ) ; } } layout Tab . set X ( stack Rect . left + x ) ; layout Tab . set Y ( stack Rect . top + y ) ; } }
@ Override public int compare To ( final Time Instant rhs ) { return Integer . compare ( this . time , rhs . time ) ; }
private boolean write To Characteristic ( Bluetooth Gatt Characteristic charc , byte [ ] data ) { charc . set Value ( data ) ; boolean result = m Gatt Client . write Characteristic ( charc ) ; if ( result ) { Log . d ( TAG , STRING + charc . get Uuid ( ) + STRING + Arrays . to String ( data ) ) ; } else { Log . e ( TAG , STRING + charc . get Uuid ( ) + STRING + Arrays . to String ( data ) ) ; } return result ; }
public static void compose Through Mask ( Raster src , Writable Raster dst , Raster sel ) { int x = src . get Min X ( ) ; int y = src . get Min Y ( ) ; int w = src . get Width ( ) ; int h = src . get Height ( ) ; int src RGB [ ] = null ; int sel RGB [ ] = null ; int dst RGB [ ] = null ; for ( int i = NUM ; i < h ; i ++ ) { src RGB = src . get Pixels ( x , y , w , NUM , src RGB ) ; sel RGB = sel . get Pixels ( x , y , w , NUM , sel RGB ) ; dst RGB = dst . get Pixels ( x , y , w , NUM , dst RGB ) ; int k = x ; for ( int j = NUM ; j < w ; j ++ ) { int sr = src RGB [ k ] ; int dir = dst RGB [ k ] ; int sg = src RGB [ k + NUM ] ; int dig = dst RGB [ k + NUM ] ; int sb = src RGB [ k + NUM ] ; int dib = dst RGB [ k + NUM ] ; int sa = src RGB [ k + NUM ] ; int dia = dst RGB [ k + NUM ] ; float a = sel RGB [ k + NUM ] / NUM ; float ac = NUM - a ; dst RGB [ k ] = ( int ) ( a * sr + ac * dir ) ; dst RGB [ k + NUM ] = ( int ) ( a * sg + ac * dig ) ; dst RGB [ k + NUM ] = ( int ) ( a * sb + ac * dib ) ; dst RGB [ k + NUM ] = ( int ) ( a * sa + ac * dia ) ; k += NUM ; } dst . set Pixels ( x , y , w , NUM , dst RGB ) ; y ++ ; } }
public char skip To ( char to ) { char c ; int index = this . my Index ; do { c = next ( ) ; if ( c == NUM ) { this . my Index = index ; return c ; } } while ( c != to ) ; back ( ) ; return c ; }
public int check Version Size ( final Software Version version ) { URL image Url = get Image URL ( version ) ; Http URL Connection url Connection = invoke Request ( image Url ) ; return url Connection . get Content Length ( ) ; }
private static Date Time Formatter create Formatter For Style ( String style ) { if ( style == null || style . length ( ) != NUM ) { throw new Illegal Argument Exception ( STRING + style ) ; } int date Style = select Style ( style . char At ( NUM ) ) ; int time Style = select Style ( style . char At ( NUM ) ) ; if ( date Style == NONE && time Style == NONE ) { throw new Illegal Argument Exception ( STRING ) ; } return create Formatter For Style Index ( date Style , time Style ) ; }
public boolean ack Next Chunk Id ( String id ) { if ( state . is Terminated ( ) ) return BOOL ; else if ( id . equals ( chunkid ) ) { return BOOL ; } else { if ( ! allow Other Chunks In Between ( id ) ) { if ( state . is Done ( ) ) { if ( ! is Terminated ( ) ) terminate ( ) ; return BOOL ; } else { throw new Pngj Input Exception ( STRING + id + STRING + chunkid + STRING ) ; } } else return BOOL ; } }
void submit ( Process And Display Image Task task ) { init Executors If Need ( ) ; task Executor For Cached Images . execute ( task ) ; }
private Top Docs combine ( Top Docs in , Top Docs resorted , Query Rescore Context ctx ) { System . arraycopy ( resorted . score Docs , NUM , in . score Docs , NUM , resorted . score Docs . length ) ; if ( in . score Docs . length > resorted . score Docs . length ) { for ( int i = resorted . score Docs . length ; i < in . score Docs . length ; i ++ ) { in . score Docs [ i ] . score *= ctx . query Weight ( ) ; } Arrays . sort ( in . score Docs , SCORE DOC COMPARATOR ) ; } return in ; }
public void test Pos Pos Same Length ( ) { byte a Bytes [ ] = { - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM } ; byte b Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
private Response < Bitmap > do Parse ( Network Response response ) { byte [ ] data = response . data ; Bitmap Factory . Options decode Options = new Bitmap Factory . Options ( ) ; Bitmap bitmap = null ; if ( m Max Width == NUM && m Max Height == NUM ) { decode Options . in Preferred Config = m Decode Config ; bitmap = Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; } else { decode Options . in Just Decode Bounds = BOOL ; Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; int actual Width = decode Options . out Width ; int actual Height = decode Options . out Height ; int desired Width = get Resized Dimension ( m Max Width , m Max Height , actual Width , actual Height , m Scale Type ) ; int desired Height = get Resized Dimension ( m Max Height , m Max Width , actual Height , actual Width , m Scale Type ) ; decode Options . in Just Decode Bounds = BOOL ; decode Options . in Sample Size = find Best Sample Size ( actual Width , actual Height , desired Width , desired Height ) ; Bitmap temp Bitmap = Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; if ( temp Bitmap != null && ( temp Bitmap . get Width ( ) > desired Width || temp Bitmap . get Height ( ) > desired Height ) ) { bitmap = Bitmap . create Scaled Bitmap ( temp Bitmap , desired Width , desired Height , BOOL ) ; temp Bitmap . recycle ( ) ; } else { bitmap = temp Bitmap ; } } if ( bitmap == null ) { return Response . error ( new Parse Error ( response ) ) ; } else { return Response . success ( bitmap , Http Header Parser . parse Cache Headers ( response ) ) ; } }
@ Override public void pause ( boolean to Pause ) { is Paused = to Pause ; }
public static String replace All ( String original , String old Substring , String new Substring ) { return replace ( original , old Substring , new Substring , BOOL ) ; }
public long add ( final Add Op add ) throws Exception { return add ( add , UUID . random UUID ( ) ) ; }
protected boolean is Small ( ) { return this . scale * this . text Size In Meters < this . pixel Size In Meters ; }
public byte [ ] decompress ( Data Input is ) { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; try { while ( BOOL ) { byte b = is . read Byte ( ) ; if ( b == - NUM ) break ; baos . write ( b ) ; } } catch ( EOF Exception ex ) { } catch ( IO Exception ex ) { throw new Runtime Exception ( ex ) ; } return decompress ( baos . to Byte Array ( ) ) ; }
public int borrow Spare Register ( int category ) { int result = spare Register Base + borrowed Spare Registers ; borrowed Spare Registers += category ; register Count = Math . max ( register Count , result + category ) ; return result ; }
public void True ( boolean expression , Object error Message ) { if ( ! expression ) { throw new Illegal Argument Exception ( String . value Of ( error Message ) ) ; } }
private void process Fields ( final Object component , final Context context , final Context Destroyer context Destroyer ) { Class < ? > component Class = component . get Class ( ) ; while ( component Class != null && ! component Class . equals ( Object . class ) ) { final Field [ ] fields = Class Reflection . get Declared Fields ( component Class ) ; if ( fields != null && fields . length > NUM ) { process Fields ( component , fields , context , context Destroyer ) ; } component Class = component Class . get Superclass ( ) ; } }
public static String replace All ( String input , String regular Expression , String replacement ) { return input . replace All ( regular Expression , replacement ) ; }
void request Notification Update ( ) { if ( m Current Notification Group Index != NOTIFICATION OFF ) { Rhythm Notification Service . show Notification ( m Context , m Notification Id ) ; } }
public static int count Lower Case ( final String text ) { int count = NUM ; for ( final char chr : text . to Char Array ( ) ) { if ( Character . is Lower Case ( chr ) ) { count ++ ; } } return count ; }
public void assign Service ( String service Name , Map attributes ) throws Id Repo Exception , SSO Exception { Id Services id Services = Id Services Factory . get Data Store Services ( ) ; Set O Cs = get Service O Cs ( token , service Name ) ; Schema Type stype ; Map t Map = new Hash Map ( ) ; t Map . put ( service Name , O Cs ) ; Set assigned Services = id Services . get Assigned Services ( token , type , name , t Map , org Name , univ DN ) ; if ( assigned Services . contains ( service Name ) ) { Object args [ ] = { service Name , type . get Name ( ) } ; throw new Id Repo Exception ( Id Repo Bundle . BUNDLE NAME , Id Repo Error Code . SERVICE ALREADY ASSIGNED , args ) ; } try { Service Schema Manager ssm = new Service Schema Manager ( service Name , token ) ; Service Schema ss = ssm . get Schema ( type . get Name ( ) ) ; if ( ss != null ) { Set cos Priority = ( attributes != null ) ? ( Set ) attributes . remove ( COS PRIORITY ) : null ; attributes = ss . validate And Inherit Defaults ( attributes , org Name , BOOL ) ; if ( cos Priority != null ) { attributes . put ( COS PRIORITY , cos Priority ) ; } attributes = AM Common Utils . remove Empty Values ( attributes ) ; stype = ss . get Service Type ( ) ; } else { ss = ssm . get Schema ( Schema Type . DYNAMIC ) ; if ( ss == null ) { Object args [ ] = { service Name } ; throw new Id Repo Exception ( Id Repo Bundle . BUNDLE NAME , Id Repo Error Code . UNABLE GET SERVICE SCHEMA , args ) ; } if ( attributes == null ) { try { attributes = get Service Config ( token , service Name , Schema Type . DYNAMIC ) ; } catch ( SMS Exception smsex ) { Object args [ ] = { service Name , type . get Name ( ) } ; throw new Id Repo Exception ( Id Repo Bundle . BUNDLE NAME , STRING , args ) ; } } else { attributes = ss . validate And Inherit Defaults ( attributes , org Name , BOOL ) ; } attributes = AM Common Utils . remove Empty Values ( attributes ) ; stype = Schema Type . DYNAMIC ; } attributes = AM Crypt . encrypt Passwords ( attributes , ss ) ; } catch ( SMS Exception smse ) { Object [ ] args = { service Name } ; throw new Id Repo Exception ( Id Repo Bundle . BUNDLE NAME , Id Repo Error Code . SERVICE NOT ASSIGNED , args ) ; } attributes . put ( STRING , O Cs ) ; id Services . assign Service ( token , type , name , service Name , stype , attributes , org Name , univ DN ) ; }
@ Override protected void create Buttons For Button Bar ( final Composite parent ) { for ( final Iterator it = button Descriptions . iterator ( ) ; it . has Next ( ) ; ) { final Button Description button Description = ( Button Description ) it . next ( ) ; create Button ( parent , button Description . button Id , button Description . button Label , button Description . is Default ) ; } if ( include Default Buttons ) { super . create Buttons For Button Bar ( parent ) ; } hook After Buttons Created ( ) ; }
private boolean check File Modifications ( ) throws Exception { long dest File Time = dest File . last Modified ( ) ; if ( source File . last Modified ( ) > dest File Time ) { logger . debug ( STRING ) ; return BOOL ; } Properties metadata = restore File Modifications ( meta Data File ) ; if ( metadata == null ) { return BOOL ; } SAX Parser Factory parser Factory = SAX Parser Factory . new Instance ( ) ; SAX Parser parser = parser Factory . new SAX Parser ( ) ; Time Checker Handler handler = new Time Checker Handler ( base Dir , metadata ) ; parser . parse ( source File , handler ) ; return handler . is Modified ( ) ; }
public static Number mul ( Number a , Number b ) { if ( is Floating Point ( a ) || is Floating Point ( b ) ) { return a . double Value ( ) * b . double Value ( ) ; } else { return a . long Value ( ) * b . long Value ( ) ; } }
private final int find Widest Axis ( ) { int widest = NUM ; double width = ( max Limit [ NUM ] - min Limit [ NUM ] ) * get Axis Weight Hint ( NUM ) ; if ( Double . is Na N ( width ) ) { width = NUM ; } for ( int i = NUM ; i < dimensions ; i ++ ) { double nwidth = ( max Limit [ i ] - min Limit [ i ] ) * get Axis Weight Hint ( i ) ; if ( Double . is Na N ( nwidth ) ) { nwidth = NUM ; } if ( nwidth > width ) { widest = i ; width = nwidth ; } } return widest ; }
public void add Sort Key ( int column , Comparator < String > comparator ) { sort Keys . add ( column ) ; sort Comparators . add ( comparator ) ; }
public static String tag Swap ( String content , Map < String , String > tag Swap Map ) { for ( Map . Entry < String , String > entry : tag Swap Map . entry Set ( ) ) { content = content . replace ( entry . get Key ( ) , entry . get Value ( ) ) ; } return content ; }
public static Run Stats delegate Get Bucket For Integers ( int buckets ) throws Exception { Long start Time = System . current Time Millis ( ) ; Primary Index Bucket Generator Impl ibg = new Primary Index Bucket Generator Impl ( Field Data Type . INTEGER , buckets ) ; Primary Index Bucket Locator Impl locator = new Primary Index Bucket Locator Impl ( null , null , null , ibg . generate Buckets ( ) , null , null , null , null , null ) ; logger . debug ( STRING ) ; Hash Map < Long , List < Object > > hm = new Hash Map < > ( ) ; Summary Statistics stats = new Summary Statistics ( ) ; for ( int input Int = - NUM ; input Int < NUM ; input Int ++ ) { Long bucket Id = locator . get Bucket ( input Int , Field Data Type . INTEGER ) ; calculate ( hm , stats , bucket Id , input Int ) ; } Long run Time = System . current Time Millis ( ) - start Time ; Run Stats run Stats = new Run Stats ( STRING , Field Data Type . INTEGER , run Time , stats , hm ) ; logger . debug ( run Stats . to String ( ) ) ; return run Stats ; }
public static long count Substr ( final String value , final String sub Str , final boolean case Sensitive , boolean allow Overlapping ) { validate ( value , NULL STRING PREDICATE , NULL STRING MSG SUPPLIER ) ; return count Substr ( case Sensitive ? value : value . to Lower Case ( ) , case Sensitive ? sub Str : sub Str . to Lower Case ( ) , allow Overlapping , NUM ) ; }
private void drop Index ( String index Name ) throws Oracle Exception { Prepared Statement stmt = null ; if ( index Name == null ) throw SODA Utils . make Exception ( SODA Message . EX ARG CANNOT BE NULL , STRING ) ; index Name = Collection Descriptor . string To Identifier ( index Name ) ; String sqltext = drop Index DDL ( index Name ) ; try { metrics . start Timing ( ) ; stmt = conn . prepare Statement ( sqltext ) ; stmt . execute ( ) ; if ( Oracle Log . is Logging Enabled ( ) ) log . info ( STRING + index Name ) ; stmt . close ( ) ; stmt = null ; metrics . record DDL ( ) ; } catch ( SQL Exception e ) { int errcode = e . get Error Code ( ) ; if ( ( errcode == ORA SQL OBJECT NOT EXISTS ) || ( errcode == ORA SQL INDEX NOT EXISTS ) ) { if ( Oracle Log . is Logging Enabled ( ) ) log . warning ( e . to String ( ) ) ; } else { if ( Oracle Log . is Logging Enabled ( ) ) log . warning ( e . to String ( ) ) ; throw SODA Utils . make Exception With SQL Text ( e , sqltext ) ; } } finally { for ( String message : SODA Utils . close Cursor ( stmt , null ) ) { if ( Oracle Log . is Logging Enabled ( ) ) log . severe ( message ) ; } } }
void unlaunch ( ) { if ( server != null ) { server . die ( ) ; server = null ; } frame . set Visible ( BOOL ) ; client = null ; System . gc ( ) ; System . run Finalization ( ) ; }
private boolean is Outside Doc Elem ( ) { return ( null == m doc Frag ) && m elem Stack . size ( ) == NUM && ( null == m current Node || m current Node . get Node Type ( ) == Node . DOCUMENT NODE ) ; }
public int post Files ( File [ ] files , int start Index In Args , Output Stream out , String type ) { reset ( ) ; int files Posted = NUM ; for ( File src File : files ) { if ( src File . is Directory ( ) && src File . can Read ( ) ) { files Posted += post Directory ( src File , out , type ) ; } else if ( src File . is File ( ) && src File . can Read ( ) ) { files Posted += post Files ( new File [ ] { src File } , out , type ) ; } else { File parent = src File . get Parent File ( ) ; if ( parent == null ) parent = new File ( STRING ) ; String file Glob = src File . get Name ( ) ; Glob File Filter ff = new Glob File Filter ( file Glob , BOOL ) ; File [ ] file List = parent . list Files ( ff ) ; if ( file List == null || file List . length == NUM ) { warn ( STRING + src File ) ; continue ; } files Posted += post Files ( file List , out , type ) ; } } return files Posted ; }
private static String unicode 2 html ( final String text , final boolean amp , final boolean html ) { if ( text == null ) return null ; final String Builder sb = new String Builder ( text . length ( ) * NUM / NUM ) ; int textpos = NUM ; String r ; char c ; while ( textpos < text . length ( ) ) { c = text . char At ( textpos ) ; if ( amp && c == AMP UNICODE ) { sb . append ( AMP HTML ) ; textpos ++ ; continue ; } if ( ( r = UNICODE 2 HTML 4 XML . get ( c ) ) != null ) { sb . append ( r ) ; textpos ++ ; continue ; } if ( html && ( r = UNICODE 2 HTML 4 HTML . get ( c ) ) != null ) { sb . append ( r ) ; textpos ++ ; continue ; } sb . append ( c ) ; textpos ++ ; } return sb . to String ( ) ; }
public String add Playlist ( String playlist Name ) { Content Values m Inserts = new Content Values ( ) ; m Inserts . put ( Media Store . Audio . Playlists . NAME , playlist Name ) ; m Inserts . put ( Media Store . Audio . Playlists . DATE ADDED , System . current Time Millis ( ) ) ; m Inserts . put ( Media Store . Audio . Playlists . DATE MODIFIED , System . current Time Millis ( ) ) ; Uri uri = m Content Resolver . insert ( Media Store . Audio . Playlists . EXTERNAL CONTENT URI , m Inserts ) ; if ( uri == null ) { return null ; } else { String ref = PREFIX PLAYLIST + get Playlist Unique Name ( Long . to String ( Content Uris . parse Id ( uri ) ) ) ; Playlist pl = new Playlist ( ref ) ; pl . set Name ( playlist Name ) ; pl . set Is Loaded ( BOOL ) ; m Playlists . put ( ref , pl ) ; m Callback . playlist Updated ( pl ) ; return ref ; } }
public static JSON Array read JSON Array ( final JSON Object json Object , final String key , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Object . get JSON Array ( key ) ; } if ( not Null && json Object . is Null ( key ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT OBJECT , key ) ) ; } JSON Array value = null ; if ( ! json Object . is Null ( key ) ) { value = json Object . get JSON Array ( key ) ; } return value ; }
default int copy To ( @ Not Null byte [ ] bytes ) throws Buffer Underflow Exception { int len = ( int ) Math . min ( bytes . length , read Remaining ( ) ) ; for ( int i = NUM ; i < len ; i ++ ) bytes [ i ] = read Byte ( start ( ) + i ) ; return len ; }
private static float [ ] random Points ( Random random , int waves Count , float width , float shift Coef ) { float shift ; float [ ] points = new float [ waves Count + NUM ] ; for ( int i = NUM ; i < points . length ; i ++ ) { if ( i == NUM ) { points [ i ] = - NUM ; } else if ( i == points . length - NUM ) { points [ i ] = NUM ; } else { shift = random . next Float ( ) * shift Coef * width ; shift *= random . next Boolean ( ) ? NUM : - NUM ; points [ i ] = - NUM + i * width + shift ; } } return points ; }
private void add Characters ( final Map < String , RP Object > characters ) { for ( Entry < String , RP Object > character : characters . entry Set ( ) ) { J Button button = create Character Button ( character . get Key ( ) , character . get Value ( ) ) ; character Panel . add ( button ) ; } }
public void run Test ( ) throws Throwable { Document doc ; Node List gender List ; Node gender Node ; Character Data ent Text ; Entity Reference ent Reference ; doc = ( Document ) load ( STRING , BOOL ) ; gender List = doc . get Elements By Tag Name ( STRING ) ; gender Node = gender List . item ( NUM ) ; ent Reference = doc . create Entity Reference ( STRING ) ; assert Not Null ( STRING , ent Reference ) ; ent Text = ( Character Data ) ent Reference . get First Child ( ) ; assert Not Null ( STRING , ent Text ) ; { boolean success = BOOL ; try { ent Text . insert Data ( NUM , STRING ) ; } catch ( DOM Exception ex ) { success = ( ex . code == DOM Exception . NO MODIFICATION ALLOWED ERR ) ; } assert True ( STRING , success ) ; } }
@ Override public void unbind View ( VH holder ) { }
public static boolean is Present ( Rule rule ) { if ( rule == null ) { return BOOL ; } return ( ! is Not Set ( rule . get Min Scale Denominator ( ) ) || ! is Not Set ( rule . get Max Scale Denominator ( ) ) ) ; }
public long startcode ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
public static void consume Process Output ( Process self ) { consume Process Output ( self , ( Output Stream ) null , ( Output Stream ) null ) ; }
public static void register Default Resolvers ( ) { List < Key Resolver > key Resolver List = new Array List < Key Resolver > ( ) ; key Resolver List . add ( new Key Resolver ( new RSA Key Value Resolver ( ) ) ) ; key Resolver List . add ( new Key Resolver ( new DSA Key Value Resolver ( ) ) ) ; key Resolver List . add ( new Key Resolver ( new X509 Certificate Resolver ( ) ) ) ; key Resolver List . add ( new Key Resolver ( new X509 SKI Resolver ( ) ) ) ; key Resolver List . add ( new Key Resolver ( new Retrieval Method Resolver ( ) ) ) ; key Resolver List . add ( new Key Resolver ( new X509 Subject Name Resolver ( ) ) ) ; key Resolver List . add ( new Key Resolver ( new X509 Issuer Serial Resolver ( ) ) ) ; key Resolver List . add ( new Key Resolver ( new DER Encoded Key Value Resolver ( ) ) ) ; key Resolver List . add ( new Key Resolver ( new Key Info Reference Resolver ( ) ) ) ; key Resolver List . add ( new Key Resolver ( new X509 Digest Resolver ( ) ) ) ; resolver Vector . add All ( key Resolver List ) ; }
public static final void delete ( String file Name ) { File file = new File ( file Name ) ; if ( ! file . delete ( ) ) { log . error ( STRING , file ) ; } File metadata File = new File ( file Name + METADATA SUFFIX ) ; if ( ! metadata File . delete ( ) ) { log . error ( STRING , metadata File ) ; } File directory = file . get Parent File ( ) ; if ( directory . is Directory ( ) ) { directory . delete ( ) ; } }
protected final void refresh Loading Views Size ( ) { final int maximum Pull Scroll = ( int ) ( get Maximum Pull Scroll ( ) * NUM ) ; int p Left = get Padding Left ( ) ; int p Top = get Padding Top ( ) ; int p Right = get Padding Right ( ) ; int p Bottom = get Padding Bottom ( ) ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Width ( maximum Pull Scroll ) ; p Left = - maximum Pull Scroll ; } else { p Left = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Width ( maximum Pull Scroll ) ; p Right = - maximum Pull Scroll ; } else { p Right = NUM ; } break ; case VERTICAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Height ( maximum Pull Scroll ) ; p Top = - maximum Pull Scroll ; } else { p Top = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Height ( maximum Pull Scroll ) ; p Bottom = - maximum Pull Scroll ; } else { p Bottom = NUM ; } break ; } if ( DEBUG ) { Log . d ( LOG TAG , String . format ( STRING , p Left , p Top , p Right , p Bottom ) ) ; } set Padding ( p Left , p Top , p Right , p Bottom ) ; }
public static boolean is Extension ( String filename , String extension ) { if ( filename == null ) { return BOOL ; } if ( extension == null || extension . length ( ) == NUM ) { return index Of Extension ( filename ) == - NUM ; } String file Ext = get Extension ( filename ) ; return file Ext . equals ( extension ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL ; } if ( ! ( obj instanceof Time Period Values Collection ) ) { return BOOL ; } Time Period Values Collection that = ( Time Period Values Collection ) obj ; if ( this . domain Is Points In Time != that . domain Is Points In Time ) { return BOOL ; } if ( this . x Position != that . x Position ) { return BOOL ; } if ( ! Object Utilities . equal ( this . data , that . data ) ) { return BOOL ; } return BOOL ; }
public void print ( J Text Pane pane ) { set Document ( pane ) ; print Dialog ( ) ; }
private boolean ensure Scroll Wheel Adjusted ( ) { int delta Y = m Initial Scroll Offset - m Current Scroll Offset ; if ( delta Y != NUM ) { m Previous Scroller Y = NUM ; if ( Math . abs ( delta Y ) > m Selector Element Height / NUM ) { delta Y += ( delta Y > NUM ) ? - m Selector Element Height : m Selector Element Height ; } m Adjust Scroller . start Scroll ( NUM , NUM , NUM , delta Y , SELECTOR ADJUSTMENT DURATION MILLIS ) ; invalidate ( ) ; return BOOL ; } return BOOL ; }
private String sort Xml ( final String original Xml ) { String error Msg = STRING ; xml Processing Instruction Parser . scan For Ignored Sections ( original Xml ) ; String xml = xml Processing Instruction Parser . replace Ignored Sections ( ) ; insert Xml In Xml Processor ( xml , error Msg ) ; xml Processor . sort Xml ( ) ; try ( Byte Array Output Stream sorted Xml Output Stream = xml Processor . get Sorted Xml ( ) ) { String sorted Xml = sorted Xml Output Stream . to String ( encoding ) ; if ( xml Processing Instruction Parser . exists Ignored Sections ( ) ) { sorted Xml = xml Processing Instruction Parser . revert Ignored Sections ( sorted Xml ) ; } return sorted Xml ; } catch ( IO Exception e ) { throw new Failure Exception ( error Msg + xml , e ) ; } }
void wait For Dictionary Loading ( ) { while ( m Updating Dictionary ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { } } }
private void publish Data ( String path , byte [ ] data ) { try { if ( data != null && data . length > NUM ) { Byte Array Input Stream bii = new Byte Array Input Stream ( data ) ; Object Input Stream ois = new Object Input Stream ( bii ) ; Object data Obj = ois . read Object ( ) ; Zoo Keeper Data Wrapper wrapper = ( Zoo Keeper Data Wrapper ) ( data Obj ) ; Jetstream Message tm = ( Jetstream Message ) wrapper . get Orginal Data ( ) ; String tracker Key = create Key ( path , wrapper ) ; m change Tracker . put ( tracker Key , wrapper . get Timestamp ( ) ) ; try { LOGGER . warn ( STRING + path + STRING + tracker Key + STRING + wrapper . get Timestamp ( ) ) ; m transport Listener . post Message ( tm , m queue Stats ) ; } catch ( Throwable mse ) { String Buffer buf = new String Buffer ( ) ; buf . append ( STRING ) ; buf . append ( mse . get Localized Message ( ) ) ; LOGGER . error ( STRING + path + buf . to String ( ) , mse ) ; } m total Msgs Rcvd . increment ( ) ; m msgs Rcvd Per Sec . increment ( ) ; } } catch ( Class Not Found Exception e ) { LOGGER . error ( STRING + path , e ) ; } catch ( IO Exception e ) { LOGGER . error ( STRING + path , e ) ; } }
static public long next Addr ( Random r , Worm Address Manager am ) { if ( r . next Int ( NUM ) < NUM ) return NUM ; return next Non Zero Addr ( r , am ) ; }
public void undoable Edit Happened ( mx Undoable Edit undoable Edit ) { if ( enabled ) { if ( undoable Edit . get Transparent ( ) ) { } else if ( ! undoable Edit . get Undoable ( ) ) { not Undoable Edit Happened ( ) ; } else if ( collection ) { collected . add ( undoable Edit ) ; fire Event ( new mx Event Object ( mx Event . ADD , STRING , undoable Edit ) ) ; } else { collected . add ( undoable Edit ) ; add Event List ( ) ; fire Event ( new mx Event Object ( mx Event . ADD , STRING , undoable Edit ) ) ; } } }
public File ( File dir , String name ) { this ( dir == null ? null : dir . get Path ( ) , name ) ; }
public void remove Drag Listener ( Drag Listener l ) { m Listeners . remove ( l ) ; }
private High Tide Values find High Tide ( JSON Object response Object ) throws JSON Exception , Parse Exception { JSON Array predictions = ( JSON Array ) response Object . get ( STRING ) ; JSON Object last Prediction = null , first High Tide = null , second High Tide = null , low Tide = null ; boolean first Tide Done = BOOL ; for ( int i = NUM ; i < predictions . length ( ) ; i ++ ) { JSON Object prediction = ( JSON Object ) predictions . get ( i ) ; if ( last Prediction == null ) { last Prediction = prediction ; continue ; } if ( is Tide Increasing ( last Prediction , prediction ) ) { if ( ! first Tide Done ) { first High Tide = prediction ; } else { second High Tide = prediction ; } } else { if ( ! first Tide Done && first High Tide != null ) { first Tide Done = BOOL ; } else if ( second High Tide != null ) { break ; } if ( first Tide Done ) { low Tide = prediction ; } } last Prediction = prediction ; } Date Format date Format = new Simple Date Format ( STRING ) ; return new High Tide Values ( Alexa Date Util . get Formatted Time ( date Format . parse ( first High Tide . get String ( STRING ) ) ) , get Formatted Height ( first High Tide . get String ( STRING ) ) , Alexa Date Util . get Formatted Time ( date Format . parse ( low Tide . get String ( STRING ) ) ) , get Formatted Height ( low Tide . get String ( STRING ) ) , Alexa Date Util . get Formatted Time ( date Format . parse ( second High Tide . get String ( STRING ) ) ) , get Formatted Height ( second High Tide . get String ( STRING ) ) ) ; }
public static boolean is Ip Address ( String ip Address ) { Matcher m1 = valid IPV 4 Pattern . matcher ( ip Address ) ; if ( m1 . matches ( ) ) { return BOOL ; } Matcher m2 = valid IPV 6 Pattern . matcher ( ip Address ) ; return m2 . matches ( ) ; }
@ Override public synchronized void remove Training Set Listener ( Training Set Listener tsl ) { m training Listeners . remove Element ( tsl ) ; }
public void rename Attribute Value ( Attribute att , String val , String name ) { int v = att . index Of Value ( val ) ; if ( v == - NUM ) { throw new Illegal Argument Exception ( val + STRING ) ; } rename Attribute Value ( att . index ( ) , v , name ) ; }
private static void s uacmean ( Sparse Block a , double [ ] c , int m , int n , Kahan Object kbuff , Mean kmean , int rl , int ru ) { Arrays . fill ( c , n , n * NUM , ru - rl ) ; if ( a . is Contiguous ( ) ) { count Dis Agg ( a . values ( rl ) , c , a . indexes ( rl ) , a . pos ( rl ) , n , ( int ) a . size ( rl , ru ) ) ; } else { for ( int i = rl ; i < ru ; i ++ ) { if ( ! a . is Empty ( i ) ) count Dis Agg ( a . values ( i ) , c , a . indexes ( i ) , a . pos ( i ) , n , a . size ( i ) ) ; } } if ( a . is Contiguous ( ) ) { mean Agg ( a . values ( rl ) , c , a . indexes ( rl ) , a . pos ( rl ) , ( int ) a . size ( rl , ru ) , n , kbuff , kmean ) ; } else { for ( int i = rl ; i < ru ; i ++ ) { if ( ! a . is Empty ( i ) ) mean Agg ( a . values ( i ) , c , a . indexes ( i ) , a . pos ( i ) , a . size ( i ) , n , kbuff , kmean ) ; } } }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
public boolean is Pdf Attachment ( ) { if ( get PO ( ) == null ) return BOOL ; return m po . is Pdf Attachment ( ) ; }
private int name To Index ( String parameter Name ) throws SQL Exception { parameter Metadata . read Metadata From Db If Required ( ) ; for ( int i = NUM ; i <= parameter Metadata . get Parameter Count ( ) ; i ++ ) { String name = parameter Metadata . get Name ( i ) ; if ( name != null && name . equals Ignore Case ( parameter Name ) ) { return i ; } } throw new SQL Exception ( STRING + parameter Name ) ; }
public void sort ( Comparator < ? super Sub Range > comparator ) { Collections . sort ( data , comparator ) ; }
private void add ( Tree Map < String , Object > map , String key , Object value ) { Vector < Object > v = get List ( map , key ) ; if ( v == null ) { v = new Vector < > ( ) ; synchronized ( map ) { map . put ( key , v ) ; } } if ( ! v . contains ( value ) ) { v . add ( value ) ; } }
public void test single Resource Locking serialized waits For high Concurrency task Timeout ( ) throws Exception { final Properties properties = new Properties ( ) ; final int nthreads = NUM ; final int ntasks = NUM ; properties . set Property ( Test Options . CORE POOL SIZE , STRING + nthreads ) ; properties . set Property ( Test Options . NTASKS , STRING + ntasks ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . TASK TIMEOUT , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; final Result result = do Comparison Test ( properties ) ; assert Equals ( STRING , NUM , Integer . parse Int ( result . get ( STRING ) ) ) ; assert Equals ( STRING , NUM , Integer . parse Int ( result . get ( STRING ) ) ) ; final int ncancel = Integer . parse Int ( result . get ( STRING ) ) ; assert True ( STRING , ncancel > NUM ) ; }
private void blackman Harris 3 s ( int size ) { int start = ( window Function . length - size ) / NUM ; int stop = ( window Function . length + size ) / NUM ; double scale = NUM / ( double ) size / NUM ; for ( int i = NUM ; start < stop ; start ++ , i ++ ) window Function [ i ] = scale * ( NUM - NUM * Math . cos ( two PI * i / size ) + NUM * Math . cos ( NUM * two PI * i / size ) ) ; }
private Week Fields ( Day Of Week first Day Of Week , int minimal Days In First Week ) { Objects . require Non Null ( first Day Of Week , STRING ) ; if ( minimal Days In First Week < NUM || minimal Days In First Week > NUM ) { throw new Illegal Argument Exception ( STRING ) ; } this . first Day Of Week = first Day Of Week ; this . minimal Days = minimal Days In First Week ; }
private Result Points And Transitions transitions Between ( Result Point from , Result Point to ) { int from X = ( int ) from . get X ( ) ; int from Y = ( int ) from . get Y ( ) ; int to X = ( int ) to . get X ( ) ; int to Y = ( int ) to . get Y ( ) ; boolean steep = Math . abs ( to Y - from Y ) > Math . abs ( to X - from X ) ; if ( steep ) { int temp = from X ; from X = from Y ; from Y = temp ; temp = to X ; to X = to Y ; to Y = temp ; } int dx = Math . abs ( to X - from X ) ; int dy = Math . abs ( to Y - from Y ) ; int error = - dx > > NUM ; int ystep = from Y < to Y ? NUM : - NUM ; int xstep = from X < to X ? NUM : - NUM ; int transitions = NUM ; boolean in Black = image . get ( steep ? from Y : from X , steep ? from X : from Y ) ; for ( int x = from X , y = from Y ; x != to X ; x += xstep ) { boolean is Black = image . get ( steep ? y : x , steep ? x : y ) ; if ( is Black != in Black ) { transitions ++ ; in Black = is Black ; } error += dy ; if ( error > NUM ) { if ( y == to Y ) { break ; } y += ystep ; error -= dx ; } } return new Result Points And Transitions ( from , to , transitions ) ; }
private void place Groups ( ) { start Row ( ) ; place Child ( m Close Button , Gravity . END ) ; place Group ( m Main Group ) ; int custom Group Width = NUM ; if ( m Custom Group != null ) { update Custom Group For Row ( ROW MAIN ) ; custom Group Width = get Width With Margins ( m Custom Group ) ; } int button Group Width = NUM ; if ( m Button Group != null ) { update Button Group For Row ( ROW MAIN ) ; button Group Width = get Width With Margins ( m Button Group ) ; } boolean custom Group On Main Row = custom Group Width <= available Width ( ) ; boolean button Group On Main Row = custom Group Width + button Group Width <= available Width ( ) ; if ( m Custom Group != null ) { if ( custom Group On Main Row ) { m Custom Group . gravity = ( m Button Group != null && button Group On Main Row ) ? Gravity . START : Gravity . END ; } else { start Row ( ) ; update Custom Group For Row ( ROW OTHER ) ; } place Group ( m Custom Group ) ; } if ( m Button Group != null ) { if ( ! button Group On Main Row ) { start Row ( ) ; update Button Group For Row ( ROW OTHER ) ; if ( m Custom Group == null && m Message Text View != null ) { Layout Params lp = ( Layout Params ) m Message Text View . get Layout Params ( ) ; int message Bottom = lp . top + m Message Text View . get Measured Height ( ) ; m Top = Math . max ( m Top , message Bottom + NUM * m Margin ) ; } } place Group ( m Button Group ) ; if ( m Custom Button != null && ! button Group On Main Row ) { Layout Params primary Button LP = ( Layout Params ) m Primary Button . get Layout Params ( ) ; Layout Params custom Button LP = ( Layout Params ) m Custom Button . get Layout Params ( ) ; Layout Params message LP = ( Layout Params ) m Message View . get Layout Params ( ) ; if ( custom Button LP . start >= message LP . start ) { custom Button LP . start = message LP . start ; } else { custom Button LP . start = m Margin ; } if ( ! m Button Group . is Stacked ) { custom Button LP . top = primary Button LP . top + ( m Primary Button . get Measured Height ( ) - m Custom Button . get Measured Height ( ) ) / NUM ; } } } start Row ( ) ; if ( button Group On Main Row ) { int layout Height = m Bottom ; for ( int i = NUM ; i < get Child Count ( ) ; i ++ ) { View child = get Child At ( i ) ; int extra Space = layout Height - child . get Measured Height ( ) ; Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; lp . top = extra Space / NUM ; } } }
static Heap Doubles Sketch copy ( Doubles Sketch sketch ) { Heap Doubles Sketch qs Copy ; qs Copy = Heap Doubles Sketch . new Instance ( sketch . get K ( ) ) ; qs Copy . n = sketch . get N ( ) ; qs Copy . min Value = sketch . get Min Value ( ) ; qs Copy . max Value = sketch . get Max Value ( ) ; qs Copy . combined Buffer Item Capacity = sketch . get Combined Buffer Item Capacity ( ) ; qs Copy . base Buffer Count = sketch . get Base Buffer Count ( ) ; qs Copy . bit Pattern = sketch . get Bit Pattern ( ) ; double [ ] comb Buf = sketch . get Combined Buffer ( ) ; qs Copy . combined Buffer = Arrays . copy Of ( comb Buf , comb Buf . length ) ; return qs Copy ; }
public List < Verification OK > verify ( List < Verification OK > result ) throws IO Exception , General Security Exception { if ( result == null ) result = new Array List < > ( ) ; while ( pkcs 7 != null ) { result . add All ( verify Signature ( ) ) ; } return result ; }
public Schema Field ( String name , Field Type type ) { this ( name , type , type . properties , null ) ; }
private void create Day Slot ( Array List < M Assignment Slot > list , M Assignment Slot ma ) { Timestamp start = ma . get Start Time ( ) ; Gregorian Calendar cal Start = new Gregorian Calendar ( ) ; cal Start . set Time ( start ) ; cal Start . set ( Calendar . HOUR OF DAY , NUM ) ; cal Start . set ( Calendar . MINUTE , NUM ) ; cal Start . set ( Calendar . SECOND , NUM ) ; cal Start . set ( Calendar . MILLISECOND , NUM ) ; Timestamp end = ma . get End Time ( ) ; Gregorian Calendar cal End = new Gregorian Calendar ( ) ; cal End . set Time ( end ) ; cal End . set ( Calendar . HOUR OF DAY , NUM ) ; cal End . set ( Calendar . MINUTE , NUM ) ; cal End . set ( Calendar . SECOND , NUM ) ; cal End . set ( Calendar . MILLISECOND , NUM ) ; while ( cal Start . before ( cal End ) ) { Timestamp x Start = new Timestamp ( cal Start . get Time In Millis ( ) ) ; cal Start . add ( Calendar . DAY OF YEAR , NUM ) ; Timestamp x End = new Timestamp ( cal Start . get Time In Millis ( ) ) ; M Assignment Slot my Ma = new M Assignment Slot ( x Start , x End , ma . get Name ( ) , ma . get Description ( ) , ma . get Status ( ) ) ; list . add ( my Ma ) ; } }
public boolean is Attachment ( String file Name ) { return file Name . starts With ( ENTRY ATTACHMENT ) ; }
void subtract Flakes ( int quantity ) { for ( int i = NUM ; i < quantity ; ++ i ) { int index = num Flakes - i - NUM ; flakes . remove ( index ) ; } set Num Flakes ( num Flakes - quantity ) ; }
public Optimized ( int n , int s , int t , Iterator < Edge Info > edges ) { super ( n , s , t ) ; queue = new int [ n ] ; QUEUE SIZE = n ; capacity = new int [ n ] [ n ] ; flow = new int [ n ] [ n ] ; previous = new int [ n ] ; visited = new int [ n ] ; while ( edges . has Next ( ) ) { Edge Info ei = edges . next ( ) ; capacity [ ei . start ] [ ei . end ] = ei . capacity ; } }
public void put ( Buffer buffer ) { if ( buffer . get Length ( ) <= NUM ) { return ; } byte [ ] current Rtp Packet Data = ( ( byte [ ] ) buffer . get Data ( ) ) ; H264 Rtp Headers h264 Rtp Headers = new H264 Rtp Headers ( current Rtp Packet Data ) ; if ( h264 Rtp Headers . get FUI F ( ) ) { return ; } if ( reassembled Data == null ) { time Stamp = buffer . get Time Stamp ( ) ; format = buffer . get Format ( ) ; seq Number = buffer . get Sequence Number ( ) ; reassembled Data NAL Header = h264 Rtp Headers . get NAL Header ( ) ; reassembled Data = new byte [ Java Packetizer . H264 MAX RTP PKTS ] [ H264 FRAME PACKET SIZE ] ; reassembled Data Size = new int [ Java Packetizer . H264 MAX RTP PKTS ] ; reassembled Data Has Start = BOOL ; reassembled Data Has End = BOOL ; } int pos Seq = ( int ) ( buffer . get Sequence Number ( ) & VIDEO DECODER MAX PAYLOADS CHUNKS MASK ) ; int payload Start Position = h264 Rtp Headers . get Header Size ( ) ; int payload Length = buffer . get Length ( ) - h264 Rtp Headers . get Header Size ( ) ; if ( h264 Rtp Headers . get FUI TYPE ( ) == H264 Rtp Headers . AVC NALTYPE FUA ) { reassembled Data Has Start |= ( h264 Rtp Headers . get FUH S ( ) ) ; reassembled Data Has End |= ( h264 Rtp Headers . get FUH E ( ) ) ; reassembled Data Pos Seq Start = ( ( h264 Rtp Headers . get FUH S ( ) ) ? pos Seq : reassembled Data Pos Seq Start ) ; reassembled Data Pos Seq End = ( ( h264 Rtp Headers . get FUH E ( ) ) ? pos Seq : reassembled Data Pos Seq End ) ; } reassembled Data Size [ pos Seq ] = payload Length ; reassembled Data Full Size += payload Length ; System . arraycopy ( current Rtp Packet Data , payload Start Position , reassembled Data [ pos Seq ] , NUM , payload Length ) ; video Orientation = buffer . get Video Orientation ( ) ; }
public static Map < String , Object > bad Expire Even Processor ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Generic Value credit Card = ( Generic Value ) context . get ( STRING ) ; String expire Date = credit Card . get String ( STRING ) ; String last Number Str = expire Date . substring ( expire Date . length ( ) - NUM ) ; int last Number = Integer . parse Int ( last Number Str ) ; if ( last Number % NUM == NUM ) { return always Bad Expire Processor ( dctx , context ) ; } else { return always Approve Processor ( dctx , context ) ; } }
public Expression Type negate ( ) { if ( is Negated ( ) ) { return new Expression Type ( type String . replace ( SUFFIX NEGATED , STRING ) ) ; } else { return new Expression Type ( type String + SUFFIX NEGATED ) ; } }
protected void update Path Greyness ( Tree Path ancestor ) { boolean value = is Path Check Box ( ancestor ) ; Object ancestor Node = ancestor . get Last Path Component ( ) ; if ( ! is Path Check Box ( ancestor ) ) { add To Check Box Paths Set ( ancestor ) ; return ; } }
protected Array List < String > use Tokenizer ( String s ) throws Exception { String [ ] tokens ; Array List < String > result ; int i ; tokens = Tokenizer . tokenize ( m Tokenizer , new String [ ] { s } ) ; result = new Array List < String > ( ) ; for ( i = NUM ; i < tokens . length ; i ++ ) { result . add ( tokens [ i ] ) ; } return result ; }
public DOM Storable Input Output Format ( DOM Factory factory , String description , String file Extension , String mime Type ) { this . factory = factory ; this . description = description ; this . file Extension = file Extension ; this . mime Type = mime Type ; try { this . data Flavor = new Data Flavor ( mime Type ) ; } catch ( Class Not Found Exception ex ) { Internal Error error = new Internal Error ( STRING + mime Type ) ; error . init Cause ( ex ) ; throw error ; } }
default Type Parameter Declaration as Type Parameter ( ) { throw new Unsupported Operation Exception ( String . format ( STRING , this ) ) ; }
public void add Column ( String header ) { if ( get Model ( ) instanceof Default Table Model ) { Default Table Model model = ( Default Table Model ) get Model ( ) ; model . add Column ( Util . clean Amp ( header ) ) ; } else throw new Illegal Argument Exception ( STRING ) ; }
public void add Move Script ( String pathname ) { move Scripts . add ( pathname ) ; set Dirty And Fire Property Change ( STRING , pathname , null ) ; }
private void check And Add Resize Handler ( ) { Component parent = get Parent ( ) ; if ( parent != null && resizable && resize Handler == null ) { resize Handler = new Resize Handler ( ) ; parent . add Component Listener ( resize Handler ) ; } }
static public void use Xalan X Path Support ( ) throws Exception { Class . for Name ( STRING ) ; Class c = Class . for Name ( STRING ) ; synchronized ( STATIC LOCK ) { xpath Support Class = c ; } if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING ) ; } }
public int number Of Owning Shards ( ) { int count = NUM ; for ( Shard Routing shard Entry : this ) { if ( shard Entry . state ( ) != Shard Routing State . RELOCATING ) { count ++ ; } } return count ; }
public String convert Binary To Hex String ( byte [ ] bytes ) { String Builder builder = new String Builder ( bytes . length * NUM ) ; for ( byte b : bytes ) { int high Bits Int = ( b > > NUM ) & NUM ; int low Bits Int = b & NUM ; builder . append ( HEX CHARS [ high Bits Int ] ) ; builder . append ( HEX CHARS [ low Bits Int ] ) ; } return builder . to String ( ) ; }
protected static void write Header ( XML Writer writer ) { Xml Writer Util . write Comment Line Break ( writer ) ; Xml Writer Util . write Comment ( writer , STRING ) ; Date Format date Format = new Simple Date Format ( STRING ) ; Xml Writer Util . write Comment ( writer , STRING + date Format . format ( new Date ( System . current Time Millis ( ) ) ) ) ; Xml Writer Util . write Comment ( writer , STRING ) ; Xml Writer Util . write Comment ( writer , STRING ) ; Xml Writer Util . write Comment Line Break ( writer ) ; Xml Writer Util . write Line Break ( writer ) ; }
protected void close ( ) { try { if ( to != null ) to . close ( ) ; if ( from != null ) from . close ( ) ; } catch ( IO Exception e ) { } if ( process != null ) process . destroy ( ) ; process = null ; to = null ; from = null ; error Logger = null ; }
public void clear Parse Issues ( ) { parse Issues . clear ( ) ; }
public int validate ( Graphics Configuration gc ) { int return Code = Volatile Image . IMAGE OK ; boolean lost Surface Tmp = lost Surface ; lost Surface = BOOL ; if ( is Acceleration Enabled ( ) ) { if ( ! is Config Valid ( gc ) ) { return Code = Volatile Image . IMAGE INCOMPATIBLE ; } else if ( sd Accel == null ) { sd Accel = init Accelerated Surface ( ) ; if ( sd Accel != null ) { sd Current = sd Accel ; sd Backup = null ; return Code = Volatile Image . IMAGE RESTORED ; } else { sd Current = get Backup Surface ( ) ; } } else if ( sd Accel . is Surface Lost ( ) ) { try { restore Accelerated Surface ( ) ; sd Current = sd Accel ; sd Accel . set Surface Lost ( BOOL ) ; sd Backup = null ; return Code = Volatile Image . IMAGE RESTORED ; } catch ( sun . java 2 d . Invalid Pipe Exception e ) { sd Current = get Backup Surface ( ) ; } } else if ( lost Surface Tmp ) { return Code = Volatile Image . IMAGE RESTORED ; } } else if ( sd Accel != null ) { sd Current = get Backup Surface ( ) ; sd Accel = null ; return Code = Volatile Image . IMAGE RESTORED ; } if ( ( return Code != Volatile Image . IMAGE INCOMPATIBLE ) && ( sd Current != sd Previous ) ) { sd Previous = sd Current ; return Code = Volatile Image . IMAGE RESTORED ; } if ( return Code == Volatile Image . IMAGE RESTORED ) { init Contents ( ) ; } return return Code ; }
private static String unsigned To String ( final int value ) { if ( value >= NUM ) { return Integer . to String ( value ) ; } else { return Long . to String ( ( ( long ) value ) & NUM ) ; } }
public Connection Manager ( Connection Manager Configuration configuration ) throws Exception { configuration = configuration ; if ( configuration == null ) { throw new Connection Manager Exception ( STRING ) ; } }
@ Suppress Warnings ( STRING ) public Pids ( ) { Arrays . sort ( PI Ds , pid Comparator ) ; }
public void handle Header Column Released ( Point p ) { TABLE . set Pressed Column Index ( - NUM ) ; J Table Header th = TABLE . get Table Header ( ) ; int col = th . column At Point ( p ) ; if ( col != - NUM ) th . repaint ( th . get Header Rect ( col ) ) ; }
public void create Devices ( @ Not Null List < Device > devices ) { if ( ! init If Necessary ( ) ) { return ; } for ( Device device : devices ) { String device Id Base = device . get Id ( ) ; String device Name Base = device . get Display Name ( ) ; int i = NUM ; while ( is User Device ( device ) ) { String id = String . format ( Locale . get Default ( ) , STRING , device Id Base , i ) ; String name = String . format ( Locale . get Default ( ) , STRING , device Name Base , i ) ; device = clone Device With New Id And Name ( device , id , name ) ; } our Device Manager . add User Device ( device ) ; } our Device Manager . save User Devices ( ) ; }
public Writable Raster create Compatible Writable Raster ( int w , int h ) { if ( w <= NUM || h <= NUM ) { throw new Raster Format Exception ( STRING + ( ( w <= NUM ) ? STRING : STRING ) ) ; } Sample Model sm = sample Model . create Compatible Sample Model ( w , h ) ; return new Short Banded Raster ( sm , new Point ( NUM , NUM ) ) ; }
public void write ( Print Writer writer ) { for ( int i = NUM ; i < count ; i ++ ) { writer . println ( keys [ i ] + STRING + values [ i ] ) ; } writer . flush ( ) ; }
@ Worker Thread public synchronized int stop Record ( ) { if ( m Recorder == null ) { m State = STATE IDLE ; return - NUM ; } int length = - NUM ; switch ( m State ) { case STATE RECORDING : try { Thread . sleep ( STOP AUDIO RECORD DELAY MILLIS ) ; m Recorder . stop ( ) ; length = ( int ) ( ( System . current Time Millis ( ) - m Sample Start ) / NUM ) ; } catch ( Runtime Exception e ) { Log . w ( TAG , STRING + e . get Message ( ) ) ; } catch ( Interrupted Exception e ) { Log . w ( TAG , STRING + e . get Message ( ) ) ; } case STATE PREPARED : case STATE IDLE : default : try { m Recorder . reset ( ) ; } catch ( Runtime Exception e ) { Log . w ( TAG , STRING + e . get Message ( ) ) ; } m Recorder . release ( ) ; m Recorder = null ; m State = STATE IDLE ; break ; } return length ; }
public XML Parser ( final Class class To Be Bound , final String [ ] schemas ) throws XML Exception { try { JAXB Context jc = JAXB Context . new Instance ( class To Be Bound ) ; marshaller = jc . create Marshaller ( ) ; marshaller . set Schema ( XML Schema Utils . create Schema ( schemas ) ) ; unmarshaller = jc . create Unmarshaller ( ) ; unmarshaller . set Schema ( XML Schema Utils . create Schema ( schemas ) ) ; } catch ( JAXB Exception e ) { throw new XML Exception ( STRING + class To Be Bound , e ) ; } }
private void abort ( Throwable t ) { throwable = t ; }
public static User Impl signup ( Map < String , String [ ] > parameters , String ip , List < Signup Error > errors ) { log . entering ( STRING , STRING ) ; String email = get First ( parameters , STRING ) ; String display Name = get First ( parameters , STRING ) ; String photo Url = get First ( parameters , STRING ) ; String password = get First ( parameters , STRING ) ; String confirm = get First ( parameters , STRING ) ; if ( Strings . is Null Or Empty ( email ) || ! Email Validator . is Valid ( email ) ) { errors . add ( Signup Error . INVALID EMAIL ) ; } if ( Strings . is Null Or Empty ( display Name ) ) { errors . add ( Signup Error . EMPTY DISPLAY NAME ) ; } if ( Strings . is Null Or Empty ( password ) ) { errors . add ( Signup Error . INVALID PASSWORD ) ; } else if ( ! password . equals ( confirm ) ) { errors . add ( Signup Error . CONFIRM MISMATCH ) ; } else if ( password . length ( ) < NUM ) { errors . add ( Signup Error . INVALID PASSWORD ) ; } Persistence Manager pm = pmf . get Persistence Manager ( ) ; try { User Record record = find User By Email ( pm , email ) ; if ( record != null ) { errors . add ( Signup Error . EMAIL REGISTERED ) ; } else if ( errors . is Empty ( ) ) { log . fine ( STRING + email ) ; record = new User Record ( ) ; record . set Email ( email ) ; record . set Display Name ( display Name ) ; record . set Photo Url ( photo Url ) ; record . set Password ( password ) ; record . set Tos Accepted ( BOOL ) ; record . set Last Big Change Time ( System . current Time Millis ( ) ) ; pm . make Persistent ( record ) ; User Impl user = create User By Record ( record ) ; return user ; } } finally { pm . close ( ) ; } log . exiting ( STRING , STRING ) ; return null ; }
@ Override public final String read Null Terminated Ascii String ( ) { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; byte b ; while ( BOOL ) { b = read Byte ( ) ; if ( b == NUM ) { break ; } baos . write ( b ) ; } byte [ ] buf = baos . to Byte Array ( ) ; char [ ] chr Buf = new char [ buf . length ] ; for ( int x = NUM ; x < buf . length ; x ++ ) { chr Buf [ x ] = ( char ) buf [ x ] ; } return String . value Of ( chr Buf ) ; }
private void threshold Blur ( Kernel kernel , int [ ] in Pixels , int [ ] out Pixels , int width , int height , boolean alpha ) { float [ ] matrix = kernel . get Kernel Data ( null ) ; int cols = kernel . get Width ( ) ; int cols 2 = cols / NUM ; for ( int y = NUM ; y < height ; y ++ ) { int ioffset = y * width ; int out Index = y ; for ( int x = NUM ; x < width ; x ++ ) { float r = NUM , g = NUM , b = NUM , a = NUM ; int moffset = cols 2 ; int rgb 1 = in Pixels [ ioffset + x ] ; int a1 = ( rgb 1 > > NUM ) & NUM ; int r1 = ( rgb 1 > > NUM ) & NUM ; int g1 = ( rgb 1 > > NUM ) & NUM ; int b1 = rgb 1 & NUM ; float af = NUM , rf = NUM , gf = NUM , bf = NUM ; for ( int col = - cols 2 ; col <= cols 2 ; col ++ ) { float f = matrix [ moffset + col ] ; if ( f != NUM ) { int ix = x + col ; if ( ! ( NUM <= ix && ix < width ) ) ix = x ; int rgb 2 = in Pixels [ ioffset + ix ] ; int a2 = ( rgb 2 > > NUM ) & NUM ; int r2 = ( rgb 2 > > NUM ) & NUM ; int g2 = ( rgb 2 > > NUM ) & NUM ; int b2 = rgb 2 & NUM ; int d ; d = a1 - a2 ; if ( d >= - threshold && d <= threshold ) { a += f * a2 ; af += f ; } d = r1 - r2 ; if ( d >= - threshold && d <= threshold ) { r += f * r2 ; rf += f ; } d = g1 - g2 ; if ( d >= - threshold && d <= threshold ) { g += f * g2 ; gf += f ; } d = b1 - b2 ; if ( d >= - threshold && d <= threshold ) { b += f * b2 ; bf += f ; } } } a = af == NUM ? a1 : a / af ; r = rf == NUM ? r1 : r / rf ; g = gf == NUM ? g1 : g / gf ; b = bf == NUM ? b1 : b / bf ; int ia = alpha ? Pixel Utils . clamp ( ( int ) ( a + NUM ) ) : NUM ; int ir = Pixel Utils . clamp ( ( int ) ( r + NUM ) ) ; int ig = Pixel Utils . clamp ( ( int ) ( g + NUM ) ) ; int ib = Pixel Utils . clamp ( ( int ) ( b + NUM ) ) ; out Pixels [ out Index ] = ( ia << NUM ) | ( ir << NUM ) | ( ig << NUM ) | ib ; out Index += height ; } } }
void close Silently ( Server Socket socket ) { try { socket . close ( ) ; } catch ( Exception e ) { } }
public Expression Parser Builder with Process ( Process process ) { this . process = process ; return this ; }
void add Associated Component At ( int index , Component cmp ) { if ( comps == null ) { comps = new Vector ( ) ; } comps . insert Element At ( cmp , index ) ; }
private static byte [ ] read Class ( final Input Stream is ) throws IO Exception { if ( is == null ) { throw new IO Exception ( STRING ) ; } byte [ ] b = new byte [ is . available ( ) ] ; int len = NUM ; while ( BOOL ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - NUM ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; System . arraycopy ( b , NUM , c , NUM , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < NUM ) { return b ; } byte [ ] c = new byte [ b . length + NUM ] ; System . arraycopy ( b , NUM , c , NUM , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } }
static String string From Packet ( Datagram Packet packet ) { return new String ( packet . get Data ( ) , NUM , packet . get Length ( ) ) ; }
private String read Attribute Name ( boolean return Lower Case ) { skip Whitespace ( ) ; int c = find ( ATTRIBUTE NAME TERMINATORS ) ; String for Substring = return Lower Case ? input Lower Case : input ; String result = pos < c ? for Substring . substring ( pos , c ) : null ; pos = c ; return result ; }
public boolean contains ( final Entity entity ) { if ( entity == null ) { return BOOL ; } final IRP Zone entity Zone = entity . get Zone ( ) ; return zone . equals ( entity Zone ) && zone . has ( entity . get ID ( ) ) && shape . contains ( entity . get X ( ) , entity . get Y ( ) ) ; }
protected void check Offscreen Image ( Dimension d ) { if ( double Buffered ) { if ( offscreen == null || offscreen . get Width ( ) != d . width || offscreen . get Height ( ) != d . height ) { offscreen = new Buffered Image ( d . width , d . height , Buffered Image . TYPE INT ARGB ) ; offscreen G 2 d = offscreen . create Graphics ( ) ; } } }
public void clear ( ) { synchronized ( m Lock ) { m Graphics . clear ( ) ; } post Invalidate ( ) ; }
public void test Set Object int Object int ( ) throws SQL Exception { Prepared Statement ps = null ; try { String query = STRING ; ps = conn . prepare Statement ( query ) ; Statement st = null ; try { ps . set Object ( NUM , Integer . MAX VALUE , Types . INTEGER ) ; ps . execute ( ) ; st = conn . create Statement ( ) ; st . execute ( STRING + Integer . MAX VALUE ) ; Result Set rs = st . get Result Set ( ) ; assert Equals ( NUM , get Count ( rs ) ) ; } finally { try { st . close ( ) ; } catch ( Exception ee ) { } } query = STRING ; ps = conn . prepare Statement ( query ) ; try { ps . set Object ( NUM , STRING , Types . CHAR ) ; ps . execute ( ) ; st = conn . create Statement ( ) ; st . execute ( STRING ) ; Result Set rs = st . get Result Set ( ) ; assert Equals ( NUM , get Count ( rs ) ) ; } finally { try { st . close ( ) ; } catch ( Exception ee ) { } } query = STRING ; ps = conn . prepare Statement ( query ) ; ps . set Object ( NUM , new Object ( ) , Types . DECIMAL ) ; ps . execute ( ) ; query = STRING ; ps = conn . prepare Statement ( query ) ; Date d = new Date ( NUM ) ; try { ps . set Object ( NUM , d , Types . DATE ) ; ps . execute ( ) ; st = conn . create Statement ( ) ; st . execute ( STRING + d . get Time ( ) + STRING ) ; Result Set rs = st . get Result Set ( ) ; assert Equals ( NUM , get Count ( rs ) ) ; } finally { try { st . close ( ) ; } catch ( Exception ee ) { } } query = STRING ; ps = conn . prepare Statement ( query ) ; try { ps . set Object ( NUM , STRING , Types . BLOB ) ; ps . execute ( ) ; } finally { try { st . close ( ) ; } catch ( Exception ee ) { } } } finally { try { ps . close ( ) ; } catch ( Exception ee ) { } } try { ps . set Object ( NUM , Integer . MAX VALUE , Types . INTEGER ) ; fail ( STRING ) ; } catch ( SQL Exception e ) { } }
public void warning ( org . xml . sax . SAX Parse Exception e ) throws org . xml . sax . SAX Exception { String formatted Msg = e . get Message ( ) ; SAX Source Locator locator = get Locator ( ) ; Error Listener handler = m stylesheet Processor . get Error Listener ( ) ; try { handler . warning ( new Transformer Exception ( formatted Msg , locator ) ) ; } catch ( Transformer Exception te ) { throw new org . xml . sax . SAX Exception ( te ) ; } }
public static boolean check Chroot Path ( String zk Host , boolean create ) throws Keeper Exception , Interrupted Exception { if ( ! contains Chroot ( zk Host ) ) { return BOOL ; } log . info ( STRING ) ; String chroot Path = zk Host . substring ( zk Host . index Of ( STRING ) , zk Host . length ( ) ) ; Solr Zk Client tmp Client = new Solr Zk Client ( zk Host . substring ( NUM , zk Host . index Of ( STRING ) ) , NUM * NUM ) ; boolean exists = tmp Client . exists ( chroot Path , BOOL ) ; if ( ! exists && create ) { tmp Client . make Path ( chroot Path , BOOL , BOOL ) ; exists = BOOL ; } tmp Client . close ( ) ; return exists ; }
public void add Job ( Runnable job ) { m Jobs . add ( job ) ; }
public void add X Value ( String x Val ) { mX Val Average Length = ( mX Val Average Length + x Val . length ( ) ) / NUM ; mX Vals . add ( x Val ) ; }
public boolean is Navigation At Bottom ( ) { return ( m Smallest Width Dp >= NUM || m In Portrait ) ; }
public long time Since Start ( ) { long current Time = System . current Time Millis ( ) ; return current Time - start Time ; }
public void fill Rect Radial Gradient ( Object graphics , int start Color , int end Color , int x , int y , int width , int height , float relative X , float relative Y , float relative Size ) { int center X = ( int ) ( width * ( NUM - relative X ) ) ; int center Y = ( int ) ( height * ( NUM - relative Y ) ) ; int size = ( int ) ( Math . min ( width , height ) * relative Size ) ; int x2 = ( int ) ( width / NUM - ( size * relative X ) ) ; int y2 = ( int ) ( height / NUM - ( size * relative Y ) ) ; boolean aa = is Anti Aliased ( graphics ) ; set Anti Aliased ( graphics , BOOL ) ; if ( cache Radial Gradients ( ) ) { Object r = find Cached Gradient ( radial Gradient Cache , start Color , end Color , x , y , width , height , BOOL , center X , center Y , size ) ; if ( r != null ) { draw Image ( graphics , r , x , y ) ; } else { r = create Mutable Image ( width , height , NUM ) ; Object image Graphics = get Native Graphics ( r ) ; set Color ( image Graphics , end Color ) ; fill Rect ( image Graphics , NUM , NUM , width , height ) ; fill Radial Gradient Impl ( image Graphics , start Color , end Color , x2 , y2 , size , size , NUM , NUM ) ; draw Image ( graphics , r , x , y ) ; if ( radial Gradient Cache == null ) { radial Gradient Cache = new Hashtable ( ) ; } store Cached Gradient ( r , radial Gradient Cache , start Color , end Color , x , y , BOOL , center X , center Y , size ) ; } } else { set Color ( graphics , end Color ) ; fill Rect ( graphics , x , y , width , height ) ; fill Radial Gradient Impl ( graphics , start Color , end Color , x + x2 , y + y2 , size , size , NUM , NUM ) ; } if ( aa ) { set Anti Aliased ( graphics , BOOL ) ; } }
public Formatter format ( Locale l , String format , Object ... args ) { ensure Open ( ) ; int last = - NUM ; int lasto = - NUM ; Format String [ ] fsa = parse ( format ) ; for ( int i = NUM ; i < fsa . length ; i ++ ) { Format String fs = fsa [ i ] ; int index = fs . index ( ) ; try { switch ( index ) { case - NUM : fs . print ( null , l ) ; break ; case - NUM : if ( last < NUM || ( args != null && last > args . length - NUM ) ) throw new Missing Format Argument Exception ( fs . to String ( ) ) ; fs . print ( ( args == null ? null : args [ last ] ) , l ) ; break ; case NUM : lasto ++ ; last = lasto ; if ( args != null && lasto > args . length - NUM ) throw new Missing Format Argument Exception ( fs . to String ( ) ) ; fs . print ( ( args == null ? null : args [ lasto ] ) , l ) ; break ; default : last = index - NUM ; if ( args != null && last > args . length - NUM ) throw new Missing Format Argument Exception ( fs . to String ( ) ) ; fs . print ( ( args == null ? null : args [ last ] ) , l ) ; break ; } } catch ( IO Exception x ) { last Exception = x ; } } return this ; }
public void test Write Read Empty ( ) throws Exception { Byte Array Output Stream out = new Byte Array Output Stream ( NUM ) ; Object Output Stream os = new Object Output Stream ( out ) ; os . write Object ( empty ) ; Object Input Stream is = new Object Input Stream ( new Byte Array Input Stream ( out . to Byte Array ( ) ) ) ; Cluster Policy copy = ( Cluster Policy ) is . read Object ( ) ; is . close ( ) ; os . close ( ) ; assert True ( helper . are Equals ( empty , copy ) ) ; }
DOM String List Impl ( String [ ] params ) { f Strings = new Vector ( ) ; if ( params != null ) { for ( int i = NUM ; i < params . length ; i ++ ) { f Strings . add ( params [ i ] ) ; } } }
public Instant watermark Hold ( ) { long min = Long . MAX VALUE ; for ( Instant hold : watermark Holds . values ( ) ) { min = Math . min ( min , hold . get Millis ( ) ) ; } return new Instant ( min ) ; }
@ Override public final boolean is Cap Present ( int cap ) { return ( ( ogl Caps . get Caps ( ) & cap ) != NUM ) ; }
public static < T > Menu Result < T > again ( ) { return new Menu Result < > ( Type . AGAIN , Collections . < T > empty List ( ) ) ; }
@ Suppress Warnings ( STRING ) public V put ( K key , V value ) { final int hash = key . hash Code ( ) ; int index = index Of ( key , hash ) ; if ( index >= NUM ) { index = ( index << NUM ) + NUM ; final V old = ( V ) m Array [ index ] ; m Array [ index ] = value ; return old ; } index = ~ index ; if ( m Size >= m Hashes . length ) { final int n = m Size >= ( BASE SIZE * NUM ) ? ( m Size + ( m Size > > NUM ) ) : ( m Size >= BASE SIZE ? ( BASE SIZE * NUM ) : BASE SIZE ) ; final int [ ] ohashes = m Hashes ; final Object [ ] oarray = m Array ; alloc Arrays ( n ) ; if ( m Hashes . length > NUM ) { System . arraycopy ( ohashes , NUM , m Hashes , NUM , ohashes . length ) ; System . arraycopy ( oarray , NUM , m Array , NUM , oarray . length ) ; } free Arrays ( ohashes , oarray , m Size ) ; } if ( index < m Size ) { System . arraycopy ( m Hashes , index , m Hashes , index + NUM , m Size - index ) ; System . arraycopy ( m Array , index << NUM , m Array , ( index + NUM ) << NUM , ( m Size - index ) << NUM ) ; } m Hashes [ index ] = hash ; m Array [ index << NUM ] = key ; m Array [ ( index << NUM ) + NUM ] = value ; m Size ++ ; return null ; }
public Long add New User ( String SID , String username , String userpass , String lastname , String firstname , String email , String additionalname , String street , String zip , String fax , long states id , String town , long language id , String base URL ) throws Axis Fault { try { Long users id = session Management . check Session ( SID ) ; Long user level = user Management . get User Level By ID ( users id ) ; if ( auth Level Management . check Web Service Level ( user level ) ) { Configuration conf = cfg Management . get Conf Key ( NUM , STRING ) ; String j Name time Zone = STRING ; if ( conf != null ) { j Name time Zone = conf . get Conf value ( ) ; } Long user id = user Management . register User ( username , userpass , lastname , firstname , email , new Date ( ) , street , additionalname , fax , zip , states id , town , language id , STRING , base URL , BOOL , j Name time Zone ) ; if ( user id == null || user id < NUM ) { return user id ; } Users user = user Management . get User By Id ( user id ) ; user . set Status ( NUM ) ; user . set Updatetime ( new Date ( ) ) ; user Management . update User ( user ) ; return user id ; } else { return new Long ( - NUM ) ; } } catch ( Exception err ) { log . error ( STRING , err ) ; throw new Axis Fault ( err . get Message ( ) ) ; } }
public static void interpreter Only ( Runnable runnable ) { runnable . run ( ) ; }
public D Add Extension Type ( J Dialog parent , X509 Extension extensions ) { super ( parent , Dialog . Modality Type . DOCUMENT MODAL ) ; set Title ( res . get String ( STRING ) ) ; this . extensions = extensions ; init Components ( ) ; }
private int hash ( Graphics Configuration config , int w , int h , Object ... args ) { int hash ; hash = ( config != null ? config . hash Code ( ) : NUM ) ; hash = NUM * hash + w ; hash = NUM * hash + h ; hash = NUM * hash + Arrays . deep Hash Code ( args ) ; return hash ; }
public static byte [ ] decode ( byte [ ] input , int offset , int len , int flags ) { Decoder decoder = new Decoder ( flags , new byte [ len * NUM / NUM ] ) ; if ( ! decoder . process ( input , offset , len , BOOL ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( decoder . op == decoder . output . length ) { return decoder . output ; } byte [ ] temp = new byte [ decoder . op ] ; System . arraycopy ( decoder . output , NUM , temp , NUM , decoder . op ) ; return temp ; }
protected void paint Text ( Graphics g , Abstract Button b , Rectangle text Rect , String text ) { paint Text ( g , ( J Component ) b , text Rect , text ) ; }
public static boolean uses Second Operand ( final Integer mnemonic ) { return ! mnemonic . equals ( Reil Helpers . OPCODE NOP ) && ! mnemonic . equals ( Reil Helpers . OPCODE BISZ ) && ! mnemonic . equals ( Reil Helpers . OPCODE STR ) && ! mnemonic . equals ( Reil Helpers . OPCODE STM ) && ! mnemonic . equals ( Reil Helpers . OPCODE LDM ) && ! mnemonic . equals ( Reil Helpers . OPCODE JCC ) ; }
public Rhythm Group add Overlay ( Rhythm Overlay overlay ) { m Overlays . add ( overlay ) ; if ( m Current Overlay Index == NO OVERLAY ) { select Overlay ( NUM ) ; } return this ; }
public char [ ] to Char Array ( ) { char [ ] buffer = new char [ count ] ; System . arraycopy ( value , offset , buffer , NUM , count ) ; return buffer ; }
private File [ ] filter Files ( final File [ ] to Filter , final String file Name ) { if ( file Name != null && to Filter != null ) { final File file As Filter = new File ( file Name ) ; for ( File file : to Filter ) { if ( file . compare To ( file As Filter ) == NUM ) { return new File [ ] { file As Filter } ; } } return new File [ NUM ] ; } return to Filter ; }
public Fp ( EC Curve curve , EC Field Element x , EC Field Element y ) { this ( curve , x , y , BOOL ) ; }
private void pull Event ( ) { final int new Scroll Value ; final int item Dimension ; final float initial Motion Value , last Motion Value ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : initial Motion Value = m Initial Motion X ; last Motion Value = m Last Motion X ; break ; case VERTICAL : default : initial Motion Value = m Initial Motion Y ; last Motion Value = m Last Motion Y ; break ; } switch ( m Current Mode ) { case PULL FROM END : new Scroll Value = Math . round ( Math . max ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Footer Size ( ) ; break ; case PULL FROM START : default : new Scroll Value = Math . round ( Math . min ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Header Size ( ) ; break ; } set Header Scroll ( new Scroll Value ) ; if ( new Scroll Value != NUM && ! is Refreshing ( ) ) { float scale = Math . abs ( new Scroll Value ) / ( float ) item Dimension ; switch ( m Current Mode ) { case PULL FROM END : m Footer Layout . on Pull ( scale ) ; break ; case PULL FROM START : default : m Header Layout . on Pull ( scale ) ; break ; } if ( m State != State . PULL TO REFRESH && item Dimension >= Math . abs ( new Scroll Value ) ) { set State ( State . PULL TO REFRESH ) ; } else if ( ( m State == State . PULL TO REFRESH && item Dimension < Math . abs ( new Scroll Value ) ) || ( m State == State . RESET && item Dimension < Math . abs ( new Scroll Value ) ) ) { set State ( State . RELEASE TO REFRESH ) ; } } }
private File write Private Key File ( ) throws Git Exception { final File key Directory = new File ( root Folder , host ) ; if ( ! key Directory . exists ( ) ) { key Directory . mkdirs ( ) ; } final File key File = new File ( key Directory , DEFAULT KEY NAME ) ; try ( File Output Stream fos = new File Output Stream ( key File ) ) { fos . write ( ssh Key ) ; } catch ( IO Exception e ) { LOG . error ( STRING , e ) ; throw new Git Exception ( STRING ) ; } protect Private Key File ( key File ) ; return key File ; }
protected boolean draw Left Border ( Component c , Graphics g , int x , int y , int width , int height ) { if ( super . draw Left Border ( c , g , x , y , width , height ) && frame . is Resizable ( ) ) { g . set Color ( get Frame Highlight ( ) ) ; int top Y = y + CORNER SIZE ; g . draw Line ( x , top Y , x + NUM , top Y ) ; int bottom Y = height - CORNER SIZE ; g . draw Line ( x + NUM , bottom Y , x + NUM , bottom Y ) ; g . set Color ( get Frame Shadow ( ) ) ; g . draw Line ( x + NUM , top Y - NUM , x + NUM , top Y - NUM ) ; g . draw Line ( x + NUM , bottom Y - NUM , x + NUM , bottom Y - NUM ) ; return BOOL ; } return BOOL ; }
public static boolean is File Readable ( String file Name ) { final File file = new File ( file Name ) ; return file . exists ( ) && file . can Read ( ) ; }
public static String hinting Size ( Font font ) { int instr Size = NUM ; Loca Table loca Table = Font Utils . get Loca Table ( font ) ; Glyph Table glyf Table = Font Utils . get Glyph Table ( font ) ; for ( int i = NUM ; i < loca Table . num Glyphs ( ) ; i ++ ) { Glyph glyph = glyf Table . glyph ( loca Table . glyph Offset ( i ) , loca Table . glyph Length ( i ) ) ; instr Size += glyph . instruction Size ( ) ; } double percentage = instr Size * NUM / glyf Table . header Length ( ) ; return String . format ( STRING , instr Size , two Decimal Places . format ( percentage ) ) ; }
public static void premain ( String agent Args , Instrumentation inst ) { instrumentation = inst ; LOGGER . info ( STRING ) ; check For Correct Setup ( ) ; try { @ Suppress Warnings ( STRING ) Inspect It Class Loader class Loader = new Inspect It Class Loader ( new URL [ NUM ] ) ; Class < ? > agent Clazz = class Loader . load Class ( INSPECTIT AGENT ) ; Constructor < ? > constructor = agent Clazz . get Constructor ( File . class ) ; Object real Agent = constructor . new Instance ( get Inspect It Agent Jar File Location ( ) ) ; Agent . agent = ( I Agent ) real Agent ; preload Classes ( ) ; LOGGER . info ( STRING ) ; analyze Already Loaded Classes ( ) ; inst . add Transformer ( new Java Agent ( ) ) ; } catch ( Exception e ) { LOGGER . severe ( STRING ) ; e . print Stack Trace ( ) ; } }
private static float system Property Value ( String name ) { String float String = System . get Property ( name ) ; if ( float String == null ) return Float . Na N ; try { return Float . parse Float ( float String ) ; } catch ( Number Format Exception ex ) { throw new Illegal Argument Exception ( String . format ( STRING , name , float String ) ) ; } }
@ Zap Api Ignore public boolean is Confirm Remove Proxy Excluded Domain ( ) { return this . confirm Remove Proxy Exclude Domain ; }
public Float Column ( int nrows , int capacity , float default Value ) { super ( float . class , new Float ( default Value ) ) ; if ( capacity < nrows ) { throw new Illegal Argument Exception ( STRING ) ; } m values = new float [ capacity ] ; Arrays . fill ( m values , default Value ) ; m size = nrows ; }
private boolean add Local Key ( Key Cache Object key , Affinity Topology Version top Ver , Collection < Key Cache Object > distributed Keys ) throws Ignite Checked Exception { Grid Distributed Cache Entry entry = cctx . colocated ( ) . entry Exx ( key , top Ver , BOOL ) ; assert ! entry . detached ( ) ; if ( ! cctx . is All ( entry , filter ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + entry ) ; on Complete ( BOOL , BOOL ) ; return BOOL ; } Grid Cache Mvcc Candidate cand = add Entry ( entry ) ; if ( cand != null && ! cand . reentry ( ) ) distributed Keys . add ( key ) ; return in Tx ( ) && cand == null ; }
public static boolean is Supplemental ( int c ) { return ( c >= NUM && c <= NUM ) ; }
public void test Radix 10 Neg ( ) { String value = STRING ; int radix = NUM ; Big Integer a Number = new Big Integer ( value , radix ) ; String result = a Number . to String ( radix ) ; assert True ( result . equals ( value ) ) ; }
public synchronized int read In Test From SUT ( ) { if ( remote Buffer . is Empty ( ) ) { return - NUM ; } return remote Buffer . poll ( ) & NUM ; }
public Spatial Index ( String shp Filename ) throws IO Exception { this . shp File Name = shp Filename ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + shp Filename + STRING ) ; } }
public int invoke Compiler ( ) { List < String > args = get Exec Arguments ( ) ; for ( int i = NUM ; i < args . size ( ) ; i ++ ) { String arg = args . get ( i ) ; if ( arg . starts With ( STRING ) ) { String file Name = arg . substring ( NUM ) ; args . remove ( i ) ; output Arguments To File ( file Name , args ) ; break ; } } return Exec Util . execute ( args . to Array ( new String [ args . size ( ) ] ) , System . out , System . err ) ; }
static double four Neighbors IDW ( Spatial Grid sg , double x Coord , double y Coord , double exp ) { double x Dif = ( x Coord - sg . get Xmin ( ) ) % sg . get Resolution ( ) ; double y Dif = ( y Coord - sg . get Ymin ( ) ) % sg . get Resolution ( ) ; if ( x Dif == NUM && y Dif == NUM ) { return sg . get Value ( x Coord , y Coord ) ; } double x1 = x Coord - x Dif ; double x2 = x1 + sg . get Resolution ( ) ; double y1 = y Coord - y Dif ; double y2 = y1 + sg . get Resolution ( ) ; double d11 = Math . pow ( distance ( x1 , y1 , x Coord , y Coord ) , exp ) ; double d12 = Math . pow ( distance ( x1 , y2 , x Coord , y Coord ) , exp ) ; double d21 = Math . pow ( distance ( x2 , y1 , x Coord , y Coord ) , exp ) ; double d22 = Math . pow ( distance ( x2 , y2 , x Coord , y Coord ) , exp ) ; if ( x Coord == sg . get Xmax ( ) ) { return ( sg . get Value ( x1 , y1 ) / d11 + sg . get Value ( x1 , y2 ) / d12 ) / ( NUM / d11 + NUM / d12 ) ; } if ( y Coord == sg . get Ymax ( ) ) { return ( sg . get Value ( x1 , y1 ) / d11 + sg . get Value ( x2 , y1 ) / d21 ) / ( NUM / d11 + NUM / d21 ) ; } return ( sg . get Value ( x1 , y1 ) / d11 + sg . get Value ( x1 , y2 ) / d12 + sg . get Value ( x2 , y1 ) / d21 + sg . get Value ( x2 , y2 ) / d22 ) / ( NUM / d11 + NUM / d12 + NUM / d21 + NUM / d22 ) ; }
protected void pre Update Menu ( ) { }
public Pojo Value Field ( Property Descriptor desc ) { super ( desc ) ; }
public Url Filter Rule ( String rule Text ) { super ( rule Text ) ; String url Rule Text = rule Text ; if ( String Utils . starts With ( url Rule Text , MASK WHITE LIST ) ) { url Rule Text = url Rule Text . substring ( MASK WHITE LIST . length ( ) ) ; white List Rule = BOOL ; } int options Index = String Utils . last Index Of ( url Rule Text , OPTIONS DELIMITER ) ; if ( options Index > - NUM ) { url Rule Text = url Rule Text . substring ( NUM , options Index ) ; } url Rule Text = to Punycode ( url Rule Text ) ; boolean regex Rule = url Rule Text . starts With ( MASK REGEX RULE ) && url Rule Text . ends With ( MASK REGEX RULE ) ; if ( ! regex Rule ) { shortcut = find Shortcut ( url Rule Text ) ; } }
protected static Pair < String , String > lsr Register ( final long offset , final I Translation Environment environment , final List < Reil Instruction > instructions , final String register Node Value 1 , final String register Node Value 2 ) { final String shifter Operand = environment . get Next Variable String ( ) ; final String shifter Carry Out = environment . get Next Variable String ( ) ; final String tmp Var 1 = environment . get Next Variable String ( ) ; final String tmp Var 11 = environment . get Next Variable String ( ) ; final String tmp Var 2 = environment . get Next Variable String ( ) ; final String tmp Var 3 = environment . get Next Variable String ( ) ; final String tmp Var 4 = environment . get Next Variable String ( ) ; final String tmp Var 5 = environment . get Next Variable String ( ) ; final String tmp Var 6 = environment . get Next Variable String ( ) ; final String tmp Var 7 = environment . get Next Variable String ( ) ; final String is Zero Condition = environment . get Next Variable String ( ) ; final String shifter Carry Out Tmp 1 = environment . get Next Variable String ( ) ; final String shifter Carry Out Tmp 2 = environment . get Next Variable String ( ) ; final String shifter Carry Out Tmp 3 = environment . get Next Variable String ( ) ; final String shifter Carry Out Tmp 4 = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add ( Reil Helpers . create And ( base Offset ++ , d Word Size , register Node Value 2 , d Word Size , String . value Of ( NUM ) , d Word Size , tmp Var 1 ) ) ; instructions . add ( Reil Helpers . create Sub ( base Offset ++ , d Word Size , String . value Of ( NUM ) , d Word Size , tmp Var 1 , d Word Size , tmp Var 11 ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value 1 , d Word Size , tmp Var 11 , d Word Size , tmp Var 2 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , d Word Size , tmp Var 2 , d Word Size , bit Mask All Bits Set , d Word Size , shifter Operand ) ) ; instructions . add ( Reil Helpers . create Bisz ( base Offset ++ , d Word Size , tmp Var 11 , byte Size , is Zero Condition ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , byte Size , is Zero Condition , byte Size , STRING , byte Size , shifter Carry Out Tmp 1 ) ) ; instructions . add ( Reil Helpers . create Xor ( base Offset ++ , d Word Size , tmp Var 11 , word Size , String . value Of ( NUM ) , d Word Size , tmp Var 3 ) ) ; instructions . add ( Reil Helpers . create Bisz ( base Offset ++ , d Word Size , tmp Var 3 , byte Size , is Zero Condition ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value 1 , d Word Size , thirty One Set , byte Size , tmp Var 4 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , byte Size , is Zero Condition , byte Size , tmp Var 4 , byte Size , shifter Carry Out Tmp 2 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , d Word Size , tmp Var 11 , d Word Size , not Thirty One Set , d Word Size , tmp Var 5 ) ) ; instructions . add ( Reil Helpers . create Bisz ( base Offset ++ , d Word Size , tmp Var 5 , byte Size , is Zero Condition ) ) ; instructions . add ( Reil Helpers . create Sub ( base Offset ++ , d Word Size , tmp Var 11 , d Word Size , one Set , d Word Size , tmp Var 6 ) ) ; instructions . add ( Reil Helpers . create Sub ( base Offset ++ , d Word Size , zero Set , d Word Size , tmp Var 6 , d Word Size , tmp Var 6 ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value 1 , d Word Size , tmp Var 6 , byte Size , tmp Var 7 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , byte Size , is Zero Condition , byte Size , tmp Var 7 , byte Size , shifter Carry Out Tmp 3 ) ) ; instructions . add ( Reil Helpers . create Or ( base Offset ++ , byte Size , shifter Carry Out Tmp 1 , byte Size , shifter Carry Out Tmp 2 , byte Size , shifter Carry Out Tmp 4 ) ) ; instructions . add ( Reil Helpers . create Or ( base Offset ++ , byte Size , shifter Carry Out Tmp 3 , byte Size , shifter Carry Out Tmp 4 , byte Size , shifter Carry Out ) ) ; return new Pair < String , String > ( shifter Operand , shifter Carry Out ) ; }
public static boolean is Drm Convert Needed ( String mimetype ) { return MIMETYPE DRM MESSAGE . equals ( mimetype ) ; }
public static String pad ( String original , int length , char pad Char ) { if ( original . length ( ) >= length ) return original ; String Builder sb = new String Builder ( original ) ; while ( sb . length ( ) < length ) { sb . append ( pad Char ) ; } return sb . to String ( ) ; }
public void property Change ( Property Change Event evt ) { String prop Name = evt . get Property Name ( ) ; if ( prop Name == Map Bean . Cursor Property ) { fallback Map Bean Cursor = ( ( Cursor ) evt . get New Value ( ) ) ; } else { if ( prop Name == Mouse Delegator . Active Mode Property ) { Map Mouse Mode mmm = ( Map Mouse Mode ) evt . get New Value ( ) ; set Reset Cursor ( mmm . get Mode Cursor ( ) ) ; } else if ( prop Name == Map Bean . Layers Property ) { reset For Layers ( ( Layer [ ] ) evt . get New Value ( ) , ( Layer [ ] ) evt . get Old Value ( ) ) ; } else if ( prop Name != Map Bean . Projection Property ) { return ; } set All Labels ( fudge String ) ; } init Tool Tip ( ) ; }
private void check For Night ( final Zoned Date Time TIME ) { int hour = TIME . get Hour ( ) ; int minute = TIME . get Minute ( ) ; if ( NUM <= hour && minute >= NUM && hour <= NUM && minute <= NUM || NUM <= hour && minute <= NUM && hour <= NUM && minute <= NUM ) { if ( is Night Mode ( ) ) return ; set Night Mode ( BOOL ) ; } else { if ( ! is Night Mode ( ) ) return ; set Night Mode ( BOOL ) ; } }
@ Override public int calculate Offset Y ( ) { return - ( int ) ( Math . sin ( this . angle ) * this . distance ) - this . shadow Size ; }
private double [ ] concatenate Samples ( final double [ ] x , final double [ ] y ) { final double [ ] z = new double [ x . length + y . length ] ; System . arraycopy ( x , NUM , z , NUM , x . length ) ; System . arraycopy ( y , NUM , z , x . length , y . length ) ; return z ; }
@ Override public void draw Series ( Canvas canvas , Paint paint , List < Float > points , XY Series Renderer renderer , float y Axis Value , int series Index , int start Index ) { paint . set Color ( renderer . get Color ( ) ) ; final float stroke = paint . get Stroke Width ( ) ; if ( renderer . is Fill Points ( ) ) { paint . set Style ( Style . FILL ) ; } else { paint . set Stroke Width ( renderer . get Point Stroke Width ( ) ) ; paint . set Style ( Style . STROKE ) ; } int length = points . size ( ) ; Point Style ps = renderer . get Point Style ( ) ; if ( ps == Point Style . X ) { paint . set Stroke Width ( renderer . get Point Stroke Width ( ) ) ; for ( int i = NUM ; i < length ; i += NUM ) { draw X ( canvas , paint , points . get ( i ) , points . get ( i + NUM ) ) ; } } else { if ( ps == Point Style . CIRCLE ) { for ( int i = NUM ; i < length ; i += NUM ) { draw Circle ( canvas , paint , points . get ( i ) , points . get ( i + NUM ) ) ; } } else { if ( ps == Point Style . TRIANGLE ) { float [ ] path = new float [ NUM ] ; for ( int i = NUM ; i < length ; i += NUM ) { draw Triangle ( canvas , paint , path , points . get ( i ) , points . get ( i + NUM ) ) ; } } else { if ( ps == Point Style . SQUARE ) { for ( int i = NUM ; i < length ; i += NUM ) { draw Square ( canvas , paint , points . get ( i ) , points . get ( i + NUM ) ) ; } } else { if ( ps == Point Style . DIAMOND ) { float [ ] path = new float [ NUM ] ; for ( int i = NUM ; i < length ; i += NUM ) { draw Diamond ( canvas , paint , path , points . get ( i ) , points . get ( i + NUM ) ) ; } } else { if ( ps == Point Style . POINT ) { for ( int i = NUM ; i < length ; i += NUM ) { canvas . draw Point ( points . get ( i ) , points . get ( i + NUM ) , paint ) ; } } } } } } } paint . set Stroke Width ( stroke ) ; }
public final void push Sub Context List ( Sub Context List iter ) { m axes Iterator Stack . push ( iter ) ; }
public String handle Word ( String a Word ) { Matcher m = condition Pattern . matcher ( a Word ) ; if ( m != null && m . matches ( ) ) { if ( type . equals ( Affix Type . PREFIX ) ) { return handle Prefix ( a Word ) ; } else if ( type . equals ( Affix Type . SUFFIX ) ) { return handle Suffix ( a Word ) ; } } return null ; }
public static void round ( Calendar c , String unit ) { Integer uu = CALENDAR UNITS . get ( unit ) ; if ( null == uu ) { throw new Illegal Argument Exception ( STRING + unit ) ; } int u = uu . int Value ( ) ; switch ( u ) { case Calendar . YEAR : c . clear ( Calendar . MONTH ) ; case Calendar . MONTH : c . clear ( Calendar . DAY OF MONTH ) ; c . clear ( Calendar . DAY OF WEEK ) ; c . clear ( Calendar . DAY OF WEEK IN MONTH ) ; c . clear ( Calendar . DAY OF YEAR ) ; c . clear ( Calendar . WEEK OF MONTH ) ; c . clear ( Calendar . WEEK OF YEAR ) ; case Calendar . DATE : c . clear ( Calendar . HOUR OF DAY ) ; c . clear ( Calendar . HOUR ) ; c . clear ( Calendar . AM PM ) ; case Calendar . HOUR OF DAY : c . clear ( Calendar . MINUTE ) ; case Calendar . MINUTE : c . clear ( Calendar . SECOND ) ; case Calendar . SECOND : c . clear ( Calendar . MILLISECOND ) ; break ; default : throw new Illegal State Exception ( STRING + u + STRING + unit ) ; } }
private static final char [ ] grow Buffer ( char [ ] dest , int index , int size ) { char [ ] copy = new char [ size ] ; if ( index > NUM ) { System . arraycopy ( dest , NUM , copy , NUM , index ) ; } return copy ; }
public boolean sync ( ) { if ( ulog == null ) { return BOOL ; } log . info ( msg ( ) + STRING + replicas + STRING + n Updates ) ; if ( ! ( ulog . get State ( ) == Update Log . State . ACTIVE || ulog . get State ( ) == Update Log . State . REPLAYING ) ) { log . error ( msg ( ) + STRING + ulog ) ; } if ( debug ) { if ( starting Versions != null ) { log . debug ( msg ( ) + STRING + starting Versions . size ( ) + STRING + starting Versions ) ; } } for ( String replica : replicas ) { request Versions ( replica ) ; } recent Updates = ulog . get Recent Updates ( ) ; try { our Updates = recent Updates . get Versions ( n Updates ) ; } finally { recent Updates . close ( ) ; } Collections . sort ( our Updates , abs Comparator ) ; if ( starting Versions != null ) { if ( starting Versions . size ( ) == NUM ) { log . warn ( STRING ) ; return BOOL ; } Collections . sort ( starting Versions , abs Comparator ) ; our Low Threshold = percentile ( starting Versions , NUM ) ; our High Threshold = percentile ( starting Versions , NUM ) ; long smallest New Update = Math . abs ( our Updates . get ( our Updates . size ( ) - NUM ) ) ; if ( Math . abs ( starting Versions . get ( NUM ) ) < smallest New Update ) { log . warn ( msg ( ) + STRING ) ; return BOOL ; } List < Long > new List = new Array List < > ( our Updates ) ; for ( Long ver : starting Versions ) { if ( Math . abs ( ver ) < smallest New Update ) { new List . add ( ver ) ; } } our Updates = new List ; } else { if ( our Updates . size ( ) > NUM ) { our Low Threshold = percentile ( our Updates , NUM ) ; our High Threshold = percentile ( our Updates , NUM ) ; } else { log . info ( msg ( ) + STRING ) ; return BOOL ; } } our Update Set = new Hash Set < > ( our Updates ) ; requested Update Set = new Hash Set < > ( our Updates ) ; for ( ; ; ) { Shard Response srsp = shard Handler . take Completed Or Error ( ) ; if ( srsp == null ) break ; boolean success = handle Response ( srsp ) ; if ( ! success ) { log . info ( msg ( ) + STRING ) ; shard Handler . cancel All ( ) ; return BOOL ; } } log . info ( msg ( ) + STRING ) ; return BOOL ; }
public static String strip File Protocol ( String uri String ) { if ( uri String . starts With ( STRING ) ) { uri String = uri String . substring ( NUM ) ; } return uri String ; }
private void content Spec Tree ( int content Spec Index , XML Content Spec content Spec , Children List children ) { get Content Spec ( content Spec Index , content Spec ) ; if ( content Spec . type == XML Content Spec . CONTENTSPECNODE LEAF || ( content Spec . type & NUM ) == XML Content Spec . CONTENTSPECNODE ANY || ( content Spec . type & NUM ) == XML Content Spec . CONTENTSPECNODE ANY LOCAL || ( content Spec . type & NUM ) == XML Content Spec . CONTENTSPECNODE ANY OTHER ) { if ( children . length == children . qname . length ) { Q Name [ ] new Q Name = new Q Name [ children . length * NUM ] ; System . arraycopy ( children . qname , NUM , new Q Name , NUM , children . length ) ; children . qname = new Q Name ; int [ ] new Type = new int [ children . length * NUM ] ; System . arraycopy ( children . type , NUM , new Type , NUM , children . length ) ; children . type = new Type ; } children . qname [ children . length ] = new Q Name ( null , ( String ) content Spec . value , ( String ) content Spec . value , ( String ) content Spec . other Value ) ; children . type [ children . length ] = content Spec . type ; children . length ++ ; return ; } final int left Node = content Spec . value != null ? ( ( int [ ] ) ( content Spec . value ) ) [ NUM ] : - NUM ; int right Node = - NUM ; if ( content Spec . other Value != null ) right Node = ( ( int [ ] ) ( content Spec . other Value ) ) [ NUM ] ; else return ; if ( content Spec . type == XML Content Spec . CONTENTSPECNODE CHOICE || content Spec . type == XML Content Spec . CONTENTSPECNODE SEQ ) { content Spec Tree ( left Node , content Spec , children ) ; content Spec Tree ( right Node , content Spec , children ) ; return ; } if ( content Spec . type == XML Content Spec . CONTENTSPECNODE ZERO OR ONE || content Spec . type == XML Content Spec . CONTENTSPECNODE ZERO OR MORE || content Spec . type == XML Content Spec . CONTENTSPECNODE ONE OR MORE ) { content Spec Tree ( left Node , content Spec , children ) ; return ; } throw new Runtime Exception ( STRING + content Spec . type ) ; }
protected J Text Field create Editor Component ( ) { J Text Field editor = new Borderless Text Field ( STRING , NUM ) ; editor . set Border ( null ) ; return editor ; }
private void add Arg ( String key , Object value ) { if ( request Arguments == null ) { request Arguments = new Hashtable ( ) ; } if ( value == null || key == null ) { return ; } if ( post ) { set Write Request ( BOOL ) ; } request Arguments . put ( key , value ) ; }
public static double [ ] read File Column ( String filename , int column Idx , int size Limit ) throws IO Exception , SAX Exception { Path path = Paths . get ( filename ) ; if ( ! ( Files . exists ( path ) ) ) { throw new SAX Exception ( STRING ) ; } Buffered Reader br = new Buffered Reader ( new Input Stream Reader ( new File Input Stream ( filename ) , STRING ) ) ; return read TS ( br , column Idx , size Limit ) ; }
private void start Reader ( Connection Table conn Table ) { Assert . assert True ( ! this . is Running ) ; stopped = BOOL ; this . is Running = BOOL ; conn Table . execute Command ( this ) ; }
public static boolean is Compaction Required For Table ( String meta Folder Path ) { String minor Compaction Status File = meta Folder Path + Carbon Common Constants . FILE SEPARATOR + Carbon Common Constants . minor Compaction Required File ; String major Compaction Status File = meta Folder Path + Carbon Common Constants . FILE SEPARATOR + Carbon Common Constants . major Compaction Required File ; try { if ( File Factory . is File Exist ( minor Compaction Status File , File Factory . get File Type ( minor Compaction Status File ) ) || File Factory . is File Exist ( major Compaction Status File , File Factory . get File Type ( major Compaction Status File ) ) ) { return BOOL ; } } catch ( IO Exception e ) { LOGGER . error ( STRING + e . get Message ( ) ) ; } return BOOL ; }
Big Integer copy ( ) { prepare Java Representation ( ) ; int [ ] copy Digits = new int [ number Length ] ; System . arraycopy ( digits , NUM , copy Digits , NUM , number Length ) ; return new Big Integer ( sign , number Length , copy Digits ) ; }
public void add Excluded Class ( String class Name ) { m Excluded Classes . add ( class Name ) ; }
public Bundle Message Source ( Locale locale ) { messages = Resource Bundle . get Bundle ( BASE NAME , locale ) ; }
private void clip View On The Right ( Rect cur View Bound , float cur View Width , int right ) { cur View Bound . right = ( int ) ( right - m Clip Padding ) ; cur View Bound . left = ( int ) ( cur View Bound . right - cur View Width ) ; }
private void create Edit Panel ( ) { edit Panel = new J Panel ( ) ; add ( edit Panel , Border Layout . CENTER ) ; Card Layout cardlayout = new Card Layout ( ) ; edit Panel . set Layout ( cardlayout ) ; if ( colour Ramp Map != null ) { for ( Colour Ramp Panel Interface data : colour Ramp Map . key Set ( ) ) { data . set Parent ( this ) ; String key = data . get Title ( ) ; edit Panel . add ( data . get Panel ( ) , key ) ; } } }
public static long atol ( String s ) { int i = NUM ; while ( i < s . length ( ) && Character . is Whitespace ( s . char At ( i ) ) ) i ++ ; if ( i < s . length ( ) && s . char At ( i ) == STRING ) { if ( i + NUM < s . length ( ) && ( s . char At ( i + NUM ) == STRING || s . char At ( i + NUM ) == STRING ) ) return parse Long ( s . substring ( i + NUM ) , NUM ) ; else return parse Long ( s , NUM ) ; } else return parse Long ( s , NUM ) ; }
public Object eval ( Reader reader , Script Engine engine ) throws Script Exception { return engine . eval ( reader ) ; }
public static Input Stream to Input Stream ( Char Sequence input , Charset encoding ) { return to Input Stream ( input . to String ( ) , encoding ) ; }
public void class For Name ( Soot Method container , Stmt for Name Invoke Stmt ) { Set < String > class Names = reflection Info . class For Name Class Names ( container ) ; if ( class Names == null || class Names . is Empty ( ) ) { register Guard ( container , for Name Invoke Stmt , STRING ) ; } else { for ( String cls Name : class Names ) { constant For Name ( cls Name , container , for Name Invoke Stmt ) ; } } }
private Abstract Renderer create Renderer ( J Tabbed Pane tabbed Pane ) { return has Embedded Tabs ( ) ? Abstract Renderer . create Embedded Renderer ( tabbed Pane ) : Abstract Renderer . create Renderer ( tab Pane ) ; }
public void read Map ( Input Stream input Stream , Map Builder builder ) { try { parse Map ( input Stream , builder ) ; if ( builder . node Refs Without Defs Added ( ) ) LOG . warning ( STRING ) ; } catch ( SAX Parse Exception e ) { throw new Osm Runtime Exception ( STRING + STRING + e . get Public Id ( ) + STRING + e . get System Id ( ) + STRING + e . get Line Number ( ) + STRING + e . get Column Number ( ) + STRING , e ) ; } catch ( SAX Exception e ) { throw new Osm Runtime Exception ( STRING , e ) ; } catch ( IO Exception e ) { throw new Osm Runtime Exception ( STRING , e ) ; } finally { if ( input Stream != null ) { try { input Stream . close ( ) ; } catch ( IO Exception e ) { LOG . log ( Level . SEVERE , STRING , e ) ; } } } }
private void process Comment ( ) { template Reader . next Character ( ) ; if ( template Reader . starts With ( syntax . get Document Type Opening ( ) ) ) { process Schema Comment ( ) ; return ; } else if ( nested Comments ) { process Nested Comment ( ) ; return ; } while ( template Reader . has Next Character ( ) ) { final char comment Character = template Reader . next Character ( ) ; if ( is Comment Closing Marker ( comment Character ) && template Reader . has Next Character ( ) && template Reader . peek Character ( ) == syntax . get Tag Closing ( ) ) { template Reader . next Character ( ) ; break ; } } }
private void emit Permutations App Cache ( Tree Logger logger , Linker Context context , Artifact Set artifacts , String start Screen Id , Offline Screen offline Screen ) throws Unable To Complete Exception { for ( Emitted Artifact emitted : artifacts . find ( Emitted Artifact . class ) ) { if ( emitted . get Visibility ( ) == Visibility . Private ) { continue ; } String path Name = emitted . get Partial Path ( ) ; if ( accept Cached Resource ( path Name ) ) { if ( ! all Artifacts . contains ( path Name ) ) { cached Artifacts . add ( path Name ) ; } } } Set < Artifacts Group > key Set = artifacts By Group . key Set ( ) ; for ( Artifacts Group group : key Set ) { Set < String > set = artifacts By Group . get ( group ) ; set . add All ( cached Artifacts ) ; artifacts . add ( create Cache Manifest ( context , logger , set , group . get Group Id ( ) , start Screen Id , offline Screen ) ) ; artifacts . add ( create Cache Manifest Loader ( context , logger , group . get Group Id ( ) , start Screen Id ) ) ; } }
public final boolean is Registered ( ) { return ! canonical Name . starts With ( STRING ) && ! canonical Name . starts With ( STRING ) ; }
public License ( final String filename , final String text ) { if ( filename == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( filename . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . filename = filename ; if ( text == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( text . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . text = text ; }
protected static void process Explorer Props ( File props File ) { try { Properties exp Props = new Properties ( ) ; Buffered Input Stream bi = new Buffered Input Stream ( new File Input Stream ( props File ) ) ; exp Props . load ( bi ) ; bi . close ( ) ; bi = null ; Set < Object > keys = exp Props . key Set ( ) ; Iterator < Object > keys I = keys . iterator ( ) ; while ( keys I . has Next ( ) ) { String key = ( String ) keys I . next ( ) ; if ( ! key . ends With ( STRING ) ) { String existing Val = Explorer Defaults . get ( key , STRING ) ; if ( existing Val . length ( ) > NUM ) { String replace Policy = exp Props . get Property ( key + STRING ) ; if ( replace Policy != null && replace Policy . length ( ) > NUM ) { if ( replace Policy . equals Ignore Case ( STRING ) ) { String new Val = exp Props . get Property ( key ) ; Explorer Defaults . set ( key , new Val ) ; } else { String new Val = exp Props . get Property ( key ) ; if ( existing Val . index Of ( new Val ) < NUM ) { new Val = existing Val + STRING + new Val ; Explorer Defaults . set ( key , new Val ) ; } } } else { String new Val = exp Props . get Property ( key ) ; if ( existing Val . index Of ( new Val ) < NUM ) { new Val = existing Val + STRING + new Val ; Explorer Defaults . set ( key , new Val ) ; } } } else { String new Val = exp Props . get Property ( key ) ; Explorer Defaults . set ( key , new Val ) ; } } } } catch ( Exception ex ) { } }
long calculate Mid Entry ( long lo Val , long hi Val , final double dfp , long lo Entry , long hi Entry ) { final double dhi = ( double ) hi Entry ; final double dlo = ( double ) lo Entry ; final double dhi Val = ( double ) hi Val ; final double dlo Val = ( double ) lo Val ; long mid Entry = lo Entry + ( long ) ( ( dhi - dlo ) * ( dfp - dlo Val ) / ( dhi Val - dlo Val ) ) ; if ( mid Entry == hi Entry ) { mid Entry -- ; } return mid Entry ; }
@ Suppress Warnings ( STRING ) protected int hash Fields ( int hash , Map < Field Descriptor , Object > map ) { for ( Map . Entry < Field Descriptor , Object > entry : map . entry Set ( ) ) { Field Descriptor field = entry . get Key ( ) ; Object value = entry . get Value ( ) ; hash = ( NUM * hash ) + field . get Number ( ) ; if ( field . get Type ( ) != Field Descriptor . Type . ENUM ) { hash = ( NUM * hash ) + value . hash Code ( ) ; } else if ( field . is Repeated ( ) ) { List < ? extends Enum Lite > list = ( List < ? extends Enum Lite > ) value ; hash = ( NUM * hash ) + hash Enum List ( list ) ; } else { hash = ( NUM * hash ) + hash Enum ( ( Enum Lite ) value ) ; } } return hash ; }
public Dashboard Service Helper ( ) { attributes Require Update . add ( DASHBOARD CLASS NAME ) ; attributes Require Update . add ( DASHBOARD NAME ) ; attributes Require Update . add ( DASHBOARD DISPLAY NAME ) ; attributes Require Update . add ( DASHBOARD ICON ) ; attributes Require Update . add ( DASHBOARD LOGIN ) ; attributes Require Update . add ( ICF IDENTIFIER ) ; attributes . add All ( attributes Require Update ) ; }
public static String java Util Regex Escape ( String s ) { if ( s . index Of ( STRING ) == - NUM ) { return STRING + s + STRING ; } String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { sb . append ( STRING ) ; sb . append ( s . char At ( i ) ) ; } return sb . to String ( ) ; }
public void forget Ffmpeg Path ( ) { settings . put ( SETTINGS FFMPEG PATH , FFMPEG PATH UNSET ) ; }
@ Override public void print Warning ( final String message ) { print Warning ( message , preference Store . get Boolean ( UI Preference Constants . CONSOLE SHOW ON NEW WARNING ) ) ; }
public static String revert New Lines ( String string ) { int index ; String Buffer new String Buffer = new String Buffer ( ) ; while ( ( index = string . index Of ( STRING ) ) != - NUM ) { if ( index > NUM ) { new String Buffer . append ( string . substring ( NUM , index ) ) ; } new String Buffer . append ( STRING ) ; if ( ( index + NUM ) < string . length ( ) ) { string = string . substring ( index + NUM ) ; } else { string = STRING ; } } new String Buffer . append ( string ) ; string = new String Buffer . to String ( ) ; new String Buffer = new String Buffer ( ) ; while ( ( index = string . index Of ( STRING ) ) != - NUM ) { if ( index > NUM ) { new String Buffer . append ( string . substring ( NUM , index ) ) ; } new String Buffer . append ( STRING ) ; if ( ( index + NUM ) < string . length ( ) ) { string = string . substring ( index + NUM ) ; } else { string = STRING ; } } new String Buffer . append ( string ) ; return new String Buffer . to String ( ) ; }
public void path Values To Pixel ( List < Path > paths ) { for ( int i = NUM ; i < paths . size ( ) ; i ++ ) { path Value To Pixel ( paths . get ( i ) ) ; } }
@ Override public void on Insert Complete ( int task Id , Object cookie , long insert Row Id ) { if ( task Id == App Constants . Query Tokens . INSERT WALLPOST && insert Row Id != - NUM ) { Logger . i ( TAG , STRING + insert Row Id ) ; } }
protected void parse List ( Array List < String > list , String text ) { list . clear ( ) ; String Tokenizer st = new String Tokenizer ( text , STRING ) ; while ( st . has More Elements ( ) ) { String line = ( String ) st . next Element ( ) ; list . add ( line . trim ( ) ) ; } }
protected List < Node > split Assignments ( Node node ) { if ( node instanceof Assignment Node ) { List < Node > result = new Array List < > ( ) ; Assignment Node a = ( Assignment Node ) node ; result . add ( a . get Target ( ) ) ; result . add All ( split Assignments ( a . get Expression ( ) ) ) ; return result ; } else { return Collections . singleton List ( node ) ; } }
public Tree < String > extract Best Max Rule Parse ( int start , int end , List < String > sentence ) { return extract Best Max Rule Parse 1 ( start , end , NUM , sentence ) ; }
public static double normalize ( double val , double min , double max ) { if ( max < min ) throw new Illegal Argument Exception ( STRING ) ; return ( val - min ) / ( max - min ) ; }
private static boolean contains Only Transient And Static Fields ( List < Field > fields ) { boolean contains Normal Field = BOOL ; for ( Field field : fields ) { if ( ! Modifier . is Transient ( field . get Modifiers ( ) ) && ! Modifier . is Static ( field . get Modifiers ( ) ) ) { contains Normal Field = BOOL ; } } return ! contains Normal Field ; }
@ Override public void append Index Map To ( Appendable out , String name , List < Source Map Section > sections ) throws IO Exception { out . append ( STRING ) ; append First Field ( out , STRING , STRING ) ; append Field ( out , STRING , escape String ( name ) ) ; append Field Start ( out , STRING ) ; out . append ( STRING ) ; boolean first = BOOL ; for ( Source Map Section section : sections ) { if ( first ) { first = BOOL ; } else { out . append ( STRING ) ; } out . append ( STRING ) ; append First Field ( out , STRING , offset Value ( section . get Line ( ) , section . get Column ( ) ) ) ; if ( section . get Section Type ( ) == Source Map Section . Section Type . URL ) { append Field ( out , STRING , escape String ( section . get Section Value ( ) ) ) ; } else if ( section . get Section Type ( ) == Source Map Section . Section Type . MAP ) { append Field ( out , STRING , section . get Section Value ( ) ) ; } else { throw new IO Exception ( STRING ) ; } out . append ( STRING ) ; } out . append ( STRING ) ; append Field End ( out ) ; out . append ( STRING ) ; }
public Builder add Part ( Part part ) { if ( part == null ) throw new Null Pointer Exception ( STRING ) ; parts . add ( part ) ; return this ; }
protected void notify Gone ( L locator ) { synchronized ( this ) { if ( ! stale Locators . add ( locator . get Partition Id ( ) ) ) { fail ( STRING + locator ) ; } } }
@ Override public void add Vetoable Change Listener ( String name , Vetoable Change Listener vcl ) { m bc Support . add Vetoable Change Listener ( name , vcl ) ; }
public String build User ( ) { return properties . get Property ( STRING ) ; }
private void update Idle Expire Time ( long now ) { thread Idle Expire Time . set ( now + idle Timeout ) ; }
protected Ct Class create Ct Class ( String classname , boolean use Cache ) { if ( classname . char At ( NUM ) == STRING ) classname = Descriptor . to Class Name ( classname ) ; if ( classname . ends With ( STRING ) ) { String base = classname . substring ( NUM , classname . index Of ( STRING ) ) ; if ( ( ! use Cache || get Cached ( base ) == null ) && find ( base ) == null ) return null ; else return new Ct Array ( classname , this ) ; } else if ( find ( classname ) == null ) return null ; else return new Ct Class Type ( classname , this ) ; }
@ Transactional public long create Voucher From Bill ( final int bill Id ) throws Application Runtime Exception { try { String voucher Status = null ; final List v Status List = app Config Values Service . get Config Values By Module And Key ( STRING , STRING ) ; if ( ! v Status List . is Empty ( ) && v Status List . size ( ) == NUM ) { final App Config Values app Val = ( App Config Values ) v Status List . get ( NUM ) ; voucher Status = app Val . get Value ( ) ; } else throw new Application Runtime Exception ( STRING + MISSINGMSG ) ; final long vh = create Voucher . create Voucher From Bill ( bill Id , voucher Status , null , null ) ; return vh ; } catch ( final Exception e ) { LOGGER . error ( e . get Message ( ) ) ; throw new Application Runtime Exception ( e . get Message ( ) ) ; } }
public static float compare Equivalance ( Bitmap bitmap 1 , Bitmap bitmap 2 ) { if ( bitmap 1 == null || bitmap 2 == null || bitmap 1 . get Width ( ) != bitmap 2 . get Width ( ) || bitmap 1 . get Height ( ) != bitmap 2 . get Height ( ) ) { return NUM ; } Byte Buffer buffer 1 = Byte Buffer . allocate ( bitmap 1 . get Height ( ) * bitmap 1 . get Row Bytes ( ) ) ; bitmap 1 . copy Pixels To Buffer ( buffer 1 ) ; Byte Buffer buffer 2 = Byte Buffer . allocate ( bitmap 2 . get Height ( ) * bitmap 2 . get Row Bytes ( ) ) ; bitmap 2 . copy Pixels To Buffer ( buffer 2 ) ; byte [ ] array 1 = buffer 1 . array ( ) ; byte [ ] array 2 = buffer 2 . array ( ) ; int len = array 1 . length ; int count = NUM ; for ( int i = NUM ; i < len ; i ++ ) { if ( array 1 [ i ] == array 2 [ i ] ) { count ++ ; } } return ( ( float ) ( count ) ) / len ; }
public void handle Tbl Charset Alias Href Action Request ( Request Invocation Event event ) throws Model Control Exception { try { Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute ( PROPERTY ATTRIBUTE , ( Hash Map ) values ) ; G11 N Charset Alias Edit View Bean vb = ( G11 N Charset Alias Edit View Bean ) get View Bean ( G11 N Charset Alias Edit View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . populate Values ( ( String ) get Display Field Value ( STRING ) ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } }
public Boolean Glass Gene Im ( Boolean Glass Gene Pm gene Pm , Parameters parameters ) { try { this . gene Pm = gene Pm ; this . glass Function = new Boolean Glass Function ( gene Pm . get Lag Graph ( ) ) ; this . initializer = new Basal Initializer ( glass Function , NUM , NUM ) ; this . history = new Gene History ( initializer , glass Function ) ; this . simulator = new Measurement Simulator Params ( parameters ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
protected List < ITEM TYPE > select Fold Train Items ( List < ITEM TYPE > items , int n Folds , int fold ) { List < ITEM TYPE > train Items = new Array List < ITEM TYPE > ( ) ; for ( int i = NUM ; i < items . size ( ) ; ++ i ) { if ( i % n Folds != fold ) { train Items . add ( items . get ( i ) ) ; } } return train Items ; }
private boolean journal Rebuild Required ( ) { final int redundant Op Compact Threshold = NUM ; return redundant Op Count >= redundant Op Compact Threshold && redundant Op Count >= lru Entries . size ( ) ; }
protected void rehash ( int new Capacity ) { int old Capacity = set . length ; K old Keys [ ] = ( K [ ] ) set ; short old Vals [ ] = values ; set = new Object [ new Capacity ] ; Arrays . fill ( set , FREE ) ; values = new short [ new Capacity ] ; for ( int i = old Capacity ; i -- > NUM ; ) { if ( old Keys [ i ] != FREE && old Keys [ i ] != REMOVED ) { K o = old Keys [ i ] ; int index = insertion Index ( o ) ; if ( index < NUM ) { throw Object Contract Violation ( set [ ( - index - NUM ) ] , o ) ; } set [ index ] = o ; values [ index ] = old Vals [ i ] ; } } }
protected void add Attributes ( Element element , Attributes attributes ) { boolean no Namespace Attributes = BOOL ; if ( element instanceof Abstract Element ) { Abstract Element base Element = ( Abstract Element ) element ; base Element . set Attributes ( attributes , namespace Stack , no Namespace Attributes ) ; } else { int size = attributes . get Length ( ) ; for ( int i = NUM ; i < size ; i ++ ) { String attribute Q Name = attributes . get Q Name ( i ) ; if ( no Namespace Attributes || ! attribute Q Name . starts With ( STRING ) ) { String attribute URI = attributes . get URI ( i ) ; String attribute Local Name = attributes . get Local Name ( i ) ; String attribute Value = attributes . get Value ( i ) ; Q Name q Name = namespace Stack . get Attribute Q Name ( attribute URI , attribute Local Name , attribute Q Name ) ; element . add Attribute ( q Name , attribute Value ) ; } } } }
public static < T > boolean remove ( Collection < T > collection , T element ) { if ( element == null ) { return BOOL ; } if ( Collection Utils . is Empty ( collection ) ) { return BOOL ; } return collection . remove ( element ) ; }
private static void persist Updated Vpool List ( List < Virtual Pool > updated Vpool List , Db Client db Client ) { if ( ! updated Vpool List . is Empty ( ) ) { db Client . update And Reindex Object ( updated Vpool List ) ; } }
void compose Templates ( Elem Template Element templ ) throws Transformer Exception { templ . compose ( this ) ; for ( Elem Template Element child = templ . get First Child Elem ( ) ; child != null ; child = child . get Next Sibling Elem ( ) ) { compose Templates ( child ) ; } templ . end Compose ( this ) ; }
public static boolean class Exists ( String class Name ) { try { return Class . for Name ( class Name ) != null ; } catch ( Class Not Found Exception e ) { return BOOL ; } }
public static void create Top Level Classes XML ( String output Dir , String templates Path , boolean lenient ) throws Compiler Exception { try { As Doc Helper as Doc Help = new As Doc Helper ( output Dir + STRING , output Dir + STRING , output Dir , output Dir + STRING + File . separator + STRING ) ; as Doc Help . create Top Level Classes ( lenient ) ; } catch ( Throwable t ) { t . print Stack Trace ( ) ; Compiler Message c = new Could Not Create ( STRING , t . get Message ( ) ) ; Thread Local Toolkit . log ( c ) ; throw c ; } }
void draw Shape ( Graphics g , CSS . Value type , int ax , int ay , int aw , int ah , float align ) { int gap = is Left To Right ? - ( bulletgap + NUM ) : ( aw + bulletgap ) ; int x = ax + gap ; int y = Math . max ( ay , ay + ( int ) ( align * ah ) - NUM ) ; if ( type == CSS . Value . SQUARE ) { g . draw Rect ( x , y , NUM , NUM ) ; } else if ( type == CSS . Value . CIRCLE ) { g . draw Oval ( x , y , NUM , NUM ) ; } else { g . fill Oval ( x , y , NUM , NUM ) ; } }
public static void restore ( final Context context ) { Shared Preferences prefs = Preference Manager . get Default Shared Preferences ( context ) ; if ( Long Term Orbits . is Supported ( ) && prefs . get Boolean ( KEY LOCATION TOGGLE , BOOL ) ) { save Download Data Wifi Only Pref ( context ) ; Alarm Manager am = ( Alarm Manager ) context . get System Service ( Context . ALARM SERVICE ) ; Intent intent = new Intent ( context , Lto Service . class ) ; Pending Intent pi = Pending Intent . get Service ( context , NUM , intent , Pending Intent . FLAG UPDATE CURRENT | Pending Intent . FLAG ONE SHOT ) ; long next Lto Download = System . current Time Millis ( ) + ( NUM * NUM * NUM ) ; am . set ( Alarm Manager . RTC , next Lto Download , pi ) ; } }
private void generate File ( int word Cnt ) throws Exception { Random rnd = new Random ( System . current Time Millis ( ) ) ; try ( Output Stream Writer writer = new Output Stream Writer ( igfs . create ( FILE , BOOL ) ) ) { int cnt = NUM ; while ( cnt < word Cnt ) { String word = DICTIONARY [ rnd . next Int ( DICTIONARY . length ) ] ; writer . write ( word + STRING ) ; cnt ++ ; } } }
public void polygon ( double [ ] x , double [ ] y ) { int n = x . length ; General Path path = new General Path ( ) ; path . move To ( ( float ) scale X ( x [ NUM ] ) , ( float ) scale Y ( y [ NUM ] ) ) ; for ( int i = NUM ; i < n ; i ++ ) path . line To ( ( float ) scale X ( x [ i ] ) , ( float ) scale Y ( y [ i ] ) ) ; path . close Path ( ) ; offscreen . draw ( path ) ; draw ( ) ; }
public void force Rewrite Exif ( String filename , Collection < Exif Tag > tags ) throws File Not Found Exception , IO Exception { if ( ! rewrite Exif ( filename , tags ) ) { Exif Data temp Data = m Data ; m Data = new Exif Data ( DEFAULT BYTE ORDER ) ; File Input Stream is = null ; Byte Array Output Stream bytes = null ; try { is = new File Input Stream ( filename ) ; bytes = new Byte Array Output Stream ( ) ; do Exif Stream IO ( is , bytes ) ; byte [ ] image Bytes = bytes . to Byte Array ( ) ; read Exif ( image Bytes ) ; set Tags ( tags ) ; write Exif ( image Bytes , filename ) ; } catch ( IO Exception e ) { close Silently ( is ) ; throw e ; } finally { is . close ( ) ; m Data = temp Data ; } } }
public void append ( int key , E value ) { if ( m Size != NUM && key <= m Keys [ m Size - NUM ] ) { put ( key , value ) ; return ; } if ( m Garbage && m Size >= m Keys . length ) { gc ( ) ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n = Container Helpers . ideal Int Array Size ( pos + NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( m Keys , NUM , nkeys , NUM , m Keys . length ) ; System . arraycopy ( m Values , NUM , nvalues , NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + NUM ; }
public void test Negate Negative ( ) { String a = STRING ; int a Scale = NUM ; String c = STRING ; int c Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal c Number = new Big Decimal ( new Big Integer ( c ) , c Scale ) ; assert Equals ( STRING , c Number , a Number . negate ( ) ) ; }
public List < Search Result > search By Object Name ( String name ) { List < Search Result > all = new Array List < > ( ) ; for ( Layer layer : layers ) { if ( is Layer Visible ( layer ) ) { all . add All ( layer . search By Object Name ( name ) ) ; } } Log . d ( TAG , STRING + all . size ( ) + STRING + name ) ; return all ; }
private void clear Messages ( ) { messages . clear ( ) ; }
public Searcher ( ) throws IO Exception { searcher = new Index Searcher ( Directory Reader . open ( FS Directory . open ( Paths . get ( INDEX DIR ) ) ) ) ; parser = new Query Parser ( CONTENT FIELD , new Standard Analyzer ( ) ) ; }
public void clear Text Edits ( ) { f Edits . clear ( ) ; }
public static void main ( String [ ] args ) { Frame frame = new Packet Tool ( ) ; frame . pack ( ) ; frame . set Location Relative To ( null ) ; frame . set Visible ( BOOL ) ; }
private void create Tool Bar ( ) { tool Bar = new J Tool Bar ( STRING ) ; if ( listener . running As J Console Plugin || listener . running As Visual VM Plugin ) { tool Bar . add ( create Tool Bar Button ( STRING , STRING ) ) ; tool Bar . set Floatable ( BOOL ) ; } else { tool Bar . add ( create Tool Bar Button ( STRING , STRING ) ) ; close Tool Bar Button = create Tool Bar Button ( STRING , STRING ) ; close Tool Bar Button . set Enabled ( BOOL ) ; tool Bar . add ( close Tool Bar Button ) ; } tool Bar . add Separator ( ) ; tool Bar . add ( create Tool Bar Button ( STRING , STRING ) ) ; tool Bar . add Separator ( ) ; expand Button = create Tool Bar Button ( STRING , STRING ) ; expand Button . set Enabled ( BOOL ) ; tool Bar . add ( expand Button ) ; collapse Button = create Tool Bar Button ( STRING , STRING ) ; collapse Button . set Enabled ( BOOL ) ; tool Bar . add ( collapse Button ) ; tool Bar . add Separator ( ) ; find LR Threads Button = create Tool Bar Button ( STRING , STRING ) ; find LR Threads Button . set Enabled ( BOOL ) ; tool Bar . add ( find LR Threads Button ) ; tool Bar . add ( create Tool Bar Button ( STRING , STRING ) ) ; tool Bar . add ( create Tool Bar Button ( STRING , STRING ) ) ; tool Bar . add Separator ( ) ; }
public static Map attr Set To Map ( Attr Set attr Set , boolean fetch Byte Values ) { Map attributes Map = new AM Hash Map ( fetch Byte Values ) ; if ( attr Set == null ) { return attributes Map ; } int attr Set Size = attr Set . size ( ) ; if ( ! fetch Byte Values ) { for ( int i = NUM ; i < attr Set Size ; i ++ ) { Attr attr = attr Set . element At ( i ) ; String values [ ] = attr . get String Values ( ) ; attributes Map . put ( attr . get Name ( ) , string Array To Set ( values ) ) ; } } else { for ( int i = NUM ; i < attr Set Size ; i ++ ) { Attr attr = attr Set . element At ( i ) ; attributes Map . put ( attr . get Name ( ) , attr . get Byte Values ( ) ) ; } } return attributes Map ; }
public final Iterator < String > schemes Iterator ( ) { return m Data Schemes != null ? m Data Schemes . iterator ( ) : null ; }
@ Override public void close ( ) throws IO Exception { try { out . close ( ) ; } finally { lock File . delete ( ) ; } }
public static void reinit Recompiler ( ) { rewriter . set ( new Program Rewriter ( BOOL , BOOL ) ) ; }
default Value remove ( Optional < ? extends Char Sequence > name ) { return name . is Present ( ) ? remove ( name . get ( ) ) : null ; }
private String next To Internal ( String excluded ) { int start = pos ; for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . char At ( pos ) ; if ( c == STRING || c == STRING || excluded . index Of ( c ) != - NUM ) { return in . substring ( start , pos ) ; } } return in . substring ( start ) ; }
Accept Tcp ( Port Tcp port , Server Socket Bar server Socket ) { Objects . require Non Null ( port ) ; Objects . require Non Null ( server Socket ) ; port = port ; server Socket = server Socket ; }
private static void update Grabbed Cursor ( Cursor cur ) { X Base Window target = X Awt State . get Grab Window ( ) ; if ( target instanceof X Window Peer ) { X Window Peer grabber = ( X Window Peer ) target ; grabber . p Set Cursor ( cur ) ; } }
protected void parse URI ( String uri String ) throws URI Syntax Exception { String s = uri String ; int index = s . index Of ( FRAGMENT SEPARATOR ) ; if ( index != - NUM ) { set Fragment ( s . substring ( index + NUM ) , BOOL ) ; s = s . substring ( NUM , index ) ; } index = s . index Of ( SCHEME SEPARATOR ) ; if ( index != - NUM ) { String scheme = s . substring ( NUM , index ) ; if ( is Valid Scheme ( scheme ) ) { set Scheme ( scheme ) ; s = s . substring ( index + NUM ) ; } } parse Scheme Specific Part ( s , BOOL ) ; }
@ Override public boolean equals ( Object obj ) { if ( ( obj instanceof Keep Alive Key ) == BOOL ) return BOOL ; Keep Alive Key kae = ( Keep Alive Key ) obj ; return host . equals ( kae . host ) && ( port == kae . port ) && protocol . equals ( kae . protocol ) && this . obj == kae . obj ; }
protected static void append Long String Type ( String Builder sb ) { sb . append ( STRING ) ; }
public void test Connect Headset ( ) { int iterations = Bluetooth Test Runner . s Connect Headset Iterations ; if ( iterations == NUM ) { return ; } Bluetooth Adapter adapter = Bluetooth Adapter . get Default Adapter ( ) ; Bluetooth Device device = adapter . get Remote Device ( Bluetooth Test Runner . s Device Address ) ; m Test Utils . disable ( adapter ) ; m Test Utils . enable ( adapter ) ; m Test Utils . unpair ( adapter , device ) ; m Test Utils . pair ( adapter , device , Bluetooth Test Runner . s Device Pair Passkey , Bluetooth Test Runner . s Device Pair Pin ) ; m Test Utils . disconnect Profile ( adapter , device , Bluetooth Profile . HEADSET , null ) ; for ( int i = NUM ; i < iterations ; i ++ ) { m Test Utils . write Output ( STRING + ( i + NUM ) + STRING + iterations ) ; m Test Utils . connect Profile ( adapter , device , Bluetooth Profile . HEADSET , String . format ( STRING , device ) ) ; m Test Utils . disconnect Profile ( adapter , device , Bluetooth Profile . HEADSET , String . format ( STRING , device ) ) ; } m Test Utils . unpair ( adapter , device ) ; m Test Utils . disable ( adapter ) ; }
public static boolean is NA ( String [ ] N Astrings , String w ) { if ( N Astrings == null ) return BOOL ; for ( String na : N Astrings ) { if ( w . equals ( na ) ) return BOOL ; } return BOOL ; }
private double [ ] evaluate Probability ( double [ ] data ) { double [ ] prob = new double [ m Num Classes ] , v = new double [ m Num Classes ] ; for ( int j = NUM ; j < m Num Classes - NUM ; j ++ ) { for ( int k = NUM ; k <= m Num Predictors ; k ++ ) { v [ j ] += m Par [ k ] [ j ] * data [ k ] ; } } v [ m Num Classes - NUM ] = NUM ; for ( int m = NUM ; m < m Num Classes ; m ++ ) { double sum = NUM ; for ( int n = NUM ; n < m Num Classes - NUM ; n ++ ) { sum += Math . exp ( v [ n ] - v [ m ] ) ; } prob [ m ] = NUM / ( sum + Math . exp ( - v [ m ] ) ) ; } return prob ; }
public static final Hash Map read Map Xml ( Input Stream in ) throws Xml Pull Parser Exception , IO Exception { Xml Pull Parser parser = Xml . new Pull Parser ( ) ; parser . set Input ( in , null ) ; return ( Hash Map ) read Value Xml ( parser , new String [ NUM ] ) ; }
protected void modify OM Graphic For Edit Render ( ) { }
int next Node ( String s Str , int i ) { int n Braces = NUM ; char c = s Str . char At ( i ) ; do { i ++ ; if ( i < s Str . length ( ) ) { c = s Str . char At ( i ) ; if ( c == STRING ) { while ( i < s Str . length ( ) && s Str . char At ( i ) != STRING ) { i ++ ; } i ++ ; if ( i < s Str . length ( ) ) { c = s Str . char At ( i ) ; } } switch ( c ) { case STRING : n Braces ++ ; break ; case STRING : n Braces -- ; break ; default : break ; } } } while ( i < s Str . length ( ) && ( n Braces > NUM || ( c != STRING && c != STRING && c != STRING ) ) ) ; if ( i >= s Str . length ( ) || n Braces < NUM ) { return - NUM ; } else if ( s Str . char At ( i ) == STRING ) { i ++ ; if ( s Str . char At ( i ) == STRING ) { while ( i < s Str . length ( ) && s Str . char At ( i ) != STRING ) { i ++ ; } i ++ ; if ( i >= s Str . length ( ) ) { return - NUM ; } } if ( s Str . char At ( i ) == STRING ) { i ++ ; c = s Str . char At ( i ) ; while ( i < s Str . length ( ) && ( c == STRING || Character . is Digit ( c ) ) ) { i ++ ; if ( i < s Str . length ( ) ) { c = s Str . char At ( i ) ; } } } } return i ; }
public boolean select Node ( D node Data , Signal Event event ) { if ( selected Nodes . is Empty ( ) ) { insert And Select Node ( node Data , NUM , BOOL ) ; return BOOL ; } if ( ! has Same Parent ( selected Nodes . get ( NUM ) , node Data ) ) { if ( ! this . multilevel Selection || event . get Shift Key ( ) ) { return select Single Node ( node Data ) ; } } if ( event == null || event . get Command Key ( ) ) { ctrl Select ( node Data ) ; return BOOL ; } else { if ( event . get Shift Key ( ) ) { return shift Select ( node Data ) ; } } return select Single Node ( node Data ) ; }
@ Override public int [ ] sequence Lengths ( final long start , final long end ) throws IO Exception { final int entry Size = m Index . get Version ( ) >= Index File . PER SEQUENCE CHECKSUM VERSION ? ( m Index . has Quality ( ) ? NUM : NUM ) : NUM ; final long internal Start = start + m Start ; final long internal End = end + m Start ; final int [ ] ret = new int [ ( int ) ( internal End - internal Start ) ] ; if ( ret . length == NUM ) { return ret ; } if ( m Index . get Max Length ( ) == m Index . get Min Length ( ) ) { Arrays . fill ( ret , ( int ) m Index . get Max Length ( ) ) ; return ret ; } final byte [ ] buffer = new byte [ entry Size * NUM ] ; final Data File Index data Index = m Sequence Manager . sequence Index ( ) ; final long [ ] num Sequences = new long [ data Index . number Entries ( ) ] ; int start File No = - NUM ; int end File No = - NUM ; for ( int i = NUM ; i < num Sequences . length ; i ++ ) { if ( i > NUM ) { num Sequences [ i ] = num Sequences [ i - NUM ] + data Index . number Sequences ( i ) ; } else { num Sequences [ NUM ] = data Index . number Sequences ( NUM ) ; } if ( internal Start < num Sequences [ i ] ) { if ( start File No == - NUM ) { start File No = i ; } if ( internal End < num Sequences [ i ] ) { end File No = i ; break ; } } } final long start Lower = start File No == NUM ? NUM : num Sequences [ start File No - NUM ] ; final long end Lower = end File No < NUM ? NUM : num Sequences [ end File No - NUM ] ; int seq No = NUM ; for ( int i = start File No ; ( end File No == - NUM || i <= end File No ) && i < num Sequences . length ; i ++ ) { try ( Random Access File raf = new Random Access File ( Sdf File Utils . sequence Pointer File ( m Directory , i ) , STRING ) ) { final long pos ; if ( i == start File No ) { pos = ( internal Start - start Lower ) * entry Size ; raf . seek ( pos ) ; } else { pos = NUM ; } final long end Pos = end File No == i ? ( internal End - end Lower ) * entry Size : raf . length ( ) ; seq No = sequence Lengths Helper ( raf , buffer , ret , seq No , pos , end Pos , entry Size ) ; if ( end File No != i && seq No > NUM ) { final long file Length = data Index . data Size ( i ) ; ret [ seq No - NUM ] = ret [ seq No - NUM ] - ( int ) file Length ; } else { if ( seq No != ret . length ) { throw new Corrupt Sdf Exception ( STRING + ret . length + STRING + seq No ) ; } raf . read ( ) ; ret [ seq No - NUM ] -= raf . read Int ( ) ; } } } ret [ ret . length - NUM ] = NUM - ret [ ret . length - NUM ] ; return ret ; }
public Observable < Drive Id > create File ( Drive Folder folder , File file , String title ) { return create File ( folder , file , title , Mime Type Map . get File Extension From Url ( file . get Path ( ) ) ) ; }
public static String extract Collection From Path ( String path ) { String extracted Collection Name = null ; String path Modified = remove From End Of String ( path , SLASH ) ; String [ ] path Segments = path Modified . split ( STRING ) ; if ( path Segments . length > NUM ) { extracted Collection Name = path Segments [ path Segments . length - NUM ] ; } return extracted Collection Name ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public boolean is Private ( ) { return Modifier . is Private ( field . get Modifiers ( ) ) ; }
public static final long long Encode ( final String hash ) { int level = hash . length ( ) - NUM ; long b ; long l = NUM ; for ( char c : hash . to Char Array ( ) ) { b = ( long ) ( BASE 32 STRING . index Of ( c ) ) ; l |= ( b << ( level -- * NUM ) ) ; } return ( l << NUM ) | hash . length ( ) ; }
@ Override public void on Success ( T result ) { try { LOGGER . debug ( STRING , result ) ; queue . put ( result ) ; } catch ( Interrupted Exception e ) { LOGGER . warn ( STRING , e ) ; } }
public void handle Tbl Provider Resource Id Mapper Button Add Request ( Request Invocation Event event ) throws Model Control Exception { try { Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute ( PROPERTY ATTRIBUTE , ( Hash Map ) values ) ; SM Discovery Provider Resource Id Mapper Add View Bean vb = ( SM Discovery Provider Resource Id Mapper Add View Bean ) get View Bean ( SM Discovery Provider Resource Id Mapper Add View Bean . class ) ; remove Page Session Attribute ( SM Discovery Provider Resource Id Mapper Add View Bean . PROPERTY ATTRIBUTE ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } }
public C Open Original Function ( final C Graph Window parent , final I View Container container , final I Navi Function function ) { super ( String . format ( STRING , function . get Name ( ) ) ) ; m parent = parent ; m container = container ; m function = function ; }
public int read ( char [ ] buffer , int offset , int length ) throws IO Exception { byte [ ] bytes = new byte [ length ] ; int count = file . read ( bytes , NUM , length ) ; for ( int i = NUM ; i < count ; i ++ ) { buffer [ offset + i ] = ( char ) bytes [ i ] ; } return count ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Vector 2 f ) ) { return BOOL ; } if ( this == o ) { return BOOL ; } Vector 2 f comp = ( Vector 2 f ) o ; if ( Float . compare ( x , comp . x ) != NUM ) { return BOOL ; } if ( Float . compare ( y , comp . y ) != NUM ) { return BOOL ; } return BOOL ; }
@ Override protected E Class find Instantiable Compatible ( E Class e Type ) { if ( ! is Instantiatable Sub Type ( e Type , e Type ) ) { throw new Illegal State Exception ( String . value Of ( e Type ) ) ; } return e Type ; }
private int measure Width ( int measure Spec ) { int result = NUM ; int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; if ( spec Mode == Measure Spec . EXACTLY ) { result = spec Size ; } else { result = IMAGE WIDTH + MAX TEXT WIDTH + TOAST HEIGHT ; if ( spec Mode == Measure Spec . AT MOST ) { result = Math . min ( result , spec Size ) ; } } return result ; }
public void restore Topology ( Iterable < Tcp Discovery Node > nodes , long top Ver ) { assert ! F . is Empty ( nodes ) ; assert top Ver > NUM ; rw Lock . write Lock ( ) . lock ( ) ; try { loc Node . internal Order ( top Ver ) ; clear ( ) ; boolean first Add = BOOL ; for ( Tcp Discovery Node node : nodes ) { if ( nodes Map . contains Key ( node . id ( ) ) ) continue ; nodes Map . put ( node . id ( ) , node ) ; if ( first Add ) { this . nodes = new Tree Set < > ( this . nodes ) ; first Add = BOOL ; } node . last Update Time ( U . current Time Millis ( ) ) ; this . nodes . add ( node ) ; } node Order = top Ver ; initialize Minimum Version ( ) ; } finally { rw Lock . write Lock ( ) . unlock ( ) ; } }
final protected void start Op ( final I Start Op Message msg ) { if ( ! controller ) throw new Unsupported Operation Exception ( ERR NOT CONTROLLER ) ; if ( msg == null ) throw new Illegal Argument Exception ( ) ; if ( ! query Id . equals ( msg . get Query Id ( ) ) ) throw new Illegal Argument Exception ( ) ; lock . lock ( ) ; try { if ( log . is Trace Enabled ( ) ) log . trace ( msg . to String ( ) ) ; if ( future . is Done ( ) ) throw new Runtime Exception ( STRING ) ; run State . start Op ( msg ) ; } catch ( Timeout Exception ex ) { halt ( ex ) ; } finally { lock . unlock ( ) ; } }
public Flux < IN > drain ( ) { return Flux . empty ( ) ; }
int traverse Consistency Check ( Text Edit Processor processor , Document document , List < List < Text Edit > > source Edits ) { int result = NUM ; if ( f Children != null ) { for ( int i = f Children . size ( ) - NUM ; i >= NUM ; i -- ) { Text Edit child = ( Text Edit ) f Children . get ( i ) ; result = Math . max ( result , child . traverse Consistency Check ( processor , document , source Edits ) ) ; } } if ( processor . consider Edit ( this ) ) { perform Consistency Check ( processor , document ) ; } return result ; }
public Minute ( Date time , Time Zone zone ) { this ( time , zone , Locale . get Default ( ) ) ; }
private Plan build Plan 1 ( ) { Plan plan = Population Utils . create Plan ( ) ; Activity a = Population Utils . create Activity From Coord ( STRING , Coord Utils . create Coord ( NUM , NUM ) ) ; a . set End Time ( Time . parse Time ( STRING ) ) ; plan . add Activity ( a ) ; plan . add Leg ( Population Utils . create Leg ( STRING ) ) ; double travel Time = Time . parse Time ( STRING ) ; double distance = Math . round ( ( travel Time * Chain Chopper . AVERAGE SPEED ) / Chain Chopper . CROWFLY FACTOR ) ; Activity b = Population Utils . create Activity From Coord ( STRING , Coord Utils . create Coord ( distance , NUM ) ) ; plan . add Activity ( b ) ; return plan ; }
protected void encode Atom ( Output Stream out Stream , byte data [ ] , int offset , int len ) throws IO Exception { byte a , b = NUM , c = NUM ; int c1 , c2 , c3 , c4 ; a = data [ offset ] ; if ( len > NUM ) { b = data [ offset + NUM ] ; } if ( len > NUM ) { c = data [ offset + NUM ] ; } c1 = ( a > > > NUM ) & NUM ; c2 = ( ( a << NUM ) & NUM ) | ( ( b > > > NUM ) & NUM ) ; c3 = ( ( b << NUM ) & NUM ) | ( ( c > > > NUM ) & NUM ) ; c4 = c & NUM ; out Stream . write ( c1 + STRING ) ; out Stream . write ( c2 + STRING ) ; out Stream . write ( c3 + STRING ) ; out Stream . write ( c4 + STRING ) ; return ; }
public void test unwrap Byte Buffer Byte Buffer 05 ( ) { String host = STRING ; int port = NUM ; Byte Buffer bbs = Byte Buffer . allocate ( NUM ) ; Byte Buffer bbd = Byte Buffer . allocate ( NUM ) ; SSL Engine sse = get Engine ( host , port ) ; sse . set Use Client Mode ( BOOL ) ; try { SSL Engine Result res = sse . unwrap ( bbs , bbd ) ; assert Equals ( NUM , res . bytes Consumed ( ) ) ; assert Equals ( NUM , res . bytes Produced ( ) ) ; } catch ( Exception e ) { fail ( STRING + e ) ; } }
private int adjust Alpha ( int color , float factor ) { int alpha = Math . round ( Color . alpha ( color ) * factor ) ; int red = Color . red ( color ) ; int green = Color . green ( color ) ; int blue = Color . blue ( color ) ; return Color . argb ( alpha , red , green , blue ) ; }
private void initialize Ratio Slider ( ) { ratio Slider . set Major Tick Spacing ( NUM ) ; ratio Slider . set Minor Tick Spacing ( NUM ) ; ratio Slider . set Paint Ticks ( BOOL ) ; Hashtable < Integer , J Label > label Table = new Hashtable < Integer , J Label > ( ) ; label Table . put ( new Integer ( NUM ) , new J Label ( STRING ) ) ; label Table . put ( new Integer ( NUM ) , new J Label ( STRING ) ) ; label Table . put ( new Integer ( NUM ) , new J Label ( STRING ) ) ; label Table . put ( new Integer ( NUM ) , new J Label ( STRING ) ) ; label Table . put ( new Integer ( NUM ) , new J Label ( STRING ) ) ; ratio Slider . set Label Table ( label Table ) ; ratio Slider . set Paint Labels ( BOOL ) ; }
private static void initialize Settings ( Settings . Builder output , Settings input , boolean load Defaults ) { output . put ( input ) ; if ( use System Properties ( input ) ) { if ( load Defaults ) { for ( String prefix : PROPERTY DEFAULTS PREFIXES ) { output . put Properties ( prefix , System . get Properties ( ) ) ; } } for ( String prefix : PROPERTY PREFIXES ) { output . put Properties ( prefix , System . get Properties ( ) , PROPERTY DEFAULTS PREFIXES ) ; } } output . replace Property Placeholders ( ) ; }
@ Override public void draw Oval ( int x , int y , int width , int height ) { set State To Local ( ) ; m printstream . println ( x Transform ( x Scale ( x ) ) + STRING + y Transform ( y Scale ( y ) ) + STRING + x Scale ( width ) + STRING + y Scale ( height ) + STRING ) ; }
public String to String ( int indent Factor ) throws JSON Exception { return to String ( indent Factor , NUM ) ; }
private void validate SQL Fields ( ) { boolean flag = controller . is Enable SQL Database Output ( ) ; enable SQL Database Connection . set Selected ( flag ) ; sql Host Label . set Enabled ( flag ) ; sql Host Field . set Enabled ( flag ) ; sql Database Label . set Enabled ( flag ) ; sql Database Field . set Enabled ( flag ) ; sql User Label . set Enabled ( flag ) ; sql User Field . set Enabled ( flag ) ; sql Password Label . set Enabled ( flag ) ; sql Password Field . set Enabled ( flag ) ; enable Zip Encoding Check Box . set Enabled ( flag ) ; }
public void read From Object ( Object object ) { try { Method method = Bean Utils . get Read Method ( object . get Class ( ) , get Name ( ) ) ; if ( method != null ) { Object value = method . invoke ( object , null ) ; initialize Value ( value ) ; if ( value != null ) { for ( Iterator iter = sub Properties . iterator ( ) ; iter . has Next ( ) ; ) { Property sub Property = ( Property ) iter . next ( ) ; sub Property . read From Object ( value ) ; } } } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
private boolean internal Offer Task ( A Frame Task task ) { synchronized ( m Frame Task Queue ) { return m Frame Task Queue . offer ( task ) ; } }
public void start DTD ( String name , String public Id , String system Id ) throws org . xml . sax . SAX Exception { }
public static String to String ( Byte Buffer bb ) { byte [ ] bytes = new byte [ bb . get Int ( ) ] ; String s = STRING ; try { if ( Array Utils . is Not Empty ( bytes ) ) { bb . get ( bytes ) ; s = new String ( bytes , UTF 8 ) ; } } catch ( Exception e ) { throw new Runtime Exception ( STRING + STRING , e ) ; } return s ; }
public static boolean valid Image ( Image image ) { return ( image != null && image . get Width ( null ) > NUM && image . get Height ( null ) > NUM ) ; }
protected void ping ( Inet Address address ) throws Exception { Socket socket = null ; int ping = NUM ; for ( ; ; ) { if ( is Debug ( ) ) { log ( STRING + ping + STRING + get Max Pings ( ) + STRING + address + STRING + get Port ( ) ) ; } try { socket = new Socket ( address , get Port ( ) ) ; break ; } catch ( Connect Exception ce ) { log ( STRING + ping + STRING + get Max Pings ( ) + STRING + ce . to String ( ) + STRING + address + STRING + get Port ( ) ) ; ping ++ ; if ( ping <= get Max Pings ( ) ) { log ( STRING + get Ping Interval Milli ( ) + STRING ) ; Thread . sleep ( get Ping Interval Milli ( ) ) ; } else { break ; } } } if ( socket == null ) { throw new Connect Exception ( STRING + get Max Pings ( ) + STRING ) ; } try { Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( socket . get Input Stream ( ) , STRING ) ) ; Print Writer writer = new Print Writer ( new Buffered Writer ( new Output Stream Writer ( socket . get Output Stream ( ) ) ) , BOOL ) ; log ( STRING + address + STRING ) ; writer . println ( STRING ) ; writer . flush ( ) ; boolean pong Received = BOOL ; for ( ; ; ) { String answer = reader . read Line ( ) ; if ( answer != null ) { answer = answer . trim ( ) ; log ( STRING + answer + STRING ) ; answer = answer . trim ( ) ; if ( answer . equals ( STRING ) ) { pong Received = BOOL ; } } else { break ; } } reader . close ( ) ; writer . close ( ) ; if ( ! pong Received ) { throw new Connect Exception ( STRING ) ; } } finally { socket . close ( ) ; } }
private Image Size compute Size To Fit ( float max Side ) { if ( NUM == max Side ) { return new Image Size ( NUM , NUM ) ; } Image Size resized = new Image Size ( this ) ; if ( ( this . m Width > max Side ) || ( this . m Height > max Side ) ) { double ratio X = max Side / this . m Width ; double ratio Y = max Side / this . m Height ; double scale = Math . min ( ratio X , ratio Y ) ; scale = NUM / Integer . highest One Bit ( ( int ) Math . floor ( NUM / scale ) ) ; resized . m Width = ( int ) ( Math . floor ( resized . m Width * scale / NUM ) * NUM ) ; resized . m Height = ( int ) ( Math . floor ( resized . m Height * scale / NUM ) * NUM ) ; } return resized ; }
public static List < Big Integer > embedded Selector To Partitions ( String selector , String type , Data Partitioner partitioner ) throws PIR Exception { List < Big Integer > parts ; int partition Bits = partitioner . get Bits ( type ) ; if ( partition Bits > NUM ) { int hashed Selector = Keyed Hash . hash ( STRING , NUM , selector , STRING ) ; parts = partitioner . to Partitions ( hashed Selector , Primitive Type Partitioner . INT ) ; } else { parts = partitioner . to Partitions ( selector , type ) ; } return parts ; }
public static double stddevp ( double [ ] a , int lo , int hi ) { return Math . sqrt ( varp ( a , lo , hi ) ) ; }
public void maybe Look Ahead Scripts ( ) { }
public Java 2 Type Script Translator ( Transpilation Handler log Handler , J Sweet Context context , JC Compilation Unit compilation Unit , boolean preserve Source Line Numbers ) { super ( log Handler , context , compilation Unit , new Java 2 Type Script Adapter ( context ) , preserve Source Line Numbers ) ; }
@ Override protected void on Measure ( int width Measure Spec , int height Measure Spec ) { int count = get Child Count ( ) ; m Left Width = NUM ; m Right Width = NUM ; int max Height = NUM ; int max Width = NUM ; int child State = NUM ; for ( int i = NUM ; i < count ; i ++ ) { final View child = get Child At ( i ) ; if ( child . get Visibility ( ) != GONE ) { measure Child With Margins ( child , width Measure Spec , NUM , height Measure Spec , NUM ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . position == Layout Params . POSITION LEFT ) { m Left Width += Math . max ( max Width , child . get Measured Width ( ) + lp . left Margin + lp . right Margin ) ; } else if ( lp . position == Layout Params . POSITION RIGHT ) { m Right Width += Math . max ( max Width , child . get Measured Width ( ) + lp . left Margin + lp . right Margin ) ; } else { max Width = Math . max ( max Width , child . get Measured Width ( ) + lp . left Margin + lp . right Margin ) ; } max Height = Math . max ( max Height , child . get Measured Height ( ) + lp . top Margin + lp . bottom Margin ) ; child State = combine Measured States ( child State , child . get Measured State ( ) ) ; } } max Width += m Left Width + m Right Width ; max Height = Math . max ( max Height , get Suggested Minimum Height ( ) ) ; max Width = Math . max ( max Width , get Suggested Minimum Width ( ) ) ; set Measured Dimension ( resolve Size And State ( max Width , width Measure Spec , child State ) , resolve Size And State ( max Height , height Measure Spec , child State << MEASURED HEIGHT STATE SHIFT ) ) ; }
protected int exec ( String command , String List args ) { try { print ( command ) ; String List cmd = new String List ( ) ; cmd = cmd . plus ( command ) ; if ( args != null ) { for ( String a : args ) { print ( STRING + a ) ; } cmd . add All ( args ) ; } println ( STRING ) ; Process Builder pb = new Process Builder ( ) ; pb . command ( cmd . array ( ) ) ; pb . redirect Error Stream ( BOOL ) ; Process p = pb . start ( ) ; copy In Thread ( p . get Input Stream ( ) , quiet ? null : sys Out ) ; p . wait For ( ) ; return p . exit Value ( ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
@ Ignore @ Test public void test Gateway Sender Event Listener Invocation Without Locator ( ) { int m Port = Available Port Helper . get Random Available Port For D Unit Site ( ) ; vm 4 . invoke ( null ) ; vm 5 . invoke ( null ) ; vm 6 . invoke ( null ) ; vm 7 . invoke ( null ) ; vm 4 . invoke ( null ) ; vm 5 . invoke ( null ) ; start Sender In V Ms ( STRING , vm 4 , vm 5 ) ; vm 4 . invoke ( null ) ; vm 5 . invoke ( null ) ; vm 6 . invoke ( null ) ; vm 7 . invoke ( null ) ; final Map key Values = new Hash Map ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { key Values . put ( i , i ) ; } vm 4 . invoke ( null ) ; vm 4 . invoke ( null ) ; vm 5 . invoke ( null ) ; vm 4 . invoke ( null ) ; vm 5 . invoke ( null ) ; fail ( STRING ) ; }
protected Application User build User ( Map < String , String > header Map , boolean include Roles ) { LOGGER . debug ( STRING ) ; Map < String , String > header Names = get Header Names ( ) ; Application User application User = create New Application User ( ) ; build User Id ( application User , header Map , header Names . get ( HTTP HEADER USER ID ) ) ; build First Name ( application User , header Map , header Names . get ( HTTP HEADER FIRST NAME ) ) ; build Last Name ( application User , header Map , header Names . get ( HTTP HEADER LAST NAME ) ) ; build Email ( application User , header Map , header Names . get ( HTTP HEADER EMAIL ) ) ; build Session Id ( application User , header Map , HTTP HEADER SESSION ID ) ; build Session Init Time ( application User , header Map , header Names . get ( HTTP HEADER SESSION INIT TIME ) ) ; user Namespace Authorization Helper . build Namespace Authorizations ( application User ) ; if ( include Roles ) { build Roles ( application User , header Map , header Names . get ( HTTP HEADER ROLES ) ) ; } LOGGER . debug ( STRING + application User ) ; return application User ; }
@ Interruptible public static void harness End ( ) { Stats . stop All ( ) ; inside Harness = BOOL ; }
private Cluster < Subspace Model > run Fast DOC ( Database database , Relation < V > relation , Array Modifiable DBI Ds S , int d , int n , int m , int r ) { long [ ] D = null ; DBID Var dV = DBID Util . new Var ( ) ; Finite Progress iprogress = LOG . is Verbose ( ) ? new Finite Progress ( STRING , m * n , LOG ) : null ; Random random = rnd . get Single Threaded Random ( ) ; DBID Array Iter iter = S . iter ( ) ; outer : for ( int i = NUM ; i < n ; ++ i ) { iter . seek ( random . next Int ( S . size ( ) ) ) ; for ( int j = NUM ; j < m ; ++ j ) { DBI Ds random Set = DBID Util . random Sample ( S , r , random ) ; long [ ] nD = Bits Util . zero ( d ) ; for ( int k = NUM ; k < d ; ++ k ) { if ( dimension Is Relevant ( k , relation , random Set ) ) { Bits Util . set I ( nD , k ) ; } } if ( D == null || Bits Util . cardinality ( nD ) > Bits Util . cardinality ( D ) ) { D = nD ; dV . set ( iter ) ; if ( Bits Util . cardinality ( D ) >= d zero ) { if ( iprogress != null ) { iprogress . set Processed ( iprogress . get Total ( ) , LOG ) ; } break outer ; } } LOG . increment Processed ( iprogress ) ; } } LOG . ensure Completed ( iprogress ) ; if ( D == null || Bits Util . cardinality ( D ) == NUM ) { return null ; } Subspace Maximum Distance Function df = new Subspace Maximum Distance Function ( D ) ; Distance Query < V > dq = database . get Distance Query ( relation , df ) ; Range Query < V > rq = database . get Range Query ( dq , Database Query . HINT SINGLE ) ; DBI Ds C = DBID Util . intersection ( S , rq . get Range For DBID ( dV , w ) ) ; return ( C . size ( ) > NUM ) ? make Cluster ( relation , C , D ) : null ; }
public Race GUI ( String app Name ) { UI Manager . put ( STRING , Boolean . FALSE ) ; J Frame f = new J Frame ( app Name ) ; f . set Default Close Operation ( J Frame . EXIT ON CLOSE ) ; f . set Layout ( new Border Layout ( ) ) ; track = new Track View ( ) ; f . add ( track , Border Layout . CENTER ) ; control Panel = new Race Control Panel ( ) ; f . add ( control Panel , Border Layout . SOUTH ) ; f . pack ( ) ; f . set Visible ( BOOL ) ; }
public static Iterable < String > to Hex Strings ( Iterable < Byte Array > arrays ) { Array List < String > ret = new Array List < String > ( ) ; for ( Byte Array array : arrays ) ret . add ( Hex String . to Hex String ( array . get ( ) ) ) ; return ret ; }
public static List < Geo Time Serie > partition And Apply ( Object function , Warp Script Stack stack , Macro validator , Collection < String > bylabels , List < Geo Time Serie > ... series ) throws Warp Script Exception { Map < Map < String , String > , List < Geo Time Serie > > unflattened = partition And Apply Unflattened ( function , stack , validator , bylabels , series ) ; List < Geo Time Serie > results = new Array List < Geo Time Serie > ( ) ; for ( List < Geo Time Serie > l : unflattened . values ( ) ) { results . add All ( l ) ; } return results ; }
final Work Queue register Worker ( Fork Join Worker Thread wt ) { Thread . Uncaught Exception Handler handler ; Work Queue [ ] ws ; int s , ps ; wt . set Daemon ( BOOL ) ; if ( ( handler = ueh ) != null ) wt . set Uncaught Exception Handler ( handler ) ; do { } while ( ! U . compare And Swap Int ( this , INDEXSEED , s = index Seed , s += SEED INCREMENT ) || s == NUM ) ; Work Queue w = new Work Queue ( this , wt , config > > > NUM , s ) ; if ( ( ( ps = plock ) & PL LOCK ) != NUM || ! U . compare And Swap Int ( this , PLOCK , ps , ps += PL LOCK ) ) ps = acquire Plock ( ) ; int nps = ( ps & SHUTDOWN ) | ( ( ps + PL LOCK ) & ~ SHUTDOWN ) ; try { if ( ( ws = work Queues ) != null ) { int n = ws . length , m = n - NUM ; int r = ( s << NUM ) | NUM ; if ( ws [ r &= m ] != null ) { int probes = NUM ; int step = ( n <= NUM ) ? NUM : ( ( n > > > NUM ) & EVENMASK ) + NUM ; while ( ws [ r = ( r + step ) & m ] != null ) { if ( ++ probes >= n ) { work Queues = ws = Arrays . copy Of ( ws , n <<= NUM ) ; m = n - NUM ; probes = NUM ; } } } w . event Count = w . pool Index = r ; ws [ r ] = w ; } } finally { if ( ! U . compare And Swap Int ( this , PLOCK , ps , nps ) ) release Plock ( nps ) ; } wt . set Name ( worker Name Prefix . concat ( Integer . to String ( w . pool Index ) ) ) ; return w ; }
public void clear ( ) { documents . clear ( ) ; fire MRU List Changed ( ) ; }
public boolean is Directly Control Dependent On ( Basic Block ins Block , Branch b ) { Set < Control Flow Edge > incomming = incoming Edges Of ( ins Block ) ; if ( incomming . size ( ) == NUM ) { for ( Control Flow Edge e : incomming ) { if ( ! e . has Control Dependency ( ) && ! e . is Exception Edge ( ) ) { return is Directly Control Dependent On ( get Edge Source ( e ) , b ) ; } } } boolean is Root Dependent = is Root Dependent ( ins Block ) ; if ( b == null ) return is Root Dependent ; if ( is Root Dependent && b != null ) return BOOL ; for ( Control Flow Edge e : incomming ) { Branch current = e . get Branch Instruction ( ) ; if ( e . is Exception Edge ( ) ) { if ( current != null ) throw new Illegal State Exception ( STRING ) ; else continue ; } if ( current == null ) continue ; if ( current . equals ( b ) ) return BOOL ; } return BOOL ; }
final boolean try Read Lock ( ) { Thread current = Thread . current Thread ( ) ; for ( ; ; ) { int c = get State ( ) ; if ( exclusive Count ( c ) != NUM && get Exclusive Owner Thread ( ) != current ) return BOOL ; int r = shared Count ( c ) ; if ( r == MAX COUNT ) throw new Error ( STRING ) ; if ( compare And Set State ( c , c + SHARED UNIT ) ) { if ( r == NUM ) { first Reader = current ; first Reader Hold Count = NUM ; } else if ( first Reader == current ) { first Reader Hold Count ++ ; } else { Hold Counter rh = cached Hold Counter ; if ( rh == null || rh . tid != current . get Id ( ) ) cached Hold Counter = rh = read Holds . get ( ) ; else if ( rh . count == NUM ) read Holds . set ( rh ) ; rh . count ++ ; } return BOOL ; } } }
public static String replace ( String text , String oldsub , String newsub , boolean case Insensitive , boolean first Only ) { String Builder buf ; int tln ; int oln = oldsub . length ( ) ; if ( oln == NUM ) { int nln = newsub . length ( ) ; if ( nln == NUM ) { return text ; } else { if ( first Only ) { return newsub + text ; } else { tln = text . length ( ) ; buf = new String Builder ( tln + ( tln + NUM ) * nln ) ; buf . append ( newsub ) ; for ( int i = NUM ; i < tln ; i ++ ) { buf . append ( text . char At ( i ) ) ; buf . append ( newsub ) ; } return buf . to String ( ) ; } } } else { oldsub = case Insensitive ? oldsub . to Lower Case ( ) : oldsub ; String input = case Insensitive ? text . to Lower Case ( ) : text ; int e = input . index Of ( oldsub ) ; if ( e == - NUM ) { return text ; } int b = NUM ; tln = text . length ( ) ; buf = new String Builder ( tln + Math . max ( newsub . length ( ) - oln , NUM ) * NUM ) ; do { buf . append ( text . substring ( b , e ) ) ; buf . append ( newsub ) ; b = e + oln ; e = input . index Of ( oldsub , b ) ; } while ( e != - NUM && ! first Only ) ; buf . append ( text . substring ( b ) ) ; return buf . to String ( ) ; } }
public void serialize Form Def ( Form Def fd , String filepath ) { String hash = File Utils . get Md 5 Hash ( new File ( filepath ) ) ; File form Def = new File ( Collect . CACHE PATH + File . separator + hash + STRING ) ; if ( ! form Def . exists ( ) ) { File Output Stream fos ; try { fos = new File Output Stream ( form Def ) ; Data Output Stream dos = new Data Output Stream ( fos ) ; fd . write External ( dos ) ; dos . flush ( ) ; dos . close ( ) ; } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } }
private void paint Route ( Graphics 2 D graphics , JX Map Viewer viewer , Plottable Entity entity ) { Set < Plottable > plottables = entity . get Plottables ( ) ; if ( plottables . size ( ) > NUM ) { graphics . set Color ( Color . BLACK ) ; graphics . set Stroke ( new Basic Stroke ( NUM ) ) ; draw Route ( plottables , graphics , viewer ) ; graphics . set Color ( entity . get Color ( ) ) ; graphics . set Stroke ( new Basic Stroke ( NUM ) ) ; draw Route ( plottables , graphics , viewer ) ; } }
private boolean install Reply ( String alias , Input Stream in ) throws Exception { if ( alias == null ) { alias = key Alias ; } Pair < Key , char [ ] > objs = recover Key ( alias , store Pass , key Pass ) ; Private Key priv Key = ( Private Key ) objs . fst ; if ( key Pass == null ) { key Pass = objs . snd ; } Certificate user Cert = key Store . get Certificate ( alias ) ; if ( user Cert == null ) { Message Format form = new Message Format ( rb . get String ( STRING ) ) ; Object [ ] source = { alias } ; throw new Exception ( form . format ( source ) ) ; } Collection < ? extends Certificate > c = cf . generate Certificates ( in ) ; if ( c . is Empty ( ) ) { throw new Exception ( rb . get String ( STRING ) ) ; } Certificate [ ] reply Certs = c . to Array ( new Certificate [ c . size ( ) ] ) ; Certificate [ ] new Chain ; if ( reply Certs . length == NUM ) { new Chain = establish Cert Chain ( user Cert , reply Certs [ NUM ] ) ; } else { new Chain = validate Reply ( alias , user Cert , reply Certs ) ; } if ( new Chain != null ) { key Store . set Key Entry ( alias , priv Key , ( key Pass != null ) ? key Pass : store Pass , new Chain ) ; return BOOL ; } else { return BOOL ; } }
@ Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case Eip Package . AGGREGATOR NAME : return NAME EDEFAULT == null ? name != null : ! NAME EDEFAULT . equals ( name ) ; case Eip Package . AGGREGATOR TO CHANNELS : return to Channels != null && ! to Channels . is Empty ( ) ; case Eip Package . AGGREGATOR FROM CHANNELS : return from Channels != null && ! from Channels . is Empty ( ) ; case Eip Package . AGGREGATOR PART : return part != PART EDEFAULT ; case Eip Package . AGGREGATOR STRATEGY : return STRATEGY EDEFAULT == null ? strategy != null : ! STRATEGY EDEFAULT . equals ( strategy ) ; case Eip Package . AGGREGATOR EXPRESSION : return EXPRESSION EDEFAULT == null ? expression != null : ! EXPRESSION EDEFAULT . equals ( expression ) ; } return super . e Is Set ( feature ID ) ; }
public synchronized void mouse Wheel ( int wheel Amt ) { peer . mouse Wheel ( wheel Amt ) ; after Event ( ) ; }
@ Override public int length ( ) { return data . length / ( format . get Frame Size ( ) * NUM ) ; }
public void validate ( Set set Data ) throws Validation Exception { for ( Iterator iter = set Data . iterator ( ) ; iter . has Next ( ) ; ) { perform Validation ( ( String ) iter . next ( ) ) ; } }
public static void delete Directory ( final File dir , boolean check For Links ) { if ( dir . is File ( ) ) { throw new Illegal Argument Exception ( STRING + dir . get Name ( ) + STRING ) ; } else if ( check For Links && is Link ( dir ) ) { throw new Illegal Argument Exception ( STRING + dir . get Name ( ) + STRING ) ; } if ( dir . exists ( ) ) { IO Utils . delete Dir ( dir , check For Links ) ; } else { throw new Illegal Argument Exception ( STRING + dir . get Name ( ) + STRING ) ; } }
private static Marshaller create Marshaller ( JAXB Context jaxb Context , String schema Path ) throws SAX Exception , JAXB Exception { Schema schema = Xml Parser . get Schema ( new String [ ] { schema Path } ) ; Marshaller jaxb Marshaller = jaxb Context . create Marshaller ( ) ; jaxb Marshaller . set Schema ( schema ) ; jaxb Marshaller . set Property ( Marshaller . JAXB FORMATTED OUTPUT , BOOL ) ; jaxb Marshaller . set Property ( Marshaller . JAXB ENCODING , STRING ) ; return jaxb Marshaller ; }
public static General Path cardinal Spline ( float pts [ ] , float slack , boolean closed ) { General Path path = new General Path ( ) ; path . move To ( pts [ NUM ] , pts [ NUM ] ) ; return cardinal Spline ( path , pts , slack , closed , NUM , NUM ) ; }
public static String make Method Safe ( final String S ) { String name = make HTML Name Safe ( S ) ; name = name . replace ( STRING , STRING ) ; return name ; }
public Builder add Listen Url ( String url ) { if ( Url Util . is Url ( url ) ) { if ( m Listen Urls == null ) { m Listen Urls = new Hash Set < String > ( ) ; } m Listen Urls . add ( url ) ; } return this ; }
private void expand ( int i ) { if ( count + i <= buf . length ) { return ; } byte [ ] newbuf = m Pool . get Buf ( ( count + i ) * NUM ) ; System . arraycopy ( buf , NUM , newbuf , NUM , count ) ; m Pool . return Buf ( buf ) ; buf = newbuf ; }
public void remove ( Production production ) { productions . remove ( production ) ; }
private void write Delay ( ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { fail ( STRING ) ; } }
public static void main ( String [ ] argv ) { Arg Parser ap = new Arg Parser ( STRING ) ; ap . add ( STRING , STRING , NUM ) ; if ( argv . length < NUM ) { ap . bail ( STRING , BOOL ) ; } ap . parse ( argv ) ; String [ ] files = ap . get Arg Values ( STRING ) ; if ( files != null && files [ NUM ] != null ) { String shp = files [ NUM ] ; String dbf = null ; try { dbf = shp . substring ( NUM , shp . last Index Of ( STRING ) + NUM ) + PARAM DBF ; Dbf Table Model model = Dbf Table Model . get Dbf Table Model ( Prop Utils . get Resource Or File Or URL ( dbf ) ) ; Esri Graphic List list = Esri Graphic List . get Esri Graphic List ( Prop Utils . get Resource Or File Or URL ( shp ) , null , null ) ; logger . info ( list . get Description ( ) ) ; Esri Shape Export ese = new Esri Shape Export ( list , model , null ) ; ese . export ( ) ; } catch ( Malformed URL Exception murle ) { logger . warning ( STRING + murle . get Message ( ) ) ; } catch ( Null Pointer Exception npe ) { logger . warning ( STRING ) ; } catch ( Exception exception ) { logger . warning ( STRING + exception . get Message ( ) ) ; exception . print Stack Trace ( ) ; } } else { ap . bail ( STRING , BOOL ) ; } System . exit ( NUM ) ; }
public Partial Hull ( I Point first , I Point second ) { points . add ( first ) ; points . add ( second ) ; }
public void test Max Greater ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . max ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert True ( STRING , result . signum ( ) == NUM ) ; }
public static Sorted Set < Interval > find Full Availability Gaps ( Set < Interval > available Intervals , Set < Interval > needed Intervals ) { Comparator < Interval > interval Start Comparator = new Interval Start Comparator ( ) ; Sorted Set < Interval > sorted Available Intervals = new Tree Set < > ( interval Start Comparator ) ; sorted Available Intervals . add All ( available Intervals ) ; Sorted Set < Interval > sorted Needed Intervals = new Tree Set < > ( interval Start Comparator ) ; sorted Needed Intervals . add All ( needed Intervals ) ; Iterator < Interval > available Intervals Iterator = sorted Available Intervals . iterator ( ) ; if ( ! available Intervals Iterator . has Next ( ) ) { return sorted Needed Intervals ; } Interval available = available Intervals Iterator . next ( ) ; Sorted Set < Interval > missing Intervals = new Tree Set < > ( interval Start Comparator ) ; for ( Interval needed : sorted Needed Intervals ) { while ( ! can Determine Availability ( available , needed ) && available Intervals Iterator . has Next ( ) ) { available = available Intervals Iterator . next ( ) ; } if ( available . contains ( needed ) ) { continue ; } missing Intervals . add ( needed ) ; } return missing Intervals ; }
public static List < String > split ( String str , String delim ) { List < String > split List = null ; String Tokenizer st = null ; if ( str == null ) return split List ; if ( delim != null ) st = new String Tokenizer ( str , delim ) ; else st = new String Tokenizer ( str ) ; if ( st != null && st . has More Tokens ( ) ) { split List = new Linked List < String > ( ) ; while ( st . has More Tokens ( ) ) split List . add ( st . next Token ( ) ) ; } return split List ; }
public void write Exif ( String jpeg File Name , String exif Out File Name ) throws File Not Found Exception , IO Exception { if ( jpeg File Name == null || exif Out File Name == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Input Stream is = null ; is = new File Input Stream ( jpeg File Name ) ; write Exif ( is , exif Out File Name ) ; is . close ( ) ; }
public boolean is Gen Class ( Soot Class clz ) { return gen Classes . contains ( clz . get Name ( ) ) ; }
public boolean has Extra Still Image ( ) { return is Apng ( ) && ! firs Idat Apng Frame ; }
private void read Response Headers ( State state , Inner State inner State , Http Response response ) throws Stop Request { Header header = response . get First Header ( STRING ) ; if ( header != null ) { inner State . m Header Content Disposition = header . get Value ( ) ; } header = response . get First Header ( STRING ) ; if ( header != null ) { inner State . m Header Content Location = header . get Value ( ) ; } header = response . get First Header ( STRING ) ; if ( header != null ) { inner State . m Header E Tag = header . get Value ( ) ; } String header Transfer Encoding = null ; header = response . get First Header ( STRING ) ; if ( header != null ) { header Transfer Encoding = header . get Value ( ) ; } String header Content Type = null ; header = response . get First Header ( STRING ) ; if ( header != null ) { header Content Type = header . get Value ( ) ; if ( ! header Content Type . equals ( STRING ) ) { throw new Stop Request ( Downloader Service . STATUS FILE DELIVERED INCORRECTLY , STRING ) ; } } if ( header Transfer Encoding == null ) { header = response . get First Header ( STRING ) ; if ( header != null ) { inner State . m Header Content Length = header . get Value ( ) ; long content Length = Long . parse Long ( inner State . m Header Content Length ) ; if ( content Length != - NUM && content Length != m Info . m Total Bytes ) { Log . e ( Constants . TAG , STRING ) ; } } } else { if ( Constants . LOGVV ) { Log . v ( Constants . TAG , STRING ) ; } } if ( Constants . LOGVV ) { Log . v ( Constants . TAG , STRING + inner State . m Header Content Disposition ) ; Log . v ( Constants . TAG , STRING + inner State . m Header Content Length ) ; Log . v ( Constants . TAG , STRING + inner State . m Header Content Location ) ; Log . v ( Constants . TAG , STRING + inner State . m Header E Tag ) ; Log . v ( Constants . TAG , STRING + header Transfer Encoding ) ; } boolean no Size Info = inner State . m Header Content Length == null && ( header Transfer Encoding == null || ! header Transfer Encoding . equals Ignore Case ( STRING ) ) ; if ( no Size Info ) { throw new Stop Request ( Downloader Service . STATUS HTTP DATA ERROR , STRING ) ; } }
public void remove Change Listener ( final PT Property Change Listener listener ) { change Listeners . remove ( listener ) ; }
public static Result Set optimize In Join Select ( ) { Simple Result Set rs = new Simple Result Set ( ) ; rs . add Column ( STRING , Types . INTEGER , NUM , NUM ) ; rs . add Row ( NUM ) ; return rs ; }
public Partition Substitution Model parse PAUP Block ( Beauti Options options , List < Char Set > char Sets ) throws Import Exception , IO Exception { Partition Substitution Model model = new Partition Substitution Model ( options , STRING ) ; read Top Level Block ( options , model , char Sets ) ; return model ; }
private void z Event Toggle Time Menu Button Mouse Pressed ( Mouse Event e ) { toggle Popup ( ) ; }
private void add Line ( Grid Field field , V Editor editor , boolean mandatory ) { log . fine ( STRING + field ) ; J Label label = V Editor Factory . get Label ( field ) ; label . set Label For ( ( Component ) editor ) ; editor . set Read Write ( BOOL ) ; editor . set Mandatory ( mandatory ) ; field . add Property Change Listener ( editor ) ; if ( m new Row ) { m gbc . gridy = m line ++ ; m gbc . gridx = NUM ; } else m gbc . gridx = NUM ; m gbc . insets = m label Insets ; m gbc . fill = Grid Bag Constraints . HORIZONTAL ; m gbc . weightx = NUM ; parameter Panel . add ( label , m gbc ) ; if ( m new Row ) m gbc . gridx = NUM ; else m gbc . gridx = NUM ; m gbc . insets = m field Insets ; m gbc . fill = Grid Bag Constraints . HORIZONTAL ; m gbc . weightx = NUM ; parameter Panel . add ( ( Component ) editor , m gbc ) ; m new Row = ! m new Row ; }
protected Object lazily Load Desktop Property ( String name ) { return null ; }
@ edu . umd . cs . findbugs . annotations . Suppress Warnings ( value = STRING , justification = STRING ) public void init Recovered Version ( T member , Region Version Holder < T > v , boolean latest Oplog ) { Region Version Holder < T > recovered = v . clone ( ) ; if ( member == null || member . equals ( my Id ) ) { synchronized ( local Exceptions ) { if ( latest Oplog || local Version . get ( ) == NUM ) { local Exceptions = recovered ; if ( logger . is Trace Enabled ( Log Marker . RVV ) ) { logger . trace ( Log Marker . RVV , STRING , recovered . version ) ; } local Version . set ( recovered . version ) ; } } } else { Long gc Version = member To GC Version . get ( member ) ; synchronized ( member To Version ) { Region Version Holder < T > old Version = member To Version . get ( member ) ; if ( latest Oplog || old Version == null || old Version . version == NUM ) { if ( gc Version != null ) { recovered . remove Exceptions Older Than ( gc Version ) ; } member To Version . put ( member , recovered ) ; } } } }
protected void notify Click Listeners About Click ( int item ) { if ( clicking Listeners . size ( ) > NUM ) { for ( On Wheel Clicked Listener listener : clicking Listeners ) { listener . on Item Clicked ( this , item ) ; } } else { set Current Item ( item , BOOL , NUM ) ; } }
@ Override public synchronized void disconnection Notification ( String event Name , Object source ) { List < Object > listenees = m listenees . get ( event Name ) ; if ( listenees != null ) { listenees . remove ( source ) ; if ( listenees . size ( ) == NUM ) { m listenees . remove ( event Name ) ; } } if ( event Name . compare To ( STRING ) == NUM ) { stop ( ) ; } }
public void test Constructor Sign Bytes Zero Null 1 ( ) { byte a Bytes [ ] = { } ; int a Sign = - NUM ; byte r Bytes [ ] = { NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
private String replace Illegal Char ( String data , char ch , String replacement ) { int idx = NUM ; String Builder buffer = new String Builder ( data . length ( ) * NUM ) ; while ( ( data != null ) && ( idx = data . index Of ( ch ) ) != - NUM ) { buffer . append ( data . substring ( NUM , idx ) ) ; buffer . append ( replacement ) ; data = data . substring ( idx + NUM ) ; } if ( ( data != null ) && ( data . length ( ) > NUM ) ) { buffer . append ( data ) ; } return buffer . to String ( ) ; }
protected static final void adjust Module Name ( Debug Module d ) { d . name = adjust Module Name ( d . name ) ; }
public org . dom 4 j . Attribute create Attribute ( Element elem , Attribute attr ) { return factory . create Attribute ( elem , create Q Name ( attr . get Name ( ) ) , attr . get Value ( ) ) ; }
public Log Entry ( ) { index = ENTRY INDEX . get And Increment ( ) ; time = System . current Time Millis ( ) ; }
public void test Bit Length Positive 3 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; assert Equals ( NUM , a Number . bit Length ( ) ) ; }
public boolean is Signature Valid ( ) { return EC Key . verify ( Utils . double Digest ( content ) , signature , params . get Alert Signing Key ( ) ) ; }
private void validate Create Information ( Date start Time , String task Name ) { Assert . not Null ( start Time , STRING ) ; if ( task Name != null && task Name . length ( ) > this . max Task Name Size ) { throw new Illegal Argument Exception ( STRING + this . max Task Name Size + STRING ) ; } }
private static Object increment ( final Object object , final Number amount , final Json Pointer field ) throws Bad Request Exception { if ( object instanceof Long ) { return ( ( Long ) object ) + amount . long Value ( ) ; } else if ( object instanceof Integer ) { return ( ( Integer ) object ) + amount . int Value ( ) ; } else if ( object instanceof Float ) { return ( ( Float ) object ) + amount . float Value ( ) ; } else if ( object instanceof Double ) { return ( ( Double ) object ) + amount . double Value ( ) ; } else { throw new Bad Request Exception ( STRING + field + STRING ) ; } }
public static Linked Hash Set < Entity > find Entites ( Linked Hash Set < Entity > matches , Hash Set < Entity > checked , Entity entity , Predicate predicate ) { if ( ! checked . add ( entity ) ) { return matches ; } if ( predicate . matches ( entity ) ) { matches . add ( entity ) ; } for ( Ref Node ref Node : entity . get Children ( Ref Node . class ) ) { Entity e = ref Node . get Reference ( ) ; if ( e != null ) { find Entites ( matches , checked , e , predicate ) ; } } for ( To Many Node to Many Node : entity . get Children ( To Many Node . class ) ) { for ( Entity e : to Many Node . get List ( ) ) { if ( e != null ) { find Entites ( matches , checked , e , predicate ) ; } } } return matches ; }
protected OM Geometry create MGRS Rectangle ( MGRS Point mgrs Base Point , double voffset , double hoffset , double interval , Ellipsoid ellipsoid ) { double [ ] llpoints = new double [ NUM ] ; double easting = mgrs Base Point . easting + hoffset ; double northing = mgrs Base Point . northing + voffset ; int zone number = mgrs Base Point . zone number ; char zone letter = mgrs Base Point . zone letter ; Lat Lon Point llp 1 = new Lat Lon Point . Double ( ) ; llp 1 = MGRS Point . MGR Sto LL ( ellipsoid , northing , easting , zone number , zone letter , llp 1 ) ; llpoints [ NUM ] = llp 1 . get Y ( ) ; llpoints [ NUM ] = llp 1 . get X ( ) ; llpoints [ NUM ] = llp 1 . get Y ( ) ; llpoints [ NUM ] = llp 1 . get X ( ) ; MGRS Point . MGR Sto LL ( ellipsoid , northing , easting + interval , zone number , zone letter , llp 1 ) ; llpoints [ NUM ] = llp 1 . get Y ( ) ; llpoints [ NUM ] = llp 1 . get X ( ) ; MGRS Point . MGR Sto LL ( ellipsoid , northing + interval , easting + interval , zone number , zone letter , llp 1 ) ; llpoints [ NUM ] = llp 1 . get Y ( ) ; llpoints [ NUM ] = llp 1 . get X ( ) ; MGRS Point . MGR Sto LL ( ellipsoid , northing + interval , easting , zone number , zone letter , llp 1 ) ; llpoints [ NUM ] = llp 1 . get Y ( ) ; llpoints [ NUM ] = llp 1 . get X ( ) ; MGRS Point mgrs = new MGRS Point ( northing , easting , zone number , zone letter ) ; mgrs . resolve ( mgrs Base Point . get Accuracy ( ) ) ; String mgrs String = mgrs . get MGRS ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + mgrs String + STRING + mgrs . get Accuracy ( ) ) ; Polygon Geometry poly = new Polygon Geometry . LL ( llpoints , OM Graphic . DECIMAL DEGREES , ( interval <= NUM ? OM Graphic . LINETYPE STRAIGHT : OM Graphic . LINETYPE GREATCIRCLE ) ) ; poly . put Attribute ( OM Graphic . APP OBJECT , mgrs String ) ; return poly ; }
public String to XML String ( ) throws XACML Exception { return to XML String ( BOOL , BOOL ) ; }
public void add Memory Pressure Listener ( Memory Pressure Listener listener ) { m Listeners . add ( listener ) ; }
private void reset For OT ( ) { if ( bottom OT && home Score == away Score ) { game Yard Line = NUM ; game Yards Need = NUM ; game Down = NUM ; num OT ++ ; if ( ( num OT % NUM ) == NUM ) game Poss = BOOL ; else game Poss = BOOL ; game Time = - NUM ; bottom OT = BOOL ; } else if ( ! bottom OT ) { game Poss = ! game Poss ; game Yard Line = NUM ; game Yards Need = NUM ; game Down = NUM ; game Time = - NUM ; bottom OT = BOOL ; } else { playing OT = BOOL ; } }
public synchronized void start Polling ( ) { m scheduler . schedule At Fixed Rate ( m notification Poller , NUM , NUM , Time Unit . MILLISECONDS ) ; }
private void drop Proxy ( Proxy Reg reg ) { synchronized ( caches ) { Iterator iter = caches . iterator ( ) ; while ( iter . has Next ( ) ) { Lookup Cache Impl cache = ( Lookup Cache Impl ) iter . next ( ) ; cache . remove Proxy Reg ( reg ) ; } } }
public void test Update 4 ( ) { int new Value 1 = - NUM ; int new Value 2 = - NUM ; String update Query = STRING + Database Creator . TEST TABLE 1 + STRING + new Value 1 + STRING + new Value 2 + STRING ; try { int num = statement . execute Update ( update Query ) ; int expected Updated = NUM ; assert Equals ( STRING , expected Updated , num ) ; String select Query = STRING + Database Creator . TEST TABLE 1 ; Result Set result = statement . execute Query ( select Query ) ; while ( result . next ( ) ) { int id = result . get Int ( STRING ) ; } result . close ( ) ; } catch ( SQL Exception e ) { fail ( STRING + e . get Message ( ) ) ; } }
public long to Long ( ) { return m value . long Value ( ) ; }
public static void move To Directory ( File src , File dest Dir , boolean create Dest Dir ) throws IO Exception { if ( src == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( dest Dir == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ! src . exists ( ) ) { throw new File Not Found Exception ( STRING + src + STRING ) ; } if ( src . is Directory ( ) ) { move Directory To Directory ( src , dest Dir , create Dest Dir ) ; } else { move File To Directory ( src , dest Dir , create Dest Dir ) ; } }
public static int copy And Close Both ( Reader input , Writer output ) throws IO Exception { try { return copy And Close Output ( input , output ) ; } finally { input . close ( ) ; } }
protected void write Header ( ) throws IO Exception { header = new byte [ SHAPE FILE HEADER LENGTH ] ; write BE Int ( header , NUM , SHAPE FILE CODE ) ; write BE Int ( header , NUM , NUM ) ; write LE Int ( header , NUM , SHAPE FILE VERSION ) ; write LE Int ( header , NUM , SHAPE TYPE NULL ) ; write LE Double ( header , NUM , NUM ) ; write LE Double ( header , NUM , NUM ) ; write LE Double ( header , NUM , NUM ) ; write LE Double ( header , NUM , NUM ) ; raf . seek ( NUM ) ; raf . write ( header , NUM , SHAPE FILE HEADER LENGTH ) ; }
public String hash Key For Disk ( String key ) { String cache Key ; try { final Message Digest m Digest = Message Digest . get Instance ( STRING ) ; m Digest . update ( key . get Bytes ( ) ) ; cache Key = bytes To Hex String ( m Digest . digest ( ) ) ; } catch ( No Such Algorithm Exception e ) { cache Key = String . value Of ( key . hash Code ( ) ) ; } return cache Key ; }
private Favorite pack Favorite ( Cursor c ) { Favorite favorite = new Favorite ( ) ; favorite . id = c . get Long ( ID INDEX ) ; favorite . screen = c . get Int ( SCREEN INDEX ) ; favorite . container = c . get Int ( CONTAINER INDEX ) ; favorite . cell X = c . get Int ( CELLX INDEX ) ; favorite . cell Y = c . get Int ( CELLY INDEX ) ; favorite . span X = c . get Int ( SPANX INDEX ) ; favorite . span Y = c . get Int ( SPANY INDEX ) ; favorite . icon Type = c . get Int ( ICON TYPE INDEX ) ; if ( favorite . icon Type == Favorites . ICON TYPE RESOURCE ) { String icon Package = c . get String ( ICON PACKAGE INDEX ) ; if ( ! Text Utils . is Empty ( icon Package ) ) { favorite . icon Package = icon Package ; } String icon Resource = c . get String ( ICON RESOURCE INDEX ) ; if ( ! Text Utils . is Empty ( icon Resource ) ) { favorite . icon Resource = icon Resource ; } } if ( favorite . icon Type == Favorites . ICON TYPE BITMAP ) { byte [ ] blob = c . get Blob ( ICON INDEX ) ; if ( blob != null && blob . length > NUM ) { favorite . icon = blob ; } } String title = c . get String ( TITLE INDEX ) ; if ( ! Text Utils . is Empty ( title ) ) { favorite . title = title ; } String intent Description = c . get String ( INTENT INDEX ) ; if ( ! Text Utils . is Empty ( intent Description ) ) { try { Intent intent = Intent . parse Uri ( intent Description , NUM ) ; intent . remove Extra ( Item Info . EXTRA PROFILE ) ; favorite . intent = intent . to Uri ( NUM ) ; } catch ( URI Syntax Exception e ) { Log . e ( TAG , STRING , e ) ; } } favorite . item Type = c . get Int ( ITEM TYPE INDEX ) ; if ( favorite . item Type == Favorites . ITEM TYPE APPWIDGET ) { favorite . app Widget Id = c . get Int ( APPWIDGET ID INDEX ) ; String app Widget Provider = c . get String ( APPWIDGET PROVIDER INDEX ) ; if ( ! Text Utils . is Empty ( app Widget Provider ) ) { favorite . app Widget Provider = app Widget Provider ; } } return favorite ; }
public static void unregister ( SPIN Thread Functions old ) { if ( old != null ) { local Functions . set ( old ) ; } else { local Functions . remove ( ) ; } }
public static boolean load Properties ( Properties properties , Input Stream props In ) { try { properties . load ( props In ) ; return BOOL ; } catch ( java . io . IO Exception e ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . warning ( STRING ) ; } return BOOL ; } }
public Complex sin ( ) { return new Complex ( Math . sin ( re ) * Math . cosh ( im ) , Math . cos ( re ) * Math . sinh ( im ) ) ; }
@ On Click ( R . id . dismiss button ) public void on Dismiss Click ( View view ) { if ( System Clock . elapsed Realtime ( ) - m Last Click Time < NUM ) { return ; } m Last Click Time = System Clock . elapsed Realtime ( ) ; dismiss Offer ( get Adapter Position ( ) ) ; if ( snackbar != null ) { snackbar . dismiss ( ) ; } }
public Table find Table ( String name ) { return find Table ( name , BOOL ) ; }
public static void append String ( final String Buffer buf , final String s ) { buf . append ( STRING ) ; for ( int i = NUM ; i < s . length ( ) ; ++ i ) { char c = s . char At ( i ) ; if ( c == STRING ) { buf . append ( STRING ) ; } else if ( c == STRING ) { buf . append ( STRING ) ; } else if ( c == STRING ) { buf . append ( STRING ) ; } else if ( c == STRING ) { buf . append ( STRING ) ; } else if ( c < NUM || c > NUM ) { buf . append ( STRING ) ; if ( c < NUM ) { buf . append ( STRING ) ; } else if ( c < NUM ) { buf . append ( STRING ) ; } else if ( c < NUM ) { buf . append ( STRING ) ; } buf . append ( Integer . to String ( c , NUM ) ) ; } else { buf . append ( c ) ; } } buf . append ( STRING ) ; }
public void draw ( final Graphics g , final int height , final int width ) { int constant Dim ; int changing Dim ; if ( orientation == X AXIS ) { changing Dim = width ; constant Dim = height ; } else { changing Dim = height ; constant Dim = width ; } int dim Step ; if ( fixed Steps ) { dim Step = changing Dim / STEPS ; } else { dim Step = NUM ; STEPS = changing Dim / dim Step ; } float red = red T ; float green = green T ; float blue = blue T ; int offset = NUM ; for ( int i = NUM ; i < STEPS ; i ++ ) { Color c = new Color ( round ( red ) , round ( green ) , round ( blue ) ) ; g . set Color ( c ) ; draw Rect ( g , offset , constant Dim , dim Step ) ; offset += dim Step ; float value = shader . get Value ( ( float ) i / ( float ) STEPS ) ; red = red T + ( red B - red T ) * value ; green = green T + ( green B - green T ) * value ; blue = blue T + ( blue B - blue T ) * value ; } Color c = new Color ( round ( red ) , round ( green ) , round ( blue ) ) ; g . set Color ( c ) ; draw Rect ( g , offset , constant Dim , changing Dim - offset ) ; }
public static double [ ] convex Hull ( double [ ] pts , int len , float [ ] angles , int [ ] idx , int [ ] stack ) { int plen = len / NUM - NUM ; if ( len < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( angles . length < plen || idx . length < plen || stack . length < len / NUM ) { throw new Illegal Argument Exception ( STRING ) ; } int i0 = NUM ; for ( int i = NUM ; i < len ; i += NUM ) { if ( pts [ i + NUM ] < pts [ i0 + NUM ] ) { i0 = i ; } else if ( pts [ i + NUM ] == pts [ i0 + NUM ] ) { i0 = ( pts [ i ] < pts [ i0 ] ? i : i0 ) ; } } for ( int i = NUM , j = NUM ; i < len ; i += NUM ) { if ( i == i0 ) continue ; angles [ j ] = ( float ) Math . atan 2 ( pts [ i + NUM ] - pts [ i0 + NUM ] , pts [ i ] - pts [ i0 ] ) ; idx [ j ++ ] = i ; } Array Lib . sort ( angles , idx , plen ) ; float angle = angles [ NUM ] ; int ti = NUM , tj = idx [ NUM ] ; for ( int i = NUM ; i < plen ; i ++ ) { int j = idx [ i ] ; if ( angle == angles [ i ] ) { double x1 = pts [ tj ] - pts [ i0 ] ; double y1 = pts [ tj + NUM ] - pts [ i0 + NUM ] ; double x2 = pts [ j ] - pts [ i0 ] ; double y2 = pts [ j + NUM ] - pts [ i0 + NUM ] ; double d1 = x1 * x1 + y1 * y1 ; double d2 = x2 * x2 + y2 * y2 ; if ( d1 >= d2 ) { idx [ i ] = - NUM ; } else { idx [ ti ] = - NUM ; angle = angles [ i ] ; ti = i ; tj = j ; } } else { angle = angles [ i ] ; ti = i ; tj = j ; } } int sp = NUM ; stack [ sp ++ ] = i0 ; int j = NUM ; for ( int k = NUM ; k < NUM ; j ++ ) { if ( idx [ j ] != - NUM ) { stack [ sp ++ ] = idx [ j ] ; k ++ ; } } for ( ; j < plen ; j ++ ) { if ( idx [ j ] == - NUM ) continue ; while ( is Non Left ( i0 , stack [ sp - NUM ] , stack [ sp - NUM ] , idx [ j ] , pts ) ) { sp -- ; } stack [ sp ++ ] = idx [ j ] ; } double [ ] hull = new double [ NUM * sp ] ; for ( int i = NUM ; i < sp ; i ++ ) { hull [ NUM * i ] = pts [ stack [ i ] ] ; hull [ NUM * i + NUM ] = pts [ stack [ i ] + NUM ] ; } return hull ; }
private void send Messages ( ) { List < Murmur Message > messages = get Messages ( NUM ) ; Murmur Message exchange Info Message = new Murmur Message ( STRING , Integer . to String ( messages . size ( ) ) , NUM ) ; if ( length Value Write ( out , exchange Info Message . to JSON ( Murmur Application . get Context ( ) , NUM , NUM ) ) ) { for ( Murmur Message message : messages ) { List < Murmur Message > packet = new Array List < > ( ) ; packet . add ( message ) ; Cleartext Messages messages Message = new Cleartext Messages ( ( Array List < Murmur Message > ) packet ) ; length Value Write ( out , messages Message . to Json ( Murmur Application . get Context ( ) ) ) ; } } }
protected void init ( String str ) { int len = str . length ( ) ; text = new char [ len ] ; lc Text = new char [ len ] ; for ( int i = NUM ; i < len ; i ++ ) { char c = str . char At ( i ) ; text [ i ] = c ; if ( c == STRING || c == STRING || c == STRING ) { lc Text [ i ] = STRING ; } else lc Text [ i ] = ( ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) ) ? c : Character . to Lower Case ( c ) ; } }
private void update Attrs ( Svc Reg reg , Entry Rep entry , Object [ ] values ) { Entry Class eclass = entry . eclass ; for ( int fldidx = values . length ; -- fldidx >= NUM ; ) { Object oval = entry . fields [ fldidx ] ; Object nval = values [ fldidx ] ; if ( nval != null && ! nval . equals ( oval ) ) { eclass = get Defining Class ( eclass , fldidx ) ; Hash Map map = add Attr ( reg , eclass , fldidx , nval ) ; entry . fields [ fldidx ] = nval ; if ( has Attr ( reg , eclass , fldidx , oval ) ) continue ; Array List regs = ( Array List ) map . get ( oval ) ; regs . remove ( regs . index Of ( reg ) ) ; if ( regs . is Empty ( ) ) map . remove ( oval ) ; } } }
public void finalize Network Construction ( ) { Set < Motif Link > key Set = node Sets Departing From Link . key Set ( ) ; nodes With Link = new Hash Map < Motif Link , Array List < Node > > ( key Set . size ( ) ) ; for ( Motif Link motif Link : key Set ) { Set < Node > nodes = node Sets Departing From Link . get ( motif Link ) ; Array List < Node > n = new Array List < Node > ( nodes ) ; Collections . sort ( n ) ; nodes With Link . put ( motif Link , n ) ; } node Sets Departing From Link = null ; }
public Collection < AIS Validation Failure > failures ( ) { return Collections . unmodifiable Collection ( failure List ) ; }
public static Get Inactive Images Response check Get Inactive Images Response ( Get Inactive Images Response response ) throws Rpc Exception { logger . info ( STRING , response ) ; switch ( response . get Result ( ) ) { case OK : break ; case SYSTEM ERROR : throw new System Error Exception ( response . get Error ( ) ) ; case DATASTORE NOT FOUND : throw new Datastore Not Found Exception ( response . get Error ( ) ) ; case OPERATION IN PROGRESS : throw new Operation In Progress Exception ( response . get Error ( ) ) ; default : throw new Rpc Exception ( String . format ( STRING , response . get Result ( ) ) ) ; } return response ; }
public void run Test ( ) throws Throwable { Document doc ; Element root ; Node List element List ; Node first Child ; Node List text List ; Character Data text Node ; String data ; doc = ( Document ) load ( STRING , BOOL ) ; root = doc . get Document Element ( ) ; root . normalize ( ) ; element List = root . get Elements By Tag Name ( STRING ) ; first Child = element List . item ( NUM ) ; text List = first Child . get Child Nodes ( ) ; text Node = ( Character Data ) text List . item ( NUM ) ; data = text Node . get Data ( ) ; assert Equals ( STRING , STRING , data ) ; }
public double semi Deviation ( ) { return Math . sqrt ( semi Variance ( ) ) ; }
private void check Posts Display On Recycler View ( List < Post > posts To Check , int position ) { int column Count = NUM ; int size = posts To Check . size ( ) + position ; int pos = NUM ; for ( int i = position ; i < size ; i ++ ) { check Item At Position ( i , posts To Check . get ( pos ) ) ; if ( ( ( i + NUM ) % column Count ) == NUM ) { int next Row Start = i + column Count ; int next Row End = next Row Start - column Count + NUM ; for ( int n = next Row Start ; n >= next Row End ; n -- ) { check Item At Position ( n , posts To Check . get ( n - position ) ) ; } i = i + column Count ; } pos ++ ; } }
private void add Dependent Classes To Worklist ( GV Congruence Class c ) { for ( Value Graph Vertex v : c ) { for ( Enumeration < Graph Node > e = v . in Nodes ( ) ; e . has More Elements ( ) ; ) { Value Graph Vertex in = ( Value Graph Vertex ) e . next Element ( ) ; int vn = in . get Value Number ( ) ; GV Congruence Class x = B . get ( vn ) ; work List . push ( x ) ; } } }
public synchronized JSON Object to JSON Object ( ) { JSON Object res = new JSON Object ( ) ; res . put All ( this ) ; return res ; }
private Shape create Ellipse Internal ( int x , int y , int w , int h ) { ellipse . set Frame ( x , y , w , h ) ; return ellipse ; }
public static String write ( String Builder sb , String ... strings ) { for ( String string : strings ) sb . append ( string ) ; return sb . to String ( ) ; }
public Import Folder Validation validate ( final String path ) { Check . not Null ( path , STRING ) ; if ( validation Cache == null ) { validation Cache = new Hash Map ( ) ; } else { if ( validation Cache . contains Key ( path ) ) { return ( Import Folder Validation ) validation Cache . get ( path ) ; } } final Import Folder Validation validation = compute Validation ( path ) ; validation Cache . put ( path , validation ) ; return validation ; }
private static byte [ ] hmac sha ( String crypto , byte [ ] key Bytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . get Instance ( crypto ) ; Secret Key Spec mac Key = new Secret Key Spec ( key Bytes , STRING ) ; hmac . init ( mac Key ) ; return hmac . do Final ( text ) ; } catch ( General Security Exception gse ) { throw new Undeclared Throwable Exception ( gse ) ; } }
public static String fetch Cg Name ( String cluster Cg Name ) { String cg Name = null ; if ( cluster Cg Name != null && ! cluster Cg Name . is Empty ( ) ) { String [ ] tmp = cluster Cg Name . split ( SPLITTER ) ; cg Name = tmp [ NUM ] ; } return cg Name ; }
public void test choose Server Alias ( ) { init ( SERVER ) ; assert Null ( manager . choose Server Alias ( null , null , new Socket ( ) ) ) ; assert Null ( manager . choose Server Alias ( STRING , null , new Socket ( ) ) ) ; String res = manager . choose Server Alias ( TYPE RSA , null , null ) ; assert Not Null ( res ) ; assert Equals ( STRING , res . to Lower Case ( ) ) ; res = manager . choose Server Alias ( TYPE RSA , null , new Socket ( ) ) ; assert Not Null ( res ) ; assert Equals ( STRING , res . to Lower Case ( ) ) ; }
public void add ( int index , Entity entity ) { if ( entities . contains ( entity ) ) { throw new Illegal State Exception ( STRING + entity + STRING ) ; } if ( entity . get Entity Type ( ) != entity Type ) { throw new Illegal State Exception ( STRING + entity . get Entity Type ( ) + STRING + get Parent ( ) + STRING + get Name ( ) ) ; } if ( entity . is Clearly Not In Database ( ) ) { new Entities . add ( entity ) ; } entities . add ( index , entity ) ; }
public static Control Tag Cache Object create Test Equipment Alive ( ) { Control Tag Cache Object cache Object = new Control Tag Cache Object ( new Long ( NUM ) , STRING , STRING , Data Tag Constants . MODE TEST ) ; cache Object . set Description ( STRING ) ; cache Object . set Logged ( BOOL ) ; cache Object . set Unit ( STRING ) ; cache Object . set Dip Address ( STRING ) ; cache Object . set Japc Address ( STRING ) ; cache Object . set Value ( new Long ( System . current Time Millis ( ) ) ) ; cache Object . set Value Description ( STRING ) ; cache Object . set Simulated ( BOOL ) ; cache Object . set Min Value ( Long . MIN VALUE ) ; cache Object . set Max Value ( Long . MAX VALUE ) ; cache Object . set Value Dictionary ( new Data Tag Value Dictionary ( ) ) ; cache Object . set Address ( new Data Tag Address ( ) ) ; cache Object . set Data Tag Quality ( create Valid Quality ( ) ) ; cache Object . set Cache Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; cache Object . set Daq Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; cache Object . set Source Timestamp ( new Timestamp ( System . current Time Millis ( ) ) ) ; return cache Object ; }
public Distributed Log Configuration ( ) { super ( ) ; add Configuration ( new System Configuration ( ) ) ; }
public static double sample Standard Deviation ( int size , double sample Variance ) { double s , Cn ; int n = size ; s = Math . sqrt ( sample Variance ) ; if ( n > NUM ) { Cn = NUM + NUM / ( NUM * ( n - NUM ) ) ; } else { Cn = Math . sqrt ( ( n - NUM ) * NUM ) * Gamma . gamma ( ( n - NUM ) * NUM ) / Gamma . gamma ( n * NUM ) ; } return Cn * s ; }
void normalize ( ) throws IO Exception { int end = chars . length ( ) ; if ( end == NUM ) { return ; } int pos = NUM ; int codepoint = Character . code Point At ( chars , NUM ) ; boolean escaped = BOOL ; for ( int i = NUM ; i < end ; ) { int char Count = Character . char Count ( codepoint ) ; int i2 = i + char Count ; int next Codepoint = i2 < end ? Character . code Point At ( chars , i2 ) : - NUM ; if ( escaped ) { escaped = BOOL ; if ( escape One Codepoint ( pos , i - NUM , codepoint , next Codepoint ) ) { pos = i2 ; } } else if ( codepoint == STRING ) { escaped = BOOL ; } else if ( escape One Codepoint ( pos , i , codepoint , next Codepoint ) ) { pos = i2 ; } i = i2 ; codepoint = next Codepoint ; } out . append ( chars , pos , end ) ; }
protected void rebuild List Model ( ) { Default List Model dlm = ( Default List Model ) get List Model ( ) ; OM Graphic List list = get List ( ) ; int [ ] selected Indicies = null ; if ( list != null ) { if ( selected Tiles != null && selected Tiles . length > NUM ) { selected Indicies = new int [ selected Tiles . length ] ; } int tile Count = NUM ; int selected Index = NUM ; if ( selected Indicies != null ) { for ( OM Graphic omg : list ) { Image Tile image Tile = ( Image Tile ) omg ; if ( image Tile . is Selected ( ) && selected Index < selected Indicies . length ) { selected Indicies [ selected Index ++ ] = tile Count ; } tile Count ++ ; } } dlm . clear ( ) ; for ( OM Graphic omg : list ) { tile Count ++ ; dlm . add Element ( omg ) ; } } if ( results List != null ) { if ( selected Indicies != null ) { results List . set Selected Indices ( selected Indicies ) ; } results List . repaint ( ) ; } }
public void tick ( ) { tick ( NUM ) ; }
public Result send ( Email email , boolean ... sync ) { return service . send ( email , bool To Int ( BOOL , sync ) ) ; }
private boolean is Populating ( ) { return is Populating ; }
public void process Attributes ( java . io . Writer writer , int n Attrs ) throws IO Exception , SAX Exception { String encoding = get Encoding ( ) ; for ( int i = NUM ; i < n Attrs ; i ++ ) { final String name = m attributes . get Q Name ( i ) ; final String value = m attributes . get Value ( i ) ; writer . write ( STRING ) ; writer . write ( name ) ; writer . write ( STRING ) ; write Attr String ( writer , value , encoding ) ; writer . write ( STRING ) ; } }
public int processor ( ) { return Integer . parse Int ( fields [ NUM ] ) ; }
public void add Native Child At ( React Shadow Node child , int native Index ) { Assertions . assert Condition ( ! m Is Layout Only ) ; Assertions . assert Condition ( ! child . m Is Layout Only ) ; if ( m Native Children == null ) { m Native Children = new Array List < > ( NUM ) ; } m Native Children . add ( native Index , child ) ; child . m Native Parent = this ; }
public boolean contains Key ( final Object e Key ) { return element Order . contains ( e Key ) ; }
private void handle Exit Message ( final Component component , final long native Ctxt ) { post Drop Target Event ( component , NUM , NUM , Dn D Constants . ACTION NONE , Dn D Constants . ACTION NONE , null , native Ctxt , Sun Drop Target Event . MOUSE EXITED , Sun Drop Target Context Peer . DISPATCH SYNC ) ; }
public void add Parameter Annotations ( Cst Method Ref method , Annotations List list ) { if ( parameter Annotations == null ) { parameter Annotations = new Array List < Parameter Annotation Struct > ( ) ; } parameter Annotations . add ( new Parameter Annotation Struct ( method , list ) ) ; }
public static String unhtml Single Quotes ( final String str ) { return str . replace All ( STRING , STRING ) ; }
public void add Input Method Listener ( Input Method Listener l ) { m text Area . add Input Method Listener ( l ) ; }
public void init Raw Swap ( Array List < S2 Cell Id > cell Ids ) { this . cell Ids = new Array List < S2 Cell Id > ( cell Ids ) ; cell Ids . clear ( ) ; }
protected void encrypt Final ( ) throws IO Exception { in Buffer . flip ( ) ; out Buffer . clear ( ) ; try { cipher . do Final ( in Buffer , out Buffer ) ; } catch ( Short Buffer Exception e ) { throw new IO Exception ( e ) ; } catch ( Illegal Block Size Exception e ) { throw new IO Exception ( e ) ; } catch ( Bad Padding Exception e ) { throw new IO Exception ( e ) ; } in Buffer . clear ( ) ; out Buffer . flip ( ) ; while ( out Buffer . has Remaining ( ) ) { output . write ( out Buffer ) ; } }
private static boolean span Will Overlap ( Spannable span Text , URL Span [ ] span List , int start , int end ) { if ( start == end ) { return BOOL ; } for ( URL Span span : span List ) { int existing Start = span Text . get Span Start ( span ) ; int existing End = span Text . get Span End ( span ) ; if ( ( start >= existing Start && start < existing End ) || end > existing Start && end <= existing End ) { if ( Log . is Loggable ( TAG , Log . VERBOSE ) ) { Char Sequence seq = span Text . sub Sequence ( start , end ) ; Log . v ( TAG , STRING + seq + STRING ) ; } return BOOL ; } } return BOOL ; }
private Hash Map < Integer , Trie > build Lookup Table ( final Map < Integer , List < Trie > > child Tries ) { Hash Map < Integer , Trie > lookup = new Hash Map < > ( child Tries . size ( ) ) ; for ( int id : child Tries . key Set ( ) ) { final List < Trie > tries = child Tries . get ( id ) ; if ( tries . size ( ) == NUM ) { lookup . put ( id , tries . get ( NUM ) ) ; } else { lookup . put ( id , new Slice Aggregating Trie ( tries ) ) ; } } return lookup ; }
public void add Marker ( int x , int z , Color color ) { Map Marker marker = new Map Marker ( ) ; marker . x = x ; marker . z = z ; marker . color = color ; markers . add ( marker ) ; }
private void commit Discard ( long time , boolean allow Discard ) { if ( m Discarding Tab == null ) return ; assert m Stack Tabs != null ; Stack Tab discarded = m Discarding Tab ; if ( Math . abs ( discarded . get Discard Amount ( ) ) / get Discard Range ( ) > DISCARD COMMIT THRESHOLD && allow Discard ) { m Layout . ui Requesting Close Tab ( time , discarded . get Id ( ) ) ; Record User Action . record ( STRING ) ; Record User Action . record ( STRING ) ; } else { start Animation ( time , Overview Animation Type . UNDISCARD ) ; } m Discarding Tab = null ; request Update ( ) ; }
public List < Object > build Java Method Parameters ( Asset Options Context context , Map < String , String > available Assets , Asset Options Method Info asset Method ) { final List < Object > java Method Parameters = Lists . new Array List ( ) ; java Method Parameters . add ( context ) ; for ( String parent Asset Name : asset Method . asset Dependencies ) { String parent Asset Value = available Assets . get ( parent Asset Name ) ; int index = java Method Parameters . size ( ) ; Object value = asset Method . convert Parameter ( index , parent Asset Value ) ; java Method Parameters . add ( value ) ; } return java Method Parameters ; }
private static Image View pick Graphic ( Restartable Service start Stoppable ) { final boolean running = start Stoppable . is Running ( ) ; final Image View icon = running ? new Image View ( stop Image ) : new Image View ( start Image ) ; if ( ! running ) { final Fade Transition ft = new Fade Transition ( Duration . millis ( NUM ) , icon ) ; ft . set To Value ( NUM ) ; ft . set Cycle Count ( Transition . INDEFINITE ) ; ft . set Auto Reverse ( BOOL ) ; ft . play ( ) ; } icon . set Fit Height ( DPI Utility . MINI ICON SIZE ) ; icon . set Fit Width ( DPI Utility . MINI ICON SIZE ) ; return icon ; }
public static boolean is Extension ( String filename , String extension ) { if ( filename == null ) { return BOOL ; } if ( extension == null || extension . length ( ) == NUM ) { return index Of Extension ( filename ) == - NUM ; } String file Ext = get Extension ( filename ) ; return file Ext . equals ( extension ) ; }
public void create Cash Based Journal Entries And Reversals For Savings Charges ( final Office office , final String currency Code , final CASH ACCOUNTS FOR SAVINGS account Type To Be Debited , final CASH ACCOUNTS FOR SAVINGS account Type To Be Credited , final Long savings Product Id , final Long payment Type Id , final Long loan Id , final String transaction Id , final Date transaction Date , final Big Decimal total Amount , final Boolean is Reversal , final List < Charge Payment DTO > charge Payment DT Os ) { if ( charge Payment DT Os . size ( ) != NUM ) { throw new Platform Data Integrity Exception ( STRING , STRING ) ; } Charge Payment DTO charge Payment DTO = charge Payment DT Os . get ( NUM ) ; final GL Account charge Specific Account = get Linked GL Account For Savings Charges ( savings Product Id , account Type To Be Credited . get Value ( ) , charge Payment DTO . get Charge Id ( ) ) ; final GL Account savings Control Account = get Linked GL Account For Savings Product ( savings Product Id , account Type To Be Debited . get Value ( ) , payment Type Id ) ; if ( is Reversal ) { create Debit Journal Entry For Savings ( office , currency Code , charge Specific Account , loan Id , transaction Id , transaction Date , total Amount ) ; create Credit Journal Entry For Savings ( office , currency Code , savings Control Account , loan Id , transaction Id , transaction Date , total Amount ) ; } else { create Debit Journal Entry For Savings ( office , currency Code , savings Control Account , loan Id , transaction Id , transaction Date , total Amount ) ; create Credit Journal Entry For Savings ( office , currency Code , charge Specific Account , loan Id , transaction Id , transaction Date , total Amount ) ; } }
public void add All ( Json Array array ) { elements . add All ( array . elements ) ; }
public double next Double ( double k ) { double u , v , w , c , z ; if ( k <= NUM ) throw new Illegal Argument Exception ( ) ; if ( k set != k ) { tau = NUM + Math . sqrt ( NUM + NUM * k * k ) ; rho = ( tau - Math . sqrt ( NUM * tau ) ) / ( NUM * k ) ; r = ( NUM + rho * rho ) / ( NUM * rho ) ; k set = k ; } do { u = random Generator . raw ( ) ; v = random Generator . raw ( ) ; z = Math . cos ( Math . PI * u ) ; w = ( NUM + r * z ) / ( r + z ) ; c = k * ( r - w ) ; } while ( ( c * ( NUM - c ) < v ) && ( Math . log ( c / v ) + NUM < c ) ) ; return ( random Generator . raw ( ) > NUM ) ? Math . acos ( w ) : - Math . acos ( w ) ; }
public void test List Options ( ) { if ( m Option Tester . get Option Handler ( ) != null ) { if ( ! m Option Tester . check List Options ( ) ) { fail ( STRING ) ; } } }
@ Override final public void mouse Released ( Mouse Event e ) { if ( is Component Pressed Down ) { mouse Liberal Click ( e ) ; long now = System . current Time Millis ( ) ; long time Between Unused Clicks = now - last Unused Liberal Single Click Time Stamp ; if ( time Between Unused Clicks <= slowest Double Click Milliseconds ) { mouse Liberal Double Click ( e ) ; last Unused Liberal Single Click Time Stamp = NUM ; } else { last Unused Liberal Single Click Time Stamp = System . current Time Millis ( ) ; } } is Component Pressed Down = BOOL ; mouse Release ( e ) ; }
public static Modification Type value Of ( final int int Value ) { Modification Type result = null ; if ( NUM <= int Value && int Value < ELEMENTS . length ) { result = ELEMENTS [ int Value ] ; } if ( result == null ) { result = new Modification Type ( int Value , STRING + int Value + STRING , Enum . UNKNOWN ) ; } return result ; }
@ Override public void fill Header ( Header hdr ) { try { Standard . context ( Ascii Table . class ) ; hdr . set Xtension ( STRING ) ; hdr . set Bitpix ( Basic HDU . BITPIX BYTE ) ; hdr . set Naxes ( NUM ) ; hdr . set Naxis ( NUM , this . row Len ) ; hdr . set Naxis ( NUM , this . n Rows ) ; Cursor < String , Header Card > iter = hdr . iterator ( ) ; iter . set Key ( NAXIS 2 . key ( ) ) ; iter . next ( ) ; iter . add ( new Header Card ( PCOUNT . key ( ) , NUM , PCOUNT . comment ( ) ) ) ; iter . add ( new Header Card ( GCOUNT . key ( ) , NUM , GCOUNT . comment ( ) ) ) ; iter . add ( new Header Card ( TFIELDS . key ( ) , this . n Fields , TFIELDS . comment ( ) ) ) ; for ( int i = NUM ; i < this . n Fields ; i += NUM ) { add Col Info ( i , iter ) ; } } catch ( Header Card Exception e ) { LOG . log ( Level . SEVERE , STRING + e . get Message ( ) , e ) ; } finally { Standard . context ( null ) ; } }
private boolean search End Match ( final String item Name ) { for ( Map . Entry < String , Sentence > e : parsed Names . entry Set ( ) ) { Sentence parsed = e . get Value ( ) ; if ( item Name . ends With ( parsed . get Original Text ( ) ) || item Name . ends With ( parsed . get Normalized ( ) ) ) { name = e . get Key ( ) ; return BOOL ; } } return BOOL ; }
private static byte expected Norm ( final Default Similarity sim , final int length , final float boost ) { return ( byte ) sim . encode Norm Value ( boost / ( ( float ) Math . sqrt ( length ) ) ) ; }
public void test Compare To Equal Neg ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; int b Sign = - NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; assert Equals ( NUM , a Number . compare To ( b Number ) ) ; }
@ Override public Shape Tile Simplex enlarge ( double p offset ) { if ( p offset == NUM ) return this ; Shape Tile Simplex offset simplex = offset ( p offset ) ; Shape Tile Octagon bounding oct = bounding octagon ( ) ; if ( bounding oct . is Na N ( ) ) return Shape Tile Simplex . EMPTY ; Shape Tile Octagon offset oct = bounding oct . offset ( p offset ) ; return offset simplex . intersection ( offset oct . to Simplex ( ) ) ; }
V remove ( Object key , int hash , Object value ) { lock ( ) ; try { int c = cnt - NUM ; HE < K , V > [ ] tab = table ; int index = hash & ( tab . length - NUM ) ; HE < K , V > first = tab [ index ] ; HE < K , V > e = first ; while ( e != null && ( e . hash != hash || ! key . equals ( e . k ) ) ) e = e . next ; V old Value = null ; if ( e != null ) { V v = e . v ; if ( value == null || value . equals ( v ) ) { old Value = v ; ++ mod Cnt ; HE < K , V > new First = e . next ; for ( HE < K , V > p = first ; p != e ; p = p . next ) new First = new HE < K , V > ( p . k , p . hash , new First , p . v ) ; tab [ index ] = new First ; cnt = c ; } } return old Value ; } finally { unlock ( ) ; } }
public static Tree Path path Till Of Kind ( final Tree Path path , final Tree . Kind kind ) { return path Till Of Kind ( path , Enum Set . of ( kind ) ) ; }
public Big Decimal read F 2 Dot 14 ( int index ) { throw new Unsupported Operation Exception ( ) ; }
public int size ( ) { return set . size ( ) ; }
private void write Attribute ( java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( namespace . equals ( STRING ) ) { xml Writer . write Attribute ( att Name , att Value ) ; } else { register Prefix ( xml Writer , namespace ) ; xml Writer . write Attribute ( namespace , att Name , att Value ) ; } }
public void add Rendering Hints ( Map < ? , ? > hints ) { m Graphics . add Rendering Hints ( hints ) ; }
private void create New Fields Array ( ) { for ( int i = NUM ; i < person Fields Old . length ; i ++ ) { person Fields New [ i ] = person Fields Old [ i ] + STRING ; } }
public void remove All Relations ( ) { for ( B Node input Node : new Linked List < B Node > ( input Nodes . values ( ) ) ) { remove Input Node ( input Node . get Id ( ) ) ; } for ( B Node output Node : new Linked List < B Node > ( output Nodes . values ( ) ) ) { remove Output Node ( output Node . get Id ( ) ) ; } }
private void add Exposed Types ( Class < ? > clazz , Class < ? > cause ) { if ( pruned ( clazz ) ) { return ; } boolean already Done = done ( clazz ) ; visit ( clazz ) ; record Exposure ( clazz , cause ) ; if ( already Done || pruned ( clazz ) ) { return ; } Type Token < ? > token = Type Token . of ( clazz ) ; for ( Type Token < ? > super Type : token . get Types ( ) ) { if ( ! super Type . equals ( token ) ) { logger . debug ( STRING , super Type , clazz ) ; add Exposed Types ( super Type , clazz ) ; } } for ( Class inner Class : clazz . get Declared Classes ( ) ) { if ( exposed ( inner Class . get Modifiers ( ) ) ) { logger . debug ( STRING , inner Class , clazz ) ; add Exposed Types ( inner Class , clazz ) ; } } for ( Field field : clazz . get Declared Fields ( ) ) { if ( exposed ( field . get Modifiers ( ) ) ) { logger . debug ( STRING , field , clazz ) ; add Exposed Types ( field , clazz ) ; } } for ( Invokable invokable : get Exposed Invokables ( token ) ) { logger . debug ( STRING , invokable , clazz ) ; add Exposed Types ( invokable , clazz ) ; } }
public void store Logs ( File folder ) { String path = folder . get Absolute Path ( ) ; m Logger Folder = new Log This ( path ) ; }
@ Override public Object clone ( ) { return new Location Path ( this ) ; }
private Assignment recursive Back Tracking Search ( CSP csp , Assignment assignment ) { Assignment result = null ; if ( assignment . is Complete ( csp . get Variables ( ) ) ) { result = assignment ; } else { Variable var = select Unassigned Variable ( assignment , csp ) ; for ( Object value : order Domain Values ( var , assignment , csp ) ) { assignment . set Assignment ( var , value ) ; fire State Changed ( assignment , csp ) ; if ( assignment . is Consistent ( csp . get Constraints ( var ) ) ) { Domain Restore Info info = inference ( var , assignment , csp ) ; if ( ! info . is Empty ( ) ) fire State Changed ( csp ) ; if ( ! info . is Empty Domain Found ( ) ) { result = recursive Back Tracking Search ( csp , assignment ) ; if ( result != null ) break ; } info . restore Domains ( csp ) ; } assignment . remove Assignment ( var ) ; } } return result ; }
private static JSON Object create File Transfer Error ( int error Code , String source , String target , String body , Integer http Status ) { JSON Object error = null ; try { error = new JSON Object ( ) ; error . put ( STRING , error Code ) ; error . put ( STRING , source ) ; error . put ( STRING , target ) ; if ( body != null ) { error . put ( STRING , body ) ; } if ( http Status != null ) { error . put ( STRING , http Status ) ; } } catch ( JSON Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return error ; }
public Array List < Value > keys ( ) { Array List < Value > list = New . array List ( size ) ; for ( Value k : keys ) { if ( k != null && k != Value Null . DELETED ) { list . add ( k ) ; } } return list ; }
private void close ( ) { if ( closed ) { return ; } closed = BOOL ; try { result Set . close ( ) ; } catch ( final SQL Exception e ) { logger . error ( e , e ) ; } try { if ( statement != null ) { statement . close ( ) ; } } catch ( final SQL Exception e ) { logger . error ( e , e ) ; } }
public Delivery Thread ( TOM Layer tom Layer , Service Replica receiver , Recoverable recoverer , Server View Controller controller ) { super ( STRING ) ; this . decided = new Linked Blocking Queue < > ( ) ; this . tom Layer = tom Layer ; this . receiver = receiver ; this . recoverer = recoverer ; this . controller = controller ; }
protected void add Button Listener ( ) { Application Insights Add Dialog dialog = new Application Insights Add Dialog ( get Shell ( ) ) ; dialog . open ( ) ; table Viewer . refresh ( ) ; }
public int [ ] to Array ( ) { int [ ] result = new int [ size ] ; System . arraycopy ( array , NUM , result , NUM , size ) ; return result ; }
public Block obtain Block ( String prototype Name , @ Nullable String uuid ) { Block block ; if ( uuid != null ) { Weak Reference < Block > ref = m Block Refs . get ( uuid ) ; if ( ref != null ) { block = ref . get ( ) ; if ( block != null ) { throw new Illegal Argument Exception ( STRING + uuid + STRING ) ; } } } if ( ! m Block Templates . contains Key ( prototype Name ) ) { Log . w ( TAG , STRING + prototype Name + STRING ) ; return null ; } Block . Builder builder = new Block . Builder ( m Block Templates . get ( prototype Name ) ) ; if ( uuid != null ) { builder . set Uuid ( uuid ) ; } block = builder . build ( ) ; m Block Refs . put ( block . get Id ( ) , new Weak Reference < Block > ( block ) ) ; return block ; }
public Sms Console Service Config ( ) { Document doc = parse Document ( CONFIG FILENAME ) ; config Services ( doc ) ; hidden Services = Collections . unmodifiable Set ( services . get ( HIDDEN SERVICES ) ) ; }
@ Override protected void on Size Changed ( int w , int h , int oldw , int oldh ) { super . on Size Changed ( w , h , oldw , oldh ) ; setup Bounds ( w , h ) ; setup Paints ( ) ; invalidate ( ) ; }
private static String convert To Quoted String ( String s ) { if ( s == null || s . is Empty ( ) ) { return null ; } if ( s . char At ( NUM ) == STRING && s . char At ( s . length ( ) - NUM ) == STRING ) { return s ; } return STRING + s + STRING ; }
public Pattern Observer Expr ( String namespace , String name , Expression [ ] parameters ) { super ( namespace , name , Arrays . as List ( parameters ) ) ; }
public static String convert String To Hex String ( String data ) { return convent Bytes To Hex String ( data . get Bytes ( ) ) ; }
public boolean is Transient ( ) { return Modifier . is Transient ( get Access Flags ( ) ) ; }
public boolean is For HTTP Basic ( ) { return ( nego Value != null ) ? nego Value . equals Ignore Case ( HTTP HTTPBASIC ) : BOOL ; }
private String indent ( int level ) { final String s = STRING ; if ( level == NUM ) return STRING ; String Builder sb = new String Builder ( level * s . length ( ) ) ; for ( int i = NUM ; i < level ; i ++ ) { sb . append ( s ) ; } return s . to String ( ) ; }
public static String cut ( String line , Int Predicate test Function ) { String s = STRING ; int pos = Sub Parser . locate ( line , test Function ) ; if ( pos != - NUM ) { s = line . substring ( NUM , pos ) ; } return s ; }
public void add Listener ( Update Manager Listener listener ) { listeners . add ( listener ) ; }
@ Override public void run ( ) { List < Span > dequeued Spans = new Array List < Span > ( max Span Batch Size ) ; long error Count = NUM ; while ( running . get ( ) || queue . size ( ) > NUM ) { Span first Span = null ; try { first Span = queue . poll ( NUM , Time Unit . SECONDS ) ; if ( first Span != null ) { dequeued Spans . add ( first Span ) ; queue . drain To ( dequeued Spans , max Span Batch Size - NUM ) ; } } catch ( Interrupted Exception ie ) { } start Client ( ) ; if ( dequeued Spans . is Empty ( ) ) { continue ; } try { List < Event > events = new Array List < Event > ( dequeued Spans . size ( ) ) ; for ( Span span : dequeued Spans ) { Map < String , String > headers = new Hash Map < String , String > ( ) ; headers . put ( STRING , span . to String ( ) ) ; headers . put ( STRING , span . get Tracer Id ( ) ) ; headers . put ( STRING , span . get Description ( ) ) ; String body = span . to Json ( ) ; Event evt = Event Builder . with Body ( body , Charset . for Name ( STRING ) , headers ) ; events . add ( evt ) ; } flume Client . append Batch ( events ) ; dequeued Spans . clear ( ) ; error Count = NUM ; } catch ( Exception e ) { error Count += NUM ; if ( error Count < MAX ERRORS ) { try { queue . add All ( dequeued Spans ) ; } catch ( Illegal State Exception ex ) { LOG . error ( STRING + dequeued Spans . size ( ) + STRING ) ; } } close Client ( ) ; try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e1 ) { } } } close Client ( ) ; }
public void cancel Authentication ( ) { synchronized ( sync Lock ) { authenticating = BOOL ; timer . cancel ( ) ; timer . purge ( ) ; } }
private void check Valid Interval ( Duration polling Interval , int retries , long time Slept Millis ) { long high Sum = NUM ; long low Sum = NUM ; for ( int i = NUM ; i < retries ; i ++ ) { double current Interval = polling Interval . get Millis ( ) * Math . pow ( Dataflow Pipeline Job . DEFAULT BACKOFF EXPONENT , i ) ; double random Offset = NUM * current Interval ; high Sum += Math . round ( current Interval + random Offset ) ; low Sum += Math . round ( current Interval - random Offset ) ; } assert That ( time Slept Millis , all Of ( greater Than Or Equal To ( low Sum ) , less Than Or Equal To ( high Sum ) ) ) ; }
public void write ( String str , int off , int len ) throws IO Exception { if ( output Stream == null ) throw new IO Exception ( STRING ) ; final int off plus len = off + len ; for ( int i = off ; i < off plus len ; ) { char c = str . char At ( i ++ ) ; if ( c < NUM ) { bytes [ index ] = ( byte ) c ; if ( ++ index >= bytes . length ) { flush Buffer ( ) ; } } else { write ( c ) ; } } }
public Commit Record Index ( I Raw Store store , Checkpoint checkpoint , Index Metadata metadata , boolean read Only ) { super ( store , checkpoint , metadata , read Only ) ; this . ser = new Entry . Entry Serializer ( ) ; }
protected String encode Body ( ) { return Long . to String ( this . sequence Number ) ; }
public void add Container ( Image Container container ) { m Containers . add ( container ) ; }
private void check Size ( final int i ) { if ( i >= max size ) { final int old size = max size ; max size += increment size ; if ( max size <= i ) { max size = i + increment size + NUM ; } final Rectangle [ ] temp = items ; items = new Rectangle [ max size ] ; System . arraycopy ( temp , NUM , items , NUM , old size ) ; increment size = increment Size ( increment size ) ; } }
public static double [ ] gen Pulse From Fourier Mag ( double [ ] mag , double f0 ) { int num Harm = mag . length ; int current F 0 = ( int ) Math . round ( f0 ) ; int T ; if ( current F 0 < NUM ) T = NUM ; else T = NUM ; int T2 = NUM * T ; double [ ] pulse = new double [ T ] ; double [ ] real = new double [ T2 ] ; double [ ] imag = new double [ T2 ] ; real [ NUM ] = real [ T ] = NUM ; for ( int i = NUM ; i <= num Harm ; i ++ ) { real [ i ] = real [ T - i ] = real [ T + i ] = real [ T2 - i ] = mag [ i - NUM ] ; imag [ i ] = imag [ T - i ] = imag [ T + i ] = imag [ T2 - i ] = NUM ; } for ( int i = ( num Harm + NUM ) ; i < ( T - num Harm ) ; i ++ ) { real [ i ] = real [ T - i ] = real [ T + i ] = real [ T2 - i ] = NUM ; imag [ i ] = imag [ T - i ] = imag [ T + i ] = imag [ T2 - i ] = NUM ; } FFT . transform ( real , imag , BOOL ) ; double sqrt f0 = Math . sqrt ( current F 0 ) ; for ( int i = NUM ; i < T ; i ++ ) pulse [ i ] = real [ ( i - num Harm ) % T ] * sqrt f0 ; return pulse ; }
public double volume ( ) { if ( cached Volume < NUM ) { cached Volume = NUM ; I Hypercube cube = this . region ; int nd = cube . dimensionality ( ) ; for ( int d = NUM ; d <= nd ; d ++ ) { double right = cube . get Right ( d ) ; double left = cube . get Left ( d ) ; if ( Double . is Infinite ( right ) ) { right = + NUM ; } if ( Double . is Infinite ( left ) ) { left = - NUM ; } if ( left == - NUM && right == + NUM ) { } else { cached Volume *= ( right - left ) ; } } } return cached Volume ; }
static String target So File ( String lib Name , int version ) { Context context = m Context ; if ( null == context ) { return STRING ; } String path = STRING + context . get Package Name ( ) + STRING ; File f = context . get Files Dir ( ) ; if ( f != null ) { path = f . get Path ( ) ; } return path + STRING + lib Name + STRING + version + STRING ; }
@ Override public void stop Monitoring ( ) { stop Monitoring ( BOOL ) ; }
@ Override public Object compute ( Array List < Map < String , Object > > rows ) throws Exception { if ( column . equals ( STRING ) ) { return rows . size ( ) ; } long count = NUM ; for ( Map < String , Object > row : rows ) { if ( row . contains Key ( column ) && ( row . get ( column ) != null ) ) { count ++ ; } } return count ; }
private Property [ ] parse Properties ( final String contents ) { final String [ ] parts = contents . split ( STRING ) ; final List < Property > results As List = new Array List < Property > ( ) ; for ( String part : parts ) { try { if ( ! String Utils . is Empty ( part . trim ( ) ) ) { results As List . add ( new Property ( part ) ) ; } } catch ( final Exception e ) { LOG . warn ( e . get Message ( ) , e ) ; } } return results As List . to Array ( new Property [ results As List . size ( ) ] ) ; }
public void request Seconds Until Account Expiration ( ) { operations . add ( Password Policy State Operation Type . GET SECONDS UNTIL ACCOUNT EXPIRATION ) ; }
public final boolean equals Ignore Case ( String a ) { int len = a . length ( ) ; if ( length != len ) return BOOL ; int offset = offset ; char [ ] buffer = buffer ; for ( int i = NUM ; i < len ; i ++ ) { char ca = buffer [ offset + i ] ; char cb = a . char At ( i ) ; if ( ca == cb ) { } else if ( Character . to Lower Case ( ca ) != Character . to Lower Case ( cb ) ) return BOOL ; } return BOOL ; }
public static int [ ] check Object Start ( Pdf Tokenizer line Tokenizer ) { try { line Tokenizer . seek ( NUM ) ; if ( ! line Tokenizer . next Token ( ) || line Tokenizer . get Token Type ( ) != Token Type . Number ) return null ; int num = line Tokenizer . get Int Value ( ) ; if ( ! line Tokenizer . next Token ( ) || line Tokenizer . get Token Type ( ) != Token Type . Number ) return null ; int gen = line Tokenizer . get Int Value ( ) ; if ( ! line Tokenizer . next Token ( ) ) return null ; if ( ! Arrays . equals ( Obj , line Tokenizer . get Byte Content ( ) ) ) return null ; return new int [ ] { num , gen } ; } catch ( Exception ioe ) { } return null ; }
private Object single Element ( int row , int col ) { Object res = null ; if ( this . is Null == null || ! this . is Null [ row * this . n Fields + col ] ) { res = Array Funcs . new Instance ( this . types [ col ] , NUM ) ; System . arraycopy ( this . data [ col ] , row , res , NUM , NUM ) ; } return res ; }
private char convert To Char ( String kurzname ) { char result = KEIN SIEGEL ; if ( kurzname != null && ! kurzname . is Empty ( ) ) { if ( kurzname . length ( ) > NUM ) { result = kurzname . to Char Array ( ) [ NUM ] ; } else { result = kurzname . to Char Array ( ) [ NUM ] ; } } return result ; }
public Node Set DTM ( Node Iterator iterator , X Path Context xctxt ) { super ( ) ; Node node ; m manager = xctxt . get DTM Manager ( ) ; while ( null != ( node = iterator . next Node ( ) ) ) { int handle = xctxt . get DTM Handle From Node ( node ) ; add Node In Doc Order ( handle , xctxt ) ; } }
public static Vec mean Vector ( Data Set data Set ) { Dense Vector dv = new Dense Vector ( data Set . get Num Numerical Vars ( ) ) ; mean Vector ( dv , data Set ) ; return dv ; }
private void make Cache Directory ( ) { File cache Dir = new File ( CACHE DIRECTORY ) ; if ( ! cache Dir . exists ( ) ) { cache Dir . mkdir ( ) ; } }
public void input Keyevent ( int value ) { execute Command Quietly ( adb Command ( STRING , STRING , STRING , STRING + value ) ) ; try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { log . warn ( STRING , e ) ; } }
public static void pass Mock Sleep ( ) { mock Sleep Queue . offer ( BOOL ) ; }
private static File create Reserve Disk Cache Dir ( Context context ) { File cache Dir = Storage Utils . get Cache Directory ( context , BOOL ) ; File individual Dir = new File ( cache Dir , STRING ) ; if ( individual Dir . exists ( ) || individual Dir . mkdir ( ) ) { cache Dir = individual Dir ; } return cache Dir ; }
JSON Stringer close ( Scope empty , Scope nonempty , String close Bracket ) throws JSON Exception { Scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new JSON Exception ( STRING ) ; } stack . remove ( stack . size ( ) - NUM ) ; if ( context == nonempty ) { newline ( ) ; } out . append ( close Bracket ) ; return this ; }
private Query Builder build Sort ( ) { Query Builder builder = new Query Builder ( ) ; Iterator < String > sort Iterator = m Sorting Order List . iterator ( ) ; while ( sort Iterator . has Next ( ) ) { builder . append ( sort Iterator . next ( ) ) ; if ( sort Iterator . has Next ( ) ) builder . append ( STRING ) ; } return builder ; }
public void init ( int mode , byte [ ] key , byte [ ] iv ) { context = Open Ssl Native . init ( context , mode , algorithm , padding , key , iv ) ; }
private String diff words To Chars Munge ( String text , List < String > line Array , Map < String , Integer > line Hash ) { int line Start = NUM ; int line End = - NUM ; String line ; String Builder chars = new String Builder ( ) ; while ( line End < text . length ( ) - NUM ) { String pattern Str = STRING ; Pattern pattern = Pattern . compile ( pattern Str ) ; Matcher matcher = pattern . matcher ( text ) ; matcher . region ( line Start , text . length ( ) ) ; if ( matcher . find ( ) ) { line End = matcher . start ( ) ; } else line End = - NUM ; if ( line End == - NUM ) { line End = text . length ( ) - NUM ; } line = text . substring ( line Start , line End + NUM ) ; line Start = line End + NUM ; if ( line Hash . contains Key ( line ) ) { chars . append ( String . value Of ( ( char ) ( int ) line Hash . get ( line ) ) ) ; } else { line Array . add ( line ) ; line Hash . put ( line , line Array . size ( ) - NUM ) ; chars . append ( String . value Of ( ( char ) ( line Array . size ( ) - NUM ) ) ) ; } } return chars . to String ( ) ; }
private void replace Top ( Scope top Of Stack ) { stack . set ( stack . size ( ) - NUM , top Of Stack ) ; }
public boolean has Next ( ) { return index < desc . length ( ) ; }
public void register Session Thread ( Session Thread new Session ) { synchronized ( this ) { List < Session Thread > to Be Removed = new Array List < Session Thread > ( ) ; for ( Session Thread session Thread : session Threads ) { if ( ! session Thread . is Alive ( ) ) { Log . d ( TAG , STRING ) ; try { session Thread . join ( ) ; Log . d ( TAG , STRING ) ; to Be Removed . add ( session Thread ) ; session Thread . close Socket ( ) ; } catch ( Interrupted Exception e ) { Log . d ( TAG , STRING ) ; } } } for ( Session Thread remove Thread : to Be Removed ) { session Threads . remove ( remove Thread ) ; } session Threads . add ( new Session ) ; } Log . d ( TAG , STRING ) ; }
protected I Object Info < T > store impl ( Segment < T > segment , Object Info < T > oi ) { if ( invalid ) return null ; size . increment And Get ( ) ; segment . increment Size ( ) ; Object Info < T > tail = segment . get Tail ( ) ; tail . set Forward Ref ( oi ) ; oi . set Backward Ref ( tail ) ; segment . set Tail ( oi ) ; return oi ; }
public Te X Formula ( ) { parser = new Te X Parser ( STRING , this , BOOL ) ; }
public static void gray To Binary ( Binary Variable variable ) { int n = variable . get Number Of Bits ( ) ; Bit Set gray = variable . get Bit Set ( ) ; variable . set ( n - NUM , gray . get ( n - NUM ) ) ; for ( int i = n - NUM ; i >= NUM ; i -- ) { variable . set ( i , variable . get ( i + NUM ) ^ gray . get ( i ) ) ; } }
private void update Tags ( Movie movie ) { List < String > available Tags = new Array List < > ( tags Observable ) ; for ( String tag In Movie : new Array List < > ( movie . get Tags ( ) ) ) { boolean tag Found = BOOL ; for ( String tag : available Tags ) { if ( tag In Movie . equals ( tag ) ) { tag Found = BOOL ; break ; } } if ( ! tag Found ) { add Tag ( tag In Movie ) ; } } }
protected void remove Next Protocol Messages ( List < Protocol Message > protocol Messages , int from Index ) { for ( int i = protocol Messages . size ( ) - NUM ; i >= from Index ; i -- ) { protocol Messages . remove ( i ) ; } }
public static double sigmoid ( double x ) { return NUM / ( NUM + Math . pow ( Math . E , - x ) ) ; }
public void test Radix 36 Neg ( ) { String value = STRING ; int radix = NUM ; Big Integer a Number = new Big Integer ( value , radix ) ; String result = a Number . to String ( radix ) ; assert True ( result . equals ( value ) ) ; }
public UCI Best Move stop ( ) { if ( ! is Connected ( ) ) { throw new Illegal State Exception ( STRING ) ; } if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING ) ; } UCI Best Move result = null ; synchronized ( stop Synch ) { if ( ! is Processing Go ( ) ) { result = last Best Move ; last Best Move = null ; } else { long total Sleep Time = NUM ; send ( STRING ) ; while ( go Runnable != null && total Sleep Time < NUM ) { try { Thread . sleep ( NUM ) ; total Sleep Time += NUM ; } catch ( Interrupted Exception ie ) { } } result = last Best Move ; last Best Move = null ; } } return result ; }
@ Override public boolean supports Data Definition And Data Manipulation Transactions ( ) { debug Code Call ( STRING ) ; return BOOL ; }
public static void remove Java No Op Logger ( Collection < Handler > rmv Hnds ) { Logger log = Logger . get Logger ( STRING ) ; for ( Handler h : log . get Handlers ( ) ) log . remove Handler ( h ) ; if ( ! F . is Empty ( rmv Hnds ) ) { for ( Handler h : rmv Hnds ) log . add Handler ( h ) ; } }
public void on Configuration Changed ( ) { int cur First = pager . get Current Screen ( ) * PAGE SIZE ; cal Page Size ( ) ; int new Page = cur First / PAGE SIZE ; remove View At ( NUM ) ; after Platform List Got ( ) ; pager . set Current Screen ( new Page ) ; }
private int binary Search ( final int start , final int end , final Size Tester size Tester , final Rect F available Space ) { int last Best = start ; int low = start ; int high = end - NUM ; int middle ; while ( low <= high ) { middle = low + high > > > NUM ; final int mid Val Cmp = size Tester . on Test Size ( middle , available Space ) ; if ( mid Val Cmp < NUM ) { last Best = low ; low = middle + NUM ; } else if ( mid Val Cmp > NUM ) { high = middle - NUM ; last Best = high ; } else return middle ; } return last Best ; }
protected boolean is Valid Domain ( String domain ) { Matcher ip Domain Matcher = IP DOMAIN PATTERN . matcher ( domain ) ; if ( ip Domain Matcher . matches ( ) ) { Inet Address Validator inet Address Validator = Inet Address Validator . get Instance ( ) ; return inet Address Validator . is Valid ( ip Domain Matcher . group ( NUM ) ) ; } Domain Validator domain Validator = Domain Validator . get Instance ( allow Local ) ; return domain Validator . is Valid ( domain ) || domain Validator . is Valid Tld ( domain ) ; }
public void table Switch ( final int [ ] keys , final Table Switch Generator generator , final boolean use Table ) { for ( int i = NUM ; i < keys . length ; ++ i ) { if ( keys [ i ] < keys [ i - NUM ] ) { throw new Illegal Argument Exception ( STRING ) ; } } Label def = new Label ( ) ; Label end = new Label ( ) ; if ( keys . length > NUM ) { int len = keys . length ; int min = keys [ NUM ] ; int max = keys [ len - NUM ] ; int range = max - min + NUM ; if ( use Table ) { Label [ ] labels = new Label [ range ] ; Arrays . fill ( labels , def ) ; for ( int i = NUM ; i < len ; ++ i ) { labels [ keys [ i ] - min ] = new Label ( ) ; } mv . visit Table Switch Insn ( min , max , def , labels ) ; for ( int i = NUM ; i < range ; ++ i ) { Label label = labels [ i ] ; if ( label != def ) { mark ( label ) ; generator . generate Case ( i + min , end ) ; } } } else { Label [ ] labels = new Label [ len ] ; for ( int i = NUM ; i < len ; ++ i ) { labels [ i ] = new Label ( ) ; } mv . visit Lookup Switch Insn ( def , keys , labels ) ; for ( int i = NUM ; i < len ; ++ i ) { mark ( labels [ i ] ) ; generator . generate Case ( keys [ i ] , end ) ; } } } mark ( def ) ; generator . generate Default ( ) ; mark ( end ) ; }
public void test Remainder Knuth Multi Digits By One Digit ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , - NUM , NUM , - NUM , NUM , NUM , - NUM } ; byte b Bytes [ ] = { NUM , - NUM , - NUM , - NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { NUM , - NUM , - NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . remainder ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public void test Timed Invoke Any 4 ( ) throws Throwable { Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; long start Time = System . nano Time ( ) ; List < Callable < String > > l = new Array List < Callable < String > > ( ) ; l . add ( new NPE Task ( ) ) ; try { e . invoke Any ( l , LONG DELAY MS , MILLISECONDS ) ; should Throw ( ) ; } catch ( Execution Exception success ) { assert True ( success . get Cause ( ) instanceof Null Pointer Exception ) ; } assert True ( millis Elapsed Since ( start Time ) < LONG DELAY MS ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
private void parse ( File dir ) { File [ ] xml Files = dir . list Files ( new Xml Filter ( ) ) ; for ( File xml File : xml Files ) { parse Test From Xml ( xml File ) ; } }
public boolean has Next ( int index ) { for ( int p = NUM ; p < mask . length ; p ++ ) { if ( mask [ p ] ) { if ( index <= last Element Index [ p ] ) { return BOOL ; } } } return BOOL ; }
public static boolean is External Storage Available ( ) { String state = Environment . get External Storage State ( ) ; if ( state . equals ( Environment . MEDIA MOUNTED ) ) { return BOOL ; } else { return BOOL ; } }
public Tar Entry ( byte [ ] header Buf ) { this ( ) ; parse Tar Header ( header Buf ) ; }
public static void unregister Mbeans ( M Bean Server m Bean Server ) { try { m Bean Server . unregister M Bean ( Log 4 j MX Bean Imp . get Object Name ( ) ) ; m Bean Server . unregister M Bean ( Exception MX Bean Imp . get Object Name ( ) ) ; m Bean Server . unregister M Bean ( Exception Delta MX Bean Imp . get Object Name ( ) ) ; m Bean Server . unregister M Bean ( Log 4 j Delta MX Bean Imp . get Object Name ( ) ) ; m Bean Server . unregister M Bean ( Jamon MX Bean Imp . get Object Name ( ) ) ; m Bean Server . unregister M Bean ( Http Status MX Bean Imp . get Object Name ( ) ) ; m Bean Server . unregister M Bean ( Http Status Delta MX Bean Imp . get Object Name ( ) ) ; unregister Gc MX Bean ( m Bean Server ) ; unregister Mbeans From Props File ( m Bean Server ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
public static Deterministic Key create Master Private Key ( byte [ ] seed ) throws HD Derivation Exception { check Argument ( seed . length > NUM , STRING ) ; byte [ ] i = HD Utils . hmac Sha 512 ( MASTER HMAC SHA 512 , seed ) ; check State ( i . length == NUM , i . length ) ; byte [ ] il = Arrays . copy Of Range ( i , NUM , NUM ) ; byte [ ] ir = Arrays . copy Of Range ( i , NUM , NUM ) ; Arrays . fill ( i , ( byte ) NUM ) ; Deterministic Key master Priv Key = create Master Priv Key From Bytes ( il , ir ) ; Arrays . fill ( il , ( byte ) NUM ) ; Arrays . fill ( ir , ( byte ) NUM ) ; return master Priv Key ; }
public boolean is NANPA Country ( String region Code ) { return nanpa Regions . contains ( region Code ) ; }
public void parse ( Input Stream in ) throws IO Exception , SAX Exception { try { xml Reader . set Input ( in ) ; parse All ( ) ; } catch ( XML Stream Exception e ) { if ( e . get Nested Exception ( ) instanceof IO Exception ) throw ( IO Exception ) e . get Nested Exception ( ) ; throw new SAX Exception ( e . get Message ( ) ) ; } finally { xml Reader . reset ( ) ; } }
@ Override public void print Stack Trace ( Print Stream ps ) { super . print Stack Trace ( ps ) ; if ( nested != null ) nested . print Stack Trace ( ps ) ; }
public AM Password ( char [ ] pw ) { int i ; int length = pw . length ; cleared = BOOL ; password = new char [ length ] ; System . arraycopy ( pw , NUM , password , NUM , length ) ; }
public void reset ( ) { first Step = BOOL ; N3 = NUM ; N4 = NUM ; System . arraycopy ( IV , NUM , ofb V , NUM , IV . length ) ; byte Count = NUM ; cipher . reset ( ) ; }
private static img create Control Button Image ( String name , String js command , boolean enabled ) { String Buffer img Name = new String Buffer ( STRING + name ) ; if ( ! enabled ) img Name . append ( STRING ) ; img Name . append ( STRING ) ; img img = new img ( Mobile Env . get Image Directory ( img Name . to String ( ) ) , name ) ; if ( enabled ) img . set Alt ( Msg . get Msg ( AD Language , name ) ) ; img . set ID ( STRING ) ; if ( js command != null && js command . length ( ) > NUM && enabled ) { img . set On Click ( STRING + FORM NAME + STRING + M Command + STRING + name + STRING + js command ) ; } return img ; }
public String [ ] to Array ( ) throws Exception { return Utils . split Options ( to Command Line ( ) ) ; }
public static Set < Eval Factory Node > recursive Get Child Nodes ( Eval Factory Node current Node , Eval Node Util Factory Filter filter ) { Set < Eval Factory Node > result = new Linked Hash Set < Eval Factory Node > ( ) ; if ( filter . consider ( current Node ) ) { result . add ( current Node ) ; } recursive Get Child Nodes ( result , current Node , filter ) ; return result ; }
void dispose ( ) { if ( popup != null ) { popup . remove All ( ) ; } popup = null ; }
void check Frame Value ( final Object value ) { if ( value == Opcodes . TOP || value == Opcodes . INTEGER || value == Opcodes . FLOAT || value == Opcodes . LONG || value == Opcodes . DOUBLE || value == Opcodes . NULL || value == Opcodes . UNINITIALIZED THIS ) { return ; } if ( value instanceof String ) { check Internal Name ( ( String ) value , STRING ) ; return ; } if ( ! ( value instanceof Label ) ) { throw new Illegal Argument Exception ( STRING + value ) ; } else { used Labels . add ( ( Label ) value ) ; } }
@ Override public void end Prefix Mapping ( String str ) throws SAX Exception { }
@ Override public void parse ( final Cookie cookie , final String value ) throws Malformed Cookie Exception { if ( cookie == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( value == null ) { throw new Malformed Cookie Exception ( STRING ) ; } int age = - NUM ; try { age = Integer . parse Int ( value ) ; } catch ( final Number Format Exception e ) { age = - NUM ; } if ( age < NUM ) { throw new Malformed Cookie Exception ( STRING ) ; } cookie . set Expiry Date ( new Date ( System . current Time Millis ( ) + age * NUM ) ) ; }
public Variable Config Resource ( String configuration , Text Resource base Resource ) { this ( base Resource ) ; for ( String configuration Line : configuration . split ( STRING ) ) { String [ ] config Split = configuration Line . split ( STRING ) ; add Config ( config Split [ NUM ] , config Split [ NUM ] ) ; } }
private static String read File ( String file Name ) { String class Method = STRING ; String Builder file Data = new String Builder ( ) ; String file String = STRING ; try { Buffered Reader reader = new Buffered Reader ( new File Reader ( file Name ) ) ; char [ ] buf = new char [ NUM ] ; int num Read = NUM ; while ( ( num Read = reader . read ( buf ) ) != - NUM ) { String read Data = String . value Of ( buf , NUM , num Read ) ; file Data . append ( read Data ) ; buf = new char [ NUM ] ; } reader . close ( ) ; file String = file Data . to String ( ) ; } catch ( Exception e ) { debug . error ( class Method + STRING + file Name ) ; } return file String ; }
public Scale IO Snapshot Volume Response snapshot Multi Volume ( Map < String , String > id 2 snapshot , String system Id ) throws Exception { String uri = Scale IO Constants . get Snapshot Volumes URI ( system Id ) ; Scale IO Snapshot Volumes sp Vol = new Scale IO Snapshot Volumes ( ) ; for ( Map . Entry < String , String > entry : id 2 snapshot . entry Set ( ) ) { sp Vol . add Snapshot ( entry . get Key ( ) , entry . get Value ( ) ) ; } Client Response response = post ( URI . create ( uri ) , get Json For Entity ( sp Vol ) ) ; return get Response Object ( Scale IO Snapshot Volume Response . class , response ) ; }
@ Override public String to String ( ) { return STRING + m Width + STRING + m Sum Of Weights + STRING + m TM . to String ( ) ; }
public synchronized void return Buf ( byte [ ] buf ) { if ( buf == null || buf . length > m Size Limit ) { return ; } m Buffers By Last Use . add ( buf ) ; int pos = Collections . binary Search ( m Buffers By Size , buf , BUF COMPARATOR ) ; if ( pos < NUM ) { pos = - pos - NUM ; } m Buffers By Size . add ( pos , buf ) ; m Current Size += buf . length ; trim ( ) ; }
public boolean is Draft ( ) { return draft != null && draft . boolean Value ( ) ; }
private Weather Updater ( ) { on Turn Reached ( NUM ) ; }
protected void write Data To File ( Node Holder node Holder ) throws Carbon Data Writer Exception { long offset = write Data To File ( node Holder , file Channel ) ; Blocklet Info Columnar blocklet Info = get Blocklet Info ( node Holder , offset ) ; blocklet Info List . add ( blocklet Info ) ; }
protected Container create Side Navigation Component ( Vector commands ) { return create Side Navigation Component ( commands , null ) ; }
public static double min ( double [ ] a ) { double min = Double . POSITIVE INFINITY ; for ( int i = NUM ; i < a . length ; i ++ ) { if ( Double . is Na N ( a [ i ] ) ) return Double . Na N ; if ( a [ i ] < min ) min = a [ i ] ; } return min ; }
@ Override public void on Update Selection ( int old Sel Start , int old Sel End , int new Sel Start , int new Sel End , int candidates Start , int candidates End ) { super . on Update Selection ( old Sel Start , old Sel End , new Sel Start , new Sel End , candidates Start , candidates End ) ; if ( m Composing . length ( ) > NUM && ( new Sel Start != candidates End || new Sel End != candidates End ) ) { m Composing . set Length ( NUM ) ; update Candidates ( ) ; Input Connection ic = get Current Input Connection ( ) ; if ( ic != null ) { ic . finish Composing Text ( ) ; } } }
public < T > T map To ( final Class < T > mapping Class ) { return map To ( mapping Class , null ) ; }
private Array List < Spinner Language Element > create Spinner Languages ( int avoid Language ) { Array List < Spinner Language Element > result = new Array List < Spinner Language Element > ( ) ; List < String > languages = m Session Options . all Languages ( ) ; for ( int i = NUM ; i < languages . size ( ) ; ++ i ) { if ( i != avoid Language ) { result . add ( new Spinner Language Element ( languages . get ( i ) , i ) ) ; } } return result ; }
private String user Agent ( ) { return m User Agent ; }
protected void collect Properties ( Class < ? > type , Type < ? > reference Type , Map < String , Property > properties ) { try { Bean Info bean Info = Introspector . get Bean Info ( type ) ; Property Descriptor [ ] descriptors = bean Info . get Property Descriptors ( ) ; for ( final Property Descriptor pd : descriptors ) { try { Method read Method = get Read Method ( pd , type ) ; Method write Method = get Write Method ( pd , type , null ) ; Property property = process Property ( pd . get Name ( ) , pd . get Property Type ( ) , read Method , write Method , type , reference Type , properties ) ; post Process Property ( property , pd , read Method , write Method , type , reference Type , properties ) ; } catch ( final Exception e ) { throw new Runtime Exception ( STRING + reference Type . get Canonical Name ( ) + STRING + pd . get Name ( ) + STRING , e ) ; } } } catch ( Introspection Exception e ) { throw new Runtime Exception ( e ) ; } }
private void before Key ( ) throws JSON Exception { Scope context = peek ( ) ; if ( context == Scope . NONEMPTY OBJECT ) { out . append ( STRING ) ; } else if ( context != Scope . EMPTY OBJECT ) { throw new JSON Exception ( STRING ) ; } newline ( ) ; replace Top ( Scope . DANGLING KEY ) ; }
public void add Header View ( View v , Object data , boolean is Selectable ) { if ( m Adapter != null && ! ( m Adapter instanceof Header View List Adapter ) ) { throw new Illegal State Exception ( STRING ) ; } Fixed View Info info = new Fixed View Info ( ) ; info . view = v ; info . data = data ; info . is Selectable = is Selectable ; m Header View Infos . add ( info ) ; if ( m Adapter != null && m Observer != null ) { m Observer . on Changed ( ) ; } }
private void render Operator Background ( final Operator operator , final Graphics 2 D g2 ) { Rectangle 2 D frame = model . get Operator Rect ( operator ) ; if ( frame == null ) { return ; } Round Rectangle 2 D background = new Round Rectangle 2 D . Double ( frame . get X ( ) - NUM , frame . get Y ( ) - NUM , frame . get Width ( ) + NUM , frame . get Height ( ) + NUM , OPERATOR BG CORNER , OPERATOR BG CORNER ) ; g2 . set Color ( Color . WHITE ) ; g2 . fill ( background ) ; Rectangle 2 D name Bounds = OPERATOR FONT . get String Bounds ( operator . get Name ( ) , g2 . get Font Render Context ( ) ) ; if ( name Bounds . get Width ( ) > frame . get Width ( ) ) { double relevant Width = Math . min ( name Bounds . get Width ( ) , frame . get Width ( ) * MAX HEADER RATIO ) ; double offset = ( frame . get Width ( ) - relevant Width ) / NUM ; int x = ( int ) ( frame . get X ( ) + offset ) ; int padding = NUM ; Round Rectangle 2 D name Background = new Round Rectangle 2 D . Double ( ( int ) Math . min ( frame . get X ( ) - padding , x - padding ) , frame . get Y ( ) - NUM , relevant Width + NUM * padding , Process Renderer Model . HEADER HEIGHT + NUM , OPERATOR BG CORNER , OPERATOR BG CORNER ) ; g2 . fill ( name Background ) ; } render Ports Background ( operator . get Input Ports ( ) , g2 ) ; render Ports Background ( operator . get Output Ports ( ) , g2 ) ; }
protected void option Window ( Action Event e ) { if ( options Frame == null ) { options Frame = new Jmri J Frame ( Bundle . get Message ( STRING ) , BOOL , BOOL ) ; options Pane = options Frame . get Content Pane ( ) ; options Pane . set Layout ( new Box Layout ( options Frame . get Content Pane ( ) , Box Layout . Y AXIS ) ) ; clear Entry . set Selected Index ( nx Pairs . get Clear Down Option ( ) ) ; J Panel p1 = new J Panel ( ) ; clear Entry . set Tool Tip Text ( STRING ) ; p1 . add ( new J Label ( Bundle . get Message ( STRING ) ) ) ; p1 . add ( clear Entry ) ; options Pane . add ( p1 ) ; J Panel p2 = new J Panel ( ) ; initialize Color Combo ( setting Track Color Box ) ; set Color Combo ( setting Track Color Box , nx Pairs . get Setting Route Color ( ) ) ; Action Listener setting Track Color Listener = null ; setting Track Color Box . add Action Listener ( setting Track Color Listener ) ; p2 . add ( new J Label ( Bundle . get Message ( STRING ) ) ) ; p2 . add ( setting Track Color Box ) ; options Pane . add ( p2 ) ; duration Setting . set Text ( STRING + nx Pairs . get Setting Timer ( ) ) ; if ( nx Pairs . use Different Color When Setting ( ) ) { duration Setting . set Enabled ( BOOL ) ; } else { duration Setting . set Enabled ( BOOL ) ; } J Panel p3 = new J Panel ( ) ; p3 . add ( new J Label ( Bundle . get Message ( STRING ) ) ) ; p3 . add ( duration Setting ) ; options Pane . add ( p3 ) ; J Panel p4 = new J Panel ( ) ; p4 . add ( dispatcher Use ) ; dispatcher Use . set Selected ( nx Pairs . get Dispatcher Integration ( ) ) ; options Pane . add ( p4 ) ; J Button ok = new J Button ( Bundle . get Message ( STRING ) ) ; options Pane . add ( ok ) ; ok . add Action Listener ( null ) ; } options Frame . pack ( ) ; options Frame . set Visible ( BOOL ) ; }
public void make Existing Demand Bill Inactive ( String assessment No ) { Demand Bill Service demand Bill Service = ( Demand Bill Service ) bean Provider . get Bean ( STRING ) ; demand Bill Service . make Demand Bill Inactive ( assessment No ) ; }
public void write ( Data Output out ) throws IO Exception { Writable Utils . write V Int ( out , length ) ; out . write ( bytes , NUM , length ) ; }
int character Class ( ) throws RE Syntax Exception { if ( pattern . char At ( idx ) != STRING ) { internal Error ( ) ; } if ( ( idx + NUM ) >= len || pattern . char At ( ++ idx ) == STRING ) { syntax Error ( STRING ) ; } if ( idx < len && pattern . char At ( idx ) == STRING ) { idx ++ ; int idx Start = idx ; while ( idx < len && pattern . char At ( idx ) >= STRING && pattern . char At ( idx ) <= STRING ) { idx ++ ; } if ( ( idx + NUM ) < len && pattern . char At ( idx ) == STRING && pattern . char At ( idx + NUM ) == STRING ) { String char Class = pattern . substring ( idx Start , idx ) ; Character i = ( Character ) hash POSIX . get ( char Class ) ; if ( i != null ) { idx += NUM ; return node ( RE . OP POSIXCLASS , i . char Value ( ) ) ; } syntax Error ( STRING + char Class + STRING ) ; } syntax Error ( STRING ) ; } int ret = node ( RE . OP ANYOF , NUM ) ; char CHAR INVALID = Character . MAX VALUE ; char last = CHAR INVALID ; char simple Char ; boolean include = BOOL ; boolean defining Range = BOOL ; int idx First = idx ; char range Start = Character . MIN VALUE ; char range End ; RE Range range = new RE Range ( ) ; while ( idx < len && pattern . char At ( idx ) != STRING ) { switch On Character : switch ( pattern . char At ( idx ) ) { case STRING : include = ! include ; if ( idx == idx First ) { range . include ( Character . MIN VALUE , Character . MAX VALUE , BOOL ) ; } idx ++ ; continue ; case STRING : { int c ; switch ( c = escape ( ) ) { case ESC COMPLEX : case ESC BACKREF : syntax Error ( STRING ) ; case ESC CLASS : if ( defining Range ) { syntax Error ( STRING ) ; } switch ( pattern . char At ( idx - NUM ) ) { case RE . E NSPACE : range . include ( Character . MIN VALUE , NUM , include ) ; range . include ( ( char ) NUM , include ) ; range . include ( NUM , NUM , include ) ; range . include ( NUM , Character . MAX VALUE , include ) ; break ; case RE . E NALNUM : range . include ( Character . MIN VALUE , STRING , include ) ; range . include ( STRING , STRING , include ) ; range . include ( STRING , STRING , include ) ; range . include ( STRING , include ) ; range . include ( STRING , Character . MAX VALUE , include ) ; break ; case RE . E NDIGIT : range . include ( Character . MIN VALUE , STRING , include ) ; range . include ( STRING , Character . MAX VALUE , include ) ; break ; case RE . E SPACE : range . include ( STRING , include ) ; range . include ( STRING , include ) ; range . include ( STRING , include ) ; range . include ( STRING , include ) ; range . include ( STRING , include ) ; range . include ( STRING , include ) ; break ; case RE . E ALNUM : range . include ( STRING , STRING , include ) ; range . include ( STRING , STRING , include ) ; range . include ( STRING , include ) ; case RE . E DIGIT : range . include ( STRING , STRING , include ) ; break ; } last = CHAR INVALID ; break ; default : simple Char = ( char ) c ; break switch On Character ; } } continue ; case STRING : if ( defining Range ) { syntax Error ( STRING ) ; } defining Range = BOOL ; range Start = ( last == CHAR INVALID ? NUM : last ) ; if ( ( idx + NUM ) < len && pattern . char At ( ++ idx ) == STRING ) { simple Char = Character . MAX VALUE ; break ; } continue ; default : simple Char = pattern . char At ( idx ++ ) ; break ; } if ( defining Range ) { range End = simple Char ; if ( range Start >= range End ) { syntax Error ( STRING ) ; } range . include ( range Start , range End , include ) ; last = CHAR INVALID ; defining Range = BOOL ; } else { if ( idx >= len || pattern . char At ( idx ) != STRING ) { range . include ( simple Char , include ) ; } last = simple Char ; } } if ( idx == len ) { syntax Error ( STRING ) ; } idx ++ ; instruction [ ret + RE . offset Opdata ] = ( char ) range . num ; for ( int i = NUM ; i < range . num ; i ++ ) { emit ( ( char ) range . min Range [ i ] ) ; emit ( ( char ) range . max Range [ i ] ) ; } return ret ; }
public static byte [ ] decode ( byte [ ] data ) { int len = data . length / NUM * NUM ; Byte Array Output Stream b Out = new Byte Array Output Stream ( len ) ; try { encoder . decode ( data , NUM , data . length , b Out ) ; } catch ( Exception e ) { throw new Decoder Exception ( STRING + e . get Message ( ) , e ) ; } return b Out . to Byte Array ( ) ; }
@ Override public int do Final ( final byte [ ] out , final int out Off ) throws Bad Ciphertext Exception { complete = BOOL ; int written = content Crypto Handler . do Final ( out , out Off ) ; update Trailing Signature ( out , out Off , written ) ; if ( crypto Algo . get Trailing Signature Length ( ) > NUM ) { try { Ciphertext Footers footer = new Ciphertext Footers ( trailing Sig . sign ( ) ) ; byte [ ] f Bytes = footer . to Byte Array ( ) ; System . arraycopy ( f Bytes , NUM , out , out Off + written , f Bytes . length ) ; return written + f Bytes . length ; } catch ( final Signature Exception ex ) { throw new Aws Crypto Exception ( ex ) ; } } else { return written ; } }
public void hide All Budges ( ) { for ( Relative Layout badge : badge List ) { if ( badge . get Visibility ( ) == VISIBLE ) Badge Helper . hide Badge ( badge ) ; } badge Save Instance Hash Map . clear ( ) ; }
public Element render ( SVG Plot svgp ) { Element tag = svgp . svg Element ( SVG Constants . SVG G TAG ) ; Element button = svgp . svg Rect ( x , y , w , h ) ; if ( ! Double . is Na N ( r ) ) { SVG Util . set Att ( button , SVG Constants . SVG RX ATTRIBUTE , r ) ; SVG Util . set Att ( button , SVG Constants . SVG RY ATTRIBUTE , r ) ; } SVG Util . set Att ( button , SVG Constants . SVG STYLE ATTRIBUTE , butcss . inline CSS ( ) ) ; tag . append Child ( button ) ; if ( svgp . get Id Element ( SVG Effects . LIGHT GRADIENT ID ) != null ) { Element light = svgp . svg Rect ( x , y , w , h ) ; if ( ! Double . is Na N ( r ) ) { SVG Util . set Att ( light , SVG Constants . SVG RX ATTRIBUTE , r ) ; SVG Util . set Att ( light , SVG Constants . SVG RY ATTRIBUTE , r ) ; } SVG Util . set Att ( light , SVG Constants . SVG STYLE ATTRIBUTE , STRING + SVG Effects . LIGHT GRADIENT ID + STRING ) ; tag . append Child ( light ) ; } if ( svgp . get Id Element ( SVG Effects . SHADOW ID ) != null ) { button . set Attribute ( SVG Constants . SVG FILTER ATTRIBUTE , STRING + SVG Effects . SHADOW ID + STRING ) ; } if ( title != null ) { Element label = svgp . svg Text ( x + w * NUM , y + h * NUM , title ) ; label . set Attribute ( SVG Constants . SVG STYLE ATTRIBUTE , titlecss . inline CSS ( ) ) ; tag . append Child ( label ) ; } return tag ; }
public void add ( String gram ) { if ( name == null || gram == null ) return ; int len = gram . length ( ) ; if ( len < NUM || len > N Gram . N GRAM ) return ; ++ n words [ len - NUM ] ; if ( freq . contains Key ( gram ) ) { freq . put ( gram , freq . get ( gram ) + NUM ) ; } else { freq . put ( gram , NUM ) ; } }
public void test addressing ( ) { final Journal store = ( Journal ) get Store ( ) ; try { final RW Strategy buffer Strategy = ( RW Strategy ) store . get Buffer Strategy ( ) ; final RW Store rw = buffer Strategy . get Store ( ) ; final Array List < Integer > sizes = new Array List < Integer > ( ) ; final Tree Map < Long , Integer > paddrs = new Tree Map < Long , Integer > ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { final int s = r . next Int ( NUM ) + NUM ; sizes . add ( s ) ; final int a = rw . alloc ( s , null ) ; final long pa = rw . physical Address ( a ) ; assert True ( paddrs . get ( pa ) == null ) ; paddrs . put ( pa , a ) ; } for ( int i = NUM ; i < NUM ; i ++ ) { final int s = r . next Int ( NUM ) + NUM ; sizes . add ( s ) ; final int a = rw . alloc ( s , null ) ; final long pa = rw . physical Address ( a ) ; paddrs . put ( pa , a ) ; } } finally { store . destroy ( ) ; } }
public void handle Client Membership ( String client Id , int event Type ) { String notif Type = null ; List < Managed Resource > cleaned Up = null ; if ( event Type == Client Membership Message . LEFT ) { notif Type = NOTIF CLIENT LEFT ; cleaned Up = cleanup Bridge Client Resources ( client Id ) ; } else if ( event Type == Client Membership Message . CRASHED ) { notif Type = NOTIF CLIENT CRASHED ; cleaned Up = cleanup Bridge Client Resources ( client Id ) ; } else if ( event Type == Client Membership Message . JOINED ) { notif Type = NOTIF CLIENT JOINED ; } if ( cleaned Up != null ) { for ( Managed Resource resource : cleaned Up ) { M Bean Util . unregister M Bean ( resource ) ; } } Helper . send Notification ( this , new Notification ( notif Type , this . model M Bean , Helper . get Next Notification Sequence Number ( ) , client Id ) ) ; }
public < V extends Comparable < ? super V > > Optional Double max By ( Double Function < V > key Extractor ) { Obj Double Box < V > result = collect ( null , null , null ) ; return result . a == null ? Optional Double . empty ( ) : Optional Double . of ( result . b ) ; }
private J Label add Keybind Label ( J Panel panel , String label Text ) { Grid Bag Constraints gbc = new Grid Bag Constraints ( ) ; gbc . anchor = Grid Bag Constraints . WEST ; gbc . insets = new Insets ( NUM , NUM , NUM , NUM ) ; gbc . gridx = NUM ; gbc . gridy = keybind Label Grid Y Counter ++ ; gbc . weightx = NUM ; J Label jlbl = new J Label ( label Text ) ; panel . add ( jlbl , gbc ) ; return jlbl ; }
public static boolean is Letter Or Number ( int c ) { return is Letter ( c ) || is Number ( c ) ; }
public String season Summary Str ( ) { set Team Ranks ( ) ; String Builder sb = new String Builder ( ) ; sb . append ( ncg Summary Str ( ) ) ; sb . append ( STRING + user Team . season Summary Str ( ) ) ; sb . append ( STRING + league Records . broken Records Str ( get Year ( ) , user Team . abbr ) ) ; return sb . to String ( ) ; }
public void add End Bumper ( ) { num End Bumpers ++ ; String name = STRING ; boolean duplicate = BOOL ; while ( duplicate ) { name = STRING + num End Bumpers ; if ( finder . find Positionable Point By Name ( name ) == null ) { duplicate = BOOL ; } if ( duplicate ) { num End Bumpers ++ ; } } Positionable Point o = new Positionable Point ( name , Positionable Point . END BUMPER , current Point , this ) ; point List . add ( o ) ; set Dirty ( BOOL ) ; }
public Map < String , Object > convert Data To Objects ( Map < String , String > data ) { Map < String , Object > results = new Hash Map < > ( ) ; if ( data != null ) { for ( String key : data . key Set ( ) ) { results . put ( key , data . get ( key ) ) ; } } return results ; }
public int pixel For ( Color c ) { return pixel For ( c . get RGB ( ) ) ; }
void strip Non Compiled Nodes ( Node n , Set < String > files To Compile ) { for ( Node child : n . children ( ) ) { if ( ! files To Compile . contains ( child . get Source File Name ( ) ) ) { child . detach From Parent ( ) ; } } }
protected void restore Base URI ( ) { f Base URI . pop ( ) ; f Literal System ID . pop ( ) ; f Expanded System ID . pop ( ) ; f Base URI Scope . pop ( ) ; f Current Base URI . set Base System Id ( ( String ) f Base URI . peek ( ) ) ; f Current Base URI . set Literal System Id ( ( String ) f Literal System ID . peek ( ) ) ; f Current Base URI . set Expanded System Id ( ( String ) f Expanded System ID . peek ( ) ) ; }
private boolean check Touch Slop ( View child , float dx , float dy ) { if ( child == null ) { return BOOL ; } final boolean check Horizontal = m Callback . get View Horizontal Drag Range ( child ) > NUM ; final boolean check Vertical = m Callback . get View Vertical Drag Range ( child ) > NUM ; if ( check Horizontal && check Vertical ) { return dx * dx + dy * dy > m Touch Slop * m Touch Slop ; } else if ( check Horizontal ) { return Math . abs ( dx ) > m Touch Slop ; } else if ( check Vertical ) { return Math . abs ( dy ) > m Touch Slop ; } return BOOL ; }
public void test To Big Integer Pos 1 ( ) { String a = STRING ; Big Integer b Number = new Big Integer ( STRING ) ; Big Decimal a Number = new Big Decimal ( a ) ; Big Integer result = a Number . to Big Integer ( ) ; assert True ( STRING , result . equals ( b Number ) ) ; }
public static boolean as Boolean ( Char Sequence string ) { return string . length ( ) > NUM ; }
public void initialize ( ) { Texture State ts = new Texture State ( ) ; ts . set Enabled ( BOOL ) ; set Render State ( ts ) ; for ( int i = NUM ; i < landmark List . size ( ) ; ++ i ) { Landmark State state = landmark List . get ( i ) ; add Landmark ( state , BOOL ) ; } z Buffer State = new Z Buffer State ( ) ; z Buffer State . set Function ( Z Buffer State . Test Function . Less Than Or Equal To ) ; z Buffer State . set Enabled ( BOOL ) ; set Render State ( z Buffer State ) ; }
public List < JC Compilation Unit > enter Trees ( List < JC Compilation Unit > roots ) { if ( ! task Listener . is Empty ( ) ) { for ( JC Compilation Unit unit : roots ) { Task Event e = new Task Event ( Task Event . Kind . ENTER , unit ) ; task Listener . started ( e ) ; } } enter . main ( roots ) ; if ( ! task Listener . is Empty ( ) ) { for ( JC Compilation Unit unit : roots ) { Task Event e = new Task Event ( Task Event . Kind . ENTER , unit ) ; task Listener . finished ( e ) ; } } if ( need Root Classes || source Output || stub Output ) { List Buffer < JC Class Decl > cdefs = new List Buffer < > ( ) ; for ( JC Compilation Unit unit : roots ) { for ( List < JC Tree > defs = unit . defs ; defs . non Empty ( ) ; defs = defs . tail ) { if ( defs . head instanceof JC Class Decl ) cdefs . append ( ( JC Class Decl ) defs . head ) ; } } root Classes = cdefs . to List ( ) ; } for ( JC Compilation Unit unit : roots ) { input Files . add ( unit . sourcefile ) ; } return roots ; }
final V replace Node ( long key , V value , Object cv ) { int hash = spread ( key ) ; for ( Node < V > [ ] tab = table ; ; ) { Node < V > f ; int n , i , fh ; if ( tab == null || ( n = tab . length ) == NUM || ( f = tab At ( tab , i = ( n - NUM ) & hash ) ) == null ) { break ; } else if ( ( fh = f . hash ) == MOVED ) { tab = help Transfer ( tab , f ) ; } else { V old Val = null ; boolean validated = BOOL ; synchronized ( f ) { if ( tab At ( tab , i ) == f ) { if ( fh >= NUM ) { validated = BOOL ; for ( Node < V > e = f , pred = null ; ; ) { if ( ( e . key == key ) ) { V ev = e . val ; if ( cv == null || cv == ev || ( ev != null && cv . equals ( ev ) ) ) { old Val = ev ; if ( value != null ) { e . val = value ; } else if ( pred != null ) { pred . next = e . next ; } else { set Tab At ( tab , i , e . next ) ; } } break ; } pred = e ; if ( ( e = e . next ) == null ) { break ; } } } else if ( f instanceof Tree Bin ) { validated = BOOL ; Tree Bin < V > t = ( Tree Bin < V > ) f ; Tree Node < V > r , p ; if ( ( r = t . root ) != null && ( p = r . find Tree Node ( hash , key ) ) != null ) { V pv = p . val ; if ( cv == null || cv == pv || ( pv != null && cv . equals ( pv ) ) ) { old Val = pv ; if ( value != null ) { p . val = value ; } else if ( t . remove Tree Node ( p ) ) { set Tab At ( tab , i , untreeify ( t . first ) ) ; } } } } } } if ( validated ) { if ( old Val != null ) { if ( value == null ) { add Count ( - NUM , - NUM ) ; } return old Val ; } break ; } } } return null ; }
public static Line By Line File Input Operator checkpoint ( Line By Line File Input Operator oper , Byte Array Output Stream bos ) throws Exception { Kryo kryo = new Kryo ( ) ; Output loutput = new Output ( bos ) ; kryo . write Object ( loutput , oper ) ; loutput . close ( ) ; Input l Input = new Input ( bos . to Byte Array ( ) ) ; @ Suppress Warnings ( STRING ) Line By Line File Input Operator check Pointed Oper = kryo . read Object ( l Input , oper . get Class ( ) ) ; l Input . close ( ) ; return check Pointed Oper ; }
public static String explode ( Collection < String > collection , String delimiter ) { String Builder sb = new String Builder ( ) ; if ( ! collection . is Empty ( ) ) { Iterator < String > i = collection . iterator ( ) ; sb . append ( i . next ( ) ) ; while ( i . has Next ( ) ) { sb . append ( delimiter ) ; sb . append ( i . next ( ) ) ; } } return sb . to String ( ) ; }
@ Override public int hash Code ( ) { return fully Qualified Name . hash Code ( ) ; }
@ Override public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( NUM ) ; new Vector . add Element ( STRING ) ; return new Vector . elements ( ) ; }
public static void write Statistics ( T Double Object Hash Map < Descriptive Statistics > stats Map , String key Label , String file ) throws IO Exception { double [ ] keys = stats Map . keys ( ) ; Arrays . sort ( keys ) ; Buffered Writer writer = new Buffered Writer ( new File Writer ( file ) ) ; writer . write ( key Label ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . new Line ( ) ; for ( double key : keys ) { Descriptive Statistics stats = stats Map . get ( key ) ; writer . write ( String . value Of ( key ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Mean ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Percentile ( NUM ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Min ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get Max ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( stats . get N ( ) ) ) ; writer . new Line ( ) ; } writer . close ( ) ; }
public void action Performed ( Action Event e ) { if ( ! check Modified ( ) ) return ; if ( m Script . get Filename ( ) == null ) return ; try { m Script . start ( m Args ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; J Option Pane . show Message Dialog ( File Scripting Panel . this , STRING + ex , STRING , J Option Pane . ERROR MESSAGE ) ; } }
static String encode Stub ( RMI Server rmi Server , Map < String , ? > env ) throws IO Exception { if ( IIOP Helper . is Stub ( rmi Server ) ) return STRING + encode IIOP Stub ( rmi Server , env ) ; else return STRING + encode JRMP Stub ( rmi Server , env ) ; }
public int line To Y ( int line ) { Font Metrics fm = painter . get Font Metrics ( ) ; return ( line - first Line ) * fm . get Height ( ) - ( fm . get Leading ( ) + fm . get Max Descent ( ) ) ; }
private void handle Double Click ( Double Click Event e ) { I Selection selection = e . get Selection ( ) ; if ( selection instanceof I Structured Selection ) { I Structured Selection structured = ( I Structured Selection ) selection ; if ( structured . size ( ) == NUM ) { Object first = structured . get First Element ( ) ; if ( first instanceof ISVN Remote File ) { open Action . selection Changed ( null , selection ) ; open Action . run ( null ) ; } else { tree Viewer . set Expanded State ( first , ! tree Viewer . get Expanded State ( first ) ) ; } } } }
public CSV Result Set Configuration ( ) { }
protected File choose File ( int type ) { Frame frame = get Frame ( ) ; File f = null ; if ( file Chooser == null ) file Chooser = new J File Chooser ( ) ; file Chooser . set Current Directory ( E00 File ) ; if ( type == NUM ) file Chooser . set Dialog Type ( J File Chooser . OPEN DIALOG ) ; else file Chooser . set Dialog Type ( J File Chooser . SAVE DIALOG ) ; int retval = file Chooser . show Dialog ( frame , null ) ; if ( retval == J File Chooser . APPROVE OPTION ) f = file Chooser . get Selected File ( ) ; return f ; }
public void pixellate ( Font Render Context render FRC , Point 2 D loc , Point px Result ) { if ( render FRC == null ) { render FRC = frc ; } Affine Transform at = render FRC . get Transform ( ) ; at . transform ( loc , loc ) ; px Result . x = ( int ) loc . get X ( ) ; px Result . y = ( int ) loc . get Y ( ) ; loc . set Location ( px Result . x , px Result . y ) ; try { at . inverse Transform ( loc , loc ) ; } catch ( Noninvertible Transform Exception e ) { throw new Illegal Argument Exception ( STRING ) ; } }
public static long start Time ( ) { return System . nano Time ( ) ; }
@ Transactional public int delete All ( ) { List < T > all Entities = retrieve All ( ) ; for ( T entity : all Entities ) { delete ( entity ) ; } return all Entities . size ( ) ; }
private GS Message Impl receive From Queue ( long timeout ) throws Receive From Queue Exception { Transaction txn = m session . get Transaction ( ) ; if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING + txn ) ; } try { return ( GS Message Impl ) m space . take ( m jms Message Template , txn , timeout ) ; } catch ( Exception e ) { throw new Receive From Queue Exception ( e ) ; } }
public static void write Byte Array To File ( File file , byte [ ] data , boolean append ) throws IO Exception { Output Stream out = null ; try { out = open Output Stream ( file , append ) ; out . write ( data ) ; out . close ( ) ; } finally { IO Utils . close Quietly ( out ) ; } }
public String find Next ( boolean previous Flipped ) { boolean reset Is Flipped = BOOL ; if ( previous Flipped && count > NUM ) { if ( ! value Iterator . has Next ( ) ) { value Iterator = values . iterator ( ) ; index = NUM ; is Flipped = BOOL ; reset Is Flipped = BOOL ; } else { index ++ ; } current Value = value Iterator . next ( ) ; } count ++ ; if ( reset Is Flipped ) { is Flipped = BOOL ; } return current Value ; }
public static boolean is Not Empty ( List < Object > list ) { return ! list . is Empty ( ) ; }
private Registration Result check Password ( String password , String confirm Password ) { if ( ( password == null ) || password . length ( ) == NUM ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING ) ; } return Registration Result . NO PASSWORD ERROR ; } else { if ( password . length ( ) < required Password Length ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING ) ; } return Registration Result . PASSWORD TOO SHORT ; } if ( ( confirm Password == null ) || confirm Password . length ( ) == NUM ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING ) ; } return Registration Result . NO CONFIRMATION ERROR ; } else { if ( ! password . equals ( confirm Password ) ) { return Registration Result . PASSWORD MISMATCH ERROR ; } } } return Registration Result . NO ERROR ; }
private static LDAP Filter create AND Filter ( Filter Set filter Set ) throws LDAP Exception , IO Exception { List < JAXB Element < ? > > list = filter Set . get Filter Group ( ) ; Array List < Raw Filter > filters = new Array List < > ( list . size ( ) ) ; for ( JAXB Element < ? > filter : list ) { filters . add ( create Filter ( filter ) ) ; } return LDAP Filter . create AND Filter ( filters ) ; }
void calculate Utility ( Firing Plan firing Plan , int overheat Tolerance , boolean shooter Is Aero ) { int overheat = NUM ; if ( firing Plan . get Heat ( ) > overheat Tolerance ) { overheat = firing Plan . get Heat ( ) - overheat Tolerance ; } double modifier = NUM ; modifier += calc Command Utility ( firing Plan . get Target ( ) ) ; modifier += calc Strategic Building Target Utility ( firing Plan . get Target ( ) ) ; modifier += calc Priority Unit Target Utility ( firing Plan . get Target ( ) ) ; double utility = NUM ; utility += DAMAGE UTILITY * firing Plan . get Expected Damage ( ) ; utility += CRITICAL UTILITY * firing Plan . get Expected Criticals ( ) ; utility += KILL UTILITY * firing Plan . get Kill Probability ( ) ; utility *= calc Target Potential Damage Multiplier ( firing Plan . get Target ( ) ) ; utility += TARGET HP FRACTION DEALT UTILITY * calc Damage Allocation Utility ( firing Plan . get Target ( ) , firing Plan . get Expected Damage ( ) ) ; utility -= calc Civilian Target Disutility ( firing Plan . get Target ( ) ) ; utility *= modifier ; utility -= ( shooter Is Aero ? OVERHEAT DISUTILITY AERO : OVERHEAT DISUTILITY ) * overheat ; utility -= ( firing Plan . get Target ( ) instanceof Mech Warrior ) ? EJECTED PILOT DISUTILITY : NUM ; firing Plan . set Utility ( utility ) ; }
public void put ( String key , double value ) { if ( value == Double . POSITIVE INFINITY ) { put ( key , STRING ) ; } else if ( value == Double . NEGATIVE INFINITY ) { put ( key , STRING ) ; } else { put ( key , Double . to String ( value ) ) ; } }
public void test fill$FIIF ( ) { float val = Float . MAX VALUE ; float d [ ] = new float [ NUM ] ; Arrays . fill ( d , NUM , d . length , val ) ; for ( int i = NUM ; i < NUM ; i ++ ) assert True ( STRING , ! ( d [ i ] == val ) ) ; for ( int i = NUM ; i < d . length ; i ++ ) assert True ( STRING , d [ i ] == val ) ; try { Arrays . fill ( d , NUM , NUM , val ) ; fail ( STRING ) ; } catch ( Illegal Argument Exception e ) { } try { Arrays . fill ( d , - NUM , NUM , val ) ; fail ( STRING ) ; } catch ( Array Index Out Of Bounds Exception e ) { } try { Arrays . fill ( d , NUM , d . length + NUM , val ) ; fail ( STRING ) ; } catch ( Array Index Out Of Bounds Exception e ) { } }
public static long persian To Julian ( long year , int month , int day ) { return NUM * ( ( ceil ( year - NUM , NUM ) + NUM ) - NUM ) + ( ( long ) Math . floor ( ( NUM * ( ceil ( year - NUM , NUM ) + NUM ) - NUM ) / NUM ) ) + ( Persian Calendar Constants . PERSIAN EPOCH - NUM ) + NUM * ( ( long ) Math . floor ( ( year - NUM ) / NUM ) ) + ( month < NUM ? NUM * month : NUM * month + NUM ) + day ; }
@ Override public void mouse Dragged ( Mouse Event evt ) { int x Trans = NUM ; int y Trans = NUM ; if ( slider . get Snap To Ticks ( ) ) { int pos = get Location For Value ( get Snapped Value ( evt ) ) ; if ( pos > - NUM ) { if ( slider . get Orientation ( ) == J Slider . HORIZONTAL ) { x Trans = pos - evt . get X ( ) + offset ; evt . translate Point ( x Trans , NUM ) ; } else { y Trans = pos - evt . get Y ( ) + offset ; evt . translate Point ( NUM , y Trans ) ; } } } delegate . mouse Dragged ( evt ) ; evt . translate Point ( x Trans , y Trans ) ; }
@ Override final Node < K , V > find ( int h , Object k ) { if ( k != null ) { for ( Node < K , V > e = first ; e != null ; e = e . next ) { int s ; K ek ; if ( ( ( s = lock State ) & ( WAITER | WRITER ) ) != NUM ) { if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; } else if ( U . compare And Swap Int ( this , LOCKSTATE , s , s + READER ) ) { Tree Node < K , V > r , p ; try { p = ( ( r = root ) == null ? null : r . find Tree Node ( h , k , null ) ) ; } finally { Thread w ; int ls ; do { } while ( ! U . compare And Swap Int ( this , LOCKSTATE , ls = lock State , ls - READER ) ) ; if ( ls == ( READER | WAITER ) && ( w = waiter ) != null ) Lock Support . unpark ( w ) ; } return p ; } } } return null ; }
public void stop Enumeration ( Enumeration Deletion Context aws ) { aws . compute Enumeration Request . enumeration Action = Enumeration Action . STOP ; handle Enumeration Request For Deletion ( aws ) ; }
public static void do Restart ( Context c ) { try { if ( c != null ) { Package Manager pm = c . get Package Manager ( ) ; if ( pm != null ) { Intent m Start Activity = pm . get Launch Intent For Package ( c . get Package Name ( ) ) ; if ( m Start Activity != null ) { m Start Activity . add Flags ( Intent . FLAG ACTIVITY CLEAR TOP ) ; int m Pending Intent Id = NUM ; Pending Intent m Pending Intent = Pending Intent . get Activity ( c , m Pending Intent Id , m Start Activity , Pending Intent . FLAG CANCEL CURRENT ) ; Alarm Manager mgr = ( Alarm Manager ) c . get System Service ( Context . ALARM SERVICE ) ; mgr . set ( Alarm Manager . RTC , System . current Time Millis ( ) + NUM , m Pending Intent ) ; System . exit ( NUM ) ; } else { Log . e ( STRING , STRING ) ; } } else { Log . e ( STRING , STRING ) ; } } else { Log . e ( STRING , STRING ) ; } } catch ( Exception ex ) { Log . e ( STRING , STRING ) ; } }
public Collection < Object > values ( ) { Array List < Object > answer = new Array List < Object > ( read Methods . size ( ) ) ; for ( Iterator < Object > iter = value Iterator ( ) ; iter . has Next ( ) ; ) { answer . add ( iter . next ( ) ) ; } return Collections . unmodifiable List ( answer ) ; }
protected Date Time Data parse ( String str ) throws Schema Date Time Exception { Date Time Data date = new Date Time Data ( str , this ) ; int len = str . length ( ) ; int end = get Year Month ( str , NUM , len , date ) ; date . day = DAY ; parse Time Zone ( str , end , len , date ) ; validate Date Time ( date ) ; save Unnormalized ( date ) ; if ( date . utc != NUM && date . utc != STRING ) { normalize ( date ) ; } date . position = NUM ; return date ; }
public Array Val ( double [ ] values ) { this . array = new double [ values . length ] ; for ( int i = NUM ; i < array . length ; i ++ ) { array [ i ] = values [ i ] ; } hashcode = Arrays . hash Code ( array ) ; }
public void add Child ( String child ) { if ( child == null ) { return ; } String child Path = path . ends With ( STRING ) ? path + child : path + STRING + child ; children . add ( new Zk Node ( child Path ) ) ; }
@ Visible For Testing public static boolean send To T Master ( String command , String topology Name , Scheduler State Manager Adaptor state Manager , Network Utils . Tunnel Config tunnel Config ) { LOG . fine ( STRING + topology Name ) ; Topology Master . T Master Location location = state Manager . get T Master Location ( topology Name ) ; if ( location == null ) { LOG . severe ( STRING + topology Name ) ; return BOOL ; } LOG . fine ( STRING + topology Name ) ; String url = String . format ( STRING , location . get Host ( ) , location . get Controller Port ( ) , command , location . get Topology Id ( ) ) ; try { URL endpoint = new URL ( url ) ; LOG . fine ( STRING + endpoint ) ; return send Get Request ( endpoint , command , tunnel Config ) ; } catch ( Malformed URL Exception e ) { throw new Runtime Exception ( STRING + url , e ) ; } }
public int add Padding ( byte [ ] in , int in Off ) { byte code = ( byte ) ( in . length - in Off ) ; while ( in Off < ( in . length - NUM ) ) { in [ in Off ] = ( byte ) random . next Int ( ) ; in Off ++ ; } in [ in Off ] = code ; return code ; }
public void update ( long duration , Time Unit unit ) { update ( unit . to Nanos ( duration ) ) ; }
public static String from Doc 2 String ( Document doc ) throws Exception { K Xml Serializer serializer = new K Xml Serializer ( ) ; Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; Data Output Stream dos = new Data Output Stream ( bos ) ; try { serializer . set Feature ( STRING , BOOL ) ; serializer . set Output ( dos , Xform Constants . DEFAULT CHARACTER ENCODING ) ; doc . write ( serializer ) ; serializer . flush ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return null ; } return new String ( bos . to Byte Array ( ) , Xform Constants . DEFAULT CHARACTER ENCODING ) ; }
public int add Order Term ( Generic Value order Term ) { order Terms . add ( order Term ) ; return order Terms . index Of ( order Term ) ; }
public static int check Actions ( Map < String , Object > entry ) { boolean ip 6 = BOOL ; boolean ip 4 = BOOL ; String actions = null ; if ( entry . contains Key ( Static Flow Entry Pusher . COLUMN ACTIONS ) || entry . contains Key ( Static Flow Entry Pusher . COLUMN INSTR APPLY ACTIONS ) || entry . contains Key ( Static Flow Entry Pusher . COLUMN INSTR WRITE ACTIONS ) ) { if ( entry . contains Key ( Static Flow Entry Pusher . COLUMN ACTIONS ) ) { actions = ( String ) entry . get ( Static Flow Entry Pusher . COLUMN ACTIONS ) ; } else if ( entry . contains Key ( Static Flow Entry Pusher . COLUMN INSTR APPLY ACTIONS ) ) { actions = ( String ) entry . get ( Static Flow Entry Pusher . COLUMN INSTR APPLY ACTIONS ) ; } else if ( entry . contains Key ( Static Flow Entry Pusher . COLUMN INSTR WRITE ACTIONS ) ) { actions = ( String ) entry . get ( Static Flow Entry Pusher . COLUMN INSTR WRITE ACTIONS ) ; } if ( actions . contains ( Match Utils . STR ICMPV 6 CODE ) || actions . contains ( Match Utils . STR ICMPV 6 TYPE ) || actions . contains ( Match Utils . STR IPV 6 DST ) || actions . contains ( Match Utils . STR IPV 6 SRC ) || actions . contains ( Match Utils . STR IPV 6 FLOW LABEL ) || actions . contains ( Match Utils . STR IPV 6 ND SSL ) || actions . contains ( Match Utils . STR IPV 6 ND TARGET ) || actions . contains ( Match Utils . STR IPV 6 ND TTL ) ) { ip 6 = BOOL ; } if ( actions . contains ( Match Utils . STR NW SRC ) || actions . contains ( Match Utils . STR NW DST ) || actions . contains ( Match Utils . STR ARP OPCODE ) || actions . contains ( Match Utils . STR ARP SHA ) || actions . contains ( Match Utils . STR ARP DHA ) || actions . contains ( Match Utils . STR ARP SPA ) || actions . contains ( Match Utils . STR ARP DPA ) || actions . contains ( Match Utils . STR ICMP CODE ) || actions . contains ( Match Utils . STR ICMP TYPE ) ) { ip 4 = BOOL ; } } if ( ip 6 == BOOL && ip 4 == BOOL ) { return NUM ; } else if ( ip 6 == BOOL && ip 4 == BOOL ) { return NUM ; } else if ( ip 6 == BOOL && ip 4 == BOOL ) { return NUM ; } else { return - NUM ; } }
public String to String ( ) { String Builder string Builder = new String Builder ( ) ; for ( Validation Error Object error : errors ) { string Builder . append ( error . to String ( ) ) ; } return string Builder . to String ( ) ; }
public static Observable String Value decision ( Observable Boolean Value condition , Observable String Value if True , Observable String Value if False ) { String Property ret = new Simple String Property ( ) ; condition . add Listener ( null ) ; if True . add Listener ( null ) ; if False . add Listener ( null ) ; ret . set ( condition . get ( ) ? if True . get ( ) : if False . get ( ) ) ; return ret ; }
public static final boolean read From Stream ( Input Stream in , byte [ ] buf , int offset , int len ) throws IO Exception { int total Bytes Read = NUM ; while ( total Bytes Read < len ) { int bytes Read = in . read ( buf , offset + total Bytes Read , len - total Bytes Read ) ; if ( bytes Read < NUM ) { return BOOL ; } total Bytes Read += bytes Read ; } return BOOL ; }
public static Field find Static Field ( Class < ? > type , String name ) throws No Such Field Exception { Field field = find Field ( type , name ) ; if ( ! Modifier . is Static ( field . get Modifiers ( ) ) ) { throw new No Such Field Exception ( STRING + name + STRING ) ; } return field ; }
public void new Braces ( Editor State editor State , char ch ) { String cas Name = argument Helper . read Characters ( editor State ) ; if ( ch == FUNCTION OPEN KEY && meta Model . is General ( cas Name ) ) { del Characters ( editor State , cas Name . length ( ) ) ; new Function ( editor State , cas Name ) ; } else if ( ch == FUNCTION OPEN KEY && meta Model . is Function ( cas Name ) ) { del Characters ( editor State , cas Name . length ( ) ) ; new Function ( editor State , cas Name ) ; } else { new Array ( editor State , NUM , ch ) ; } }
@ Override public Xid [ ] recover ( int flag ) throws XA Exception { debug Code Call ( STRING , quote Flags ( flag ) ) ; check Open ( ) ; try ( Statement stat = physical Conn . create Statement ( ) ) { Result Set rs = stat . execute Query ( STRING + STRING ) ; Array List < Xid > list = New . array List ( ) ; while ( rs . next ( ) ) { String tid = rs . get String ( STRING ) ; int id = get Next Id ( XID ) ; Xid xid = new Jdbc Xid ( factory , id , tid ) ; list . add ( xid ) ; } rs . close ( ) ; Xid [ ] result = new Xid [ list . size ( ) ] ; list . to Array ( result ) ; if ( list . size ( ) > NUM ) { prepared = BOOL ; } return result ; } catch ( SQL Exception e ) { XA Exception xa = new XA Exception ( XA Exception . XAER RMERR ) ; xa . init Cause ( e ) ; throw xa ; } }
public void bind ( Texture texture ) { faces . for Each ( null ) ; }
public final void clear Password ( ) { Arrays . fill ( password , STRING ) ; password = null ; }
private static int New Char Array ( JNI Environment env , int length ) { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { char [ ] new Array = new char [ length ] ; return env . push JNI Ref ( new Array ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
private void init Quad Program ( ) { gl Use Program ( quad Program ) ; int tex Uniform = gl Get Uniform Location ( quad Program , STRING ) ; gl Uniform 1 i ( tex Uniform , NUM ) ; gl Use Program ( NUM ) ; }
public void put ( E e ) throws Interrupted Exception { if ( e == null ) throw new Null Pointer Exception ( ) ; int c = - NUM ; Node < E > node = new Node < E > ( e ) ; final Reentrant Lock put Lock = this . put Lock ; final Atomic Integer count = this . count ; put Lock . lock Interruptibly ( ) ; try { while ( count . get ( ) == capacity ) { not Full . await ( ) ; } enqueue ( node ) ; c = count . get And Increment ( ) ; if ( c + NUM < capacity ) not Full . signal ( ) ; } finally { put Lock . unlock ( ) ; } if ( c == NUM ) signal Not Empty ( ) ; }
public static boolean log File Zipped ( String file ) { return file . ends With ( STRING ) || file . ends With ( STRING ) || file . ends With ( STRING ) ; }
private void validate Has Checksum File ( File archive File ) throws Invalid Archive Update Exception { try { resolve Checksum File ( extract File To Directory ( archive File , CHECKSUMS FILE IN OPENIDM ) ) ; } catch ( Exception e ) { throw new Invalid Archive Update Exception ( archive File . get Name ( ) , STRING + archive File . get Name ( ) + STRING , e ) ; } }
protected String rats Problem ( ) { final String text = STRING + STRING ; return ( text ) ; }
public Class < ? > lookup Entity Class ( Class < ? > obj Class ) { for ( Class < ? > cls = obj Class ; cls != null ; cls = cls . get Superclass ( ) ) { if ( entity Bindings . contains Key ( cls ) || cls . is Annotation Present ( Entity . class ) ) { return cls ; } } throw new Illegal Argument Exception ( STRING + obj Class ) ; }
private boolean is Whitespace ( int position ) { if ( len >= NUM && position >= len ) { return BOOL ; } return Character . is Whitespace ( working [ position ] ) ; }
private void collect Wrapper Classes ( Class Loader cl , String pkg , File file ) throws Exception { for ( File f : file . list Files ( ) ) { if ( f . is Directory ( ) ) { collect Wrapper Classes ( cl , pkg + f . get Name ( ) + STRING , f ) ; } else { add Wrapper Class To Wrapper Classes List ( cl , pkg , f ) ; } } }
public void clear Images ( ) { chunks . clear ( ) ; markers . clear ( ) ; redraw ( BOOL ) ; shift x = NUM ; shift y = NUM ; zoom level pos = NUM ; zoom level = NUM ; }
public void test fill$JIIJ ( ) { long d [ ] = new long [ NUM ] ; Arrays . fill ( d , NUM , d . length , Long . MAX VALUE ) ; for ( int i = NUM ; i < NUM ; i ++ ) assert True ( STRING , ! ( d [ i ] == Long . MAX VALUE ) ) ; for ( int i = NUM ; i < d . length ; i ++ ) assert True ( STRING , d [ i ] == Long . MAX VALUE ) ; try { Arrays . fill ( d , NUM , NUM , Long . MIN VALUE ) ; fail ( STRING ) ; } catch ( Illegal Argument Exception e ) { } try { Arrays . fill ( d , - NUM , NUM , Long . MAX VALUE ) ; fail ( STRING ) ; } catch ( Array Index Out Of Bounds Exception e ) { } try { Arrays . fill ( d , NUM , d . length + NUM , Long . MAX VALUE ) ; fail ( STRING ) ; } catch ( Array Index Out Of Bounds Exception e ) { } }
public Object ext Function ( String ns , String func Name , Vector arg Vec , Object method Key , Expression Context expr Context ) throws javax . xml . transform . Transformer Exception { Object result = null ; if ( null != ns ) { Extension Handler ext NS = ( Extension Handler ) m extension Function Namespaces . get ( ns ) ; if ( null != ext NS ) { try { result = ext NS . call Function ( func Name , arg Vec , method Key , expr Context ) ; } catch ( javax . xml . transform . Transformer Exception e ) { throw e ; } catch ( Exception e ) { throw new javax . xml . transform . Transformer Exception ( e ) ; } } else { throw new X Path Processor Exception ( XSL Messages . create Message ( XSLT Error Resources . ER EXTENSION FUNC UNKNOWN , new Object [ ] { ns , func Name } ) ) ; } } return result ; }
private static void add Component ( final J Panel panel , final Component component , final String description , final String hint ) { final J Panel setting Panel = new J Panel ( new Border Layout ( ) ) ; setting Panel . set Border ( STANDARD EMPTY BORDER ) ; setting Panel . add ( new J Label ( description ) , Border Layout . CENTER ) ; final J Panel inner Panel = new J Panel ( new Border Layout ( ) ) ; inner Panel . add ( component , Border Layout . CENTER ) ; final J Hint Icon hint Popup = new J Hint Icon ( hint ) ; hint Popup . set Border ( new Empty Border ( NUM , NUM , NUM , NUM ) ) ; inner Panel . add ( hint Popup , Border Layout . EAST ) ; setting Panel . add ( inner Panel , Border Layout . EAST ) ; panel . add ( setting Panel ) ; }
private void write Attribute ( java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( namespace . equals ( STRING ) ) { xml Writer . write Attribute ( att Name , att Value ) ; } else { register Prefix ( xml Writer , namespace ) ; xml Writer . write Attribute ( namespace , att Name , att Value ) ; } }
public Reversed Lines File Reader ( final File file , final int block Size , final String encoding ) throws IO Exception { this ( file , block Size , Charsets . to Charset ( encoding ) ) ; }
private void on Connect ( ) { connection State = Connection State . Connected ; check For Updated Flight = BOOL ; subscribe ( String . format ( traffic Alert Channel , flight Id ) ) ; subscribe ( String . format ( situational Awareness Channel , flight Id ) ) ; }
public static double cdf ( double x , double sigma ) { if ( x <= NUM ) { return NUM ; } final double xs = x / sigma ; return NUM - Math . exp ( - NUM * xs * xs ) ; }
public double gaussian Shortfall ( double target ) { final Cumulative Normal Distribution g Integral = new Cumulative Normal Distribution ( mean ( ) , standard Deviation ( ) ) ; return g Integral . op ( target ) ; }
@ Override public int read ( char ch [ ] , int offset , int length ) throws IO Exception { int byte Length = length << NUM ; if ( byte Length > f Buffer . length ) { byte Length = f Buffer . length ; } int byte Count = f Input Stream . read ( f Buffer , NUM , byte Length ) ; if ( byte Count == - NUM ) { return - NUM ; } if ( ( byte Count & NUM ) != NUM ) { int b = f Input Stream . read ( ) ; if ( b == - NUM ) { expected Two Bytes ( ) ; } f Buffer [ byte Count ++ ] = ( byte ) b ; } final int char Count = byte Count > > NUM ; if ( f Is Big Endian ) { process BE ( ch , offset , char Count ) ; } else { process LE ( ch , offset , char Count ) ; } return char Count ; }
public static void end Wrapper ( Writer writer ) throws IO Exception { writer . write ( STRING ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; }
protected Document create Configuration Document ( AV List params ) { Document doc = super . create Configuration Document ( params ) ; if ( doc == null || doc . get Document Element ( ) == null ) return doc ; Data Configuration Utils . create WMS Layer Config Elements ( params , doc . get Document Element ( ) ) ; return doc ; }
public void register Callback ( String challenge , Challenge Callback Plugin plugin , Http Message attack ) { clean Expired Callbacks ( ) ; reg Callbacks . put ( challenge , new Registered Callback ( plugin , attack ) ) ; }
public static double min ( Array array ) throws Page Exception { if ( array . get Dimension ( ) > NUM ) throw new Expression Exception ( STRING ) ; if ( array . size ( ) == NUM ) return NUM ; double rtn = to Double Value ( array , NUM ) ; int len = array . size ( ) ; try { for ( int i = NUM ; i <= len ; i ++ ) { double v = to Double Value ( array , i ) ; if ( rtn > v ) rtn = v ; } } catch ( Page Exception e ) { throw new Expression Exception ( STRING + e . get Message ( ) ) ; } return rtn ; }
public static byte [ ] write To Array ( NS Object root ) throws IO Exception { Byte Array Output Stream bout = new Byte Array Output Stream ( ) ; write ( bout , root ) ; return bout . to Byte Array ( ) ; }
private static void load Library Resource ( String resource Subdirectory Name , String library Name , String temp Subdirectory Name , String ... dependent Library Names ) throws Throwable { for ( String dependent Library Name : dependent Library Names ) { logger . log ( level , STRING + library Name + STRING + dependent Library Name ) ; String dependent Resource Subdirectory Name = resource Subdirectory Name + STRING + os String ( ) + STRING + arch String ( ) ; String dependent Library Temp Sub Directory Name = library Name + STRING + File . separator + os String ( ) + File . separator + arch String ( ) + File . separator ; load Library Resource ( dependent Resource Subdirectory Name , dependent Library Name , dependent Library Temp Sub Directory Name ) ; } String library File Name = create Library File Name ( library Name ) ; File library Temp File = create Temp File ( temp Subdirectory Name , library File Name ) ; if ( ! library Temp File . exists ( ) ) { String library Resource Name = resource Subdirectory Name + STRING + library File Name ; logger . log ( level , STRING + library Resource Name ) ; logger . log ( level , STRING + library Temp File ) ; write Resource To File ( library Resource Name , library Temp File ) ; } logger . log ( level , STRING + library Temp File ) ; System . load ( library Temp File . to String ( ) ) ; logger . log ( level , STRING + library Temp File + STRING ) ; }
private Job Definition create Job Definition ( ) throws Exception { namespace Dao Test Helper . create Namespace Entity ( TEST ACTIVITI NAMESPACE CD ) ; Job Definition Create Request request = job Definition Service Test Helper . create Job Definition Create Request ( ) ; Job Definition job Definition = job Definition Service . create Job Definition ( request , BOOL ) ; validate Job Definition ( job Definition ) ; return job Definition ; }
private Web Socket Input Stream open Input Stream ( Socket socket ) throws Web Socket Exception { try { return new Web Socket Input Stream ( new Buffered Input Stream ( socket . get Input Stream ( ) ) ) ; } catch ( IO Exception e ) { throw new Web Socket Exception ( Web Socket Error . SOCKET INPUT STREAM FAILURE , STRING + e . get Message ( ) , e ) ; } }
@ Override protected void draw First Pass Shape ( Graphics 2 D g2 , int pass , int series , int item , Shape shape ) { if ( is Shadow Pass ( pass ) ) { if ( get Wall Paint ( ) != null ) { g2 . set Stroke ( get Item Stroke ( series , item ) ) ; g2 . set Paint ( get Wall Paint ( ) ) ; g2 . translate ( get X Offset ( ) , get Y Offset ( ) ) ; g2 . draw ( shape ) ; g2 . translate ( - get X Offset ( ) , - get Y Offset ( ) ) ; } } else { super . draw First Pass Shape ( g2 , pass , series , item , shape ) ; } }
public static double as Double ( String str , double def ) { try { return Double . parse Double ( str ) ; } catch ( Number Format Exception e ) { return def ; } }
public J Menu create Help Menu ( ) { Show Help Action help Action = new Show Help Action ( STRING ) ; J Menu help Menu = new J Menu ( STRING ) ; help Menu . add ( help Action ) ; return help Menu ; }
@ Override public void add Focusables ( Array List < View > views , int direction , int focusable Mode ) { final int focusable Count = views . size ( ) ; final int descendant Focusability = get Descendant Focusability ( ) ; if ( descendant Focusability != FOCUS BLOCK DESCENDANTS ) { for ( int i = NUM ; i < get Child Count ( ) ; i ++ ) { final View child = get Child At ( i ) ; if ( child . get Visibility ( ) == VISIBLE ) { Item Info ii = info For Child ( child ) ; if ( ii != null && ii . position == m Cur Item ) { child . add Focusables ( views , direction , focusable Mode ) ; } } } } if ( descendant Focusability != FOCUS AFTER DESCENDANTS || ( focusable Count == views . size ( ) ) ) { if ( ! is Focusable ( ) ) { return ; } if ( ( focusable Mode & FOCUSABLES TOUCH MODE ) == FOCUSABLES TOUCH MODE && is In Touch Mode ( ) && ! is Focusable In Touch Mode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }
public static void expand Digits ( String number String , Word Relation word Relation , Item token Item ) { int number Digits = number String . length ( ) ; for ( int i = NUM ; i < number Digits ; i ++ ) { char digit = number String . char At ( i ) ; if ( is Digit ( digit ) ) { word Relation . add Word ( token Item , digit 2 num [ number String . char At ( i ) - STRING ] ) ; } else { word Relation . add Word ( token Item , STRING ) ; } } }
public String longest Match ( String input ) { Trie Node node = root ; String result = null ; for ( int i = input . length ( ) - NUM ; i >= NUM ; i -- ) { node = node . get Child ( input . char At ( i ) ) ; if ( node == null ) break ; if ( node . is Terminal ( ) ) result = input . substring ( i ) ; } return result ; }
public void test Map Sub Class ( ) throws Exception { Object Mapper mapper = new Object Mapper ( ) ; Map Sub Class result = mapper . read Value ( STRING , Map Sub Class . class ) ; assert Equals ( NUM , result . size ( ) ) ; Object value = result . get ( STRING ) ; assert Equals ( Boolean Wrapper . class , value . get Class ( ) ) ; Boolean Wrapper bw = ( Boolean Wrapper ) value ; assert Equals ( Boolean . TRUE , bw . b ) ; }
@ Override public void remove Property Change Listener ( Property Change Listener pcl ) { m pcs . remove Property Change Listener ( pcl ) ; }
public void add On Tag Click Listener ( Tags Click Listener listener ) { if ( click Listeners == null ) { click Listeners = new Array List < > ( ) ; } click Listeners . add ( listener ) ; }
public void remove All Tracking Icons ( ) { if ( tracking Icons != null && tracking Icons . size ( ) > NUM ) { tracking Icons . clear ( ) ; repaint ( ) ; } }
private void read Reference ( ) { Array List < String > v value = new Array List < String > ( ) ; Array List < String > v name = new Array List < String > ( ) ; Array List < String > v description = new Array List < String > ( ) ; Document Engine . read Reference List ( v value , v name , v description ) ; int size = v value . size ( ) ; s value = new String [ size ] ; s name = new String [ size ] ; s description = new String [ size ] ; for ( int i = NUM ; i < size ; i ++ ) { s value [ i ] = ( String ) v value . get ( i ) ; s name [ i ] = ( String ) v name . get ( i ) ; s description [ i ] = ( String ) v description . get ( i ) ; } }
protected void assert Round Trip ( TPS expected ) throws IO Exception , Class Not Found Exception { final byte [ ] serialized ; { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; Object Output Stream oos = new Object Output Stream ( baos ) ; expected . write External ( oos ) ; oos . flush ( ) ; serialized = baos . to Byte Array ( ) ; } final TPS actual ; { actual = new TPS ( ) ; Byte Array Input Stream bais = new Byte Array Input Stream ( serialized ) ; Object Input Stream ois = new Object Input Stream ( bais ) ; actual . read External ( ois ) ; } assert Equals ( expected , actual ) ; }
public static double calculate Contrast Ratio ( double lum 1 , double lum 2 ) { if ( ( lum 1 < NUM ) || ( lum 2 < NUM ) ) { throw new Illegal Argument Exception ( STRING ) ; } return ( Math . max ( lum 1 , lum 2 ) + NUM ) / ( Math . min ( lum 1 , lum 2 ) + NUM ) ; }
protected void reset ( ) throws XNI Exception { int count = f Components . size ( ) ; for ( int i = NUM ; i < count ; i ++ ) { XML Component c = ( XML Component ) f Components . get ( i ) ; c . reset ( this ) ; } }
public synchronized void unregister ( String name ) { Stream Scope < ? > stream Scope = by Name Map . remove ( name ) ; if ( stream Scope == null ) return ; List < String > names = by Stream Scope Map . get ( stream Scope ) ; names . remove ( name ) ; if ( names . is Empty ( ) ) by Stream Scope Map . remove ( stream Scope ) ; }
private String expand Affix ( String pattern , String Buffer buffer ) { buffer . set Length ( NUM ) ; for ( int i = NUM ; i < pattern . length ( ) ; ) { char c = pattern . char At ( i ++ ) ; if ( c == QUOTE ) { c = pattern . char At ( i ++ ) ; switch ( c ) { case CURRENCY SIGN : if ( i < pattern . length ( ) && pattern . char At ( i ) == CURRENCY SIGN ) { ++ i ; buffer . append ( symbols . get International Currency Symbol ( ) ) ; } else { buffer . append ( symbols . get Currency Symbol ( ) ) ; } continue ; case PATTERN PERCENT : c = symbols . get Percent ( ) ; break ; case PATTERN PER MILLE : c = symbols . get Per Mill ( ) ; break ; case PATTERN MINUS : c = symbols . get Minus Sign ( ) ; break ; } } buffer . append ( c ) ; } return buffer . to String ( ) ; }
public static Query Functions extract Functions ( String [ ] filter Queries ) { final Query Functions result = new Query Functions ( ) ; if ( is Empty ( filter Queries ) ) { return result ; } String [ ] arguments = new String [ NUM ] ; for ( String unmodified Analysis : filter Queries ) { String function = extract Function ( unmodified Analysis ) ; String [ ] functions ; if ( function . contains ( FUNCTION ARGUMENT SPLITTER ) ) { functions = function . split ( FUNCTION ARGUMENT SPLITTER ) ; } else { functions = new String [ ] { function } ; } for ( String sub Function : functions ) { if ( sub Function . contains ( AGGREGATION ARGUMENT DELIMITER ) ) { arguments = extract Aggregation Parameter ( sub Function ) ; sub Function = sub Function . substring ( NUM , sub Function . index Of ( AGGREGATION ARGUMENT DELIMITER ) ) ; } Function Type type = Function Type . value Of ( sub Function . to Upper Case ( ) ) ; add Function ( result , type , arguments ) ; } } return result ; }
protected final void fire Vetoable Change ( String property Name , int old Value , int new Value ) throws Property Veto Exception { Vetoable Change Support a Veto Support = this . veto Support ; if ( a Veto Support == null ) { return ; } a Veto Support . fire Vetoable Change ( property Name , Integer . value Of ( old Value ) , Integer . value Of ( new Value ) ) ; }
protected boolean is Valid Classname ( String classname ) { return ( classname . index Of ( STRING ) == - NUM ) ; }
public static int number ( ) { return all . size ( ) ; }
public String generate Inverted String ( ) { return String . format ( STRING , NUM & generate Inverted ( ) ) ; }
@ Not Null public String extract Presentable Url ( @ Not Null String path ) { return path . replace ( STRING , File . separator Char ) ; }
public String convert SWF To HTML ( URL in ) throws Exception { Http URL Connection conn = ( Http URL Connection ) in . open Connection ( ) ; conn . set Allow User Interaction ( BOOL ) ; conn . set Request Property ( STRING , STRING ) ; conn . set Instance Follow Redirects ( BOOL ) ; conn . connect ( ) ; return convert SWF To HTML ( conn . get Input Stream ( ) ) ; }
private void init Program ( ) { gl Use Program ( this . program ) ; view Proj Matrix Uniform = gl Get Uniform Location ( this . program , STRING ) ; gl Use Program ( NUM ) ; }
private boolean is Negative ( final String input ) { require Non Null ( input ) ; for ( final String negative String : negative Strings ) { if ( input . equals Ignore Case ( negative String ) ) { return BOOL ; } } return BOOL ; }
@ Override protected void send Disposition Header ( final Output Stream out ) throws IO Exception { LOG . trace ( STRING ) ; super . send Disposition Header ( out ) ; final String filename = source . get File Name ( ) ; if ( filename != null ) { out . write ( FILE NAME BYTES ) ; out . write ( QUOTE BYTES ) ; out . write ( Encoding Util . get Ascii Bytes ( filename ) ) ; out . write ( QUOTE BYTES ) ; } }
private List < Map < String , Object > > prepare Resultsfor Display ( Collection < Scored Result > scored Results ) { Array List < Map < String , Object > > output = new Array List < Map < String , Object > > ( scored Results . size ( ) ) ; for ( Scored Result result : scored Results ) { Map < String , Object > result Map = new Hash Map < String , Object > ( ) ; if ( result . track != null ) { prepare Track For Display ( result . track , result Map ) ; } else { prepare Marker For Display ( result . waypoint , result Map ) ; } output . add ( result Map ) ; } return output ; }
public long copy ( final Input Stream from , final Output Stream to ) throws IO Exception { long count = NUM ; byte [ ] tmp = m Byte Array Pool . get ( m Temp Buf Size ) ; try { while ( BOOL ) { int read = from . read ( tmp , NUM , m Temp Buf Size ) ; if ( read == - NUM ) { return count ; } to . write ( tmp , NUM , read ) ; count += read ; } } finally { m Byte Array Pool . release ( tmp ) ; } }
private static Element info As Element ( Document doc , Library Info info ) { Element library Element = doc . create Element ( STRING ) ; library Element . set Attribute ( STRING , info . get Version ( ) ) ; append Path Elements ( doc , STRING , library Element , info . get Bootpath ( ) ) ; append Path Elements ( doc , STRING , library Element , info . get Extension Dirs ( ) ) ; append Path Elements ( doc , STRING , library Element , info . get Endorsed Dirs ( ) ) ; return library Element ; }
public void add Choice Value ( String value , String i18 n Key ) throws SMS Exception , SSO Exception { Map choice Values = as . get Choice Values Map ( ) ; choice Values . put ( value , i18 n Key ) ; update Choice Values ( choice Values ) ; }
private void notify Change ( int previous , int current ) { if ( m On Value Change Listener != null ) { m On Value Change Listener . on Value Change ( this , previous , m Value ) ; } }
public void load Library ( String lib Name ) { load Library 0 ( lib Name , RVM Class . get Class Loader From Stack Frame ( NUM ) , BOOL ) ; }
public void handle Tbl Data Action Href Request ( Request Invocation Event event ) { String id Repo Name = hex To String ( ( String ) get Display Field Value ( TBL DATA ACTION HREF ) ) ; String cur Realm = ( String ) get Page Session Attribute ( AM Admin Constants . CURRENT REALM ) ; try { ID Repo Model model = ( ID Repo Model ) get Model ( ) ; set Page Session Attribute ( ID Repo Op View Bean Base . IDREPO NAME , id Repo Name ) ; set Page Session Attribute ( ID Repo Op View Bean Base . IDREPO TYPE , model . get ID Repo Type ( cur Realm , id Repo Name ) ) ; ID Repo Edit View Bean vb = ( ID Repo Edit View Bean ) get View Bean ( ID Repo Edit View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; forward To ( ) ; } }
public Charset charset ( ) { return charset != null ? Charset . for Name ( charset ) : null ; }
public boolean initialize ( DDF Module po Module In , String psz Tag In , byte [ ] pach Field Area ) { int iFD Offset = po Module In . field Control Length ; po Module = po Module In ; psz Tag = psz Tag In ; data struct code = Data Struct Code . get ( ( char ) pach Field Area [ NUM ] ) ; data type code = Data Type Code . get ( ( char ) pach Field Area [ NUM ] ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + psz Tag In + STRING + data struct code + STRING + data type code + STRING + iFD Offset ) ; } byte [ ] temp Data = new byte [ pach Field Area . length - iFD Offset ] ; System . arraycopy ( pach Field Area , iFD Offset , temp Data , NUM , pach Field Area . length - iFD Offset ) ; Mutable Int n Chars Consumed = new Mutable Int ( ) ; field Name = DDF Utils . fetch Variable ( temp Data , temp Data . length , DDF UNIT TERMINATOR , DDF FIELD TERMINATOR , n Chars Consumed ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + psz Tag In + STRING + field Name ) ; } iFD Offset += n Chars Consumed . value ; temp Data = new byte [ pach Field Area . length - iFD Offset ] ; System . arraycopy ( pach Field Area , iFD Offset , temp Data , NUM , pach Field Area . length - iFD Offset ) ; array Descr = DDF Utils . fetch Variable ( temp Data , temp Data . length , DDF UNIT TERMINATOR , DDF FIELD TERMINATOR , n Chars Consumed ) ; iFD Offset += n Chars Consumed . value ; temp Data = new byte [ pach Field Area . length - iFD Offset ] ; System . arraycopy ( pach Field Area , iFD Offset , temp Data , NUM , pach Field Area . length - iFD Offset ) ; format Controls = DDF Utils . fetch Variable ( temp Data , temp Data . length , DDF UNIT TERMINATOR , DDF FIELD TERMINATOR , n Chars Consumed ) ; if ( data struct code != Data Struct Code . ELEMENTARY ) { if ( ! build Subfield Defns ( array Descr ) ) { return BOOL ; } if ( ! apply Formats ( format Controls ) ) { return BOOL ; } } return BOOL ; }
@ Override public void load Height Map ( Raster raster ) throws IO Exception { int strip Height = Math . min ( STRIP ROWS , raster Length ) ; int strip Width = raster Width * samples Per Pixel ; int strip Size = strip Width * strip Height * bytes Per Sample ; int num Strips = ( int ) Math . ceil ( ( double ) raster Length / strip Height ) ; if ( strip Size > Integer . MAX VALUE ) { throw new Illegal Argument Exception ( STRING + Integer . MAX VALUE + STRING ) ; } if ( ( minimum == null ) || ( maximum == null ) ) { compute Min Max From Strip ( data Type , num Strips , strip Size , strip Width , strip Height ) ; } load From Strip ( data Type , num Strips , strip Size , strip Width , strip Height , raster , BOOL ) ; }
public void add Footer ( @ Non Null View view ) { if ( view == null ) { throw new Illegal Argument Exception ( STRING ) ; } m Footers . add ( view ) ; }
public static Pair < int [ ] , double [ ] > convert ( Set < Feature > features , Lexicon lexicon , boolean training Mode ) { T Int Double Hash Map f Map = new T Int Double Hash Map ( features . size ( ) ) ; for ( Feature feature : features ) { final int feature Id = Feature Utilities . get Feature Id ( lexicon , training Mode , feature ) ; if ( feature Id < NUM ) continue ; double value = feature . get Value ( ) + f Map . get ( feature Id ) ; f Map . put ( feature Id , value ) ; } int [ ] ids Original = f Map . keys ( ) ; int [ ] ids = new int [ ids Original . length ] ; System . arraycopy ( ids Original , NUM , ids , NUM , ids . length ) ; Arrays . sort ( ids ) ; double [ ] vals = new double [ f Map . size ( ) ] ; int count = NUM ; for ( int key : ids ) { vals [ count ++ ] = f Map . get ( key ) ; } return new Pair < > ( ids , vals ) ; }
private static String crete XML Total Count ( int first Row , int num PFIS , int num PJUR , int r Default , int max Results ) { String result = null ; Document document = Document Helper . create Document ( ) ; Element root = document . add Element ( Person Keys . XML PERSONAS TEXT ) ; root . add Attribute ( Person Keys . XML INICIO TEXT , Integer . to String ( first Row ) ) ; if ( ( first Row + r Default ) > ( num PFIS + num PJUR ) ) { root . add Attribute ( Person Keys . XML FIN TEXT , Integer . to String ( num PFIS + num PJUR ) ) ; } else { root . add Attribute ( Person Keys . XML FIN TEXT , Integer . to String ( first Row + r Default ) ) ; } root . add Attribute ( Person Keys . XML TOTAL TEXT , Integer . to String ( num PFIS + num PJUR ) ) ; root . add Attribute ( Person Keys . XML RANGO TEXT , Integer . to String ( r Default ) ) ; root . add Attribute ( Person Keys . XML RESULT MAX TEXT , Integer . to String ( max Results ) ) ; result = document . as XML ( ) ; return result ; }
public String to Feature String ( Feature Vector fv ) { if ( num Byte Features != fv . get Number Of Byte Features ( ) || num Short Features != fv . get Number Of Short Features ( ) || num Continuous Features != fv . get Number Of Continuous Features ( ) ) throw new Illegal Argument Exception ( STRING + fv + STRING ) ; String Builder buf = new String Builder ( ) ; for ( int i = NUM ; i < num Byte Features ; i ++ ) { if ( buf . length ( ) > NUM ) buf . append ( STRING ) ; buf . append ( get Feature Value As String ( i , fv . get Byte Feature ( i ) ) ) ; } for ( int i = num Byte Features ; i < num Byte Features + num Short Features ; i ++ ) { if ( buf . length ( ) > NUM ) buf . append ( STRING ) ; buf . append ( get Feature Value As String ( i , fv . get Short Feature ( i ) ) ) ; } for ( int i = num Byte Features + num Short Features ; i < num Byte Features + num Short Features + num Continuous Features ; i ++ ) { if ( buf . length ( ) > NUM ) buf . append ( STRING ) ; buf . append ( fv . get Continuous Feature ( i ) ) ; } return buf . to String ( ) ; }
protected void sort Population ( ) { if ( Properties . SHUFFLE GOALS ) Randomness . shuffle ( population ) ; if ( is Maximization Function ( ) ) { Collections . sort ( population , Collections . reverse Order ( ) ) ; } else { Collections . sort ( population ) ; } }
public void clean ( ) { Chrono Full Revision cfr = first CFR ; total Size = size ; while ( cfr != null ) { total Size += cfr . size ( ) ; cfr = cfr . get Next ( ) ; } if ( total Size < MAX STORAGE SIZE ) { return ; } cfr = first CFR ; while ( cfr != null ) { total Size += cfr . clean ( revision Index , NUM ) ; cfr = cfr . get Next ( ) ; } Chrono Storage Block block ; while ( last != null && total Size >= MAX STORAGE SIZE ) { block = last . get Index Prev ( ) ; if ( storage . remove ( last . get Revision Index ( ) ) == null ) { throw new Runtime Exception ( STRING ) ; } total Size -= last . length ( ) ; size += last . length ( ) ; if ( block != null ) { block . set Index Next ( null ) ; } last . set Index Prev ( null ) ; cfr = last . get Chrono Full Revision ( ) ; total Size += cfr . size ( ) - cfr . clean ( revision Index , last . get Revision Index ( ) ) ; if ( last == first ) { first = null ; } last = block ; } System . gc ( ) ; }
public static Number plus ( Character left , Character right ) { return plus ( Integer . value Of ( left ) , right ) ; }
boolean contain Relay State ( String relay State ) { return relay State Map . contains Key ( relay State ) ; }
public void local Search Started ( ) { start Time = System . current Time Millis ( ) ; end Time = start Time + Properties . LOCAL SEARCH BUDGET * NUM ; tests = NUM ; suites = NUM ; fitness Evaluations = NUM ; executed Start = Max Statements Stopping Condition . get Num Executed Statements ( ) ; }
public synchronized int write ( Input Stream in ) throws IO Exception { int read Count = NUM ; int in Buffer Pos = count - filled Buffer Sum ; int n = in . read ( current Buffer , in Buffer Pos , current Buffer . length - in Buffer Pos ) ; while ( n != - NUM ) { read Count += n ; in Buffer Pos += n ; count += n ; if ( in Buffer Pos == current Buffer . length ) { need New Buffer ( current Buffer . length ) ; in Buffer Pos = NUM ; } n = in . read ( current Buffer , in Buffer Pos , current Buffer . length - in Buffer Pos ) ; } return read Count ; }
public static double normalize Radians ( double r ) { if ( r < NUM && r >= - TWO PI ) return r + TWO PI ; if ( r >= TWO PI && r < FOUR PI ) return r - TWO PI ; if ( r >= NUM && r < TWO PI ) return r ; r -= TWO PI * Math . floor ( r * TWO PI INVERSE ) ; if ( r < NUM ) r += TWO PI ; return r ; }
public static Tetrad Matrix convert Cov To Corr ( Tetrad Matrix m ) { for ( int i = NUM ; i < m . rows ( ) ; i ++ ) { for ( int j = NUM ; j < m . columns ( ) ; j ++ ) { if ( Double . is Na N ( m . get ( i , j ) ) ) { throw new Illegal Argument Exception ( STRING ) ; } } } return correlation ( m ) ; }
private byte [ ] ungzip ( byte [ ] body ) { Byte Array Input Stream bytein = new Byte Array Input Stream ( body ) ; try ( GZIP Input Stream gzin = new GZIP Input Stream ( bytein ) ; Byte Array Output Stream byteout = new Byte Array Output Stream ( ) ) { int res = NUM ; byte buf [ ] = new byte [ NUM ] ; while ( res >= NUM ) { res = gzin . read ( buf , NUM , buf . length ) ; if ( res > NUM ) { byteout . write ( buf , NUM , res ) ; } } byte uncompressed [ ] = byteout . to Byte Array ( ) ; return uncompressed ; } catch ( IO Exception e ) { } return null ; }
private boolean select ID ( int node ID , boolean show ) { if ( m root == null ) return BOOL ; log . config ( STRING + node ID + STRING + show + STRING + m root ) ; M Tree Node node = m root . find Node ( node ID ) ; if ( node != null ) { Tree Path tree Path = new Tree Path ( node . get Path ( ) ) ; log . config ( STRING + node + STRING + tree Path . to String ( ) ) ; tree . set Selection Path ( tree Path ) ; if ( show ) { tree . make Visible ( tree Path ) ; tree . scroll Path To Visible ( tree Path ) ; } return BOOL ; } log . info ( STRING + node ID ) ; return BOOL ; }
@ Override public void load RGBA ( Raster raster ) throws IO Exception { if ( band Storage Type == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( samples Per Pixel < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( i Stream != null ) { i Stream . close ( ) ; } i Stream = new File Image Input Stream ( new File ( data File Path ) ) ; i Stream . seek ( image Start ) ; int strip Height = Math . min ( STRIP ROWS , raster Length ) ; int strip Width = raster Width * samples Per Pixel ; int num Strips = ( int ) Math . ceil ( ( double ) raster Length / strip Height ) ; if ( band Storage Type . equals ( STRING ) ) { int strip Size = strip Width * strip Height * bytes Per Sample ; if ( strip Size > Integer . MAX VALUE ) { throw new Illegal Argument Exception ( STRING + Integer . MAX VALUE + STRING ) ; } byte [ ] bb Array = new byte [ strip Size ] ; Byte Buffer bbuf = Byte Buffer . allocate ( NUM * raster Width * strip Height ) ; i Stream . seek ( image Start ) ; int r = NUM ; for ( int i = NUM ; i < num Strips ; ++ i ) { int h = Math . min ( raster Length - strip Height * i , strip Height ) ; int len = h * strip Width ; len = i Stream . read ( bb Array , NUM , len ) ; for ( int j = NUM ; j < h ; ++ j ) { for ( int k = NUM ; k < strip Width ; k += samples Per Pixel ) { for ( int l = NUM ; l < samples Per Pixel ; ++ l ) { bbuf . put ( bb Array [ k + l ] ) ; } if ( samples Per Pixel == NUM ) { bbuf . put ( ( byte ) NUM ) ; } } r ++ ; } bbuf . rewind ( ) ; raster . set ( r , h , bb Array ) ; } } else if ( band Storage Type . equals ( STRING ) ) { int strip Size = raster Width * strip Height ; if ( strip Size > Integer . MAX VALUE ) { throw new Illegal Argument Exception ( STRING + Integer . MAX VALUE + STRING ) ; } raster . set ( NUM ) ; byte [ ] b Array = new byte [ NUM * raster Width * strip Height ] ; byte [ ] bb Array = new byte [ strip Size ] ; i Stream . seek ( image Start ) ; for ( int k = NUM ; k < samples Per Pixel ; ++ k ) { int r = NUM ; for ( int i = NUM ; i < num Strips ; ++ i ) { int h = Math . min ( raster Length - strip Height * i , strip Height ) ; int len = h * raster Width ; len = i Stream . read ( bb Array , NUM , len ) ; for ( int j = NUM ; j < h ; ++ j ) { raster . get ( r , b Array ) ; for ( int c = NUM ; c < raster Width ; ++ c ) { b Array [ c * NUM + k ] = bb Array [ c ] ; } raster . set ( r , NUM , b Array ) ; r ++ ; } } } } if ( minimum == null ) { minimum = new double [ ] { NUM , NUM , NUM , NUM } ; } if ( maximum == null ) { maximum = new double [ ] { NUM , NUM , NUM , NUM } ; } }
protected final boolean is List State ( ) { return state Text Types . char At ( state ) == STRING ; }
private static Class < ? extends Activity > guess Error Activity Class ( Context context ) { Class < ? extends Activity > resolved Activity Class ; resolved Activity Class = Custom Activity On Crash . get Error Activity Class With Intent Filter ( context ) ; if ( resolved Activity Class == null ) { resolved Activity Class = Default Error Activity . class ; } return resolved Activity Class ; }
public void load Glyphs ( String chars ) throws No Glyph Exception { char [ ] chs = chars . to Char Array ( ) ; for ( int i = NUM ; i < chs . length ; i ++ ) { get Glyph ( chs [ i ] , null ) ; } }
private void init Quest And Add To World ( final I Quest quest ) { logger . info ( STRING + quest . get Name ( ) ) ; quest . add To World ( ) ; quests . add ( quest ) ; }
public static Move Command [ ] values ( int f , Game Options opts , boolean forward Ini ) { boolean manual Shutdown = BOOL , self Destruct = BOOL ; if ( opts != null ) { manual Shutdown = opts . boolean Option ( STRING ) ; self Destruct = opts . boolean Option ( STRING ) ; } Array List < Move Command > flagged Cmds = new Array List < Move Command > ( ) ; for ( Move Command cmd : Move Command . values ( ) ) { if ( ( cmd == MOVE SHUTDOWN || cmd == MOVE STARTUP ) && ! manual Shutdown ) { continue ; } if ( cmd == MOVE SELF DESTRUCT && ! self Destruct ) { continue ; } if ( cmd == MOVE FORWARD INI && ! forward Ini ) { continue ; } if ( ( cmd . flag & f ) == f ) { flagged Cmds . add ( cmd ) ; } } return flagged Cmds . to Array ( new Move Command [ NUM ] ) ; }
public boolean is LDAP ( ) { String host = get LDAP Host ( ) ; if ( host == null || host . length ( ) == NUM ) return BOOL ; String domain = get LDAP Domain ( ) ; return domain != null && domain . length ( ) > NUM ; }
public void shed Cache ( ) { Connection [ ] conn ; synchronized ( free List ) { conn = free List . to Array ( new Connection [ free List . size ( ) ] ) ; free List . clear ( ) ; } for ( int i = conn . length ; -- i >= NUM ; ) { Connection c = conn [ i ] ; conn [ i ] = null ; try { c . close ( ) ; } catch ( java . io . IO Exception e ) { } } }
public static byte [ ] hash ( Input Stream in ) throws IO Exception { if ( HASH DIGEST == null ) { throw new Evernote Util Exception ( EDAM HASH ALGORITHM + STRING , new No Such Algorithm Exception ( EDAM HASH ALGORITHM ) ) ; } byte [ ] buf = new byte [ NUM ] ; int n ; while ( ( n = in . read ( buf ) ) != - NUM ) { HASH DIGEST . update ( buf , NUM , n ) ; } return HASH DIGEST . digest ( ) ; }
public byte [ ] read Raw Bytes ( final int size ) throws IO Exception { if ( size < NUM ) { throw Invalid Protocol Buffer Nano Exception . negative Size ( ) ; } if ( buffer Pos + size > current Limit ) { skip Raw Bytes ( current Limit - buffer Pos ) ; throw Invalid Protocol Buffer Nano Exception . truncated Message ( ) ; } if ( size <= buffer Size - buffer Pos ) { final byte [ ] bytes = new byte [ size ] ; System . arraycopy ( buffer , buffer Pos , bytes , NUM , size ) ; buffer Pos += size ; return bytes ; } else { throw Invalid Protocol Buffer Nano Exception . truncated Message ( ) ; } }
public abstract Tree Node create Node ( final int x , final int y ) ;
@ Suppress Warnings ( STRING ) public static < T extends Feature Structure > List < T > to List ( FS Array array ) { if ( array == null ) { return new Array List < T > ( ) ; } else { return ( List < T > ) Arrays . as List ( array . to Array ( ) ) ; } }
private void reset Notes 2 ( ) { if ( error In Status 2 ) { if ( edit Mode ) { status Text 1 . set Text ( edit Status 2 ) ; } else { status Text 2 . set Text ( std Status 2 ) ; } error In Status 2 = BOOL ; } }
protected static int to Digit ( final char ch , final int index ) throws Illegal Argument Exception { final int digit = Character . digit ( ch , NUM ) ; if ( digit == - NUM ) { throw new Illegal Argument Exception ( STRING + ch + STRING + index ) ; } return digit ; }
public static Server Side Sort Request Control new Control ( final boolean is Critical , final Collection < Sort Key > keys ) { Reject . if Null ( keys ) ; Reject . if False ( ! keys . is Empty ( ) , STRING ) ; return new Server Side Sort Request Control ( is Critical , Collections . unmodifiable List ( new Array List < Sort Key > ( keys ) ) ) ; }
@ Suppress Warnings ( { STRING , STRING } ) static < E extends Comparable < E > > Auto Sorted Collection < E > create Auto Sorted Collection ( Supplier < List < Sorted List Element < E > > > list Sup , Collection < ? extends E > values ) { List list = list Sup . get ( ) ; if ( ! list . is Empty ( ) ) { throw new Illegal State Exception ( STRING ) ; } Auto Sorted Collection < E > sorted Collection = new Auto List Sorted Collection < > ( list , null ) ; sorted Collection . add All ( values ) ; return sorted Collection ; }
private void int Stream ( ) { int [ ] ints = new int [ ] { NUM , NUM , NUM , NUM , NUM } ; Int Stream int Stream = Int Stream . of ( ints ) ; int Stream . for Each ( null ) ; Int Stream int Stream 2 = Int Stream . of ( NUM , NUM , NUM , NUM , NUM ) ; int Stream 2 . for Each ( null ) ; }
@ Suppress Warnings ( STRING ) public boolean is Customized ( ) { if ( m customization Level == null ) { get Element ID ( ) ; m customization Level = new Integer ( s parameters . CUSTOMNONE ) ; if ( m parent . is Custom Prefix ( m name ) ) { m customization Level = new Integer ( s parameters . CUSTOMPREFIXED ) ; } else { if ( m parent . is Object Exists ( STRING , m parent . get Tables ( ) ) && m parent . is Object Exists ( STRING , m parent . get Tables ( ) ) ) { String sql = s db Engine . sql AD get Table Column Entity Type ( m parent . get Vendor ( ) , m parent . get Catalog ( ) , m parent . get Schema ( ) , m table , m name ) ; Statement stmt = m parent . set Statement ( ) ; Result Set rs = m parent . execute Query ( stmt , sql ) ; if ( m parent . get Result Set Next ( rs ) ) { String s = m parent . get Result Set String ( rs , STRING ) ; if ( m parent . is Custom Entity Type ( s ) ) m customization Level = new Integer ( s parameters . CUSTOMMARKED ) ; } m parent . release Result Set ( rs ) ; m parent . release Statement ( stmt ) ; } } } if ( m customization Level . int Value ( ) > s parameters . CUSTOMNONE ) return BOOL ; else return BOOL ; }
private void reload Queue ( ) { String q = null ; int id = m Card Id ; if ( m Preferences . contains ( STRING ) ) { id = m Preferences . get Int ( STRING , ~ m Card Id ) ; } if ( id == m Card Id ) { q = m Preferences . get String ( STRING , STRING ) ; } int qlen = q != null ? q . length ( ) : NUM ; if ( qlen > NUM ) { int plen = NUM ; int n = NUM ; int shift = NUM ; for ( int i = NUM ; i < qlen ; i ++ ) { final char c = q . char At ( i ) ; if ( c == STRING ) { ensure Play List Capacity ( plen + NUM ) ; m Play List [ plen ] = n ; plen ++ ; n = NUM ; shift = NUM ; } else { if ( c >= STRING && c <= STRING ) { n += c - STRING << shift ; } else if ( c >= STRING && c <= STRING ) { n += NUM + c - STRING << shift ; } else { plen = NUM ; break ; } shift += NUM ; } } m Play List Len = plen ; final int pos = m Preferences . get Int ( STRING , NUM ) ; if ( pos < NUM || pos >= m Play List Len ) { m Play List Len = NUM ; return ; } m Play Pos = pos ; update Cursor ( m Play List [ m Play Pos ] ) ; if ( m Cursor == null ) { System Clock . sleep ( NUM ) ; update Cursor ( m Play List [ m Play Pos ] ) ; } synchronized ( this ) { close Cursor ( ) ; m Open Failed Counter = NUM ; open Current And Next ( ) ; } if ( m Player == null || ! m Player . is Initialized ( ) ) { m Play List Len = NUM ; return ; } final long seekpos = m Preferences . get Long ( STRING , NUM ) ; seek ( seekpos >= NUM && seekpos < duration ( ) ? seekpos : NUM ) ; if ( D ) { LOG . info ( STRING + position ( ) + STRING + duration ( ) + STRING + seekpos + STRING ) ; } int repmode = m Preferences . get Int ( STRING , REPEAT NONE ) ; if ( repmode != REPEAT ALL && repmode != REPEAT CURRENT ) { repmode = REPEAT NONE ; } m Repeat Mode = repmode ; int shufmode = m Preferences . get Int ( STRING , SHUFFLE NONE ) ; if ( shufmode != SHUFFLE AUTO && shufmode != SHUFFLE NORMAL ) { shufmode = SHUFFLE NONE ; } if ( shufmode != SHUFFLE NONE ) { q = m Preferences . get String ( STRING , STRING ) ; qlen = q != null ? q . length ( ) : NUM ; if ( qlen > NUM ) { n = NUM ; shift = NUM ; m History . clear ( ) ; for ( int i = NUM ; i < qlen ; i ++ ) { final char c = q . char At ( i ) ; if ( c == STRING ) { if ( n >= m Play List Len ) { m History . clear ( ) ; break ; } m History . add ( n ) ; n = NUM ; shift = NUM ; } else { if ( c >= STRING && c <= STRING ) { n += c - STRING << shift ; } else if ( c >= STRING && c <= STRING ) { n += NUM + c - STRING << shift ; } else { m History . clear ( ) ; break ; } shift += NUM ; } } } } if ( shufmode == SHUFFLE AUTO ) { if ( ! make Auto Shuffle List ( ) ) { shufmode = SHUFFLE NONE ; } } m Shuffle Mode = shufmode ; } }
public final void scheduled For Flush ( ) { scheduled For Flush . set ( BOOL ) ; }
public Image Info inspect Image ( String image ) throws IO Exception { return inspect Image ( Inspect Image Params . create ( image ) ) ; }
@ Override public double prev Cumulative Quantity ( final Long wo Activity Id , Long mb Header Id ) { if ( mb Header Id == null ) mb Header Id = - NUM ; final Object [ ] params = new Object [ ] { mb Header Id , mb Header Id , Works Constants . CANCELLED STATUS , wo Activity Id } ; final Double p Quant = ( Double ) generic Service . find By Named Query ( STRING , params ) ; if ( p Quant == null ) return NUM ; else return p Quant . double Value ( ) ; }
void receive ( int length , Data Input Stream in ) throws IO Exception { synchronized ( lock ) { if ( ( pos > NUM ) && ( ( buffer . length - present ) < length ) ) { System . arraycopy ( buffer , pos , buffer , NUM , present - pos ) ; present -= pos ; pos = NUM ; } if ( ( buffer . length - present ) < length ) throw new IO Exception ( STRING ) ; in . read Fully ( buffer , present , length ) ; present += length ; requested -= length ; lock . notify All ( ) ; } }
public JDA Builder remove Listener ( Object listener ) { listeners . remove ( listener ) ; return this ; }
private void update Base Matrix ( Drawable d ) { Image View image View = get Image View ( ) ; if ( null == image View || null == d ) { return ; } final float view Width = get Image View Width ( image View ) ; final float view Height = get Image View Height ( image View ) ; final int drawable Width = d . get Intrinsic Width ( ) ; final int drawable Height = d . get Intrinsic Height ( ) ; m Base Matrix . reset ( ) ; final float width Scale = view Width / drawable Width ; final float height Scale = view Height / drawable Height ; if ( m Scale Type == Scale Type . CENTER ) { m Base Matrix . post Translate ( ( view Width - drawable Width ) / NUM , ( view Height - drawable Height ) / NUM ) ; } else if ( m Scale Type == Scale Type . CENTER CROP ) { float scale = Math . max ( width Scale , height Scale ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM , ( view Height - drawable Height * scale ) / NUM ) ; } else if ( m Scale Type == Scale Type . CENTER INSIDE ) { float scale = Math . min ( NUM , Math . min ( width Scale , height Scale ) ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM , ( view Height - drawable Height * scale ) / NUM ) ; } else { Rect F m Temp Src = new Rect F ( NUM , NUM , drawable Width , drawable Height ) ; Rect F m Temp Dst = new Rect F ( NUM , NUM , view Width , view Height ) ; switch ( m Scale Type ) { case FIT CENTER : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . CENTER ) ; break ; case FIT START : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . START ) ; break ; case FIT END : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . END ) ; break ; case FIT XY : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . FILL ) ; break ; default : break ; } } reset Matrix ( ) ; }
private static List < String > read File ( File file ) throws IO Exception { File Reader fr = new File Reader ( file ) ; Buffered Reader br = new Buffered Reader ( fr ) ; List < String > lines = new Array List < String > ( ) ; String line ; while ( ( line = br . read Line ( ) ) != null ) lines . add ( line ) ; fr . close ( ) ; br . close ( ) ; return lines ; }
Flexible Node read External Node ( Hash Map < String , Taxon > translation List ) throws Import Exception , IO Exception { Flexible Node node = new Flexible Node ( ) ; String label = read Token ( STRING ) ; Taxon taxon ; if ( translation List . size ( ) > NUM ) { taxon = translation List . get ( label ) ; if ( taxon == null ) { throw new Unknown Taxon Exception ( STRING + label + STRING ) ; } } else { taxon = new Taxon ( label ) ; } if ( get Last Meta Comment ( ) != null ) { parse Migration String ( get Last Meta Comment ( ) , node ) ; clear Last Meta Comment ( ) ; } node . set Taxon ( taxon ) ; int pop = Integer . parse Int ( label . split ( STRING ) [ NUM ] ) ; node . set Attribute ( POP , ( pop - NUM ) ) ; return node ; }
static void plug Together Pair ( Input Stream in , Output Stream out , Input Stream in 1 , Output Stream out 1 ) { Thread in Thread = null ; Thread out Thread = null ; int n Execs = get Num Exec ( ) ; in Thread = Access Controller . do Privileged ( new New Thread Action ( new Pipe Writer ( in , out , STRING , n Execs ) , STRING , BOOL ) ) ; out Thread = Access Controller . do Privileged ( new New Thread Action ( new Pipe Writer ( in 1 , out 1 , STRING , n Execs ) , STRING , BOOL ) ) ; in Thread . start ( ) ; out Thread . start ( ) ; }
@ Non Null public static Storable Fence and ( @ Non Null Storable Fence ... fences ) { return Storable Fence . and ( Arrays . as List ( fences ) ) ; }
public MXFUID ( byte [ ] uid ) { this . uid = Arrays . copy Of ( uid , uid . length ) ; }
private int shrink Flex Items ( Flex Line flex Line , @ Flex Direction int flex Direction , int max Main Size , int padding Along Main Axis , int start Index ) { int child Index = start Index ; int size Before Shrink = flex Line . m Main Size ; if ( flex Line . m Total Flex Shrink <= NUM || max Main Size > flex Line . m Main Size ) { child Index += flex Line . m Item Count ; return child Index ; } boolean needs Reshrink = BOOL ; float unit Shrink = ( flex Line . m Main Size - max Main Size ) / flex Line . m Total Flex Shrink ; float accumulated Round Error = NUM ; flex Line . m Main Size = padding Along Main Axis + flex Line . m Divider Length In Main Size ; for ( int i = NUM ; i < flex Line . m Item Count ; i ++ ) { View child = get Reordered Child At ( child Index ) ; if ( child == null ) { continue ; } else if ( child . get Visibility ( ) == View . GONE ) { child Index ++ ; continue ; } Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( is Main Axis Direction Horizontal ( flex Direction ) ) { if ( ! m Children Frozen [ child Index ] ) { float raw Calculated Width = child . get Measured Width ( ) - unit Shrink * lp . flex Shrink ; if ( i == flex Line . m Item Count - NUM ) { raw Calculated Width += accumulated Round Error ; accumulated Round Error = NUM ; } int new Width = Math . round ( raw Calculated Width ) ; if ( new Width < lp . min Width ) { needs Reshrink = BOOL ; new Width = lp . min Width ; m Children Frozen [ child Index ] = BOOL ; flex Line . m Total Flex Shrink -= lp . flex Shrink ; } else { accumulated Round Error += ( raw Calculated Width - new Width ) ; if ( accumulated Round Error > NUM ) { new Width += NUM ; accumulated Round Error -= NUM ; } else if ( accumulated Round Error < - NUM ) { new Width -= NUM ; accumulated Round Error += NUM ; } } child . measure ( Measure Spec . make Measure Spec ( new Width , Measure Spec . EXACTLY ) , Measure Spec . make Measure Spec ( child . get Measured Height ( ) , Measure Spec . EXACTLY ) ) ; } flex Line . m Main Size += child . get Measured Width ( ) + lp . left Margin + lp . right Margin ; } else { if ( ! m Children Frozen [ child Index ] ) { float raw Calculated Height = child . get Measured Height ( ) - unit Shrink * lp . flex Shrink ; if ( i == flex Line . m Item Count - NUM ) { raw Calculated Height += accumulated Round Error ; accumulated Round Error = NUM ; } int new Height = Math . round ( raw Calculated Height ) ; if ( new Height < lp . min Height ) { needs Reshrink = BOOL ; new Height = lp . min Height ; m Children Frozen [ child Index ] = BOOL ; flex Line . m Total Flex Shrink -= lp . flex Shrink ; } else { accumulated Round Error += ( raw Calculated Height - new Height ) ; if ( accumulated Round Error > NUM ) { new Height += NUM ; accumulated Round Error -= NUM ; } else if ( accumulated Round Error < - NUM ) { new Height -= NUM ; accumulated Round Error += NUM ; } } child . measure ( Measure Spec . make Measure Spec ( child . get Measured Width ( ) , Measure Spec . EXACTLY ) , Measure Spec . make Measure Spec ( new Height , Measure Spec . EXACTLY ) ) ; } flex Line . m Main Size += child . get Measured Height ( ) + lp . top Margin + lp . bottom Margin ; } child Index ++ ; } if ( needs Reshrink && size Before Shrink != flex Line . m Main Size ) { shrink Flex Items ( flex Line , flex Direction , max Main Size , padding Along Main Axis , start Index ) ; } return child Index ; }
public static Data Model List serializable Instance ( ) { return new Data Model List ( ) ; }
@ Override public MB Header find Last MB Page No For Line Item ( final Work Order Activity work Order Activity , final Long mb Header Id ) { logger . info ( STRING ) ; String query = STRING ; Object [ ] params ; final List < Object > param List = new Array List < Object > ( ) ; query = query + STRING + STRING + STRING + STRING ; param List . add ( work Order Activity . get Id ( ) ) ; param List . add ( mb Header Id ) ; param List . add ( Works Constants . APPROVED ) ; param List . add ( mb Header Id ) ; params = new Object [ param List . size ( ) ] ; params = param List . to Array ( params ) ; final List < MB Header > mb Header List = generic Service . find All By ( query , params ) ; MB Header result = null ; if ( mb Header List != null && ! mb Header List . is Empty ( ) ) result = mb Header List . get ( NUM ) ; return result ; }
synchronized private void output Buffered Chunk ( ) { if ( small Chunks == null || chunk Size == NUM ) { return ; } if ( small Chunks . size ( ) == NUM ) { output Chunk ( small Chunks . get ( NUM ) ) ; chunk Size = NUM ; small Chunks = null ; return ; } final I Binding Set [ ] chunk = new I Binding Set [ chunk Size ] ; int dest Pos = NUM ; for ( I Binding Set [ ] e : small Chunks ) { System . arraycopy ( e , NUM , chunk , dest Pos , e . length ) ; dest Pos += e . length ; } output Chunk ( chunk ) ; chunk Size = NUM ; small Chunks = null ; }
public Byte Vector put Byte Array ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b != null ) { System . arraycopy ( b , off , data , length , len ) ; } length += len ; return this ; }
private void wait Load Compete ( ) { if ( m load Complete ) return ; m loader . set Priority ( Thread . NORM PRIORITY ) ; log . config ( STRING ) ; while ( m loader . is Alive ( ) ) { try { Thread . sleep ( NUM ) ; } catch ( Exception e ) { log . log ( Level . SEVERE , STRING , e ) ; } } log . config ( STRING ) ; }
@ Suppress Warnings ( STRING ) private void dtdatt ( Pair elm ) throws Exception { char attqn [ ] = null ; Pair att = null ; char ch ; for ( short st = NUM ; st >= NUM ; ) { ch = getch ( ) ; switch ( st ) { case NUM : switch ( chtyp ( ch ) ) { case STRING : case STRING : case STRING : case STRING : case STRING : bkch ( ) ; attqn = qname ( m Is NS Aware ) ; att = find ( elm . list , attqn ) ; if ( att == null ) { att = pair ( elm . list ) ; att . chars = attqn ; elm . list = att ; } else { att = pair ( null ) ; att . chars = attqn ; att . id = STRING ; } wsskip ( ) ; st = NUM ; break ; case STRING : pent ( STRING ) ; break ; case STRING : break ; default : panic ( FAULT ) ; break ; } break ; case NUM : switch ( chtyp ( ch ) ) { case STRING : att . id = STRING ; st = NUM ; break ; case STRING : pent ( STRING ) ; break ; case STRING : break ; default : bkch ( ) ; bntok ( ) ; att . id = bkeyword ( ) ; switch ( att . id ) { case STRING : if ( wsskip ( ) != STRING ) { panic ( FAULT ) ; } ch = getch ( ) ; st = NUM ; break ; case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : wsskip ( ) ; st = NUM ; break ; default : panic ( FAULT ) ; break ; } break ; } break ; case NUM : switch ( chtyp ( ch ) ) { case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : bkch ( ) ; switch ( att . id ) { case STRING : bntok ( ) ; break ; case STRING : m Buff Idx = - NUM ; bname ( BOOL ) ; break ; default : panic ( FAULT ) ; break ; } wsskip ( ) ; st = NUM ; break ; case STRING : pent ( STRING ) ; break ; case STRING : break ; default : panic ( FAULT ) ; break ; } break ; case NUM : switch ( ch ) { case STRING : wsskip ( ) ; st = NUM ; break ; case STRING : wsskip ( ) ; switch ( att . id ) { case STRING : bntok ( ) ; break ; case STRING : m Buff Idx = - NUM ; bname ( BOOL ) ; break ; default : panic ( FAULT ) ; break ; } wsskip ( ) ; break ; case STRING : pent ( STRING ) ; break ; default : panic ( FAULT ) ; break ; } break ; case NUM : switch ( ch ) { case STRING : bntok ( ) ; switch ( bkeyword ( ) ) { case STRING : switch ( wsskip ( ) ) { case STRING : case STRING : st = NUM ; break ; case EOS : panic ( FAULT ) ; default : st = - NUM ; break ; } break ; case STRING : case STRING : st = - NUM ; break ; default : panic ( FAULT ) ; break ; } break ; case STRING : case STRING : bkch ( ) ; st = NUM ; break ; case STRING : case STRING : case STRING : case STRING : break ; case STRING : pent ( STRING ) ; break ; default : bkch ( ) ; st = - NUM ; break ; } break ; case NUM : switch ( ch ) { case STRING : case STRING : bkch ( ) ; bqstr ( STRING ) ; att . list = pair ( null ) ; att . list . chars = new char [ att . chars . length + m Buff Idx + NUM ] ; System . arraycopy ( att . chars , NUM , att . list . chars , NUM , att . chars . length - NUM ) ; att . list . chars [ att . chars . length - NUM ] = STRING ; att . list . chars [ att . chars . length ] = ch ; System . arraycopy ( m Buff , NUM , att . list . chars , att . chars . length + NUM , m Buff Idx ) ; att . list . chars [ att . chars . length + m Buff Idx + NUM ] = ch ; att . list . chars [ att . chars . length + m Buff Idx + NUM ] = STRING ; st = - NUM ; break ; default : panic ( FAULT ) ; break ; } break ; default : panic ( FAULT ) ; break ; } } }
public void add Classes ( List < String > class Names ) { if ( handler Factories == null ) { handler Factories = new Array List < String > ( ) ; } handler Factories . add All ( class Names ) ; }
public static boolean is Constant Name ( String name ) { return Pattern . matches ( STRING , name ) ; }
private void notify Dead ( final RP Entity dead ) { if ( ! rats . remove ( dead ) ) { logger . warn ( STRING + dead . to String ( ) + STRING ) ; } if ( rats . size ( ) == NUM ) { phase To Default Phase ( new Linked List < String > ( Arrays . as List ( STRING ) ) ) ; } }
public static OM Grid read ( Data Input Stream dis ) throws IO Exception { return read ( dis , null ) ; }
public Varchar Constant ( String s ) { type = new Varchar Type ( s . length ( ) ) ; val = s ; }
public boolean add Child Planet ( Dimension Properties child ) { if ( child == this ) return BOOL ; child Planets . add ( child . get Id ( ) ) ; child . set Parent Planet ( this ) ; return BOOL ; }
@ Override public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( NUM ) ; new Vector . add ( STRING ) ; return new Vector . elements ( ) ; }
int [ ] calculate Relative ( int [ ] absolute ) { int [ ] res = new int [ absolute . length ] ; res [ NUM ] = absolute [ NUM ] ; for ( int i = NUM ; i < res . length ; i ++ ) { res [ i ] = absolute [ i ] - absolute [ i - NUM ] ; } return res ; }
@ After Class public static void delete Log Dir ( ) { if ( log Dir != null ) { File Utils . delete Quietly ( log Dir ) ; } }
public String to String ( ) { String Buffer sb = new String Buffer ( ) ; char [ ] separator = { STRING , STRING } ; int n = rows ( ) ; int m = columns ( ) ; for ( int i = NUM ; i < n ; i ++ ) { separator [ NUM ] = STRING ; for ( int j = NUM ; j < m ; j ++ ) { sb . append ( separator ) ; sb . append ( components [ i ] [ j ] ) ; separator [ NUM ] = STRING ; } sb . append ( STRING ) ; sb . append ( STRING ) ; } return sb . to String ( ) ; }
public static String [ ] split String Into Array ( String value ) { String [ ] values = new String [ NUM ] ; if ( value != null && value . length ( ) > NUM ) { if ( value . index Of ( CIM Constants . COMMA SEPERATOR ) != - NUM ) { values = value . split ( STRING ) ; } else { values = new String [ NUM ] ; values [ NUM ] = value ; } } return values ; }
public static String from Attr Modeling Model Class ( String va Model Class ) { return va Model Class . split ( Value Analysis . MODEL PACKAGE PREFIX ) [ NUM ] ; }
private void pull Event ( ) { final int new Scroll Value ; final int item Dimension ; final float initial Motion Value , last Motion Value ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : initial Motion Value = m Initial Motion X ; last Motion Value = m Last Motion X ; break ; case VERTICAL : default : initial Motion Value = m Initial Motion Y ; last Motion Value = m Last Motion Y ; break ; } switch ( m Current Mode ) { case PULL FROM END : new Scroll Value = Math . round ( Math . max ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Footer Size ( ) ; break ; case PULL FROM START : default : new Scroll Value = Math . round ( Math . min ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Header Size ( ) ; break ; } set Header Scroll ( new Scroll Value ) ; if ( new Scroll Value != NUM && ! is Refreshing ( ) ) { float scale = Math . abs ( new Scroll Value ) / ( float ) item Dimension ; switch ( m Current Mode ) { case PULL FROM END : m Footer Layout . on Pull ( scale ) ; break ; case PULL FROM START : default : m Header Layout . on Pull ( scale ) ; break ; } if ( m State != State . PULL TO REFRESH && item Dimension >= Math . abs ( new Scroll Value ) ) { set State ( State . PULL TO REFRESH ) ; } else if ( m State == State . PULL TO REFRESH && item Dimension < Math . abs ( new Scroll Value ) ) { set State ( State . RELEASE TO REFRESH ) ; } } }
public synchronized void add ( Dcc Loco Address loco Address , boolean direction Normal ) { if ( ! contains ( loco Address ) ) { if ( Consist List . size ( ) == NUM ) { byte command = Nce Binary Command . LOCO CMD FWD CONSIST LEAD ; if ( ! direction Normal ) { command = Nce Binary Command . LOCO CMD REV CONSIST LEAD ; } add Loco To Consist ( loco Address . get Number ( ) , loco Address . is Long Address ( ) , command ) ; Consist Position . put ( loco Address , Dcc Consist . POSITION LEAD ) ; } else if ( Consist List . size ( ) == NUM ) { byte command = Nce Binary Command . LOCO CMD FWD CONSIST REAR ; if ( ! direction Normal ) { command = Nce Binary Command . LOCO CMD REV CONSIST REAR ; } add Loco To Consist ( loco Address . get Number ( ) , loco Address . is Long Address ( ) , command ) ; Consist Position . put ( loco Address , Dcc Consist . POSITION TRAIL ) ; } else { byte command = Nce Binary Command . LOCO CMD FWD CONSIST MID ; if ( ! direction Normal ) { command = Nce Binary Command . LOCO CMD REV CONSIST MID ; } add Loco To Consist ( loco Address . get Number ( ) , loco Address . is Long Address ( ) , command ) ; Consist Position . put ( loco Address , Consist Position . size ( ) ) ; } Consist List . add ( loco Address ) ; Consist Dir . put ( loco Address , Boolean . value Of ( direction Normal ) ) ; } else { log . error ( STRING + loco Address + STRING + get Consist Address ( ) ) ; } }
private Grid Client Configuration client Configuration ( ) { Grid Client Configuration cfg = new Grid Client Configuration ( ) ; cfg . set Topology Refresh Frequency ( topology Refresh Frequency ( ) ) ; cfg . set Max Connection Idle Time ( max Connection Idle Time ( ) ) ; cfg . set Protocol ( protocol ( ) ) ; cfg . set Servers ( Arrays . as List ( server Address ( ) ) ) ; cfg . set Balancer ( new Grid Client Round Robin Balancer ( ) ) ; if ( use Ssl ( ) ) cfg . set Ssl Context Factory ( ssl Context Factory ( ) ) ; Grid Client Data Configuration loc = new Grid Client Data Configuration ( ) ; Grid Client Data Configuration partitioned = new Grid Client Data Configuration ( ) ; partitioned . set Name ( PARTITIONED CACHE NAME ) ; partitioned . set Affinity ( new Grid Client Partition Affinity ( ) ) ; Grid Client Data Configuration partitioned Async Backup = new Grid Client Data Configuration ( ) ; partitioned Async Backup . set Name ( PARTITIONED ASYNC BACKUP CACHE NAME ) ; partitioned Async Backup . set Affinity ( new Grid Client Partition Affinity ( ) ) ; Grid Client Data Configuration replicated = new Grid Client Data Configuration ( ) ; replicated . set Name ( REPLICATED CACHE NAME ) ; Grid Client Data Configuration replicated Async = new Grid Client Data Configuration ( ) ; replicated Async . set Name ( REPLICATED ASYNC CACHE NAME ) ; cfg . set Data Configurations ( Arrays . as List ( loc , partitioned , replicated , replicated Async , partitioned Async Backup ) ) ; return cfg ; }
public final Test Subscriber assert Not Subscribed ( ) { String prefix = STRING ; if ( done . get Count ( ) != NUM ) { prefix = STRING ; } if ( subscription . get ( ) != null ) { fail ( prefix , STRING , errors ) ; } else if ( ! errors . is Empty ( ) ) { fail ( prefix , STRING , errors ) ; } return this ; }
public Builder ( ) { set Version Code ( Math . min ( Fresh Air . get Current Application Version ( ) , NUM ) ) ; set Features ( new Linked List < Feature Info > ( ) ) ; }
protected String convert Date Format ( String pattern ) { boolean inside = BOOL ; boolean mark = BOOL ; boolean modified Command = BOOL ; String Builder buf = new String Builder ( ) ; for ( int i = NUM ; i < pattern . length ( ) ; i ++ ) { char c = pattern . char At ( i ) ; if ( c == STRING && ! mark ) { mark = BOOL ; } else { if ( mark ) { if ( modified Command ) { modified Command = BOOL ; mark = BOOL ; } else { inside = translate Command ( buf , pattern , i , inside ) ; if ( c == STRING || c == STRING ) { modified Command = BOOL ; } else { mark = BOOL ; } } } else { if ( ! inside && c != STRING ) { buf . append ( STRING ) ; inside = BOOL ; } buf . append ( c ) ; } } } if ( buf . length ( ) > NUM ) { char last Char = buf . char At ( buf . length ( ) - NUM ) ; if ( last Char != STRING && inside ) { buf . append ( STRING ) ; } } return buf . to String ( ) ; }
public void add Child Node ( Eval Factory Node child Node ) { child Nodes . add ( child Node ) ; }
public final void head To ( Tuple 3 d p ) { double angle = Geometric . angle ( this . location , p ) ; turn To ( Math . to Degrees ( angle ) ) ; }
public void compact Buffer ( ) { if ( offset != buffer . length ) { byte [ ] new Buffer = new byte [ offset ] ; System . arraycopy ( buffer , NUM , new Buffer , NUM , offset ) ; buffer = new Buffer ; } }
public static byte [ ] decode ( String s ) { return decode ( s . to Char Array ( ) ) ; }
public static int put Byte Buffer ( byte [ ] bytes , int offset , Byte Buffer buf ) { int len = buf . remaining ( ) ; buf . get ( bytes , offset , len ) ; return offset + len ; }
private void clear Index To First ( ) { for ( ; ; ) { Index < K , V > q = head ; for ( ; ; ) { Index < K , V > r = q . right ; if ( r != null && r . indexes Deleted Node ( ) && ! q . unlink ( r ) ) break ; if ( ( q = q . down ) == null ) { if ( head . right == null ) try Reduce Level ( ) ; return ; } } } }
final void try Terminate ( ) { for ( ; ; ) { int c = ctl . get ( ) ; if ( is Running ( c ) || run State At Least ( c , TIDYING ) || ( run State Of ( c ) == SHUTDOWN && ! work Queue . is Empty ( ) ) ) return ; if ( worker Count Of ( c ) != NUM ) { interrupt Idle Workers ( ONLY ONE ) ; return ; } final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { if ( ctl . compare And Set ( c , ctl Of ( TIDYING , NUM ) ) ) { try { terminated ( ) ; } finally { ctl . set ( ctl Of ( TERMINATED , NUM ) ) ; termination . signal All ( ) ; } return ; } } finally { main Lock . unlock ( ) ; } } }
public void join Resource ( ) throws Interrupted Exception { if ( run Obj != null ) { synchronized ( complete ) { if ( run Obj != null ) complete . wait ( ) ; } } }
public static String to JSON String ( List list ) { if ( list == null ) return STRING ; boolean first = BOOL ; String Buffer sb = new String Buffer ( ) ; Iterator iter = list . iterator ( ) ; sb . append ( STRING ) ; while ( iter . has Next ( ) ) { if ( first ) first = BOOL ; else sb . append ( STRING ) ; Object value = iter . next ( ) ; if ( value == null ) { sb . append ( STRING ) ; continue ; } sb . append ( JSON Value . to JSON String ( value ) ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
@ Override public int hash Code ( ) { final int prime = NUM ; int result = super . hash Code ( ) ; result = prime * result + ( tenant == null ? NUM : tenant . hash Code ( ) ) ; return result ; }
public void load Accessors ( Mapped Field configured Field , Mapped Field target Field ) { load Accessors ( target Class , configured Field , target Field ) ; }
public static Matrix Block reshape ( Matrix Block in , Matrix Block out , int rows , int cols , boolean rowwise ) throws DML Runtime Exception { int rlen = in . rlen ; int clen = in . clen ; if ( ( ( long ) rlen ) * clen != ( ( long ) rows ) * cols ) throw new DML Runtime Exception ( STRING + rlen + STRING + clen + STRING + rows + STRING + cols + STRING ) ; if ( rlen == rows && clen == cols ) { out . copy ( in ) ; return out ; } out . sparse = Matrix Block . eval Sparse Format In Memory ( rows , cols , in . non Zeros ) ; out . rlen = rows ; out . clen = cols ; out . non Zeros = in . non Zeros ; if ( ! in . sparse && ! out . sparse ) reshape Dense ( in , out , rows , cols , rowwise ) ; else if ( in . sparse && out . sparse ) reshape Sparse ( in , out , rows , cols , rowwise ) ; else if ( in . sparse ) reshape Sparse To Dense ( in , out , rows , cols , rowwise ) ; else reshape Dense To Sparse ( in , out , rows , cols , rowwise ) ; return out ; }
public static Class < ? > [ ] to Classes From Objects ( final Object [ ] params ) { final Class < ? > [ ] classes = new Class < ? > [ params . length ] ; int i = NUM ; for ( final Object object : params ) { if ( object != null ) { classes [ i ++ ] = object . get Class ( ) ; } else { classes [ i ++ ] = Object . class ; } } return classes ; }
public Admin Region ( String local Name , Remote Gem Fire VM vm , String user Attribute Desc ) { String gn = local Name ; int idx = local Name . last Index Of ( name Sep ) ; if ( idx != - NUM ) { local Name = local Name . substring ( idx + NUM ) ; } else { gn = name Sep + gn ; } this . global Name = gn ; this . local Name = local Name ; this . user Attribute Desc = user Attribute Desc ; this . vm = vm ; }
public Element sign With WSSX 509 Token Profile ( Document doc , java . security . cert . Certificate cert , String algorithm , List ids ) throws XML Signature Exception { return sign With WSSX 509 Token Profile ( doc , cert , algorithm , ids , SOAP Binding Constants . WSF 10 VERSION ) ; }
public void add User Message Listener ( User Message Listener user Message Listener ) { user Message Listeners . add ( user Message Listener ) ; }
public Iterator Builder add Template ( I Space Query query ) { templates . add ( query ) ; return this ; }
public String add To Class Path ( final String path ) { this . class Path += ( System . get Property ( STRING ) + path ) ; return this . class Path ; }
private static int New Long Array ( JNI Environment env , int length ) { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { long [ ] new Array = new long [ length ] ; return env . push JNI Ref ( new Array ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
protected abstract void finalize Output ( final int [ ] source Image Pixels , final int image Width , final int image Height ) ;
public static boolean ignoring Battery Optimizations ( ) { return Ngn Application . ignoring Battery Optimizations ( null ) ; }
private boolean retry Delay Has Passed By ( Long last Fail Time ) { return last Fail Time == null || last Fail Time + this . retry After Ms < System . current Time Millis ( ) ; }
public static java . lang . String value Of ( long l ) { return Long . to String ( l ) ; }
private boolean use Metric ( Metric Rule rule , Metric metric ) { if ( rule . aws Dimension Select == null && rule . aws Dimension Select Regex == null ) { return BOOL ; } if ( rule . aws Dimension Select != null && metrics Is In Aws Dimension Select ( rule , metric ) ) { return BOOL ; } if ( rule . aws Dimension Select Regex != null && metric Is In Aws Dimension Select Regex ( rule , metric ) ) { return BOOL ; } return BOOL ; }
final void add Icon Manager ( Abstract Status Icon Manager manager ) { icon Managers . add ( manager ) ; }
public Index Meta Data upgrade Index Meta Data ( Index Meta Data index Meta Data ) { if ( is Upgraded ( index Meta Data ) ) { return index Meta Data ; } check Supported Version ( index Meta Data ) ; Index Meta Data new Meta Data = upgrade Legacy Routing Settings ( index Meta Data ) ; new Meta Data = add Default Units If Needed ( new Meta Data ) ; check Mappings Compatibility ( new Meta Data ) ; new Meta Data = upgrade Settings ( new Meta Data ) ; new Meta Data = mark As Upgraded ( new Meta Data ) ; return new Meta Data ; }
static final void encode ( byte [ ] src , int src Off , int len , byte [ ] dst , int dst Off ) { dst [ dst Off ] = ( byte ) ENCODE TABLE . char At ( ( src [ src Off ] > > NUM ) & NUM ) ; if ( len == NUM ) { dst [ dst Off + NUM ] = ( byte ) ENCODE TABLE . char At ( ( ( src [ src Off ] << NUM ) & NUM ) | ( ( src [ src Off + NUM ] > > NUM ) & NUM ) ) ; dst [ dst Off + NUM ] = ( byte ) ENCODE TABLE . char At ( ( ( src [ src Off + NUM ] << NUM ) & NUM ) | ( ( src [ src Off + NUM ] > > NUM ) & NUM ) ) ; dst [ dst Off + NUM ] = ( byte ) ENCODE TABLE . char At ( src [ src Off + NUM ] & NUM ) ; } else if ( len == NUM ) { dst [ dst Off + NUM ] = ( byte ) ENCODE TABLE . char At ( ( ( src [ src Off ] << NUM ) & NUM ) | ( ( src [ src Off + NUM ] > > NUM ) & NUM ) ) ; dst [ dst Off + NUM ] = ( byte ) ENCODE TABLE . char At ( ( src [ src Off + NUM ] << NUM ) & NUM ) ; } else { dst [ dst Off + NUM ] = ( byte ) ENCODE TABLE . char At ( ( src [ src Off ] << NUM ) & NUM ) ; } }
public static void convolve V ( Kernel kernel , int [ ] in Pixels , int [ ] out Pixels , int width , int height , boolean alpha , int edge Action ) { int index = NUM ; float [ ] matrix = kernel . get Kernel Data ( null ) ; int rows = kernel . get Height ( ) ; int rows 2 = rows / NUM ; for ( int y = NUM ; y < height ; y ++ ) { for ( int x = NUM ; x < width ; x ++ ) { float r = NUM , g = NUM , b = NUM , a = NUM ; for ( int row = - rows 2 ; row <= rows 2 ; row ++ ) { int iy = y + row ; int ioffset ; if ( iy < NUM ) { if ( edge Action == CLAMP EDGES ) ioffset = NUM ; else if ( edge Action == WRAP EDGES ) ioffset = ( ( y + height ) % height ) * width ; else ioffset = iy * width ; } else if ( iy >= height ) { if ( edge Action == CLAMP EDGES ) ioffset = ( height - NUM ) * width ; else if ( edge Action == WRAP EDGES ) ioffset = ( ( y + height ) % height ) * width ; else ioffset = iy * width ; } else ioffset = iy * width ; float f = matrix [ row + rows 2 ] ; if ( f != NUM ) { int rgb = in Pixels [ ioffset + x ] ; a += f * ( ( rgb > > NUM ) & NUM ) ; r += f * ( ( rgb > > NUM ) & NUM ) ; g += f * ( ( rgb > > NUM ) & NUM ) ; b += f * ( rgb & NUM ) ; } } int ia = alpha ? Pixel Utils . clamp ( ( int ) ( a + NUM ) ) : NUM ; int ir = Pixel Utils . clamp ( ( int ) ( r + NUM ) ) ; int ig = Pixel Utils . clamp ( ( int ) ( g + NUM ) ) ; int ib = Pixel Utils . clamp ( ( int ) ( b + NUM ) ) ; out Pixels [ index ++ ] = ( ia << NUM ) | ( ir << NUM ) | ( ig << NUM ) | ib ; } } }
@ Suppress Warnings ( STRING ) public final void store Data ( final List data ) throws IDB Persistence Exception { Sql Session session = null ; int size = data . size ( ) ; int commited = NUM ; T dt Short Term Log ; try { session = sql Session Factory . open Session ( Executor Type . BATCH , BOOL ) ; if ( LOGGER . is Debug Enabled ( ) ) { LOGGER . debug ( STRING + session . to String ( ) + STRING ) ; } Logger Mapper < T > persistence Mapper = session . get Mapper ( mapper Interface ) ; for ( int i = NUM ; i != size ; i ++ ) { if ( ( NUM == i % RECORDS PER BATCH ) && i > NUM ) { if ( LOGGER . is Debug Enabled ( ) ) { LOGGER . debug ( STRING + i ) ; } session . commit ( ) ; commited = i ; } if ( data . get ( i ) != null ) { dt Short Term Log = ( T ) data . get ( i ) ; if ( LOGGER . is Debug Enabled ( ) ) { LOGGER . debug ( STRING + dt Short Term Log . get Id ( ) ) ; } persistence Mapper . insert Log ( dt Short Term Log ) ; } } session . commit ( ) ; commited = size ; } catch ( Persistence Exception e ) { LOGGER . error ( STRING + data . size ( ) + STRING , e ) ; try { if ( session != null ) { session . rollback ( ) ; } } catch ( Exception sql ) { LOGGER . error ( STRING , sql ) ; } throw new IDB Persistence Exception ( e . get Message ( ) , commited ) ; } finally { try { if ( session != null ) { session . close ( ) ; } } catch ( Exception e ) { LOGGER . error ( STRING , e ) ; } } }
@ Suppress Warnings ( STRING ) public static Map < String , Configuration Key < ? > > registered Keys ( ) { synchronized ( registered Keys ) { if ( copy == null ) copy = Collections . unmodifiable Map ( ( Map < String , Configuration Key < ? > > ) registered Keys . clone ( ) ) ; return copy ; } }
public static String md 5 ( String string To Hash ) { if ( string To Hash != null ) { try { Message Digest md = Message Digest . get Instance ( STRING ) ; byte [ ] bytes = md . digest ( string To Hash . get Bytes ( ) ) ; String Builder sb = new String Builder ( NUM * bytes . length ) ; for ( int i = NUM ; i < bytes . length ; i ++ ) { int low = ( bytes [ i ] & NUM ) ; int high = ( ( bytes [ i ] & NUM ) > > NUM ) ; sb . append ( Constants . HEXADECIMAL [ high ] ) ; sb . append ( Constants . HEXADECIMAL [ low ] ) ; } return sb . to String ( ) ; } catch ( No Such Algorithm Exception e ) { return STRING ; } } else { return STRING ; } }
public String most Of String ( ) { String type Name = STRING ; switch ( type ) { case BUILTIN : type Name = STRING ; break ; case NUMBER : type Name = STRING ; break ; case STRING : type Name = STRING ; break ; case PF STEP : type Name = STRING ; break ; case IDENT : type Name = STRING ; break ; case COMMENT : type Name = STRING ; break ; case DASHES : type Name = STRING ; break ; case END MODULE : type Name = STRING ; break ; case PROLOG : type Name = STRING ; break ; case EPILOG : type Name = STRING ; break ; case PCAL LABEL : type Name = STRING ; break ; } ; String str = STRING + string + STRING ; if ( string == null ) { str = STRING ; } ; String result = STRING + str + STRING + type Name + STRING + column + STRING + get Width ( ) ; if ( above Align . line != - NUM ) { result = result + STRING + above Align . to String ( ) ; } ; if ( below Align . line != - NUM ) { result = result + STRING + below Align . to String ( ) ; } ; if ( pre Space != NUM ) { result = result + STRING + pre Space ; } ; if ( is Alignment Point ) { result = result + STRING ; } ; if ( dist From Margin != NUM ) { result = result + STRING + dist From Margin ; } ; if ( subscript ) { result = result + STRING ; } ; return result ; }
public Create Index Request mapping ( String type , X Content Builder source ) { if ( mappings . contains Key ( type ) ) { throw new Illegal State Exception ( STRING + type + STRING ) ; } try { mappings . put ( type , source . string ( ) ) ; } catch ( IO Exception e ) { throw new Illegal Argument Exception ( STRING , e ) ; } return this ; }
public static Pretty Print indent With Spaces ( int number ) { if ( number < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } char [ ] chars = new char [ number ] ; Arrays . fill ( chars , STRING ) ; return new Pretty Print ( chars ) ; }
private static void copy File ( File src , File dst , Integer port , boolean internal Compression ) throws IO Exception { Buffered Reader in = new Buffered Reader ( new Input Stream Reader ( new File Input Stream ( src ) , Standard Charsets . UTF 8 ) ) ; Writer out = new Output Stream Writer ( new File Output Stream ( dst ) , Standard Charsets . UTF 8 ) ; for ( String line = in . read Line ( ) ; null != line ; line = in . read Line ( ) ) { if ( null != port ) line = line . replace ( STRING , port . to String ( ) ) ; line = line . replace ( STRING , internal Compression ? STRING : STRING ) ; out . write ( line ) ; } in . close ( ) ; out . close ( ) ; }
public void assert Event Log Contains ( Object event ) { if ( ! m Event Log . contains ( event ) ) { fail ( STRING + m Event Log ) ; } }
private static boolean is All Underscores ( ) { int i = NUM ; boolean result = BOOL ; while ( result && ( i < token . length ( ) ) ) { if ( token . char At ( i ) != STRING ) { result = BOOL ; } ; i = i + NUM ; } ; return result ; }
public Image Warp ( Buffered Image bi , Geo Coord Transformation transform , Data Bounds image Bounds ) { if ( bi != null ) { iwidth = bi . get Width ( ) ; iheight = bi . get Height ( ) ; set Geo Trans ( transform ) ; set Image Bounds ( image Bounds ) ; pixels = get Pixels ( bi , NUM , NUM , iwidth , iheight ) ; bi = null ; } }
public static Equipment Logger Factory create Factory ( final Equipment Configuration econf , final Process Configuration pconf , boolean use Equipment Loggers , boolean use Equipment Appenders Only ) { return new Equipment Logger Factory ( econf . get Handler Class Name ( ) , Long . value Of ( econf . get Id ( ) ) , econf . get Name ( ) , pconf . get Process Name ( ) , use Equipment Loggers , use Equipment Appenders Only ) ; }
protected void assert Equals ( Integer expected , Integer actual ) { if ( expected == null || actual == null ) { if ( expected != actual ) { assert Equals ( STRING + expected , STRING + actual ) ; } } else { assert Equals ( expected . int Value ( ) , actual . int Value ( ) ) ; } }
public static boolean v Pool Specifies Snapshots ( final Virtual Pool virtual Pool ) { if ( virtual Pool . get Max Native Snapshots ( ) == null ) { return BOOL ; } return virtual Pool . get Max Native Snapshots ( ) != MAX DISABLED ; }
public void map Dataset To Axis ( int index , int axis Index ) { List axis Indices = new java . util . Array List ( NUM ) ; axis Indices . add ( new Integer ( axis Index ) ) ; map Dataset To Axes ( index , axis Indices ) ; }
public Authenticator App Registration URI Builder ( AM Identity id , String secret Hex , int code Length , String issuer ) { Reject . if Null ( id , STRING ) ; Reject . if Null ( secret Hex , STRING ) ; Reject . if True ( String Utils . is Blank ( issuer ) , STRING ) ; Reject . if True ( ( code Length < MIN CODE LENGTH ) , STRING + MIN CODE LENGTH + STRING ) ; if ( secret Hex . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } this . issuer = issuer ; this . id = id ; this . secret Hex = secret Hex ; this . code Length = code Length ; }
protected void update Application Enabled ( ) { fire Property Change ( STRING , Boolean . value Of ( ! is Enabled ( ) ) , Boolean . value Of ( is Enabled ( ) ) ) ; }
public Personality Insights ( final String version Date , String username , String password ) { this ( version Date ) ; set Username And Password ( username , password ) ; }
public String sign Message ( String message ) throws Illegal State Exception { Validate . not Null ( get Sign Algorithm ( ) , STRING ) ; Validate . not Null ( get Private Key ( ) , STRING ) ; Validate . not Empty ( message , STRING ) ; log . debug ( STRING + message + STRING + get Sign Algorithm ( ) ) ; try { Signature Algorithm algo = Signature Algorithm . get Signature Algorithm For URI ( get Sign Algorithm ( ) ) ; Signature sig = Signature . get Instance ( algo . get Algorithm Name ( ) ) ; sig . init Sign ( this . private Key ) ; byte [ ] message Bytes = message . get Bytes ( STRING ) ; sig . update ( message Bytes ) ; byte [ ] sig Bytes = sig . sign ( ) ; String signature = Shared Utils . encode Bytes ( sig Bytes ) ; log . debug ( STRING + signature ) ; return signature ; } catch ( Exception e ) { log . error ( STRING , e ) ; throw new Illegal State Exception ( e ) ; } }
private void output Price Lists ( Properties ctx , Print Writer out , boolean include Any ) { out . println ( STRING ) ; if ( include Any ) out . println ( STRING ) ; out . println ( STRING ) ; out . println ( STRING ) ; out . println ( STRING ) ; }
public void clear Bindings ( ) { if ( m Bind Args != null ) { Arrays . fill ( m Bind Args , null ) ; } }
public boolean assign If Best Match ( Method Declaration declaration ) { assert ! finalized : STRING ; if ( ! is Match ( declaration . get Parameters ( ) ) ) { return BOOL ; } if ( this . best Match Method . is Present ( ) ) { if ( this . best Match Method . get ( ) . get Parameters ( ) . size ( ) > declaration . get Parameters ( ) . size ( ) ) { return BOOL ; } } this . best Match Method = Optional . of ( declaration ) ; return BOOL ; }
public static List < User > from ( Cursor c ) { List < User > users = null ; int count = c . get Count ( ) ; if ( count > NUM ) { users = new Array List < > ( count ) ; while ( c . move To Next ( ) ) { User user = new User ( ) ; Syncing . from ( c , user ) ; int col = c . get Column Index ( EMAIL HASH ) ; if ( col >= NUM ) { user . email Hash = c . get String ( col ) ; } col = c . get Column Index ( FOLLOWING ) ; if ( col >= NUM ) { user . is Following = c . get Int ( col ) == NUM ; } users . add ( user ) ; } } c . close ( ) ; return users ; }
@ Override public void flush ( ) throws IO Exception { out . flush ( ) ; }
private void start Checking Status ( ) { future = executor . submit ( null ) ; }
private static Object new Instance No Service Loader ( Class < ? > provider Class ) { if ( System . get Security Manager ( ) == null ) { return null ; } try { Method creation Method = provider Class . get Declared Method ( STRING ) ; return creation Method . invoke ( null , ( Object [ ] ) null ) ; } catch ( No Such Method Exception exc ) { return null ; } catch ( Exception exc ) { return null ; } }
private void add Signature Profile ( Signature Wrapper signature , Xml Signature xml Signature ) { Signature Type signature Type = Signature Type . NA ; String certificate Id = signature . get Signing Certificate Id ( ) ; if ( certificate Id != null ) { signature Type = get Signature Type ( certificate Id ) ; } xml Signature . set Signature Level ( signature Type . name ( ) ) ; }
private static final int parse Time String ( String str ) { str = str . trim ( ) ; int ret = NUM ; boolean neg = BOOL ; int i = NUM ; if ( str . char At ( NUM ) == STRING ) { neg = BOOL ; i ++ ; } int num = NUM ; final int len = str . length ( ) ; for ( ; i < len ; i ++ ) { char c = str . char At ( i ) ; if ( ( c >= STRING ) && ( c <= STRING ) ) { num = num * NUM + c - STRING ; } else if ( c == STRING ) { ret += num ; num = NUM ; ret *= NUM ; } } ret += num ; ret *= NUM ; if ( neg ) ret = - ret ; return ret ; }
public synchronized void remove Image Listener ( Image Listener cl ) { m image Listeners . remove ( cl ) ; }
public Array List < Constraint Widget > build List ( Scout Widget [ ] list ) { Array List < Constraint Widget > ret = new Array List < > ( ) ; for ( int i = m Contain Set . next Set Bit ( NUM ) ; i >= NUM ; i = m Contain Set . next Set Bit ( i + NUM ) ) { ret . add ( list [ i ] . m Constraint Widget ) ; } return ret ; }
private boolean node Exists ( String Tokenizer path ) throws Backing Store Exception { String token = path . next Token ( ) ; if ( token . equals ( STRING ) ) throw new Illegal Argument Exception ( STRING ) ; synchronized ( lock ) { Abstract Preferences child = kid Cache . get ( token ) ; if ( child == null ) child = get Child ( token ) ; if ( child == null ) return BOOL ; if ( ! path . has More Tokens ( ) ) return BOOL ; path . next Token ( ) ; if ( ! path . has More Tokens ( ) ) throw new Illegal Argument Exception ( STRING ) ; return child . node Exists ( path ) ; } }
public int size ( ) { return delegate . size ( ) ; }
public Network Address Factory Impl ( ) throws Initialization Exception { this ( DEFAULT TCP HTTP LISTEN PORT ) ; }
public Transparent Glass Pane Panel ( Image Icon icon , String text , Color background Color , float transparency ) { set Layout ( new Grid Bag Layout ( ) ) ; Grid Bag Constraints gbc = new Grid Bag Constraints ( ) ; gbc . gridy = NUM ; gbc . gridx = NUM ; J Label icon Label = new J Label ( icon ) ; add ( icon Label , gbc ) ; gbc . gridy += NUM ; label = new J Label ( text ) ; add ( label , gbc ) ; if ( transparency > NUM ) { transparency = NUM ; } else if ( transparency < NUM ) { transparency = NUM ; } Color transparent Color = new Color ( background Color . get Red ( ) , background Color . get Green ( ) , background Color . get Blue ( ) , ( int ) ( transparency * NUM ) ) ; set Background ( transparent Color ) ; set Opaque ( BOOL ) ; }
@ Override protected void fill Header ( Header head ) { try { Standard . context ( Undefined Data . class ) ; head . set Xtension ( STRING ) ; head . set Bitpix ( Basic HDU . BITPIX BYTE ) ; head . set Naxes ( NUM ) ; head . add Value ( NAXI Sn . n ( NUM ) , this . data . length ) ; head . add Value ( PCOUNT , NUM ) ; head . add Value ( GCOUNT , NUM ) ; head . add Value ( EXTEND , BOOL ) ; } catch ( Header Card Exception e ) { LOG . log ( Level . SEVERE , STRING , e ) ; } finally { Standard . context ( null ) ; } }
protected void clean Stations And Network ( ) { log . info ( STRING ) ; clean Schedule ( ) ; remove Non Used Stop Facilities ( ) ; clean Modes ( ) ; remove Non Used Links ( ) ; log . info ( STRING ) ; }
private static String strip Apple Span From Markup ( String markup ) { String Builder stripped = new String Builder ( markup ) ; int prefix Beg Idx = stripped . index Of ( APPLE SPAN PREFIX ) ; while ( prefix Beg Idx >= NUM ) { int prefix End Idx = stripped . index Of ( STRING , prefix Beg Idx ) + NUM ; stripped . replace ( prefix Beg Idx , prefix End Idx , STRING ) ; int suffix Beg Idx = stripped . last Index Of ( APPLE SPAN SUFFIX ) ; int suffix End Idx = suffix Beg Idx + APPLE SPAN SUFFIX . length ( ) ; stripped . replace ( suffix Beg Idx , suffix End Idx , STRING ) ; prefix Beg Idx = stripped . index Of ( APPLE SPAN PREFIX ) ; } return stripped . to String ( ) ; }
private Invocation Constraints create Invocation Constraints ( ) { if ( MIN RETRY >= sleep Time [ try Indx ] ) { return new Invocation Constraints ( new Connection Absolute Time ( System . current Time Millis ( ) + sleep Time [ try Indx ] ) , null ) ; } else { return Invocation Constraints . EMPTY ; } }
public void create ( SSO Token token , String dn , Map attrs ) throws SMS Exception , SSO Exception { create ( token . get Principal ( ) , dn , attrs ) ; object Changed ( dn , ADD ) ; }
@ Override public void close ( ) throws IO Exception { if ( ! closed ) { try { if ( ! eof ) { exhaust Input Stream ( this ) ; } } finally { eof = BOOL ; closed = BOOL ; } } }
private void discard Downstream Media Chunk ( ) { Media Chunk removed = media Chunks . remove First ( ) ; long total Bytes = removed . bytes Loaded ( ) ; removed . release ( ) ; notify Downstream Discarded ( removed . start Time Us , removed . end Time Us , total Bytes ) ; }
public Object execute Script ( final Script script , final Script Context context ) { final Script Engine engine = script Engine Provider . get Script Engine ( script . get Type ( ) ) ; return execute Script ( script , engine , context ) ; }
public static Placeholder Fragment new Instance ( ) { Placeholder Fragment fragment = new Placeholder Fragment ( ) ; Bundle args = new Bundle ( ) ; fragment . set Arguments ( args ) ; return fragment ; }
void remove EQ ( Object o ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] array = queue ; for ( int i = NUM , n = size ; i < n ; i ++ ) { if ( o == array [ i ] ) { remove At ( i ) ; break ; } } } finally { lock . unlock ( ) ; } }
public T eval ( ) { return eval ( bindings ( ) ) ; }
public void add ( XMP Path Segment segment ) { segments . add ( segment ) ; }
private void next Sync ( ) { if ( sync Item Iterator . has Next ( ) ) { partial Start Time = System . current Time Millis ( ) ; current Sync Item = sync Item Iterator . next ( ) ; current Sync Item . sync ( this , host Connection , callback Handler , content Resolver ) ; } else { Log Utils . LOGD ( TAG , STRING + ( System . current Time Millis ( ) - start Time ) ) ; if ( listener != null ) { listener . on Sync Finished ( this ) ; } sync Service . stop Self ( service Start Id ) ; } }
public String decode ( String encoded ) { Json Object object = new Json Object ( encoded ) ; Json Array headers = object . get Json Array ( STRING ) ; for ( Object header Obj : headers ) { Json Array header = ( Json Array ) header Obj ; String key = header . get String ( NUM ) ; String value = header . get String ( NUM ) ; if ( key . equals Ignore Case ( CONTENT TYPE ) && ( value . contains ( STRING ) || value . contains ( APPLICATION JSON ) ) ) { try { object . put ( STRING , new Json Object ( new String ( object . get Binary ( PAYLOAD ) , Charset . for Name ( UTF 8 ) ) ) ) ; } catch ( Decode Exception e ) { object . put ( STRING , new String ( object . get Binary ( PAYLOAD ) , Charset . for Name ( UTF 8 ) ) ) ; } object . remove ( PAYLOAD ) ; break ; } } return object . to String ( ) ; }
public boolean matches Word ( ) { return ! is Empty ( ) && Character . is Letter Or Digit ( queue . char At ( pos ) ) ; }
public void test do As 01 ( ) { Subject subj = new Subject ( ) ; Privileged Action < Object > pa = new my Privileged Action ( ) ; Privileged Action < Object > pa Null = null ; try { Object obj = Subject . do As ( null , pa ) ; } catch ( Exception e ) { fail ( STRING + e ) ; } try { Object obj = Subject . do As ( subj , pa ) ; } catch ( Exception e ) { fail ( STRING + e ) ; } try { Object obj = Subject . do As ( subj , pa Null ) ; fail ( STRING ) ; } catch ( Null Pointer Exception npe ) { } }
public void test Divide Exp Less Zero ( ) { String a = STRING ; int a Scale = NUM ; String b = STRING ; int b Scale = NUM ; String c = STRING ; int res Scale = - NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; Big Decimal result = a Number . divide ( b Number , res Scale , Big Decimal . ROUND CEILING ) ; assert Equals ( STRING , c , result . to String ( ) ) ; assert Equals ( STRING , res Scale , result . scale ( ) ) ; }
public static boolean contains Whitespace ( final Char Sequence seq ) { if ( is Empty ( seq ) ) { return BOOL ; } final int str Len = seq . length ( ) ; for ( int i = NUM ; i < str Len ; i ++ ) { if ( Character . is Whitespace ( seq . char At ( i ) ) ) { return BOOL ; } } return BOOL ; }
public boolean is Wheel Event ( ) { return is Wheel Event ; }
public Connection ( String client Handle , String client Id , String host , int port , Context context , Mqtt Android Client client , boolean ssl Connection ) { this . client Handle = client Handle ; this . client Id = client Id ; this . host = host ; this . port = port ; this . context = context ; this . client = client ; this . ssl Connection = ssl Connection ; history = new Array List < String > ( ) ; String Buffer sb = new String Buffer ( ) ; sb . append ( STRING ) ; sb . append ( client Id ) ; sb . append ( STRING ) ; add Action ( sb . to String ( ) ) ; }
public void record State ( Dialogue State state , String name ) { if ( frame != null ) { state Monitor Tab . record State ( state , name ) ; } }
public void characters ( org . w3 c . dom . Node node ) throws org . xml . sax . SAX Exception { flush Pending ( ) ; String data = node . get Node Value ( ) ; if ( data != null ) { final int length = data . length ( ) ; if ( length > m chars Buff . length ) { m chars Buff = new char [ length * NUM + NUM ] ; } data . get Chars ( NUM , length , m chars Buff , NUM ) ; characters ( m chars Buff , NUM , length ) ; } }
private void compute Filters From Default ( Indicator View State old State ) { filters = new Array List < Filter > ( ) ; Set < String > default Filter Names = new Hash Set < String > ( ) ; for ( Filter default Filter : default Filters ) { filters . add ( default Filter ) ; if ( default Filter . name != null ) default Filter Names . add ( default Filter . name ) ; } if ( old State != null ) { for ( Filter old Filter : old State . filters ) { if ( old Filter . name == null || ! default Filter Names . contains ( old Filter . name ) ) filters . add ( old Filter ) ; } } }
private static Data parse Name ( Set me , Set peer ) { if ( me == null ) { throw new Null Pointer Exception ( STRING ) ; } else if ( me . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } Data data = new Data ( ) ; String Buffer b = new String Buffer ( ) ; data . me = cons ( me , b ) ; if ( peer != null && ! peer . is Empty ( ) ) { b . append ( STRING ) ; data . peer = cons ( peer , b ) ; } data . name = b . to String ( ) ; return data ; }
public static boolean stream Content Equals ( Input Stream s1 , Input Stream s2 ) throws IO Exception { try { int b1 , b2 ; do { b1 = s1 . read ( ) ; b2 = s2 . read ( ) ; } while ( ( b1 == b2 ) && ( b1 != - NUM ) ) ; return b1 == b2 ; } finally { try { s1 . close ( ) ; s2 . close ( ) ; } catch ( Exception e ) { } } }
public Content Node parse ( JS Doc Char Scanner scanner , Tag Dictionary < Abstract Inline Tag Definition > inline Tags Dictinary ) { Composed Content description = Dom Factory . eINSTANCE . create Composed Content ( ) ; if ( ! scanner . has Next ( ) ) { return null ; } if ( next Is Tag Title ( scanner ) ) { return null ; } int start = scanner . next Offset ( ) ; int end = start ; String Builder strb = new String Builder ( ) ; while ( scanner . has Next ( ) ) { char c = scanner . peek ( ) ; if ( region Start ( c ) ) { Scanner State st = scanner . save State ( ) ; Inline Tag tag = ( Inline Tag ) parse Region ( scanner , inline Tags Dictinary ) ; if ( tag != null ) { save Text Tokens ( description , start , end , strb ) ; strb = new String Builder ( ) ; start = end ; description . get Contents ( ) . add ( tag ) ; continue ; } else { scanner . restore State ( st ) ; if ( start == end ) { assert BOOL ; } } } scanner . next ( ) ; if ( JS Doc Char Scanner . is NL ( c ) ) { if ( scanner . has Next ( ) && ! next Is Tag Title ( scanner ) ) { end = scanner . offset ( ) ; } else { break ; } } strb . append ( c ) ; end = scanner . offset ( ) ; } String pending Data = strb . to String ( ) ; if ( pending Data . is Empty ( ) == BOOL ) { save Text Tokens ( description , start , end , strb ) ; } switch ( description . get Contents ( ) . size ( ) ) { case NUM : return null ; case NUM : return description . get Contents ( ) . get ( NUM ) ; default : return description ; } }
static public void add ( Errors errors , String text ) { if ( errors == null ) { return ; } errors . add ( text ) ; }
public synchronized void remove Icons For Pkg ( String package Name , User Handle Compat user ) { remove From Mem Cache Locked ( package Name , user ) ; long user Serial = m User Manager . get Serial Number For User ( user ) ; m Icon Db . delete ( Icon DB . COLUMN COMPONENT + STRING + Icon DB . COLUMN USER + STRING , new String [ ] { package Name + STRING , Long . to String ( user Serial ) } ) ; }
public boolean contains ( String s Category ) { return Category Estimations . contains Key ( s Category ) ; }
private void create Recursivly ( String path ) throws Keeper Exception , Interrupted Exception { try { if ( zk . exists ( path , BOOL ) == null && path . length ( ) > NUM ) { String temp = path . substring ( NUM , path . last Index Of ( File . separator ) ) ; create Recursivly ( temp ) ; zk . create ( path , null , Ids . OPEN ACL UNSAFE , Create Mode . PERSISTENT ) ; } else { return ; } } catch ( Keeper Exception e ) { throw e ; } catch ( Interrupted Exception e ) { throw e ; } }
public static final void front End Statistics ( Spec Obj spec ) { }
public String to String ( ) { if ( not Before == null || not After == null ) return STRING ; return ( STRING + not Before . to String ( ) + STRING + not After . to String ( ) + STRING ) ; }
public void zoom ( double x , double y , double factor ) { double range X = Math . abs ( current Extent . get Max X ( ) - current Extent . get Min X ( ) ) ; double range Y = Math . abs ( current Extent . get Max Y ( ) - current Extent . get Min Y ( ) ) ; current Extent . set Min X ( x - ( range X * factor ) / NUM ) ; current Extent . set Min Y ( y - ( range Y * factor ) / NUM ) ; current Extent . set Max X ( x + ( range X * factor ) / NUM ) ; current Extent . set Max Y ( y + ( range Y * factor ) / NUM ) ; add To Extent History ( current Extent ) ; }
protected boolean is Output Line Expected ( final String line , final String [ ] expected Prefixes , final boolean file Paths Are Expected ) { final String trimmed = line != null ? line . trim ( ) : null ; if ( String Utils . is Not Empty ( trimmed ) ) { if ( file Paths Are Expected && is File Path ( line ) ) { return BOOL ; } if ( expected Prefixes != null ) { for ( final String prefix : expected Prefixes ) { if ( String Utils . starts With Ignore Case ( line , prefix ) ) { return BOOL ; } } } return BOOL ; } return BOOL ; }
public static String meter To String ( OF Instruction Meter inst , Logger log ) { return STR SUB GOTO METER METER ID + STRING + Long . to String ( inst . get Meter Id ( ) ) ; }
public boolean is Image Cachable ( int w , int h ) { return ( w * h ) < max Single Image Pixel Size ; }
public static Big Integer size Of Directory As Big Integer ( File directory ) { check Directory ( directory ) ; final File [ ] files = directory . list Files ( ) ; if ( files == null ) { return Big Integer . ZERO ; } Big Integer size = Big Integer . ZERO ; for ( final File file : files ) { try { if ( ! is Symlink ( file ) ) { size = size . add ( Big Integer . value Of ( size Of ( file ) ) ) ; } } catch ( IO Exception ioe ) { } } return size ; }
private void write Attribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( xml Writer . get Prefix ( namespace ) == null ) { xml Writer . write Namespace ( prefix , namespace ) ; xml Writer . set Prefix ( prefix , namespace ) ; } xml Writer . write Attribute ( namespace , att Name , att Value ) ; }
public void free Entry ( Basic Pool Entry entry ) { if ( num Entries < NUM ) { throw new Illegal State Exception ( STRING + route ) ; } if ( num Entries <= free Entries . size ( ) ) { throw new Illegal State Exception ( STRING + route ) ; } free Entries . add ( entry ) ; }
public boolean is In ( Coords coords ) { return coordinates . contains ( coords ) ; }
private Dialog Base Units compute Dialog Base Units ( Font Metrics metrics ) { double average Char Width = compute Average Char Width ( metrics , average Char Width Test String ) ; int ascent = metrics . get Ascent ( ) ; double height = ascent > NUM ? ascent : ascent + ( NUM - ascent ) / NUM ; Dialog Base Units dialog Base Units = new Dialog Base Units ( average Char Width , height ) ; if ( LOGGER . is Loggable ( Level . CONFIG ) ) { LOGGER . config ( STRING + dialog Base Units + STRING + metrics . get Font ( ) ) ; } return dialog Base Units ; }
public synchronized void close ( ) { try { writer . close ( ) ; } catch ( IO Exception ioe ) { ioe . print Stack Trace ( ) ; } }
public static boolean is Proxy Uri ( final String url ) { not Null ( url ) ; return url . contains ( get Request Handler Path ( ) ) ; }
public void add Action ( Action act ) { if ( act . entry != null && act . entry != this ) { Log . e ( TAG , STRING + act . entry . ID + STRING + ID ) ; return ; } if ( m Actions == null ) { m Actions = new Array List < Action > ( ) ; } if ( m Actions . size ( ) == NUM ) { Log . w ( TAG , STRING ) ; return ; } act . entry = this ; m Actions . add ( act ) ; }
public abstract Iterable < ? extends Compilation Unit Tree > parse ( ) throws IO Exception ;
private void name ( String Builder builder ) { String name = type . get Name ( ) ; if ( name != null ) { builder . append ( STRING ) ; builder . append ( name ) ; builder . append ( STRING ) ; } }
boolean ensure Process Size Fits ( final Execution Unit process , final Rectangle 2 D rect ) { Dimension process Size = model . get Process Size ( process ) ; if ( process Size == null ) { return BOOL ; } if ( rect == null ) { return BOOL ; } boolean needs Resize = BOOL ; double process Width = process Size . get Width ( ) * ( NUM / model . get Zoom Factor ( ) ) ; double process Height = process Size . get Height ( ) * ( NUM / model . get Zoom Factor ( ) ) ; double width = process Width ; double height = process Height ; if ( process Size != null ) { if ( process Width < rect . get Max X ( ) + Process Drawer . GRID X OFFSET ) { double diff = rect . get Max X ( ) + Process Drawer . GRID X OFFSET - process Width ; if ( diff > Process Drawer . GRID X OFFSET ) { width += diff ; } else { width += Process Drawer . GRID X OFFSET ; } needs Resize = BOOL ; } if ( process Height < rect . get Max Y ( ) + Process Drawer . GRID Y OFFSET ) { double diff = rect . get Max Y ( ) + Process Drawer . GRID Y OFFSET - process Height ; if ( diff > Process Drawer . GRID Y OFFSET ) { height += diff ; } else { height += Process Drawer . GRID Y OFFSET ; } needs Resize = BOOL ; } if ( needs Resize ) { model . set Process Width ( process , width ) ; model . set Process Height ( process , height ) ; balance ( ) ; model . fire Process Size Changed ( ) ; return BOOL ; } } return BOOL ; }
public void handle Tbl Handlers Button Add Request ( Request Invocation Event event ) throws Model Control Exception { try { Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute ( PROPERTY ATTRIBUTE , ( Hash Map ) values ) ; WS Auth N Services Handlers Add View Bean vb = ( WS Auth N Services Handlers Add View Bean ) get View Bean ( WS Auth N Services Handlers Add View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } }
public void reduce DL ( double exp FP Rate , boolean check Err ) { boolean need Update = BOOL ; double [ ] ruleset Stat = new double [ NUM ] ; for ( int j = NUM ; j < m Simple Stats . size ( ) ; j ++ ) { ruleset Stat [ NUM ] += m Simple Stats . get ( j ) [ NUM ] ; ruleset Stat [ NUM ] += m Simple Stats . get ( j ) [ NUM ] ; ruleset Stat [ NUM ] += m Simple Stats . get ( j ) [ NUM ] ; if ( j == m Simple Stats . size ( ) - NUM ) { ruleset Stat [ NUM ] = m Simple Stats . get ( j ) [ NUM ] ; ruleset Stat [ NUM ] = m Simple Stats . get ( j ) [ NUM ] ; ruleset Stat [ NUM ] = m Simple Stats . get ( j ) [ NUM ] ; } } for ( int k = m Simple Stats . size ( ) - NUM ; k >= NUM ; k -- ) { double [ ] rule Stat = m Simple Stats . get ( k ) ; double if Deleted = potential ( k , exp FP Rate , ruleset Stat , rule Stat , check Err ) ; if ( ! Double . is Na N ( if Deleted ) ) { if ( k == ( m Simple Stats . size ( ) - NUM ) ) { remove Last ( ) ; } else { m Ruleset . remove ( k ) ; need Update = BOOL ; } } } if ( need Update ) { m Filtered = null ; m Simple Stats = null ; count Data ( ) ; } }
@ Override public void on Draw Frame ( GL 10 gl 10 ) { GLES 20 . gl Clear Color ( NUM , NUM , NUM , NUM ) ; GLES 20 . gl Clear ( GLES 20 . GL COLOR BUFFER BIT | GLES 20 . GL DEPTH BUFFER BIT ) ; GLES 20 . gl Enable ( GLES 20 . GL DEPTH TEST ) ; GLES 20 . gl Enable ( GLES 20 . GL CULL FACE ) ; GLES 20 . gl Enable ( GLES 20 . GL BLEND ) ; GLES 20 . gl Blend Func ( GLES 20 . GL SRC ALPHA , GLES 20 . GL ONE MINUS SRC ALPHA ) ; long current Time Millis = System . current Time Millis ( ) ; update With Delta ( current Time Millis - last Time Millis ) ; last Time Millis = current Time Millis ; }
public void remove Line Highlight ( Object tag ) { if ( tag instanceof Line Highlight Info ) { line Highlights . remove ( tag ) ; repaint Line ( ( Line Highlight Info ) tag ) ; } }
private Element create Single Log Out For Castle As IDP ( String binding ) throws Exception { String entity ID = idm Client . get Entity ID ( tenant Name ) ; String sso Loc = convert To IPV 6 Short Form ( entity ID ) ; if ( sso Loc == null ) { sso Loc = tenant Name ; } String slo Loc = sso Loc . replace All ( STRING , STRING ) ; Element slos Ele = create End Point ( SAML Names . SLOS , binding , slo Loc , null ) ; return slos Ele ; }
public static void unregister Transport M Bean ( String container Name ) throws Exception { M Bean Server m Bean Server = get M Bean Server ( container Name ) ; if ( m Bean Server == null ) return ; Object Name transport M Bean Object Name = Transport Constants . create Transport M Bean Object Name ( container Name ) ; if ( m Bean Server . is Registered ( transport M Bean Object Name ) ) { m Bean Server . unregister M Bean ( transport M Bean Object Name ) ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING ) ; } } }
public void add Nodes In Doc Order ( Node Iterator iterator , X Path Context support ) { if ( ! m mutable ) throw new Runtime Exception ( XSL Messages . create XPATH Message ( XPATH Error Resources . ER NODESET NOT MUTABLE , null ) ) ; Node node ; while ( null != ( node = iterator . next Node ( ) ) ) { add Node In Doc Order ( node , support ) ; } }
protected void uninstall Defaults ( ) { Sea Glass Context context = get Context ( split Pane , ENABLED ) ; style . uninstall Defaults ( context ) ; context . dispose ( ) ; style = null ; context = get Context ( split Pane , Region . SPLIT PANE DIVIDER , ENABLED ) ; divider Style . uninstall Defaults ( context ) ; context . dispose ( ) ; divider Style = null ; super . uninstall Defaults ( ) ; }
public void subtract Amount ( final String amount ) { subtract Amount ( Integer . parse Int ( amount ) ) ; }
private synchronized void make Composite Builder ( ) throws Invalid Object Exception { if ( composite Builder != null ) return ; Class < ? > target Class = ( Class < ? > ) get Java Type ( ) ; Composite Builder [ ] [ ] builders = { { new Composite Builder Via From ( target Class , item Names ) } , { new Composite Builder Via Constructor ( target Class , item Names ) } , { new Composite Builder Check Getters ( target Class , item Names , getter Mappings ) , new Composite Builder Via Setters ( target Class , item Names ) , new Composite Builder Via Proxy ( target Class , item Names ) } } ; Composite Builder found Builder = null ; final String Builder why Nots = new String Builder ( ) ; Throwable possible Cause = null ; find : for ( Composite Builder [ ] related Builders : builders ) { for ( int i = NUM ; i < related Builders . length ; i ++ ) { Composite Builder builder = related Builders [ i ] ; String why Not = builder . applicable ( getters ) ; if ( why Not == null ) { found Builder = builder ; break find ; } Throwable cause = builder . possible Cause ( ) ; if ( cause != null ) possible Cause = cause ; if ( why Not . length ( ) > NUM ) { if ( why Nots . length ( ) > NUM ) why Nots . append ( STRING ) ; why Nots . append ( why Not ) ; if ( i == NUM ) break ; } } } if ( found Builder == null ) { String msg = STRING + target Class . get Name ( ) + STRING + why Nots ; if ( possible Cause != null ) msg += STRING ; throw invalid Object Exception ( msg , possible Cause ) ; } composite Builder = found Builder ; }
public void append ( Char Sequence s ) { text . append ( s ) ; }
public void invalidate All ( ) { if ( m tuples == null ) return ; for ( int i = NUM ; i < m tuples . length ; ++ i ) invalidate ( i ) ; }
public void add ( final long addr ) { addrs . add ( addr ) ; }
@ Android Only ( STRING ) public void test wrap Byte Buffer Byte Buffer 04 ( ) { String host = STRING ; int port = NUM ; Byte Buffer bbs = Byte Buffer . allocate ( NUM ) ; Byte Buffer bbd = Byte Buffer . allocate ( NUM ) ; SSL Engine sse = get Engine ( host , port ) ; try { sse . wrap ( bbs , bbd ) ; fail ( STRING ) ; } catch ( Illegal State Exception iobe ) { } catch ( Exception e ) { fail ( e + STRING ) ; } }
public static boolean is Black Listed ( @ Nonnull Size size , @ Nonnull String blacklist String ) { String [ ] blacklist String Array = blacklist String . split ( STRING ) ; if ( blacklist String Array . length == NUM ) { return BOOL ; } Set < String > blacklisted Sizes = new Hash Set ( Lists . new Array List ( blacklist String Array ) ) ; return is Black Listed ( size , blacklisted Sizes ) ; }
static private void write Dec Ref ( Writer out , char ch ) throws IO Exception { if ( ch == STRING ) { out . write ( STRING ) ; return ; } out . write ( STRING ) ; int i = ( int ) ch ; if ( i > NUM ) { out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + i ) ; } else if ( i > NUM ) { out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + i ) ; } else { out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + ( i / NUM ) ) ; i = i % NUM ; out . write ( STRING + i ) ; } out . write ( STRING ) ; }
protected byte [ ] input Stream To Byte Array ( Input Stream is ) throws IO Exception { Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; int next = is . read ( ) ; while ( next > - NUM ) { bos . write ( next ) ; next = is . read ( ) ; } bos . flush ( ) ; is . close ( ) ; return bos . to Byte Array ( ) ; }
@ Override public String to String ( ) { Object value = get ( ) ; return value == null ? STRING : value . to String ( ) ; }
private boolean is A Reference Tag ( String str ) { if ( str == null ) { return BOOL ; } return str . index Of ( STRING ) == NUM && str . last Index Of ( STRING ) == ( str . length ( ) - NUM ) ; }
protected static String encode ( String url ) { String Builder encoder = new String Builder ( ) ; for ( char chr : url . to Char Array ( ) ) { byte chr Byte = ( byte ) chr ; if ( ( chr Byte <= NUM || chr Byte >= NUM || chr == STRING || chr == STRING ) ) { encoder . append ( String . format ( STRING , chr Byte ) ) ; } else { encoder . append ( chr ) ; } } return encoder . to String ( ) ; }
public void test X 509 CRL Entry ( ) { TBTCRL Entry tbt crlentry = new TBTCRL Entry ( ) ; assert Null ( tbt crlentry . get Certificate Issuer ( ) ) ; assert Null ( tbt crlentry . get Critical Extension OI Ds ( ) ) ; try { assert Null ( tbt crlentry . get Encoded ( ) ) ; } catch ( CRL Exception e ) { fail ( STRING + e . get Message ( ) ) ; } assert Null ( tbt crlentry . get Non Critical Extension OI Ds ( ) ) ; assert Null ( tbt crlentry . get Revocation Date ( ) ) ; }
public static long now ( ) { return System . current Time Millis ( ) ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
private Binlog Position find Heartbeat ( Maxwell Replicator r ) throws Exception { r . start Replicator ( ) ; for ( Row Map row = r . get Row ( ) ; row != null ; row = r . get Row ( ) ) { if ( Objects . equals ( r . get Last Heartbeat Read ( ) , recovery Info . heartbeat ) ) return row . get Position ( ) ; } return null ; }
private Configure ( ) { Properties p = new Properties ( ) ; Map args = new Hash Map ( ) ; args . put All ( System . getenv ( ) ) ; args . put All ( System . get Properties ( ) ) ; p . put All ( args ) ; this . property = p ; reload ( BOOL ) ; }
private void handle Truncated Info ( final Statement Info info ) throws SQL Exception { final byte [ ] original Info = statement . get Statement Info Request Items ( ) ; final byte [ ] new Info Items = new byte [ original Info . length + NUM * NUM ] ; int new Index = NUM ; for ( final byte info Item : original Info ) { assert new Index < new Info Items . length : STRING ; switch ( info Item ) { case ISC Constants . isc info sql select : case ISC Constants . isc info sql bind : final Row Descriptor Builder current Builder = info Item == ISC Constants . isc info sql select ? info . field Builder : info . parameter Builder ; final int descriptor Index = current Builder != null ? current Builder . get First Unprocessed Index ( ) + NUM : NUM ; new Info Items [ new Index ++ ] = ISC Constants . isc info sql sqlda start ; new Info Items [ new Index ++ ] = NUM ; new Info Items [ new Index ++ ] = ( byte ) ( descriptor Index & NUM ) ; new Info Items [ new Index ++ ] = ( byte ) ( descriptor Index > > NUM ) ; new Info Items [ new Index ++ ] = info Item ; break ; default : new Info Items [ new Index ++ ] = info Item ; break ; } } assert new Index == new Info Items . length : STRING ; info . request Buffer Size = Math . min ( NUM * info . request Buffer Size , statement . get Max Sql Info Size ( ) ) ; info . buffer = statement . get Sql Info ( new Info Items , info . request Buffer Size ) ; info . current Index = NUM ; }
public static String strip File Extension ( String name ) { int pos = name . last Index Of ( STRING ) ; if ( pos > NUM & pos < name . length ( ) - NUM ) return name . substring ( NUM , pos ) ; return name ; }
private static void push Transaction Start Stamp ( Transaction t ) { Map < Transaction , Timestamp > map = suspended Tx Start Stamps . get ( ) ; Timestamp stamp = transaction Start Stamp . get ( ) ; if ( stamp != null ) { map . put ( t , stamp ) ; } else { Debug . log Error ( STRING , module ) ; } }
private int indexed Binary Search ( List < S2 Cell Id > l , S2 Cell Id key , int low ) { int high = l . size ( ) - NUM ; while ( low <= high ) { int mid = ( low + high ) > > NUM ; S2 Cell Id mid Val = l . get ( mid ) ; int cmp = mid Val . compare To ( key ) ; if ( cmp < NUM ) { low = mid + NUM ; } else if ( cmp > NUM ) { high = mid - NUM ; } else { return mid ; } } return low ; }
public Variable [ ] find Local Arrays ( ) { List < Variable > arrays = new Array List < Variable > ( ) ; for ( List Iterator < Variable > iterator = f Local Variables . list Iterator ( f Local Variables . size ( ) ) ; iterator . has Previous ( ) ; ) { Variable local Variable = iterator . previous ( ) ; if ( local Variable . is Array ( ) ) arrays . add ( local Variable ) ; } return arrays . to Array ( new Variable [ arrays . size ( ) ] ) ; }
public static int index Of Java Like Extension ( String file Name ) { int file Name Length = file Name . length ( ) ; char [ ] [ ] java Like Extensions = get Java Like Extensions ( ) ; extensions : for ( int i = NUM , length = java Like Extensions . length ; i < length ; i ++ ) { char [ ] extension = java Like Extensions [ i ] ; int extension Length = extension . length ; int extension Start = file Name Length - extension Length ; int dot Index = extension Start - NUM ; if ( dot Index < NUM ) continue ; if ( file Name . char At ( dot Index ) != STRING ) continue ; for ( int j = NUM ; j < extension Length ; j ++ ) { if ( file Name . char At ( extension Start + j ) != extension [ j ] ) continue extensions ; } return dot Index ; } return - NUM ; }
public Shape Tile Simplex remove border line ( int p no ) { if ( p no < NUM || p no >= lines size ( ) ) { return this ; } Array List < Pla Line Int > new arr = new Array List < Pla Line Int > ( lines size ( ) ) ; new arr . add All ( lines list ) ; new arr . remove ( p no ) ; return new Shape Tile Simplex ( new arr ) ; }
protected boolean wait Before Execution ( ) throws Interrupted Exception { return BOOL ; }
static boolean is Valid Streaming Url ( String url ) { return url != null && url . matches ( STRING ) ; }
public Web Service Proxy ( URL server URL , Executor Service executor Service ) { this ( server URL , executor Service , NUM , NUM ) ; }
private static byte [ ] expose Byte Array Input Stream Bytes ( Byte Array Input Stream bais ) { byte [ ] buffer ; synchronized ( bais ) { byte [ ] buf ; int pos ; try { buf = ( byte [ ] ) BAIS BUF . get ( bais ) ; pos = BAIS POS . get Int ( bais ) ; } catch ( Illegal Access Exception iae ) { throw new Assertion Error ( iae ) ; } int available = bais . available ( ) ; if ( pos == NUM && buf . length == available ) { buffer = buf ; } else { buffer = new byte [ available ] ; System . arraycopy ( buf , pos , buffer , NUM , available ) ; } bais . skip ( available ) ; } return buffer ; }
private void restore Data ( ) { Map < String , ? > map = preference Utils . get All ( ) ; Set < String > strings = map . key Set ( ) ; for ( String string : strings ) { if ( string . starts With ( Shared Preference Utils . key Test Mode ) ) { preference Utils . restore Key ( string ) ; } } refresh Key Values ( ) ; }
public String put Image ( String the Folder , String the Image Name , Bitmap the Bitmap ) { if ( the Folder == null || the Image Name == null || the Bitmap == null ) return null ; this . DEFAULT APP IMAGEDATA DIRECTORY = the Folder ; String m Full Path = setup Full Path ( the Image Name ) ; if ( ! m Full Path . equals ( STRING ) ) { last Image Path = m Full Path ; save Bitmap ( m Full Path , the Bitmap ) ; } return m Full Path ; }
public Class < ? > type ( ) { if ( is Class ) { return ( Class < ? > ) object ; } else { return object . get Class ( ) ; } }
void add To External CSS ( CSS Element css Element ) { if ( external CSS == null ) { external CSS = new Vector ( ) ; } external CSS . add Element ( css Element ) ; }
@ Override public String to String ( ) { return buf . to String ( ) ; }
private void remove ( String world , Permission Holder holder , String permission ) { try { if ( world != null && ! world . equals ( STRING ) ) { holder . unset Permission ( permission , server , world ) ; } else { holder . unset Permission ( permission , server ) ; } } catch ( Object Lacks Exception ignored ) { } save ( holder ) ; }
private void action tree Add All ( ) { log . info ( STRING ) ; List Model model = center List . get Model ( ) ; int size = model . get Size ( ) ; int index = - NUM ; for ( index = NUM ; index < size ; index ++ ) { List Item item = ( List Item ) model . get Element At ( index ) ; action tree Add ( item ) ; } }
private Concurrent Skip List Map . Node < K , V > hi Node ( ) { if ( hi == null ) return m . find Last ( ) ; else if ( hi Inclusive ) return m . find Near ( hi , LT | EQ ) ; else return m . find Near ( hi , LT ) ; }
public static final Image Point convert Point ( Map Point map Point , Map Envelope map Env , int img Height , int img Width ) { long image Y = Math . round ( convert Y ( map Point , map Env , img Height ) ) ; long image X = Math . round ( convert X ( map Point , map Env , img Width ) ) ; return new Image Point ( image X , image Y ) ; }
private void check Using Adaptation ( ) { if ( ts Use Adaptation . is Selected ( ) ) { tf Adaptation Time . set Enabled ( BOOL ) ; tf Adaptation Param . set Enabled ( BOOL ) ; } else { tf Adaptation Time . set Enabled ( BOOL ) ; tf Adaptation Param . set Enabled ( BOOL ) ; } }
public String combine Mix ( List < String > files , String out File ) { Array List < String > cmd = new Array List < String > ( ) ; cmd . add ( sox Bin ) ; cmd . add ( STRING ) ; for ( String file : files ) { cmd . add ( STRING ) ; cmd . add ( STRING ) ; cmd . add ( file ) ; } cmd . add ( out File ) ; try { int rc = exec Sox ( cmd , callback ) ; if ( rc != NUM ) { out File = null ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } return out File ; }
public Quarter ( int quarter , Year year ) { if ( ( quarter < FIRST QUARTER ) || ( quarter > LAST QUARTER ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . year = ( short ) year . get Year ( ) ; this . quarter = ( byte ) quarter ; peg ( Calendar . get Instance ( ) ) ; }
public void send Request Vote Request ( boolean is Prevote ) throws Gondola Exception { if ( ! enabled || master Id >= NUM ) { return ; } if ( ! is Prevote ) { current Term ++ ; voted For = - NUM ; save ( current Term , member Id ) ; voted For = member Id ; } prevotes Only = is Prevote ; Message message = pool . checkout ( ) ; try { save Queue . get Latest ( saved Rid ) ; message . request Vote Request ( member Id , current Term , is Prevote , saved Rid ) ; peers . for Each ( null ) ; } finally { message . release ( ) ; } prevote Ts = clock . now ( ) + ( long ) ( ( Math . random ( ) * prevote Period ) ) ; if ( ! is Prevote ) { prevote Ts += election Timeout ; } }
private List < String > filter Targets From Response ( Set < String > varray Tagged Port WW Ns , Map < String , List < String > > initiator Target Map , String initiator Key ) { log . debug ( STRING ) ; List < String > filtered Target List = new Array List < String > ( ) ; List < String > target Port List From Response = initiator Target Map . get ( initiator Key ) ; for ( String port WWN : target Port List From Response ) { if ( varray Tagged Port WW Ns . contains ( port WWN ) || varray Tagged Port WW Ns . contains ( port WWN . to Upper Case ( ) ) ) { filtered Target List . add ( port WWN . to Upper Case ( ) ) ; } } log . debug ( STRING ) ; return filtered Target List ; }
public Piloting Roll Data check Maneuver ( Move Step step , Entity Movement Type overall Move Type ) { Piloting Roll Data roll = get Base Piloting Roll ( overall Move Type ) ; if ( ( step == null ) || ( step . get Type ( ) != Move Step Type . MANEUVER ) ) { roll . add Modifier ( Target Roll . CHECK FALSE , STRING ) ; return roll ; } boolean side Slip Mod = ( this instanceof Conv Fighter ) && is VSTOL ( ) ; roll . append ( new Piloting Roll Data ( get Id ( ) , Maneuver Type . get Mod ( step . get Maneuver Type ( ) , side Slip Mod ) , Maneuver Type . get Type Name ( step . get Maneuver Type ( ) ) + STRING ) ) ; return roll ; }
public static List < String > parse Program Args ( I Launch Configuration launch Config ) throws Core Exception { return parse Args ( launch Config . get Attribute ( I Java Launch Configuration Constants . ATTR PROGRAM ARGUMENTS , STRING ) ) ; }
public abstract T decode Value ( String value ) ;
private void fit Image To View ( ) { Drawable drawable = get Drawable ( ) ; if ( drawable == null || drawable . get Intrinsic Width ( ) == NUM || drawable . get Intrinsic Height ( ) == NUM ) { return ; } if ( matrix == null || prev Matrix == null ) { return ; } int drawable Width = drawable . get Intrinsic Width ( ) ; int drawable Height = drawable . get Intrinsic Height ( ) ; float scale X = ( float ) view Width / drawable Width ; float scale Y = ( float ) view Height / drawable Height ; switch ( m Scale Type ) { case CENTER : scale X = scale Y = NUM ; break ; case CENTER CROP : scale X = scale Y = Math . max ( scale X , scale Y ) ; break ; case CENTER INSIDE : scale X = scale Y = Math . min ( NUM , Math . min ( scale X , scale Y ) ) ; case FIT CENTER : scale X = scale Y = Math . min ( scale X , scale Y ) ; break ; case FIT XY : break ; default : throw new Unsupported Operation Exception ( STRING ) ; } float redundant X Space = view Width - ( scale X * drawable Width ) ; float redundant Y Space = view Height - ( scale Y * drawable Height ) ; match View Width = view Width - redundant X Space ; match View Height = view Height - redundant Y Space ; if ( ! is Zoomed ( ) && ! image Rendered At Least Once ) { matrix . set Scale ( scale X , scale Y ) ; matrix . post Translate ( redundant X Space / NUM , redundant Y Space / NUM ) ; normalized Scale = NUM ; } else { if ( prev Match View Width == NUM || prev Match View Height == NUM ) { save Previous Image Values ( ) ; } prev Matrix . get Values ( m ) ; m [ Matrix . MSCALE X ] = match View Width / drawable Width * normalized Scale ; m [ Matrix . MSCALE Y ] = match View Height / drawable Height * normalized Scale ; float trans X = m [ Matrix . MTRANS X ] ; float trans Y = m [ Matrix . MTRANS Y ] ; float prev Actual Width = prev Match View Width * normalized Scale ; float actual Width = get Image Width ( ) ; translate Matrix After Rotate ( Matrix . MTRANS X , trans X , prev Actual Width , actual Width , prev View Width , view Width , drawable Width ) ; float prev Actual Height = prev Match View Height * normalized Scale ; float actual Height = get Image Height ( ) ; translate Matrix After Rotate ( Matrix . MTRANS Y , trans Y , prev Actual Height , actual Height , prev View Height , view Height , drawable Height ) ; matrix . set Values ( m ) ; } fix Trans ( ) ; set Image Matrix ( matrix ) ; }
@ Override public synchronized MX Bean Mapping mapping For Type ( Type obj Type , MX Bean Mapping Factory factory ) throws Open Data Exception { if ( in Progress . contains Key ( obj Type ) ) { throw new Open Data Exception ( STRING + type Name ( obj Type ) ) ; } MX Bean Mapping mapping ; mapping = get Mapping ( obj Type ) ; if ( mapping != null ) return mapping ; in Progress . put ( obj Type , obj Type ) ; try { mapping = make Mapping ( obj Type , factory ) ; } catch ( Open Data Exception e ) { throw open Data Exception ( STRING + type Name ( obj Type ) , e ) ; } finally { in Progress . remove ( obj Type ) ; } put Mapping ( obj Type , mapping ) ; return mapping ; }
public void test Case 18 ( ) { byte a Bytes [ ] = { NUM } ; byte b Bytes [ ] = { NUM } ; byte r Bytes [ ] = { NUM } ; int a Sign = NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public static Element create Element In Signature 11 Space ( Document doc , String element Name ) { if ( doc == null ) { throw new Runtime Exception ( STRING ) ; } if ( ( ds 11 Prefix == null ) || ( ds 11 Prefix . length ( ) == NUM ) ) { return doc . create Element NS ( Constants . Signature Spec 11 NS , element Name ) ; } return doc . create Element NS ( Constants . Signature Spec 11 NS , ds 11 Prefix + STRING + element Name ) ; }
public void remove Element At ( final int index ) { entries . remove ( index ) ; }
public static void c2 ir ( double c [ ] , int nc , double hh [ ] , int leng ) { hh [ NUM ] = Math . exp ( c [ NUM ] ) ; for ( int n = NUM ; n < leng ; n ++ ) { double d = NUM ; int upl = ( n >= nc ) ? nc - NUM : n ; for ( int k = NUM ; k <= upl ; k ++ ) d += k * c [ k ] * hh [ n - k ] ; hh [ n ] = d / n ; } }
public void close ( ) { nc Guards = null ; }
public void process Indication ( Hashtable < String , String > cim Notification ) { String cim Indication Type = get Cim Indication Type ( cim Notification ) ; if ( monitoring Properties Loader . is To Log Indications ( ) ) { logger . debug ( STRING + get Indication Data ( cim Notification ) ) ; } if ( cim Indication Type != null && cim Indication Type . equals ( Cim Constants . CIM ALERT INDICATION TYPE ) ) { if ( monitoring Properties Loader . is To Log Indications ( ) ) { logger . debug ( STRING ) ; } alert Processor . process Indication ( cim Notification ) ; } else if ( cim Indication Type != null && cim Indication Type . equals ( Cim Constants . CIM INST INDICATION TYPE ) ) { if ( monitoring Properties Loader . is To Log Indications ( ) ) { logger . debug ( STRING ) ; } event Processor . process Indication ( cim Notification ) ; } else { if ( monitoring Properties Loader . is To Log Indications ( ) ) { logger . debug ( STRING , cim Indication Type ) ; } } }
public Replication Job create Job For Copy Table ( long audit Log Id , long audit Log Entry Create Time , Table table ) throws State Update Exception { Replication Operation replication Operation = Hive Utils . is Partitioned ( table ) ? Replication Operation . COPY PARTITIONED TABLE : Replication Operation . COPY UNPARTITIONED TABLE ; Map < String , String > extras = new Hash Map < > ( ) ; extras . put ( Persisted Job Info . AUDIT LOG ID EXTRAS KEY , Long . to String ( audit Log Id ) ) ; extras . put ( Persisted Job Info . AUDIT LOG ENTRY CREATE TIME KEY , Long . to String ( audit Log Entry Create Time ) ) ; Persisted Job Info persisted Job Info = job Info Store . resilient Create ( replication Operation , Replication Status . PENDING , Replication Utils . get Location ( table ) , src Cluster . get Name ( ) , new Hive Object Spec ( table ) , Collections . empty List ( ) , Replication Utils . get Tldt ( table ) , Optional . empty ( ) , Optional . empty ( ) , extras ) ; Hive Object Spec spec = new Hive Object Spec ( table ) ; Optional < Path > table Location = Replication Utils . get Location ( table ) ; switch ( replication Operation ) { case COPY UNPARTITIONED TABLE : return new Replication Job ( conf , new Copy Unpartitioned Table Task ( conf , destination Object Factory , object Conflict Handler , src Cluster , dest Cluster , spec , table Location , directory Copier , BOOL ) , on State Change Handler , persisted Job Info ) ; case COPY PARTITIONED TABLE : return new Replication Job ( conf , new Copy Partitioned Table Task ( conf , destination Object Factory , object Conflict Handler , src Cluster , dest Cluster , spec , table Location ) , on State Change Handler , persisted Job Info ) ; default : throw new Runtime Exception ( STRING + replication Operation ) ; } }
public static String read Fully ( Reader reader ) throws IO Exception { try { String Writer writer = new String Writer ( ) ; char [ ] buffer = new char [ NUM ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM ) { writer . write ( buffer , NUM , count ) ; } return writer . to String ( ) ; } finally { reader . close ( ) ; } }
synchronized public void release XML Reader ( XML Reader reader ) { if ( m reader Manager != null ) { m reader Manager . release XML Reader ( reader ) ; } }
public int un Finish Size ( ) { return m Un Finish Queue . size ( ) ; }
public void add Sample ( int weight , float value ) { ensure Sorted By Index ( ) ; Sample new Sample = recycled Sample Count > NUM ? recycled Samples [ -- recycled Sample Count ] : new Sample ( ) ; new Sample . index = next Sample Index ++ ; new Sample . weight = weight ; new Sample . value = value ; samples . add ( new Sample ) ; total Weight += weight ; while ( total Weight > max Weight ) { int excess Weight = total Weight - max Weight ; Sample oldest Sample = samples . get ( NUM ) ; if ( oldest Sample . weight <= excess Weight ) { total Weight -= oldest Sample . weight ; samples . remove ( NUM ) ; if ( recycled Sample Count < MAX RECYCLED SAMPLES ) { recycled Samples [ recycled Sample Count ++ ] = oldest Sample ; } } else { oldest Sample . weight -= excess Weight ; total Weight -= excess Weight ; } } }
private void specialised Predicates ( ) { Double Predicate double Predicate = null ; Long Predicate long Predicate = null ; }
private static final synchronized int next Pool Id ( ) { return ++ pool Number Sequence ; }
public static boolean sec Key Verify ( byte [ ] seckey ) { Preconditions . check Argument ( seckey . length == NUM ) ; Byte Buffer byte Buff = native ECDSA Buffer . get ( ) ; if ( byte Buff == null || byte Buff . capacity ( ) < seckey . length ) { byte Buff = Byte Buffer . allocate Direct ( seckey . length ) ; byte Buff . order ( Byte Order . native Order ( ) ) ; native ECDSA Buffer . set ( byte Buff ) ; } byte Buff . rewind ( ) ; byte Buff . put ( seckey ) ; r . lock ( ) ; try { return secp 256 k 1 ec seckey verify ( byte Buff , Secp 256 k 1 Context . get Context ( ) ) == NUM ; } finally { r . unlock ( ) ; } }
public Tree Node Iterator ( Node root , boolean preorder ) { m preorder = preorder ; m root = root ; m stack = new Array List ( ) ; m stack . add ( root ) ; if ( ! preorder ) { for ( Node n = root . get Child ( NUM ) ; n != null ; n = n . get Child ( NUM ) ) m stack . add ( n ) ; } }
public static Writable Native Array make Native Array ( List objects ) { Writable Native Array native Array = new Writable Native Array ( ) ; if ( objects == null ) { return native Array ; } for ( Object elem : objects ) { elem = make Native Object ( elem ) ; if ( elem == null ) { native Array . push Null ( ) ; } else if ( elem instanceof Boolean ) { native Array . push Boolean ( ( Boolean ) elem ) ; } else if ( elem instanceof Integer ) { native Array . push Int ( ( Integer ) elem ) ; } else if ( elem instanceof Double ) { native Array . push Double ( ( Double ) elem ) ; } else if ( elem instanceof String ) { native Array . push String ( ( String ) elem ) ; } else if ( elem instanceof Writable Native Array ) { native Array . push Array ( ( Writable Native Array ) elem ) ; } else if ( elem instanceof Writable Native Map ) { native Array . push Map ( ( Writable Native Map ) elem ) ; } else { throw new Illegal Argument Exception ( STRING + elem . get Class ( ) ) ; } } return native Array ; }
public static Big Integer size Of Directory As Big Integer ( File directory ) { check Directory ( directory ) ; final File [ ] files = directory . list Files ( ) ; if ( files == null ) { return Big Integer . ZERO ; } Big Integer size = Big Integer . ZERO ; for ( final File file : files ) { try { if ( ! is Symlink ( file ) ) { size = size . add ( Big Integer . value Of ( size Of ( file ) ) ) ; } } catch ( IO Exception ioe ) { } } return size ; }
@ Override public void node Changed ( ) { log . info ( STRING ) ; wakeup ( ) ; }
private static Node Pair split Block ( final View view , final Function function , final Code Node node , final Instruction instruction ) { boolean before = BOOL ; final List < Instruction > before Instructions = new Array List < Instruction > ( ) ; final List < Instruction > after Instructions = new Array List < Instruction > ( ) ; for ( final Instruction node Instruction : node . get Instructions ( ) ) { if ( before ) { before Instructions . add ( node Instruction ) ; } else { after Instructions . add ( node Instruction ) ; } if ( node Instruction == instruction ) { before = BOOL ; } } if ( after Instructions . is Empty ( ) ) { return new Node Pair ( node , null ) ; } else { final Code Node first Node = view . create Code Node ( function , before Instructions ) ; final Code Node second Node = view . create Code Node ( function , after Instructions ) ; first Node . set Color ( node . get Color ( ) ) ; second Node . set Color ( DEFAULT BLOCK COLOR ) ; for ( final View Edge edge : node . get Incoming Edges ( ) ) { final View Edge new Edge = view . create Edge ( edge . get Source ( ) , first Node , edge . get Type ( ) ) ; new Edge . set Color ( edge . get Color ( ) ) ; } for ( final View Edge edge : node . get Outgoing Edges ( ) ) { final View Edge new Edge = view . create Edge ( second Node , edge . get Target ( ) , edge . get Type ( ) ) ; new Edge . set Color ( edge . get Color ( ) ) ; } view . delete Node ( node ) ; return new Node Pair ( first Node , second Node ) ; } }
public Pair < String , String > object To String ( final long shop Id , final String currency , final Big Decimal regular Price ) { return new Pair < String , String > ( STRING + shop Id + STRING + currency , money Bridge . object To String ( regular Price ) ) ; }
public String read Line ( ) throws IO Exception { String Builder line = new String Builder ( ) ; int i ; char c ; i = read ( ) ; if ( i == - NUM ) return null ; while ( i > - NUM && i != STRING && i != STRING ) { c = ( char ) ( i & NUM ) ; line = line . append ( c ) ; i = read ( ) ; } if ( i == STRING ) { if ( ( i = read ( ) ) != STRING ) throw new IO Exception ( STRING + Integer . to Hex String ( i ) + STRING + line ) ; } return line . to String ( ) ; }
static public void force Creation Of New Index ( ) { force Creation Of New Index ( BOOL ) ; }
public Frame Block zero Out Operations ( Frame Block result , Index Range range , boolean complementary , int i Row Start Src , int i Row Start Dest , int brlen , int i Max Rows To Copy ) throws DML Runtime Exception { int clen = get Num Columns ( ) ; if ( result == null ) result = new Frame Block ( get Schema ( ) ) ; else { result . reset ( NUM , BOOL ) ; result . set Schema ( get Schema ( ) ) ; } result . ensure Allocated Columns ( brlen ) ; if ( complementary ) { for ( int r = ( int ) range . row Start ; r <= range . row End && r + i Row Start Dest < brlen ; r ++ ) { for ( int c = ( int ) range . col Start ; c <= range . col End ; c ++ ) result . set ( r + i Row Start Dest , c , get ( r + i Row Start Src , c ) ) ; } } else { int r = i Row Start Dest ; for ( ; r < ( int ) range . row Start && r - i Row Start Dest < i Max Rows To Copy ; r ++ ) for ( int c = NUM ; c < clen ; c ++ ) result . set ( r , c , get ( r + i Row Start Src - i Row Start Dest , c ) ) ; for ( ; r <= ( int ) range . row End && r - i Row Start Dest < i Max Rows To Copy ; r ++ ) { for ( int c = NUM ; c < ( int ) range . col Start ; c ++ ) result . set ( r , c , get ( r + i Row Start Src - i Row Start Dest , c ) ) ; for ( int c = ( int ) range . col End + NUM ; c < clen ; c ++ ) result . set ( r , c , get ( r + i Row Start Src - i Row Start Dest , c ) ) ; } for ( ; r - i Row Start Dest < i Max Rows To Copy ; r ++ ) for ( int c = NUM ; c < clen ; c ++ ) result . set ( r , c , get ( r + i Row Start Src - i Row Start Dest , c ) ) ; } return result ; }
public Signal Barrier ( ) { owner = null ; }
public void test To Big Integer Pos 1 ( ) { String a = STRING ; Big Integer b Number = new Big Integer ( STRING ) ; Big Decimal a Number = new Big Decimal ( a ) ; Big Integer result = a Number . to Big Integer ( ) ; assert True ( STRING , result . equals ( b Number ) ) ; }
private static float [ ] normalize ( float [ ] coefficients ) { float accumulator = NUM ; for ( int x = NUM ; x < coefficients . length ; x ++ ) { accumulator += Math . abs ( coefficients [ x ] ) ; } for ( int x = NUM ; x < coefficients . length ; x ++ ) { coefficients [ x ] = coefficients [ x ] / accumulator ; } return coefficients ; }
protected void print Track ( Track track ) { Default Entity View Info v Info = ( Default Entity View Info ) track . get View Info ( ) ; tmp Node Buffer . clear ( ) ; tmp Node Buffer . add All ( track . get Nodes ( ) ) ; if ( ! tmp Node Buffer . is Empty ( ) ) { print Line ( image Bdr , tmp Node Buffer , v Info , BOOL , BOOL , null ) ; print Point ( image Bdr , tmp Node Buffer . get ( tmp Node Buffer . size ( ) - NUM ) , v Info , null ) ; } }
private Period Formatter Builder append Suffix ( Period Field Affix suffix ) { final Object original Printer ; final Object original Parser ; if ( i Element Pairs . size ( ) > NUM ) { original Printer = i Element Pairs . get ( i Element Pairs . size ( ) - NUM ) ; original Parser = i Element Pairs . get ( i Element Pairs . size ( ) - NUM ) ; } else { original Printer = null ; original Parser = null ; } if ( original Printer == null || original Parser == null || original Printer != original Parser || ! ( original Printer instanceof Field Formatter ) ) { throw new Illegal State Exception ( STRING ) ; } clear Prefix ( ) ; Field Formatter new Field = new Field Formatter ( ( Field Formatter ) original Printer , suffix ) ; i Element Pairs . set ( i Element Pairs . size ( ) - NUM , new Field ) ; i Element Pairs . set ( i Element Pairs . size ( ) - NUM , new Field ) ; i Field Formatters [ new Field . get Field Type ( ) ] = new Field ; return this ; }
public Collection < Cube > all ( ) { return Collections . unmodifiable Collection ( cubes ) ; }
public static short read U Byte ( Byte Buffer buffer ) { byte b = buffer . get ( ) ; return ( short ) ( b & NUM ) ; }
public static double most Toxic Row ( Gate g ) { return Collections . min ( g . get toxicity ( ) ) ; }
public Multi Server ( ) { this ( Network Config . DEFAULT TCP PORT , Network Config . DEFAULT UDP PORT ) ; }
protected String url String ( ) throws Parse Exception { String Buffer retval = new String Buffer ( ) ; lexer . select Lexer ( STRING ) ; while ( lexer . has More Chars ( ) ) { char la = lexer . look Ahead ( NUM ) ; if ( la == STRING || la == STRING || la == STRING || la == STRING || la == STRING ) break ; lexer . consume ( NUM ) ; retval . append ( la ) ; } return retval . to String ( ) ; }
public Xml Element ( byte [ ] encoded Document ) { if ( encoded Document == null ) throw new Illegal Argument Exception ( STRING ) ; this . encoded = encoded Document . clone ( ) ; }
public void add ( int position , int height ) { int curr Height = m Map . get ( position , - NUM ) ; if ( curr Height != height ) { if ( curr Height == - NUM ) { if ( m Map . size ( ) == m Max Size ) { m Map . delete ( m Order . remove ( NUM ) ) ; } } else { m Order . remove ( ( Integer ) position ) ; } m Map . put ( position , height ) ; m Order . add ( position ) ; } }
public void testmod Inverse Pos 2 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , - NUM , NUM , - NUM } ; byte m Bytes [ ] = { NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int m Sign = NUM ; byte r Bytes [ ] = { NUM , - NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer modulus = new Big Integer ( m Sign , m Bytes ) ; Big Integer result = a Number . mod Inverse ( modulus ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
@ GET @ Path ( STRING ) @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Check Permission ( roles = { Role . SECURITY ADMIN } ) public OS Tenant List Rest Rep list Coprhd Os Tenants ( ) { log . debug ( STRING ) ; List < OS Tenant > tenants = get Os Tenants From Coprhd Db ( ) ; return map ( tenants ) ; }
public int read ( final byte [ ] data ) { init ( ) ; if ( data != null ) { raw Data = Byte Buffer . wrap ( data ) ; raw Data . rewind ( ) ; raw Data . order ( Byte Order . LITTLE ENDIAN ) ; read Header ( ) ; if ( ! err ( ) ) { read Contents ( ) ; if ( frame Count < NUM ) { status = STATUS FORMAT ERROR ; } } } else { status = STATUS OPEN ERROR ; } return status ; }
private void calculate Unique Value ( Object [ ] min Value , Object [ ] unique Value ) { for ( int i = NUM ; i < measure Count ; i ++ ) { if ( type [ i ] == Carbon Common Constants . BIG INT MEASURE ) { unique Value [ i ] = ( long ) min Value [ i ] - NUM ; } else if ( type [ i ] == Carbon Common Constants . BIG DECIMAL MEASURE ) { Big Decimal val = ( Big Decimal ) min Value [ i ] ; unique Value [ i ] = ( val . subtract ( new Big Decimal ( NUM ) ) ) ; } else { unique Value [ i ] = ( double ) min Value [ i ] - NUM ; } } }
@ Request Mapping ( value = STRING ) public void sso Binding Error ( Locale locale , @ Path Variable ( value = STRING ) String tenant , Http Servlet Response response ) throws IO Exception { logger . info ( STRING + locale . to String ( ) + STRING + tenant ) ; sso Default Tenant Binding Error ( locale , response ) ; }
public long env end ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return STRINGS ; case NUM : return HELLO ; default : return null ; } }
public X509 Trust Chain Key Selector ( X509 Certificate ... trusted Roots ) { log = Logger Factory . get Logger ( X509 Trust Chain Key Selector . class ) ; check Ctor Args Not Null ( trusted Roots ) ; trust Anchors = new Hash Set < Trust Anchor > ( ) ; for ( X509 Certificate cert : trusted Roots ) { trust Anchors . add ( new Trust Anchor ( cert , null ) ) ; } }
@ Override public void remove Attribute NS ( String namespace URI , String local Name ) { if ( owner Document . error Checking && is Read Only ( ) ) { String msg = DOM Message Formatter . format Message ( DOM Message Formatter . DOM DOMAIN , STRING , null ) ; throw new DOM Exception ( DOM Exception . NO MODIFICATION ALLOWED ERR , msg ) ; } if ( needs Sync Data ( ) ) { synchronize Data ( ) ; } if ( attributes == null ) { return ; } attributes . safe Remove Named Item NS ( namespace URI , local Name ) ; }
public boolean draw Image ( Image img , Affine Transform xform , Image Observer obs ) { if ( img == null ) { return BOOL ; } boolean result ; int src Width = img . get Width ( null ) ; int src Height = img . get Height ( null ) ; if ( src Width < NUM || src Height < NUM ) { result = BOOL ; } else { result = draw Image To Platform ( img , xform , null , NUM , NUM , src Width , src Height , BOOL ) ; } return result ; }
public void handle Button 1 Request ( Request Invocation Event event ) throws Model Control Exception { Server Site Model model = ( Server Site Model ) get Model ( ) ; AM Property Sheet ps = ( AM Property Sheet ) get Child ( PROPERTY ATTRIBUTE ) ; String server Name = ( String ) get Page Session Attribute ( PG ATTR SERVER NAME ) ; String name = ( String ) get Display Field Value ( TF NAME ) ; name = name . trim ( ) ; if ( name . length ( ) > NUM ) { try { model . clone Server ( server Name , name ) ; back Trail ( ) ; Server Site View Bean vb = ( Server Site View Bean ) get View Bean ( Server Site View Bean . class ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; forward To ( ) ; } } else { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , STRING ) ; forward To ( ) ; } }
public static < TK , FV > Feature Value Collection < FV > combine ( Derivation < TK , FV > hyp ) { Counter < FV > counter = new Classic Counter < FV > ( ) ; for ( ; hyp != null ; hyp = hyp . parent ) { if ( hyp . features != null ) { for ( Feature Value < FV > feature : hyp . features ) { counter . increment Count ( feature . name , feature . value ) ; } } } Set < FV > feature Names = new Tree Set < FV > ( counter . key Set ( ) ) ; Feature Value Collection < FV > combined List = new Feature Value List < FV > ( feature Names . size ( ) ) ; for ( FV feature : feature Names ) { combined List . add ( new Feature Value < FV > ( feature , counter . get Count ( feature ) ) ) ; } return combined List ; }
public void send Titles ( ) { if ( listeners == null ) { return ; } String Builder labels = new String Builder ( STRING ) ; labels . append ( STRING + Bundle . get Message ( STRING ) + STRING ) ; labels . append ( STRING + manager . get Closed Text ( ) + STRING ) ; labels . append ( STRING + manager . get Thrown Text ( ) + STRING ) ; String message = labels . to String ( ) ; for ( Controller Interface listener : listeners ) { listener . send Packet To Device ( message ) ; } }
public Filename Utils ( ) { super ( ) ; }
public static void close Session ( ) throws Hibernate Exception { Session session = ( Session ) thread Local . get ( ) ; thread Local . set ( null ) ; if ( session != null ) { session . close ( ) ; } }
protected Calendar ( ) { zone = Time Zone . get Default ( ) ; fields = new int [ FIELD COUNT ] ; is Set = new boolean [ FIELD COUNT ] ; are Fields Set = is Time Set = BOOL ; set Time In Millis ( System . current Time Millis ( ) ) ; }
private Point Pair calculate Edge ( Component comp 1 , Component comp 2 ) { Rectangle r1 = comp 1 . get Bounds ( ) ; Rectangle r2 = comp 2 . get Bounds ( ) ; Point c1 = new Point ( ( int ) ( r1 . x + r1 . width / NUM ) , ( int ) ( r1 . y + r1 . height / NUM ) ) ; Point c2 = new Point ( ( int ) ( r2 . x + r2 . width / NUM ) , ( int ) ( r2 . y + r2 . height / NUM ) ) ; double angle = Math . atan 2 ( c1 . y - c2 . y , c1 . x - c2 . x ) ; angle += Math . PI / NUM ; Point d = new Point ( ( int ) ( offset * Math . cos ( angle ) ) , ( int ) ( offset * Math . sin ( angle ) ) ) ; c1 . translate ( d . x , d . y ) ; c2 . translate ( d . x , d . y ) ; Point p1 = get Boundary Intersection ( comp 1 , c1 , c2 ) ; Point p2 = get Boundary Intersection ( comp 2 , c2 , c1 ) ; if ( ( p1 == null ) || ( p2 == null ) ) { c1 = new Point ( ( int ) ( r1 . x + r1 . width / NUM ) , ( int ) ( r1 . y + r1 . height / NUM ) ) ; c2 = new Point ( ( int ) ( r2 . x + r2 . width / NUM ) , ( int ) ( r2 . y + r2 . height / NUM ) ) ; p1 = get Boundary Intersection ( comp 1 , c1 , c2 ) ; p2 = get Boundary Intersection ( comp 2 , c2 , c1 ) ; } if ( ( p1 == null ) || ( p2 == null ) ) { return null ; } return new Point Pair ( p1 , p2 ) ; }
public static boolean is XML 11 Space ( int c ) { return ( c < NUM && ( XML 11 CHARS [ c ] & MASK XML 11 SPACE ) != NUM ) ; }
public void unregister Player Listener ( Cheerleader Player Listener listener ) { check State ( ) ; m Cheerleader Player Listeners . remove ( listener ) ; }
public Output Stream open Output Stream ( Uri uri , boolean append ) throws IO Exception { assert Background Thread ( ) ; switch ( get Uri Type ( uri ) ) { case URI TYPE FILE : { File local File = new File ( uri . get Path ( ) ) ; File parent = local File . get Parent File ( ) ; if ( parent != null ) { parent . mkdirs ( ) ; } return new File Output Stream ( local File , append ) ; } case URI TYPE CONTENT : case URI TYPE RESOURCE : { Asset File Descriptor asset Fd = content Resolver . open Asset File Descriptor ( uri , append ? STRING : STRING ) ; return asset Fd . create Output Stream ( ) ; } } throw new File Not Found Exception ( STRING + uri ) ; }
protected Integer adjust Integer Value ( Integer orig Value , Integer min Value , Integer max Value ) { Integer result Value = orig Value ; if ( result Value . compare To ( min Value ) < NUM ) { result Value = min Value ; } if ( result Value . compare To ( max Value ) > NUM ) { result Value = max Value ; } return result Value ; }
private void init Paints ( Resources res ) { final String month Typeface = res . get String ( R . string . date picker month typeface ) ; final String day Of Week Typeface = res . get String ( R . string . date picker day of week typeface ) ; final String day Typeface = res . get String ( R . string . date picker day typeface ) ; final int month Text Size = res . get Dimension Pixel Size ( R . dimen . date picker month text size ) ; final int day Of Week Text Size = res . get Dimension Pixel Size ( R . dimen . date picker day of week text size ) ; final int day Text Size = res . get Dimension Pixel Size ( R . dimen . date picker day text size ) ; m Month Paint . set Anti Alias ( BOOL ) ; m Month Paint . set Text Size ( month Text Size ) ; m Month Paint . set Typeface ( Typeface . create ( month Typeface , NUM ) ) ; m Month Paint . set Text Align ( Align . CENTER ) ; m Month Paint . set Style ( Style . FILL ) ; m Day Of Week Paint . set Anti Alias ( BOOL ) ; m Day Of Week Paint . set Text Size ( day Of Week Text Size ) ; m Day Of Week Paint . set Typeface ( Typeface . create ( day Of Week Typeface , NUM ) ) ; m Day Of Week Paint . set Text Align ( Align . CENTER ) ; m Day Of Week Paint . set Style ( Style . FILL ) ; m Day Selector Paint . set Anti Alias ( BOOL ) ; m Day Selector Paint . set Style ( Style . FILL ) ; m Day Highlight Paint . set Anti Alias ( BOOL ) ; m Day Highlight Paint . set Style ( Style . FILL ) ; m Day Paint . set Anti Alias ( BOOL ) ; m Day Paint . set Text Size ( day Text Size ) ; m Day Paint . set Typeface ( Typeface . create ( day Typeface , NUM ) ) ; m Day Paint . set Text Align ( Align . CENTER ) ; m Day Paint . set Style ( Style . FILL ) ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String child Data ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; child . delete Data ( NUM , NUM ) ; child Data = child . get Data ( ) ; assert Equals ( STRING , STRING , child Data ) ; }
public int size ( ) { return rules . size ( ) ; }
private void copy Arrays ( ) { String [ ] old Syms = symbols ; int size = old Syms . length ; symbols = new String [ size ] ; System . arraycopy ( old Syms , NUM , symbols , NUM , size ) ; Bucket [ ] old Buckets = buckets ; size = old Buckets . length ; buckets = new Bucket [ size ] ; System . arraycopy ( old Buckets , NUM , buckets , NUM , size ) ; }
static Label Node [ ] clone ( final List < Label Node > labels , final Map < Label Node , Label Node > map ) { Label Node [ ] clones = new Label Node [ labels . size ( ) ] ; for ( int i = NUM ; i < clones . length ; ++ i ) { clones [ i ] = map . get ( labels . get ( i ) ) ; } return clones ; }
@ Procedure @ Performs Writes @ Description ( STRING ) public Stream < Relationship Refactor Result > from ( @ Name ( STRING ) Relationship rel , @ Name ( STRING ) Node new Node ) { Relationship Refactor Result result = new Relationship Refactor Result ( rel . get Id ( ) ) ; try { Relationship new Rel = new Node . create Relationship To ( rel . get End Node ( ) , rel . get Type ( ) ) ; copy Properties ( rel , new Rel ) ; rel . delete ( ) ; return Stream . of ( result . with Other ( new Rel ) ) ; } catch ( Exception e ) { return Stream . of ( result . with Error ( e ) ) ; } }
public static long max Fill ( final long n , final float f ) { return Math . min ( ( long ) Math . ceil ( n * f ) , n - NUM ) ; }
public static void print ( char x ) { out . print ( x ) ; out . flush ( ) ; }
public void clear Source Elements ( ) { for ( P Node node : source Elements ) { Source Handle . remove Source Handle From ( node ) ; } source Elements . clear ( ) ; selection Model . fire Selection Changed ( ) ; }
public static double [ ] [ ] read Matrix ( int number Of Rows , int number Of Columns , boolean ignore First Line , String file Name ) { double [ ] [ ] matrix = new double [ number Of Rows ] [ number Of Columns ] ; try { File Reader fr = new File Reader ( file Name ) ; Buffered Reader br = new Buffered Reader ( fr ) ; String line ; String Tokenizer tokenizer ; String token ; if ( ignore First Line ) { br . read Line ( ) ; } line = br . read Line ( ) ; int row Id = NUM ; while ( line != null ) { tokenizer = new String Tokenizer ( line ) ; for ( int i = NUM ; i < number Of Columns ; i ++ ) { token = tokenizer . next Token ( ) ; double parsed Number = Double . parse Double ( token ) ; matrix [ row Id ] [ i ] = parsed Number ; } if ( tokenizer . has More Tokens ( ) ) { throw new Runtime Exception ( STRING ) ; } line = br . read Line ( ) ; row Id ++ ; } if ( row Id != number Of Rows ) { throw new Runtime Exception ( STRING ) ; } } catch ( Runtime Exception e ) { throw e ; } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new Runtime Exception ( STRING ) ; } return matrix ; }
@ Override protected boolean read Into Buffer ( int min Length ) { if ( buffer Space Left ( ) < min Length ) { increase Buffer Size ( min Length + currently In Buffer ( ) ) ; } else if ( buf . length - write Pos < min Length ) { compact ( ) ; } int read Sum = NUM ; while ( read Sum < min Length && ! datagrams . is Empty ( ) ) { Datagram next = datagrams . remove First ( ) ; int length = ( int ) next . get Duration ( ) ; if ( buf . length < write Pos + length ) { increase Buffer Size ( write Pos + length ) ; } int read = read Datagram ( next , buf , write Pos ) ; write Pos += read ; read Sum += read ; } if ( data Processor != null ) { data Processor . apply Inline ( buf , write Pos - read Sum , read Sum ) ; } return read Sum >= min Length ; }
private int height Of Phi ( int Phi ) { if ( Phi == NUM ) { return - NUM ; } int Tau = NUM ; int modul = NUM ; while ( Phi % modul == NUM ) { modul *= NUM ; Tau += NUM ; } return Tau - NUM ; }
@ Not Null public Clarifai Client build Sync ( ) { return new Clarifai Client Impl ( this ) ; }
public void mouse Released ( Mouse Event e ) { Visualization Viewer < ? , ? > vv = ( Visualization Viewer < ? , ? > ) e . get Source ( ) ; down = null ; vv . set Cursor ( Cursor . get Predefined Cursor ( Cursor . DEFAULT CURSOR ) ) ; }
@ Nullable public static Class < ? > class For Name ( @ Nullable String cls , @ Nullable Class < ? > dflt , boolean include Primitive Types ) { Class < ? > clazz ; if ( cls == null ) clazz = dflt ; else if ( ! include Primitive Types || cls . length ( ) > NUM || ( clazz = primitive Map . get ( cls ) ) == null ) { try { clazz = Class . for Name ( cls ) ; } catch ( Class Not Found Exception ignore ) { clazz = dflt ; } } return clazz ; }
public String check Write Protected ( int res Id Action , final File ... files To Be Modified ) { if ( files To Be Modified != null ) { for ( File file : files To Be Modified ) { if ( ( file != null ) && ( file . exists ( ) ) && ( ! file . can Write ( ) ) ) { String action = ( res Id Action == NUM ) ? STRING : m Context . get String ( res Id Action ) ; return m Context . get String ( R . string . file err writeprotected , file . get Absolute Path ( ) , action ) ; } } } return null ; }
private int clamp Mag ( int value , int abs Min , int abs Max ) { final int abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }
@ Not Null @ Contract ( pure = BOOL ) public static String strip ( @ Not Null final String s , @ Not Null final Char Filter filter ) { final String Builder result = new String Builder ( s . length ( ) ) ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char ch = s . char At ( i ) ; if ( filter . accept ( ch ) ) { result . append ( ch ) ; } } return result . to String ( ) ; }
protected void add Component ( XML Component component ) { if ( f Components . contains ( component ) ) { return ; } f Components . add ( component ) ; add Recognized Params And Set Defaults ( component ) ; }
public void test Local Instances distribution ( ) { Matsim Random . reset ( NUM ) ; Random local 1 a = Matsim Random . get Local Instance ( ) ; double value 1 = local 1 a . next Double ( ) ; Matsim Random . reset ( NUM ) ; Random local 2 a = Matsim Random . get Local Instance ( ) ; double value 2 a = local 2 a . next Double ( ) ; Random local 2 b = Matsim Random . get Local Instance ( ) ; double value 2 b = local 2 b . next Double ( ) ; assert True ( Math . abs ( value 1 - value 2 a ) > EPSILON ) ; assert True ( Math . abs ( value 2 a - value 2 b ) > EPSILON ) ; assert True ( Math . abs ( value 1 - value 2 b ) > EPSILON ) ; }
public final void test ROUNDTRIP Get Key Spec Key 02 ( ) { boolean performed = BOOL ; for ( int i = NUM ; i < alg Name . length ; i ++ ) { try { Test Data Generator g = new Test Data Generator ( alg Name [ i ] [ NUM ] , alg Name [ i ] [ NUM ] , private Key Info Damaged , null ) ; Encrypted Private Key Info epki ; if ( g . ap ( ) == null ) { epki = new Encrypted Private Key Info ( alg Name [ i ] [ NUM ] , g . ct ( ) ) ; } else { epki = new Encrypted Private Key Info ( g . ap ( ) , g . ct ( ) ) ; } try { epki . get Key Spec ( g . pub K ( ) == null ? g . k ( ) : g . pub K ( ) ) ; fail ( alg Name [ i ] [ NUM ] + STRING + alg Name [ i ] [ NUM ] ) ; } catch ( Invalid Key Exception e ) { } performed = BOOL ; } catch ( Test Data Generator . Allowed Failure allowed Failure ) { } catch ( No Such Algorithm Exception allowed Failure ) { } } assert True ( STRING , performed ) ; }
public void clear ( I Validatable bean ) { for ( Binding b : opt Components . values ( ) ) { b . clear ( bean ) ; } for ( Binding b : bindings . values ( ) ) { b . clear ( bean ) ; } modified = BOOL ; }
public boolean has Credentials ( ) { return has Credentials ; }
public boolean is Recursive Attr Set ( Elem Attribute Set attr Set ) { if ( null == m attr Set Stack ) { m attr Set Stack = new Stack ( ) ; } if ( ! m attr Set Stack . empty ( ) ) { int loc = m attr Set Stack . search ( attr Set ) ; if ( loc > - NUM ) { return BOOL ; } } return BOOL ; }
public void clear ( Absolute Table Identifier absolute Table Identifier ) { table Lock Map . remove ( absolute Table Identifier ) ; table Segment Map . remove ( absolute Table Identifier ) ; }
public int enumerate ( Thread [ ] threads ) { return enumerate ( threads , BOOL ) ; }
public static Input Stream to Input Stream ( Char Sequence input ) { return to Input Stream ( input . to String ( ) ) ; }
@ Override public void process ( Number tuple ) { values . add ( tuple . double Value ( ) ) ; }
public void grant Write Permission ( Collection attribute Names ) { Iterator it = attribute Names . iterator ( ) ; if ( it != null ) { while ( it . has Next ( ) ) { String temp = ( String ) it . next ( ) ; writables . add ( temp . to Lower Case ( ) ) ; } } }
public void save Data ( File file ) throws IO Exception { synchronized ( accumulators ) { Object Output Stream oos = null ; try { oos = new Object Output Stream ( new File Output Stream ( file ) ) ; oos . write Object ( accumulators ) ; } finally { if ( oos != null ) { oos . close ( ) ; } } } }
public static Ingredient from Cursor ( Cursor cursor ) { Ingredient ingredient = new Ingredient ( ) ; for ( int c = NUM ; c < cursor . get Column Count ( ) ; c ++ ) { String column Name = cursor . get Column Name ( c ) ; if ( column Name . equals ( Recipe Ingredient Table . AMOUNT COLUMN ) ) { ingredient . set Amount ( cursor . get String ( c ) ) ; } else if ( column Name . equals ( Recipe Ingredient Table . DESCRIPTION COLUMN ) ) { ingredient . set Description ( cursor . get String ( c ) ) ; } } return ingredient ; }
public void append ( char c [ ] , int off , int len ) { int rest Length = buffer . length - pos ; if ( len < rest Length ) { System . arraycopy ( c , off , buffer , pos , len ) ; pos += len ; } else { System . arraycopy ( c , off , buffer , pos , rest Length ) ; curr . next = new Entity ( buffer ) ; curr = curr . next ; length += buffer . length ; buffer = new char [ ( buffer . length > len - rest Length ) ? buffer . length : len - rest Length ] ; System . arraycopy ( c , off + rest Length , buffer , NUM , len - rest Length ) ; pos = len - rest Length ; } }
public boolean contains ( String voice Name ) { return ( get Voice ( voice Name ) != null ) ; }
public static boolean is Enterprise Edition ( String server Version ) { return server Version . contains ( STRING ) || server Version . contains ( STRING ) || server Version . contains ( STRING ) ; }
@ Override public Category Item Renderer State initialise ( Graphics 2 D g2 , Rectangle 2 D data Area , Category Plot plot , int renderer Index , Plot Rendering Info info ) { Category Item Renderer State state = super . initialise ( g2 , data Area , plot , renderer Index , info ) ; Category Axis domain Axis = get Domain Axis ( plot , renderer Index ) ; Category Dataset dataset = plot . get Dataset ( renderer Index ) ; if ( dataset != null ) { int columns = dataset . get Column Count ( ) ; int rows = dataset . get Row Count ( ) ; double space = NUM ; Plot Orientation orientation = plot . get Orientation ( ) ; if ( orientation == Plot Orientation . HORIZONTAL ) { space = data Area . get Height ( ) ; } else if ( orientation == Plot Orientation . VERTICAL ) { space = data Area . get Width ( ) ; } double max Width = space * get Maximum Bar Width ( ) ; double category Margin = NUM ; double current Item Margin = NUM ; if ( columns > NUM ) { category Margin = domain Axis . get Category Margin ( ) ; } if ( rows > NUM ) { current Item Margin = get Item Margin ( ) ; } double used = space * ( NUM - domain Axis . get Lower Margin ( ) - domain Axis . get Upper Margin ( ) - category Margin - current Item Margin ) ; if ( ( rows * columns ) > NUM ) { state . set Bar Width ( Math . min ( used / ( dataset . get Column Count ( ) * dataset . get Row Count ( ) ) , max Width ) ) ; } else { state . set Bar Width ( Math . min ( used , max Width ) ) ; } } return state ; }
public static boolean create Folder ( @ Suppress Warnings ( STRING ) Context m Context , String path , String folder Name ) { File SD Card Root = new File ( path , folder Name ) ; if ( ! SD Card Root . exists ( ) ) { return SD Card Root . mkdir ( ) ; } return BOOL ; }
private static NS Object parse Object ( Node n ) throws Parse Exception , IO Exception { String type = n . get Node Name ( ) ; if ( type . equals ( STRING ) ) { NS Dictionary dict = new NS Dictionary ( ) ; List < Node > children = filter Element Nodes ( n . get Child Nodes ( ) ) ; for ( int i = NUM ; i < children . size ( ) ; i += NUM ) { Node key = children . get ( i ) ; Node val = children . get ( i + NUM ) ; String key String = get Node Text Contents ( key ) ; dict . put ( key String , parse Object ( val ) ) ; } return dict ; } else if ( type . equals ( STRING ) ) { List < Node > children = filter Element Nodes ( n . get Child Nodes ( ) ) ; NS Array array = new NS Array ( children . size ( ) ) ; for ( int i = NUM ; i < children . size ( ) ; i ++ ) { array . set Value ( i , parse Object ( children . get ( i ) ) ) ; } return array ; } else if ( type . equals ( STRING ) ) { return new NS Number ( BOOL ) ; } else if ( type . equals ( STRING ) ) { return new NS Number ( BOOL ) ; } else if ( type . equals ( STRING ) ) { return new NS Number ( get Node Text Contents ( n ) ) ; } else if ( type . equals ( STRING ) ) { return new NS Number ( get Node Text Contents ( n ) ) ; } else if ( type . equals ( STRING ) ) { return new NS String ( get Node Text Contents ( n ) ) ; } else if ( type . equals ( STRING ) ) { return new NS Data ( get Node Text Contents ( n ) ) ; } else if ( type . equals ( STRING ) ) { return new NS Date ( get Node Text Contents ( n ) ) ; } return null ; }
Lua String load String ( ) throws IO Exception { int size = this . luac Sizeof Size T == NUM ? ( int ) load Int 64 ( ) : load Int ( ) ; if ( size == NUM ) return null ; byte [ ] bytes = new byte [ size ] ; is . read Fully ( bytes , NUM , size ) ; return Lua String . value Of ( bytes , NUM , bytes . length - NUM ) ; }
protected Abstract Preferences ( Abstract Preferences parent , String name ) { if ( parent == null ) { if ( ! name . equals ( STRING ) ) throw new Illegal Argument Exception ( STRING + name + STRING ) ; this . absolute Path = STRING ; root = this ; } else { if ( name . index Of ( STRING ) != - NUM ) throw new Illegal Argument Exception ( STRING + name + STRING ) ; if ( name . equals ( STRING ) ) throw new Illegal Argument Exception ( STRING ) ; root = parent . root ; absolute Path = ( parent == root ? STRING + name : parent . absolute Path ( ) + STRING + name ) ; } this . name = name ; this . parent = parent ; }
static Class < ? > canonicalize ( Class < ? > t , int how ) { Class < ? > ct ; if ( t == Object . class ) { } else if ( ! t . is Primitive ( ) ) { switch ( how ) { case UNWRAP : ct = Wrapper . as Primitive Type ( t ) ; if ( ct != t ) return ct ; break ; case RAW RETURN : case ERASE : return Object . class ; } } else if ( t == void . class ) { switch ( how ) { case RAW RETURN : return int . class ; case WRAP : return Void . class ; } } else { switch ( how ) { case WRAP : return Wrapper . as Wrapper Type ( t ) ; case INTS : if ( t == int . class || t == long . class ) return null ; if ( t == double . class ) return long . class ; return int . class ; case LONGS : if ( t == long . class ) return null ; return long . class ; case RAW RETURN : if ( t == int . class || t == long . class || t == float . class || t == double . class ) return null ; return int . class ; } } return null ; }
protected String extract Substring ( String psz Src ) { int n Bracket = NUM ; int i ; String psz Return ; for ( i = NUM ; i < psz Src . length ( ) && ( n Bracket > NUM || psz Src . char At ( i ) != STRING ) ; i ++ ) { if ( psz Src . char At ( i ) == STRING ) { n Bracket ++ ; } else if ( psz Src . char At ( i ) == STRING ) { n Bracket -- ; } } if ( psz Src . char At ( NUM ) == STRING ) { psz Return = psz Src . substring ( NUM , i - NUM ) ; } else { psz Return = psz Src . substring ( NUM , i ) ; } return psz Return ; }
public void read ( Appendable dest ) throws IO Exception { if ( input Stream == null ) throw new IO Exception ( STRING ) ; while ( BOOL ) { if ( start >= end ) { start = NUM ; end = input Stream . read ( bytes , NUM , bytes . length ) ; if ( end <= NUM ) { break ; } } byte b = bytes [ start ] ; if ( b >= NUM ) { dest . append ( ( char ) b ) ; start ++ ; } else { int code = read 2 ( ) ; if ( code < NUM ) { dest . append ( ( char ) code ) ; } else if ( code <= NUM ) { dest . append ( ( char ) ( ( ( code - NUM ) > > NUM ) + NUM ) ) ; dest . append ( ( char ) ( ( ( code - NUM ) & NUM ) + NUM ) ) ; } else { throw new Char Conversion Exception ( STRING + Integer . to Hex String ( code ) + STRING ) ; } } } }
public boolean is Monitoring ( ) { return m Monitor . is Monitoring ( ) ; }
static final Color hex To Color ( String value ) { String digits ; int n = value . length ( ) ; if ( value . starts With ( STRING ) ) { digits = value . substring ( NUM , Math . min ( value . length ( ) , NUM ) ) ; } else { digits = value ; } String hstr = STRING + digits ; Color c ; try { c = Color . decode ( hstr ) ; } catch ( Number Format Exception nfe ) { c = null ; } return c ; }
public final boolean content Equals ( java . lang . Char Sequence csq ) { if ( csq . length ( ) != length ) return BOOL ; for ( int i = NUM ; i < length ; ) { char c = high [ i > > B1 ] [ i & M1 ] ; if ( csq . char At ( i ++ ) != c ) return BOOL ; } return BOOL ; }
private void populate Available Data Stores ( ) { Data Access Factory fac ; logger . debug ( STRING ) ; Iterator < Data Store Factory Spi > iterator = Data Store Finder . get Available Data Stores ( ) ; while ( iterator . has Next ( ) ) { fac = ( Data Access Factory ) iterator . next ( ) ; logger . debug ( STRING + fac . get Display Name ( ) ) ; available Data Store List . add ( fac . get Display Name ( ) ) ; } }
protected void add ( double value , int group ) { if ( ( group < NUM ) || ( group >= number Of Groups ) ) { throw new Illegal Argument Exception ( STRING ) ; } data . add ( new Observation ( value , group ) ) ; }
protected static String make Option String ( Script script ) { String Buffer result ; Enumeration < Option > enm ; Option option ; result = new String Buffer ( STRING ) ; result . append ( STRING ) ; result . append ( STRING ) ; result . append ( STRING ) ; result . append ( STRING ) ; result . append ( STRING ) ; enm = script . list Options ( ) ; while ( enm . has More Elements ( ) ) { option = enm . next Element ( ) ; result . append ( option . synopsis ( ) + STRING ) ; result . append ( option . description ( ) + STRING ) ; } result . append ( STRING ) ; result . append ( STRING ) ; result . append ( STRING ) ; result . append ( STRING ) ; return result . to String ( ) ; }
public Registration Builder add Contact ( URI contact ) { contacts . add ( contact ) ; return this ; }
public static void close Quietly ( Auto Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( Runtime Exception rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
String format Time ( int hour , int minute ) { String s = STRING ; String t = Integer . to String ( hour ) ; if ( t . length ( ) == NUM ) { s = t + STRING ; } else if ( t . length ( ) == NUM ) { s = STRING + t + STRING ; } t = Integer . to String ( minute ) ; if ( t . length ( ) == NUM ) { s = s + t ; } else if ( t . length ( ) == NUM ) { s = s + STRING + t ; } if ( s . length ( ) != NUM ) { s = STRING ; } return s ; }
public boolean is Empty ( ) { return ( sentence Type == Sentence Type . UNDEFINED ) && expressions . is Empty ( ) ; }
@ Override public void init ( Abstract Addressbook Manager a Boo Mgr ) { set Address Book Manager ( a Boo Mgr ) ; reload Settings ( ) ; try { connection = Driver Manager . get Connection ( IDENTITYDB CONNECT STRING ) ; } catch ( SQL Exception e ) { logger . error ( STRING + IDENTITYDB CONNECT STRING , e ) ; } Statement statement ; try { statement = connection . create Statement ( ) ; statement . set Query Timeout ( NUM ) ; statement . execute Update ( STRING + TABLE IDENTITY + STRING ) ; statement . execute Update ( STRING + TABLE CLOUDPROVIDER + STRING ) ; statement . execute Update ( STRING + TABLE CLOUDPROVIDER MAP + STRING ) ; a Boo Mgr . init ( ) ; } catch ( SQL Exception e ) { logger . error ( STRING , e ) ; } finally { if ( connection != null ) { try { connection . close ( ) ; } catch ( SQL Exception e ) { logger . error ( STRING , e ) ; } } } }
private Buffer check Error Packet ( int command ) throws SQL Exception { Buffer result Packet = null ; this . server Status = NUM ; try { result Packet = reuse And Read Packet ( this . reusable Packet ) ; } catch ( SQL Exception sql Ex ) { throw sql Ex ; } catch ( Exception fall Thru ) { throw SQL Error . create Communications Exception ( this . connection , this . last Packet Sent Time Ms , this . last Packet Received Time Ms , fall Thru , get Exception Interceptor ( ) ) ; } check Error Packet ( result Packet ) ; return result Packet ; }
public void apply Settings ( boolean load Core Components ) throws Apply Settings Exception { List < String > errors = new Array List < String > ( NUM ) ; apply Torrent Data Save Folder Settings ( errors ) ; apply Torrent Seeding Settings ( errors ) ; if ( ! errors . is Empty ( ) ) { throw new Apply Settings Exception ( String Utils . explode ( errors , STRING ) ) ; } }
public boolean should Select Cell ( Event Object e ) { return BOOL ; }
private int measure Short ( int measure Spec ) { int result ; int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; if ( spec Mode == Measure Spec . EXACTLY ) { result = spec Size ; } else { result = ( int ) ( NUM * m Radius + get Padding Top ( ) + get Padding Bottom ( ) + NUM ) ; if ( spec Mode == Measure Spec . AT MOST ) { result = Math . min ( result , spec Size ) ; } } return result ; }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; if ( resource Bundle Name != null ) { try { rb = Resource Bundle . get Bundle ( resource Bundle Name ) ; } catch ( Missing Resource Exception e ) { rb = null ; } } }
method info find Method ( String s ) { method info m ; int i ; for ( i = NUM ; i < methods count ; i ++ ) { m = methods [ i ] ; if ( s . equals ( m . to Name ( constant pool ) ) ) { return m ; } } return null ; }
private boolean matches ( @ Nullable Object obj , String operator , String operand Str ) { Obs Value value ; if ( obj == null ) { switch ( operator ) { case STRING : case STRING : case STRING : return operand Str . is Empty ( ) ; default : return BOOL ; } } else if ( obj instanceof Obs Point ) { value = ( ( Obs Point ) obj ) . value ; } else if ( obj instanceof Obs Value ) { value = ( Obs Value ) obj ; } else return BOOL ; Obs Value operand = null ; if ( value . uuid != null ) { operand = Obs Value . new Coded ( Utils . expand Uuid ( operand Str ) ) ; } else if ( value . number != null ) { try { operand = Obs Value . new Number ( Double . value Of ( operand Str ) ) ; } catch ( Number Format Exception e ) { operand = Obs Value . ZERO ; } } else if ( value . text != null ) { operand = Obs Value . new Text ( operand Str ) ; } else if ( value . date != null ) { try { operand = Obs Value . new Date ( Local Date . parse ( operand Str ) ) ; } catch ( Illegal Argument Exception e ) { operand = Obs Value . MIN DATE ; } } else if ( value . instant != null ) { try { operand = Obs Value . new Time ( Long . value Of ( operand Str ) ) ; } catch ( Illegal Argument Exception e ) { operand = Obs Value . MIN TIME ; } } switch ( operator ) { case STRING : case STRING : case STRING : return Objects . equal ( value . uuid , operand . uuid ) ; case STRING : return value . compare To ( operand ) < NUM ; case STRING : return value . compare To ( operand ) <= NUM ; case STRING : return value . compare To ( operand ) > NUM ; case STRING : return value . compare To ( operand ) >= NUM ; } return BOOL ; }
private void wait Until Readable ( ) throws IO Exception { read Timeout . enter ( ) ; try { while ( read Buffer . size ( ) == NUM && ! finished && ! closed && error Code == null ) { wait For Io ( ) ; } } finally { read Timeout . exit And Throw If Timed Out ( ) ; } }
public static < X extends Exception > String to String ( Iteration < ? , X > iter , String separator ) throws X { String Builder sb = new String Builder ( ) ; to String ( iter , separator , sb ) ; return sb . to String ( ) ; }
@ Suppress Warnings ( STRING ) @ Override public boolean contains ( final Object obj ) { if ( null != obj ) { Iterator < E > it = new Array Deque Iterator < E > ( ) ; while ( it . has Next ( ) ) { if ( obj . equals ( ( E ) it . next ( ) ) ) { return BOOL ; } } } return BOOL ; }
public static synchronized Grid Test Print Stream acquire Err ( ) { if ( test Err == null ) test Err = new Grid Test Print Stream ( sys Err ) ; if ( err Cnt == NUM ) System . set Err ( test Err ) ; err Cnt ++ ; return test Err ; }
private void write Object ( Object Output Stream out ) throws IO Exception { out . default Write Object ( ) ; do Write Object ( out ) ; }
private static boolean is Property Name ( String name ) { return ( ( name . length ( ) > NUM ) && Character . is Upper Case ( name . char At ( NUM ) ) ) || ( ( name . length ( ) > NUM ) && Character . is Upper Case ( name . char At ( NUM ) ) ) ; }
public Collection < Expression Object < ? > > analyze Expression ( Generic PK id , Expression formula , Expression AST expression ) throws Scope Exception { Extract References visitor = new Extract References ( ) ; List < Expression Ref > references = visitor . apply ( expression ) ; String internal = rewrite Expression Value ( formula . get Value ( ) , expression , references ) ; if ( ! internal . equals ( formula . get Value ( ) ) ) { formula . set Internal ( internal ) ; } else { formula . set Internal ( null ) ; } int level = compute Reference Tree ( expression , references ) ; formula . set Level ( level ) ; Collection < Expression Object < ? > > objects = new Hash Set < > ( ) ; for ( Expression Ref expr : references ) { Object ref = expr . get Reference ( ) ; if ( ref != null && ref instanceof Property ) { Property property = ( Property ) ref ; Expression Object < ? > object = property . get Expression Object ( ) ; if ( object != null ) { objects . add ( object ) ; } } } if ( ! objects . is Empty ( ) ) { Collection < Expression Object < ? > > closure = null ; Collection < Expression Object < ? > > transitive Closure = objects ; do { closure = transitive Closure ; transitive Closure = transitive Closure ( id , closure ) ; } while ( closure . size ( ) < transitive Closure . size ( ) ) ; Collection < Reference PK < ? > > I Ds = new Hash Set < > ( ) ; for ( Expression Object < ? > object : transitive Closure ) { Reference PK < ? > ref Pk = reference ( object ) ; if ( ref Pk != null ) { I Ds . add ( ref Pk ) ; } } formula . set References ( I Ds ) ; return transitive Closure ; } else { return objects ; } }
public void remove Rtcp Listener ( Rtcp Event Listener listener ) { if ( s Logger . is Activated ( ) ) { s Logger . debug ( STRING ) ; } m Listeners . remove Element ( listener ) ; }
private static void collect All Times ( Tree tree , Node Ref node , Node Ref [ ] exclude Below , Array List times , Array List < Integer > childs ) { times . add ( new Comparable Double ( tree . get Node Height ( node ) ) ) ; childs . add ( tree . get Child Count ( node ) ) ; for ( int i = NUM ; i < tree . get Child Count ( node ) ; i ++ ) { Node Ref child = tree . get Child ( node , i ) ; if ( exclude Below == null ) { collect All Times ( tree , child , exclude Below , times , childs ) ; } else { boolean include = BOOL ; for ( Node Ref an Exclude Below : exclude Below ) { if ( an Exclude Below . get Number ( ) == child . get Number ( ) ) { include = BOOL ; break ; } } if ( include ) collect All Times ( tree , child , exclude Below , times , childs ) ; } } }
protected void paint Text ( final Graphics g , final J Component c , final Rectangle local Text Rect , final String text ) { final Graphics 2 D g2 d = g instanceof Graphics 2 D ? ( Graphics 2 D ) g : null ; final Abstract Button b = ( Abstract Button ) c ; final Button Model model = b . get Model ( ) ; final Font Metrics fm = g . get Font Metrics ( ) ; final int mnemonic Index = Aqua Mnemonic Handler . is Mnemonic Hidden ( ) ? - NUM : b . get Displayed Mnemonic Index ( ) ; if ( model . is Enabled ( ) ) { g . set Color ( b . get Foreground ( ) ) ; } else { g . set Color ( default Disabled Text Color ) ; } Swing Utilities 2 . draw String Underline Char At ( c , g , text , mnemonic Index , local Text Rect . x , local Text Rect . y + fm . get Ascent ( ) ) ; }
public static Constraint Widget [ ] infer Table List ( Widgets Scene list ) { for ( Constraint Widget widget : list . get Widgets ( ) ) { widget . reset Anchors ( ) ; } return infer Table List ( list . get Root ( ) ) ; }
public String to XML String ( boolean include NS , boolean declare NS ) throws FS Msg Exception { return to XML String ( include NS , declare NS , BOOL ) ; }
public void if Present ( Long Consumer consumer ) { if ( is Present ) consumer . accept ( value ) ; }
public void update ( String [ ] columns , Object [ ] column Values , String [ ] conditions , Object [ ] condition Values ) throws Data Access Exception { if ( columns . length != column Values . length || conditions . length != condition Values . length ) { logger . error ( STRING ) ; return ; } Object [ ] values = Arrays . copy Of ( column Values , column Values . length + condition Values . length ) ; System . arraycopy ( condition Values , NUM , values , column Values . length , condition Values . length ) ; final String sql = Prepared Statement Util . prepare Update Template With Column ( table Name , columns , conditions ) ; execute ( sql , values ) ; }
public static String replica Set Used In ( String addresses ) { if ( addresses . starts With ( STRING ) ) { return null ; } int index = addresses . index Of ( STRING ) ; if ( index < NUM ) return null ; return addresses . substring ( NUM , index ) ; }
public void on Progress ( long bytes Written , long total Size ) { Log . v ( LOG TAG , String . format ( STRING , bytes Written , total Size , ( total Size > NUM ) ? ( bytes Written * NUM / total Size ) * NUM : - NUM ) ) ; }
public String self ( Type Declaration decl ) { if ( decl instanceof Constructor ) { decl = ( Type Declaration ) decl . get Container ( ) ; } String name = Js Utils . escape String Literal ( decl . get Name ( ) ) ; if ( decl . is Shared ( ) || decl . is Toplevel ( ) ) { name += nesting Suffix ( decl , BOOL ) ; } else { name = STRING + Long . to String ( get UID ( decl ) , NUM ) ; } return String . format ( STRING , Character . to Lower Case ( name . char At ( NUM ) ) , name . substring ( NUM ) ) ; }
public double elapsed Time ( ) { long now = thread Timer . get Current Thread Cpu Time ( ) ; return ( now - start ) / NANOSECONDS PER SECOND ; }
public static void sort List ( List list ) { if ( System Utils . IS JAVA 1 7 && list instanceof Copy On Write Array List ) { List temp List = new Array List ( list ) ; Collections . sort ( temp List ) ; list . clear ( ) ; list . add All ( temp List ) ; } else { Collections . sort ( list ) ; } }
public void fire Indexed Property Change ( String property Name , int index , boolean old Value , boolean new Value ) { if ( old Value != new Value ) { fire Indexed Property Change ( property Name , index , Boolean . value Of ( old Value ) , Boolean . value Of ( new Value ) ) ; } }
public static < T > T [ ] concat ( T [ ] first , T [ ] second , Class < T > type ) { T [ ] result = new Array ( type , first . length + second . length ) ; System . arraycopy ( first , NUM , result , NUM , first . length ) ; System . arraycopy ( second , NUM , result , first . length , second . length ) ; return result ; }
public synchronized void write To Remote ( byte b ) { remote Buffer . add ( b ) ; }
@ Override public void draw Series ( Canvas canvas , Paint paint , List < Float > points , List < Double > values , XY Series Renderer series Renderer , Support Series Render support Series Render , float y Axis Value , int series Index , int start Index ) { int series Nr = m Dataset . get Series Count ( ) ; int length = points . size ( ) ; paint . set Color ( series Renderer . get Color ( ) ) ; paint . set Style ( Style . FILL ) ; float half Diff X = get Half Diff X ( points , length , series Nr ) ; int start = NUM ; if ( start Index > NUM ) { start = NUM ; } for ( int i = start ; i < length ; i += NUM ) { if ( points . size ( ) > i + NUM ) { float x Min = points . get ( i ) ; float y Min = points . get ( i + NUM ) ; float x Max = points . get ( i + NUM ) ; float y Max = points . get ( i + NUM ) ; draw Bar ( canvas , x Min , y Min , x Max , y Max , half Diff X , series Nr , series Index , paint ) ; } } paint . set Color ( series Renderer . get Color ( ) ) ; }
private void begin Gesture ( int scroll Offset Y , int scroll Extent Y ) { m Initial Translation Y = get Translation Y ( ) ; boolean is Initially Visible = m Initial Translation Y < m Total Height ; int starting Y = is Initially Visible ? scroll Offset Y : Math . min ( scroll Offset Y , m Total Height ) ; m Initial Offset Y = starting Y + scroll Extent Y ; }
@ Override public void add ( String ... identifiers ) { whitelist . add All ( Arrays . as List ( identifiers ) ) ; }
public static void clear ( ) { shop Id . set ( NUM ) ; shop Code . set ( STRING ) ; }
@ Override public boolean communication Initiated ( ) { return bugs Populated . get Count ( ) == NUM && communication Initiated && network Client . ready ( ) ; }
public static Charset to Charset ( Charset charset ) { return charset == null ? Charset . default Charset ( ) : charset ; }
@ Override public void dump ( String prefix , File Descriptor fd , Print Writer writer , String [ ] args ) { super . dump ( prefix , fd , writer , args ) ; writer . print ( prefix ) ; writer . print ( STRING ) ; writer . println ( raw Query ) ; writer . print ( prefix ) ; writer . print ( STRING ) ; writer . println ( Arrays . to String ( args ) ) ; }
public void add Contig Field ( Contig Field field ) { add Id Field ( m Contig Lines , field ) ; }
boolean remove Index Entry ( String resource Name , String policy Name ) { Iterator iter = top Level Entries . iterator ( ) ; boolean processed = BOOL ; while ( ! processed && ( iter . has Next ( ) ) ) { Resource Index Entry resource Index Entry = ( Resource Index Entry ) iter . next ( ) ; if ( resource Index Entry . remove Index Entry ( resource Type , resource Name , policy Name ) ) { processed = BOOL ; } } return processed ; }
public static double pdf ( double x , double mu , double shape ) { if ( ! ( x > NUM ) || x == Double . POSITIVE INFINITY ) { return NUM ; } final double v = ( x - mu ) / mu ; double t1 = Math . sqrt ( shape / ( Math Util . TWOPI * x * x * x ) ) ; return t1 > NUM ? t1 * Math . exp ( - shape * v * v * NUM / x ) : NUM ; }
@ Override public void on Stop Tracking Touch ( Seek Bar seek Bar ) { final int pos = m Item List . index Of ( m Selected Tracker ) ; final int delta = NUM / m Item List . size ( ) ; cp mover . set Progress ( pos * delta + delta / NUM ) ; }
public static int max Profit ( int [ ] prices ) { if ( prices == null || prices . length < NUM ) { return NUM ; } int max = NUM ; int min = prices [ NUM ] ; for ( int i = NUM ; i < prices . length ; i ++ ) { min = Math . min ( min , prices [ i ] ) ; if ( prices [ i ] > prices [ i - NUM ] ) { max = Math . max ( max , prices [ i ] - min ) ; } } return max ; }
public void add ( String string ) { elements . add ( string == null ? Json Null . INSTANCE : new Json Primitive ( string ) ) ; }
public void component Added ( Container Event e ) { Layer child Layer = ( Layer ) e . get Child ( ) ; add Projection Listener ( child Layer ) ; if ( ! removed Layers . remove Element ( child Layer ) ) { added Layers . add Element ( child Layer ) ; } change Layers ( e ) ; }
public void processing Instruction ( String target , String data ) throws SAX Exception { characters Flush ( ) ; int data Index = m data . size ( ) ; m previous = add Node ( DTM . PROCESSING INSTRUCTION NODE , DTM . PROCESSING INSTRUCTION NODE , m parents . peek ( ) , m previous , - data Index , BOOL ) ; m data . add Element ( m values Or Prefixes . string To Index ( target ) ) ; m values . add Element ( data ) ; m data . add Element ( m value Index ++ ) ; }
protected void panic ( String msg ) throws SAX Exception { SAX Parse Exception spe = new SAX Parse Exception ( msg , this ) ; m Hand Err . fatal Error ( spe ) ; throw spe ; }
private void update Namespace Permissions ( User Namespace Authorization Entity user Namespace Authorization Entity , List < Namespace Permission Enum > namespace Permissions ) { user Namespace Authorization Entity . set Read Permission ( namespace Permissions . contains ( Namespace Permission Enum . READ ) ) ; user Namespace Authorization Entity . set Write Permission ( namespace Permissions . contains ( Namespace Permission Enum . WRITE ) ) ; user Namespace Authorization Entity . set Execute Permission ( namespace Permissions . contains ( Namespace Permission Enum . EXECUTE ) ) ; user Namespace Authorization Entity . set Grant Permission ( namespace Permissions . contains ( Namespace Permission Enum . GRANT ) ) ; }
public static void report ( ) { if ( ! booted ) return ; Controller Thread . report ( ) ; Runtime Measurements . report ( ) ; for ( Enumeration < Organizer > e = organizers . elements ( ) ; e . has More Elements ( ) ; ) { Organizer organizer = e . next Element ( ) ; organizer . report ( ) ; } if ( options . FINAL REPORT LEVEL >= NUM ) { Edge Counts . dump Counts ( ) ; dcg . dump Graph ( ) ; } if ( options . REPORT INTERRUPT STATS ) { VM . sys Writeln ( STRING ) ; VM . sys Writeln ( STRING , RVM Thread . timer Ticks ) ; VM . sys Writeln ( STRING , controller Clock ) ; VM . sys Writeln ( STRING , ( int ) method Samples . get Total Number Of Samples ( ) ) ; } }
public static Set < ? > convert Array To Set ( Object [ ] source ) { Set < Object > set = new Hash Set < Object > ( ) ; for ( Object element : source ) { set . add ( element ) ; } return set ; }
public static int intersect Line Rectangle ( Line 2 D l , Rectangle 2 D r , Point 2 D [ ] pts ) { double a1 x = l . get X 1 ( ) , a1 y = l . get Y 1 ( ) ; double a2 x = l . get X 2 ( ) , a2 y = l . get Y 2 ( ) ; double mxx = r . get Max X ( ) , mxy = r . get Max Y ( ) ; double mnx = r . get Min X ( ) , mny = r . get Min Y ( ) ; if ( pts [ NUM ] == null ) pts [ NUM ] = new Point 2 D . Double ( ) ; if ( pts [ NUM ] == null ) pts [ NUM ] = new Point 2 D . Double ( ) ; int i = NUM ; if ( intersect Line Line ( mnx , mny , mxx , mny , a1 x , a1 y , a2 x , a2 y , pts [ i ] ) > NUM ) i ++ ; if ( intersect Line Line ( mxx , mny , mxx , mxy , a1 x , a1 y , a2 x , a2 y , pts [ i ] ) > NUM ) i ++ ; if ( i == NUM ) return i ; if ( intersect Line Line ( mxx , mxy , mnx , mxy , a1 x , a1 y , a2 x , a2 y , pts [ i ] ) > NUM ) i ++ ; if ( i == NUM ) return i ; if ( intersect Line Line ( mnx , mxy , mnx , mny , a1 x , a1 y , a2 x , a2 y , pts [ i ] ) > NUM ) i ++ ; return i ; }
public static String cidr Mask To Net Mask ( String cidr Mask ) { if ( cidr Mask == null ) { return null ; } int cidr Mask Value = NUM ; try { cidr Mask Value = Integer . parse Int ( cidr Mask ) ; } catch ( Number Format Exception e ) { return null ; } int cidr Mask Full = NUM << ( NUM - cidr Mask Value ) ; int cidr Mask Bits 1 = cidr Mask Full > > NUM & NUM ; int cidr Mask Bits 2 = cidr Mask Full > > NUM & NUM ; int cidr Mask Bits 3 = cidr Mask Full > > NUM & NUM ; int cidr Mask Bits 4 = cidr Mask Full > > NUM & NUM ; String Buffer net Mask Buf = new String Buffer ( ) ; net Mask Buf . append ( cidr Mask Bits 1 ) ; net Mask Buf . append ( STRING ) ; net Mask Buf . append ( cidr Mask Bits 2 ) ; net Mask Buf . append ( STRING ) ; net Mask Buf . append ( cidr Mask Bits 3 ) ; net Mask Buf . append ( STRING ) ; net Mask Buf . append ( cidr Mask Bits 4 ) ; return net Mask Buf . to String ( ) ; }
public boolean in Bounds ( Mouse Event e ) { return e . get X ( ) > x && e . get X ( ) < x + width && e . get Y ( ) > y && e . get Y ( ) < y + height ; }
public Class Path ( @ Nonnull Iterable < Dex File > class Path , boolean check Package Private Access ) { Iterable < Dex File > dex Files = Iterables . concat ( class Path , Lists . new Array List ( get Basic Classes ( ) ) ) ; unknown Class = new Unknown Class Proto ( this ) ; loaded Classes . put ( unknown Class . get Type ( ) , unknown Class ) ; this . check Package Private Access = check Package Private Access ; load Primitive Type ( STRING ) ; load Primitive Type ( STRING ) ; load Primitive Type ( STRING ) ; load Primitive Type ( STRING ) ; load Primitive Type ( STRING ) ; load Primitive Type ( STRING ) ; load Primitive Type ( STRING ) ; load Primitive Type ( STRING ) ; load Primitive Type ( STRING ) ; for ( Dex File dex File : dex Files ) { for ( Class Def class Def : dex File . get Classes ( ) ) { Class Def prev = available Classes . get ( class Def . get Type ( ) ) ; if ( prev == null ) { available Classes . put ( class Def . get Type ( ) , class Def ) ; } } } }
private boolean ask To Save ( ) { if ( main Frame . is Project Changed ( ) ) { int response = J Option Pane . show Confirm Dialog ( main Frame , L10 N . get Local String ( STRING , STRING ) , L10 N . get Local String ( STRING , STRING ) , J Option Pane . YES NO CANCEL OPTION , J Option Pane . WARNING MESSAGE ) ; if ( response == J Option Pane . YES OPTION ) { if ( main Frame . get Save File ( ) != null ) { save ( ) ; } else { save As ( ) ; } } else if ( response == J Option Pane . CANCEL OPTION ) { return BOOL ; } } return BOOL ; }
public Map Cursor add Cursor ( Map Cursor cursor ) { cursors . add ( cursor ) ; return cursor ; }
private boolean discard Upstream Media Chunks ( int queue Length ) { if ( media Chunks . size ( ) <= queue Length ) { return BOOL ; } long start Time Us = NUM ; long end Time Us = media Chunks . get Last ( ) . end Time Us ; Base Media Chunk removed = null ; while ( media Chunks . size ( ) > queue Length ) { removed = media Chunks . remove Last ( ) ; start Time Us = removed . start Time Us ; } sample Queue . discard Upstream Samples ( removed . get First Sample Index ( ) ) ; notify Upstream Discarded ( start Time Us , end Time Us ) ; return BOOL ; }
public Metalink File Builder add File ( String name ) { Metalink File Builder new File = new Metalink File Builder ( name ) ; files . add ( new File ) ; return new File ; }
private void send After Connect ( Channel ch , Netty Channel Context context Final , Operation request , Netty Channel Group group ) { if ( request . get Status Code ( ) < Operation . STATUS CODE FAILURE THRESHOLD ) { request . complete ( ) ; } else { request . fail ( request . get Status Code ( ) ) ; } }
protected String check Production ( final Territory to , final Collection < Unit > units , final Player ID player ) { final List < Territory > producers = get All Producers ( to , player , units ) ; if ( producers . is Empty ( ) ) { return STRING + to . get Name ( ) ; } Collections . sort ( producers , get Best Producer Comparator ( to , units , player ) ) ; if ( ! get Can All Units With Requires Units Be Placed Correctly ( units , to ) ) { return STRING ; } final int max Units To Be Placed = get Max Units To Be Placed ( units , to , player , BOOL ) ; if ( ( max Units To Be Placed != - NUM ) && ( max Units To Be Placed < units . size ( ) ) ) { return STRING + units . size ( ) + STRING + to . get Name ( ) ; } return null ; }
@ Override public void close Write ( ) throws IO Exception { if ( is Write Closed ) { return ; } is Write Closed = BOOL ; Socket Stream stream = stream Impl ; if ( stream != null ) { stream . close Write ( ) ; } else if ( s != null ) { try { s . shutdown Output ( ) ; } catch ( Unsupported Operation Exception e ) { log . log ( Level . FINEST , e . to String ( ) , e ) ; } catch ( Exception e ) { log . finer ( e . to String ( ) ) ; log . log ( Level . FINEST , e . to String ( ) , e ) ; } } }
public boolean equals ( Object that ) { return ( that instanceof Char Set ) && Arrays . equals ( chars , ( ( Char Set ) that ) . chars ) ; }
public static Void process Records ( List < Kinesis Event Record > input Records , Kinesis User Record Processor processor ) { List < Record > raw Records = new Linked List < > ( ) ; for ( Kinesis Event Record rec : input Records ) { raw Records . add ( rec . get Kinesis ( ) ) ; } return processor . process ( User Record . deaggregate ( raw Records ) ) ; }
protected Font resolve Font ( Shared Context ctx , String font , float size , Ident Value weight , Ident Value style , Ident Value variant ) { if ( font . starts With ( STRING ) ) { font = font . substring ( NUM ) ; } if ( font . ends With ( STRING ) ) { font = font . substring ( NUM , font . length ( ) - NUM ) ; } if ( font . equals Ignore Case ( STRING ) ) { font = STRING ; } if ( font . equals Ignore Case ( STRING ) ) { font = STRING ; } if ( font . equals Ignore Case ( STRING ) ) { font = STRING ; } if ( font . equals ( STRING ) && style == Ident Value . OBLIQUE ) { font = STRING ; } if ( font . equals ( STRING ) && style == Ident Value . ITALIC ) { font = STRING ; } String font Instance Name = get Font Instance Hash Name ( ctx , font , size , weight , style , variant ) ; if ( instance Hash . contains Key ( font Instance Name ) ) { return instance Hash . get ( font Instance Name ) ; } if ( available Fonts Hash . contains Key ( font ) ) { Font possibly Null Font = available Fonts Hash . get ( font ) ; Font root Font = null ; if ( possibly Null Font != null ) { root Font = possibly Null Font ; } else { root Font = new Font ( font , Font . PLAIN , NUM ) ; available Fonts Hash . put ( font , root Font ) ; } Font fnt = create Font ( ctx , root Font , size , weight , style , variant ) ; instance Hash . put ( font Instance Name , fnt ) ; return fnt ; } return null ; }
public Array Real Vector ( double [ ] d , int pos , int size ) throws Math Illegal Argument Exception , Null Argument Exception { if ( d == null ) { throw new Null Argument Exception ( ) ; } if ( d . length < pos + size ) { throw new Math Illegal Argument Exception ( Localized Core Formats . NUMBER TOO LARGE , pos + size , d . length ) ; } data = new double [ size ] ; System . arraycopy ( d , pos , data , NUM , size ) ; }
public void clear Payment Methods By Id ( List < String > payment Method Ids To Remove ) { if ( Util Validate . is Empty ( payment Method Ids To Remove ) ) return ; for ( Iterator < Cart Payment Info > iter = payment Info . iterator ( ) ; iter . has Next ( ) ; ) { Cart Payment Info info = iter . next ( ) ; if ( payment Method Ids To Remove . contains ( info . payment Method Id ) ) { iter . remove ( ) ; } } }
@ Override public void clean ( ) { set Current Points ( NUM ) ; check State ( ) ; }
public void handle Button 2 Request ( Request Invocation Event event ) { set Page Session Attribute ( get Tracking Tab ID Name ( ) , AM Admin Constants . FED TAB ID ) ; set Page Session Attribute ( AM Admin Constants . PREVIOUS TAB ID , get Tracking Tab ID Name ( ) ) ; Federation View Bean vb = ( Federation View Bean ) get View Bean ( Federation View Bean . class ) ; back Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; }
@ Override public void perform Request ( String request ) { if ( request . compare To ( STRING ) == NUM ) { stop ( ) ; } else { throw new Illegal Argument Exception ( request + STRING ) ; } }
public byte [ ] to Bytes ( ) { byte [ ] return Bytes = new byte [ bytes Length ] ; System . arraycopy ( bytes , NUM , return Bytes , NUM , bytes Length ) ; return return Bytes ; }
public void start Check ( ) { checker = new Thread ( new Check For Update ( ) ) ; checker . set Priority ( Thread . MIN PRIORITY ) ; checker . start ( ) ; }
@ Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case S Graph Package . TRANSITION TRIGGER : return trigger != null ; case S Graph Package . TRANSITION EFFECT : return effect != null ; case S Graph Package . TRANSITION PROPERTIES : return properties != null && ! properties . is Empty ( ) ; case S Graph Package . TRANSITION DOCUMENTATION : return DOCUMENTATION EDEFAULT == null ? documentation != null : ! DOCUMENTATION EDEFAULT . equals ( documentation ) ; case S Graph Package . TRANSITION TARGET : return target != null ; case S Graph Package . TRANSITION SOURCE : return basic Get Source ( ) != null ; } return super . e Is Set ( feature ID ) ; }
public boolean is Ack Seen ( ) { return this . ack Seen ; }
protected void uninstall Listeners ( ) { super . uninstall Listeners ( ) ; split Pane . remove Property Change Listener ( this ) ; }
private static Collector < Segment Info , ? , Map < String , Segment Info > > partitions To Map Collector ( ) { return Collector . of ( null , null , null ) ; }
public boolean is Crc ( ) { return is Flags ( FLAG CACHED VALUES CHECKED & FLAG CRC CALCED ) ; }
public int size ( ) { return queue . size ( ) ; }
@ Override public String Buffer format ( double number , String Buffer result , Field Position field Position ) { boolean try Fast Path = BOOL ; if ( field Position == Dont Care Field Position . INSTANCE ) try Fast Path = BOOL ; else { field Position . set Begin Index ( NUM ) ; field Position . set End Index ( NUM ) ; } if ( try Fast Path ) { String temp Result = fast Format ( number ) ; if ( temp Result != null ) { result . append ( temp Result ) ; return result ; } } return format ( number , result , field Position . get Field Delegate ( ) ) ; }
private void build Cursor Conditionally ( Matrix Cursor cursor , Character Record cr , String selection , String [ ] selection Args ) { if ( selection Args == null ) cursor . add Row ( new Object [ ] { cr . get Id ( ) , cr . get Name ( ) , cr . get Race ( ) } ) ; else for ( String item : selection Args ) if ( ( selection . equals ( Character Contract . Character Entry . COLUMN NAME ) && item . equals ( cr . get Name ( ) ) ) || ( selection . equals ( Character Contract . Character Entry . COLUMN RACE ) && item . equals ( cr . get Race ( ) ) ) ) { cursor . add Row ( new Object [ ] { cr . get Id ( ) , cr . get Name ( ) , cr . get Race ( ) } ) ; } }
public Modpack File Selection Panel ( Wizard Controller controller , Map wizard Data , File game Dir , Bi Function < String , Boolean , Integer > black List ) { init Components ( ) ; this . controller = controller ; this . wizard Data = wizard Data ; this . black List = black List ; Check Box Tree Node root = create ( game Dir , STRING ) ; j Tree 1 . set Model ( new Default Tree Model ( root ) ) ; j Tree 1 . set Cell Renderer ( new Check Box Tree Cell Renderer ( ) ) ; j Tree 1 . add Mouse Listener ( new Check Box Tree Node Selection Listener ( ) ) ; wizard Data . put ( STRING , root ) ; }
public Shape paint Layer ( Graphics g , int offs 0 , int offs 1 , Shape bounds , J Text Component c , View view ) { Graphics 2 D g2 d = ( Graphics 2 D ) g ; Composite original Composite = null ; if ( get Alpha ( ) < NUM ) { original Composite = g2 d . get Composite ( ) ; g2 d . set Composite ( get Alpha Composite ( ) ) ; } Paint paint = get Paint ( ) ; if ( paint == null ) g2 d . set Color ( c . get Selection Color ( ) ) ; else g2 d . set Paint ( paint ) ; if ( offs 0 == view . get Start Offset ( ) && offs 1 == view . get End Offset ( ) ) { Rectangle alloc ; if ( bounds instanceof Rectangle ) alloc = ( Rectangle ) bounds ; else alloc = bounds . get Bounds ( ) ; g2 d . fill Rect ( alloc . x , alloc . y , alloc . width , alloc . height ) ; if ( get Alpha ( ) < NUM ) g2 d . set Composite ( original Composite ) ; return alloc ; } else { try { Shape shape = view . model To View ( offs 0 , Position . Bias . Forward , offs 1 , Position . Bias . Backward , bounds ) ; Rectangle r = ( shape instanceof Rectangle ) ? ( Rectangle ) shape : shape . get Bounds ( ) ; if ( rounded Edges ) { g2 d . fill Round Rect ( r . x , r . y , r . width , r . height , ARCWIDTH , ARCHEIGHT ) ; } else { g2 d . fill Rect ( r . x , r . y , r . width , r . height ) ; } if ( get Alpha ( ) < NUM ) g2 d . set Composite ( original Composite ) ; return r ; } catch ( Bad Location Exception ble ) { ble . print Stack Trace ( ) ; } finally { if ( get Alpha ( ) < NUM ) g2 d . set Composite ( original Composite ) ; } } return null ; }
private void create Container If Necessary ( ) { if ( container . is Full ( ) ) { container = new Timer Raw Container ( ) ; data . add ( container ) ; } }
private void process Update Counts ( int [ ] update Counts , int commands In Batch ) { if ( update Counts . length < commands In Batch ) { error . emit ( tuples . get ( update Counts . length + batch Start Idx ) ) ; error Tuples ++ ; tuples Written Successfully += update Counts . length ; batch Start Idx += update Counts . length + NUM ; if ( ( tuples . size ( ) - batch Start Idx ) > NUM ) { process Batch ( ) ; } } else { tuples Written Successfully = commands In Batch ; for ( int i = NUM ; i < commands In Batch ; i ++ ) { if ( update Counts [ i ] == Statement . EXECUTE FAILED ) { error . emit ( tuples . get ( i + batch Start Idx ) ) ; error Tuples ++ ; tuples Written Successfully -- ; } } } }
public int choose Protocol Version ( ) { return preferred Protocol Version ; }
public Sensor create New Sensor ( String system Name , String user Name ) { Sensor s ; String s Name = Acela Address . normalize System Name ( system Name ) ; if ( s Name . equals ( STRING ) ) { log . error ( STRING + system Name ) ; return null ; } s = get By System Name ( s Name ) ; if ( s != null ) { log . error ( STRING + system Name ) ; return null ; } String alt Name = Acela Address . convert System Name To Alternate ( s Name ) ; s = get By System Name ( alt Name ) ; if ( s != null ) { log . error ( STRING + system Name + STRING + alt Name + STRING ) ; return null ; } int bit = Acela Address . get Bit From System Name ( s Name ) ; if ( ( bit < NUM ) || ( bit >= NUM ) ) { log . error ( STRING + Integer . to String ( bit ) + STRING ) ; return null ; } if ( user Name == null ) { s = new Acela Sensor ( s Name ) ; } else { s = new Acela Sensor ( s Name , user Name ) ; } Acela Node node = Acela Address . get Node From System Name ( s Name , memo ) ; if ( node == null ) { log . warn ( STRING + s Name + STRING ) ; return s ; } if ( ! node . has Active Sensors ) { int newnodeaddress ; newnodeaddress = node . get Node Address ( ) ; log . warn ( STRING + newnodeaddress ) ; return s ; } node . register Sensor ( s , bit ) ; return s ; }
public static Input Stream need Stream ( String property Name ) throws No Such Property Exception , File Not Found Exception , Mary Configuration Exception { Mary Properties . need Property ( property Name ) ; return get Stream ( property Name ) ; }
public static boolean equal ( Object a , Object b ) { return a == b || ( a != null && a . equals ( b ) ) ; }
public static String network Name To String ( byte [ ] data , int offset , int length ) { String ret ; if ( ( data [ offset ] & NUM ) != NUM || length < NUM ) { return STRING ; } switch ( ( data [ offset ] > > > NUM ) & NUM ) { case NUM : int count Septets ; int unused Bits = data [ offset ] & NUM ; count Septets = ( ( ( length - NUM ) * NUM ) - unused Bits ) / NUM ; ret = Gsm Alphabet . gsm 7 Bit Packed To String ( data , offset + NUM , count Septets ) ; break ; case NUM : try { ret = new String ( data , offset + NUM , length - NUM , STRING ) ; } catch ( Unsupported Encoding Exception ex ) { ret = STRING ; Log . e ( LOG TAG , STRING , ex ) ; } break ; default : ret = STRING ; break ; } if ( ( data [ offset ] & NUM ) != NUM ) { } return ret ; }
public void add ( Marker marker ) { m Items . add ( marker ) ; }
public static String read Ascii Line ( Input Stream in ) throws IO Exception { String Builder result = new String Builder ( NUM ) ; while ( BOOL ) { int c = in . read ( ) ; if ( c == - NUM ) { throw new EOF Exception ( ) ; } else if ( c == STRING ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > NUM && result . char At ( length - NUM ) == STRING ) { result . set Length ( length - NUM ) ; } return result . to String ( ) ; }
private static Map . Entry < Date Time , Time Series Value > find Name ( List < Time Series Collection > c , Group Name name ) { List Iterator < Time Series Collection > iter = c . list Iterator ( ) ; while ( iter . has Next ( ) ) { final int idx = iter . next Index ( ) ; final Time Series Collection tsdata = iter . next ( ) ; final Optional < Time Series Value > found = tsdata . get ( name ) ; if ( found . is Present ( ) ) return Simple Map Entry . create ( tsdata . get Timestamp ( ) , found . get ( ) ) ; } throw new Illegal State Exception ( STRING ) ; }
public Map < String , Object > finalize Order Entry Payment ( String check Out Payment Id , Big Decimal amount , boolean single Use , boolean append ) { Map < String , Object > result = Service Util . return Success ( ) ; if ( Util Validate . is Not Empty ( check Out Payment Id ) ) { if ( ! append ) { cart . clear Payments ( ) ; } cart . add Payment Amount ( check Out Payment Id , amount , single Use ) ; } return result ; }
public void deploy ( String route Id , String route Name , Json Value route Config ) throws Router Handler Exception { Reject . if Null ( route Name ) ; write . lock ( ) ; try { load ( route Id , route Name , route Config . copy ( ) ) ; directory Monitor . store ( route Id , route Config ) ; logger . info ( STRING , route Id , route Name ) ; } catch ( IO Exception e ) { throw new Router Handler Exception ( format ( STRING , route Id ) , e ) ; } finally { write . unlock ( ) ; } }
private static char [ ] subscript For Digit ( int digit ) { return Character . to Chars ( NUM + digit ) ; }
private Fs Permission permission ( Igfs File file ) { String perm = file . property ( Igfs Utils . PROP PERMISSION , null ) ; if ( perm == null ) return Fs Permission . get Default ( ) ; try { return new Fs Permission ( ( short ) Integer . parse Int ( perm , NUM ) ) ; } catch ( Number Format Exception ignore ) { return Fs Permission . get Default ( ) ; } }
public Simple Mailbox ACL ( ) { this . entries = Collections . empty Map ( ) ; }
private void read Stream Result ( In H 3 h In , Headers Amp headers ) throws IO Exception { Service Ref Amp service Ref = read To Address ( h In ) ; long id = h In . read Long ( ) ; Query Ref Amp query Ref = service Ref . get Query Ref ( id ) ; if ( query Ref != null ) { Class Loader loader = query Ref . get Class Loader ( ) ; Thread thread = Thread . current Thread ( ) ; thread . set Context Class Loader ( loader ) ; } int sequence = h In . read Int ( ) ; List < Object > values = ( List ) h In . read Object ( ) ; Throwable exn = ( Throwable ) h In . read Object ( Throwable . class ) ; boolean is Complete = h In . read Boolean ( ) ; if ( log . is Loggable ( log Level ) ) { log . log ( log Level , STRING + values + STRING + is Complete + STRING + this + STRING + STRING + id + STRING + service Ref + STRING + headers + STRING ) ; } if ( query Ref != null ) { if ( query Ref . accept ( headers , values , sequence , is Complete ) ) { service Ref . remove Query Ref ( id ) ; } if ( exn != null ) { service Ref . remove Query Ref ( id ) ; query Ref . fail ( headers , exn ) ; } } else if ( log . is Loggable ( Level . WARNING ) ) { log . warning ( STRING + id + STRING + service Ref + STRING + headers ) ; } }
public static int rect Crossings For Path ( Path Iterator pi , double rxmin , double rymin , double rxmax , double rymax ) { if ( rxmax <= rxmin || rymax <= rymin ) { return NUM ; } if ( pi . is Done ( ) ) { return NUM ; } double coords [ ] = new double [ NUM ] ; if ( pi . current Segment ( coords ) != Path Iterator . SEG MOVETO ) { throw new Illegal Path State Exception ( STRING + STRING ) ; } pi . next ( ) ; double curx , cury , movx , movy , endx , endy ; curx = movx = coords [ NUM ] ; cury = movy = coords [ NUM ] ; int crossings = NUM ; while ( crossings != RECT INTERSECTS && ! pi . is Done ( ) ) { switch ( pi . current Segment ( coords ) ) { case Path Iterator . SEG MOVETO : if ( curx != movx || cury != movy ) { crossings = rect Crossings For Line ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , movx , movy ) ; } movx = curx = coords [ NUM ] ; movy = cury = coords [ NUM ] ; break ; case Path Iterator . SEG LINETO : endx = coords [ NUM ] ; endy = coords [ NUM ] ; crossings = rect Crossings For Line ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , endx , endy ) ; curx = endx ; cury = endy ; break ; case Path Iterator . SEG QUADTO : endx = coords [ NUM ] ; endy = coords [ NUM ] ; crossings = rect Crossings For Quad ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , coords [ NUM ] , coords [ NUM ] , endx , endy , NUM ) ; curx = endx ; cury = endy ; break ; case Path Iterator . SEG CUBICTO : endx = coords [ NUM ] ; endy = coords [ NUM ] ; crossings = rect Crossings For Cubic ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , coords [ NUM ] , coords [ NUM ] , coords [ NUM ] , coords [ NUM ] , endx , endy , NUM ) ; curx = endx ; cury = endy ; break ; case Path Iterator . SEG CLOSE : if ( curx != movx || cury != movy ) { crossings = rect Crossings For Line ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , movx , movy ) ; } curx = movx ; cury = movy ; break ; } pi . next ( ) ; } if ( crossings != RECT INTERSECTS && ( curx != movx || cury != movy ) ) { crossings = rect Crossings For Line ( crossings , rxmin , rymin , rxmax , rymax , curx , cury , movx , movy ) ; } return crossings ; }
public void update Field Visibility ( Neuron Update Rule rule ) { boolean bounded = rule instanceof Bounded Update Rule ; boolean clip = BOOL ; set Bounds Panel Visible ( bounded ) ; if ( bounded ) { clip = rule instanceof Clippable Update Rule ; clipping Drop Down . set Selected ( clip ) ; } set Clipping Panel Visible ( clip ) ; set Bounds Enabled ( bounded ) ; }
@ Override public int hash Code ( ) { int hash = NUM ; if ( alt Format != null ) { hash += alt Format . hash Code ( ) ; } if ( projection != null ) { hash = hash * NUM ; hash += projection . hash Code ( ) ; } if ( version != null ) { hash = hash * NUM ; hash += version . hash Code ( ) ; } return hash ; }
public void remove Ok Listener ( Action Listener a ) { m ok But . remove Action Listener ( a ) ; }
void change item shape ( Brd Item p item , int p shape no , Shape Tile p new shape ) { Awtree Node Leaf [ ] old entries = p item . get search tree entries ( this ) ; Awtree Node Leaf [ ] new leaf arr = new Awtree Node Leaf [ old entries . length ] ; Shape Tile [ ] new precalculated tree shapes = new Shape Tile [ old entries . length ] ; remove leaf ( old entries [ p shape no ] ) ; for ( int i = NUM ; i < new precalculated tree shapes . length ; ++ i ) { if ( i == p shape no ) { new precalculated tree shapes [ i ] = p new shape ; } else { new precalculated tree shapes [ i ] = p item . get tree shape ( this , i ) ; new leaf arr [ i ] = old entries [ i ] ; } } p item . set precalculated tree shapes ( new precalculated tree shapes , this ) ; new leaf arr [ p shape no ] = insert ( p item , p shape no ) ; p item . set search tree entries ( this , new leaf arr ) ; }
public J Quick Start Pane ( Kse Frame kse Frame ) { super ( GRADIENT COLOR 1 , GRADIENT COLOR 2 ) ; this . kse Frame = kse Frame ; new Drop Target ( this , this ) ; init Components ( ) ; }
protected String decode ( String url String ) { try { Class clazz = URL Decoder . class ; Method method = clazz . get Declared Method ( STRING , new Class [ ] { String . class , String . class } ) ; if ( url String . index Of ( STRING ) >= NUM ) { int len = url String . length ( ) ; String Buffer buf = new String Buffer ( len ) ; for ( int i = NUM ; i < len ; i ++ ) { char c = url String . char At ( i ) ; if ( c == STRING ) buf . append ( STRING ) ; else buf . append ( c ) ; } url String = buf . to String ( ) ; } Object result = method . invoke ( null , new Object [ ] { url String , STRING } ) ; if ( result != null ) return ( String ) result ; } catch ( Exception e ) { } boolean replaced = BOOL ; byte [ ] encoded Bytes = url String . get Bytes ( ) ; int encoded Length = encoded Bytes . length ; byte [ ] decoded Bytes = new byte [ encoded Length ] ; int decoded Length = NUM ; for ( int i = NUM ; i < encoded Length ; i ++ ) { byte b = encoded Bytes [ i ] ; if ( b == STRING ) { if ( i + NUM >= encoded Length ) throw new Illegal Argument Exception ( STRING + url String + STRING ) ; byte enc 1 = encoded Bytes [ ++ i ] ; byte enc 2 = encoded Bytes [ ++ i ] ; b = ( byte ) ( ( hex To Byte ( enc 1 ) << NUM ) + hex To Byte ( enc 2 ) ) ; replaced = BOOL ; } decoded Bytes [ decoded Length ++ ] = b ; } if ( ! replaced ) return url String ; try { return new String ( decoded Bytes , NUM , decoded Length , STRING ) ; } catch ( Unsupported Encoding Exception e ) { return new String ( decoded Bytes , NUM , decoded Length ) ; } }
public static String indent ( final int depth ) { if ( depth < NUM ) { return STRING ; } return ws . substring ( NUM , Math . min ( ws . length ( ) , depth * NUM ) ) ; }
public Exceptionless Output Stream ( Output Stream out ) { super ( new Data Output Stream ( out ) ) ; dos = ( Data Output Stream ) this . out ; }
public T advance To Element ( Predicate < T > predicate ) { Node < T > start = head ; if ( head == null ) return null ; do { T curr Element = advance ( ) ; if ( predicate . test ( curr Element ) ) { return curr Element ; } } while ( head != start ) ; return null ; }
public void add Trace ( final Trace trace ) { trace List . add ( trace ) ; add ( trace ) ; revalidate ( ) ; }
public static void ping All Devices ( String message ) throws IO Exception { Sender sender = new Sender ( Ids . API KEY ) ; for ( Device Info device Info : endpoint . list Device Info ( ) ) { do Send Via Gcm ( message , sender , device Info ) ; } }
public static void w ( String tag , String msg , Object ... args ) { if ( s Level > LEVEL WARNING ) { return ; } if ( args . length > NUM ) { msg = String . format ( msg , args ) ; } Log . w ( tag , msg ) ; }
private void find Matches In Contexts ( List < Number Context > contexts , boolean is Valid , boolean is Possible , String region , String number ) { if ( is Valid ) { do Test In Context ( number , region , contexts , Leniency . VALID ) ; } else { for ( Number Context context : contexts ) { String text = context . leading Text + number + context . trailing Text ; assert True ( STRING + text , has No Matches ( phone Util . find Numbers ( text , region ) ) ) ; } } if ( is Possible ) { do Test In Context ( number , region , contexts , Leniency . POSSIBLE ) ; } else { for ( Number Context context : contexts ) { String text = context . leading Text + number + context . trailing Text ; assert True ( STRING + text , has No Matches ( phone Util . find Numbers ( text , region , Leniency . POSSIBLE , Long . MAX VALUE ) ) ) ; } } }
public void test General Punctuation Category ( ) { String [ ] s = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; String regexp = STRING ; for ( int i = NUM ; i < s . length ; i ++ ) { Pattern pattern = Pattern . compile ( regexp ) ; Matcher matcher = pattern . matcher ( s [ i ] ) ; assert True ( matcher . find ( ) ) ; } }
@ Override public int hash Code ( ) { int code = NUM ; if ( e Subjects != null ) { for ( Entitlement Subject e Subject : e Subjects ) { code += e Subject . hash Code ( ) ; } } if ( p Subject Name != null ) { code += p Subject Name . hash Code ( ) ; } return code ; }
private void assign Random Lower Triangular Matrix ( int n , Secure Random sr ) { num Rows = n ; num Columns = n ; length = ( n + NUM ) > > > NUM ; matrix = new int [ num Rows ] [ length ] ; for ( int i = NUM ; i < num Rows ; i ++ ) { int q = i > > > NUM ; int r = i & NUM ; int s = NUM - r ; r = NUM << r ; for ( int j = NUM ; j < q ; j ++ ) { matrix [ i ] [ j ] = sr . next Int ( ) ; } matrix [ i ] [ q ] = ( sr . next Int ( ) > > > s ) | r ; for ( int j = q + NUM ; j < length ; j ++ ) { matrix [ i ] [ j ] = NUM ; } } }
private boolean load With Inspect It Class Loader ( String class Name ) { return class Name . starts With ( CLASS NAME PREFIX ) ; }
public static void add Custom Commands ( String commands , Context Menu m ) { Matcher matcher = CUSTOM COMMANDS PATTERN . matcher ( commands ) ; boolean sep = BOOL ; while ( matcher . find ( ) ) { String match = matcher . group ( ) ; if ( match . equals ( STRING ) ) { sep = BOOL ; } else { String command = matcher . group ( NUM ) ; String submenu = null ; if ( match . starts With ( STRING ) ) { submenu = CUSTOM COMMANDS SUBMENU ; } if ( sep ) { m . add Separator ( submenu ) ; } m . add Sub Item ( STRING + command , Helper . replace Underscore With Space ( command ) , submenu ) ; sep = BOOL ; } } }
public void paint Border ( Component c , Graphics g , int x , int y , int width , int height ) { Border border = get Border ( ) ; String title = get Title ( ) ; if ( ( title != null ) && ! title . is Empty ( ) ) { int edge = ( border instanceof Titled Border ) ? NUM : EDGE SPACING ; J Label label = get Label ( c ) ; Dimension size = label . get Preferred Size ( ) ; Insets insets = get Border Insets ( border , c , new Insets ( NUM , NUM , NUM , NUM ) ) ; int border X = x + edge ; int border Y = y + edge ; int border W = width - edge - edge ; int border H = height - edge - edge ; int label Y = y ; int label H = size . height ; int position = get Position ( ) ; switch ( position ) { case ABOVE TOP : insets . left = NUM ; insets . right = NUM ; border Y += label H - edge ; border H -= label H - edge ; break ; case TOP : insets . top = edge + insets . top / NUM - label H / NUM ; if ( insets . top < edge ) { border Y -= insets . top ; border H += insets . top ; } else { label Y += insets . top ; } break ; case BELOW TOP : label Y += insets . top + edge ; break ; case ABOVE BOTTOM : label Y += height - label H - insets . bottom - edge ; break ; case BOTTOM : label Y += height - label H ; insets . bottom = edge + ( insets . bottom - label H ) / NUM ; if ( insets . bottom < edge ) { border H += insets . bottom ; } else { label Y -= insets . bottom ; } break ; case BELOW BOTTOM : insets . left = NUM ; insets . right = NUM ; label Y += height - label H ; border H -= label H - edge ; break ; } insets . left += edge + TEXT INSET H ; insets . right += edge + TEXT INSET H ; int label X = x ; int label W = width - insets . left - insets . right ; if ( label W > size . width ) { label W = size . width ; } switch ( get Justification ( c ) ) { case LEFT : label X += insets . left ; break ; case RIGHT : label X += width - insets . right - label W ; break ; case CENTER : label X += ( width - label W ) / NUM ; break ; } if ( border != null ) { if ( ( position != TOP ) && ( position != BOTTOM ) ) { border . paint Border ( c , g , border X , border Y , border W , border H ) ; } else { Graphics g2 = g . create ( ) ; if ( g2 instanceof Graphics 2 D ) { Graphics 2 D g2 d = ( Graphics 2 D ) g2 ; Path 2 D path = new Path 2 D . Float ( ) ; path . append ( new Rectangle ( border X , border Y , border W , label Y - border Y ) , BOOL ) ; path . append ( new Rectangle ( border X , label Y , label X - border X - TEXT SPACING , label H ) , BOOL ) ; path . append ( new Rectangle ( label X + label W + TEXT SPACING , label Y , border X - label X + border W - label W - TEXT SPACING , label H ) , BOOL ) ; path . append ( new Rectangle ( border X , label Y + label H , border W , border Y - label Y + border H - label H ) , BOOL ) ; g2 d . clip ( path ) ; } border . paint Border ( c , g2 , border X , border Y , border W , border H ) ; g2 . dispose ( ) ; } } g . translate ( label X , label Y ) ; label . set Size ( label W , label H ) ; label . paint ( g ) ; g . translate ( - label X , - label Y ) ; } else if ( border != null ) { border . paint Border ( c , g , x , y , width , height ) ; } }
public int next Clear Bit ( int from Index ) { int i = from Index > > ADDRESS BITS ; int max = data . length ; for ( ; i < max ; i ++ ) { if ( data [ i ] == - NUM ) { continue ; } int j = Math . max ( from Index , i << ADDRESS BITS ) ; for ( int end = j + NUM ; j < end ; j ++ ) { if ( ! get ( j ) ) { return j ; } } } return max << ADDRESS BITS ; }
private final void next Request ( ) { pacing Timer . stop ( ) ; pacing Timer . restart ( ) ; reply Try Count = NUM ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) { return BOOL ; } if ( o == null || get Class ( ) != o . get Class ( ) ) { return BOOL ; } Account account = ( Account ) o ; if ( username != null ? ! username . equals ( account . username ) : account . username != null ) { return BOOL ; } return BOOL ; }
public static int identify Pid ( final String name ) throws Pid Unavailable Exception { try { final int index = name . index Of ( STRING ) ; if ( index < NUM ) { throw new Pid Unavailable Exception ( STRING + name ) ; } return Integer . value Of ( name . substring ( NUM , index ) ) ; } catch ( Number Format Exception e ) { throw new Pid Unavailable Exception ( STRING + name , e ) ; } }
abstract protected void process Command ( String line ) throws Exception ;
private void write Attribute ( java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( namespace . equals ( STRING ) ) { xml Writer . write Attribute ( att Name , att Value ) ; } else { register Prefix ( xml Writer , namespace ) ; xml Writer . write Attribute ( namespace , att Name , att Value ) ; } }
protected Object next ( ) { int i = NUM ; char [ ] c ; try { i = st . next Token ( ) ; } catch ( IO Exception e ) { Debug . error ( STRING + e . to String ( ) + STRING ) ; } if ( ( i == Stream Tokenizer . TT EOF ) || ( i == NUM ) ) return EOF ; if ( i == Stream Tokenizer . TT WORD ) return new Symbol ( st . sval , NUM ) ; if ( ( i == STRING ) || ( i == STRING ) ) return st . sval ; if ( i == Stream Tokenizer . TT NUMBER ) return new Double ( st . nval ) ; if ( ( i == STRING ) || ( i == STRING ) || ( i == STRING ) ) return LP ; if ( ( i == STRING ) || ( i == STRING ) || ( i == STRING ) ) return RP ; c = new char [ NUM ] ; c [ NUM ] = ( char ) i ; return new Symbol ( new String ( c ) , NUM ) ; }
public static void copy ( File source , File dest ) throws IO Exception { if ( source . is Directory ( ) ) { dest . mkdir ( ) ; for ( File child : list Files ( source ) ) { copy ( child , new File ( dest , child . get Name ( ) ) ) ; } } else { if ( source . exists ( ) ) { long lm = source . last Modified ( ) ; if ( dest . is Directory ( ) ) { dest = new File ( dest , source . get Name ( ) ) ; } File Output Stream fos = new File Output Stream ( dest ) ; try { File Input Stream fis = new File Input Stream ( source ) ; try { if ( USE NIO ) { nio Copy ( fos , fis ) ; } else { oio Copy ( source , fos , fis ) ; } } finally { fis . close ( ) ; } } finally { fos . close ( ) ; } dest . set Executable ( source . can Execute ( ) , BOOL ) ; dest . set Last Modified ( lm ) ; } } }
public static int class Index ( int lua State , Class clazz , String search Name ) throws Lua Exception { synchronized ( Lua State Factory . get Existing State ( lua State ) ) { int res ; res = check Field ( lua State , clazz , search Name ) ; if ( res != NUM ) { return NUM ; } res = check Method ( lua State , clazz , search Name ) ; if ( res != NUM ) { return NUM ; } return NUM ; } }
private void notify Resource Event Listeners ( Resource Event event , Object resource ) { for ( Iterator < Resource Events Listener > iter = resource Listeners . iterator ( ) ; iter . has Next ( ) ; ) { try { Resource Events Listener listener = ( Resource Events Listener ) iter . next ( ) ; listener . handle Event ( event , resource ) ; } catch ( Cancel Exception e ) { } catch ( Gem Fire Security Exception | Management Exception ex ) { if ( event == Resource Event . CACHE CREATE ) { throw ex ; } else { logger . warn ( ex . get Message ( ) , ex ) ; } } catch ( Exception err ) { logger . warn ( err . get Message ( ) , err ) ; } catch ( Virtual Machine Error e ) { System Failure . initiate Failure ( e ) ; throw e ; } catch ( Throwable t ) { System Failure . check Failure ( ) ; logger . warn ( t . get Message ( ) , t ) ; } } }
public boolean is Enum Constant ( ) { return ( get Modifiers ( ) & Modifier . ENUM ) != NUM ; }
private void infer Caller ( ) { need To Infer Caller = BOOL ; Throwable throwable = new Throwable ( ) ; boolean looking For Logger = BOOL ; for ( final Stack Trace Element frame : throwable . get Stack Trace ( ) ) { String cname = frame . get Class Name ( ) ; boolean is Logger Impl = is Logger Impl Frame ( cname ) ; if ( looking For Logger ) { if ( is Logger Impl ) { looking For Logger = BOOL ; } } else { if ( ! is Logger Impl ) { if ( ! cname . starts With ( STRING ) && ! cname . starts With ( STRING ) ) { set Source Class Name ( cname ) ; set Source Method Name ( frame . get Method Name ( ) ) ; return ; } } } } }
final int record Exceptional Completion ( Throwable ex ) { int s ; if ( ( s = status ) >= NUM ) { int h = System . identity Hash Code ( this ) ; final Reentrant Lock lock = exception Table Lock ; lock . lock ( ) ; try { expunge Stale Exceptions ( ) ; Exception Node [ ] t = exception Table ; int i = h & ( t . length - NUM ) ; for ( Exception Node e = t [ i ] ; ; e = e . next ) { if ( e == null ) { t [ i ] = new Exception Node ( this , ex , t [ i ] , exception Table Ref Queue ) ; break ; } if ( e . get ( ) == this ) break ; } } finally { lock . unlock ( ) ; } s = set Completion ( EXCEPTIONAL ) ; } return s ; }
private void analyze Resulting Tls Context And Write File ( Tls Context tls Context , String folder , String field Name , String workflow Name , long phase ) throws JAXB Exception , IO Exception { if ( Tls Context Analyzer . contains Full Workflow With Missing Message ( tls Context ) || Tls Context Analyzer . contains Server Finished With Modified Handshake ( tls Context ) || Tls Context Analyzer . contains Full Workflow With Modified Message ( tls Context ) ) { String file Name Basic = create File Name ( folder , phase , tls Context , field Name ) ; File Output Stream fos = new File Output Stream ( file Name Basic + workflow Name + STRING ) ; Workflow Trace Serializer . write ( fos , tls Context . get Workflow Trace ( ) ) ; } }
private static String to Variable Name ( String str ) { String Buffer rtn = new String Buffer ( ) ; char [ ] chars = str . to Char Array ( ) ; long changes = NUM ; boolean do Correct = BOOL ; for ( int i = NUM ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( i == NUM && ( c >= STRING && c <= STRING ) ) rtn . append ( STRING + c ) ; else if ( ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || c == STRING || c == STRING ) rtn . append ( c ) ; else { do Correct = BOOL ; rtn . append ( STRING ) ; changes += ( c * ( i + NUM ) ) ; } } if ( changes > NUM ) rtn . append ( changes ) ; if ( do Correct ) return correct Reserved Word ( rtn . to String ( ) ) ; return rtn . to String ( ) ; }
public Year ( int year ) { if ( ( year < Year . MINIMUM YEAR ) || ( year > Year . MAXIMUM YEAR ) ) { throw new Illegal Argument Exception ( STRING + year + STRING ) ; } this . year = ( short ) year ; peg ( Calendar . get Instance ( ) ) ; }
@ Suppress Warnings ( STRING ) public List < String > host Vcenter Change Details ( URI host Id , URI cluster Id , URI datacenter Id , boolean is Vcenter ) { List < String > result = Lists . new Array List ( ) ; Host host = db Client . query Object ( Host . class , host Id ) ; Vcenter Data Center datacenter = db Client . query Object ( Vcenter Data Center . class , datacenter Id ) ; if ( host != null && datacenter != null ) { result . add ( Compute System Dialog Properties . get Message ( STRING , host . get Label ( ) , datacenter . get Label ( ) ) ) ; result . add All ( host Cluster Change Details ( host Id , cluster Id , datacenter Id , is Vcenter ) ) ; } return result ; }
public boolean delete Statement ( Test Case test , int position ) throws Construction Failed Exception { if ( ! Constraint Verifier . can Delete ( test , position ) ) { return BOOL ; } logger . debug ( STRING , position ) ; Set < Integer > to Delete = new Linked Hash Set < > ( ) ; recursive Delete Inclusion ( test , to Delete , position ) ; List < Integer > pos = new Array List < > ( to Delete ) ; Collections . sort ( pos , Collections . reverse Order ( ) ) ; for ( Integer i : pos ) { logger . debug ( STRING , i ) ; test . remove ( i ) ; } return BOOL ; }
public boolean is Compound ( ) { return splits . size ( ) != NUM ; }
@ Override public Set < Statement > sum ( final IGAS State < Set < Statement > , Set < Statement > , Set < Statement > > state , final Set < Statement > left , final Set < Statement > right ) { final Set < Statement > tmp = new Linked Hash Set < Statement > ( left ) ; tmp . add All ( right ) ; return tmp ; }
public void test Signum Positive ( ) { String a = STRING ; int a Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return HOST ; case NUM : return PORT ; case NUM : return ID ; case NUM : return V NODES ; case NUM : return PING FREQUENCY ; case NUM : return SERVICE NAME ; case NUM : return STATE ; case NUM : return TIMESTAMP ; default : return null ; } }
private static int categorize By Year 2014 Method ( Context c ) { Array List < Integer > component Years = new Array List < Integer > ( ) ; conditionally Add ( component Years , get Num Cores Year ( ) ) ; conditionally Add ( component Years , get Clock Speed Year ( ) ) ; conditionally Add ( component Years , get Ram Year ( c ) ) ; if ( component Years . is Empty ( ) ) return CLASS UNKNOWN ; Collections . sort ( component Years ) ; if ( ( component Years . size ( ) & NUM ) == NUM ) { return component Years . get ( component Years . size ( ) / NUM ) ; } else { int base Index = component Years . size ( ) / NUM - NUM ; return component Years . get ( base Index ) + ( component Years . get ( base Index + NUM ) - component Years . get ( base Index ) ) / NUM ; } }
public Time ( Date time ) { Simple Time Zone tz = new Simple Time Zone ( NUM , STRING ) ; Simple Date Format date F = new Simple Date Format ( STRING ) ; date F . set Time Zone ( tz ) ; String d = date F . format ( time ) + STRING ; int year = Integer . parse Int ( d . substring ( NUM , NUM ) ) ; if ( year < NUM || year > NUM ) { this . time = new DER Generalized Time ( d ) ; } else { this . time = new DERUTC Time ( d . substring ( NUM ) ) ; } }
public Action Request Helper then ( Action Request Helper next Action ) { m Next . add ( next Action ) ; return this ; }
protected int [ ] read Color Table ( final int ncolors ) { final int nbytes = NUM * ncolors ; int [ ] tab = null ; final byte [ ] c = new byte [ nbytes ] ; try { raw Data . get ( c ) ; tab = new int [ NUM ] ; int i = NUM ; int j = NUM ; while ( i < ncolors ) { final int r = ( c [ j ++ ] ) & NUM ; final int g = ( c [ j ++ ] ) & NUM ; final int b = ( c [ j ++ ] ) & NUM ; tab [ i ++ ] = NUM | ( r << NUM ) | ( g << NUM ) | b ; } } catch ( final Buffer Underflow Exception e ) { Log . w ( TAG , STRING , e ) ; status = STATUS FORMAT ERROR ; } return tab ; }
public boolean is Current ( String str ) { if ( pos + str . length ( ) > lc Text . length ) return BOOL ; for ( int i = str . length ( ) - NUM ; i >= NUM ; i -- ) { if ( str . char At ( i ) != lc Text [ pos + i ] ) return BOOL ; } return BOOL ; }
private static String matchable Path ( String path ) { if ( path == null ) { return STRING ; } else if ( path . ends With ( STRING ) ) { return path ; } else { return path + STRING ; } }
public void assert Usable ( ) throws IO Exception { if ( throwable . get ( ) == null ) { if ( connection == null ) { throw new IO Exception ( STRING ) ; } return ; } Throwable t = throwable . get ( ) ; if ( t instanceof IO Exception ) { throw ( IO Exception ) t ; } else { throw Throwables . propagate ( t ) ; } }
protected static double compute H ( final int i , double [ ] dist i , double [ ] pij i , double mbeta ) { double sum P = NUM ; for ( int j = NUM ; j < i ; j ++ ) { sum P += ( pij i [ j ] = Math . exp ( dist i [ j ] * mbeta ) ) ; } for ( int j = i + NUM ; j < dist i . length ; j ++ ) { sum P += ( pij i [ j ] = Math . exp ( dist i [ j ] * mbeta ) ) ; } if ( ! ( sum P > NUM ) ) { return Double . NEGATIVE INFINITY ; } final double s = NUM / sum P ; double sum = NUM ; for ( int j = NUM ; j < dist i . length ; j ++ ) { sum += dist i [ j ] * ( pij i [ j ] *= s ) ; } return Math . log ( sum P ) - mbeta * sum ; }
private Collection < Insanity > check Subreaders ( Map Of Sets < Integer , Cache Entry > val Id To Items , Map Of Sets < Reader Field , Integer > reader Field To Val Ids ) { final List < Insanity > insanity = new Array List < > ( NUM ) ; Map < Reader Field , Set < Reader Field > > bad Children = new Hash Map < > ( NUM ) ; Map Of Sets < Reader Field , Reader Field > bad Kids = new Map Of Sets < > ( bad Children ) ; Map < Integer , Set < Cache Entry > > vi To Item Sets = val Id To Items . get Map ( ) ; Map < Reader Field , Set < Integer > > rf To Val Id Sets = reader Field To Val Ids . get Map ( ) ; Set < Reader Field > seen = new Hash Set < > ( NUM ) ; Set < Reader Field > reader Fields = rf To Val Id Sets . key Set ( ) ; for ( final Reader Field rf : reader Fields ) { if ( seen . contains ( rf ) ) continue ; List < Object > kids = get All Descendant Reader Keys ( rf . reader Key ) ; for ( Object kid Key : kids ) { Reader Field kid = new Reader Field ( kid Key , rf . field Name ) ; if ( bad Children . contains Key ( kid ) ) { bad Kids . put ( rf , kid ) ; bad Kids . put All ( rf , bad Children . get ( kid ) ) ; bad Children . remove ( kid ) ; } else if ( rf To Val Id Sets . contains Key ( kid ) ) { bad Kids . put ( rf , kid ) ; } seen . add ( kid ) ; } seen . add ( rf ) ; } for ( final Reader Field parent : bad Children . key Set ( ) ) { Set < Reader Field > kids = bad Children . get ( parent ) ; List < Cache Entry > bad Entries = new Array List < > ( kids . size ( ) * NUM ) ; { for ( final Integer value : rf To Val Id Sets . get ( parent ) ) { bad Entries . add All ( vi To Item Sets . get ( value ) ) ; } } for ( final Reader Field kid : kids ) { for ( final Integer value : rf To Val Id Sets . get ( kid ) ) { bad Entries . add All ( vi To Item Sets . get ( value ) ) ; } } Cache Entry [ ] badness = new Cache Entry [ bad Entries . size ( ) ] ; badness = bad Entries . to Array ( badness ) ; insanity . add ( new Insanity ( Insanity Type . SUBREADER , STRING + parent . to String ( ) , badness ) ) ; } return insanity ; }
public static String add Protocol To Url ( String url ) { if ( ! url . starts With ( HTTP PROTOCOL PREFIX ) && ! url . starts With ( HTTPS PROTOCOL PREFIX ) && ! url . starts With ( FILE PROTOCOL PREFIX ) ) { if ( url . starts With ( FILE PREFIX ) ) { url = FILE PROTOCOL PREFIX + url ; } else { url = HTTP PROTOCOL PREFIX + url ; } } return url ; }
public X Path ( String expr String , Source Locator locator , Prefix Resolver prefix Resolver , int type ) throws javax . xml . transform . Transformer Exception { this ( expr String , locator , prefix Resolver , type , null ) ; }
public static String method Name To Property Name ( String method Name ) { if ( method Name . starts With ( STRING ) ) method Name = method Name . substring ( NUM ) ; else if ( method Name . starts With ( STRING ) ) method Name = method Name . substring ( NUM ) ; else if ( method Name . starts With ( STRING ) ) method Name = method Name . substring ( NUM ) ; if ( method Name . length ( ) == NUM ) return null ; char ch = method Name . char At ( NUM ) ; if ( Character . is Upper Case ( ch ) && ( method Name . length ( ) == NUM || ! Character . is Upper Case ( method Name . char At ( NUM ) ) ) ) { method Name = Character . to Lower Case ( ch ) + method Name . substring ( NUM ) ; } return method Name ; }
private String Builder create Indent ( int indent ) { String Builder one Indent = create Indent ( ) ; String Builder ret = new String Builder ( ) ; while ( indent -- > NUM ) { ret . append ( one Indent ) ; } return ret ; }
protected Class Loader ( ) { this ( get System Class Loader ( ) ) ; }
public static void matchv Pool With Storage Pools ( Virtual Pool vpool , List < Storage Pool > pools , Db Client db Client , Coordinator Client coordinator , String matcher Group Name , String Buffer error Message ) { List < Storage Pool > filter Pools = get Matched Pool With Storage Pools ( vpool , pools , Virtual Pool . get Protection Settings ( vpool , db Client ) , Virtual Pool . get Remote Protection Settings ( vpool , db Client ) , Virtual Pool . get File Remote Protection Settings ( vpool , db Client ) , db Client , coordinator , matcher Group Name , error Message ) ; update Invalid And Matched Pools For Vpool ( vpool , filter Pools , pools , db Client ) ; }
private static int [ ] trim Array ( int [ ] array , int size ) { if ( size < NUM ) { throw new Illegal Argument Exception ( ) ; } if ( size == NUM ) { return NO ERRORS ; } int [ ] a = new int [ size ] ; System . arraycopy ( array , NUM , a , NUM , size ) ; return a ; }
static < T > boolean remove If ( Iterable < T > remove From , Predicate < ? super T > predicate ) { if ( remove From instanceof Random Access && remove From instanceof List ) { return remove If From Random Access List ( ( List < T > ) remove From , check Not Null ( predicate ) ) ; } return Iterators . remove If ( remove From . iterator ( ) , predicate ) ; }
@ Before Class public static void create Ecom Connection ( ) { boolean was Exception = BOOL ; try { connection = new Ecom Connection ( create Connection Info ( ) , create Listener ( ) , new Cim Filter Map ( ) ) ; } catch ( Exception e ) { was Exception = BOOL ; } Assert . assert False ( was Exception ) ; }
protected void init ( final I Datatype URI Resolver resolver , final I Lexicon Configuration < Bigdata Value > config , final Collection < I Extension < ? extends Bigdata Value > > extensions ) { }
public mx Rectangle graph Model Changed ( mx I Graph Model sender , List < mx Undoable Change > changes , Boolean rv ) { int thresh = get Changes Repaint Threshold ( ) ; boolean ignore Dirty = thresh > NUM && changes . size ( ) > thresh ; if ( ! ignore Dirty ) { Iterator < mx Undoable Change > it = changes . iterator ( ) ; while ( it . has Next ( ) ) { if ( it . next ( ) instanceof mx Root Change ) { ignore Dirty = BOOL ; break ; } } } Array List < Object > changed Cells = new Array List < Object > ( ) ; mx Rectangle dirty = process Changes ( changes , BOOL , ignore Dirty , changed Cells ) ; if ( ! rv ) { if ( changed Cells != null ) { for ( Object changed Cell : changed Cells ) { mx Cell State parent State = view . get State ( model . get Parent ( changed Cell ) , BOOL ) ; view . validate ( parent State , changed Cell , BOOL ) ; } } } else view . validate ( ) ; if ( ! ignore Dirty ) { mx Rectangle tmp = process Changes ( changes , BOOL , ignore Dirty ) ; if ( tmp != null ) { if ( dirty == null ) { dirty = tmp ; } else { dirty . add ( tmp ) ; } } } remove Selection Cells ( get Removed Cells For Changes ( changes ) ) ; return dirty ; }
public void test Set Bit Exception ( ) { byte a Bytes [ ] = { - NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = NUM ; int number = - NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; try { a Number . set Bit ( number ) ; fail ( STRING ) ; } catch ( Arithmetic Exception e ) { } }
public void guard ( final Guard r ) throws Interrupted Exception { inc Thread ( ) ; try { r . run ( ) ; } catch ( Interrupted Exception e ) { throw e ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } finally { dec Thread ( ) ; } }
public void log ( Date time , String message ) { try { Print Writer w = new Print Writer ( new File Writer ( filename , BOOL ) ) ; w . println ( STRING + format . format ( time ) + STRING + message ) ; w . close ( ) ; } catch ( IO Exception e ) { } }
protected Resource Info new Element ( int type ) { Resource Info result = null ; switch ( type ) { case I Resource . FILE : case I Resource . FOLDER : result = new Resource Info ( type ) ; break ; case I Resource . PROJECT : result = new Resource Info ( type ) ; break ; case I Resource . ROOT : result = new Resource Info ( type ) ; break ; } return result ; }
private boolean is Model Useful ( Contingency Matrix cm ) { return BOOL ; }
public void register Player Observer ( Player Events Observer observer , boolean reply Immediately ) { if ( this . connection == null ) return ; player Events Observers . add ( observer ) ; if ( reply Immediately ) reply With Last Result ( observer ) ; if ( player Events Observers . size ( ) == NUM ) { if ( connection . get Protocol ( ) == Host Connection . PROTOCOL TCP ) { connection . register Player Notifications Observer ( this , checker Handler ) ; connection . register System Notifications Observer ( this , checker Handler ) ; connection . register Input Notifications Observer ( this , checker Handler ) ; checker Handler . post ( tcp Checker Runnable ) ; } else { checker Handler . post ( http Checker Runnable ) ; } } }
@ Override public int num Elements ( ) throws Exception { if ( m zero R != null ) { return NUM ; } return m Tree . num Nodes ( ) ; }
public boolean is Highlightable ( OM Graphic omg ) { return BOOL ; }
public void test Virtual Destinations Dinamically Included Behavior 3 ( ) throws Exception { final String topic = STRING ; final String vq = STRING + topic ; start All Brokers ( ) ; final int msgs 1 = NUM ; final int msgs 2 = NUM ; Destination t Dest = create Destination ( topic , BOOL ) ; Destination vq Dest = create Destination ( vq , BOOL ) ; Message Consumer client B 1 t = create Consumer ( STRING , t Dest ) ; Message Consumer client B 2 t = create Consumer ( STRING , t Dest ) ; Message Consumer client B 1 vq = create Consumer ( STRING , vq Dest ) ; Thread . sleep ( NUM * NUM ) ; send Messages ( STRING , t Dest , msgs 1 ) ; send Messages ( STRING , t Dest , msgs 2 ) ; Thread . sleep ( NUM ) ; Message Id List msgs B 1 t = get Consumer Messages ( STRING , client B 1 t ) ; msgs B 1 t . wait For Messages To Arrive ( msgs 1 + msgs 2 ) ; assert Equals ( msgs 1 + msgs 2 , msgs B 1 t . get Message Count ( ) ) ; Message Id List msgs B 2 t = get Consumer Messages ( STRING , client B 2 t ) ; msgs B 2 t . wait For Messages To Arrive ( msgs 1 + msgs 2 ) ; assert Equals ( msgs 1 + msgs 2 , msgs B 2 t . get Message Count ( ) ) ; Message Id List msgs B 1 vq = get Consumer Messages ( STRING , client B 1 vq ) ; msgs B 1 vq . wait For Messages To Arrive ( msgs 1 + msgs 2 ) ; assert Equals ( msgs 1 + msgs 2 , msgs B 1 vq . get Message Count ( ) ) ; assert Equals ( NUM , get Queue Size ( STRING , ( Active MQ Destination ) vq Dest ) ) ; assert Equals ( NUM , get Queue Size ( STRING , ( Active MQ Destination ) vq Dest ) ) ; destroy All Brokers ( ) ; }
public Rpc Client peer With ( Peer Info server Info , Bootstrap bootstrap , Map < String , Object > attributes ) throws IO Exception { Inet Socket Address remote Address = new Inet Socket Address ( server Info . get Host Name ( ) , server Info . get Port ( ) ) ; return peer With ( remote Address , bootstrap , attributes ) ; }
public Grid Reversed Lines File Reader ( final File file , final int block Size , final String encoding ) throws IO Exception { this ( file , block Size , Charset . for Name ( encoding ) ) ; }
private void before Name ( ) throws IO Exception { int context = peek ( ) ; if ( context == NONEMPTY OBJECT ) { out . write ( STRING ) ; } else if ( context != EMPTY OBJECT ) { throw new Illegal State Exception ( STRING ) ; } newline ( ) ; replace Top ( DANGLING NAME ) ; }
protected String const Name ( ) { return STRING + name . to Upper Case ( ) ; }
public boolean is Timestamp Within Interval ( Date Time timestamp , String interval String ) throws Illegal Argument Exception { Interval interval = Interval . parse ( interval String ) ; return interval . contains ( timestamp ) ; }
private void process Ansi Os Command ( ) { if ( ansi Os Command . char At ( NUM ) != STRING || ansi Os Command . char At ( NUM ) != STRING ) { Logger . log ( STRING + ansi Os Command + STRING ) ; return ; } }
private void add To Renaming ( Renaming renaming , Hash Set < String > prev Declared , Expr Node expr ) { if ( ! ( expr instanceof Op Appl Node ) ) { return ; } Hash Set < String > new Declared = ( Hash Set < String > ) prev Declared . clone ( ) ; Op Appl Node node = ( Op Appl Node ) expr ; if ( node . get Unbded Quant Symbols ( ) != null ) { for ( int i = NUM ; i < node . get Unbded Quant Symbols ( ) . length ; i ++ ) { Formal Param Node id = node . get Unbded Quant Symbols ( ) [ i ] ; if ( new Declared . contains ( get Current Name ( id , renaming ) ) ) { String newname = get New Name ( id , new Declared , renaming ) ; new Declared . add ( newname ) ; add Current Name ( id , newname , renaming ) ; } } } if ( node . get Bded Quant Symbol Lists ( ) != null ) { for ( int i = NUM ; i < node . get Bded Quant Symbol Lists ( ) . length ; i ++ ) { add To Renaming ( renaming , prev Declared , node . get Bded Quant Bounds ( ) [ i ] ) ; Formal Param Node [ ] node List = node . get Bded Quant Symbol Lists ( ) [ i ] ; for ( int j = NUM ; j < node List . length ; j ++ ) { Formal Param Node id = node List [ j ] ; if ( new Declared . contains ( get Current Name ( id , renaming ) ) ) { String newname = get New Name ( id , new Declared , renaming ) ; new Declared . add ( newname ) ; add Current Name ( id , newname , renaming ) ; } } } } for ( int i = NUM ; i < node . get Args ( ) . length ; i ++ ) { if ( node . get Args ( ) [ i ] instanceof Expr Node ) { add To Renaming ( renaming , new Declared , ( Expr Node ) node . get Args ( ) [ i ] ) ; } } }
private Linked List < Diff > diff line Mode ( String text 1 , String text 2 , long deadline ) { Lines To Chars Result b = diff lines To Chars ( text 1 , text 2 ) ; text 1 = b . chars 1 ; text 2 = b . chars 2 ; List < String > linearray = b . line Array ; Linked List < Diff > diffs = diff main ( text 1 , text 2 , BOOL , deadline ) ; diff chars To Lines ( diffs , linearray ) ; diff cleanup Semantic ( diffs ) ; diffs . add ( new Diff ( Operation . EQUAL , STRING ) ) ; int count delete = NUM ; int count insert = NUM ; String text delete = STRING ; String text insert = STRING ; List Iterator < Diff > pointer = diffs . list Iterator ( ) ; Diff this Diff = pointer . next ( ) ; while ( this Diff != null ) { switch ( this Diff . operation ) { case INSERT : count insert ++ ; text insert += this Diff . text ; break ; case DELETE : count delete ++ ; text delete += this Diff . text ; break ; case EQUAL : if ( count delete >= NUM && count insert >= NUM ) { pointer . previous ( ) ; for ( int j = NUM ; j < count delete + count insert ; j ++ ) { pointer . previous ( ) ; pointer . remove ( ) ; } for ( Diff new Diff : diff main ( text delete , text insert , BOOL , deadline ) ) { pointer . add ( new Diff ) ; } } count insert = NUM ; count delete = NUM ; text delete = STRING ; text insert = STRING ; break ; } this Diff = pointer . has Next ( ) ? pointer . next ( ) : null ; } diffs . remove Last ( ) ; return diffs ; }
public boolean remove Trigger Group To Never Delete ( String group ) { if ( group != null ) return trigger Groups To Never Delete . remove ( group ) ; return BOOL ; }
public void remove ( Rule rule ) { rules . remove ( rule ) ; }
private boolean upload All Track Points ( Fusiontables fusiontables , String table Id , Track track ) throws IO Exception { int number Of Points = track . get Number Of Points ( ) ; List < Location > locations = new Array List < Location > ( MAX POINTS PER UPLOAD ) ; Location last Valid Location = null ; boolean sent Start Marker = BOOL ; int read Count = NUM ; Location Iterator location Iterator = null ; try { location Iterator = my Tracks Provider Utils . get Track Point Location Iterator ( track Id , - NUM , BOOL , My Tracks Provider Utils . DEFAULT LOCATION FACTORY ) ; while ( location Iterator . has Next ( ) ) { Location location = location Iterator . next ( ) ; locations . add ( location ) ; if ( Location Utils . is Valid Location ( location ) ) { last Valid Location = location ; } if ( ! sent Start Marker && last Valid Location != null ) { String name = context . get String ( R . string . marker label start , track . get Name ( ) ) ; create New Point ( fusiontables , table Id , name , STRING , last Valid Location , MARKER TYPE START ) ; sent Start Marker = BOOL ; } read Count ++ ; if ( read Count % MAX POINTS PER UPLOAD == NUM ) { if ( ! prepare And Upload Points ( fusiontables , table Id , track , locations , BOOL ) ) { Log . d ( TAG , STRING ) ; return BOOL ; } update Progress ( read Count , number Of Points ) ; locations . clear ( ) ; } } if ( ! prepare And Upload Points ( fusiontables , table Id , track , locations , BOOL ) ) { Log . d ( TAG , STRING ) ; return BOOL ; } if ( last Valid Location != null ) { String name = context . get String ( R . string . marker label end , track . get Name ( ) ) ; Description Generator description Generator = new Description Generator Impl ( context ) ; String description = description Generator . generate Track Description ( track , null , null , BOOL ) ; create New Point ( fusiontables , table Id , name , description , last Valid Location , MARKER TYPE END ) ; } return BOOL ; } finally { if ( location Iterator != null ) { location Iterator . close ( ) ; } } }
@ Check Return Value @ Deprecated @ Nonnull public static String join ( @ Nonnull String [ ] s , @ Nonnull String delimiter ) { String Builder buffer = new String Builder ( ) ; for ( int i = NUM ; i < s . length ; i ++ ) { buffer . append ( s [ i ] ) ; if ( i < s . length - NUM ) { buffer . append ( delimiter ) ; } } return buffer . to String ( ) ; }
private void init Select Position ( int position ) { if ( m Select Mode == I Selectable . SELECT MODE SINGLE ) { if ( m Selected Position == I Selectable . INVALID POSITION ) { m Selected Position = position ; } } else if ( m Select Mode == I Selectable . SELECT MODE MULTI ) { if ( ! m Selected Positions . contains ( position ) ) m Selected Positions . add ( position ) ; } else { throw new Runtime Exception ( ) ; } }
@ Override public Path Impl scheme Walk ( String user Path , Map < String , Object > attributes , String file Path , int offset ) { if ( ! is Windows ( ) ) { return super . scheme Walk ( user Path , attributes , file Path , offset ) ; } String canonical Path ; if ( file Path . length ( ) < offset + NUM ) { return super . scheme Walk ( user Path , attributes , file Path , offset ) ; } char ch 1 = file Path . char At ( offset + NUM ) ; char ch 2 = file Path . char At ( offset ) ; if ( ( ch 2 == STRING || ch 2 == separator Char ) && ( ch 1 == STRING || ch 1 == separator Char ) ) return super . scheme Walk ( user Path , attributes , convert From Windows Path ( file Path . substring ( offset ) ) , NUM ) ; else return super . scheme Walk ( user Path , attributes , file Path , offset ) ; }
void init Properties ( String default Level , String default Filter , String default Formatter , String default Encoding ) { Log Manager manager = Log Manager . get Log Manager ( ) ; final String filter Name = manager . get Property ( prefix + STRING ) ; if ( filter Name != null ) { try { filter = ( Filter ) get Customize Instance ( filter Name ) ; } catch ( Exception e1 ) { print Invalid Prop Message ( STRING , filter Name , e1 ) ; filter = ( Filter ) get Default Instance ( default Filter ) ; } } else { filter = ( Filter ) get Default Instance ( default Filter ) ; } String level Name = manager . get Property ( prefix + STRING ) ; if ( level Name != null ) { try { level = Level . parse ( level Name ) ; } catch ( Exception e ) { print Invalid Prop Message ( STRING , level Name , e ) ; level = Level . parse ( default Level ) ; } } else { level = Level . parse ( default Level ) ; } final String formatter Name = manager . get Property ( prefix + STRING ) ; if ( formatter Name != null ) { try { formatter = ( Formatter ) get Customize Instance ( formatter Name ) ; } catch ( Exception e ) { print Invalid Prop Message ( STRING , formatter Name , e ) ; formatter = ( Formatter ) get Default Instance ( default Formatter ) ; } } else { formatter = ( Formatter ) get Default Instance ( default Formatter ) ; } final String encoding Name = manager . get Property ( prefix + STRING ) ; try { internal Set Encoding ( encoding Name ) ; } catch ( Unsupported Encoding Exception e ) { print Invalid Prop Message ( STRING , encoding Name , e ) ; } }
public static void write Unsigned VL ( long data , Data Output out ) throws IO Exception { while ( BOOL ) { if ( ( data & ~ NUM ) == NUM ) { out . write Byte ( ( int ) data ) ; return ; } else { out . write Byte ( ( ( int ) data & NUM ) | NUM ) ; data >>>= NUM ; } } }
public JSON Array names ( ) { JSON Array ja = new JSON Array ( ) ; Iterator keys = keys ( ) ; while ( keys . has Next ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == NUM ? null : ja ; }
public void add Table With Alias ( String table , String alias ) { Query Table Data table Data = new Query Table Data ( ) ; table Data . set Table Name ( table ) ; table Data . set Table Alias ( alias ) ; table Data . set Table Index ( tables Data . size ( ) ) ; tables Data . add ( table Data ) ; if ( alias == null ) tables . put ( table , table Data ) ; else { tables . put ( alias , table Data ) ; tables . put ( table , table Data ) ; } }
private int encrypt Block ( byte [ ] in , int in Off , byte [ ] out , int out Off ) throws Data Length Exception , Illegal State Exception { if ( ( in Off + block Size ) > in . length ) { throw new Data Length Exception ( STRING ) ; } for ( int i = NUM ; i < block Size ; i ++ ) { cbc V [ i ] ^= in [ in Off + i ] ; } int length = cipher . process Block ( cbc V , NUM , out , out Off ) ; System . arraycopy ( out , out Off , cbc V , NUM , cbc V . length ) ; return length ; }
private void render Axes ( Camera camera ) { gl Push Matrix ( ) ; gl Load Identity ( ) ; float rot X = camera . get Rotation ( ) . x ; float rot Y = camera . get Rotation ( ) . y ; float rot Z = NUM ; gl Rotatef ( rot X , NUM , NUM , NUM ) ; gl Rotatef ( rot Y , NUM , NUM , NUM ) ; gl Rotatef ( rot Z , NUM , NUM , NUM ) ; gl Line Width ( NUM ) ; gl Begin ( GL LINES ) ; gl Color 3 f ( NUM , NUM , NUM ) ; gl Vertex 3 f ( NUM , NUM , NUM ) ; gl Vertex 3 f ( NUM , NUM , NUM ) ; gl Color 3 f ( NUM , NUM , NUM ) ; gl Vertex 3 f ( NUM , NUM , NUM ) ; gl Vertex 3 f ( NUM , NUM , NUM ) ; gl Color 3 f ( NUM , NUM , NUM ) ; gl Vertex 3 f ( NUM , NUM , NUM ) ; gl Vertex 3 f ( NUM , NUM , NUM ) ; gl End ( ) ; gl Pop Matrix ( ) ; }
@ Override public Object clone ( ) throws Clone Not Supported Exception { Period Axis Label Info clone = ( Period Axis Label Info ) super . clone ( ) ; return clone ; }
public long skip ( long n ) throws IO Exception { if ( n < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } ensure Open ( ) ; int max = ( int ) Math . min ( n , Integer . MAX VALUE ) ; int total = NUM ; while ( total < max ) { int len = max - total ; if ( len > tmpbuf . length ) { len = tmpbuf . length ; } len = read ( tmpbuf , NUM , len ) ; if ( len == - NUM ) { entry EOF = BOOL ; break ; } total += len ; } return total ; }
private Path convert Path ( Path path ) throws Exception { if ( mode != PROXY ) return path ; else { URI secondary Uri = new URI ( SECONDARY URI ) ; URI path Uri = path . to Uri ( ) ; return new Path ( new URI ( path Uri . get Scheme ( ) != null ? secondary Uri . get Scheme ( ) : null , path Uri . get Authority ( ) != null ? secondary Uri . get Authority ( ) : null , path Uri . get Path ( ) , null , null ) ) ; } }
private static String join Array ( String [ ] array , String delimiter ) { String Buffer buffer = new String Buffer ( ) ; for ( int index = NUM ; index < array . length ; index ++ ) { buffer . append ( array [ index ] ) ; if ( index < array . length - NUM ) { buffer . append ( delimiter ) ; } } return buffer . to String ( ) ; }
private void output Partners ( Properties ctx , Print Writer out , int partner ID , boolean include Any ) { out . println ( STRING ) ; if ( include Any ) { out . println ( STRING ) ; if ( partner ID == NUM ) out . println ( STRING ) ; out . println ( STRING ) ; } for ( MB Partner partner : get All Partners ( ctx ) ) { out . print ( STRING + partner . get ID ( ) + STRING ) ; if ( partner ID == partner . get ID ( ) ) out . print ( STRING ) ; out . println ( STRING + Util . mask HTML ( partner . get Name ( ) ) + STRING ) ; } out . println ( STRING ) ; }
public void stop ( ) { m Cancel = BOOL ; if ( m Running . compare And Set ( BOOL , BOOL ) ) { if ( m Sample Dispatcher Task != null ) { m Sample Dispatcher Task . cancel ( BOOL ) ; m Filled Buffers . clear ( ) ; } } }
public Chess Square ( Composite parent , Chess Board chess Board , int id , boolean is Light ) { super ( parent , SWT . DOUBLE BUFFERED | SWT . NO BACKGROUND ) ; board = chess Board ; this . id = id ; this . is Light = is Light ; add Paint Listener ( paint Listener ) ; add Control Listener ( control Listener ) ; add Mouse Listener ( mouse Listener ) ; add Listener ( SWT . Mouse Wheel , mouse Wheel Listener ) ; add Listener ( SWT . Mouse Down , dnd Listener ) ; add Listener ( SWT . Mouse Up , dnd Listener ) ; }
@ Override protected void stop Service ( ) { Thread t = keep Alive Thread ; keep Alive Thread = null ; if ( t != null ) { t . interrupt ( ) ; } }
public static int truncated Compare To ( final Calendar cal 1 , final Calendar cal 2 , final int field ) { final Calendar truncated Cal 1 = truncate ( cal 1 , field ) ; final Calendar truncated Cal 2 = truncate ( cal 2 , field ) ; return truncated Cal 1 . compare To ( truncated Cal 2 ) ; }
public boolean is Port Usable ( Storage Port storage Port ) { return is Port Usable ( storage Port , BOOL ) ; }
public boolean is Expired ( ) { return this . ttl < System . current Time Millis ( ) ; }
@ Override public void action Performed ( Action Event event ) { String command = event . get Action Command ( ) ; if ( command . equals ( STRING ) ) { attempt Font Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Paint Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Modify Show Title ( ) ; } }
void remove Attribute Values ( String attr Name , Set values ) throws SMS Exception { if ( attr Name != null ) { Map attrs = get Attributes ( ) ; Set orig Values = ( Set ) attrs . get ( attr Name ) ; if ( orig Values != null && ! orig Values . is Empty ( ) ) { Set new Values = new Hash Set ( orig Values ) ; new Values . remove All ( values ) ; if ( new Values . is Empty ( ) ) { remove Attribute ( attr Name ) ; } else { Map new Attrs = new Hash Map ( ) ; new Attrs . put ( attr Name , new Values ) ; set Attributes ( new Attrs ) ; } } } }
private static boolean check Content Characters ( String chars ) throws Char Conversion Exception { boolean escape = BOOL ; for ( int i = NUM ; i < chars . length ( ) ; i ++ ) { char ch = chars . char At ( i ) ; if ( ch <= NUM ) { switch ( ch ) { case NUM : case NUM : case NUM : continue ; case STRING : if ( escape ) { continue ; } escape = ( i > NUM ) && ( chars . char At ( i - NUM ) == STRING ) ; continue ; case STRING : case STRING : escape = BOOL ; continue ; default : if ( ch < NUM ) { throw new Char Conversion Exception ( STRING + ( ( int ) ch ) + STRING ) ; } } } } return escape == BOOL ; }
public void test Find App Deployments ( ) throws Exception { WAR war = create War ( ) ; test Config War ( ) ; List < Element > l = deployer . select App Deployments ( war , domain ) ; assert Equals ( NUM , l . size ( ) ) ; deployer . remove Deployable From Domain ( war , domain ) ; l = deployer . select App Deployments ( war , domain ) ; assert Equals ( NUM , l . size ( ) ) ; }
@ Override public void draw Top ( final Graphics 2 D g2 d ) { final Rectangle r = get Area ( ) ; if ( is Contained ( ) ) { r . set Location ( NUM , NUM ) ; } else { if ( ! is On Screen ( g2 d , r ) ) { return ; } } final Composite old Composite = g2 d . get Composite ( ) ; try { g2 d . set Composite ( entity Composite ) ; draw Top ( g2 d , r . x , r . y , r . width , r . height ) ; } finally { g2 d . set Composite ( old Composite ) ; } }
protected void init Debug ( ) { set Debug ( ( get Init Parameter ( STRING ) == null ) ? BOOL : Boolean . value Of ( get Init Parameter ( STRING ) ) ) ; }
protected void index Nulls ( Input Stream is , long ptr , List < Entry > entries ) { boolean more Records = BOOL ; byte r Hdr [ ] = new byte [ SHAPE RECORD HEADER LENGTH ] ; int result ; int n Records = NUM ; int rec Length Words , rec Length Bytes ; long rec Offset ; int rec Buf Size = NUM ; byte rec Buf [ ] = new byte [ rec Buf Size ] ; double x ; double y ; try { while ( more Records ) { result = is . read ( r Hdr , NUM , SHAPE RECORD HEADER LENGTH ) ; if ( result < NUM ) { more Records = BOOL ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + n Records + STRING ) ; logger . fine ( STRING + rec Buf Size ) ; } } else { n Records ++ ; rec Offset = ptr ; read BE Int ( r Hdr , NUM ) ; rec Length Words = read BE Int ( r Hdr , NUM ) ; rec Length Bytes = rec Length Words * NUM ; if ( rec Length Bytes > rec Buf Size ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + rec Length Bytes ) ; } rec Buf Size = rec Length Bytes ; rec Buf = new byte [ rec Buf Size ] ; } result = is . read ( rec Buf , NUM , rec Length Bytes ) ; x = NUM ; y = NUM ; ptr += rec Length Bytes + NUM ; Entry entry = new Entry ( x , y , x , y , ( int ) rec Offset ) ; entries . add ( entry ) ; } } } catch ( java . io . IO Exception e ) { e . print Stack Trace ( ) ; } finally { try { is . close ( ) ; } catch ( java . io . IO Exception e ) { } } }
protected static Rpc Pair resolve Rpc Pair ( AST Node node , Peer Type Resolver peer Resolver ) { Method Declaration method Decl = AST Resolving . find Parent Method Declaration ( node ) ; Type Declaration type Decl = ( Type Declaration ) AST Resolving . find Ancestor ( node , AST Node . TYPE DECLARATION ) ; assert ( type Decl != null ) ; I Type dst Type = peer Resolver . get Peer Type ( type Decl ) ; if ( dst Type == null ) { return null ; } Compilation Unit ast Root = AST Resolving . create Quick Fix AST ( dst Type . get Compilation Unit ( ) , null ) ; Type Declaration dst Type Decl = Java AST Utils . find Type Declaration ( ast Root , dst Type . get Fully Qualified Name ( STRING ) ) ; if ( dst Type Decl == null ) { return null ; } return new Rpc Pair ( type Decl , method Decl , dst Type Decl ) ; }
public static void assert Equals ( Field Matrix < ? extends Field Element < ? > > expected , Field Matrix < ? extends Field Element < ? > > observed ) { Assert . assert Not Null ( STRING , observed ) ; if ( expected . get Column Dimension ( ) != observed . get Column Dimension ( ) || expected . get Row Dimension ( ) != observed . get Row Dimension ( ) ) { String Builder message Buffer = new String Builder ( ) ; message Buffer . append ( STRING ) ; message Buffer . append ( STRING + observed . get Row Dimension ( ) + STRING + observed . get Column Dimension ( ) ) ; message Buffer . append ( STRING + expected . get Row Dimension ( ) + STRING + expected . get Column Dimension ( ) ) ; Assert . fail ( message Buffer . to String ( ) ) ; } for ( int i = NUM ; i < expected . get Row Dimension ( ) ; ++ i ) { for ( int j = NUM ; j < expected . get Column Dimension ( ) ; ++ j ) { Field Element < ? > eij = expected . get Entry ( i , j ) ; Field Element < ? > oij = observed . get Entry ( i , j ) ; Assert . assert Equals ( eij , oij ) ; } } }
public void add Addition ( String addition ) { additions . add ( addition ) ; }
private void start New Transition ( ) { if ( ! has Bounds ( ) ) { throw new Unsupported Operation Exception ( STRING + STRING ) ; } m Current Trans = m Trans Gen . generate Next Transition ( m Drawable Rect , m Viewport Rect ) ; m Elapsed Time = NUM ; m Last Frame Time = System . current Time Millis ( ) ; fire Transition Start ( m Current Trans ) ; }
protected void rotate Orthogonal ( ) { active . set Rotation ( active . get Rotation ( ) + NUM , this ) ; error . set Rotation ( error . get Rotation ( ) + NUM , this ) ; display State ( ) ; repaint ( ) ; }
private String convert To Element Name ( String attribute Name ) { return attribute Name . replace ( STRING , STRING ) ; }
private boolean has Other Map And Reduce Parent Node ( Lop tmp Node , Array List < Lop > node List , Lop node ) { if ( tmp Node . get Exec Location ( ) == Exec Location . Map And Reduce ) return BOOL ; for ( Lop n : tmp Node . get Outputs ( ) ) { if ( node List . contains ( n ) && is Child ( n , node , ID Map ) ) { if ( ! n . equals ( node ) && n . get Exec Location ( ) == Exec Location . Map And Reduce ) return BOOL ; else return has Other Map And Reduce Parent Node ( n , node List , node ) ; } } return BOOL ; }
public synchronized void add ( double value ) { add ( m Categories . size ( ) + STRING , value ) ; }
@ Nullable String find Longest Name Prefix ( Node name , Set < String > namespaces ) { if ( namespaces . contains ( name . get Qualified Name ( ) ) ) { return name . get Qualified Name ( ) ; } else if ( name . is Get Prop ( ) ) { return find Longest Name Prefix ( name . get First Child ( ) , namespaces ) ; } return null ; }
public static Log Writer create Log Writer ( final Properties properties ) { Properties non Default = properties ; if ( non Default == null ) { non Default = new Properties ( ) ; } Distributed Test Utils . add Hydra Properties ( non Default ) ; Distribution Config dc = new Distribution Config Impl ( non Default ) ; Log Writer logger = Log Writer Factory . create Log Writer Logger ( BOOL , BOOL , dc , BOOL ) ; non Default . put ( Distribution Config . LOG WRITER NAME , logger ) ; return logger ; }
public int session ( ) { return Integer . parse Int ( fields [ NUM ] ) ; }
public Reflective Property ( Class < T > property Holder , Class < V > value Type , String name ) { super ( value Type , name ) ; char first Letter = Character . to Upper Case ( name . char At ( NUM ) ) ; String the Rest = name . substring ( NUM ) ; String capitalized Name = first Letter + the Rest ; String getter Name = PREFIX GET + capitalized Name ; try { m Getter = property Holder . get Method ( getter Name , ( Class < ? > [ ] ) null ) ; } catch ( No Such Method Exception e ) { try { m Getter = property Holder . get Declared Method ( getter Name , ( Class < ? > [ ] ) null ) ; m Getter . set Accessible ( BOOL ) ; } catch ( No Such Method Exception e2 ) { getter Name = PREFIX IS + capitalized Name ; try { m Getter = property Holder . get Method ( getter Name , ( Class < ? > [ ] ) null ) ; } catch ( No Such Method Exception e3 ) { try { m Getter = property Holder . get Declared Method ( getter Name , ( Class < ? > [ ] ) null ) ; m Getter . set Accessible ( BOOL ) ; } catch ( No Such Method Exception e4 ) { try { m Field = property Holder . get Field ( name ) ; Class field Type = m Field . get Type ( ) ; if ( ! types Match ( value Type , field Type ) ) { throw new No Such Property Exception ( STRING + field Type + STRING + STRING + value Type + STRING ) ; } return ; } catch ( No Such Field Exception e5 ) { throw new No Such Property Exception ( STRING + STRING + name ) ; } } } } } Class getter Type = m Getter . get Return Type ( ) ; if ( ! types Match ( value Type , getter Type ) ) { throw new No Such Property Exception ( STRING + getter Type + STRING + STRING + value Type + STRING ) ; } String setter Name = PREFIX SET + capitalized Name ; try { m Setter = property Holder . get Declared Method ( setter Name , getter Type ) ; m Setter . set Accessible ( BOOL ) ; } catch ( No Such Method Exception ignored ) { } }
private void write Photo Overlay ( String name , String category , String description , String style Name , Location location , String photo Url , float heading ) { if ( location != null ) { print Writer . println ( STRING ) ; print Writer . println ( STRING + String Utils . format C Data ( name ) + STRING ) ; print Writer . println ( STRING + String Utils . format C Data ( description ) + STRING ) ; print Writer . print ( STRING ) ; print Writer . print ( STRING + location . get Longitude ( ) + STRING ) ; print Writer . print ( STRING + location . get Latitude ( ) + STRING ) ; print Writer . print ( STRING ) ; print Writer . print ( STRING + heading + STRING ) ; print Writer . print ( STRING ) ; print Writer . println ( STRING ) ; print Writer . println ( STRING + String Utils . format Date Time Iso 8601 ( location . get Time ( ) ) + STRING ) ; print Writer . println ( STRING + style Name + STRING ) ; write Category ( category ) ; if ( play Track ) { print Writer . println ( STRING + Uri . decode ( photo Url ) + STRING ) ; } else { Uri uri = Uri . parse ( photo Url ) ; print Writer . println ( STRING + Kmz Track Exporter . KMZ IMAGES DIR + File . separator Char + uri . get Last Path Segment ( ) + STRING ) ; } print Writer . print ( STRING ) ; print Writer . print ( STRING ) ; print Writer . print ( STRING ) ; print Writer . print ( STRING ) ; print Writer . print ( STRING ) ; print Writer . print ( STRING ) ; print Writer . println ( STRING ) ; print Writer . println ( STRING ) ; print Writer . println ( STRING + get Coordinates ( location , STRING ) + STRING ) ; print Writer . println ( STRING ) ; print Writer . println ( STRING ) ; } }
public boolean on Back Pressed ( ) { if ( does Drawer Exist ( ) ) { if ( m Drawer . is Drawer Visible ( Gravity . START ) ) { m Drawer . close Drawer ( Gravity . START ) ; return BOOL ; } } if ( m Content View . on Back Pressed ( ) ) return BOOL ; if ( ! m State Stack . empty ( ) ) { m State Stack . pop ( ) ; if ( ! m State Stack . empty ( ) ) { set State ( m State Stack . pop ( ) ) ; return BOOL ; } } return BOOL ; }
public void simulate Method ( Soot Method method , Reference Variable this Var , Reference Variable return Var , Reference Variable params [ ] ) { String sub Signature = method . get Sub Signature ( ) ; if ( sub Signature . equals ( STRING ) ) { java io Object Input Stream latest User Defined Loader ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java io Object Input Stream allocate New Object ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java io Object Input Stream allocate New Array ( method , this Var , return Var , params ) ; return ; } else { default Method ( method , this Var , return Var , params ) ; return ; } }
public Node Set DTM ( Node Iterator iterator , X Path Context xctxt ) { super ( ) ; Node node ; m manager = xctxt . get DTM Manager ( ) ; while ( null != ( node = iterator . next Node ( ) ) ) { int handle = xctxt . get DTM Handle From Node ( node ) ; add Node In Doc Order ( handle , xctxt ) ; } }
public Shard Iterator only Node Selector Active Initializing Shards It ( String node Attribute , Discovery Nodes discovery Nodes ) { Array List < Shard Routing > ordered = new Array List < > ( active Shards . size ( ) + all Initializing Shards . size ( ) ) ; Set < String > selected Nodes = Sets . new Hash Set ( discovery Nodes . resolve Nodes Ids ( node Attribute ) ) ; for ( Shard Routing shard Routing : active Shards ) { if ( selected Nodes . contains ( shard Routing . current Node Id ( ) ) ) { ordered . add ( shard Routing ) ; } } for ( Shard Routing shard Routing : all Initializing Shards ) { if ( selected Nodes . contains ( shard Routing . current Node Id ( ) ) ) { ordered . add ( shard Routing ) ; } } if ( ordered . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING + node Attribute + STRING ) ; } return new Plain Shard Iterator ( shard Id , ordered ) ; }
private void check Changes ( ) { settings . clear Movie Nfo Filenames ( ) ; if ( cb Movie Nfo Filename 1 . is Selected ( ) ) { settings . add Movie Nfo Filename ( Movie Nfo Naming . FILENAME NFO ) ; } if ( cb Movie Nfo Filename 2 . is Selected ( ) ) { settings . add Movie Nfo Filename ( Movie Nfo Naming . MOVIE NFO ) ; } if ( cb Movie Nfo Filename 3 . is Selected ( ) ) { settings . add Movie Nfo Filename ( Movie Nfo Naming . DISC NFO ) ; } Certification Style Wrapper wrapper = ( Certification Style Wrapper ) cb Certification Style . get Selected Item ( ) ; if ( wrapper != null && settings . get Movie Certification Style ( ) != wrapper . style ) { settings . set Movie Certification Style ( wrapper . style ) ; } }
X Menu Item Peer [ ] copy Items ( ) { synchronized ( get Menu Tree Lock ( ) ) { return ( X Menu Item Peer [ ] ) items . to Array ( new X Menu Item Peer [ ] { } ) ; } }
public byte receive One Byte ( ) { Log . d ( TAG , STRING ) ; try { acquire Lock ( ) ; m Server Socket . receive ( m Receive Packet ) ; Log . d ( TAG , STRING + ( NUM + m Receive Packet . get Data ( ) [ NUM ] ) ) ; return m Receive Packet . get Data ( ) [ NUM ] ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } return Byte . MIN VALUE ; }
public static void connection Closed ( ) { num Connections . get And Decrement ( ) ; }
public static String build Chat SDP ( String ip Address , int local Port , String protocol , String accept Types , String wrapper Types , String setup , String path , String direction ) { return build SDP ( ip Address , local Port , protocol , accept Types , wrapper Types , null , null , null , setup , path , direction , null , NUM ) ; }
int [ ] determine Dimensions ( int source Code Words , int error Correction Code Words ) throws Writer Exception { float ratio = NUM ; int [ ] dimension = null ; for ( int cols = min Cols ; cols <= max Cols ; cols ++ ) { int rows = calculate Number Of Rows ( source Code Words , error Correction Code Words , cols ) ; if ( rows < min Rows ) { break ; } if ( rows > max Rows ) { continue ; } float new Ratio = ( ( NUM * cols + NUM ) * DEFAULT MODULE WIDTH ) / ( rows * HEIGHT ) ; if ( dimension != null && Math . abs ( new Ratio - PREFERRED RATIO ) > Math . abs ( ratio - PREFERRED RATIO ) ) { continue ; } ratio = new Ratio ; dimension = new int [ ] { cols , rows } ; } if ( dimension == null ) { int rows = calculate Number Of Rows ( source Code Words , error Correction Code Words , min Cols ) ; if ( rows < min Rows ) { dimension = new int [ ] { min Cols , min Rows } ; } } if ( dimension == null ) { throw new Writer Exception ( STRING ) ; } return dimension ; }
private static void s ucumm ( Sparse Block a , double [ ] agg , double [ ] c , int m , int n , int rl , int ru ) { double [ ] cprod = ( agg != null ) ? agg : new double [ n ] ; if ( agg == null ) Arrays . fill ( cprod , NUM ) ; int [ ] cnt = new int [ n ] ; for ( int i = rl , ix = rl * n ; i < ru ; i ++ , ix += n ) { if ( ! a . is Empty ( i ) ) { int apos = a . pos ( i ) ; int alen = a . size ( i ) ; int [ ] aix = a . indexes ( i ) ; double [ ] avals = a . values ( i ) ; product Agg ( avals , cprod , aix , apos , NUM , alen ) ; count Agg ( avals , cnt , aix , apos , alen ) ; } for ( int j = NUM ; j < n ; j ++ ) if ( cnt [ j ] < i + NUM ) cprod [ j ] *= NUM ; System . arraycopy ( cprod , NUM , c , ix , n ) ; } }
public static Data Display Table list Font Metrics ( Font font ) { String [ ] header = { STRING , STRING } ; Align [ ] display Alignment = { Align . Left , Align . Left } ; Data Display Table table = new Data Display Table ( Arrays . as List ( header ) ) ; table . set Alignment ( Arrays . as List ( display Alignment ) ) ; Font Header Table head Table = ( Font Header Table ) Font Utils . get Table ( font , Tag . head ) ; Horizontal Header Table hhea Table = ( Horizontal Header Table ) Font Utils . get Table ( font , Tag . hhea ) ; OS 2 Table os 2 Table = ( OS 2 Table ) Font Utils . get Table ( font , Tag . OS 2 ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , head Table . units Per Em ( ) ) } ) ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , head Table . x Min ( ) , head Table . x Max ( ) ) } ) ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , head Table . y Min ( ) , head Table . y Max ( ) ) } ) ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , head Table . lowest Rec PPEM ( ) ) } ) ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , hhea Table . ascender ( ) ) } ) ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , hhea Table . descender ( ) ) } ) ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , hhea Table . line Gap ( ) ) } ) ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , os 2 Table . us Win Ascent ( ) ) } ) ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , os 2 Table . us Win Descent ( ) ) } ) ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , os 2 Table . s Typo Ascender ( ) ) } ) ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , os 2 Table . s Typo Descender ( ) ) } ) ) ; table . add ( Arrays . as List ( new String [ ] { STRING , String . format ( STRING , os 2 Table . s Typo Line Gap ( ) ) } ) ) ; return table ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static Shopping Cart Item make Item ( Integer cart Location , String item Type , String item Description , String product Category Id , Big Decimal base Price , Big Decimal selected Amount , Big Decimal quantity , Map < String , Object > attributes , String prod Catalog Id , Shopping Cart . Shopping Cart Item Group item Group , Local Dispatcher dispatcher , Shopping Cart cart , Boolean trigger External Ops Bool ) throws Cart Item Modify Exception { Delegator delegator = cart . get Delegator ( ) ; Shopping Cart Item new Item = new Shopping Cart Item ( delegator , item Type , item Description , product Category Id , base Price , attributes , prod Catalog Id , cart . get Locale ( ) , item Group ) ; if ( cart Location == null ) { cart . add Item To End ( new Item ) ; } else { cart . add Item ( cart Location . int Value ( ) , new Item ) ; } boolean trigger External Ops = trigger External Ops Bool == null ? BOOL : trigger External Ops Bool . boolean Value ( ) ; try { new Item . set Quantity ( quantity , dispatcher , cart , trigger External Ops ) ; } catch ( Cart Item Modify Exception e ) { cart . remove Empty Cart Items ( ) ; throw e ; } if ( selected Amount != null ) { new Item . set Selected Amount ( selected Amount ) ; } return new Item ; }
private native synchronized static void hook Method Native ( Member method , Class < ? > declaring Class , int slot , Object additional Info ) ;
final void run Worker ( Worker w ) { Runnable task = w . first Task ; w . first Task = null ; boolean completed Abruptly = BOOL ; try { while ( task != null || ( task = get Task ( ) ) != null ) { w . lock ( ) ; clear Interrupts For Task Run ( ) ; try { before Execute ( w . thread , task ) ; Throwable thrown = null ; try { task . run ( ) ; } catch ( Runtime Exception x ) { thrown = x ; throw x ; } catch ( Error x ) { thrown = x ; throw x ; } catch ( Throwable x ) { thrown = x ; throw new Error ( x ) ; } finally { after Execute ( task , thrown ) ; } } finally { task = null ; w . completed Tasks ++ ; w . unlock ( ) ; } } completed Abruptly = BOOL ; } finally { process Worker Exit ( w , completed Abruptly ) ; } }
private static Cluster Properties from Properties ( Properties props ) { Cluster Properties prop = new Cluster Properties ( ) ; prop . cluster Name = get String Property ( IGNITE CLUSTER NAME , props , DEFAULT CLUSTER NAME ) ; prop . cpu Per Node = get Double Property ( IGNITE RUN CPU PER NODE , props , DEFAULT CPU PER NODE ) ; prop . mem Per Node = get Double Property ( IGNITE MEMORY PER NODE , props , DEFAULT MEM PER NODE ) ; prop . mem Over Head Per Node = get Double Property ( IGNITE MEMORY OVERHEAD PER NODE , props , Math . max ( NUM * prop . mem Per Node , DEFAULT MINIMUM MEM OVERHEAD PER NODE ) ) ; prop . node Cnt = get Double Property ( IGNITE NODE COUNT , props , DEFAULT IGNITE NODE COUNT ) ; prop . ignite Url = get String Property ( IGNITE URL , props , null ) ; prop . ignite Path = get String Property ( IGNITE PATH , props , null ) ; prop . licence Path = get String Property ( LICENCE PATH , props , null ) ; prop . jvm Opts = get String Property ( IGNITE JVM OPTS , props , null ) ; prop . ignite Work Dir = get String Property ( IGNITE WORKING DIR , props , DEFAULT IGNITE WORK DIR ) ; prop . ignite Local Work Dir = get String Property ( IGNITE LOCAL WORK DIR , props , DEFAULT IGNITE LOCAL WORK DIR ) ; prop . ignite Releases Dir = get String Property ( IGNITE RELEASES DIR , props , DEFAULT IGNITE RELEASES DIR ) ; prop . ignite Cfg = get String Property ( IGNITE CONFIG XML , props , null ) ; prop . user Libs = get String Property ( IGNITE USERS LIBS , props , null ) ; String pattern = get String Property ( IGNITE HOSTNAME CONSTRAINT , props , null ) ; if ( pattern != null ) { try { prop . hostname Constraint = Pattern . compile ( pattern ) ; } catch ( Pattern Syntax Exception e ) { log . log ( Level . WARNING , STRING , e ) ; } } return prop ; }
public static String generate Native Guid ( Storage System device ) { return String . format ( STRING , device Type Map . get ( device . get System Type ( ) ) , device . get Serial Number ( ) ) ; }
public Cache Metrics Snapshot ( Cache Metrics loc , Collection < Cache Metrics > metrics ) { cache Name = loc . name ( ) ; is Empty = loc . is Empty ( ) ; is Write Behind Enabled = loc . is Write Behind Enabled ( ) ; write Behind Flush Size = loc . get Write Behind Flush Size ( ) ; write Behind Flush Thread Cnt = loc . get Write Behind Flush Thread Count ( ) ; write Behind Flush Freq = loc . get Write Behind Flush Frequency ( ) ; write Behind Store Batch Size = loc . get Write Behind Store Batch Size ( ) ; write Behind Buf Size = loc . get Write Behind Buffer Size ( ) ; size = loc . get Size ( ) ; key Size = loc . get Key Size ( ) ; key Type = loc . get Key Type ( ) ; val Type = loc . get Value Type ( ) ; is Store By Val = loc . is Store By Value ( ) ; is Statistics Enabled = loc . is Statistics Enabled ( ) ; is Management Enabled = loc . is Management Enabled ( ) ; is Read Through = loc . is Read Through ( ) ; is Write Through = loc . is Write Through ( ) ; off Heap Max Size = loc . get Off Heap Max Size ( ) ; for ( Cache Metrics e : metrics ) { reads += e . get Cache Gets ( ) ; puts += e . get Cache Puts ( ) ; hits += e . get Cache Hits ( ) ; misses += e . get Cache Misses ( ) ; tx Commits += e . get Cache Tx Commits ( ) ; tx Rollbacks += e . get Cache Tx Rollbacks ( ) ; evicts += e . get Cache Evictions ( ) ; removes += e . get Cache Removals ( ) ; put Avg Time Nanos += e . get Average Put Time ( ) ; get Avg Time Nanos += e . get Average Get Time ( ) ; rmv Avg Time Nanos += e . get Average Remove Time ( ) ; commit Avg Time Nanos += e . get Average Tx Commit Time ( ) ; rollback Avg Time Nanos += e . get Average Tx Rollback Time ( ) ; if ( e . get Overflow Size ( ) > - NUM ) overflow Size += e . get Overflow Size ( ) ; else overflow Size = - NUM ; off Heap Gets += e . get Off Heap Gets ( ) ; off Heap Puts += e . get Off Heap Puts ( ) ; off Heap Removes += e . get Off Heap Removals ( ) ; off Heap Evicts += e . get Off Heap Evictions ( ) ; off Heap Hits += e . get Off Heap Hits ( ) ; off Heap Misses += e . get Off Heap Misses ( ) ; off Heap Entries Cnt += e . get Off Heap Entries Count ( ) ; off Heap Primary Entries Cnt += e . get Off Heap Primary Entries Count ( ) ; off Heap Backup Entries Cnt += e . get Off Heap Backup Entries Count ( ) ; off Heap Allocated Size += e . get Off Heap Allocated Size ( ) ; swap Gets += e . get Swap Gets ( ) ; swap Puts += e . get Swap Puts ( ) ; swap Removes += e . get Swap Removals ( ) ; swap Hits += e . get Swap Hits ( ) ; swap Misses += e . get Swap Misses ( ) ; swap Entries Cnt += e . get Swap Entries Count ( ) ; swap Size += e . get Swap Size ( ) ; if ( e . get Dht Evict Queue Current Size ( ) > - NUM ) dht Evict Queue Curr Size += e . get Dht Evict Queue Current Size ( ) ; else dht Evict Queue Curr Size = - NUM ; tx Thread Map Size += e . get Tx Thread Map Size ( ) ; tx Xid Map Size += e . get Tx Xid Map Size ( ) ; tx Commit Queue Size += e . get Tx Commit Queue Size ( ) ; tx Prepare Queue Size += e . get Tx Prepare Queue Size ( ) ; tx Start Ver Counts Size += e . get Tx Start Version Counts Size ( ) ; tx Committed Versions Size += e . get Tx Committed Versions Size ( ) ; tx Rolledback Versions Size += e . get Tx Rolledback Versions Size ( ) ; if ( e . get Tx Dht Thread Map Size ( ) > - NUM ) tx Dht Thread Map Size += e . get Tx Dht Thread Map Size ( ) ; else tx Dht Thread Map Size = - NUM ; if ( e . get Tx Dht Xid Map Size ( ) > - NUM ) tx Dht Xid Map Size += e . get Tx Dht Xid Map Size ( ) ; else tx Dht Xid Map Size = - NUM ; if ( e . get Tx Dht Commit Queue Size ( ) > - NUM ) tx Dht Commit Queue Size += e . get Tx Dht Commit Queue Size ( ) ; else tx Dht Commit Queue Size = - NUM ; if ( e . get Tx Dht Prepare Queue Size ( ) > - NUM ) tx Dht Prepare Queue Size += e . get Tx Dht Prepare Queue Size ( ) ; else tx Dht Prepare Queue Size = - NUM ; if ( e . get Tx Dht Start Version Counts Size ( ) > - NUM ) tx Dht Start Ver Counts Size += e . get Tx Dht Start Version Counts Size ( ) ; else tx Dht Start Ver Counts Size = - NUM ; if ( e . get Tx Dht Committed Versions Size ( ) > - NUM ) tx Dht Committed Versions Size += e . get Tx Dht Committed Versions Size ( ) ; else tx Dht Committed Versions Size = - NUM ; if ( e . get Tx Dht Rolledback Versions Size ( ) > - NUM ) tx Dht Rolledback Versions Size += e . get Tx Dht Rolledback Versions Size ( ) ; else tx Dht Rolledback Versions Size = - NUM ; if ( e . get Write Behind Total Critical Overflow Count ( ) > - NUM ) write Behind Total Critical Overflow Cnt += e . get Write Behind Total Critical Overflow Count ( ) ; else write Behind Total Critical Overflow Cnt = - NUM ; if ( e . get Write Behind Critical Overflow Count ( ) > - NUM ) write Behind Critical Overflow Cnt += e . get Write Behind Critical Overflow Count ( ) ; else write Behind Critical Overflow Cnt = - NUM ; if ( e . get Write Behind Error Retry Count ( ) > - NUM ) write Behind Error Retry Cnt += e . get Write Behind Error Retry Count ( ) ; else write Behind Error Retry Cnt = - NUM ; } int size = metrics . size ( ) ; if ( size > NUM ) { put Avg Time Nanos /= size ; get Avg Time Nanos /= size ; rmv Avg Time Nanos /= size ; commit Avg Time Nanos /= size ; rollback Avg Time Nanos /= size ; } }
private void add Reference ( final int source Position , final int reference Position ) { if ( src And Ref Positions == null ) { src And Ref Positions = new int [ NUM ] ; } if ( reference Count >= src And Ref Positions . length ) { int [ ] a = new int [ src And Ref Positions . length + NUM ] ; System . arraycopy ( src And Ref Positions , NUM , a , NUM , src And Ref Positions . length ) ; src And Ref Positions = a ; } src And Ref Positions [ reference Count ++ ] = source Position ; src And Ref Positions [ reference Count ++ ] = reference Position ; }
public void step 3 ( Map < String , String > file Name To Package Name , Map < String , List < Fun Def > > file Name To Functions ) throws Syntax Exception { for ( S Type Def s Type Def : type Def Set ) { if ( s Type Def instanceof S Class Def ) { List < S Type Def > circular Recorder = new Array List < > ( ) ; S Class Def parent = ( ( S Class Def ) s Type Def ) . parent ( ) ; while ( parent != null ) { circular Recorder . add ( parent ) ; if ( parent . equals ( s Type Def ) ) { err . Syntax Exception ( STRING + circular Recorder , Line Col . SYNTHETIC ) ; return ; } parent = parent . parent ( ) ; } circular Recorder . clear ( ) ; } else if ( s Type Def instanceof S Interface Def ) { S Interface Def i = ( S Interface Def ) s Type Def ; check Interface Circular Inheritance ( i , i . super Interfaces ( ) , new Array List < > ( ) ) ; } else { throw new Lt Bug ( STRING + s Type Def . get Class ( ) ) ; } } for ( S Type Def s Type Def : type Def Set ) { check Override All Methods ( s Type Def ) ; } for ( String file Name : map Of Statements . key Set ( ) ) { List < Import > imports = file Name To Import . get ( file Name ) ; String pkg = file Name To Package Name . get ( file Name ) ; List < Fun Def > function Defs = file Name To Functions . get ( file Name ) ; for ( Fun Def fun : function Defs ) { S Type Def type = get Type With Access ( fun . super Type , imports ) ; if ( ! ( type instanceof S Class Def || type instanceof S Interface Def ) ) { err . Syntax Exception ( STRING , fun . super Type . line col ( ) ) ; return ; } S Constructor Def [ ] zero Param Constructor = new S Constructor Def [ NUM ] ; S Method Def [ ] method To Override = new S Method Def [ NUM ] ; if ( ! get Method For Lambda ( type , zero Param Constructor , method To Override ) ) { err . Syntax Exception ( STRING , fun . super Type . line col ( ) ) ; return ; } S Class Def s Class Def = ( S Class Def ) types . get ( pkg + fun . name ) ; parse Annos ( fun . annos , s Class Def , imports , Element Type . TYPE , Arrays . as List ( Element Type . METHOD , Element Type . CONSTRUCTOR ) ) ; if ( zero Param Constructor [ NUM ] == null ) { s Class Def . set Parent ( get Object Class ( ) ) ; assert type instanceof S Interface Def ; s Class Def . super Interfaces ( ) . add ( ( S Interface Def ) type ) ; } else { s Class Def . set Parent ( ( S Class Def ) zero Param Constructor [ NUM ] . declaring Type ( ) ) ; } S Constructor Def cons = new S Constructor Def ( Line Col . SYNTHETIC ) ; parse Annos ( fun . annos , cons , imports , Element Type . CONSTRUCTOR , Arrays . as List ( Element Type . TYPE , Element Type . METHOD ) ) ; cons . set Declaring Type ( s Class Def ) ; s Class Def . constructors ( ) . add ( cons ) ; if ( zero Param Constructor [ NUM ] == null ) { zero Param Constructor [ NUM ] = get Object Class ( ) . constructors ( ) . get ( NUM ) ; } cons . statements ( ) . add ( new Ins . Invoke Special ( new Ins . This ( s Class Def ) , zero Param Constructor [ NUM ] , Line Col . SYNTHETIC ) ) ; cons . modifiers ( ) . add ( S Modifier . PUBLIC ) ; S Method Def method = new S Method Def ( Line Col . SYNTHETIC ) ; method . set Declaring Type ( s Class Def ) ; method . set Return Type ( get Real Return Type ( method To Override [ NUM ] . get Return Type ( ) , BOOL ) ) ; method . set Name ( method To Override [ NUM ] . name ( ) ) ; s Class Def . methods ( ) . add ( method ) ; parse Annos ( fun . annos , method , imports , Element Type . METHOD , Arrays . as List ( Element Type . TYPE , Element Type . CONSTRUCTOR ) ) ; method . modifiers ( ) . add ( S Modifier . PUBLIC ) ; parse Parameters ( fun . params , fun . params . size ( ) , method , imports , BOOL ) ; method To Statements . put ( method , fun . statements ) ; check Override All Methods ( s Class Def ) ; } } for ( S Type Def type Def : type Def Set ) { for ( S Anno anno : type Def . annos ( ) ) { if ( anno . type ( ) . full Name ( ) . equals ( STRING ) ) { final String msg = type Def + STRING ; if ( type Def instanceof S Interface Def ) { if ( ! get Method For Lambda ( type Def , new S Constructor Def [ NUM ] , new S Method Def [ NUM ] ) ) { err . Syntax Exception ( msg , type Def . line col ( ) ) ; return ; } } else { err . Syntax Exception ( msg , type Def . line col ( ) ) ; return ; } } else if ( anno . type ( ) . full Name ( ) . equals ( STRING ) ) { final String msg = type Def + STRING ; if ( type Def instanceof S Class Def ) { if ( ! get Method For Lambda ( type Def , new S Constructor Def [ NUM ] , new S Method Def [ NUM ] ) ) { err . Syntax Exception ( msg , type Def . line col ( ) ) ; return ; } } else { err . Syntax Exception ( msg , type Def . line col ( ) ) ; return ; } } } List < S Method Def > methods ; if ( type Def instanceof S Class Def ) methods = ( ( S Class Def ) type Def ) . methods ( ) ; else methods = ( ( S Interface Def ) type Def ) . methods ( ) ; for ( S Method Def method : methods ) { for ( S Anno anno : method . annos ( ) ) { if ( anno . type ( ) . full Name ( ) . equals ( STRING ) ) { if ( method . over Ride ( ) . is Empty ( ) ) { err . Syntax Exception ( method + STRING , method . line col ( ) ) ; return ; } } } } } for ( S Type Def type Def : type Def Set ) { if ( type Def instanceof S Class Def ) { S Class Def cls = ( S Class Def ) type Def ; if ( cls . is Data Class ( ) ) { fill Methods Into Data Class ( cls ) ; } } } }
public void remove All Update Listeners ( ) { if ( m Update Listeners == null ) { return ; } m Update Listeners . clear ( ) ; m Update Listeners = null ; }
public Vector 2 floor ( ) { x = ( float ) Math . floor ( x ) ; z = ( float ) Math . floor ( z ) ; return this ; }
public static Location create Location ( final String raw JSON ) throws Twitter Exception { try { final JSON Object json = new JSON Object ( raw JSON ) ; return location Constructor . new Instance ( json ) ; } catch ( final Instantiation Exception e ) { throw new Twitter Exception ( e ) ; } catch ( final Illegal Access Exception e ) { throw new Assertion Error ( e ) ; } catch ( final Invocation Target Exception e ) { throw new Twitter Exception ( e ) ; } catch ( final JSON Exception e ) { throw new Twitter Exception ( e ) ; } }
@ Override protected int calc Attack Value ( ) { int av = NUM ; if ( b Direct ) { av = Math . min ( av + ( to Hit . get Mo S ( ) / NUM ) , av * NUM ) ; } if ( b Glancing ) { av = ( int ) Math . floor ( av / NUM ) ; } av = ( int ) Math . floor ( get Bracketing Multiplier ( ) * av ) ; return av ; }
public void test write Immutable ( ) { final I Raw Store store = get Store ( ) ; try { final int len = NUM ; final byte [ ] expected 1 = new byte [ len ] ; r . next Bytes ( expected 1 ) ; final Byte Buffer tmp = Byte Buffer . wrap ( expected 1 ) ; final long addr 1 = store . write ( tmp ) ; assert Equals ( len , tmp . position ( ) ) ; assert Equals ( tmp . position ( ) , tmp . limit ( ) ) ; assert Equals ( expected 1 , store . read ( addr 1 ) ) ; final byte [ ] expected 2 = expected 1 . clone ( ) ; r . next Bytes ( expected 1 ) ; assert Equals ( expected 2 , store . read ( addr 1 ) ) ; } finally { store . destroy ( ) ; } }
@ Override public String query To Retrieve Data ( ) { String parameterized Query ; if ( query . contains ( STRING ) ) { parameterized Query = query . replace ( STRING , start Row + STRING ) ; } else { parameterized Query = query ; } return parameterized Query ; }
public String to String ( ) { String classname = Util . get Unqualified Name ( get Class ( ) ) ; return ( ref == null ) ? classname : classname + STRING + ref . remote To String ( ) + STRING ; }
private static void initialise ( ) { Hints hints = new Hints ( Hints . CRS , Default Geographic CRS . WGS 84 ) ; Position Factory position Factory = Geometry Factory Finder . get Position Factory ( hints ) ; Geometry Factory geometry Factory = Geometry Factory Finder . get Geometry Factory ( hints ) ; Primitive Factory primitive Factory = Geometry Factory Finder . get Primitive Factory ( hints ) ; Aggregate Factory aggregate Factory = Geometry Factory Finder . get Aggregate Factory ( hints ) ; wkt Parser = new WKT Parser ( geometry Factory , primitive Factory , position Factory , aggregate Factory ) ; wkt Type List . add ( new WKT Type ( WKT POINT , BOOL , NUM , STRING , BOOL ) ) ; wkt Type List . add ( new WKT Type ( WKT MULTIPOINT , BOOL , NUM , STRING , BOOL ) ) ; wkt Type List . add ( new WKT Type ( WKT LINESTRING , BOOL , NUM , STRING , BOOL ) ) ; wkt Type List . add ( new WKT Type ( STRING , BOOL , NUM , STRING , BOOL ) ) ; wkt Type List . add ( new WKT Type ( WKT MULTILINESTRING , BOOL , NUM , STRING , BOOL ) ) ; wkt Type List . add ( new WKT Type ( WKT POLYGON , BOOL , - NUM , STRING , BOOL ) ) ; wkt Type List . add ( new WKT Type ( WKT MULTIPOLYGON , BOOL , - NUM , STRING , BOOL , BOOL ) ) ; for ( WKT Type wky Type : wkt Type List ) { wkt Type Map . put ( wky Type . get Name ( ) , wky Type ) ; } }
public Instances prune To K ( Instances neighbours , double [ ] distances , int k ) { if ( neighbours == null || distances == null || neighbours . num Instances ( ) == NUM ) { return null ; } if ( k < NUM ) { k = NUM ; } int current K = NUM ; double current Dist ; for ( int i = NUM ; i < neighbours . num Instances ( ) ; i ++ ) { current K ++ ; current Dist = distances [ i ] ; if ( current K > k && current Dist != distances [ i - NUM ] ) { current K -- ; neighbours = new Instances ( neighbours , NUM , current K ) ; break ; } } return neighbours ; }
@ Override protected String do In Background ( String ... f url ) { int count ; Input Stream input = null ; Output Stream output = null ; try { URL url = new URL ( f url [ NUM ] ) ; URL Connection connection = url . open Connection ( ) ; connection . connect ( ) ; int length Of File = connection . get Content Length ( ) ; input = new Buffered Input Stream ( url . open Stream ( ) , NUM ) ; output = new File Output Stream ( f url [ NUM ] ) ; byte data [ ] = new byte [ NUM ] ; long total = NUM ; while ( ( count = input . read ( data ) ) != - NUM ) { total += count ; publish Progress ( Integer . to String ( ( int ) ( ( total * NUM ) / length Of File ) ) ) ; output . write ( data , NUM , count ) ; } output . flush ( ) ; } catch ( Exception e ) { Log . e ( STRING , e . get Message ( ) ) ; } finally { try { if ( output != null ) output . close ( ) ; } catch ( Exception e ) { Log . e ( STRING , e . get Message ( ) ) ; } try { if ( input != null ) input . close ( ) ; } catch ( Exception e ) { Log . e ( STRING , e . get Message ( ) ) ; } } return null ; }
public void error ( String msg ) { print ( STRING + msg , out . err ) ; }
public static void load Arm V 7 a Library ( Application Like application Like , String lib Name ) { if ( lib Name == null || lib Name . is Empty ( ) || application Like == null ) { throw new Tinker Runtime Exception ( STRING ) ; } if ( Tinker Application Helper . is Tinker Enable For Native Lib ( application Like ) ) { if ( Tinker Application Helper . load Library From Tinker ( application Like , STRING , lib Name ) ) { return ; } } System . load Library ( lib Name ) ; }
Atomic Sequence ( final long initial Value ) { UPDATER . lazy Set ( this , initial Value ) ; }
public void key Released ( Key Event e ) { if ( e . is Shift Down ( ) && e . get Key Code ( ) == NEXT THROTTLE KEY ) { request Focus For Next Frame ( ) ; } else if ( e . is Shift Down ( ) && e . get Key Code ( ) == PREV THROTTLE KEY ) { request Focus For Previous Frame ( ) ; } }
protected static Long convert String To Buckecting Long ( String string To Be Converted ) { if ( string To Be Converted == null || string To Be Converted . equals ( STRING ) ) { return null ; } byte [ ] byte String = string To Be Converted . get Bytes ( ) ; if ( byte String . length < NUM ) { byte [ ] new Byte String = new byte [ NUM ] ; for ( int i = NUM ; i < new Byte String . length ; i ++ ) { if ( i < byte String . length ) { new Byte String [ i ] = byte String [ i ] ; } else { new Byte String [ i ] = NUM ; } } byte String = new Byte String ; } Byte Buffer bb = Byte Buffer . wrap ( byte String ) ; long byte Method = bb . get Long ( ) ; byte Method = Math . abs ( byte Method ) ; return byte Method ; }
@ Override public void close Invoked ( ) { }
private void pending Event ( Event Reg reg , Service ID sid , Item item , int transition , boolean copy Item ) { if ( item != null && copy Item ) item = copy Item ( item ) ; new Notifies . add ( new Event Task ( reg , sid , item , transition ) ) ; }
public static void writeln ( String file Name , Object [ ] objects ) { if ( writer == null ) { create Writer ( file Name ) ; for ( Object obj : objects ) { writeln ( obj . to String ( ) ) ; } close Writer ( ) ; } }
protected double regression Prediction ( Instance transformed Instance , boolean [ ] selected Attributes , double [ ] coefficients ) throws Exception { double result = NUM ; int column = NUM ; for ( int j = NUM ; j < transformed Instance . num Attributes ( ) ; j ++ ) { if ( ( m Class Index != j ) && ( selected Attributes [ j ] ) ) { result += coefficients [ column ] * transformed Instance . value ( j ) ; column ++ ; } } result += coefficients [ column ] ; return result ; }
public QLF Document ( List < F > list , String docno , Map < String , String > extra Props ) { feature List = new Memory Local Feature List < F > ( list ) ; iterator = list . iterator ( ) ; if ( extra Props != null ) props . put All ( extra Props ) ; props . put ( STRING , docno ) ; }
@ Override protected Template Model invoke Generic Get ( Map key Map , Class clazz , String key ) throws Template Model Exception { Map map = ( Map ) object ; Object val = map . get ( key ) ; if ( val == null ) { if ( key . length ( ) == NUM ) { Character char Key = Character . value Of ( key . char At ( NUM ) ) ; val = map . get ( char Key ) ; if ( val == null && ! ( map . contains Key ( key ) || map . contains Key ( char Key ) ) ) { return UNKNOWN ; } } else if ( ! map . contains Key ( key ) ) { return UNKNOWN ; } } return wrap ( val ) ; }
public byte [ ] to Z Order Byte Array ( final Big Integer big Int ) { final int num Dimensions = datatype Config . get Num Dimensions ( ) ; final byte [ ] big Int As Byte Arr = big Int . to Byte Array ( ) ; final int padded Array Size = num Dimensions * BASE SIZE + NUM ; final byte [ ] big Int As Byte Arr Pad = new byte [ padded Array Size ] ; int idx = NUM ; for ( int i = NUM ; i < padded Array Size - big Int As Byte Arr . length ; i ++ ) { big Int As Byte Arr Pad [ idx ++ ] = NUM ; } for ( int i = NUM ; i < big Int As Byte Arr . length ; i ++ ) { big Int As Byte Arr Pad [ idx ++ ] = big Int As Byte Arr [ i ] ; } final byte [ ] big Int As Byte Arr Unsigned = unpad Leading Zero ( big Int As Byte Arr Pad ) ; return big Int As Byte Arr Unsigned ; }
public void clear Logcat ( @ Not Null I Device device , @ Not Null Project project ) { synchronized ( my Lock ) { Executor Service executor = my Executors . get ( device ) ; if ( executor != null ) { stop Receiving ( device ) ; executor . submit ( null ) ; start Receiving ( device ) ; } } }
public void expand ( int level ) { Array List < S2 Cell Id > output = new Array List < S2 Cell Id > ( ) ; long level Lsb = S2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM ; do { S2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM && id . contains ( cell Id ( i - NUM ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM ) ; init Swap ( output ) ; }
private String Set discover Volume Snaps ( Storage System system , List < Snap > snaps , String parent GUID , String Set parent Matched V Pools , VN Xe Api Client api Client , Db Client db Client , Map < String , List < Un Managed Volume > > host Volumes Map , VN Xe Lun lun , boolean is Snap In CG , String cg Name ) throws Exception { String Set snapsets = new String Set ( ) ; for ( Snap snap Detail : snaps ) { Un Managed Volume un Managed Volume = null ; String managed Snap Native Guid = Native GUID Generator . generate Native Guid For Volume Or Block Snap Shot ( system . get Native Guid ( ) , snap Detail . get Id ( ) ) ; Block Snapshot vipr Snap = Discovery Utils . check Block Snapshot Exists In DB ( db Client , managed Snap Native Guid ) ; if ( null != vipr Snap ) { log . info ( STRING , managed Snap Native Guid ) ; snapsets . add ( managed Snap Native Guid ) ; continue ; } String un Managed Volume Natvie Guid = Native GUID Generator . generate Native Guid For Pre Existing Volume ( system . get Native Guid ( ) , snap Detail . get Id ( ) ) ; un Managed Volume = Discovery Utils . check Un Managed Volume Exists In DB ( db Client , un Managed Volume Natvie Guid ) ; un Managed Volume = create Un Managed Volume For Snap ( un Managed Volume , un Managed Volume Natvie Guid , lun , system , db Client , host Volumes Map , snap Detail ) ; populate Snap Info ( un Managed Volume , snap Detail , parent GUID , parent Matched V Pools ) ; snapsets . add ( un Managed Volume Natvie Guid ) ; un Managed Volumes Returned From Provider . add ( un Managed Volume . get Id ( ) ) ; if ( is Snap In CG ) { add Object To Un Managed Consistency Group ( api Client , un Managed Volume , cg Name , system , db Client ) ; } } return snapsets ; }
public void receive ( final Call Event event ) { if ( event . is Valid ( ) ) { if ( ! m Events . contains ( event ) ) { m Events . add ( NUM , event ) ; fire Table Rows Inserted ( NUM , NUM ) ; prune ( ) ; } else { int row = m Events . index Of ( event ) ; fire Table Rows Updated ( row , row ) ; } } else { if ( m Events . contains ( event ) ) { int row = m Events . index Of ( event ) ; m Events . remove ( event ) ; fire Table Rows Deleted ( row , row ) ; } } }
public Pet find One ( String id ) { log . debug ( STRING , id ) ; Pet pet = pet Repository . find One ( UUID . from String ( id ) ) ; return pet ; }
public final void clear ( ) { m Active Issues . clear ( ) ; }
public static void await Data Ready ( ) { synchronized ( m Db Helper Lock ) { if ( m Db Helper == null ) { try { m Db Helper Lock . wait ( ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } } } }
protected Abstract Io Session ( Io Service service ) { this . service = service ; this . handler = service . get Handler ( ) ; long current Time = System . current Time Millis ( ) ; creation Time = current Time ; last Throughput Calculation Time = current Time ; last Read Time = current Time ; last Write Time = current Time ; last Idle Time For Both = current Time ; last Idle Time For Read = current Time ; last Idle Time For Write = current Time ; close Future . add Listener ( SCHEDULED COUNTER RESETTER ) ; session Id = id Generator . increment And Get ( ) ; }
private String process Float Token ( String token ) { String result = token . replace All ( group Separator , STRING ) ; if ( ! decimal Separator . equals ( STRING ) ) result = result . replace All ( decimal Separator , STRING ) ; boolean is Negative = BOOL ; int pre Len = negative Prefix . length ( ) ; if ( ( pre Len > NUM ) && result . starts With ( negative Prefix ) ) { is Negative = BOOL ; result = result . substring ( pre Len ) ; } int suf Len = negative Suffix . length ( ) ; if ( ( suf Len > NUM ) && result . ends With ( negative Suffix ) ) { is Negative = BOOL ; result = result . substring ( result . length ( ) - suf Len , result . length ( ) ) ; } if ( result . equals ( nan String ) ) result = STRING ; if ( result . equals ( infinity String ) ) result = STRING ; if ( is Negative ) result = STRING + result ; Matcher m = NON ASCII DIGIT . matcher ( result ) ; if ( m . find ( ) ) { String Builder in ASCII = new String Builder ( ) ; for ( int i = NUM ; i < result . length ( ) ; i ++ ) { char next Char = result . char At ( i ) ; if ( Character . is Digit ( next Char ) ) { int d = Character . digit ( next Char , NUM ) ; if ( d != - NUM ) in ASCII . append ( d ) ; else in ASCII . append ( next Char ) ; } else { in ASCII . append ( next Char ) ; } } result = in ASCII . to String ( ) ; } return result ; }
Internal Window ( String title ) { set Layout ( new Border Layout ( ) ) ; title Bar = new Title Bar ( ) ; add ( title Bar , Border Layout . NORTH ) ; title Bar . set Layout ( new S Box Layout ( S Box Layout . HORIZONTAL , TITLEBAR PADDING ) ) ; title Label = new J Label ( ) ; set Title ( title ) ; title Label . set Minimum Size ( new Dimension ( NUM , NUM ) ) ; title Bar . add ( title Label ) ; S Box Layout . add Spring ( title Bar ) ; minimize Button = new J Button ( minimize Icon ) ; minimize Button . set Margin ( new Insets ( NUM , NUM , NUM , NUM ) ) ; minimize Button . set Border ( Border Factory . create Empty Border ( ) ) ; minimize Button . set Focusable ( BOOL ) ; minimize Button . add Action Listener ( new Minimize Listener ( ) ) ; title Bar . add ( minimize Button ) ; close Button = new J Button ( close Icon ) ; close Button . set Margin ( new Insets ( NUM , NUM , NUM , NUM ) ) ; close Button . set Border ( Border Factory . create Empty Border ( ) ) ; close Button . set Focusable ( BOOL ) ; close Button . add Action Listener ( new Close Action Listener ( ) ) ; title Bar . add ( close Button ) ; cache = new Component Paint Cache ( this ) ; }
@ Suppress Warnings ( STRING ) public static Map < String , Object > load Stream ( Input Stream input Stream ) { LOG . fine ( STRING ) ; Yaml yaml = new Yaml ( ) ; Map < Object , Object > props Yaml = ( Map < Object , Object > ) yaml . load ( input Stream ) ; LOG . fine ( STRING ) ; Map < String , Object > typed Map = new Hash Map < > ( ) ; for ( Object key : props Yaml . key Set ( ) ) { typed Map . put ( key . to String ( ) , props Yaml . get ( key ) ) ; } return typed Map ; }
String [ ] split ( final String string To Split ) { if ( String Utils . is Not Blank ( string To Split ) ) { int str Lenght = string To Split . length ( ) ; int split Num = str Lenght / chunk Size ; if ( str Lenght % chunk Size > NUM ) { split Num += NUM ; } String [ ] result = new String [ split Num ] ; for ( int i = NUM ; i < split Num ; i ++ ) { int start Pos = i * chunk Size ; int end Pos = start Pos + chunk Size ; if ( end Pos > str Lenght ) { end Pos = str Lenght ; } result [ i ] = string To Split . substring ( start Pos , end Pos ) ; } return result ; } return null ; }
public void log Velocity Message ( int level , String message ) { synchronized ( this ) { Object [ ] data = new Object [ NUM ] ; data [ NUM ] = new Integer ( level ) ; data [ NUM ] = message ; pending Messages . add Element ( data ) ; } }
public void test Shift Right Neg Non Zeroes ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; int number = NUM ; byte r Bytes [ ] = { - NUM , - NUM , NUM , - NUM , NUM , - NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . shift Right ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
public void remove All Addresses ( ) { addresses . clear ( ) ; }
public static boolean is Show Tooltips ( ) { return show Tooltips ; }
private void add Reference ( final int source Position , final int reference Position ) { if ( src And Ref Positions == null ) { src And Ref Positions = new int [ NUM ] ; } if ( reference Count >= src And Ref Positions . length ) { int [ ] a = new int [ src And Ref Positions . length + NUM ] ; System . arraycopy ( src And Ref Positions , NUM , a , NUM , src And Ref Positions . length ) ; src And Ref Positions = a ; } src And Ref Positions [ reference Count ++ ] = source Position ; src And Ref Positions [ reference Count ++ ] = reference Position ; }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null ) m Context . unbind Service ( m Service Conn ) ; } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public static java . lang . String to Binary String ( int i ) { return int To Binary String ( i ) ; }
public static boolean is Property Field ( String field Name ) { return ! ID FIELD NAME . equals ( field Name ) && ! URI FIELD NAME . equals ( field Name ) && ! TEXT FIELD NAME . equals ( field Name ) && ! CONTEXT FIELD NAME . equals ( field Name ) && field Name . char At ( NUM ) != STRING ; }
public static void check Access ( int modifiers ) { if ( System . get Security Manager ( ) != null && ! Modifier . is Public ( modifiers ) ) { throw new Security Exception ( STRING ) ; } }
protected void print Indent ( String Builder ddl ) { ddl . append ( get Indent ( ) ) ; }
public N Type merge ( N Type a , N Type b ) throws Merge Failed { if ( a != null && b == null ) return a ; if ( a == null && b != null ) return b ; if ( a == null && b == null ) return null ; if ( a . equals ( b ) ) return a ; try { return Dispatcher . dispatch ( get Class ( ) , this , STRING , a , b ) ; } catch ( No Such Method Exception e ) { throw new Merge Failed ( STRING , a , b ) ; } }
public static String format ( String s , String col ) { String s1 = ( s + padd ) ; return s1 . substring ( NUM , Math . min ( col . length ( ) , s1 . length ( ) ) ) ; }
protected static void load End ( M Lookup Info info , Hash Map lookup ) { if ( info . Is Validated && lookup . size ( ) > NUM ) s loaded Lookups . put ( get Key ( info ) , lookup ) ; }
public static void info ( final String message ) { info Logger . accept ( message ) ; }
private void rotate Right ( Node < K , V > root ) { Node < K , V > pivot = root . left ; Node < K , V > right = root . right ; Node < K , V > pivot Left = pivot . left ; Node < K , V > pivot Right = pivot . right ; root . left = pivot Right ; if ( pivot Right != null ) { pivot Right . parent = root ; } replace In Parent ( root , pivot ) ; pivot . right = root ; root . parent = pivot ; root . height = Math . max ( right != null ? right . height : NUM , pivot Right != null ? pivot Right . height : NUM ) + NUM ; pivot . height = Math . max ( root . height , pivot Left != null ? pivot Left . height : NUM ) + NUM ; }
private void check No Characters Missing ( int total Length , List < Token > tokens ) { if ( ! tokens . is Empty ( ) && tokens . get ( tokens . size ( ) - NUM ) . right != total Length ) { String error = String . format ( STRING , tokens . get ( tokens . size ( ) - NUM ) . right , total Length ) ; throw new Runtime Exception ( error ) ; } int start = NUM ; for ( int i = NUM ; i < tokens . size ( ) ; i ++ ) { Token token = tokens . get ( i ) ; if ( token . left != start ) { throw new Runtime Exception ( STRING + start ) ; } start = token . right ; } }
public boolean validate Service Attributes ( String token , String validator Class , Set values ) throws SMS Exception , SSO Exception , Remote Exception { initialize ( ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + validator Class + STRING + values ) ; } try { Class clazz = Class . for Name ( validator Class ) ; Service Attribute Validator v = ( Service Attribute Validator ) clazz . new Instance ( ) ; return v . validate ( values ) ; } catch ( Instantiation Exception ex ) { throw new SMS Exception ( STRING ) ; } catch ( Illegal Access Exception ex ) { throw new SMS Exception ( STRING ) ; } catch ( Class Not Found Exception ex ) { throw new SMS Exception ( STRING ) ; } }
public synchronized void animate Pan To ( Point 2 D p , long duration ) { Point 2 D pp = new Point 2 D . Double ( ) ; m itransform . transform ( p , pp ) ; animate Pan To Abs ( pp , duration ) ; }
public static void assert Equals With Relative Error Or Both Na N ( String message , double expected , double actual ) { if ( expected == actual ) { return ; } if ( Double . is Na N ( expected ) && ! Double . is Na N ( actual ) ) { throw new Assertion Failed Error ( message + STRING + expected + STRING + actual + STRING ) ; } if ( ! Double . is Na N ( expected ) && Double . is Na N ( actual ) ) { throw new Assertion Failed Error ( message + STRING + expected + STRING + actual + STRING ) ; } double relative Error ; if ( Math . abs ( actual ) > Math . abs ( expected ) ) { relative Error = Math . abs ( ( expected - actual ) / actual ) ; } else { relative Error = Math . abs ( ( expected - actual ) / expected ) ; } if ( relative Error > MAX RELATIVE ERROR ) { throw new Assertion Failed Error ( message + STRING + expected + STRING + actual + STRING ) ; } }
protected void assert Exception ( final Abstract Exception Case exception Case ) throws Throwable { assert Exception ( exception Case , null ) ; }
@ Override public Service Host start ( ) throws Throwable { super . start ( ) ; start Default Core Services Synchronously ( ) ; super . start Service ( new Root Namespace Service ( ) ) ; super . start Service ( new Sample Service With Shared Custom Ui ( ) ) ; super . start Service ( new Sample Factory Service With Custom Ui ( ) ) ; super . start Factory ( new Sample Simple Echo Service ( ) ) ; super . start Factory ( new Sample Previous Echo Service ( ) ) ; super . start Factory ( new Example Service ( ) ) ; super . start Factory ( new Example Task Service ( ) ) ; super . start Service ( new Ui Service ( ) ) ; start Swagger Descriptor Service ( ) ; return this ; }
@ Override public void end Of Stream ( ) throws Ade Exception { for ( Msg Data data : m msg Data . values ( ) ) { if ( data . m total Log Counts > NUM ) { data . m lambda = data . m total Log Counts / data . m interval Count ; m min Lambda = Math . min ( data . m lambda , m min Lambda ) ; if ( locate Mismatching Distributions ( data ) ) { data . m bad Fit = BOOL ; } } } m trained = BOOL ; }
static Binary Tree < Integer > build Complete ( int n ) { Binary Tree < Integer > bt = new Binary Tree < Integer > ( ) ; int b = ( int ) Math . pow ( NUM , n - NUM ) ; for ( int i = NUM ; i < n ; i ++ ) { bt . insert ( b ) ; for ( int j = NUM ; j <= Math . pow ( NUM , i ) - NUM ; j ++ ) { bt . insert ( b + NUM * b * j ) ; } b = b / NUM ; } return bt ; }
public void erase ( ) { byte [ ] bytes = null ; for ( Byte Buffer buffer : buffers ) { if ( bytes == null || bytes . length < buffer . limit ( ) ) bytes = new byte [ buffer . limit ( ) ] ; buffer . position ( NUM ) ; buffer . put ( bytes , NUM , buffer . limit ( ) ) ; buffer . position ( NUM ) ; } }
@ Override boolean resurrect Selection ( ) { final int child Count = get Child Count ( ) ; if ( child Count <= NUM ) { return BOOL ; } int selected Top = NUM ; int selected Pos ; int children Top = m List Padding . top ; int children Bottom = get Bottom ( ) - get Top ( ) - m List Padding . bottom ; final int first Position = m First Position ; final int to Position = m Resurrect To Position ; boolean down = BOOL ; if ( to Position >= first Position && to Position < first Position + child Count ) { selected Pos = to Position ; final View selected = get Child At ( selected Pos - m First Position ) ; selected Top = selected . get Top ( ) ; int selected Bottom = selected . get Bottom ( ) ; if ( selected Top < children Top ) { selected Top = children Top + get Vertical Fading Edge Length ( ) ; } else if ( selected Bottom > children Bottom ) { selected Top = children Bottom - selected . get Measured Height ( ) - get Vertical Fading Edge Length ( ) ; } } else { if ( to Position < first Position ) { selected Pos = first Position ; for ( int i = NUM ; i < child Count ; i ++ ) { final View v = get Child At ( i ) ; final int top = v . get Top ( ) ; if ( i == NUM ) { selected Top = top ; if ( first Position > NUM || top < children Top ) { children Top += get Vertical Fading Edge Length ( ) ; } } if ( top >= children Top ) { selected Pos = first Position + i ; selected Top = top ; break ; } } } else { final int item Count = m Item Count ; down = BOOL ; selected Pos = first Position + child Count - NUM ; for ( int i = child Count - NUM ; i >= NUM ; i -- ) { final View v = get Child At ( i ) ; final int top = v . get Top ( ) ; final int bottom = v . get Bottom ( ) ; if ( i == child Count - NUM ) { selected Top = top ; if ( first Position + child Count < item Count || bottom > children Bottom ) { children Bottom -= get Vertical Fading Edge Length ( ) ; } } if ( bottom <= children Bottom ) { selected Pos = first Position + i ; selected Top = top ; break ; } } } } m Resurrect To Position = INVALID POSITION ; remove Callbacks ( m Fling Runnable ) ; m Touch Mode = TOUCH MODE REST ; clear Scrolling Cache ( ) ; m Specific Top = selected Top ; selected Pos = look For Selectable Position ( selected Pos , down ) ; if ( selected Pos >= first Position && selected Pos <= get Last Visible Position ( ) ) { m Layout Mode = LAYOUT SPECIFIC ; set Selection Int ( selected Pos ) ; invoke On Item Scroll Listener ( ) ; } else { selected Pos = INVALID POSITION ; } report Scroll State Change ( On Scroll Listener . SCROLL STATE IDLE ) ; return selected Pos >= NUM ; }
public void log Purchase ( Big Decimal purchase Amount , Currency currency , Bundle parameters ) { if ( purchase Amount == null ) { notify Developer Error ( STRING ) ; return ; } else if ( currency == null ) { notify Developer Error ( STRING ) ; return ; } if ( parameters == null ) { parameters = new Bundle ( ) ; } parameters . put String ( App Events Constants . EVENT PARAM CURRENCY , currency . get Currency Code ( ) ) ; log Event ( App Events Constants . EVENT NAME PURCHASED , purchase Amount . double Value ( ) , parameters ) ; eager Flush ( ) ; }
public static String pad Between ( final String first , final int length , final String last ) { final int padlen = length - ( first . length ( ) + last . length ( ) ) ; return first + ( padlen > NUM ? get Space String ( padlen ) : STRING ) + last ; }
public void apply From Resolve Info ( Package Manager pm , Resolve Info info , Widget Preview Loader loader ) { m Info = info ; Char Sequence label = info . load Label ( pm ) ; m Widget Name . set Text ( label ) ; m Widget Dims . set Text ( String . format ( m Dimensions Format String , NUM , NUM ) ) ; m Widget Preview Loader = loader ; }
private Queue Connection Impl create New Primary ( Set excluded Servers ) { Queue Connection Impl primary = null ; while ( primary == null && pool . get Pool Or Cache Cancel In Progress ( ) == null ) { List servers = find Queue Servers ( excluded Servers , NUM , BOOL , print Primary Not Found Error , Localized Strings . Queue Manager Impl COULD NOT FIND SERVER TO CREATE PRIMARY CLIENT QUEUE ) ; print Primary Not Found Error = BOOL ; if ( servers == null || servers . is Empty ( ) ) { break ; } Connection connection = null ; try { connection = factory . create Client To Server Connection ( ( Server Location ) servers . get ( NUM ) , BOOL ) ; } catch ( Gem Fire Security Exception e ) { throw e ; } catch ( Exception e ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING , servers . get ( NUM ) ) ; } } if ( connection != null ) { primary = initialize Queue Connection ( connection , BOOL , queue Connections . get Failed Updater ( ) ) ; } excluded Servers . add All ( servers ) ; } if ( primary != null && sent Client Ready && primary . send Client Ready ( ) ) { ready For Events After Failover ( primary ) ; } return primary ; }
public static int read Int ( ) { return scanner . next Int ( ) ; }
public CSV Config guess ( ) { try { Buffered Reader b In = new Buffered Reader ( new Input Stream Reader ( get Input Stream ( ) , Standard Charsets . UTF 8 ) ) ; String [ ] lines = new String [ NUM ] ; String line = null ; int counter = NUM ; while ( ( line = b In . read Line ( ) ) != null && counter <= NUM ) { lines [ counter ] = line ; counter ++ ; } if ( counter < NUM ) { String [ ] new Lines = new String [ counter ] ; System . arraycopy ( lines , NUM , new Lines , NUM , counter ) ; lines = new Lines ; } analyse Lines ( lines ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( Exception e ) { } } } CSV Config conf = config ; config = null ; return conf ; }
private void update Design ( Data Set Design data Set Design , I Connection conn , String query Text ) throws Oda Exception { I Query query = conn . new Query ( null ) ; query . prepare ( query Text ) ; query . set Property ( Query . PROP SETUP QUERY TEXT , get Setup Query Text ( ) ) ; try { I Result Set Meta Data md = query . get Meta Data ( ) ; update Result Set Design ( md , data Set Design ) ; } catch ( Oda Exception e ) { data Set Design . set Result Sets ( null ) ; e . print Stack Trace ( ) ; } try { I Parameter Meta Data param Md = query . get Parameter Meta Data ( ) ; update Parameter Design ( param Md , data Set Design ) ; } catch ( Oda Exception ex ) { data Set Design . set Parameters ( null ) ; ex . print Stack Trace ( ) ; } }
@ Override public Outlier Result run ( Database db , Relation < V > relation ) { DBI Ds ids = relation . get DBI Ds ( ) ; Similarity Query < V > sq = db . get Similarity Query ( relation , kernel Function ) ; Kernel Matrix kernel Matrix = new Kernel Matrix ( sq , relation , ids ) ; Writable Double Data Store abodvalues = Data Store Util . make Double Storage ( ids , Data Store Factory . HINT STATIC ) ; Double Min Max minmaxabod = new Double Min Max ( ) ; Mean Variance s = new Mean Variance ( ) ; KNN Heap nn = DBID Util . new Heap ( k ) ; for ( DBID Iter pA = ids . iter ( ) ; pA . valid ( ) ; pA . advance ( ) ) { final double sim AA = kernel Matrix . get Similarity ( pA , pA ) ; nn . clear ( ) ; for ( DBID Iter nB = relation . iter DBI Ds ( ) ; nB . valid ( ) ; nB . advance ( ) ) { if ( DBID Util . equal ( nB , pA ) ) { continue ; } double sim BB = kernel Matrix . get Similarity ( nB , nB ) ; double sim AB = kernel Matrix . get Similarity ( pA , nB ) ; double sqd AB = sim AA + sim BB - sim AB - sim AB ; if ( ! ( sqd AB > NUM ) ) { continue ; } nn . insert ( sqd AB , nB ) ; } KNN List nl = nn . to KNN List ( ) ; s . reset ( ) ; Double DBID List Iter iB = nl . iter ( ) , iC = nl . iter ( ) ; for ( ; iB . valid ( ) ; iB . advance ( ) ) { double sqd AB = iB . double Value ( ) ; double sim AB = kernel Matrix . get Similarity ( pA , iB ) ; if ( ! ( sqd AB > NUM ) ) { continue ; } for ( iC . seek ( iB . get Offset ( ) + NUM ) ; iC . valid ( ) ; iC . advance ( ) ) { double sqd AC = iC . double Value ( ) ; double sim AC = kernel Matrix . get Similarity ( pA , iC ) ; if ( ! ( sqd AC > NUM ) ) { continue ; } double sim BC = kernel Matrix . get Similarity ( iB , iC ) ; double numerator = sim BC - sim AB - sim AC + sim AA ; double div = NUM / ( sqd AB * sqd AC ) ; s . put ( numerator * div , Math . sqrt ( div ) ) ; } } final double abof = s . get Naive Variance ( ) ; minmaxabod . put ( abof ) ; abodvalues . put Double ( pA , abof ) ; } Double Relation score Result = new Materialized Double Relation ( STRING , STRING , abodvalues , relation . get DBI Ds ( ) ) ; Outlier Score Meta score Meta = new Inverted Outlier Score Meta ( minmaxabod . get Min ( ) , minmaxabod . get Max ( ) , NUM , Double . POSITIVE INFINITY ) ; return new Outlier Result ( score Meta , score Result ) ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String bad Substring ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; { boolean success = BOOL ; try { bad Substring = child . substring Data ( NUM , - NUM ) ; } catch ( DOM Exception ex ) { success = ( ex . code == DOM Exception . INDEX SIZE ERR ) ; } assert True ( STRING , success ) ; } }
public static String to String ( JSON Object jo ) throws JSON Exception { String Buffer sb = new String Buffer ( ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( jo . get String ( STRING ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . get String ( STRING ) ) ) ; } if ( jo . opt Boolean ( STRING ) ) { sb . append ( STRING ) ; } return sb . to String ( ) ; }
@ Override public boolean equals ( Object other Rule ) { if ( other Rule == this ) { return BOOL ; } if ( other Rule instanceof Zone Offset Transition Rule ) { Zone Offset Transition Rule other = ( Zone Offset Transition Rule ) other Rule ; return month == other . month && dom == other . dom && dow == other . dow && time Definition == other . time Definition && time . equals ( other . time ) && time End Of Day == other . time End Of Day && standard Offset . equals ( other . standard Offset ) && offset Before . equals ( other . offset Before ) && offset After . equals ( other . offset After ) ; } return BOOL ; }
private void initialize Membership Matrix ( ) { for ( int i = NUM ; i < points . size ( ) ; i ++ ) { for ( int j = NUM ; j < k ; j ++ ) { membership Matrix [ i ] [ j ] = random . next Double ( ) ; } membership Matrix [ i ] = Math Arrays . normalize Array ( membership Matrix [ i ] , NUM ) ; } }
public static void write All ( Output Stream stream , Object [ ] o ) throws Exception { Object Output Stream oos ; int i ; if ( ! ( stream instanceof Buffered Output Stream ) ) { stream = new Buffered Output Stream ( stream ) ; } oos = new Object Output Stream ( stream ) ; for ( i = NUM ; i < o . length ; i ++ ) { oos . write Object ( o [ i ] ) ; } oos . flush ( ) ; oos . close ( ) ; }
public synchronized void reset ( ) { m Buf Vertices . position ( NUM ) ; m Buf Colors . position ( NUM ) ; if ( DRAW TEXTURE ) { m Buf Tex Coords . position ( NUM ) ; } for ( int i = NUM ; i < NUM ; ++ i ) { Vertex tmp = m Arr Temp Vertices . get ( NUM ) ; tmp . set ( m Rectangle [ i ] ) ; if ( m Flip Texture ) { tmp . m Tex X *= m Texture Rect Back . right ; tmp . m Tex Y *= m Texture Rect Back . bottom ; tmp . m Color = m Texture Page . get Color ( Curl Page . SIDE BACK ) ; } else { tmp . m Tex X *= m Texture Rect Front . right ; tmp . m Tex Y *= m Texture Rect Front . bottom ; tmp . m Color = m Texture Page . get Color ( Curl Page . SIDE FRONT ) ; } add Vertex ( tmp ) ; } m Vertices Count Front = NUM ; m Vertices Count Back = NUM ; m Buf Vertices . position ( NUM ) ; m Buf Colors . position ( NUM ) ; if ( DRAW TEXTURE ) { m Buf Tex Coords . position ( NUM ) ; } m Drop Shadow Count = m Self Shadow Count = NUM ; }
public boolean delete Attachment Point ( Datapath Id sw , OF Port port ) { Attachment Point ap = new Attachment Point ( sw , port , new Date ( NUM ) ) ; if ( this . old A Ps != null ) { Array List < Attachment Point > ap List = new Array List < Attachment Point > ( ) ; ap List . add All ( this . old A Ps ) ; int index = ap List . index Of ( ap ) ; if ( index > NUM ) { ap List . remove ( index ) ; this . old A Ps = ap List ; } } if ( this . attachment Points != null ) { Array List < Attachment Point > ap List = new Array List < Attachment Point > ( ) ; ap List . add All ( this . attachment Points ) ; int index = ap List . index Of ( ap ) ; if ( index > NUM ) { ap List . remove ( index ) ; this . attachment Points = ap List ; return BOOL ; } } return BOOL ; }
public B css ( @ Non Nls String classes ) { return css ( classes , null ) ; }
public static Argument Exception adapt Property Exception ( Property Exception e , Abstract Managed Object Definition < ? , ? > d ) { return new Argument Exception ( e . get Message Object ( ) ) ; }
private Consumer < Operation > create Notification Target ( ) { return null ; }
public void write ( byte [ ] bytes ) throws IO Exception { data Output . write ( bytes ) ; offset += bytes . length ; }
static synchronized boolean is Shaping Supported ( ) { if ( is Shaping Supported == null ) { X Toolkit . awt Lock ( ) ; try { is Shaping Supported = Xlib Wrapper . X Shape Query Extension ( X Toolkit . get Display ( ) , Xlib Wrapper . larg 1 , Xlib Wrapper . larg 2 ) ; } finally { X Toolkit . awt Unlock ( ) ; } } return is Shaping Supported . boolean Value ( ) ; }
private boolean is Id Char ( int ch ) { return is Alpha ( ch ) || is Digit ( ch ) || ch == STRING || ch == STRING || ch == STRING || ch == STRING || Character . is Letter ( ch ) ; }
protected String handle Timeseal ( String text ) throws IO Exception { String result = text ; if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STRING + result ) ; while ( result . contains ( STRING ) ) { send Ack ( ) ; result = result . replace First ( STRING , STRING ) ; if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STRING + result ) ; } if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STRING + result ) ; return result ; }
public Ber Input Stream ( Input Stream in , int initial Size ) throws IO Exception { this . in = in ; buffer = new byte [ initial Size ] ; next ( ) ; if ( length != INDEFINIT LENGTH ) { if ( buffer . length < ( length + offset ) ) { byte [ ] new Buffer = new byte [ length + offset ] ; System . arraycopy ( buffer , NUM , new Buffer , NUM , offset ) ; buffer = new Buffer ; } } else { is Indefined Length = BOOL ; throw new ASN 1 Exception ( STRING ) ; } }
protected Location Handler ( Location location , Option ... options ) { this . location = location ; this . options = options . length == NUM ? Enum Set . none Of ( Option . class ) : Enum Set . copy Of ( Arrays . as List ( options ) ) ; }
private void init ( ) { logger . debug ( STRING ) ; list = new Concurrent Linked Queue < Arrived Indication > ( ) ; Intermediate Processor intermediate Processor = new Intermediate Processor ( list , processor ) ; indication Process Timer = Executors . new Single Thread Scheduled Executor ( ) ; indication Process Timer . schedule With Fixed Delay ( intermediate Processor , CIM Constants . INDICATION PROCESS INTERVAL , PERIODIC DELAY , Time Unit . SECONDS ) ; }
public void test Result Set Metadate ( ) throws Exception { final int rows = NUM ; final int tables = NUM ; final int columns = NUM ; Statement st = con . create Statement ( ) ; String Builder sb = new String Builder ( ) ; try { for ( int t = NUM ; t < tables ; t ++ ) { sb . set Length ( NUM ) ; sb . append ( STRING ) ; sb . append ( t ) ; sb . append ( STRING ) ; for ( int c = NUM ; c < columns ; c ++ ) { sb . append ( STRING ) ; sb . append ( c ) ; sb . append ( STRING ) ; } sb . append ( STRING ) ; st . execute ( sb . to String ( ) ) ; } for ( int t = NUM ; t < tables ; t ++ ) { sb . set Length ( NUM ) ; sb . append ( STRING ) ; sb . append ( t ) ; sb . append ( STRING ) ; for ( int c = NUM ; c < columns ; c ++ ) { sb . append ( STRING ) ; } sb . append ( STRING ) ; Prepared Statement pst = con . prepare Statement ( sb . to String ( ) ) ; for ( int r = NUM ; r < rows ; r ++ ) { for ( int c = NUM ; c <= columns ; c ++ ) { pst . set Int ( c + NUM , r ) ; } pst . add Batch ( ) ; } Assert . assert Equals ( rows , pst . execute Batch ( ) . length ) ; } sb . set Length ( NUM ) ; sb . append ( STRING ) ; for ( int t = NUM ; t < tables ; t ++ ) { sb . append ( t > NUM ? STRING : STRING ) ; sb . append ( STRING ) ; sb . append ( t ) ; } if ( tables > NUM ) { sb . append ( STRING ) ; for ( int t = NUM ; t < tables ; t ++ ) { sb . append ( t > NUM ? STRING : STRING ) ; sb . append ( STRING ) ; sb . append ( t ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; sb . append ( t - NUM ) ; sb . append ( STRING ) ; } } Result Set rs = st . execute Query ( sb . to String ( ) ) ; Result Set Meta Data rsmd = rs . get Meta Data ( ) ; int toal Columns = rsmd . get Column Count ( ) ; Assert . assert Equals ( tables * ( columns + NUM ) , toal Columns ) ; for ( int r = NUM ; r < rows ; r ++ ) { assert True ( rs . next ( ) ) ; } int index = NUM ; for ( int t = NUM ; t < tables ; t ++ ) { for ( int c = NUM ; c <= columns + NUM ; c ++ ) { index ++ ; Assert . assert Equals ( c > NUM ? ( STRING + ( c - NUM ) ) : STRING , rsmd . get Column Name ( index ) ) ; Assert . assert Equals ( Types . INTEGER , rsmd . get Column Type ( index ) ) ; Assert . assert Equals ( STRING + t , rsmd . get Table Name ( index ) ) ; } } } finally { for ( int t = NUM ; t < tables ; t ++ ) { drop Table ( STRING + t ) ; } } }
public static final String long To Hex String ( long a ) { String Buffer sb = new String Buffer ( NUM ) ; for ( int i = NUM ; i < NUM ; i ++ ) sb . append ( NIBBLE [ ( int ) ( a > > > ( NUM - NUM * i ) ) & NUM ] ) ; return sb . to String ( ) ; }
private Date watch Core Start At ( Solr Server client , final long timeout , final Date min ) throws Interrupted Exception , IO Exception , Solr Server Exception { final long sleep Interval = NUM ; long time Slept = NUM ; Solr Params p = params ( STRING , STRING , STRING , STRING ) ; while ( time Slept < timeout ) { Query Request req = new Query Request ( p ) ; req . set Path ( STRING ) ; try { Named List data = client . request ( req ) ; for ( String k : new String [ ] { STRING , STRING } ) { Object o = data . get ( k ) ; assert Not Null ( STRING + k , o ) ; data = ( Named List ) o ; } Date start Time = ( Date ) data . get ( STRING ) ; assert Not Null ( STRING , start Time ) ; if ( null == min || start Time . after ( min ) ) { return start Time ; } } catch ( Solr Exception e ) { if ( NUM != e . code ( ) ) { throw e ; } } time Slept += sleep Interval ; Thread . sleep ( sleep Interval ) ; } fail ( STRING + min ) ; return min ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String child Data ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; child . delete Data ( NUM , NUM ) ; child Data = child . get Data ( ) ; assert Equals ( STRING , STRING , child Data ) ; }
@ Override public Params Request Condition combine ( Params Request Condition other ) { Set < Param Expression > set = new Linked Hash Set < > ( this . expressions ) ; set . add All ( other . expressions ) ; return new Params Request Condition ( set ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL ; } if ( ! ( obj instanceof Time Series Collection ) ) { return BOOL ; } Time Series Collection that = ( Time Series Collection ) obj ; if ( this . x Position != that . x Position ) { return BOOL ; } if ( this . domain Is Points In Time != that . domain Is Points In Time ) { return BOOL ; } if ( ! Object Utilities . equal ( this . data , that . data ) ) { return BOOL ; } return BOOL ; }
private void parse Rules ( Attributes attributes ) { start Mode = get Mode Attribute ( attributes , STRING ) ; if ( start Mode == null ) { start Mode = lookup Create Mode ( IMPLICIT MODE NAME ) ; md . current Mode = start Mode ; start Mode . note Defined ( null ) ; } start Mode . note Used ( locator ) ; if ( attributes Schema ) { Mode wrapper = lookup Create Mode ( WRAPPER MODE NAME ) ; Action Set actions = new Action Set ( ) ; actions . add No Result Action ( new Allow Action ( new Mode Usage ( start Mode , start Mode ) ) ) ; wrapper . bind Element ( Namespace Specification . ANY NAMESPACE , Namespace Specification . DEFAULT WILDCARD , actions ) ; wrapper . note Defined ( null ) ; start Mode = wrapper ; } default Schema Type = get Schema Type ( attributes ) ; }
public void fill ( byte value ) { value &= NUM ; Arrays . fill ( data , ( byte ) ( value << NUM | value ) ) ; }
public void make Immutable ( ) { if ( is Mutable ) { is Mutable = BOOL ; } }
private static void parse ( Input Stream in , Encoding encoding , Content Handler content Handler ) throws IO Exception , SAX Exception { try { XML Reader reader = new Expat Reader ( ) ; reader . set Content Handler ( content Handler ) ; Input Source source = new Input Source ( in ) ; source . set Encoding ( encoding . expat Name ) ; reader . parse ( source ) ; } catch ( IO Exception e ) { throw new Assertion Error ( e ) ; } }
@ Override public List < Foo > find By Field 2 ( boolean field 2 ) { return find By Field 2 ( field 2 , Query Util . ALL POS , Query Util . ALL POS , null ) ; }
public void add To Associated ( Message as Message ) { associated Messages . add ( as Message ) ; }
private static void parse Property Assignments ( Properties p , String [ ] assignments ) { for ( String assignment : assignments ) { int split = assignment . index Of ( STRING ) ; String key = assignment . substring ( NUM , split ) ; String value = assignment . substring ( split + NUM ) ; p . put ( key , value ) ; } }
protected boolean switch Profiles ( I Profile new Selection ) { if ( new Selection == null ) { return BOOL ; } if ( m Current Profile == new Selection ) { return BOOL ; } if ( m Alternative Profile Header Switching ) { int prev Selection = - NUM ; if ( m Profile First == new Selection ) { prev Selection = NUM ; } else if ( m Profile Second == new Selection ) { prev Selection = NUM ; } else if ( m Profile Third == new Selection ) { prev Selection = NUM ; } I Profile tmp = m Current Profile ; m Current Profile = new Selection ; if ( prev Selection == NUM ) { m Profile First = tmp ; } else if ( prev Selection == NUM ) { m Profile Second = tmp ; } else if ( prev Selection == NUM ) { m Profile Third = tmp ; } } else { if ( m Profiles != null ) { Array List < I Profile > previous Active Profiles = new Array List < > ( Arrays . as List ( m Current Profile , m Profile First , m Profile Second , m Profile Third ) ) ; if ( previous Active Profiles . contains ( new Selection ) ) { int position = - NUM ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( previous Active Profiles . get ( i ) == new Selection ) { position = i ; break ; } } if ( position != - NUM ) { previous Active Profiles . remove ( position ) ; previous Active Profiles . add ( NUM , new Selection ) ; m Current Profile = previous Active Profiles . get ( NUM ) ; m Profile First = previous Active Profiles . get ( NUM ) ; m Profile Second = previous Active Profiles . get ( NUM ) ; m Profile Third = previous Active Profiles . get ( NUM ) ; } } else { m Profile Third = m Profile Second ; m Profile Second = m Profile First ; m Profile First = m Current Profile ; m Current Profile = new Selection ; } } } if ( m Only Small Profile Images Visible ) { m Profile Third = m Profile Second ; m Profile Second = m Profile First ; m Profile First = m Current Profile ; } build Profiles ( ) ; return BOOL ; }
public static Search Scope value Of ( final int int Value ) { Search Scope result = null ; if ( NUM <= int Value && int Value < ELEMENTS . length ) { result = ELEMENTS [ int Value ] ; } if ( result == null ) { result = new Search Scope ( int Value , STRING + int Value + STRING , Enum . UNKNOWN ) ; } return result ; }
public static I Package Fragment Root add Class Folder ( I Java Project jproject , String container Name , I Path source Attach Path , I Path source Attach Root ) throws Core Exception { I Project project = jproject . get Project ( ) ; I Container container = null ; if ( container Name == null || container Name . length ( ) == NUM ) { container = project ; } else { I Folder folder = project . get Folder ( container Name ) ; if ( ! folder . exists ( ) ) { Core Utility . create Folder ( folder , BOOL , BOOL , null ) ; } container = folder ; } I Classpath Entry cpe = Java Core . new Library Entry ( container . get Full Path ( ) , source Attach Path , source Attach Root ) ; add To Classpath ( jproject , cpe ) ; return jproject . get Package Fragment Root ( container ) ; }
private void previous Window ( Calendar start Time ) { if ( is Daily ( ) ) { start Time . add ( Calendar . DAY OF MONTH , - NUM ) ; } else if ( is Weekly ( ) ) { start Time . add ( Calendar . WEEK OF MONTH , - NUM ) ; } else if ( is Monthly ( ) ) { int month = start Time . get ( Calendar . MONTH ) ; adjust Day Of Month ( start Time , month + - NUM ) ; } }
private < T > T [ ] copy Elements ( T [ ] a ) { if ( head < tail ) { System . arraycopy ( elements , head , a , NUM , size ( ) ) ; } else if ( head > tail ) { int head Portion Len = elements . length - head ; System . arraycopy ( elements , head , a , NUM , head Portion Len ) ; System . arraycopy ( elements , NUM , a , head Portion Len , tail ) ; } return a ; }
abstract void execute On Handler Task ( Runnable task ) ;
public static Lat Lng translate Point ( Lat Lng point , double distance , double bearing ) { distance = distance / NUM ; double lat = Math . to Radians ( point . latitude ) ; double lng = Math . to Radians ( point . longitude ) ; bearing = Math . to Radians ( bearing ) ; double Lat 2 = Math . asin ( ( Math . sin ( lat ) * Math . cos ( distance / EARTH ) ) + ( Math . cos ( lat ) * Math . sin ( distance / EARTH ) * Math . cos ( bearing ) ) ) ; double Long 2 = lng + Math . atan 2 ( Math . sin ( bearing ) * Math . sin ( distance / EARTH ) * Math . cos ( lat ) , Math . cos ( distance / EARTH ) - ( Math . sin ( lat ) * Math . sin ( Lat 2 ) ) ) ; Lat 2 = Math . to Degrees ( Lat 2 ) ; Long 2 = Math . to Degrees ( Long 2 ) ; return new Lat Lng ( Lat 2 , Long 2 ) ; }
public Instance calc Pivot ( My Idx List list 1 , My Idx List list 2 , Instances insts ) { int class Idx = m Instances . class Index ( ) ; double [ ] attr Vals = new double [ insts . num Attributes ( ) ] ; Instance temp ; for ( int i = NUM ; i < list 1 . length ( ) ; i ++ ) { temp = insts . instance ( list 1 . get ( i ) . idx ) ; for ( int k = NUM ; k < temp . num Values ( ) ; k ++ ) { if ( temp . index ( k ) == class Idx ) { continue ; } attr Vals [ k ] += temp . value Sparse ( k ) ; } } for ( int j = NUM ; j < list 2 . length ( ) ; j ++ ) { temp = insts . instance ( list 2 . get ( j ) . idx ) ; for ( int k = NUM ; k < temp . num Values ( ) ; k ++ ) { if ( temp . index ( k ) == class Idx ) { continue ; } attr Vals [ k ] += temp . value Sparse ( k ) ; } } for ( int j = NUM , num Insts = list 1 . length ( ) + list 2 . length ( ) ; j < attr Vals . length ; j ++ ) { attr Vals [ j ] /= num Insts ; } temp = new Dense Instance ( NUM , attr Vals ) ; return temp ; }
default Optional < List < T > > parse Optional ( byte [ ] parse Message ) { return Optional . of Nullable ( parse ( parse Message ) ) ; }
public static void initialize For Client Use ( ) { Embedded Utils . initialize For Client Use ( ) ; }
private void create User ( SSO Token token , Persistent Object parent Obj , Map attributes , String profile Name ) throws UMS Exception , AM Entry Exists Exception , AM Exception { String org DN = get Organization DN ( internal Token , parent Obj . get DN ( ) ) ; String entry DN = get Naming Attribute ( AM Object . USER ) + STRING + profile Name + STRING + parent Obj . get DN ( ) ; attributes = call Back Helper . pre Process ( token , entry DN , org DN , null , attributes , Call Back Helper . CREATE , AM Object . USER , BOOL ) ; Attr Set attr Set = Common Utils . map To Attr Set ( attributes ) ; make Naming First ( attr Set , get Naming Attribute ( AM Object . USER ) , profile Name ) ; User Password Validation Helper plugin Impl = new User Password Validation Helper ( token , org DN ) ; try { plugin Impl . validate ( Common Utils . attr Set To Map ( attr Set ) ) ; } catch ( AM Exception ame ) { debug . error ( STRING + STRING , ame ) ; throw ame ; } Template Manager temp Mgr = Template Manager . get Template Manager ( ) ; Creation Template creation Temp = temp Mgr . get Creation Template ( STRING , new Guid ( org DN ) , Template Manager . SCOPE ANCESTORS ) ; attr Set = combine O Cs ( creation Temp , attr Set ) ; Persistent Object user = new Persistent Object ( creation Temp , attr Set ) ; try { parent Obj . add Child ( user ) ; } catch ( Access Rights Exception e ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STRING + STRING , e ) ; } throw new AM Exception ( token , STRING ) ; } catch ( Entry Already Exists Exception ee ) { if ( Compliance Services Impl . is Compliance User Deletion Enabled ( ) ) { compliance Impl . check If Deleted User ( token , user . get DN ( ) ) ; } if ( debug . warning Enabled ( ) ) { debug . warning ( STRING + STRING , ee ) ; } throw new AM Entry Exists Exception ( token , STRING , ee ) ; } catch ( UMS Exception ue ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STRING + STRING , ue ) ; } process Internal Exception ( token , ue , STRING ) ; } call Back Helper . post Process ( token , user . get DN ( ) , org DN , null , attributes , Call Back Helper . CREATE , AM Object . USER , BOOL ) ; AM User Entry Processed post Plugin = get User Post Plugin ( ) ; if ( post Plugin != null ) { Map attr Map = Common Utils . attr Set To Map ( attr Set ) ; post Plugin . process User Add ( token , user . get DN ( ) , attr Map ) ; } Email Notification Helper mailer Obj = new Email Notification Helper ( user . get DN ( ) ) ; mailer Obj . set User Create Notification List ( ) ; mailer Obj . send User Create Notification ( attributes ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
private static int byte Compaction ( int mode , int [ ] codewords , int code Index , String Builder result ) { if ( mode == BYTE COMPACTION MODE LATCH ) { int count = NUM ; long value = NUM ; char [ ] decoded Data = new char [ NUM ] ; int [ ] byte Compacted Codewords = new int [ NUM ] ; boolean end = BOOL ; int next Code = codewords [ code Index ++ ] ; while ( ( code Index < codewords [ NUM ] ) && ! end ) { byte Compacted Codewords [ count ++ ] = next Code ; value = NUM * value + next Code ; next Code = codewords [ code Index ++ ] ; if ( next Code == TEXT COMPACTION MODE LATCH || next Code == BYTE COMPACTION MODE LATCH || next Code == NUMERIC COMPACTION MODE LATCH || next Code == BYTE COMPACTION MODE LATCH 6 || next Code == BEGIN MACRO PDF 417 CONTROL BLOCK || next Code == BEGIN MACRO PDF 417 OPTIONAL FIELD || next Code == MACRO PDF 417 TERMINATOR ) { code Index -- ; end = BOOL ; } else { if ( ( count % NUM == NUM ) && ( count > NUM ) ) { for ( int j = NUM ; j < NUM ; ++ j ) { decoded Data [ NUM - j ] = ( char ) ( value % NUM ) ; value >>= NUM ; } result . append ( decoded Data ) ; count = NUM ; } } } if ( code Index == codewords [ NUM ] && next Code < TEXT COMPACTION MODE LATCH ) { byte Compacted Codewords [ count ++ ] = next Code ; } for ( int i = NUM ; i < count ; i ++ ) { result . append ( ( char ) byte Compacted Codewords [ i ] ) ; } } else if ( mode == BYTE COMPACTION MODE LATCH 6 ) { int count = NUM ; long value = NUM ; boolean end = BOOL ; while ( code Index < codewords [ NUM ] && ! end ) { int code = codewords [ code Index ++ ] ; if ( code < TEXT COMPACTION MODE LATCH ) { count ++ ; value = NUM * value + code ; } else { if ( code == TEXT COMPACTION MODE LATCH || code == BYTE COMPACTION MODE LATCH || code == NUMERIC COMPACTION MODE LATCH || code == BYTE COMPACTION MODE LATCH 6 || code == BEGIN MACRO PDF 417 CONTROL BLOCK || code == BEGIN MACRO PDF 417 OPTIONAL FIELD || code == MACRO PDF 417 TERMINATOR ) { code Index -- ; end = BOOL ; } } if ( ( count % NUM == NUM ) && ( count > NUM ) ) { char [ ] decoded Data = new char [ NUM ] ; for ( int j = NUM ; j < NUM ; ++ j ) { decoded Data [ NUM - j ] = ( char ) ( value & NUM ) ; value >>= NUM ; } result . append ( decoded Data ) ; count = NUM ; } } } return code Index ; }
public void add All ( @ Non Null List < T > item List ) { synchronized ( lock ) { if ( items == null ) { items = new Array List < > ( ) ; } items . add All ( item List ) ; } if ( notify On Change ) { if ( items . size ( ) - item List . size ( ) != NUM ) { notify Item Range Changed ( items . size ( ) - item List . size ( ) , item List . size ( ) ) ; } else { notify Data Set Changed ( ) ; } } }
public void write ( int a ) throws IO Exception { outs . write ( a ) ; position ++ ; }
public void test Insert 1 ( ) throws SQL Exception { Database Creator . fill Parent Table ( conn ) ; Database Creator . fill FK Strict Table ( conn ) ; Database Creator . fill FK Cascade Table ( conn ) ; statement . execute ( STRING + Database Creator . FKSTRICT TABLE + STRING ) ; statement . execute ( STRING + Database Creator . FKCASCADE TABLE + STRING ) ; }
public boolean is Starts With Mode ( ) { return starts With Mode ; }
public Builder with Threads ( int threads ) { properties . set Property ( Netty Options . THREADS , String . value Of ( Assert . arg Not ( threads , threads <= NUM , STRING ) ) ) ; return this ; }
public void paint Tabbed Pane Tab Area Background ( Synth Context context , Graphics g , int x , int y , int w , int h , int orientation ) { if ( orientation == J Tabbed Pane . LEFT ) { Affine Transform transform = new Affine Transform ( ) ; transform . scale ( - NUM , NUM ) ; transform . rotate ( Math . to Radians ( NUM ) ) ; paint Background ( context , g , y , x , h , w , transform ) ; } else if ( orientation == J Tabbed Pane . RIGHT ) { Affine Transform transform = new Affine Transform ( ) ; transform . rotate ( Math . to Radians ( NUM ) ) ; transform . translate ( NUM , - ( x + w ) ) ; paint Background ( context , g , y , NUM , h , w , transform ) ; } else if ( orientation == J Tabbed Pane . BOTTOM ) { Affine Transform transform = new Affine Transform ( ) ; transform . translate ( x , y ) ; paint Background ( context , g , NUM , NUM , w , h , transform ) ; } else { paint Background ( context , g , x , y , w , h , null ) ; } }
@ Override public void end CDATA ( Augmentations augs ) throws XNI Exception { try { if ( f Lexical Handler != null ) { f Lexical Handler . end CDATA ( ) ; } } catch ( SAX Exception e ) { throw new XNI Exception ( e ) ; } }
public static Media Locator create Media Locator ( String url ) { Media Locator ml ; if ( url . index Of ( STRING ) > NUM && ( ml = new Media Locator ( url ) ) != null ) return ml ; if ( url . starts With ( File . separator ) ) { if ( ( ml = new Media Locator ( STRING + url ) ) != null ) return ml ; } else { String file = STRING + System . get Property ( STRING ) + File . separator + url ; if ( ( ml = new Media Locator ( file ) ) != null ) return ml ; } return null ; }
private static void invoke Remote Clear And Wait ( VM remote VM , VM this VM ) { remote VM . invoke ( null ) ; try { clear Latch . await ( ) ; } catch ( Interrupted Exception e ) { fail ( STRING ) ; } }
private int measure Short ( int measure Spec ) { int result ; int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; if ( spec Mode == Measure Spec . EXACTLY ) { result = spec Size ; } else { result = ( int ) ( NUM * m Radius + get Padding Top ( ) + get Padding Bottom ( ) + NUM ) ; if ( spec Mode == Measure Spec . AT MOST ) { result = Math . min ( result , spec Size ) ; } } return result ; }
public void key ( String skey ) throws SQ Lite . Exception { synchronized ( this ) { byte ekey [ ] = null ; if ( skey != null && skey . length ( ) > NUM ) { ekey = new byte [ skey . length ( ) ] ; for ( int i = NUM ; i < skey . length ( ) ; i ++ ) { char c = skey . char At ( i ) ; ekey [ i ] = ( byte ) ( ( c & NUM ) ^ ( c > > NUM ) ) ; } } key ( ekey ) ; } }
public void test Shared Test Data ( ) throws Exception { assert Equals ( test Sql Date , Date . value Of ( test Local Date ) ) ; assert Equals ( test Sql Time , Time . value Of ( test Local Time ) ) ; assert Equals ( test Sql Time Stamp , Timestamp . value Of ( test Local Date Time ) ) ; assert Equals ( test Local Date , test Sql Date . to Local Date ( ) ) ; assert Equals ( test Local Time , test Sql Time . to Local Time ( ) ) ; assert Equals ( test Local Date Time , test Sql Time Stamp . to Local Date Time ( ) ) ; }
public static Cache . Entry make Random Cache Entry ( byte [ ] data , boolean is Expired , boolean needs Refresh ) { Random random = new Random ( ) ; Cache . Entry entry = new Cache . Entry ( ) ; if ( data != null ) { entry . data = data ; } else { entry . data = new byte [ random . next Int ( NUM ) ] ; } entry . etag = String . value Of ( random . next Long ( ) ) ; entry . server Date = random . next Long ( ) ; entry . ttl = is Expired ? NUM : Long . MAX VALUE ; entry . soft Ttl = needs Refresh ? NUM : Long . MAX VALUE ; return entry ; }
public static final void is C Data WF ( DOM Error Handler error Handler , DOM Error Impl error , DOM Locator Impl locator , String datavalue , boolean is XML 11 Version ) { if ( datavalue == null || ( datavalue . length ( ) == NUM ) ) { return ; } char [ ] dataarray = datavalue . to Char Array ( ) ; int datalength = dataarray . length ; if ( is XML 11 Version ) { int i = NUM ; while ( i < datalength ) { char c = dataarray [ i ++ ] ; if ( XML 11 Char . is XML 11 Invalid ( c ) ) { if ( XML Char . is High Surrogate ( c ) && i < datalength ) { char c2 = dataarray [ i ++ ] ; if ( XML Char . is Low Surrogate ( c2 ) && XML Char . is Supplemental ( XML Char . supplemental ( c , c2 ) ) ) { continue ; } } String msg = DOM Message Formatter . format Message ( DOM Message Formatter . XML DOMAIN , STRING , new Object [ ] { Integer . to String ( c , NUM ) } ) ; report DOM Error ( error Handler , error , locator , msg , DOM Error . SEVERITY ERROR , STRING ) ; } else if ( c == STRING ) { int count = i ; if ( count < datalength && dataarray [ count ] == STRING ) { while ( ++ count < datalength && dataarray [ count ] == STRING ) { } if ( count < datalength && dataarray [ count ] == STRING ) { String msg = DOM Message Formatter . format Message ( DOM Message Formatter . XML DOMAIN , STRING , null ) ; report DOM Error ( error Handler , error , locator , msg , DOM Error . SEVERITY ERROR , STRING ) ; } } } } } else { int i = NUM ; while ( i < datalength ) { char c = dataarray [ i ++ ] ; if ( XML Char . is Invalid ( c ) ) { if ( XML Char . is High Surrogate ( c ) && i < datalength ) { char c2 = dataarray [ i ++ ] ; if ( XML Char . is Low Surrogate ( c2 ) && XML Char . is Supplemental ( XML Char . supplemental ( c , c2 ) ) ) { continue ; } } String msg = DOM Message Formatter . format Message ( DOM Message Formatter . XML DOMAIN , STRING , new Object [ ] { Integer . to String ( c , NUM ) } ) ; report DOM Error ( error Handler , error , locator , msg , DOM Error . SEVERITY ERROR , STRING ) ; } else if ( c == STRING ) { int count = i ; if ( count < datalength && dataarray [ count ] == STRING ) { while ( ++ count < datalength && dataarray [ count ] == STRING ) { } if ( count < datalength && dataarray [ count ] == STRING ) { String msg = DOM Message Formatter . format Message ( DOM Message Formatter . XML DOMAIN , STRING , null ) ; report DOM Error ( error Handler , error , locator , msg , DOM Error . SEVERITY ERROR , STRING ) ; } } } } } }
public void characters ( char ch [ ] , int start , int length ) { if ( title Pending ) { title . append ( ch , start , length ) ; } else if ( desc Pending ) { desc . append ( ch , start , length ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
private void close Injector Resource ( Shard Id shard Id , Injector shard Injector , Class < ? extends Closeable > ... to Close ) { for ( Class < ? extends Closeable > closeable : to Close ) { if ( close Injector Optional Resource ( shard Id , shard Injector , closeable ) == BOOL ) { logger . warn ( STRING , shard Id , closeable . get Simple Name ( ) ) ; } } }
public final void increment Id Counter To ( int id ) { int diff = id - m Id Counter . get ( ) ; if ( diff < NUM ) return ; m Id Counter . add And Get ( diff ) ; update Shared Preference ( ) ; }
private static int clear Branding Resource Map Cache ( Content Resolver cr , long provider Id ) { String Builder where = new String Builder ( ) ; where . append ( Imps . Branding Resource Map Cache . PROVIDER ID ) ; where . append ( STRING ) ; where . append ( provider Id ) ; return cr . delete ( Imps . Branding Resource Map Cache . CONTENT URI , where . to String ( ) , null ) ; }
protected int check Last Login ( ) { Date Format formatter = new Simple Date Format ( STRING ) ; Date now = new Date ( ) ; Date login Time = null ; String last Login Enc = null ; String last Login = null ; String saved User Name = null ; int ret Val = NUM ; if ( time Since Last Login Attribute != null ) { Http Servlet Request req = get Http Servlet Request ( ) ; if ( req != null ) { Cookie cookie = Cookie Utils . get Cookie From Req ( req , time Since Last Login Attribute ) ; if ( cookie != null ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING , ADAPTIVE , time Since Last Login Attribute ) ; } last Login Enc = Cookie Utils . get Cookie Value ( cookie ) ; last Login = Access Controller . do Privileged ( new Decode Action ( last Login Enc ) ) ; } if ( last Login != null ) { String [ ] tokens = last Login . split ( STRING ) ; if ( tokens . length == NUM ) { last Login = tokens [ NUM ] ; saved User Name = tokens [ NUM ] ; } if ( ! user Name . equals Ignore Case ( saved User Name ) ) { last Login = null ; } if ( last Login != null ) { try { login Time = formatter . parse ( last Login ) ; if ( ( now . get Time ( ) - login Time . get Time ( ) ) < time Since Last Login Value * NUM * NUM * NUM * NUM ) { ret Val = time Since Last Login Score ; } } catch ( Parse Exception pe ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING , ADAPTIVE , last Login , pe ) ; } } } } } if ( time Since Last Login Save ) { post Auth N Map . put ( STRING , time Since Last Login Attribute ) ; last Login = formatter . format ( now ) ; last Login = UUID . random UUID ( ) + STRING + last Login + STRING + user Name ; last Login Enc = Access Controller . do Privileged ( new Encode Action ( last Login ) ) ; post Auth N Map . put ( STRING , last Login Enc ) ; } } if ( ! time Since Last Login Invert ) { ret Val = time Since Last Login Score - ret Val ; } return ret Val ; }
public byte [ ] to Byte Array ( ) { final int out Len = nonce . length + ( Long . SIZE / Byte . SIZE ) ; final Byte Buffer out = Byte Buffer . allocate ( out Len ) ; out . put ( nonce ) ; out . put Long ( content Length ) ; return out . array ( ) ; }
public void add Interface ( CP ifc ) { add CP Item ( ifc ) ; interfaces . add Element ( ifc ) ; }
public Builder add Constraint ( @ Job Constraint int constraint ) { int [ ] new Constraints = new int [ m Constraints == null ? NUM : m Constraints . length + NUM ] ; if ( m Constraints != null && m Constraints . length != NUM ) { System . arraycopy ( m Constraints , NUM , new Constraints , NUM , m Constraints . length ) ; } new Constraints [ new Constraints . length - NUM ] = constraint ; m Constraints = new Constraints ; return this ; }
void cleanup Parameters ( String relay State ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + relay State ) ; } relay State Map . remove ( relay State ) ; user Session Map . remove ( relay State ) ; user ID Map . remove ( relay State ) ; is SOAP Initiated Map . remove ( relay State ) ; is SOAP Initiated Map . remove ( relay State ) ; is IDP Initiated Map . remove ( relay State ) ; orig Protocol Map . remove ( relay State ) ; protocol List Map . remove ( relay State ) ; realm Map . remove ( relay State ) ; idp Entity ID Map . remove ( relay State ) ; sp Entity ID Map . remove ( relay State ) ; slo Request XML Map . remove ( relay State ) ; slo Response XML Map . remove ( relay State ) ; current Status Map . remove ( relay State ) ; }
private boolean extra Entity ( String output String , int char To Map ) { boolean extra = BOOL ; if ( char To Map < ASCII MAX ) { switch ( char To Map ) { case STRING : if ( ! output String . equals ( STRING ) ) extra = BOOL ; break ; case STRING : if ( ! output String . equals ( STRING ) ) extra = BOOL ; break ; case STRING : if ( ! output String . equals ( STRING ) ) extra = BOOL ; break ; case STRING : if ( ! output String . equals ( STRING ) ) extra = BOOL ; break ; default : extra = BOOL ; } } return extra ; }
protected void draw Point ( Graphics 2 D g , Point Style point Style , double x , double y , Color color , Color border Color ) { Shape point Shape = point Style . create Shape ( x , y ) ; g . set Color ( color ) ; g . fill ( point Shape ) ; g . set Color ( border Color ) ; g . draw ( point Shape ) ; }
public void test And Not Neg Neg First Longer ( ) { byte a Bytes [ ] = { - NUM , NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , - NUM } ; byte b Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . and Not ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
int retry Time ( ) { return retry Time . decrement And Get ( ) ; }
public Datepicker Combo ( final Composite parent , final int style ) { this ( parent , style , Date Format . get Date Time Instance ( ) ) ; }
public void test Pow Positive Num ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , NUM , NUM , NUM , - NUM , - NUM , NUM } ; int a Sign = NUM ; int exp = NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , NUM , - NUM , - NUM , NUM , - NUM , NUM , - NUM , NUM , - NUM , - NUM , NUM , - NUM , NUM , - NUM , NUM , - NUM , - NUM , - NUM , - NUM , NUM , - NUM , - NUM , - NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , - NUM , NUM , - NUM , NUM , - NUM , - NUM , NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . pow ( exp ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
protected void draw Mark Hilighted ( Graphics 2 D g2 , float x , float y ) { Rectangle 2 D bounds = mark . get Bounds 2 D ( ) ; float w = ( float ) bounds . get Width ( ) ; float h = ( float ) bounds . get Height ( ) ; x = x - ( w / NUM ) ; y = y - ( h / NUM ) ; g2 . translate ( x , y ) ; if ( hilighted Mark Fill Paint != null ) { g2 . set Paint ( hilighted Mark Fill Paint ) ; g2 . fill ( mark ) ; } g2 . set Paint ( hilighted Mark Paint ) ; g2 . set Stroke ( hilighted Mark Stroke ) ; g2 . draw ( mark ) ; g2 . translate ( - x , - y ) ; Rectangle 2 D rect = new Rectangle 2 D . Float ( x , y , w , h ) ; mark Bounds . add ( rect ) ; }
public static String trim Trailing Whitespace ( String str ) { if ( ! has Length ( str ) ) { return str ; } String Builder sb = new String Builder ( str ) ; while ( sb . length ( ) > NUM && Character . is Whitespace ( sb . char At ( sb . length ( ) - NUM ) ) ) { sb . delete Char At ( sb . length ( ) - NUM ) ; } return sb . to String ( ) ; }
private static Mks Ticket Response check Get Mks Ticket Response ( Mks Ticket Response mks Ticket Response ) throws Rpc Exception { logger . info ( STRING , mks Ticket Response ) ; switch ( mks Ticket Response . get Result ( ) ) { case OK : break ; case SYSTEM ERROR : throw new System Error Exception ( mks Ticket Response . get Error ( ) ) ; case VM NOT FOUND : throw new Vm Not Found Exception ( mks Ticket Response . get Error ( ) ) ; case INVALID VM POWER STATE : throw new Invalid Vm Power State Exception ( mks Ticket Response . get Error ( ) ) ; default : throw new Rpc Exception ( String . format ( STRING , mks Ticket Response . get Result ( ) ) ) ; } return mks Ticket Response ; }
@ Not Null default B append ( double d , int decimal Places ) throws Buffer Overflow Exception { if ( decimal Places < NUM ) { double d2 = d * Maths . tens ( decimal Places ) ; if ( d2 <= Long . MAX VALUE && d2 >= Long . MIN VALUE ) { return append Decimal ( Math . round ( d2 ) , decimal Places ) ; } } return append ( d ) ; }
public Completable Future < T > complete Async ( Supplier < ? extends T > supplier , Executor executor ) { if ( supplier == null || executor == null ) throw new Null Pointer Exception ( ) ; executor . execute ( new Async Supply < T > ( this , supplier ) ) ; return this ; }
private Movie Subtitle Chooser Model ( ) { name = BUNDLE . get String ( STRING ) ; }
protected Suballocated Int Vector find Namespace Context ( int element Node Index ) { if ( null != m namespace Decl Set Elements ) { int would Be At = find In Sorted Suballocated Int Vector ( m namespace Decl Set Elements , element Node Index ) ; if ( would Be At >= NUM ) return ( Suballocated Int Vector ) m namespace Decl Sets . element At ( would Be At ) ; if ( would Be At == - NUM ) return null ; would Be At = - NUM - would Be At ; int candidate = m namespace Decl Set Elements . element At ( -- would Be At ) ; int ancestor = parent ( element Node Index ) ; if ( would Be At == NUM && candidate < ancestor ) { int root Handle = get Document Root ( make Node Handle ( element Node Index ) ) ; int root ID = make Node Identity ( root Handle ) ; int uppermost NS Candidate ID ; if ( get Node Type ( root Handle ) == DTM . DOCUMENT NODE ) { int ch = firstch ( root ID ) ; uppermost NS Candidate ID = ( ch != DTM . NULL ) ? ch : root ID ; } else { uppermost NS Candidate ID = root ID ; } if ( candidate == uppermost NS Candidate ID ) { return ( Suballocated Int Vector ) m namespace Decl Sets . element At ( would Be At ) ; } } while ( would Be At >= NUM && ancestor > NUM ) { if ( candidate == ancestor ) { return ( Suballocated Int Vector ) m namespace Decl Sets . element At ( would Be At ) ; } else if ( candidate < ancestor ) { do { ancestor = parent ( ancestor ) ; } while ( candidate < ancestor ) ; } else if ( would Be At > NUM ) { candidate = m namespace Decl Set Elements . element At ( -- would Be At ) ; } else break ; } } return null ; }
public static java . sql . Timestamp now Timestamp ( ) { return get Timestamp ( System . current Time Millis ( ) ) ; }
public int diff common Suffix ( String text 1 , String text 2 ) { int text 1 length = text 1 . length ( ) ; int text 2 length = text 2 . length ( ) ; int n = Math . min ( text 1 length , text 2 length ) ; for ( int i = NUM ; i <= n ; i ++ ) { if ( text 1 . char At ( text 1 length - i ) != text 2 . char At ( text 2 length - i ) ) { return i - NUM ; } } return n ; }
private void translate Matrix After Rotate ( int axis , float trans , float prev Image Size , float image Size , int prev View Size , int view Size , int drawable Size ) { if ( image Size < view Size ) { m [ axis ] = ( view Size - ( drawable Size * m [ Matrix . MSCALE X ] ) ) * NUM ; } else if ( trans > NUM ) { m [ axis ] = - ( ( image Size - view Size ) * NUM ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM * prev View Size ) ) / prev Image Size ; m [ axis ] = - ( ( percentage * image Size ) - ( view Size * NUM ) ) ; } }
private void revoke Encrypt Policy ( org . wso 2 . emm . agent . beans . Operation operation ) { boolean encrypt Status = ( device Policy Manager . get Storage Encryption Status ( ) != device Policy Manager . ENCRYPTION STATUS UNSUPPORTED && ( device Policy Manager . get Storage Encryption Status ( ) == device Policy Manager . ENCRYPTION STATUS ACTIVE || device Policy Manager . get Storage Encryption Status ( ) == device Policy Manager . ENCRYPTION STATUS ACTIVATING ) ) ; if ( operation . is Enabled ( ) && encrypt Status ) { device Policy Manager . set Storage Encryption ( device Admin , BOOL ) ; } }
public JSON Buffer close Hash ( ) { if ( stack . empty ( ) || stack . peek ( ) != Operand . HASH ) { throw new JSON Exception ( STRING ) ; } remove Separator ( ) ; buffer . append ( STRING ) ; stack . pop ( ) ; add Separator ( ) ; return this ; }
private static byte [ ] generate Seed ( ) { try { Byte Array Output Stream seed Buffer = new Byte Array Output Stream ( ) ; Data Output Stream seed Buffer Out = new Data Output Stream ( seed Buffer ) ; seed Buffer Out . write Long ( System . current Time Millis ( ) ) ; seed Buffer Out . write Long ( System . nano Time ( ) ) ; seed Buffer Out . write ( BUILD FINGERPRINT AND DEVICE SERIAL ) ; seed Buffer Out . close ( ) ; return seed Buffer . to Byte Array ( ) ; } catch ( IO Exception e ) { throw new Security Exception ( STRING , e ) ; } }
private void init ( Snmp Mib my Mib ) { if ( debug == null ) { final Key < Debug > key = Key . get ( Debug . class , Names . named ( Core Token Constants . CTS MONITOR DEBUG ) ) ; debug = Injector Holder . get Instance ( key ) ; } final List < Operation Entry > operation Entries = new Array List < Operation Entry > ( ) ; final List < Token Entry > token Entries = new Array List < Token Entry > ( ) ; for ( Enum e : crud Items ) { final Operation Entry entry = new Operation Entry ( my Mib ) ; entry . Operation Type = e . name ( ) ; entry . Operation Table Index = ( long ) e . ordinal ( ) + NUM ; operation Entries . add ( entry ) ; } for ( Enum e : token Items ) { final Token Entry entry = new Token Entry ( my Mib ) ; entry . Token Type = e . name ( ) ; entry . Token Table Index = ( long ) e . ordinal ( ) + NUM ; token Entries . add ( entry ) ; } try { for ( Operation Entry ce : operation Entries ) { Operation Table . add Entry ( ce ) ; } for ( Token Entry te : token Entries ) { Token Table . add Entry ( te ) ; } create CRUD Operations Per Token Type Table ( my Mib , Cts CRUD Operations Per Token Type Table , operation Entries , token Entries ) ; create CRUD Operations Table ( my Mib , Cts CRUD Operations Table , operation Entries ) ; create Token Operations Table ( my Mib , Cts Token Operations Table , token Entries ) ; } catch ( Snmp Status Exception e ) { if ( debug . message Enabled ( ) ) { debug . error ( STRING , e ) ; } } }
@ Override public void disconnection Notification ( String event Name , Object source ) { m listenees . remove ( source ) ; if ( m listenees . size ( ) == NUM ) { m listenee Types . clear ( ) ; } }
public X509 Name ( Vector oids , Vector values ) { this ( oids , values , new X509 Default Entry Converter ( ) ) ; }
@ Override public To Double Function < Stream < Tuple 2 < F , Double > > > dist ( Stream < Tuple 2 < F , Double > > features 1 ) { Object 2 Double Map < F > aux Map = new Object 2 Double Open Hash Map < > ( ) ; aux Map . default Return Value ( NUM ) ; Double Adder norm 1 = new Double Adder ( ) ; features 1 . for Each ( null ) ; if ( norm 1 . double Value ( ) == NUM ) { return null ; } return null ; }
public Load Metadata Details [ ] read Load Metadata ( String table Folder Path ) { Gson gson Object To Read = new Gson ( ) ; Data Input Stream data Input Stream = null ; Buffered Reader buff Reader = null ; Input Stream Reader in Stream = null ; String metadata File Name = table Folder Path + Carbon Common Constants . FILE SEPARATOR + Carbon Common Constants . LOADMETADATA FILENAME ; Load Metadata Details [ ] list Of Load Folder Details Array ; Atomic File Operations file Operation = new Atomic File Operations Impl ( metadata File Name , File Factory . get File Type ( metadata File Name ) ) ; try { if ( ! File Factory . is File Exist ( metadata File Name , File Factory . get File Type ( metadata File Name ) ) ) { return new Load Metadata Details [ NUM ] ; } data Input Stream = file Operation . open For Read ( ) ; in Stream = new Input Stream Reader ( data Input Stream , Charset . for Name ( Carbon Common Constants . DEFAULT CHARSET ) ) ; buff Reader = new Buffered Reader ( in Stream ) ; list Of Load Folder Details Array = gson Object To Read . from Json ( buff Reader , Load Metadata Details [ ] . class ) ; } catch ( IO Exception e ) { return new Load Metadata Details [ NUM ] ; } finally { close Streams ( buff Reader , in Stream , data Input Stream ) ; } return list Of Load Folder Details Array ; }
public String to Inner Html ( Node node , Appendable appendable ) { Node Visitor renderer = create Renderer ( appendable ) ; node . visit Children ( renderer ) ; return appendable . to String ( ) ; }
private void update Storage View Info ( V Plex Storage View Info storage View Info ) { V Plex Api Discovery Manager discovery Mgr = vplex Api Client . get Discovery Manager ( ) ; discovery Mgr . update Storage View Info ( storage View Info ) ; }
static List < String > decode All ( Collection < String > event Keys ) { List < String > event Ids = Lists . new Array List ( ) ; for ( String event Key : event Keys ) { decode To ( event Key , event Ids ) ; } return event Ids ; }
public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
private void replace Top ( Scope top Of Stack ) { stack . set ( stack . size ( ) - NUM , top Of Stack ) ; }
public void test Zero One ( ) { Big Integer a Number = Big Integer . ZERO ; Big Integer b Number = Big Integer . ONE ; Big Integer result = a Number . and ( b Number ) ; assert True ( result . equals ( Big Integer . ZERO ) ) ; assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public byte [ ] to Byte Array ( String ascii ) { if ( ascii == null ) { return EMPTY BYTE ARRAY ; } return from Ascii ( ascii . to Char Array ( ) ) ; }
public static boolean [ ] copy Of Range ( boolean [ ] original , int start , int end ) { if ( start <= end ) { if ( original . length >= start && NUM <= start ) { int length = end - start ; int copy Length = Math . min ( length , original . length - start ) ; boolean [ ] copy = new boolean [ length ] ; System . arraycopy ( original , start , copy , NUM , copy Length ) ; return copy ; } throw new Array Index Out Of Bounds Exception ( ) ; } throw new Illegal Argument Exception ( ) ; }
private void on Column Sync ( ) { int sync Position = Math . min ( m Sync Position , get Count ( ) - NUM ) ; Sparse Array < Double > position Height Ratios = new Sparse Array < Double > ( sync Position ) ; for ( int pos = NUM ; pos < sync Position ; pos ++ ) { final Grid Item Record rec = m Position Data . get ( pos ) ; if ( rec == null ) break ; Log . d ( TAG , STRING + pos + STRING + rec . height Ratio ) ; position Height Ratios . append ( pos , rec . height Ratio ) ; } m Position Data . clear ( ) ; if ( DBG ) Log . d ( TAG , STRING + m Column Width ) ; for ( int pos = NUM ; pos < sync Position ; pos ++ ) { final Grid Item Record rec = get Or Create Record ( pos ) ; final double height Ratio = position Height Ratios . get ( pos ) ; final int height = ( int ) ( m Column Width * height Ratio ) ; rec . height Ratio = height Ratio ; int top ; int bottom ; if ( is Header Or Footer ( pos ) ) { top = get Lowest Positioned Bottom ( ) ; bottom = top + height ; for ( int i = NUM ; i < m Column Count ; i ++ ) { m Column Tops [ i ] = top ; m Column Bottoms [ i ] = bottom ; } } else { final int column = get Highest Positioned Bottom Column ( ) ; top = m Column Bottoms [ column ] ; bottom = top + height + get Child Top Margin ( pos ) + get Child Bottom Margin ( ) ; m Column Tops [ column ] = top ; m Column Bottoms [ column ] = bottom ; rec . column = column ; } if ( DBG ) Log . d ( TAG , STRING + pos + STRING + top + STRING + bottom + STRING + height + STRING + height Ratio ) ; } final int sync Column = get Highest Positioned Bottom Column ( ) ; set Position Column ( sync Position , sync Column ) ; int sync To Bottom = m Column Bottoms [ sync Column ] ; int offset = - sync To Bottom + m Specific Top ; offset All Columns Top And Bottom ( offset ) ; m Distance To Top = - sync To Bottom ; System . arraycopy ( m Column Bottoms , NUM , m Column Tops , NUM , m Column Count ) ; }
private static Map < Direction , Sprite [ ] > split Tiles ( Sprite Store st , Sprite orig ) { int twidth = NUM ATTACK FRAMES * TILE SIZE ; int theight = NUM * TILE SIZE ; Map < Direction , Sprite [ ] > map = new Enum Map < Direction , Sprite [ ] > ( Direction . class ) ; int y = NUM ; map . put ( Direction . UP , st . get Tiles ( orig , NUM , y , NUM ATTACK FRAMES , twidth , theight ) ) ; y += theight ; map . put ( Direction . RIGHT , st . get Tiles ( orig , NUM , y , NUM ATTACK FRAMES , twidth , theight ) ) ; y += theight ; map . put ( Direction . DOWN , st . get Tiles ( orig , NUM , y , NUM ATTACK FRAMES , twidth , theight ) ) ; y += theight ; map . put ( Direction . LEFT , st . get Tiles ( orig , NUM , y , NUM ATTACK FRAMES , twidth , theight ) ) ; return map ; }
void increment Schema ( String schema Name ) { if ( schema Name != null ) { Integer count = db Map . get ( schema Name ) ; if ( count == null ) db Map . put ( schema Name , NUM ) ; else db Map . put ( schema Name , count . int Value ( ) + NUM ) ; } last Db = schema Name ; }
private String build Event Data ( ) throws JAXB Exception { if ( event Parameters != null ) { try { JAXB Context jaxb Context = JAXB Context . new Instance ( Event Parameters . class ) ; Marshaller marshaller = jaxb Context . create Marshaller ( ) ; marshaller . set Property ( Marshaller . JAXB FORMATTED OUTPUT , BOOL ) ; Writer out Writer = new String Writer ( ) ; Stream Result result = new Stream Result ( out Writer ) ; marshaller . marshal ( event Parameters , result ) ; return out Writer . to String ( ) ; } catch ( JAXB Exception e ) { log . error ( STRING + e . get Message ( ) ) ; throw e ; } } else { return null ; } }
public boolean is Projected ( ) { return projected ; }
private boolean normalize Attr Value ( XML Attributes attributes , int index ) { boolean leading Space = BOOL ; boolean space Start = BOOL ; boolean reading Non Space = BOOL ; int count = NUM ; int eaten = NUM ; String attr Value = attributes . get Value ( index ) ; char [ ] att Value = new char [ attr Value . length ( ) ] ; f Buffer . set Length ( NUM ) ; attr Value . get Chars ( NUM , attr Value . length ( ) , att Value , NUM ) ; for ( int i = NUM ; i < att Value . length ; i ++ ) { if ( att Value [ i ] == STRING ) { if ( reading Non Space ) { space Start = BOOL ; reading Non Space = BOOL ; } if ( space Start && ! leading Space ) { space Start = BOOL ; f Buffer . append ( att Value [ i ] ) ; count ++ ; } else { if ( leading Space || ! space Start ) { eaten ++ ; } } } else { reading Non Space = BOOL ; space Start = BOOL ; leading Space = BOOL ; f Buffer . append ( att Value [ i ] ) ; count ++ ; } } if ( count > NUM && f Buffer . char At ( count - NUM ) == STRING ) { f Buffer . set Length ( count - NUM ) ; } String new Value = f Buffer . to String ( ) ; attributes . set Value ( index , new Value ) ; return ! attr Value . equals ( new Value ) ; }
private Shape decode Mark Interior ( int width , int height ) { double left = width / NUM - NUM ; double top = height / NUM - NUM ; path . reset ( ) ; path . move To ( left + NUM , top + NUM ) ; path . line To ( left + NUM , top + NUM ) ; path . line To ( left + NUM , top + NUM ) ; path . close Path ( ) ; return path ; }
public Monotone Solver ( final I Lattice Graph < Graph Node > graph , final Lattice lattice , final I State Vector < Graph Node , Lattice Element > start Vector , final I Transformation Provider < Graph Node , Lattice Element > transformation Provider , final I Graph Walker < Graph Node , Object Type > walker ) { if ( graph == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( lattice == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( start Vector == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( transformation Provider == null ) { throw new Illegal Argument Exception ( STRING ) ; } final List < Graph Node > nodes = graph . get Nodes ( ) ; if ( nodes . size ( ) != start Vector . size ( ) ) { throw new Illegal Argument Exception ( String . format ( STRING , start Vector . size ( ) , nodes . size ( ) ) ) ; } for ( final Graph Node node : nodes ) { if ( ! start Vector . has State ( node ) ) { throw new Illegal Argument Exception ( STRING + node + STRING ) ; } } this . graph = graph ; this . lattice = lattice ; this . state = start Vector ; this . transformation List = transformation Provider ; this . walker = walker ; }
private Stat prepare Port Stat Info ( String native Id , URI resource Id , long iops , long time Sample ) { Stat ip Port Stat = new Stat ( ) ; ip Port Stat . set Service Type ( Constants . File ) ; ip Port Stat . set Time Collected ( time Sample ) ; ip Port Stat . set Resource Id ( resource Id ) ; ip Port Stat . set Native Guid ( native Id ) ; ip Port Stat . set Total I Os ( iops ) ; return ip Port Stat ; }
public void test Insert 3 ( ) throws SQL Exception { Database Creator . fill Parent Table ( conn ) ; Database Creator . fill FK Strict Table ( conn ) ; statement . execute ( STRING + Database Creator . TEST TABLE 5 + STRING + STRING + Database Creator . FKSTRICT TABLE + STRING ) ; Result Set r = statement . execute Query ( STRING + Database Creator . TEST TABLE 5 ) ; r . next ( ) ; assert Equals ( STRING , NUM , r . get Int ( NUM ) ) ; r . close ( ) ; }
public int compare To ( App Version other ) { int result = major - other . major ; if ( result == NUM ) { result = minor - other . minor ; } if ( result == NUM ) { result = patch - other . patch ; } if ( result == NUM && ( milestone > - NUM || other . milestone > - NUM ) ) { if ( milestone > - NUM ) { if ( other . milestone == - NUM ) { result = - NUM ; } else { result = milestone - other . milestone ; } } else { if ( other . milestone > - NUM ) { result = NUM ; } } } if ( result == NUM && ! Object Util . null Equals ( modifier , other . modifier ) ) { if ( modifier == null ) { result = NUM ; } else if ( other . modifier == null ) { result = - NUM ; } else { result = modifier . compare To Ignore Case ( other . modifier ) ; } } return result ; }
public Stream Consumer ( Input Stream stream , String charset ) { in = new Buffered Input Stream ( stream ) ; this . charset = charset ; thread . start ( ) ; }
public Media Size ( int x , int y , int units ) { super ( x , y , units ) ; if ( x > y ) { throw new Illegal Argument Exception ( STRING ) ; } size Vector . add ( this ) ; }
private Peer construct Peer Pojo ( final Peer Data peer Data ) throws Peer Exception { Preconditions . check Not Null ( peer Data , STRING ) ; try { Peer Info peer Info = from Json ( peer Data . get Info ( ) , Peer Info . class ) ; if ( local Peer Id . equals ( peer Data . get Id ( ) ) ) { local Peer . set Peer Info ( peer Info ) ; return local Peer ; } Remote Peer Impl remote Peer = new Remote Peer Impl ( local Peer Id , security Manager , peer Info , messenger , command Response Listener , message Response Listener , provider , this ) ; Relation Info Meta relation Info Meta = new Relation Info Meta ( ) ; Map < String , String > traits = relation Info Meta . get Relation Traits ( ) ; traits . put ( STRING , STRING ) ; traits . put ( STRING , STRING ) ; traits . put ( STRING , STRING ) ; User peer Owner = identity Manager . get User By Key Id ( identity Manager . get Peer Owner Id ( ) ) ; Relation Meta relation Meta = new Relation Meta ( peer Owner , local Peer , remote Peer , local Peer . get Key Id ( ) ) ; Relation relation = relation Manager . build Relation ( relation Info Meta , relation Meta ) ; relation . set Relation Status ( Relation Status . VERIFIED ) ; relation Manager . save Relation ( relation ) ; return remote Peer ; } catch ( Exception e ) { throw new Peer Exception ( STRING , e ) ; } }
public void load Workspace Contents ( String xml ) throws Blockly Parser Exception { load Workspace Contents ( new Byte Array Input Stream ( xml . get Bytes ( ) ) ) ; }
private boolean compare And Decrement Worker Count ( int expect ) { return ctl . compare And Set ( expect , expect - NUM ) ; }
public boolean load ( String file Location , int type ) { if ( m Has Loaded ) { return BOOL ; } String shader Code ; try { shader Code = Shader Utils . get String From File In Assets ( m Context , file Location , BOOL ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; m Is Compiled = BOOL ; return BOOL ; } m Has Loaded = BOOL ; m Shader Id = GLES 20 . gl Create Shader ( type ) ; if ( m Shader Id == NUM ) { String msg = ( type == GLES 20 . GL VERTEX SHADER ? STRING : STRING ) ; Log . e ( TAG , STRING + msg ) ; return BOOL ; } GLES 20 . gl Shader Source ( m Shader Id , shader Code ) ; GLES 20 . gl Compile Shader ( m Shader Id ) ; int [ ] compile Status = new int [ NUM ] ; GLES 20 . gl Get Shaderiv ( m Shader Id , GLES 20 . GL COMPILE STATUS , compile Status , NUM ) ; m Is Compiled = ( compile Status [ NUM ] == GLES 20 . GL TRUE ) ; if ( ! m Is Compiled ) { String compile Error = GLES 20 . gl Get Shader Info Log ( m Shader Id ) ; Log . e ( TAG , compile Error ) ; GLES 20 . gl Delete Shader ( m Shader Id ) ; } return m Is Compiled && m Has Loaded ; }
public void add Child ( Pdf Layer child Layer ) { if ( child Layer . parent != null ) throw new Illegal Argument Exception ( STRING ) ; child Layer . parent = this ; if ( children == null ) children = new Array List < > ( ) ; children . add ( child Layer ) ; }
protected void move Randomly ( OM Point point , double factor , Projection proj ) { double hor = Math . random ( ) - NUM ; double vert = Math . random ( ) - NUM ; Point 2 D map Point = proj . forward ( point . get Lat ( ) , point . get Lon ( ) ) ; map Point . set Location ( map Point . get X ( ) + ( hor * factor ) , map Point . get Y ( ) + ( vert * factor ) ) ; Point 2 D llp = proj . inverse ( map Point ) ; point . set Lat ( llp . get Y ( ) ) ; point . set Lon ( llp . get X ( ) ) ; }
private void initialize Context ( ) throws IO Exception { String working Dir = System . get Property ( STRING ) ; File dataset = File Utils . get File ( working Dir + STRING ) ; File log 4 j File = File Utils . get File ( working Dir + STRING ) ; File dataset Folder = new File ( destination Folder + STRING ) ; File log 4 j Folder = new File ( destination Folder + STRING ) ; dataset . mkdirs ( ) ; log 4 j File . mkdirs ( ) ; File Utils . copy File To Directory ( dataset , dataset Folder ) ; File Utils . copy File To Directory ( log 4 j File , log 4 j Folder ) ; }
protected boolean is Token Char ( char ch ) { if ( Character . is Letter Or Digit ( ch ) ) return BOOL ; if ( Character . is ISO Control ( ch ) ) return BOOL ; if ( is Http Separator ( ch ) ) return BOOL ; return BOOL ; }
public static int parse Int ( FXG Node node , String value , String name ) { try { return Integer . parse Int ( value ) ; } catch ( Number Format Exception e ) { throw new FXG Exception ( node . get Start Line ( ) , node . get Start Column ( ) , STRING , name , value ) ; } }
public static double inv Sqrt Quick ( final double value ) { if ( USE JDK MATH ) { return NUM / Math . sqrt ( value ) ; } return Double . long Bits To Double ( NUM - ( Double . double To Raw Long Bits ( value ) > > NUM ) ) ; }
public void close ( ) throws IO Exception { article Idx Writer . close ( ) ; chrono Idx Writer . close ( ) ; revision Idx Writer . close ( ) ; }
private final byte [ ] zero Extend ( byte [ ] data To Pad ) { assert null != data To Pad ; final int target Length = NUM ; if ( target Length <= data To Pad . length ) return data To Pad ; byte padded [ ] = new byte [ target Length ] ; for ( int i = NUM ; i < data To Pad . length ; i ++ ) padded [ i ] = data To Pad [ i ] ; for ( int i = data To Pad . length ; i < padded . length ; i ++ ) padded [ i ] = ( byte ) NUM ; return padded ; }
public void apply From Resolve Info ( Package Manager pm , Resolve Info info , Widget Preview Loader loader ) { m Info = info ; Char Sequence label = info . load Label ( pm ) ; m Widget Name . set Text ( label ) ; m Widget Dims . set Text ( String . format ( m Dimensions Format String , NUM , NUM ) ) ; m Widget Preview Loader = loader ; }
private static boolean is Certificate Entry ( String alias ) throws Key Store Exception { return s Key Store . is Certificate Entry ( alias ) ; }
public void test unwrap 06 ( ) { String host = STRING ; int port = NUM ; Byte Buffer [ ] bb A = { Byte Buffer . allocate ( NUM ) , Byte Buffer . allocate ( NUM ) , Byte Buffer . allocate ( NUM ) } ; Byte Buffer bb = Byte Buffer . allocate ( NUM ) ; SSL Engine sse = get Engine ( host , port ) ; sse . set Use Client Mode ( BOOL ) ; try { SSL Engine Result res = sse . unwrap ( bb , bb A , NUM , bb A . length ) ; assert Equals ( NUM , res . bytes Consumed ( ) ) ; assert Equals ( NUM , res . bytes Produced ( ) ) ; } catch ( Exception ex ) { fail ( STRING + ex ) ; } }
public static Window window For Word In Position ( int window Size , int word Pos , List < String > sentence ) { List < String > window = new Array List < > ( ) ; List < String > only Tokens = new Array List < > ( ) ; int context Size = ( int ) Math . floor ( ( window Size - NUM ) / NUM ) ; for ( int i = word Pos - context Size ; i <= word Pos + context Size ; i ++ ) { if ( i < NUM ) window . add ( STRING ) ; else if ( i >= sentence . size ( ) ) window . add ( STRING ) ; else { only Tokens . add ( sentence . get ( i ) ) ; window . add ( sentence . get ( i ) ) ; } } String whole Sentence = String Utils . join ( sentence ) ; String window 2 = String Utils . join ( only Tokens ) ; int begin = whole Sentence . index Of ( window 2 ) ; int end = begin + window 2 . length ( ) ; return new Window ( window , begin , end ) ; }
private void fill In ( Class Symbol c ) { if ( completion Failure Name == c . fullname ) { throw new Completion Failure ( c , STRING ) ; } current Owner = c ; warned Attrs . clear ( ) ; Java File Object classfile = c . classfile ; if ( classfile != null ) { Java File Object previous Class File = current Class File ; try { if ( filling ) { Assert . error ( STRING + classfile . to Uri ( ) + STRING + previous Class File ) ; } current Class File = classfile ; if ( verbose ) { log . print Verbose ( STRING , current Class File . to String ( ) ) ; } if ( classfile . get Kind ( ) == Java File Object . Kind . CLASS ) { filling = BOOL ; try { bp = NUM ; buf = read Input Stream ( buf , classfile . open Input Stream ( ) ) ; read Class File ( c ) ; if ( ! missing Type Variables . is Empty ( ) && ! found Type Variables . is Empty ( ) ) { List < Type > missing = missing Type Variables ; List < Type > found = found Type Variables ; missing Type Variables = List . nil ( ) ; found Type Variables = List . nil ( ) ; filling = BOOL ; Class Type ct = ( Class Type ) current Owner . type ; ct . supertype field = types . subst ( ct . supertype field , missing , found ) ; ct . interfaces field = types . subst ( ct . interfaces field , missing , found ) ; } else if ( missing Type Variables . is Empty ( ) != found Type Variables . is Empty ( ) ) { Name name = missing Type Variables . head . tsym . name ; throw bad Class File ( STRING , name ) ; } } finally { missing Type Variables = List . nil ( ) ; found Type Variables = List . nil ( ) ; filling = BOOL ; } } else { if ( source Completer != null ) { source Completer . complete ( c ) ; } else { throw new Illegal State Exception ( STRING + classfile . to Uri ( ) ) ; } } return ; } catch ( IO Exception ex ) { throw bad Class File ( STRING , ex . get Message ( ) ) ; } finally { current Class File = previous Class File ; } } else { JC Diagnostic diag = diag Factory . fragment ( STRING , c . flatname ) ; throw new Completion Failure ( c , diag ) ; } }
public void enable ( ) { List < Entry > entries = remove Intersected Entries ( tree . get Selected Entries ( ) ) ; boolean enable = BOOL ; for ( Entry entry : entries ) { if ( entry == null ) { enable = BOOL ; break ; } if ( ! required Selection Type . is Instance ( entry ) ) { enable = BOOL ; break ; } if ( needs Write Access && entry . is Read Only ( ) ) { enable = BOOL ; break ; } } if ( entries . is Empty ( ) ) { enable = BOOL ; } set Enabled ( enable ) ; }
public String to String ( ) { String Buffer buffer = new String Buffer ( ) ; if ( get Name ( ) != null ) { buffer . append ( get Name ( ) ) ; } buffer . append ( STRING ) ; if ( get Enclosing Type Name ( ) != null ) { buffer . append ( get Enclosing Type Name ( ) ) ; } buffer . append ( STRING ) ; if ( get Source Name ( ) != null ) { buffer . append ( get Source Name ( ) ) ; } return buffer . to String ( ) ; }
protected void mark ( ) throws Compilation Failed Exception { apply To Source Units ( mark ) ; }
private boolean label To Keep Rec ( Node v , Set < Integer > ids , Node Set keep ) { boolean has Below = BOOL ; int id = ( Integer ) v . get Info ( ) ; if ( ids . size ( ) == NUM || ids . contains ( id ) ) has Below = BOOL ; for ( Edge e = v . get First Out Edge ( ) ; e != null ; e = v . get Next Out Edge ( e ) ) { Node w = e . get Target ( ) ; if ( label To Keep Rec ( w , ids , keep ) ) has Below = BOOL ; } if ( has Below ) keep . add ( v ) ; return has Below ; }
public void put External Property ( SSO Token client Token , String key , String value ) throws Session Exception { try { session Utils Wrapper . check Permission To Set Property ( client Token , key , value ) ; } catch ( Session Exception se ) { fire Session Event ( Session Event Type . PROTECTED PROPERTY ) ; session Logging . log Event ( to Session Info ( ) , Session Event Type . PROTECTED PROPERTY ) ; throw se ; } internal Put Property ( key , value ) ; debug . message ( STRING ) ; }
void add Edge ( Method Parameter in , Method Parameter out ) { Set < Method Parameter > outs = graph . get ( in ) ; if ( outs == null ) { outs = new Hash Set < > ( ) ; graph . put ( in , outs ) ; } outs . add ( out ) ; }
public static int [ ] random Number ( int n ) { int [ ] num = new int [ n ] ; for ( int i = NUM ; i < num . length ; i ++ ) { num [ i ] = ( int ) ( r Gen . next Double ( ) * NUM ) ; } return num ; }
public boolean is Device TV ( Context context ) { if ( Build . VERSION . SDK INT >= Build . VERSION CODES . LOLLIPOP ) { Ui Mode Manager ui Manager = ( Ui Mode Manager ) context . get System Service ( Context . UI MODE SERVICE ) ; return ui Manager != null && ui Manager . get Current Mode Type ( ) == Configuration . UI MODE TYPE TELEVISION ; } return BOOL ; }
protected void rcpt To Authors ( final Recipient Type rt ) { for ( final Account . Id id : authors ) { add ( rt , id ) ; } }
public Object create Shape Data ( Shape shape ) { return null ; }
private Protection Set create Protection Set ( Recover Point Volume Ingestion Context volume Context ) { Un Managed Protection Set umpset = volume Context . get Un Managed Protection Set ( ) ; Protection Set pset = Volume Ingestion Util . find Or Create Protection Set ( volume Context , volume Context . get Unmanaged Volume ( ) , umpset , db Client ) ; volume Context . set Managed Protection Set ( pset ) ; return pset ; }
public synchronized void dispose ( ) { if ( is Disposed ) { return ; } is Disposed = BOOL ; Array List < Pooled Connection > list = recycled Connections ; for ( int i = NUM , size = list . size ( ) ; i < size ; i ++ ) { close Connection ( list . get ( i ) ) ; } }
public static String append Parameter ( Ct Class type , String descriptor ) { int i = descriptor . index Of ( STRING ) ; if ( i < NUM ) return descriptor ; else { String Buffer newdesc = new String Buffer ( ) ; newdesc . append ( descriptor . substring ( NUM , i ) ) ; to Descriptor ( newdesc , type ) ; newdesc . append ( descriptor . substring ( i ) ) ; return newdesc . to String ( ) ; } }
public void write To ( byte [ ] bytes , int offset ) throws IO Exception { flush ( ) ; final long end = file . length ; long pos = NUM ; int buffer = NUM ; int bytes Upto = offset ; while ( pos < end ) { int length = BUFFER SIZE ; long next Pos = pos + length ; if ( next Pos > end ) { length = ( int ) ( end - pos ) ; } System . arraycopy ( file . get Buffer ( buffer ++ ) , NUM , bytes , bytes Upto , length ) ; bytes Upto += length ; pos = next Pos ; } }
protected int calcn Cluster ( ) { return NUM ; }
public static void validate Service Name ( String service Code , String service Name ) { if ( ! service Name . starts With ( service Code ) ) { throw new Coded Exception ( X INCONSISTENT HEADERS , STRING + STRING ) ; } }
protected static void init CMYK Colorspace ( ) { if ( ICC Profile For RGB == null ) { rgb Model = new Component Color Model ( rgb CS , new int [ ] { NUM , NUM , NUM } , BOOL , BOOL , Color Model . OPAQUE , Data Buffer . TYPE BYTE ) ; } else { final int comp Count = rgb CS . get Num Components ( ) ; final int [ ] values = new int [ comp Count ] ; for ( int i = NUM ; i < comp Count ; i ++ ) { values [ i ] = NUM ; } rgb Model = new Component Color Model ( rgb CS , values , BOOL , BOOL , Color Model . OPAQUE , Data Buffer . TYPE BYTE ) ; } final Fast Color Space CMYK cmyk CS = new Fast Color Space CMYK ( ) ; CS To RGB = new Color Convert Op ( cmyk CS , rgb CS , Color Spaces . hints ) ; }
private void add Notification Category Separator ( J Panel panel ) { J Separator jsep = new J Separator ( Swing Constants . HORIZONTAL ) ; jsep . set Maximum Size ( new Dimension ( Short . MAX VALUE , NUM ) ) ; panel . add ( jsep ) ; }
public void clear Dragged Operators ( ) { this . dragged Operators = Collections . unmodifiable List ( Collections . < Operator > empty List ( ) ) ; }
public Fake Clock reset Time ( ) { fake Now Ms . set ( base Time Ms ) ; return this ; }
public void remove Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners == null ) { return ; } m Update Listeners . remove ( listener ) ; if ( m Update Listeners . size ( ) == NUM ) { m Update Listeners = null ; } }
public GSER Parser ( Char Sequence value ) { Reject . check Not Null ( value ) ; this . gser Value = value . to String ( ) ; this . pos = NUM ; this . length = value . length ( ) ; }
public Slice ( double start , double end , boolean visible ) { this . start = start ; this . end = end ; this . visible = visible ; }
public static void inject To Target ( Object target , Bundle data ) { if ( target == null || data == null ) return ; Parcel Injector injector ; try { injector = get Injector By Class ( target . get Class ( ) ) ; injector . inject Data To Target ( target , data ) ; } catch ( Exception e ) { throw new Runtime Exception ( String . format ( STRING , e . get Message ( ) ) , e ) ; } }
public static boolean are Backend Initiators ( List < Initiator > initiators ) { boolean backend = BOOL ; for ( Initiator initiator : initiators ) { if ( ! Null Column Value Getter . is Null URI ( initiator . get Host ( ) ) && URI Util . is Type ( initiator . get Host ( ) , Host . class ) ) { backend = BOOL ; break ; } } return backend ; }
public boolean contains Value ( Object value ) { return map . contains Value ( value ) ; }
private void write Attribute ( java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( namespace . equals ( STRING ) ) { xml Writer . write Attribute ( att Name , att Value ) ; } else { register Prefix ( xml Writer , namespace ) ; xml Writer . write Attribute ( namespace , att Name , att Value ) ; } }
public boolean has Skins ( ) { return System . get Property ( STRING ) != null || System . get Property ( STRING ) != null ; }
public String to String ( ) { String Builder builder = new String Builder ( ) ; if ( type != null ) { name ( builder ) ; attributes ( builder ) ; } return builder . to String ( ) ; }
public void make Immutable ( ) { if ( ! is Immutable ) { overflow Entries = overflow Entries . is Empty ( ) ? Collections . < K , V > empty Map ( ) : Collections . unmodifiable Map ( overflow Entries ) ; is Immutable = BOOL ; } }
protected void parse Names ( ) { while ( reader . has Next Character ( ) ) { final char character = next ( ) ; if ( Strings . is Whitespace ( character ) ) { add Name ( ) ; continue ; } else if ( character == block Opening ) { add Name ( ) ; break ; } else { builder . append ( character ) ; } } if ( Gdx Arrays . is Empty ( tags ) ) { throw Exception ( STRING ) ; } }
protected void write Zip 64 Central Directory ( ) throws IO Exception { if ( zip 64 Mode == Zip 64 Mode . Never ) { return ; } if ( ! has Used Zip 64 && ( cd Offset >= ZIP 64 MAGIC || cd Length >= ZIP 64 MAGIC || entries . size ( ) >= ZIP 64 MAGIC SHORT ) ) { has Used Zip 64 = BOOL ; } if ( ! has Used Zip 64 ) { return ; } long offset = written ; write Out ( ZIP 64 EOCD SIG ) ; write Out ( Zip Eight Byte Integer . get Bytes ( SHORT + SHORT + WORD + WORD + DWORD + DWORD + DWORD + DWORD ) ) ; write Out ( Zip Short . get Bytes ( ZIP 64 MIN VERSION ) ) ; write Out ( Zip Short . get Bytes ( ZIP 64 MIN VERSION ) ) ; write Out ( LZERO ) ; write Out ( LZERO ) ; byte [ ] num = Zip Eight Byte Integer . get Bytes ( entries . size ( ) ) ; write Out ( num ) ; write Out ( num ) ; write Out ( Zip Eight Byte Integer . get Bytes ( cd Length ) ) ; write Out ( Zip Eight Byte Integer . get Bytes ( cd Offset ) ) ; write Out ( ZIP 64 EOCD LOC SIG ) ; write Out ( LZERO ) ; write Out ( Zip Eight Byte Integer . get Bytes ( offset ) ) ; write Out ( ONE ) ; }
public boolean is Cache Valid ( int row ) { return m valid . get ( row ) ; }
public void finish ( ) throws IO Exception { check Closed ( ) ; write ( ) ; }
public final void read Fully ( byte [ ] b , int off , int len ) throws java . io . IO Exception { if ( len < NUM ) { throw new Index Out Of Bounds Exception ( ) ; } int n = NUM ; while ( n < len ) { int count = read ( b , off + n , len - n ) ; if ( count < NUM ) { throw new EOF Exception ( ) ; } n += count ; } }
public SVG Rasterizer ( Input Stream istream ) { this . input = new Transcoder Input ( istream ) ; }
private static Future < ? > direct Execute ( Runnable runnable , int delay ) { Future < ? > future = null ; if ( delay > NUM ) { if ( ! ( executor instanceof Scheduled Executor Service ) ) { throw new Illegal Argument Exception ( STRING ) ; } Scheduled Executor Service scheduled Executor Service = ( Scheduled Executor Service ) executor ; future = scheduled Executor Service . schedule ( runnable , delay , Time Unit . MILLISECONDS ) ; } else { if ( executor instanceof Executor Service ) { Executor Service executor Service = ( Executor Service ) executor ; future = executor Service . submit ( runnable ) ; } else { executor . execute ( runnable ) ; } } return future ; }
@ Override public void on Patch Version Check Fail ( File patch File , Share Patch Info old Patch Info , String patch File Version , boolean is Upgrade Patch ) { Tinker Log . i ( TAG , STRING , patch File . get Absolute Path ( ) , patch File Version , is Upgrade Patch ) ; }
public void init ( boolean for Encryption , Cipher Parameters params ) throws Illegal Argument Exception { if ( ! ( params instanceof Parameters With IV ) ) { throw new Illegal Argument Exception ( STRING ) ; } Parameters With IV iv Params = ( Parameters With IV ) params ; byte [ ] iv = iv Params . get IV ( ) ; if ( iv == null || iv . length != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( ! ( iv Params . get Parameters ( ) instanceof Key Parameter ) ) { throw new Illegal Argument Exception ( STRING ) ; } Key Parameter key = ( Key Parameter ) iv Params . get Parameters ( ) ; working IV = new byte [ key . get Key ( ) . length ] ; working Key = new byte [ key . get Key ( ) . length ] ; lfsr = new int [ STATE SIZE ] ; nfsr = new int [ STATE SIZE ] ; out = new byte [ NUM ] ; System . arraycopy ( iv , NUM , working IV , NUM , iv . length ) ; System . arraycopy ( key . get Key ( ) , NUM , working Key , NUM , key . get Key ( ) . length ) ; reset ( ) ; }
Grid Memcached Message ( ) { }
public Extension Forced User ( ) { super ( ) ; initialize ( ) ; }
private String replace Placeholders ( String query , Map < String , String > replacements ) { String result Query = query ; for ( Map . Entry < String , String > entry : replacements . entry Set ( ) ) { result Query = result Query . replace ( entry . get Key ( ) , entry . get Value ( ) ) ; } return result Query ; }
protected int read Fully ( Input Stream in , byte buffer [ ] ) throws java . io . IO Exception { for ( int i = NUM ; i < buffer . length ; i ++ ) { int q = in . read ( ) ; if ( q == - NUM ) return i ; buffer [ i ] = ( byte ) q ; } return buffer . length ; }
public void destroy Bucket ( Auto Mix Bucket bucket ) { Shared Preferences prefs = get Prefs ( ) ; Shared Preferences . Editor editor = prefs . edit ( ) ; Set < String > set = new Tree Set < > ( prefs . get String Set ( PREF BUCKETS IDS , new Tree Set < String > ( ) ) ) ; set . remove ( bucket . get Session Id ( ) ) ; editor . put String Set ( PREF BUCKETS IDS , set ) ; editor . apply ( ) ; m Buckets . remove ( bucket ) ; }
public void clear Changed ( ) { changed . set ( BOOL ) ; }
public static Object [ ] convert Params ( Object [ ] source , Class < ? > [ ] target ) { Object [ ] converted = new Object [ target . length ] ; for ( int i = NUM ; i < target . length ; i ++ ) { converted [ i ] = convert ( source [ i ] , target [ i ] ) ; } return converted ; }
private void r Probe And Add Hops To Candidate Set ( Hop hop , Hash Set < Hop > probe Set , Hash Set < Pair < Hop , Hop > > cand Set ) { if ( hop . get Visited ( ) == Visit Status . DONE ) return ; if ( hop . get Input ( ) != null ) for ( Hop c : hop . get Input ( ) ) { if ( ! probe Set . contains ( c ) ) r Probe And Add Hops To Candidate Set ( c , probe Set , cand Set ) ; else { cand Set . add ( new Pair < Hop , Hop > ( hop , c ) ) ; } } hop . set Visited ( Visit Status . DONE ) ; }
protected void parse ( Data Input Stream stream ) throws Exception { value = stream . read Int ( ) ; }
List < String > as List ( ) { if ( more ) { list . set ( list . size ( ) - NUM , STRING ) ; } return Collections . unmodifiable List ( list ) ; }
public void test Not Neg ( ) { byte a Bytes [ ] = { - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM } ; int a Sign = - NUM ; byte r Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . not ( ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public Cache Stat Resource ( String resource Identifier , Cache Resource cache Resource ) { super ( resource Identifier ) ; this . cache Resource = cache Resource ; relative Cache Stats = cache Resource . get Cache Stats ( ) ; }
public Map < URI , List < URI > > add Target Volume Full Copies ( ) { List < URI > full Copies = Lists . new Array List ( ) ; Map < URI , List < URI > > full Copies Map = new Hash Map < > ( ) ; URI target CG = null ; for ( URI volume Id : uris ( volume Ids ) ) { List < URI > targets = get Targets ( volume Id ) ; for ( URI target : targets ) { if ( target CG == null ) { target CG = get Consistency Group ( target ) ; } List < URI > volume Full Copies = get Full Copies ( target ) ; full Copies . add All ( volume Full Copies ) ; full Copies Map . put ( target , volume Full Copies ) ; } } if ( ! full Copies . is Empty ( ) && target CG != null ) { Block Storage Utils . add Volumes To Consistency Group ( target CG , full Copies ) ; } return full Copies Map ; }
Weather Attribute ( int max , String ... desc ) { max Value = max ; value = Rand . rand ( max + NUM ) ; this . desc = desc ; }
protected Class Loader ( Class Loader parent Loader ) { Security Manager sc = System . get Security Manager ( ) ; if ( sc != null ) { sc . check Create Class Loader ( ) ; } parent Class Loader = parent Loader ; defined Packages = new Hash Map < String , Package > ( ) ; loaded Classes = new Hash Map < String , Class < ? > > ( ) ; package Certificates = new Hashtable < String , Certificate [ ] > ( ) ; }
static public double log 10 ( double in Value ) { return Math . log ( in Value ) / Math . log ( NUM ) ; }
void update Feature Counts ( int [ ] translation Ids , List < List < Rich Translation < I String , String > > > nbest Lists ) { for ( int i = NUM ; i < translation Ids . length ; i ++ ) { Set < String > features = new Hash Set < String > ( ) ; for ( Rich Translation < I String , String > trans : nbest Lists . get ( i ) ) { for ( Feature Value < String > f : trans . features ) { features . add ( f . name ) ; } } synchronized ( clipped Feature Index ) { for ( String f Name : features ) { Set < Integer > ids = clipped Feature Index . get ( f Name ) ; if ( ids == null ) { ids = new Tree Set < Integer > ( ) ; clipped Feature Index . put ( f Name , ids ) ; } if ( ids . size ( ) < min Feature Count ) { ids . add ( translation Ids [ i ] ) ; } } } } }
public static void d ( String tag , String msg , Object ... args ) { if ( s Level > LEVEL DEBUG ) { return ; } if ( args . length > NUM ) { msg = String . format ( msg , args ) ; } Log . d ( tag , msg ) ; }
private void add Native Express Ads ( ) { for ( int i = NUM ; i <= m Recycler View Items . size ( ) ; i += ITEMS PER AD ) { final Native Express Ad View ad View = new Native Express Ad View ( Main Activity . this ) ; m Recycler View Items . add ( i , ad View ) ; } }
protected boolean accept ( final I Change Record record ) { return BOOL ; }
public final T allocate ( ) { Atomic Integer top Ref = top ; while ( BOOL ) { final int top = top Ref . get ( ) ; if ( top <= NUM ) { return null ; } else if ( top Ref . compare And Set ( top , top - NUM ) ) { T value = free Stack . get And Set ( top - NUM , null ) ; if ( value != null ) { return value ; } } } }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
public void put Response Get All Resources ( List < String > resources ) { logger . debug ( STRING ) ; Resource Set resource Set = new Resource Set ( ) ; for ( String res : resources ) { Remote Resource resource = gson . from Json ( res , Remote Resource . class ) ; resource . set Resource Pool Connector ( this ) ; resource Set . add ( resource ) ; } synchronized ( get All Resource Response ) { get All Resource Response . add ( resource Set ) ; get All Resource Response . notify ( ) ; } }
public static Map < String , Set < String > > to Av Pair Map ( final Set < String > names , final String value ) { if ( value == null ) { return Collections . EMPTY MAP ; } if ( names == null || names . is Empty ( ) ) { return new Hash Map ( ) ; } final Map < String , Set < String > > map = new Hash Map < String , Set < String > > ( names . size ( ) ) ; final Set < String > set = new Hash Set < String > ( NUM ) ; set . add ( value ) ; for ( final String name : names ) { map . put ( name , set ) ; } return map ; }
public Prefix Tagger ( Maxent Tagger maxent Tagger ) { super ( maxent Tagger ) ; this . left Window = left Window ( ) ; this . right Window = right Window ( ) ; this . offset = left Window ( ) ; }
@ Override public void perform Request ( String request ) { if ( request . compare To ( STRING ) == NUM ) { stop ( ) ; } else { throw new Illegal Argument Exception ( request + STRING ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public synchronized void kill ( ) { running = BOOL ; closed = BOOL ; try { STDIN . close ( ) ; } catch ( IO Exception e ) { } try { process . destroy ( ) ; } catch ( Exception e ) { } }
private Iterable < int [ ] > split Array ( int [ ] arr ) { int len 1 = arr . length / NUM ; int len 2 = len 1 + arr . length % NUM ; int [ ] a1 = new int [ len 1 ] ; int [ ] a2 = new int [ len 2 ] ; System . arraycopy ( arr , NUM , a1 , NUM , len 1 ) ; System . arraycopy ( arr , len 1 , a2 , NUM , len 2 ) ; return Arrays . as List ( a1 , a2 ) ; }
public void put ( E e ) throws Interrupted Exception { check Not Null ( e ) ; final Reentrant Lock lock = this . lock ; lock . lock Interruptibly ( ) ; try { while ( count == items . length ) not Full . await ( ) ; enqueue ( e ) ; } finally { lock . unlock ( ) ; } }
@ Ignore @ Test public void should Capture Query Event Data ( ) throws Exception { start Client ( null ) ; counters . consume All ( NUM , Time Unit . SECONDS ) ; List < Query Event Data > all Query Events = recorded Event Data ( Query Event Data . class , - NUM ) ; all Query Events . for Each ( null ) ; }
private List < Validation Error > check For No Rates Present ( ) { if ( overhead Rates != null && overhead Rates . is Empty ( ) ) return Arrays . as List ( new Validation Error ( STRING , STRING ) ) ; else return null ; }
public void modify Export ( String id , String zone Name , Isilon Export exp ) throws Isilon Exception { String uri With Zone Name = get URI With Zone Name ( id , zone Name ) ; modify ( base Url . resolve ( URI NFS EXPORTS ) , uri With Zone Name , STRING , exp ) ; }
public double measure Num Iterations ( ) { return m Classifiers . size ( ) ; }
public void mark Potentially Unknown Bit ( Local Variable Binding local ) { if ( this != DEAD END ) { this . tag Bits |= NULL FLAG MASK ; int position ; long mask ; if ( ( position = local . id + this . max Field Count ) < Bit Cache Size ) { mask = NUM << position ; is True ( ( this . null Bit 1 & mask ) == NUM , STRING ) ; this . null Bit 4 |= mask ; if ( COVERAGE TEST FLAG ) { if ( Coverage Test Id == NUM ) { this . null Bit 4 = ~ NUM ; } } } else { int vector Index = ( position / Bit Cache Size ) - NUM ; if ( this . extra == null ) { int length = vector Index + NUM ; this . extra = new long [ extra Length ] [ ] ; for ( int j = NUM ; j < extra Length ; j ++ ) { this . extra [ j ] = new long [ length ] ; } } else { int old Length ; if ( vector Index >= ( old Length = this . extra [ NUM ] . length ) ) { for ( int j = NUM ; j < extra Length ; j ++ ) { System . arraycopy ( this . extra [ j ] , NUM , ( this . extra [ j ] = new long [ vector Index + NUM ] ) , NUM , old Length ) ; } } } mask = NUM << ( position % Bit Cache Size ) ; is True ( ( this . extra [ NUM ] [ vector Index ] & mask ) == NUM , STRING ) ; this . extra [ NUM ] [ vector Index ] |= mask ; if ( COVERAGE TEST FLAG ) { if ( Coverage Test Id == NUM ) { this . extra [ NUM ] [ vector Index ] = ~ NUM ; } } } } }
public int count ( ) { return dict . size ( ) ; }
public static boolean above Or Equal ( int a , int b ) { return Integer . compare Unsigned ( a , b ) >= NUM ; }
protected void await Completion Compute Values And Shutdown ( ) { { run Executor And Await Completion ( ) ; } if ( logger . is Debug Enabled ( ) ) print Stats ( ) ; executor . shutdown ( ) ; while ( ! executor . is Terminated ( ) ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } } }
public Flags flag List ( ) throws Decoding Exception { Flags flags = new Flags ( ) ; next Word Char ( ) ; consume Char ( STRING ) ; Character Validator validator = new Noop Char Validator ( ) ; String next Word = consume Word ( validator ) ; while ( ! next Word . ends With ( STRING ) ) { Decoder Utils . set Flag ( next Word , flags ) ; next Word = consume Word ( validator ) ; } if ( next Word . length ( ) > NUM ) { int paren Index = next Word . index Of ( STRING ) ; if ( paren Index > NUM ) { final String next Flag = next Word . substring ( NUM , paren Index ) ; Decoder Utils . set Flag ( next Flag , flags ) ; } } return flags ; }
protected Rest Client Itf create New Rest Client ( URI endpoint , String username , String password , String version , Client client ) { Xtrem IO Client xio Client = null ; if ( version != null && ! version . is Empty ( ) && Integer . value Of ( version . split ( DOT OPERATOR ) [ NUM ] ) >= XIO MIN 4X VERSION ) { xio Client = new Xtrem IOV 2 Client ( endpoint , username , password , client ) ; } else { xio Client = new Xtrem IOV 1 Client ( endpoint , username , password , client ) ; } return xio Client ; }
public String diff text 2 ( Linked List < Diff > diffs ) { String Builder text = new String Builder ( ) ; for ( Diff a Diff : diffs ) { if ( a Diff . operation != Operation . DELETE ) { text . append ( a Diff . text ) ; } } return text . to String ( ) ; }
static private < E > List < E > to Java List ( List < E > values , int rows , int columns ) { List < E > result = new Array List < > ( values . size ( ) ) ; for ( int i = NUM ; i < values . size ( ) ; i ++ ) { int row = i / columns ; int column = i % columns ; E value = values . get ( ( column * rows ) + row ) ; result . add ( value ) ; } return result ; }
public void line Arrow ( final int x0 , final int y0 , final int x1 , final int y1 , final int sidelength , final int padding , final long line Color , final long arrow Color ) { final double dx = x1 - x0 ; final double dy = y1 - y0 ; final double angle = Math . atan 2 ( dy , dx ) ; final double d = Math . sqrt ( ( dx * dx + dy * dy ) ) ; final double arrowtip = d - padding ; final double arrowlength = TL * sidelength ; final double arrowbase = arrowtip - arrowlength ; final double xn = Math . cos ( angle ) ; final double yn = Math . sin ( angle ) ; final int xt = x0 + ( ( int ) ( arrowtip * xn ) ) ; final int yt = y0 + ( ( int ) ( arrowtip * yn ) ) ; final double xb = x0 + arrowbase * xn ; final double yb = y0 + arrowbase * yn ; final double sl 2 = sidelength / NUM ; final double xk = sl 2 * Math . cos ( angle + PI 2 ) ; final double yk = sl 2 * Math . sin ( angle + PI 2 ) ; final int x2 = ( int ) ( xb + xk ) ; final int y2 = ( int ) ( yb + yk ) ; final int x3 = ( int ) ( xb - xk ) ; final int y3 = ( int ) ( yb - yk ) ; set Color ( line Color ) ; line ( x0 , y0 , ( int ) xb , ( int ) yb , NUM ) ; set Color ( arrow Color ) ; line ( x2 , y2 , x3 , y3 , NUM ) ; line ( x2 , y2 , xt , yt , NUM ) ; line ( x3 , y3 , xt , yt , NUM ) ; }
public String to Html ( Node node , Appendable appendable ) { Node Visitor renderer = create Renderer ( appendable ) ; node . visit ( renderer ) ; return appendable . to String ( ) ; }
public static String [ ] to Comma Separated Array ( String str ) throws IO Exception { return str . split ( STRING ) ; }
@ Override public final Object put ( String key , Object value ) { return set ( key , value ) ; }
private void append Float Type ( String Builder sb , Field Type field Type , int field Width ) { sb . append ( STRING ) ; }
private Http Entity params To Entity ( Request Params params , Response Handler Interface response Handler ) { Http Entity entity = null ; try { if ( params != null ) { entity = params . get Entity ( response Handler ) ; } } catch ( Throwable t ) { if ( response Handler != null ) response Handler . send Failure Message ( NUM , null , null , t ) ; else t . print Stack Trace ( ) ; } return entity ; }
public static boolean is Installable Editing ( Enum Set < Embedding Flags > flag Set ) { return flag Set . is Empty ( ) ; }
public void test Multiply Scale Pos Pos ( ) { String a = STRING ; int a Scale = NUM ; String b = STRING ; int b Scale = NUM ; String c = STRING ; int c Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; Big Decimal result = a Number . multiply ( b Number ) ; assert Equals ( STRING , c , result . to String ( ) ) ; assert Equals ( STRING , c Scale , result . scale ( ) ) ; }
public Iterator < Resource > resource Iterator ( ) { return resource List . iterator ( ) ; }
public double next Uniform ( double lower , double upper ) { if ( upper <= lower ) { throw new Math Illegal Argument Exception ( Localized Core Formats . LOWER BOUND NOT BELOW UPPER BOUND , lower , upper ) ; } if ( Double . is Infinite ( lower ) || Double . is Infinite ( upper ) ) { throw new Math Illegal Argument Exception ( Localized Core Formats . INFINITE BOUND ) ; } if ( Double . is Na N ( lower ) || Double . is Na N ( upper ) ) { throw new Math Illegal Argument Exception ( Localized Core Formats . NAN NOT ALLOWED ) ; } final double u = random Generator . next Double ( ) ; return u * upper + ( NUM - u ) * lower ; }
public Shape Tile Box bounding box ( ) { Pla Point Int lower left = new Pla Point Int ( Math . floor ( v x ) , Math . floor ( v y ) ) ; Pla Point Int upper right = new Pla Point Int ( Math . ceil ( v x ) , Math . ceil ( v y ) ) ; return new Shape Tile Box ( lower left , upper right ) ; }
public void add Interface ( String name ) { cached Interfaces = null ; int info = const Pool . add Class Info ( name ) ; if ( interfaces == null ) { interfaces = new int [ NUM ] ; interfaces [ NUM ] = info ; } else { int n = interfaces . length ; int [ ] newarray = new int [ n + NUM ] ; System . arraycopy ( interfaces , NUM , newarray , NUM , n ) ; newarray [ n ] = info ; interfaces = newarray ; } }
private void biome Factor ( final int x , final int z , final double add Height ) { float smooth Volatility = NUM ; float smooth Height = NUM ; float biome Weight Sum = NUM ; final Biome center Biome Config = get Center Biome ( x , z ) ; final int look Radius = this . max Smooth Radius ; for ( int next X = - look Radius ; next X <= look Radius ; next X ++ ) { for ( int next Z = - look Radius ; next Z <= look Radius ; next Z ++ ) { final Biome biome = get Offset Biome ( x , z , next X , next Z ) ; final float biome Height = biome . get Base Height ( ) ; final float biome Volatility = biome . get Height Variation ( ) ; double biome Weight = calc Biome Weight ( next X , next Z , biome Height ) ; biome Weight = Math . abs ( biome Weight ) ; if ( biome Height > center Biome Config . get Base Height ( ) ) { biome Weight /= NUM ; } smooth Volatility += biome Volatility * biome Weight ; smooth Height += biome Height * biome Weight ; biome Weight Sum += biome Weight ; } } smooth Volatility /= biome Weight Sum ; smooth Height /= biome Weight Sum ; this . biome Volatility = smooth Volatility * NUM + NUM ; this . biome Volatility *= NUM / NUM ; this . biome Height = NUM / NUM ; this . biome Height += smooth Height * NUM / NUM ; this . biome Height += NUM * add Height * NUM / NUM ; }
@ Suppress Warnings ( STRING ) public static M Issue create ( Properties ctx , String hex Input ) { Hash Map hm In = null ; try { byte [ ] byte Array = Secure . convert Hex String ( hex Input ) ; Byte Array Input Stream b In = new Byte Array Input Stream ( byte Array ) ; Object Input Stream o In = new Object Input Stream ( b In ) ; hm In = ( Hash Map ) o In . read Object ( ) ; } catch ( Exception e ) { s log . log ( Level . SEVERE , STRING , e ) ; return null ; } M Issue issue = new M Issue ( ctx , ( Hash Map < String , String > ) hm In ) ; return issue ; }
void flush Buffer ( ) throws IO Exception { se . flush Buffer ( ) ; }
public static void show Unknown Error ( Context context , Throwable t , Dialog Interface . On Cancel Listener listener ) { show Error ( context , String . format ( context . get String ( R . string . afc pmsg unknown error ) , t ) , listener ) ; }
private static boolean make Concave Polygon ( final Planet Model planet Model , final Geo Composite Polygon rval , final Mutable Boolean seen Concave , final Edge Buffer edge Buffer , final List < Geo Polygon > holes , final Geo Point test Point ) { if ( edge Buffer . size ( ) == NUM ) { return BOOL ; } if ( seen Concave . value ) { throw new Illegal Argument Exception ( STRING ) ; } seen Concave . value = BOOL ; if ( edge Buffer . size ( ) < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } final List < Geo Point > points = new Array List < Geo Point > ( edge Buffer . size ( ) ) ; final Bit Set internal Edges = new Bit Set ( edge Buffer . size ( ) - NUM ) ; Edge edge = edge Buffer . pick One ( ) ; boolean is Internal = BOOL ; for ( int i = NUM ; i < edge Buffer . size ( ) ; i ++ ) { points . add ( edge . start Point ) ; if ( i < edge Buffer . size ( ) - NUM ) { internal Edges . set ( i , edge . is Internal ) ; } else { is Internal = edge . is Internal ; } edge = edge Buffer . get Next ( edge ) ; } if ( test Point != null && holes != null && holes . size ( ) > NUM ) { final Geo Polygon test Polygon = new Geo Concave Polygon ( planet Model , points , null , internal Edges , is Internal ) ; if ( test Polygon . is Within ( test Point ) ) { return BOOL ; } } final Geo Polygon real Polygon = new Geo Concave Polygon ( planet Model , points , holes , internal Edges , is Internal ) ; if ( test Point != null && ( holes == null || holes . size ( ) == NUM ) ) { if ( real Polygon . is Within ( test Point ) ) { return BOOL ; } } rval . add Shape ( real Polygon ) ; return BOOL ; }
public void add Button ( final J Button the Button ) { custom Button Panel . add ( the Button ) ; }
void swap Cursor ( long month Millis , @ Nullable Event Cursor cursor , Content Observer content Observer ) { for ( int i = NUM ; i < m Months . size ( ) ; i ++ ) { if ( Calendar Utils . same Month ( month Millis , m Months . get ( i ) ) ) { swap Cursor ( i , cursor , content Observer ) ; break ; } } }
final boolean close ( ) { return ! closed . get And Set ( BOOL ) ; }
public byte [ ] encrypt Raw ( byte [ ] base Key , int usage , byte [ ] ivec , byte [ ] plaintext , int start , int len ) throws General Security Exception , Krb Crypto Exception { if ( ! Key Usage . is Valid ( usage ) ) { throw new General Security Exception ( STRING + usage ) ; } byte [ ] output = encrypt CTS ( base Key , usage , ivec , null , plaintext , start , len , BOOL ) ; return output ; }
private void fixbug ( Document doc ) { Element element = doc . get Document Element ( ) ; if ( element != null ) { fixbug ( element ) ; } }
private String to Hex String ( byte [ ] block ) { String Buffer buf = new String Buffer ( ) ; int len = block . length ; for ( int i = NUM ; i < len ; i ++ ) { byte 2 hex ( block [ i ] , buf ) ; if ( i < len - NUM ) { buf . append ( STRING ) ; } } return buf . to String ( ) ; }
public static String remove Deploy Uri ( String uri ) { if ( ( uri == null ) || ( uri . length ( ) == NUM ) ) { return uri ; } int loc = uri . index Of ( STRING , NUM ) ; if ( loc == - NUM ) { return null ; } else { return uri . substring ( loc ) ; } }
public static double loss ( double pred , double y ) { return Math . abs ( y - pred ) ; }
public boolean need Signature File Bytes ( ) { return sf Bytes == null ; }
public void insert ( T object , int index ) { synchronized ( m Lock ) { m Objects . add ( index , object ) ; } if ( m Notify On Change ) notify Item Inserted ( index ) ; }
private void load Target Modules ( ) { for ( final Module module : target . get Modules ( ) ) { module . add Listener ( module Keeper Listener ) ; modules . add ( module ) ; if ( ! module . is Loaded ( ) ) { try { module . load ( ) ; } catch ( final Couldnt Load Data Exception e ) { error Loading Module ( module , e ) ; return ; } } } step ++ ; }
public Bloom Filter ( double false Positive Probability , int expected Number Of Elements ) { this ( Math . ceil ( - ( Math . log ( false Positive Probability ) / Math . log ( NUM ) ) ) / Math . log ( NUM ) , expected Number Of Elements , ( int ) Math . ceil ( - ( Math . log ( false Positive Probability ) / Math . log ( NUM ) ) ) ) ; }
public synchronized void notify Band ( final int times , final int on Time , final int off Time , final int flash Colour ) { final List < BLE Action > list = new Array List < > ( ) ; byte [ ] colors = convert Rgb ( flash Colour ) ; list . add ( new Wait Action ( NUM ) ) ; list . add ( new Write Action ( Profile . UUID CHAR CONTROL POINT , Protocol . VIBRATION WITHOUT LED ) ) ; list . add ( new Wait Action ( NUM ) ) ; list . add ( new Write Action ( Profile . UUID CHAR CONTROL POINT , colors ) ) ; queue ( list ) ; }
public void test Constructor Ljava security cert Cert Path Parameters ( ) { try { Cert Path Parameters parameters = new My Cert Path Parameters ( ) ; Cert Path Trust Manager Parameters p = new Cert Path Trust Manager Parameters ( parameters ) ; assert Not Same ( STRING , parameters , p . get Parameters ( ) ) ; } catch ( Exception e ) { fail ( STRING + e . to String ( ) ) ; } try { new Cert Path Trust Manager Parameters ( null ) ; fail ( STRING ) ; } catch ( Null Pointer Exception npe ) { } }
private static int build Request Code ( long thread Id , int action ) { action ++ ; return ( int ) ( action * NUM + thread Id ) ; }
public Outer Join Qualifier add ( String property Left , String property Right ) { additional Properties . add ( new Property Value Expression Pair ( new Property Value Expression ( property Left ) , new Property Value Expression ( property Right ) ) ) ; return this ; }
public void insert Element At ( int value , int at ) { if ( null == m map ) { m map = new int [ m blocksize ] ; m map Size = m blocksize ; } else if ( ( m first Free + NUM ) >= m map Size ) { m map Size += m blocksize ; int new Map [ ] = new int [ m map Size ] ; System . arraycopy ( m map , NUM , new Map , NUM , m first Free + NUM ) ; m map = new Map ; } if ( at <= ( m first Free - NUM ) ) { System . arraycopy ( m map , at , m map , at + NUM , m first Free - at ) ; } m map [ at ] = value ; m first Free ++ ; }
protected static Dfp atan Internal ( final Dfp a ) { Dfp y = new Dfp ( a ) ; Dfp x = new Dfp ( y ) ; Dfp py = new Dfp ( y ) ; for ( int i = NUM ; i < NUM ; i += NUM ) { x = x . multiply ( a ) ; x = x . multiply ( a ) ; x = x . negate ( ) ; y = y . add ( x . divide ( i ) ) ; if ( y . equals ( py ) ) { break ; } py = new Dfp ( y ) ; } return y ; }
public static String parse Segment Name ( String filename ) { int idx = index Of Segment Name ( filename ) ; if ( idx != - NUM ) { filename = filename . substring ( NUM , idx ) ; } return filename ; }
private static Tree generate Sub Tree ( Hash Map < Integer , Pair < Indexed Word , List < Integer > > > dependencies , int root ) { List < Integer > children = dependencies . get ( root ) . second ; Indexed Word tw = dependencies . get ( root ) . first ; Tree tree = new Labeled Scored Tree Node ( tw ) ; boolean added Head = children . is Empty ( ) ; List < Integer > sorted Children = Collection Utils . sorted ( children ) ; for ( Integer c : sorted Children ) { if ( c > root && ! added Head ) { Tree child = new Labeled Scored Tree Node ( tw ) ; tree . add Child ( child ) ; added Head = BOOL ; } Tree child = generate Sub Tree ( dependencies , c ) ; tree . add Child ( child ) ; } if ( ! added Head ) { Tree child = new Labeled Scored Tree Node ( tw ) ; tree . add Child ( child ) ; } return tree ; }
@ HLE Function ( nid = NUM , version = NUM , check Inside Interrupt = BOOL ) public int sce Sas Rev Param ( int sas Core , int delay , int feedback ) { check Sas Handle Good ( sas Core ) ; waveform Effect Delay = delay ; waveform Effect Feedback = feedback ; return NUM ; }
static boolean is Possible FP ( String val ) { final int length = val . length ( ) ; for ( int i = NUM ; i < length ; ++ i ) { char c = val . char At ( i ) ; if ( ! ( c >= STRING && c <= STRING || c == STRING || c == STRING || c == STRING || c == STRING || c == STRING ) ) { return BOOL ; } } return BOOL ; }
public boolean delete Track ( Track track ) { synchronized ( tracks ) { return tracks . remove Element ( track ) ; } }
protected static Array List < Geo Point > parse Kml Coordinates ( String input ) { Linked List < Geo Point > tmp Coords = new Linked List < Geo Point > ( ) ; int i = NUM ; int tuple Start = NUM ; int length = input . length ( ) ; boolean start Reading Tuple = BOOL ; while ( i < length ) { char c = input . char At ( i ) ; if ( c == STRING || c == STRING || c == STRING ) { if ( start Reading Tuple ) { String tuple = input . substring ( tuple Start , i ) ; Geo Point p = parse Kml Coord ( tuple ) ; if ( p != null ) tmp Coords . add ( p ) ; start Reading Tuple = BOOL ; } } else { if ( ! start Reading Tuple ) { start Reading Tuple = BOOL ; tuple Start = i ; } if ( i == length - NUM ) { String tuple = input . substring ( tuple Start , i + NUM ) ; Geo Point p = parse Kml Coord ( tuple ) ; if ( p != null ) tmp Coords . add ( p ) ; } } i ++ ; } Array List < Geo Point > coordinates = new Array List < Geo Point > ( tmp Coords . size ( ) ) ; coordinates . add All ( tmp Coords ) ; return coordinates ; }
public void paint ( Graphics 2 D g ) { for ( int i = NUM ; i < m nodes . size ( ) ; i ++ ) { WF Node node = m nodes . get ( i ) ; Rectangle rect = node . get Bounds ( ) ; g . set Color ( Color . BLACK ) ; g . draw Rect ( rect . x , rect . y , rect . width , rect . height ) ; Graphics 2 D t = ( Graphics 2 D ) g . create ( rect . x , rect . y , rect . width , rect . height ) ; node . paint ( t ) ; t . dispose ( ) ; } create Lines ( ) ; for ( int i = NUM ; i < m lines . size ( ) ; i ++ ) { WF Line line = ( WF Line ) m lines . get ( i ) ; line . paint ( g ) ; } }
Server Session Context register Request ( long sequence , Runnable runnable ) { commands . put ( sequence , runnable ) ; return this ; }
public void test Constructor Sign Bytes Zero Null 2 ( ) { byte a Bytes [ ] = { } ; int a Sign = NUM ; byte r Bytes [ ] = { NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public void add Preferences Button ( ) { J Button prefs Button = new J Button ( STRING ) ; prefs Button . set Hide Action Text ( BOOL ) ; prefs Button . set Action ( Time Series Plot Actions . get Properties Dialog Action ( this ) ) ; button Panel . add ( prefs Button ) ; }
public static void find Index Matches ( Search Pattern pattern , Index index , Index Query Requestor requestor , Search Participant participant , I Java Search Scope scope , I Progress Monitor monitor ) throws IO Exception { pattern . find Index Matches ( index , requestor , participant , scope , monitor ) ; }
public static void log Info ( String message , Object ... args ) { message = Message Format . format ( message , args ) ; log ( I Status . INFO , I Status . OK , message , null ) ; }
public static boolean occupy ( int wait Ms ) { if ( occupied Until != null && occupied Until . after ( new Date ( ) ) ) { return BOOL ; } occupied Until = Date Utils . add Milliseconds ( new Date ( ) , wait Ms ) ; return BOOL ; }
public boolean [ ] [ ] moralize ( Bayes Net bayes Net ) { int n Nodes = bayes Net . get Nr Of Nodes ( ) ; boolean [ ] [ ] b Adjacency Matrix = new boolean [ n Nodes ] [ n Nodes ] ; for ( int i Node = NUM ; i Node < n Nodes ; i Node ++ ) { Parent Set parents = bayes Net . get Parent Sets ( ) [ i Node ] ; moralize Node ( parents , i Node , b Adjacency Matrix ) ; } return b Adjacency Matrix ; }
public void add Divider ( Image View v ) { Relative Layout . Layout Params divider Params = new Relative Layout . Layout Params ( Layout Params . FILL PARENT , Layout Params . WRAP CONTENT ) ; if ( m Image View != null ) { divider Params . add Rule ( Relative Layout . BELOW , m Image View . get Id ( ) ) ; } else if ( m Missing Image != null ) { divider Params . add Rule ( Relative Layout . BELOW , m Missing Image . get Id ( ) ) ; } else if ( m Video Button != null ) { divider Params . add Rule ( Relative Layout . BELOW , m Video Button . get Id ( ) ) ; } else if ( m Audio Button != null ) { divider Params . add Rule ( Relative Layout . BELOW , m Audio Button . get Id ( ) ) ; } else if ( m View Text != null ) { divider Params . add Rule ( Relative Layout . BELOW , m View Text . get Id ( ) ) ; } else { Log . e ( t , STRING ) ; return ; } add View ( v , divider Params ) ; }
private double find Length ( Point origin Point , Point target Point ) { int x1 = origin Point . x ; int y1 = origin Point . y ; int x2 = target Point . x ; int y2 = target Point . y ; double side A = x2 - x1 ; double side B = ( y1 > y2 ? ( y1 - y2 ) : ( y2 - y1 ) ) ; if ( side B == NUM ) { return side A ; } return Math . sqrt ( Math . pow ( side A , NUM ) + Math . pow ( side B , NUM ) ) ; }
public void test Case 4 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( NUM , result . signum ( ) ) ; }
public static Automaton determinize Simple ( Automaton a , Set < Integer > initialset ) { if ( a . get Num States ( ) == NUM ) { return a ; } int [ ] points = a . get Start Points ( ) ; Map < Set < Integer > , Set < Integer > > sets = new Hash Map < > ( ) ; Linked List < Set < Integer > > worklist = new Linked List < > ( ) ; Map < Set < Integer > , Integer > newstate = new Hash Map < > ( ) ; sets . put ( initialset , initialset ) ; worklist . add ( initialset ) ; Automaton . Builder result = new Automaton . Builder ( ) ; result . create State ( ) ; newstate . put ( initialset , NUM ) ; Transition t = new Transition ( ) ; while ( worklist . size ( ) > NUM ) { Set < Integer > s = worklist . remove First ( ) ; int r = newstate . get ( s ) ; for ( int q : s ) { if ( a . is Accept ( q ) ) { result . set Accept ( r , BOOL ) ; break ; } } for ( int n = NUM ; n < points . length ; n ++ ) { Set < Integer > p = new Hash Set < > ( ) ; for ( int q : s ) { int count = a . init Transition ( q , t ) ; for ( int i = NUM ; i < count ; i ++ ) { a . get Next Transition ( t ) ; if ( t . min <= points [ n ] && points [ n ] <= t . max ) { p . add ( t . dest ) ; } } } if ( ! sets . contains Key ( p ) ) { sets . put ( p , p ) ; worklist . add ( p ) ; newstate . put ( p , result . create State ( ) ) ; } int q = newstate . get ( p ) ; int min = points [ n ] ; int max ; if ( n + NUM < points . length ) { max = points [ n + NUM ] - NUM ; } else { max = Character . MAX CODE POINT ; } result . add Transition ( r , q , min , max ) ; } } return Operations . remove Dead States ( result . finish ( ) ) ; }
public static void write ( Input Stream in , Output Stream out , boolean close Both ) throws IO Exception { byte [ ] buff = new byte [ NUM ] ; int read = NUM ; while ( ( read = in . read ( buff ) ) > NUM ) { out . write ( buff , NUM , read ) ; } out . flush ( ) ; if ( close Both ) { safe Close Streams ( in , out ) ; } }
public static double distance ( Coordinate DD p1 , Coordinate DD p2 , UNITS units ) { final double lat P 1 = p1 . north South ; final double lat P 2 = p2 . north South ; final double lon P 1 = p1 . east West ; final double lon P 2 = p2 . east West ; if ( lat P 1 == lat P 2 && lon P 1 == lon P 2 ) return NUM ; double dist Rad = Math . acos ( Math . sin ( to Radians ( lat P 1 ) ) * Math . sin ( to Radians ( lat P 2 ) ) + Math . cos ( to Radians ( lat P 1 ) ) * Math . cos ( to Radians ( lat P 2 ) ) * Math . cos ( to Radians ( lon P 1 - lon P 2 ) ) ) ; final double dist As Degree = to Degrees ( dist Rad ) ; return meters To Units ( dist As Degree * NUM * NUM * NUM , units ) ; }
public static Liquid Network init Network ( ) { Random random = new Random ( System . current Time Millis ( ) ) ; int id = random . next Int ( ) ; while ( used Ids . contains ( id ) ) { id = random . next Int ( ) ; } ; Liquid Network net = new Liquid Network ( ) ; used Ids . add ( id ) ; net . network ID = id ; return net ; }
public String export Xml ( ) throws IO Exception { Byte Array Output Stream output Stream = new Byte Array Output Stream ( ) ; export Xml ( output Stream ) ; return output Stream . to String ( ) ; }
public Pattern Replace Filter ( Token Stream in , Pattern p , String replacement , boolean all ) { super ( in ) ; this . replacement = ( null == replacement ) ? STRING : replacement ; this . all = all ; this . m = p . matcher ( term Att ) ; }
public boolean is Mutable ( ) { return mutable ; }
public static int [ ] stable Sort ( double [ ] array ) { int [ ] index = new int [ array . length ] ; int [ ] new Index = new int [ array . length ] ; int [ ] help Index ; int num Equal ; array = ( double [ ] ) array . clone ( ) ; for ( int i = NUM ; i < index . length ; i ++ ) { index [ i ] = i ; if ( Double . is Na N ( array [ i ] ) ) { array [ i ] = Double . MAX VALUE ; } } quick Sort ( array , index , NUM , array . length - NUM ) ; int i = NUM ; while ( i < index . length ) { num Equal = NUM ; for ( int j = i + NUM ; ( ( j < index . length ) && Utils . eq ( array [ index [ i ] ] , array [ index [ j ] ] ) ) ; j ++ ) num Equal ++ ; if ( num Equal > NUM ) { help Index = new int [ num Equal ] ; for ( int j = NUM ; j < num Equal ; j ++ ) help Index [ j ] = i + j ; quick Sort ( index , help Index , NUM , num Equal - NUM ) ; for ( int j = NUM ; j < num Equal ; j ++ ) new Index [ i + j ] = index [ help Index [ j ] ] ; i += num Equal ; } else { new Index [ i ] = index [ i ] ; i ++ ; } } return new Index ; }
public void reopen Read Write ( ) { synchronized ( m Lock ) { throw If Not Open Locked ( ) ; if ( ! is Read Only Locked ( ) ) { return ; } final int old Open Flags = m Configuration Locked . open Flags ; m Configuration Locked . open Flags = ( m Configuration Locked . open Flags & ~ OPEN READ MASK ) | OPEN READWRITE ; try { m Connection Pool Locked . reconfigure ( m Configuration Locked ) ; } catch ( Runtime Exception ex ) { m Configuration Locked . open Flags = old Open Flags ; throw ex ; } } }
public static int read Chars ( Reader r , char [ ] char Array ) throws IO Exception { int total Chars Read = NUM ; int chars Read = r . read ( char Array ) ; while ( chars Read >= NUM ) { total Chars Read += chars Read ; if ( total Chars Read == char Array . length ) { break ; } chars Read = r . read ( char Array , total Chars Read , char Array . length - total Chars Read ) ; } return total Chars Read ; }
public void remove Direction ( final Direction dir , final boolean face ) { RP Action action ; int size ; action = new RP Action ( ) ; action . put ( STRING , STRING ) ; action . put ( STRING , - dir . get ( ) ) ; send ( action ) ; directions . remove ( dir ) ; size = directions . size ( ) ; if ( size == NUM ) { action = new RP Action ( ) ; action . put ( STRING , STRING ) ; } else { if ( face ) { action = new Face RP Action ( directions . get ( size - NUM ) ) ; } else { action = new Move RP Action ( directions . get ( size - NUM ) ) ; } } send ( action ) ; }
public static double [ ] ndary ( int n ) { double d [ ] = new double [ n ] ; for ( int i = NUM ; i < n ; i ++ ) { d [ i ] = R . next Gaussian ( ) ; } return d ; }
private float apply Bounce ( float velocity , float dist Out Of Bounds , float simulation Rate ) { if ( is Zero ( dist Out Of Bounds ) ) { return velocity ; } velocity *= - NUM ; float bounce = BOUNCE MULTIPLIER * Math . abs ( dist Out Of Bounds / m Iris Radius ) ; if ( velocity > NUM ) { velocity += bounce * simulation Rate ; } else { velocity -= bounce * simulation Rate ; } return velocity ; }
private double dot ( final int k0 , final int k1 , final int [ ] assignment 0 , final int [ ] assignment 1 ) { double dot = NUM ; final int N = X . size ( ) ; int a = NUM , b = NUM ; for ( int i = NUM ; i < N ; i ++ ) { if ( assignment 0 [ i ] != k0 ) continue ; a ++ ; for ( int j = NUM ; j < N ; j ++ ) { if ( assignment 1 [ j ] != k1 ) continue ; dot += kernel . eval ( i , j , X , accel ) ; } } for ( int j = NUM ; j < N ; j ++ ) if ( assignment 1 [ j ] == k1 ) b ++ ; return dot / ( a * b ) ; }
public void remove All Textures ( ) { for ( Weak Reference < CC Texture 2 D > tex SR : textures . values ( ) ) { CC Texture 2 D tex = tex SR . get ( ) ; if ( tex != null ) tex . release Texture ( CC Director . gl ) ; } textures . clear ( ) ; }
public synchronized void add To Queue ( final Image Resource Loader image Resource Loader , final String uri , final Mutable FS Image mfsi , final int width , final int height ) { XR Log . general ( Level . FINE , STRING + uri ) ; load Queue . add Last ( new Image Load Item ( image Resource Loader , uri , mfsi , width , height ) ) ; notify All ( ) ; }
private JNI Writer ( Context context ) { context . put ( jni Writer Key , this ) ; file Manager = context . get ( Java File Manager . class ) ; log = Log . instance ( context ) ; Options options = Options . instance ( context ) ; verbose = options . is Set ( VERBOSE ) ; check All = options . is Set ( STRING ) ; this . context = context ; syms = Symtab . instance ( context ) ; line Sep = System . get Property ( STRING ) ; }
public JOSM Tolerant Fast XML Parser ( Sink sink , XML Stream Reader reader , boolean enable Date Parsing ) { this . sink = sink ; this . enable Date Parsing = enable Date Parsing ; this . reader = reader ; if ( enable Date Parsing ) { timestamp Format = new Xml Timestamp Format ( ) ; } else { Calendar calendar ; calendar = Calendar . get Instance ( ) ; calendar . set ( Calendar . MILLISECOND , NUM ) ; dummy Timestamp Container = new Simple Timestamp Container ( calendar . get Time ( ) ) ; } member Type Parser = new Member Type Parser ( ) ; }
public Hashtable ( int initial Capacity , float load Factor ) { if ( initial Capacity < NUM ) { throw new Illegal Argument Exception ( STRING + initial Capacity ) ; } if ( load Factor <= NUM || Float . is Na N ( load Factor ) ) { throw new Illegal Argument Exception ( STRING + load Factor ) ; } if ( initial Capacity == NUM ) initial Capacity = NUM ; this . load Factor = load Factor ; table = new Entry [ initial Capacity ] ; threshold = ( int ) ( initial Capacity * load Factor ) ; }
public static String extract Reminder ( String public URL , String access URL ) { return public URL . substring ( access URL . length ( ) ) ; }
public void create Underlying ( ) { if ( options != null ) { options . create Underlying ( ) ; if ( Platform . is Fx Application Thread ( ) ) { line = new com . lynden . gmapsfx . shapes . Polyline ( options . convert ( ) ) ; } } }
private void init Raster Program ( ) { Int Buffer props = Buffer Utils . create Int Buffer ( NUM ) ; Int Buffer params = Buffer Utils . create Int Buffer ( NUM ) ; int uniforms Resource Index = gl Get Program Resource Index ( raster Program , GL UNIFORM BLOCK , STRING ) ; compute Ubo Binding = params . get ( NUM ) ; props . put ( NUM , GL BUFFER BINDING ) ; gl Get Program Resourceiv ( raster Program , GL UNIFORM BLOCK , uniforms Resource Index , props , null , params ) ; raster Ubo Binding = params . get ( NUM ) ; }
private void install Voice Data ( ) { if ( Text Utils . is Empty ( get Engine Name ( ) ) ) return ; Intent intent = new Intent ( Text To Speech . Engine . ACTION INSTALL TTS DATA ) ; intent . add Flags ( Intent . FLAG ACTIVITY NEW TASK ) ; intent . set Package ( get Engine Name ( ) ) ; try { Log . v ( TAG , STRING + intent . to Uri ( NUM ) ) ; start Activity ( intent ) ; } catch ( Activity Not Found Exception ex ) { Log . e ( TAG , STRING + intent + STRING ) ; } }
@ Suppress Warnings ( STRING ) Symbol select Best ( Env < Attr Context > env , Type site , List < Type > argtypes , List < Type > typeargtypes , Symbol sym , Symbol best So Far , boolean allow Boxing , boolean use Varargs , boolean operator ) { if ( sym . kind == ERR || ! sym . is Inherited In ( site . tsym , types ) ) { return best So Far ; } else if ( use Varargs && ( sym . flags ( ) & VARARGS ) == NUM ) { return best So Far . kind >= ERRONEOUS ? new Bad Varargs Method ( ( Resolve Error ) best So Far . base Symbol ( ) ) : best So Far ; } Assert . check ( sym . kind < AMBIGUOUS ) ; try { Type mt = raw Instantiate ( env , site , sym , null , argtypes , typeargtypes , allow Boxing , use Varargs , types . no Warnings ) ; if ( ! operator || verbose Resolution Mode . contains ( Verbose Resolution Mode . PREDEF ) ) current Resolution Context . add Applicable Candidate ( sym , mt ) ; } catch ( Inapplicable Method Exception ex ) { if ( ! operator ) current Resolution Context . add Inapplicable Candidate ( sym , ex . get Diagnostic ( ) ) ; switch ( best So Far . kind ) { case ABSENT MTH : return new Inapplicable Symbol Error ( current Resolution Context ) ; case WRONG MTH : if ( operator ) return best So Far ; best So Far = new Inapplicable Symbols Error ( current Resolution Context ) ; default : return best So Far ; } } if ( ! is Accessible ( env , site , sym ) ) { return ( best So Far . kind == ABSENT MTH ) ? new Access Error ( env , site , sym ) : best So Far ; } return ( best So Far . kind > AMBIGUOUS ) ? sym : most Specific ( argtypes , sym , best So Far , env , site , allow Boxing && operator , use Varargs ) ; }
public Bitmap load Bitmap ( String uri , int req Width , int req Height ) { Bitmap bitmap = load Bitmap From Mem Cache ( uri ) ; if ( bitmap != null ) { Log . d ( TAG , STRING + uri ) ; return bitmap ; } try { bitmap = load Bitmap From Disk Cache ( uri , req Width , req Height ) ; if ( bitmap != null ) { Log . d ( TAG , STRING + uri ) ; return bitmap ; } bitmap = load Bitmap From Http ( uri , req Width , req Height ) ; Log . d ( TAG , STRING + uri ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } if ( bitmap == null && ! m Is Disk Lru Cache Created ) { Log . w ( TAG , STRING ) ; bitmap = download Bitmap From Url ( uri ) ; } return bitmap ; }
public boolean is Safe To Execute SUT Code ( ) { Thread current = Thread . current Thread ( ) ; if ( ! privileged Threads . contains ( current ) ) { return BOOL ; } else { return privileged Thread To Ignore == current ; } }
public void test Case 17 ( ) { byte a Bytes [ ] = { NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public String [ ] read Directory ( String dir ) { if ( dir == null ) { throw new Null Pointer Exception ( STRING ) ; } String Array Out list Out = new String Array Out ( ) ; try { check Result ( Lib I Mobile Device . afc read directory ( get Ref ( ) , dir , list Out ) ) ; String Array list = list Out . get Value ( ) ; Array List < String > result = new Array List < String > ( ) ; if ( list != null ) { for ( int i = NUM ; ; i ++ ) { String s = list . get ( i ) ; if ( s == null ) { break ; } result . add ( s ) ; } } return result . to Array ( new String [ result . size ( ) ] ) ; } finally { Lib I Mobile Device . delete String Array values z ( list Out . get Value ( ) ) ; list Out . delete ( ) ; } }
public static String create Args String ( List < String > args ) { if ( args == null ) { return STRING ; } String Builder args Sb = new String Builder ( ) ; for ( String arg : args ) { if ( ( arg . contains ( STRING ) || arg . contains ( STRING ) ) && ! String Utilities . is Quoted ( arg ) ) { args Sb . append ( String Utilities . quote ( arg ) ) ; } else { args Sb . append ( arg ) ; } args Sb . append ( STRING ) ; } if ( args Sb . length ( ) > NUM ) { args Sb . set Length ( args Sb . length ( ) - NUM ) ; } return args Sb . to String ( ) ; }
public void add Element ( int value ) { int index Relative To Cache = m first Free - m build Cache Start Index ; if ( index Relative To Cache >= NUM && index Relative To Cache < m blocksize ) { m build Cache [ index Relative To Cache ] = value ; ++ m first Free ; } else { int index = m first Free > > > m SHIFT ; int offset = m first Free & m MASK ; if ( index >= m map . length ) { int newsize = index + m numblocks ; int [ ] [ ] new Map = new int [ newsize ] [ ] ; System . arraycopy ( m map , NUM , new Map , NUM , m map . length ) ; m map = new Map ; } int [ ] block = m map [ index ] ; if ( null == block ) block = m map [ index ] = new int [ m blocksize ] ; block [ offset ] = value ; m build Cache = block ; m build Cache Start Index = m first Free - offset ; ++ m first Free ; } }
public static < T > List < List < T > > overlap ( List < List < T > > lists , int before , int after ) { if ( before < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( after < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } List Iterator < List < T > > iter = lists . list Iterator ( ) ; List < List < T > > result = new Array List < List < T > > ( ) ; for ( ; iter . has Next ( ) ; ) { List < T > current = new Array List < T > ( iter . next ( ) ) ; List < T > prev = before > NUM ? find Previous ( iter ) : null ; List < T > next = after > NUM ? find Next ( iter ) : null ; if ( prev != null ) { List < T > overlap = prev . sub List ( prev . size ( ) - before , prev . size ( ) ) ; current . add All ( NUM , overlap ) ; } if ( next != null ) { List < T > overlap = next . sub List ( NUM , after ) ; current . add All ( overlap ) ; } result . add ( current ) ; } return result ; }
public double [ ] [ ] extract Main Set Jacobian ( final ODE State state ) { final double [ ] p = state . get Secondary State ( index ) ; final double [ ] [ ] d Yd Y 0 = new double [ state Dim ] [ state Dim ] ; int j = NUM ; for ( int i = NUM ; i < state Dim ; i ++ ) { System . arraycopy ( p , j , d Yd Y 0 [ i ] , NUM , state Dim ) ; j += state Dim ; } return d Yd Y 0 ; }
public static void init ( final Async Context context ) { final Security Context security = ( Security Context ) context . get Attribute ( Async Context . SECURITY CTX ) ; final boolean force Set Security = force Set Security Context ( context ) ; if ( force Set Security ) { Security Context Holder . set Context ( security ) ; } ctx . set ( context ) ; }
private void handle Get Candidate Result ( Placement Task current State , Operation post Operation , Map < String , Server Address > candidates , Stopwatch placement Watch ) { Service Utils . log Info ( this , STRING , placement Watch . elapsed ( Time Unit . MILLISECONDS ) ) ; if ( candidates . is Empty ( ) ) { String msg = String . format ( STRING , current State . resource ) ; Placement Task patch State = build Patch ( Task State . Task Stage . FAILED , current State . task State . is Direct , null ) ; patch State . result Code = Place Result Code . NO SUCH RESOURCE ; patch State . error = msg ; fail Task ( patch State , new Throwable ( msg ) , post Operation ) ; return ; } Service Utils . log Info ( this , STRING , candidates , current State . timeout Ms ) ; Stopwatch score Candidates Stopwatch = Stopwatch . create Started ( ) ; query Hosts For Scores ( current State . resource , candidates , null ) ; }
public boolean contains ( Json Element element ) { return elements . contains ( element ) ; }
private void append Path ( Path cp , final Path p ) { if ( p != null && p . size ( ) > NUM ) { cp . append ( p ) ; } }
public static void do Default Layout ( Composite parent , Dialog Field [ ] editors , boolean label On Top ) { do Default Layout ( parent , editors , label On Top , NUM , NUM ) ; }
protected static final List < C View > process Query Results ( final Result Set result Set , final I Navi Project project , final Map < Integer , Set < C Tag > > tags , final I Tag Manager node Tag Manager , final SQL Provider provider , final List < C View > views , final View Type view Type , final Graph Type graph Type ) throws SQL Exception { final Map < Integer , Set < C Tag > > node Tag Map = get Node Tags ( provider . get Connection ( ) , project , node Tag Manager ) ; try { while ( result Set . next ( ) ) { final int view Id = result Set . get Int ( STRING ) ; final String name = Postgre SQL Helpers . read String ( result Set , STRING ) ; final String description = Postgre SQL Helpers . read String ( result Set , STRING ) ; final Timestamp creation Date = result Set . get Timestamp ( STRING ) ; final Timestamp modification Date = result Set . get Timestamp ( STRING ) ; final boolean star State = result Set . get Boolean ( STRING ) ; final int node Count = result Set . get Int ( STRING ) ; final int edge Count = result Set . get Int ( STRING ) ; final Set < C Tag > view Tags = tags . contains Key ( view Id ) ? tags . get ( view Id ) : new Hash Set < C Tag > ( ) ; final Set < C Tag > node Tags = node Tag Map . contains Key ( view Id ) ? node Tag Map . get ( view Id ) : new Hash Set < C Tag > ( ) ; final C Project View Generator generator = new C Project View Generator ( provider , project ) ; views . add ( generator . generate ( view Id , name , description , view Type , graph Type , creation Date , modification Date , node Count , edge Count , view Tags , node Tags , star State ) ) ; } return views ; } finally { result Set . close ( ) ; } }
private void draw String ( Object native Font , String str , int x , int y , int text Decoration , int font Height ) { if ( str . length ( ) == NUM ) { return ; } if ( text Decoration != NUM ) { boolean raised = ( text Decoration & Style . TEXT DECORATION 3D ) != NUM ; boolean lowerd = ( text Decoration & Style . TEXT DECORATION 3D LOWERED ) != NUM ; boolean north = ( text Decoration & Style . TEXT DECORATION 3D SHADOW NORTH ) != NUM ; if ( raised || lowerd || north ) { text Decoration = text Decoration & ( ~ Style . TEXT DECORATION 3D ) & ( ~ Style . TEXT DECORATION 3D LOWERED ) & ( ~ Style . TEXT DECORATION 3D SHADOW NORTH ) ; int c = get Color ( ) ; int a = get Alpha ( ) ; int new Color = NUM ; int offset = - NUM ; if ( lowerd ) { offset = NUM ; new Color = NUM ; } else if ( north ) { offset = NUM ; } set Color ( new Color ) ; if ( a == NUM ) { set Alpha ( NUM ) ; } draw String ( native Font , str , x , y + offset , text Decoration , font Height ) ; set Alpha ( a ) ; set Color ( c ) ; draw String ( native Font , str , x , y , text Decoration , font Height ) ; return ; } canvas . draw Text ( str , x , y - font . get Font Ascent ( ) , font ) ; if ( ( text Decoration & Style . TEXT DECORATION UNDERLINE ) != NUM ) { paint . set Style ( Paint . Style . FILL ) ; canvas . draw Line ( x , y + font Height - NUM , x + impl . string Width ( native Font , str ) , y + font Height - NUM , paint ) ; } if ( ( text Decoration & Style . TEXT DECORATION STRIKETHRU ) != NUM ) { paint . set Style ( Paint . Style . FILL ) ; canvas . draw Line ( x , y + font Height / NUM , x + impl . string Width ( native Font , str ) , y + font Height / NUM , paint ) ; } if ( ( text Decoration & Style . TEXT DECORATION OVERLINE ) != NUM ) { paint . set Style ( Paint . Style . FILL ) ; canvas . draw Line ( x , y , x + impl . string Width ( native Font , str ) , y , paint ) ; } } else { canvas . draw Text ( str , x , y - font . get Font Ascent ( ) , font ) ; } }
protected void parse ( Data Input Stream stream ) throws Exception { value = stream . read UTF ( ) ; }
public void remove Drag Event Handlers ( ) { node . remove Event Handler ( Touch Event . ANY , touch Handler ) ; node . remove Event Handler ( Mouse Event . ANY , mouse Handler ) ; }
protected void install Listeners ( ) { super . install Listeners ( ) ; table . add Property Change Listener ( this ) ; }
public void test Compare To Zero Pos ( ) { byte b Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; int b Sign = NUM ; Big Integer a Number = Big Integer . ZERO ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; assert Equals ( - NUM , a Number . compare To ( b Number ) ) ; }
public void shutdown ( ) throws Connection Manager Exception { s logger . info ( STRING ) ; connection Lock . lock ( ) ; try { close All Connections ( ) ; if ( listener != null ) { listener . stop ( ) ; listener = null ; } executor Service . shutdown ( ) ; } catch ( Exception e ) { throw new Connection Manager Exception ( STRING , e ) ; } finally { connection Lock . unlock ( ) ; } }
private void close Writer Execution Service ( Executor Service service ) throws Carbon Data Writer Exception { try { service . shutdown ( ) ; service . await Termination ( NUM , Time Unit . DAYS ) ; } catch ( Interrupted Exception e ) { LOGGER . error ( e , e . get Message ( ) ) ; throw new Carbon Data Writer Exception ( e . get Message ( ) ) ; } }
public void remove Job ( String job Id ) { if ( jobs . contains ( job Id ) ) { jobs . remove ( job Id ) ; } }
public String format Time Millis ( long ts ) { synchronized ( time Formatter ) { return time Formatter . format ( new Date ( ts ) ) ; } }
protected static final int position Coordinate 2 D ( float value ) { return ( int ) ( value + NUM ) ; }
@ Override public Object clone ( ) { try { Identity Hash Map < K , V > clone Hash Map = ( Identity Hash Map < K , V > ) super . clone ( ) ; clone Hash Map . element Data = new Element Array ( element Data . length ) ; System . arraycopy ( element Data , NUM , clone Hash Map . element Data , NUM , element Data . length ) ; return clone Hash Map ; } catch ( Clone Not Supported Exception e ) { throw new Assertion Error ( e ) ; } }
public int trap ( int [ ] A ) { if ( A == null || A . length == NUM ) return NUM ; int l = NUM ; int r = A . length - NUM ; int level = NUM ; int all = NUM ; int block = NUM ; while ( l <= r ) { int cur Level = Math . min ( A [ l ] , A [ r ] ) ; if ( cur Level > level ) { all += ( cur Level - level ) * ( r - l + NUM ) ; level = cur Level ; } if ( A [ l ] < A [ r ] ) block += A [ l ++ ] ; else block += A [ r -- ] ; } return all - block ; }
public void search ( ) { perform Search ( ) ; }
public Remote Session ( Http Session session ) { super ( ) ; debug = Debug . get Instance ( STRING ) ; this . session = ( Http Session ) session ; creation Time = session . get Creation Time ( ) ; id = session . get Id ( ) ; last Accessed Time = session . get Last Accessed Time ( ) ; max Inactive Interval = session . get Max Inactive Interval ( ) ; is New = session . is New ( ) ; internal Attributes = new Hash Map ( ) ; Enumeration a Names = get Attribute Names ( ) ; while ( a Names . has More Elements ( ) ) { String attribute Name = ( String ) a Names . next Element ( ) ; if ( is Serializable ( get Attribute ( attribute Name ) ) && ! attribute Name . equals ( STRING ) && ! attribute Name . equals ( STRING ) ) { internal Attributes . put ( attribute Name , get Attribute ( attribute Name ) ) ; internal Attribute Names . add ( attribute Name ) ; debug . message ( STRING + attribute Name + STRING + get Attribute ( attribute Name ) ) ; } } }
@ Override public Snmp Mib Handler add Mib ( Snmp Mib Agent mib ) throws Illegal Argument Exception { if ( mib == null ) { throw new Illegal Argument Exception ( ) ; } if ( ! mibs . contains ( mib ) ) mibs . add Element ( mib ) ; root . register ( mib ) ; return this ; }
public boolean exist ( ) { return production Run != null ; }
public static String number To String ( Number number ) throws JSON Exception { if ( number == null ) { throw new JSON Exception ( STRING ) ; } double double Value = number . double Value ( ) ; JSON . check Double ( double Value ) ; if ( number . equals ( NEGATIVE ZERO ) ) { return STRING ; } long long Value = number . long Value ( ) ; if ( double Value == ( double ) long Value ) { return Long . to String ( long Value ) ; } return number . to String ( ) ; }
public static Sort Clause create ( String item , String order ) { return new Sort Clause ( item , ORDER . value Of ( order ) ) ; }
public long end Time ( ) { return get Timestamp ( ) + calculate Duration ( ) ; }
protected void build Leaves Middle Out ( Ball Node node ) throws Exception { if ( node . m Left != null && node . m Right != null ) { build Leaves Middle Out ( node . m Left ) ; build Leaves Middle Out ( node . m Right ) ; } else if ( node . m Left != null || node . m Right != null ) { throw new Exception ( STRING ) ; } else { Ball Node n2 = build Tree Middle Out ( node . m Start , node . m End ) ; if ( n2 . m Left != null && n2 . m Right != null ) { node . m Left = n2 . m Left ; node . m Right = n2 . m Right ; build Leaves Middle Out ( node ) ; } else if ( n2 . m Left != null || n2 . m Right != null ) { throw new Exception ( STRING ) ; } } }
@ Deprecated public static int [ ] decode Value ( String a ) { return to Int Array ( a . split ( STRING ) ) ; }
public Weight Vector ( Weight Vector wv ) { float in [ ] = wv . get Internal Array ( ) ; u = new float [ in . length ] ; System . arraycopy ( in , NUM , u , NUM , in . length ) ; size = in . length ; }
public void wait Until Done ( ) { count Lock . lock ( ) ; try { equal Count Cv . await ( ) ; } catch ( Interrupted Exception e ) { throw new Runtime Exception ( STRING ) ; } finally { count Lock . unlock ( ) ; } }
public java . lang . String Builder insert ( int offset , long l ) { return insert ( offset , Long . to String ( l ) ) ; }
public Projection Preferences Dialog ( Projector projector ) { this . projector = projector ; String tolerance Tool Tip = STRING + STRING ; J Label tolerance Label = new J Label ( STRING ) ; tolerance . set Tool Tip Text ( tolerance Tool Tip ) ; tolerance Label . set Tool Tip Text ( tolerance Tool Tip ) ; main Panel . add Item Label ( tolerance Label , tolerance ) ; if ( projector . get Projection Method ( ) instanceof Project Coordinate ) { main Panel . add Item ( STRING , auto Find ) ; } fill Field Values ( ) ; set Content Pane ( main Panel ) ; }
private Element generate Branch ( Tree Type tree Type , Rooted Tree tree , Node node , String node Name , double start Latitude , double finish Latitude , double start Longitude , double finish Longitude , double start Altitude , double finish Altitude , double peak Position , double peak Altitude , double start Date , double finish Date , double age Cut Off , Line Style start Style , Line Style finish Style , int division Count , List < Element > styles ) { Element element ; Double rate = ( Double ) node . get Attribute ( STRING ) ; Double support = ( Double ) node . get Attribute ( STRING ) ; double height = tree . get Height ( node ) ; boolean has Division Styles = start Style != null && finish Style != null ; if ( division Count > NUM ) { double lat Diff = finish Latitude - start Latitude ; double lat Delta = lat Diff / division Count ; double long Diff = finish Longitude - start Longitude ; double long Delta = long Diff / division Count ; double alt Diff = finish Altitude - start Altitude ; double alt Delta = alt Diff / division Count ; double date Diff = finish Date - start Date ; double date Delta = date Diff / division Count ; double last Latitude = start Latitude ; double latitude = start Latitude + lat Delta ; double last Longitude = start Longitude ; double longitude = start Longitude + long Delta ; double x = - peak Position ; double x Delta = NUM / division Count ; double a = peak Altitude - finish Altitude ; if ( peak Position == NUM ) { a *= NUM ; } double altitude = peak Altitude - ( a * ( x * x ) ) ; double last Altitude = altitude ; x += x Delta ; double date = start Date ; String style Name = null ; if ( ! has Division Styles && start Style != null ) { style Name = node Name + STRING ; styles . add ( generate Line Style ( style Name , start Style . get Width ( ) , start Style . get Color ( ) ) ) ; } element = generate Container ( STRING , node Name , null , ( style Name != null ? STRING + style Name : null ) ) ; for ( int division = NUM ; division < division Count ; division ++ ) { if ( age Cut Off == NUM || date > age Cut Off ) { String part Name = node Name + STRING + ( division + NUM ) ; style Name = null ; if ( has Division Styles ) { style Name = part Name + STRING ; } Element place Mark = generate Container ( STRING , part Name , null , ( style Name != null ? STRING + style Name : null ) ) ; annotate Branch ( place Mark , height , start Date , finish Date , rate , support ) ; if ( has Division Styles ) { double width = start Style . get Width ( ) ; Color color = get Blended Color ( ( ( float ) division ) / ( division Count - NUM ) , start Style . get Color ( ) , finish Style . get Color ( ) ) ; styles . add ( generate Line Style ( style Name , width , color ) ) ; } if ( date Diff > NUM ) { Element time Span = new Element ( STRING ) ; time Span . add Content ( generate Element ( STRING , get KML Date ( date ) ) ) ; place Mark . add Content ( time Span ) ; } Element line String = new Element ( STRING ) ; Element coordinates = new Element ( STRING ) ; if ( alt Diff > NUM || peak Altitude > NUM ) { line String . add Content ( generate Element ( STRING , altitude Mode ) ) ; altitude = peak Altitude - ( a * ( x * x ) ) ; coordinates . add Content ( STRING + last Longitude + STRING + last Latitude + STRING + last Altitude + STRING ) ; coordinates . add Content ( STRING + longitude + STRING + latitude + STRING + altitude + STRING ) ; } else { line String . add Content ( generate Element ( STRING , STRING ) ) ; line String . add Content ( generate Element ( STRING , BOOL ) ) ; coordinates . add Content ( STRING + last Longitude + STRING + last Latitude + STRING ) ; coordinates . add Content ( STRING + longitude + STRING + latitude + STRING ) ; } last Latitude = latitude ; latitude += lat Delta ; last Longitude = longitude ; longitude += long Delta ; last Altitude = altitude ; x += x Delta ; date += date Delta ; line String . add Content ( coordinates ) ; place Mark . add Content ( line String ) ; element . add Content ( place Mark ) ; } } } else { String style Name = null ; if ( start Style != null ) { style Name = node Name + STRING ; double width = start Style . get Width ( ) ; styles . add ( generate Line Style ( style Name , width , start Style . get Color ( ) ) ) ; } element = generate Container ( STRING , node Name , null , ( style Name != null ? STRING + style Name : null ) ) ; annotate Branch ( element , height , start Date , finish Date , rate , support ) ; Element line String = new Element ( STRING ) ; line String . add Content ( generate Element ( STRING , altitude Mode ) ) ; Element coordinates = new Element ( STRING ) ; if ( tree Type == Tree Type . RECTANGLE TREE ) { coordinates . add Content ( STRING + finish Longitude + STRING + finish Latitude + STRING + finish Altitude + STRING ) ; coordinates . add Content ( STRING + finish Longitude + STRING + finish Latitude + STRING + start Altitude + STRING ) ; coordinates . add Content ( STRING + start Longitude + STRING + start Latitude + STRING + start Altitude + STRING ) ; } else { coordinates . add Content ( STRING + finish Longitude + STRING + finish Latitude + STRING + finish Altitude + STRING ) ; coordinates . add Content ( STRING + start Longitude + STRING + start Latitude + STRING + start Altitude + STRING ) ; } line String . add Content ( coordinates ) ; element . add Content ( line String ) ; } return element ; }
public void add Table Value Change Listener ( Table Value Change Listener listener ) { if ( listener == null ) { return ; } m listeners . add ( listener ) ; }
@ Override public int print ( Graphics g , Page Format page Format , int page Index ) { if ( page Index > NUM ) { return ( NO SUCH PAGE ) ; } else { Graphics 2 D g2 d = ( Graphics 2 D ) g ; g2 d . translate ( page Format . get Imageable X ( ) , page Format . get Imageable Y ( ) ) ; double f Height = page Format . get Imageable Height ( ) ; double f Width = page Format . get Imageable Width ( ) ; int x Max = NUM ; int y Max = NUM ; for ( int i Node = NUM ; i Node < m Bayes Net . get Nr Of Nodes ( ) ; i Node ++ ) { if ( x Max < m Bayes Net . get Position X ( i Node ) ) { x Max = m Bayes Net . get Position X ( i Node ) ; } if ( y Max < m Bayes Net . get Position Y ( i Node ) ) { y Max = m Bayes Net . get Position Y ( i Node ) ; } } double f Current Scale = m f Scale ; x Max += m n Padded Node Width + NUM ; if ( f Width / x Max < f Height / y Max ) { m f Scale = f Width / x Max ; } else { m f Scale = f Height / y Max ; } paint ( g2 d ) ; m f Scale = f Current Scale ; return ( PAGE EXISTS ) ; } }
public Linked Hash Map < Pokemon , Nickname Pokemon Response . Result > bulk Rename With Pattern ( final String pattern , final Bi Consumer < Nickname Pokemon Response . Result , Pokemon > per Poke Callback ) { final Linked Hash Map < Pokemon , Nickname Pokemon Response . Result > results = new Linked Hash Map < > ( ) ; mons . for Each ( null ) ; return results ; }
protected static byte [ ] [ ] parse Directives ( byte [ ] buf , String [ ] key Table , List < byte [ ] > realm Choices , int realm Index ) throws Sasl Exception { byte [ ] [ ] value Table = new byte [ key Table . length ] [ ] ; Byte Array Output Stream key = new Byte Array Output Stream ( NUM ) ; Byte Array Output Stream value = new Byte Array Output Stream ( NUM ) ; boolean getting Key = BOOL ; boolean getting Quoted Value = BOOL ; boolean expect Separator = BOOL ; byte bch ; int i = skip Lws ( buf , NUM ) ; while ( i < buf . length ) { bch = buf [ i ] ; if ( getting Key ) { if ( bch == STRING ) { if ( key . size ( ) != NUM ) { throw new Sasl Exception ( STRING + key ) ; } i = skip Lws ( buf , i + NUM ) ; } else if ( bch == STRING ) { if ( key . size ( ) == NUM ) { throw new Sasl Exception ( STRING ) ; } getting Key = BOOL ; i = skip Lws ( buf , i + NUM ) ; if ( i < buf . length ) { if ( buf [ i ] == STRING ) { getting Quoted Value = BOOL ; ++ i ; } } else { throw new Sasl Exception ( STRING + key . to String ( ) ) ; } } else if ( is Lws ( bch ) ) { i = skip Lws ( buf , i + NUM ) ; if ( i < buf . length ) { if ( buf [ i ] != STRING ) { throw new Sasl Exception ( STRING + key . to String ( ) ) ; } } else { throw new Sasl Exception ( STRING + key . to String ( ) ) ; } } else { key . write ( bch ) ; ++ i ; } } else if ( getting Quoted Value ) { if ( bch == STRING ) { ++ i ; if ( i < buf . length ) { value . write ( buf [ i ] ) ; ++ i ; } else { throw new Sasl Exception ( STRING + key . to String ( ) + STRING + value . to String ( ) ) ; } } else if ( bch == STRING ) { ++ i ; getting Quoted Value = BOOL ; expect Separator = BOOL ; } else { value . write ( bch ) ; ++ i ; } } else if ( is Lws ( bch ) || bch == STRING ) { extract Directive ( key . to String ( ) , value . to Byte Array ( ) , key Table , value Table , realm Choices , realm Index ) ; key . reset ( ) ; value . reset ( ) ; getting Key = BOOL ; getting Quoted Value = expect Separator = BOOL ; i = skip Lws ( buf , i + NUM ) ; } else if ( expect Separator ) { throw new Sasl Exception ( STRING + value . to String ( ) + STRING ) ; } else { value . write ( bch ) ; ++ i ; } } if ( getting Quoted Value ) { throw new Sasl Exception ( STRING + key . to String ( ) + STRING + value . to String ( ) ) ; } if ( key . size ( ) > NUM ) { extract Directive ( key . to String ( ) , value . to Byte Array ( ) , key Table , value Table , realm Choices , realm Index ) ; } return value Table ; }
public static Assignment create Default ( String ... variables ) { return create Default ( Arrays . as List ( variables ) ) ; }
private void on Stop Attack ( ) { attacking = null ; }
public JSON Tokener ( Reader reader ) { this . reader = reader . mark Supported ( ) ? reader : new Buffered Reader ( reader ) ; this . eof = BOOL ; this . use Previous = BOOL ; this . previous = NUM ; this . index = NUM ; this . character = NUM ; this . line = NUM ; }
void calculate Pressed ( Action Event e ) { if ( check Edit Conditional ( ) ) { return ; } if ( num Conditionals > NUM ) { String c Name = STRING ; Conditional c = null ; for ( int i = NUM ; i < num Conditionals ; i ++ ) { c Name = cur Logix . get Conditional By Number Order ( i ) ; if ( c Name != null ) { c = conditional Manager . get By System Name ( c Name ) ; if ( c == null ) { log . error ( STRING + c Name ) ; } else { c . calculate ( BOOL , null ) ; } } else { log . error ( STRING ) ; } } conditional Table Model . fire Table Data Changed ( ) ; } }
public static Function Alias new Instance ( Schema schema , int id , String name , String java Class Method , boolean force , boolean buffer Result Set To Local Temp ) { Function Alias alias = new Function Alias ( schema , id , name ) ; int paren = java Class Method . index Of ( STRING ) ; int last Dot = java Class Method . last Index Of ( STRING , paren < NUM ? java Class Method . length ( ) : paren ) ; if ( last Dot < NUM ) { throw Db Exception . get ( Error Code . SYNTAX ERROR 1 , java Class Method ) ; } alias . class Name = java Class Method . substring ( NUM , last Dot ) ; alias . method Name = java Class Method . substring ( last Dot + NUM ) ; alias . buffer Result Set To Local Temp = buffer Result Set To Local Temp ; alias . init ( force ) ; return alias ; }
protected void update Menu ( ) { boolean present ; boolean initializing ; boolean running ; boolean stopping ; boolean active ; if ( m Menu Bar == null ) return ; present = ( m Experiment != null ) ; initializing = present && m Experiment . is Initializing ( ) ; running = present && m Experiment . is Running ( ) ; stopping = present && m Experiment . is Stopping ( ) ; active = initializing || running || stopping ; m Menu Item File New . set Enabled ( ! active ) ; m Menu Item File Open . set Enabled ( ! active ) ; m Menu Item File Save . set Enabled ( present && ( get Current File ( ) != null ) ) ; m Menu Item File Save As . set Enabled ( present ) ; m Menu Item File Close . set Enabled ( ! active ) ; m Menu Item Execution Start . set Enabled ( present && ! active ) ; m Menu Item Execution Stop . set Enabled ( present && running ) ; for ( Abstract Experimenter Menu Item item : m Additional Menu Items . key Set ( ) ) item . update ( this , m Additional Menu Items . get ( item ) ) ; }
@ Not Null @ Objective C Name ( STRING ) public Configuration Builder add Auto Join Group ( String group Token Or Short Name ) { auto Join Groups . add ( group Token Or Short Name ) ; return this ; }
public boolean has Value Info ( ) { return ! receiver Value . equals ( STRING ) || method Argument Values != null ; }
public boolean next Is Sep ( ) { if ( Character . is Letter Or Digit ( str . char At ( current Position ) ) ) return BOOL ; else return BOOL ; }
protected static final String add Escapes ( String str ) { String Buffer retval = new String Buffer ( ) ; char ch ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) { switch ( str . char At ( i ) ) { case NUM : continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; default : if ( ( ch = str . char At ( i ) ) < NUM || ch > NUM ) { String s = STRING + Integer . to String ( ch , NUM ) ; retval . append ( STRING + s . substring ( s . length ( ) - NUM , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . to String ( ) ; }
protected void drop Car ( Print Writer file , Car car , boolean is Manifest ) { if ( is Manifest ) { String Buffer buf = new String Buffer ( pad And Truncate String ( Setup . get Drop Car Prefix ( ) , Setup . get Manifest Prefix Length ( ) ) ) ; String [ ] format = Setup . get Drop Manifest Message Format ( ) ; boolean is Local = is Local Move ( car ) ; if ( is Local ) { buf = new String Buffer ( pad And Truncate String ( Setup . get Local Prefix ( ) , Setup . get Manifest Prefix Length ( ) ) ) ; format = Setup . get Local Manifest Message Format ( ) ; } drop Car ( file , car , buf , format , is Local , is Manifest ) ; } else { String Buffer buf = new String Buffer ( pad And Truncate String ( Setup . get Switch List Drop Car Prefix ( ) , Setup . get Switch List Prefix Length ( ) ) ) ; String [ ] format = Setup . get Drop Switch List Message Format ( ) ; boolean is Local = is Local Move ( car ) ; if ( is Local ) { buf = new String Buffer ( pad And Truncate String ( Setup . get Switch List Local Prefix ( ) , Setup . get Switch List Prefix Length ( ) ) ) ; format = Setup . get Local Switch List Message Format ( ) ; } drop Car ( file , car , buf , format , is Local , is Manifest ) ; } }
@ After Method public void delete Storage ( ) throws Business Exception , IO Exception , Serialization Exception { if ( null != storage Data ) { if ( storage Manager . get Recording State ( ) == Recording State . ON ) { storage Manager . stop Recording ( ) ; } if ( ! storage Manager . is Storage Closed ( storage Data ) ) { storage Manager . close Storage ( storage Data ) ; } storage Manager . delete Storage ( storage Data ) ; storage Data = null ; } assert That ( storage Manager . get Existing Storages ( ) , is ( empty ( ) ) ) ; }
public final void remove Element At ( int i ) { if ( i > m first Free ) System . arraycopy ( m map , i + NUM , m map , i , m first Free ) ; else m map [ i ] = java . lang . Integer . MIN VALUE ; m first Free -- ; }
protected int key On List ( String key , List < String > list ) { int ret = - NUM ; int index = NUM ; if ( list != null ) { for ( String list Key : list ) { if ( list Key . equals Ignore Case ( key ) ) { ret = index ; break ; } index ++ ; } } return ret ; }
private boolean increment Sentence ( ) throws IO Exception { if ( length == NUM ) return BOOL ; while ( BOOL ) { int start = iterator . current ( ) ; if ( start == Break Iterator . DONE ) return BOOL ; int end = iterator . next ( ) ; if ( end == Break Iterator . DONE ) return BOOL ; set Next Sentence ( start , end ) ; if ( increment Word ( ) ) { return BOOL ; } } }
Enumeration < Crypto Permission Entry > permission Elements ( ) { return permission Entries . elements ( ) ; }
private static char [ ] zz Unpack C Map ( String packed ) { char [ ] map = new char [ NUM ] ; int i = NUM ; int j = NUM ; while ( i < NUM ) { int count = packed . char At ( i ++ ) ; char value = packed . char At ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM ) ; } return map ; }
private static void populate Access Request ( Access Request access Request ) { access Request . set Access License Number ( props . get Property ( LICENSE NUMBER ) ) ; access Request . set User Id ( props . get Property ( USER NAME ) ) ; access Request . set Password ( props . get Property ( PASSWORD ) ) ; }
public Binary Table ( Header my Header ) throws Fits Exception { long heap Size L = my Header . get Long Value ( PCOUNT ) ; long heap Offset L = my Header . get Long Value ( THEAP ) ; if ( heap Offset L > MAX INTEGER VALUE ) { throw new Fits Exception ( STRING ) ; } if ( heap Size L > MAX INTEGER VALUE ) { throw new Fits Exception ( STRING ) ; } if ( heap Size L - heap Offset L > MAX INTEGER VALUE ) { throw new Fits Exception ( STRING ) ; } this . heap Offset = ( int ) heap Offset L ; int heap Size = ( int ) heap Size L ; int rwsz = my Header . get Int Value ( NAXIS 1 ) ; this . n Row = my Header . get Int Value ( NAXIS 2 ) ; if ( this . heap Offset > NUM ) { this . heap Offset -= this . n Row * rwsz ; } if ( this . heap Offset < NUM || this . heap Offset > heap Size ) { throw new Fits Exception ( STRING ) ; } this . heap = new Fits Heap ( heap Size - this . heap Offset ) ; int n Col = my Header . get Int Value ( TFIELDS ) ; this . row Len = NUM ; for ( int col = NUM ; col < n Col ; col ++ ) { this . row Len += process Col ( my Header , col ) ; } Header Card card = my Header . find Card ( NAXIS 1 ) ; card . set Value ( String . value Of ( this . row Len ) ) ; my Header . update Line ( NAXIS 1 , card ) ; }
public static Task Context current ( ) { final Deque < Task Context > stack = context Stacks . get ( ) ; if ( stack == null ) { return null ; } return stack . peek Last ( ) ; }
public static byte [ ] concat ( final byte [ ] ... arrays ) { int total Size = NUM ; for ( final byte [ ] array : arrays ) { total Size += array . length ; } int start Index = NUM ; final byte [ ] result = new byte [ total Size ] ; for ( final byte [ ] array : arrays ) { System . arraycopy ( array , NUM , result , start Index , array . length ) ; start Index += array . length ; } return result ; }
public JK Namespace ( final String url , final String prefix ) { logger . info ( String . format ( STRING , url , prefix ) ) ; this . url = url ; this . prefix = prefix ; }
public boolean is Lifo ( ) { String cm = get Costing Method ( ) ; return cm != null && cm . equals ( COSTINGMETHOD Lifo ) && COSTELEMENTTYPE Material . equals ( get Cost Element Type ( ) ) ; }
public static void main ( String [ ] args ) throws Exception { final String cfg = STRING ; final Class < ? extends Benchmark Driver > benchmark = Ignite Sql Query Benchmark . class ; final int threads = NUM ; final boolean client Driver Node = BOOL ; final int extra Nodes = NUM ; final int warm Up = NUM ; final int duration = NUM ; final int range = NUM ; final boolean throughput Latency Probe = BOOL ; for ( int i = NUM ; i < extra Nodes ; i ++ ) { Ignite Configuration node Cfg = Ignition . load Spring Bean ( cfg , STRING ) ; node Cfg . set Grid Name ( STRING + i ) ; node Cfg . set Metrics Log Frequency ( NUM ) ; Ignition . start ( node Cfg ) ; } Array List < String > args 0 = new Array List < > ( ) ; add Arg ( args 0 , STRING , threads ) ; add Arg ( args 0 , STRING , warm Up ) ; add Arg ( args 0 , STRING , duration ) ; add Arg ( args 0 , STRING , range ) ; add Arg ( args 0 , STRING , benchmark . get Simple Name ( ) ) ; add Arg ( args 0 , STRING , STRING ) ; add Arg ( args 0 , STRING , cfg ) ; if ( throughput Latency Probe ) add Arg ( args 0 , STRING , STRING ) ; if ( client Driver Node ) args 0 . add ( STRING ) ; Benchmark Driver Start Up . main ( args 0 . to Array ( new String [ args 0 . size ( ) ] ) ) ; }
public static boolean safe Navigation Operator Defined ( String nested Field Name ) { if ( nested Field Name . contains ( SAFE NAVIGATION OPERATOR ) ) if ( ! nested Field Name . starts With ( SAFE NAVIGATION OPERATOR ) ) throw new Mapping Exception ( STRING ) ; else return BOOL ; return BOOL ; }
public static boolean is Enabled ( ) { if ( s Enabled == null ) { s Enabled = detect Enabled ( ) ; } return s Enabled . boolean Value ( ) ; }
public boolean intersects ( Geo Bounds other ) { boolean rv = BOOL ; for ( Rectangle 2 D r1 : rects ) { for ( Rectangle 2 D r2 : other . rects ) { rv = r1 . intersects ( r2 ) ; if ( rv ) { break ; } } if ( rv ) { break ; } } return rv ; }
public void dispose ( ) { m Listeners . clear ( ) ; }
public void open Image Gallery ( final Action Listener response ) { open Gallery ( response , Display . GALLERY IMAGE ) ; }
private void read Object ( final java . io . Object Input Stream in ) throws IO Exception , Class Not Found Exception { inequality Symbol = ( String ) in . read Object ( ) ; time Stamp = in . read Long ( ) ; }
String pop Base Indentifier ( ) { return ( String ) m base Identifiers . pop ( ) ; }
@ Nullable public static File resolve Drawable ( @ Not Null Render Resources resources , @ Nullable Resource Value drawable , @ Not Null Project project ) { if ( drawable != null ) { drawable = resources . resolve Res Value ( drawable ) ; } if ( drawable == null ) { return null ; } String result = drawable . get Value ( ) ; State List state List = resolve State List ( resources , drawable , project ) ; if ( state List != null ) { List < State List State > states = state List . get States ( ) ; if ( ! states . is Empty ( ) ) { State List State state = states . get ( states . size ( ) - NUM ) ; result = state . get Value ( ) ; } } if ( result == null ) { return null ; } final File file = new File ( result ) ; return file . is File ( ) ? file : null ; }
public static void delete ( String code , JDA jda ) { Invite invite = resolve ( code ) ; if ( invite == null ) throw new Illegal Argument Exception ( STRING + STRING + code ) ; delete ( invite , jda ) ; }
private void update Header Separator ( ) { final String best Date Time Pattern = Date Format Utils . get Best Date Time Pattern ( m Current Locale , ( m Is 24 Hour View ) ? STRING : STRING ) ; final String separator Text ; final char [ ] hour Formats = { STRING , STRING , STRING , STRING } ; int h Index = last Index Of Any ( best Date Time Pattern , hour Formats ) ; if ( h Index == - NUM ) { separator Text = STRING ; } else { separator Text = Character . to String ( best Date Time Pattern . char At ( h Index + NUM ) ) ; } m Separator View . set Text ( separator Text ) ; }
protected void connection Failed ( Channel failed Channel , IO Exception cause ) { failure Cause = IO Exception Support . create ( cause ) ; channel = failed Channel ; connected . set ( BOOL ) ; connect Latch . count Down ( ) ; }
public void test Missing Application ( ) throws Exception { m Enabled . add ( Launcher Activity Detector . ISSUE MORE THAN ONE LAUNCHER ) ; m Enabled . add ( Launcher Activity Detector . ISSUE MISSING LAUNCHER ) ; m Enabled . add ( Launcher Activity Detector . ISSUE LAUNCHER ACTIVITY IN LIBRARY ) ; String expected = STRING ; String result = lint Project ( xml ( FN ANDROID MANIFEST XML , STRING + STRING + STRING + STRING + STRING ) ) ; assert Equals ( expected , result ) ; }
public String to String ( ) { Array List fields = new Array List ( NUM ) ; fields . add ( codebase ) ; fields . add ( policy ) ; fields . add ( classpath ) ; fields . add ( impl Class Name ) ; fields . add ( ( ( server Config Args == null ) ? null : Arrays . as List ( server Config Args ) ) ) ; fields . add ( life Cycle ) ; fields . add ( service Preparer ) ; return fields . to String ( ) ; }
public Drawable create From Path ( String path Name ) { return Drawable . create From Path ( path Name ) ; }
@ Override public void parse ( Reader reader , String base URI ) throws IO Exception , RDF Parse Exception , RDF Handler Exception { if ( reader == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( base URI == null ) { throw new Illegal Argument Exception ( STRING ) ; } Input Source input Source = new Input Source ( reader ) ; input Source . set System Id ( base URI ) ; parse ( input Source ) ; }
final public void print ( double v ) { try { out . print ( v ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } }
public static boolean is Empty ( String string ) { return string == null || string . length ( ) == NUM ; }
public static boolean is XML 11 Valid Name ( String name ) { int length = name . length ( ) ; if ( length == NUM ) return BOOL ; int i = NUM ; char ch = name . char At ( NUM ) ; if ( ! is XML 11 Name Start ( ch ) ) { if ( length > NUM && is XML 11 Name High Surrogate ( ch ) ) { char ch 2 = name . char At ( NUM ) ; if ( ! XML Char . is Low Surrogate ( ch 2 ) || ! is XML 11 Name Start ( XML Char . supplemental ( ch , ch 2 ) ) ) { return BOOL ; } i = NUM ; } else { return BOOL ; } } while ( i < length ) { ch = name . char At ( i ) ; if ( ! is XML 11 Name ( ch ) ) { if ( ++ i < length && is XML 11 Name High Surrogate ( ch ) ) { char ch 2 = name . char At ( i ) ; if ( ! XML Char . is Low Surrogate ( ch 2 ) || ! is XML 11 Name ( XML Char . supplemental ( ch , ch 2 ) ) ) { return BOOL ; } } else { return BOOL ; } } ++ i ; } return BOOL ; }
public void reset ( ) { m Expected Events . clear ( ) ; m Expected Interrupt = BOOL ; m Replaying = BOOL ; }
String generate Digest ( File file Dir , String file Name ) { final String algorithm = STRING ; Input Stream file Stream = null ; Digest Input Stream d = null ; try { file Stream = get File Stream ( file Dir , file Name ) ; Message Digest md = Message Digest . get Instance ( algorithm ) ; d = new Digest Input Stream ( file Stream , md ) ; byte [ ] buffer = new byte [ NUM ] ; while ( d . read ( buffer ) != - NUM ) { } return to Hex String ( md . digest ( ) ) ; } catch ( No Such Algorithm Exception e ) { return algorithm + STRING ; } catch ( IO Exception e ) { C Log . e ( e ) ; } finally { Stream Util . close Stream ( d ) ; Stream Util . close Stream ( file Stream ) ; } return STRING ; }
public Agent Config environment To Configuration ( Environment environment , long platform Id ) { Agent Config agent Configuration = new Agent Config ( ) ; agent Configuration . set Platform Id ( platform Id ) ; if ( Collection Utils . is Not Empty ( environment . get Platform Sensor Configs ( ) ) ) { Collection < Platform Sensor Type Config > platform Sensor Type Configs = new Array List < > ( ) ; for ( I Platform Sensor Config platform Sensor Config : environment . get Platform Sensor Configs ( ) ) { if ( platform Sensor Config . is Active ( ) ) { platform Sensor Type Configs . add ( get Platform Sensor Type Config ( platform Id , platform Sensor Config ) ) ; } } agent Configuration . set Platform Sensor Type Configs ( platform Sensor Type Configs ) ; } else { agent Configuration . set Platform Sensor Type Configs ( Collections . < Platform Sensor Type Config > empty List ( ) ) ; } if ( Collection Utils . is Not Empty ( environment . get Method Sensor Configs ( ) ) ) { Collection < Method Sensor Type Config > method Sensor Type Configs = new Array List < > ( ) ; for ( I Method Sensor Config method Sensor Config : environment . get Method Sensor Configs ( ) ) { method Sensor Type Configs . add ( get Method Sensor Type Config ( platform Id , method Sensor Config ) ) ; } agent Configuration . set Method Sensor Type Configs ( method Sensor Type Configs ) ; } else { agent Configuration . set Method Sensor Type Configs ( Collections . < Method Sensor Type Config > empty List ( ) ) ; } I Exception Sensor Config exception Sensor Config = environment . get Exception Sensor Config ( ) ; if ( null != exception Sensor Config ) { agent Configuration . set Exception Sensor Type Config ( get Exception Sensor Type Config ( platform Id , exception Sensor Config ) ) ; } Jmx Sensor Config jmx Sensor Config = environment . get Jmx Sensor Config ( ) ; if ( null != jmx Sensor Config ) { agent Configuration . set Jmx Sensor Type Config ( get Jmx Sensor Type Config ( platform Id , jmx Sensor Config ) ) ; } I Strategy Config buffer Strategy Config = environment . get Buffer Strategy Config ( ) ; agent Configuration . set Buffer Strategy Config ( new Strategy Config ( buffer Strategy Config . get Class Name ( ) , buffer Strategy Config . get Settings ( ) ) ) ; I Strategy Config sending Strategy Config = environment . get Sending Strategy Config ( ) ; agent Configuration . set Sending Strategy Config ( new Strategy Config ( sending Strategy Config . get Class Name ( ) , sending Strategy Config . get Settings ( ) ) ) ; Collection < Exclude Rule > exclude Rules = configuration Resolver . get All Exclude Rules ( environment ) ; if ( Collection Utils . is Not Empty ( exclude Rules ) ) { Collection < I Match Pattern > exclude Classes Patterns = new Array List < > ( ) ; for ( Exclude Rule exclude Rule : exclude Rules ) { exclude Classes Patterns . add ( Pattern Factory . get Pattern ( exclude Rule . get Class Name ( ) ) ) ; } agent Configuration . set Exclude Classes Patterns ( exclude Classes Patterns ) ; } else { agent Configuration . set Exclude Classes Patterns ( Collections . < I Match Pattern > empty List ( ) ) ; } agent Configuration . set Configuration Info ( configuration Resolver . get Configuration Info ( environment ) ) ; return agent Configuration ; }
private void initialize Name Goals ( Map < Test Case , Set < Test Fitness Function > > test To Goals ) { for ( Map . Entry < Test Case , Set < Test Fitness Function > > entry : test To Goals . entry Set ( ) ) { Set < Test Fitness Function > goals = new Linked Hash Set < > ( ) ; List < Test Fitness Function > top Goals = get Top Goals ( entry . get Value ( ) ) ; if ( top Goals . is Empty ( ) ) { } else if ( top Goals . size ( ) <= MAX SIMILAR GOALS ) { for ( Test Fitness Function goal : top Goals ) { goals . add ( goal ) ; String goal Name = get Test Name ( entry . get Key ( ) , goals ) ; if ( goal Name . length ( ) > MAX CHARS ) { goals . remove ( goal ) ; break ; } } } else { goals . add ( choose Representative Goal ( entry . get Key ( ) , top Goals ) ) ; } test To Goals . put ( entry . get Key ( ) , goals ) ; } }
public static java . lang . Double value Of ( java . lang . String s ) throws java . lang . Number Format Exception { return new Double ( parse Double ( s ) ) ; }
private void write Object ( java . io . Object Output Stream s ) throws java . io . IO Exception { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { s . default Write Object ( ) ; for ( Node < E > p = first ; p != null ; p = p . next ) s . write Object ( p . item ) ; s . write Object ( null ) ; } finally { lock . unlock ( ) ; } }
public boolean is Parse Robots Txt ( ) { return parse Robots Txt ; }
public String byte Array To Base 64 ( byte [ ] bytes ) { return Base 64 . encode Base 64 String ( bytes ) ; }
private void validate Index Storage ( ) { Closeable Iterator < Index Store Entry > iterator = null ; try { Array List structure List = new Array List ( ) ; iterator = index Data Structure . iterator ( null ) ; while ( iterator . has Next ( ) ) { Index Store Entry ie = iterator . next ( ) ; if ( entries Contains ( ie ) ) { structure List . add ( ie ) ; } else { fail ( STRING + ie ) ; } } assert Equals ( STRING , entries . size ( ) , structure List . size ( ) ) ; } finally { if ( iterator != null ) { iterator . close ( ) ; } } }
protected void on Exception ( final Wro Runtime Exception e ) { throw e ; }
private int quantize ( long x ) { return NUM + ( int ) Math . floor ( Math . log ( x ) / Math . log ( quantization Base ) ) ; }
public static boolean validate Output Directory ( File directory ) { if ( directory . exists ( ) ) { Diagnostic . error ( Error Type . DIRECTORY EXISTS , directory . get Path ( ) ) ; return BOOL ; } return BOOL ; }
@ Override public void on Web Socket Close ( int status Code , String reason ) { super . on Web Socket Close ( status Code , reason ) ; log . info ( STRING , peer ID , Integer . to String ( status Code ) + STRING + reason ) ; store . unsubscribe ( handle ) ; }
@ Override public double log Density ( double value ) { update Boundaries And Or Weights ( ) ; if ( m Boundaries == null ) { return Math . log ( Double . MIN VALUE ) ; } int index = Arrays . binary Search ( m Boundaries , value ) ; if ( ( index == - NUM ) || ( index == - m Boundaries . length - NUM ) ) { double val = NUM ; if ( index == - NUM ) { val = m TM . first Key ( ) - value ; } else { val = value - m TM . last Key ( ) ; } return ( CONST - Math . log ( m Width ) - NUM * ( val * val / ( m Width * m Width ) ) ) - Math . log ( m Sum Of Weights + NUM ) ; } if ( index == m Boundaries . length - NUM ) { index -- ; } else { if ( index < NUM ) { index = - index - NUM ; } } double width = m Boundaries [ index + NUM ] - m Boundaries [ index ] ; double dens Smeared Out = NUM / ( ( m Sum Of Weights + NUM ) * ( m Boundaries [ m Boundaries . length - NUM ] - m Boundaries [ NUM ] ) ) ; if ( m Weights [ index ] <= NUM ) { return Math . log ( dens Smeared Out ) ; } else { return Math . log ( dens Smeared Out + m Weights [ index ] / ( ( m Sum Of Weights + NUM ) * width ) ) ; } }
public void draw Point ( Graphics sc , I Point p ) { double x1 = p . get X ( ) ; double y1 = p . get Y ( ) ; sc . draw Oval ( ( int ) x1 - NUM , ( int ) y1 - NUM , NUM , NUM ) ; }
private static int compute Capacity ( final int expected Size ) { if ( expected Size == NUM ) { return NUM ; } final int capacity = ( int ) Fast Math . ceil ( expected Size / LOAD FACTOR ) ; final int power Of Two = Integer . highest One Bit ( capacity ) ; if ( power Of Two == capacity ) { return capacity ; } return next Power Of Two ( capacity ) ; }
public static void append String ( final String Buffer buf , final String s ) { buf . append ( STRING ) ; for ( int i = NUM ; i < s . length ( ) ; ++ i ) { char c = s . char At ( i ) ; if ( c == STRING ) { buf . append ( STRING ) ; } else if ( c == STRING ) { buf . append ( STRING ) ; } else if ( c == STRING ) { buf . append ( STRING ) ; } else if ( c == STRING ) { buf . append ( STRING ) ; } else if ( c < NUM || c > NUM ) { buf . append ( STRING ) ; if ( c < NUM ) { buf . append ( STRING ) ; } else if ( c < NUM ) { buf . append ( STRING ) ; } else if ( c < NUM ) { buf . append ( STRING ) ; } buf . append ( Integer . to String ( c , NUM ) ) ; } else { buf . append ( c ) ; } } buf . append ( STRING ) ; }
protected void a process Junction nns ( String name , Continuation cont ) throws Naming Exception { if ( name . equals ( STRING ) ) { Name Not Found Exception e = new Name Not Found Exception ( ) ; cont . set Error NNS ( this , name ) ; throw cont . fill In Exception ( e ) ; } try { Object target = a lookup ( name , cont ) ; if ( cont . is Continue ( ) ) cont . append Remaining Component ( STRING ) ; else { cont . set Continue NNS ( target , name , this ) ; } } catch ( Naming Exception e ) { e . append Remaining Component ( STRING ) ; throw e ; } }
public void add Callback ( Callback callback ) { if ( ! m Callbacks . contains ( callback ) ) { m Callbacks . add ( callback ) ; } }
public J Tidy Document Builder Factory ( Document Builder Setting [ ] settings ) throws DOM Test Incompatible Exception { super ( settings ) ; try { Class Loader class Loader = Class Loader . get System Class Loader ( ) ; Class tidy Class = class Loader . load Class ( STRING ) ; tidy Constructor = tidy Class . get Constructor ( NO CLASSES ) ; parse DOM Method = tidy Class . get Method ( STRING , new Class [ ] { java . io . Input Stream . class , java . io . Output Stream . class } ) ; dom Impl = new J Tidy DOM Implementation ( ) ; } catch ( Exception ex ) { throw new DOM Test Incompatible Exception ( ex , null ) ; } if ( settings != null ) { for ( int i = NUM ; i < settings . length ; i ++ ) { } } }
public void dispose ( ) { log Debug ( STRING ) ; m Setup Done = BOOL ; if ( m Service Conn != null ) { log Debug ( STRING ) ; if ( m Context != null ) m Context . unbind Service ( m Service Conn ) ; } m Disposed = BOOL ; m Context = null ; m Service Conn = null ; m Service = null ; m Purchase Listener = null ; }
public void enqueue ( Terminating Runnable r ) { synchronized ( queue ) { queue . add ( r ) ; queue . notify All ( ) ; } }
protected void do Process Message ( DTLS Message message ) throws Handshake Exception , General Security Exception { }
public void add Certificates And CR Ls ( Cert Store cert Store ) throws Cert Store Exception , CMS Exception { certs . add All ( CMS Utils . get Certificates From Store ( cert Store ) ) ; crls . add All ( CMS Utils . get CR Ls From Store ( cert Store ) ) ; }
void disconnect ( ) { synchronized ( lock ) { disconnected = BOOL ; lock . notify All ( ) ; } }
public Simple Rate Limiter ( double mb Per Sec ) { set MB Per Sec ( mb Per Sec ) ; last NS = System . nano Time ( ) ; }
private long wc ( String text ) { long wc = NUM ; String [ ] lines = text . split ( STRING ) ; for ( String line : lines ) { wc += line . split ( STRING ) . length ; } return wc ; }
public boolean unbind ( ) { boolean worked = BOOL ; if ( m rx Thread == null ) worked = BOOL ; else m stop Rx = BOOL ; return worked ; }
public void register ( Schedule schedule ) { Integer old Size = Integer . value Of ( schedule Hash Table . size ( ) ) ; schedule Hash Table . put ( schedule . get Id ( ) , schedule ) ; int id = Integer . parse Int ( schedule . get Id ( ) ) ; if ( id > id ) { id = id ; } set Dirty And Fire Property Change ( LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( schedule Hash Table . size ( ) ) ) ; }
public final void write Maple Ascii String ( final String s ) { write Short ( ( short ) s . length ( ) ) ; write Ascii String ( s ) ; }
public static boolean has UID ( String classname ) { boolean result ; try { result = has UID ( Class . for Name ( classname ) ) ; } catch ( Exception e ) { result = BOOL ; } return result ; }
public static boolean remove Directory ( String path To Dir ) { return delete Recursive ( new File ( path To Dir ) ) ; }
public static final boolean validate Group Name ( String s Group Name ) { if ( s Group Name . length ( ) == NUM ) { return BOOL ; } return s Group Name . matches ( STRING ) ; }
private void init ( Configuration conf ) { try { if ( this . id > NUM ) { Default Listener d = new Default Listener ( ) ; d . upgrade ( conf , this ) ; } if ( ! X . is Empty ( listener ) ) { String name = listener ; if ( name != null ) { try { Class < ? > c = Class . for Name ( name , BOOL , class Loader ) ; Object o = c . new Instance ( ) ; if ( o instanceof I Listener ) { log . info ( STRING + name ) ; I Listener l = ( I Listener ) o ; l . upgrade ( conf , this ) ; l . on Start ( conf , this ) ; } } catch ( Throwable e ) { log . error ( this . name + STRING + name , e ) ; } } } } catch ( Throwable e ) { log . error ( e . get Message ( ) , e ) ; } }
private boolean is Scan Root Available ( URL url ) { for ( Scan Root scan Root : pending Scan Roots ) { if ( url . equals ( scan Root . get Url ( ) ) ) return BOOL ; } return BOOL ; }
public Sequential Listener Manager add Listener Executor ( int index , Listener listener , Listener Executor executor ) { if ( listeners . contains ( listener ) ) throw new Illegal Argument Exception ( STRING + listener ) ; listeners . add ( index , listener ) ; listener Executors . add ( index , executor ) ; return this ; }
private boolean has As Parent ( I Node child , I Composite Node direct Parent ) { I Node parent = child ; while ( parent != null ) { if ( parent == direct Parent ) return BOOL ; parent = parent . get Parent ( ) ; } return BOOL ; }
public void clear Markers ( ) { m Google Map . clear ( ) ; markers . clear ( ) ; }
@ Override public double cloudlet Submit ( Cloudlet cl ) { return cloudlet Submit ( cl , NUM ) ; }
public void verifying Token ( ) { set Token Info ( STRING ) ; verify Token . set Enabled ( BOOL ) ; }
public Certificate build Certificate ( String cert String ) throws Invalid Certificate { try { String base 64 Cert = format Certificate ( cert String ) ; Input Stream in Bytes = new Byte Array Input Stream ( base 64 Cert . get Bytes ( ) ) ; Certificate Factory cf = Certificate Factory . get Instance ( STRING ) ; assert in Bytes . available ( ) > NUM ; Certificate certificate = cf . generate Certificate ( in Bytes ) ; in Bytes . close ( ) ; return certificate ; } catch ( Exception e ) { log . debug ( STRING + e + STRING ) ; throw Fault Util . Invalid Certificate ( STRING ) ; } }
private Page Leaf Impl compact ( Table Kelp table ) { long now = Current Time . current Time ( ) / NUM ; Set < Page Leaf Entry > entries = fill Entries ( table ) ; Array List < Block Leaf > blocks = new Array List < > ( ) ; Block Leaf block = new Block Leaf ( get Id ( ) ) ; blocks . add ( block ) ; Row row = table . row ( ) ; for ( Page Leaf Entry entry : entries ) { if ( entry . get Code ( ) != INSERT && entry . get Expires ( ) <= now ) { continue ; } while ( ! block . add Entry ( row , entry ) ) { block = new Block Leaf ( get Id ( ) ) ; blocks . add ( block ) ; } } Page Leaf Impl new Page = new Page Leaf Impl ( get Id ( ) , get Next Id ( ) , get Sequence ( ) , table , get Min Key ( ) , get Max Key ( ) , blocks ) ; new Page . validate ( table ) ; new Page . to Sorted ( table ) ; if ( is Dirty ( ) ) { new Page . set Dirty ( ) ; } if ( stub != null ) { stub . copy To Compact ( new Page ) ; } return new Page ; }
public Sabres Query ( Class < T > clazz ) { this . clazz = clazz ; name = clazz . get Simple Name ( ) ; inner Queries = null ; }
S Node await Fulfill ( S Node s , boolean timed , long nanos ) { final long deadline = timed ? System . nano Time ( ) + nanos : NUM ; Thread w = Thread . current Thread ( ) ; int spins = ( should Spin ( s ) ? ( timed ? max Timed Spins : max Untimed Spins ) : NUM ) ; for ( ; ; ) { if ( w . is Interrupted ( ) ) s . try Cancel ( ) ; S Node m = s . match ; if ( m != null ) return m ; if ( timed ) { nanos = deadline - System . nano Time ( ) ; if ( nanos <= NUM ) { s . try Cancel ( ) ; continue ; } } if ( spins > NUM ) spins = should Spin ( s ) ? ( spins - NUM ) : NUM ; else if ( s . waiter == null ) s . waiter = w ; else if ( ! timed ) Lock Support . park ( this ) ; else if ( nanos > spin For Timeout Threshold ) Lock Support . park Nanos ( this , nanos ) ; } }
public String backup Now ( String backup File Prefix ) throws Mc Exception , IO Exception { logger . debug ( STRING ) ; return Backup . backup ( backup File Prefix ) ; }
public static void CF 7 ( double [ ] x , double [ ] f , double [ ] c , int nx ) { double sum 1 = NUM ; double sum 2 = NUM ; double yj ; for ( int j = NUM ; j <= nx ; j ++ ) { if ( j % NUM == NUM ) { yj = x [ j - NUM ] - Math . cos ( NUM * PI * x [ NUM ] + j * PI / nx ) ; sum 1 += NUM * yj * yj - Math . cos ( NUM * PI * yj ) + NUM ; } else { yj = x [ j - NUM ] - Math . sin ( NUM * PI * x [ NUM ] + j * PI / nx ) ; if ( j == NUM || j == NUM ) { sum 2 += yj * yj ; } else { sum 2 += NUM * yj * yj - Math . cos ( NUM * PI * yj ) + NUM ; } } } f [ NUM ] = x [ NUM ] + sum 1 ; f [ NUM ] = ( NUM - x [ NUM ] ) * ( NUM - x [ NUM ] ) + sum 2 ; c [ NUM ] = x [ NUM ] - Math . sin ( NUM * x [ NUM ] * PI + NUM * PI / nx ) - MYSIGN ( ( x [ NUM ] - NUM ) * ( NUM - x [ NUM ] ) ) * Math . sqrt ( Math . abs ( ( x [ NUM ] - NUM ) * ( NUM - x [ NUM ] ) ) ) ; c [ NUM ] = x [ NUM ] - Math . sin ( NUM * x [ NUM ] * PI + NUM * PI / nx ) - MYSIGN ( NUM * Math . sqrt ( NUM - x [ NUM ] ) - NUM * ( NUM - x [ NUM ] ) ) * Math . sqrt ( Math . abs ( NUM * Math . sqrt ( NUM - x [ NUM ] ) - NUM * ( NUM - x [ NUM ] ) ) ) ; }
void fully Unlock ( ) { take Lock . unlock ( ) ; put Lock . unlock ( ) ; }
public boolean is Clustered Host ( Storage System storage , List < Initiator > initiators ) { return is Clustered Host ( storage , initiators , null ) ; }
public static List < Substring Replacer Match Rule > match Rules From Internal ( String match Replace Details , Instances input Structure , String status Message Prefix , Logger log , Environment env ) { List < Substring Replacer Match Rule > match Rules = new Array List < Substring Replacer Match Rule > ( ) ; String [ ] mr Parts = match Replace Details . split ( STRING ) ; for ( String p : mr Parts ) { Substring Replacer Match Rule mr = new Substring Replacer Match Rule ( p . trim ( ) ) ; mr . m status Message Prefix = status Message Prefix ; mr . m logger = log ; mr . init ( env , input Structure ) ; match Rules . add ( mr ) ; } return match Rules ; }
private static void time ( Date Time Formatter Builder bld , Collection < Date Time Field Type > fields , boolean extended , boolean strict ISO , boolean reduced Prec , boolean date Present ) { boolean hour = fields . remove ( Date Time Field Type . hour Of Day ( ) ) ; boolean minute = fields . remove ( Date Time Field Type . minute Of Hour ( ) ) ; boolean second = fields . remove ( Date Time Field Type . second Of Minute ( ) ) ; boolean milli = fields . remove ( Date Time Field Type . millis Of Second ( ) ) ; if ( ! hour && ! minute && ! second && ! milli ) { return ; } if ( hour || minute || second || milli ) { if ( strict ISO && reduced Prec ) { throw new Illegal Argument Exception ( STRING + fields ) ; } if ( date Present ) { bld . append Literal ( STRING ) ; } } if ( hour && minute && second || ( hour && ! second && ! milli ) ) { } else { if ( strict ISO && date Present ) { throw new Illegal Argument Exception ( STRING + fields ) ; } if ( ! hour && ( minute && second || ( minute && ! milli ) || second ) ) { } else { if ( strict ISO ) { throw new Illegal Argument Exception ( STRING + fields ) ; } } } if ( hour ) { bld . append Hour Of Day ( NUM ) ; } else if ( minute || second || milli ) { bld . append Literal ( STRING ) ; } if ( extended && hour && minute ) { bld . append Literal ( STRING ) ; } if ( minute ) { bld . append Minute Of Hour ( NUM ) ; } else if ( second || milli ) { bld . append Literal ( STRING ) ; } if ( extended && minute && second ) { bld . append Literal ( STRING ) ; } if ( second ) { bld . append Second Of Minute ( NUM ) ; } else if ( milli ) { bld . append Literal ( STRING ) ; } if ( milli ) { bld . append Literal ( STRING ) ; bld . append Millis Of Second ( NUM ) ; } }
public static Object [ ] merge And Extract Params ( Map < String , ? extends Object > global Config , Map < String , ? extends Object > local Params , Collection < String > ignore Params , Map < String , External Resource Description > resources ) { Set < String > unique Params = new Hash Set < > ( ) ; unique Params . add All ( local Params . key Set ( ) ) ; unique Params . add All ( global Config . key Set ( ) ) ; if ( ignore Params != null ) { unique Params . remove All ( ignore Params ) ; } Object [ ] params = new Object [ resources . size ( ) * NUM + unique Params . size ( ) * NUM ] ; int i = NUM ; for ( Entry < String , External Resource Description > entry : resources . entry Set ( ) ) { params [ i ++ ] = entry . get Key ( ) ; params [ i ++ ] = entry . get Value ( ) ; } for ( String key : unique Params ) { params [ i ++ ] = key ; if ( local Params . contains Key ( key ) ) { params [ i ++ ] = Cpe Builder Utils . convert To Parameter Value ( local Params . get ( key ) ) ; } else { params [ i ++ ] = Cpe Builder Utils . convert To Parameter Value ( global Config . get ( key ) ) ; } } return params ; }
public void store Properties ( String artifact , String version , Properties props ) throws IO Exception { Path properties File = get Properties File ( artifact , version ) ; Path dir = properties File . get Parent ( ) ; if ( ! Files . exists ( dir ) ) { Files . create Directories ( dir ) ; } try ( Output Stream out = new Buffered Output Stream ( new Output Stream ( properties File ) ) ) { props . store ( out , null ) ; } }
public static String make Descriptor ( Class [ ] params , Class ret Type ) { String Buffer sbuf = new String Buffer ( ) ; sbuf . append ( STRING ) ; for ( int i = NUM ; i < params . length ; i ++ ) make Desc ( sbuf , params [ i ] ) ; sbuf . append ( STRING ) ; if ( ret Type != null ) make Desc ( sbuf , ret Type ) ; return sbuf . to String ( ) ; }
public boolean is Loggable ( Level lev ) { return logger . is Loggable ( lev ) ; }
int parse Hour ( String source , char pattern Char , int offset ) throws Parse Exception { int min = ( pattern Char == HOUR 1 LETTER || pattern Char == HOUR 12 1 LETTER ) ? NUM : NUM ; int max = ( ( pattern Char == HOUR LETTER || pattern Char == HOUR 1 LETTER ) ? NUM : NUM ) + min ; return parse Number ( source , offset , STRING , min , max ) - min ; }
@ Override public boolean supports Knowledge ( ) { return BOOL ; }
public void or ( Criteria criteria ) { ored Criteria . add ( criteria ) ; }
@ Data Provider public Object [ ] [ ] invalid Id Provider ( ) { return new Object [ ] [ ] { new Object [ ] { STRING , STRING , Http Status . SC NOT FOUND } , new Object [ ] { STRING , STRING , Http Status . SC NOT FOUND } , new Object [ ] { STRING , STRING , Http Status . SC INTERNAL SERVER ERROR } , new Object [ ] { STRING , STRING , Http Status . SC INTERNAL SERVER ERROR } , new Object [ ] { STRING , STRING , Http Status . SC INTERNAL SERVER ERROR } } ; }
public final static Header Element parse Header Element ( final String value , Header Value Parser parser ) throws Parse Exception { if ( value == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( parser == null ) parser = Basic Header Value Parser . DEFAULT ; Char Array Buffer buffer = new Char Array Buffer ( value . length ( ) ) ; buffer . append ( value ) ; Parser Cursor cursor = new Parser Cursor ( NUM , value . length ( ) ) ; return parser . parse Header Element ( buffer , cursor ) ; }
private static void attempt Retry On Exception ( String log Prefix , Request < ? > request , Volley Error exception ) throws Volley Error { Retry Policy retry Policy = request . get Retry Policy ( ) ; int old Timeout = request . get Timeout Ms ( ) ; try { retry Policy . retry ( exception ) ; } catch ( Volley Error e ) { request . add Marker ( String . format ( STRING , log Prefix , old Timeout ) ) ; throw e ; } request . add Marker ( String . format ( STRING , log Prefix , old Timeout ) ) ; }
public static String encode String ( String s ) { return new String ( encode ( s . get Bytes ( ) ) ) ; }
private void clear State ( ) { allocated Resources . clear ( ) ; requests To Count Map . clear ( ) ; requests Queue . clear ( ) ; }
public static double [ ] vector Box Corner ( double [ ] center , double [ ] result , double distance , boolean upper Right ) { if ( result == null || result . length != center . length ) { result = new double [ center . length ] ; } if ( upper Right == BOOL ) { distance = - distance ; } distance = SIN PI DIV 4 * distance ; for ( int i = NUM ; i < center . length ; i ++ ) { result [ i ] = center [ i ] + distance ; } return result ; }
public void to Array ( int [ ] array ) { System . arraycopy ( data , NUM , array , NUM , size ) ; }
public Fixed Secure Random ( boolean int Pad , byte [ ] [ ] values ) { Byte Array Output Stream b Out = new Byte Array Output Stream ( ) ; for ( int i = NUM ; i != values . length ; i ++ ) { try { b Out . write ( values [ i ] ) ; } catch ( IO Exception e ) { throw new Illegal Argument Exception ( STRING ) ; } } data = b Out . to Byte Array ( ) ; if ( int Pad ) { int Pad = data . length % NUM ; } }
@ Override protected void ensure Number Of Columns ( int number Of Columns ) { if ( data . length >= number Of Columns ) { return ; } long [ ] new Data = new long [ number Of Columns ] ; System . arraycopy ( data , NUM , new Data , NUM , data . length ) ; data = new Data ; }
private void write Attribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( xml Writer . get Prefix ( namespace ) == null ) { xml Writer . write Namespace ( prefix , namespace ) ; xml Writer . set Prefix ( prefix , namespace ) ; } xml Writer . write Attribute ( namespace , att Name , att Value ) ; }
public void invoke Hook Spout Ack ( Object message Id , long complete Latency Ns ) { if ( task Hooks . size ( ) != NUM ) { Spout Ack Info ack Info = new Spout Ack Info ( message Id , get This Task Id ( ) , complete Latency Ns / Constants . MILLISECONDS TO NANOSECONDS ) ; for ( I Task Hook task Hook : task Hooks ) { task Hook . spout Ack ( ack Info ) ; } } }
public static float wrap ( float value ) { if ( value >= NUM ) { return value - ( int ) value ; } float wrapped Value = value - ( float ) Math . floor ( value ) ; if ( wrapped Value >= NUM ) { wrapped Value -= NUM ; } return wrapped Value ; }
Stub Skeleton Writer ( Batch Environment env , Remote Class remote Class , Stub Version version ) { this . env = env ; this . remote Class = remote Class ; this . version = version ; stub Class Name = Util . binary Name Of ( remote Class . class Doc ( ) ) + STRING ; skeleton Class Name = Util . binary Name Of ( remote Class . class Doc ( ) ) + STRING ; int i = stub Class Name . last Index Of ( STRING ) ; package Name = ( i != - NUM ? stub Class Name . substring ( NUM , i ) : STRING ) ; stub Class Simple Name = stub Class Name . substring ( i + NUM ) ; skeleton Class Simple Name = skeleton Class Name . substring ( i + NUM ) ; remote Methods = remote Class . remote Methods ( ) ; method Field Names = name Method Fields ( remote Methods ) ; }
private void write Object ( java . io . Object Output Stream s ) throws java . io . IO Exception { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { s . default Write Object ( ) ; for ( Node < E > p = first ; p != null ; p = p . next ) s . write Object ( p . item ) ; s . write Object ( null ) ; } finally { lock . unlock ( ) ; } }
public void remove Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners == null ) { return ; } m Update Listeners . remove ( listener ) ; if ( m Update Listeners . size ( ) == NUM ) { m Update Listeners = null ; } }
public void put ( String key , Object value , boolean error On Fail ) { if ( value == null ) { put Null ( key ) ; } else if ( value instanceof Boolean ) { put ( key , ( Boolean ) value ) ; } else if ( value instanceof Byte ) { put ( key , ( Byte ) value ) ; } else if ( value instanceof Double ) { put ( key , ( Double ) value ) ; } else if ( value instanceof Float ) { put ( key , ( Float ) value ) ; } else if ( value instanceof Integer ) { put ( key , ( Integer ) value ) ; } else if ( value instanceof Long ) { put ( key , ( Long ) value ) ; } else if ( value instanceof Short ) { put ( key , ( Short ) value ) ; } else if ( value instanceof String ) { put ( key , ( String ) value ) ; } else if ( value instanceof byte [ ] ) { put ( key , ( byte [ ] ) value ) ; } else if ( error On Fail ) { throw new Unsupported Operation Exception ( STRING + value . get Class ( ) ) ; } }
private void step ( ) { casings . for Each ( null ) ; casings . for Each ( null ) ; casings . for Each ( null ) ; step Pipes ( ) ; step Forwarders ( ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return HOST ; case NUM : return PORT ; case NUM : return ID ; case NUM : return STATE ; case NUM : return TIMESTAMP ; case NUM : return VERSION ; default : return null ; } }
public static void CF 7 ( double [ ] x , double [ ] f , double [ ] c , int nx ) { double sum 1 = NUM ; double sum 2 = NUM ; double yj ; for ( int j = NUM ; j <= nx ; j ++ ) { if ( j % NUM == NUM ) { yj = x [ j - NUM ] - Math . cos ( NUM * PI * x [ NUM ] + j * PI / nx ) ; sum 1 += NUM * yj * yj - Math . cos ( NUM * PI * yj ) + NUM ; } else { yj = x [ j - NUM ] - Math . sin ( NUM * PI * x [ NUM ] + j * PI / nx ) ; if ( j == NUM || j == NUM ) { sum 2 += yj * yj ; } else { sum 2 += NUM * yj * yj - Math . cos ( NUM * PI * yj ) + NUM ; } } } f [ NUM ] = x [ NUM ] + sum 1 ; f [ NUM ] = ( NUM - x [ NUM ] ) * ( NUM - x [ NUM ] ) + sum 2 ; c [ NUM ] = x [ NUM ] - Math . sin ( NUM * x [ NUM ] * PI + NUM * PI / nx ) - MYSIGN ( ( x [ NUM ] - NUM ) * ( NUM - x [ NUM ] ) ) * Math . sqrt ( Math . abs ( ( x [ NUM ] - NUM ) * ( NUM - x [ NUM ] ) ) ) ; c [ NUM ] = x [ NUM ] - Math . sin ( NUM * x [ NUM ] * PI + NUM * PI / nx ) - MYSIGN ( NUM * Math . sqrt ( NUM - x [ NUM ] ) - NUM * ( NUM - x [ NUM ] ) ) * Math . sqrt ( Math . abs ( NUM * Math . sqrt ( NUM - x [ NUM ] ) - NUM * ( NUM - x [ NUM ] ) ) ) ; }
public static Number abs ( Number a ) { if ( is Floating Point ( a ) ) { return Math . abs ( a . double Value ( ) ) ; } else { return Math . abs ( a . long Value ( ) ) ; } }
private static Double Matrix 2 D xdistance Old ( Double Matrix 2 D matrix , int norm ) { return null ; }
public Map < String , String > map ( ) { return hash Map ( ) ; }
private String discover Tag Name ( R Syntax Document doc , int dot ) { Stack stack = new Stack ( ) ; Element root = doc . get Default Root Element ( ) ; int cur Line = root . get Element Index ( dot ) ; for ( int i = NUM ; i <= cur Line ; i ++ ) { Token t = doc . get Token List For Line ( i ) ; while ( t != null && t . is Paintable ( ) ) { if ( t . type == Token . MARKUP TAG DELIMITER ) { if ( t . is Single Char ( STRING ) || t . is Single Char ( STRING ) ) { t = t . get Next Token ( ) ; while ( t != null && t . is Paintable ( ) ) { if ( t . type == Token . MARKUP TAG NAME || t . type == Token . MARKUP TAG ATTRIBUTE ) { stack . push ( t . get Lexeme ( ) ) ; break ; } t = t . get Next Token ( ) ; } } else if ( t . text Count == NUM && t . text [ t . text Offset ] == STRING && ( t . text [ t . text Offset + NUM ] == STRING || t . text [ t . text Offset + NUM ] == STRING ) ) { if ( ! stack . is Empty ( ) ) { stack . pop ( ) ; } } else if ( t . text Count == NUM && ( t . text [ t . text Offset ] == STRING || t . text [ t . text Offset ] == STRING ) && t . text [ t . text Offset + NUM ] == STRING ) { String tag Name = null ; if ( ! stack . is Empty ( ) ) { tag Name = ( String ) stack . pop ( ) ; } if ( t . offset + t . text Count >= dot ) { return tag Name ; } } } t = t . get Next Token ( ) ; } } return null ; }
private static void add Query Fields ( Document doc , Node parent , Collection < Pojo Field > fields ) { if ( ! fields . is Empty ( ) ) { Element prop = add Property ( doc , parent , STRING , null ) ; Element map = add Element ( doc , prop , STRING , STRING , STRING ) ; for ( Pojo Field field : fields ) add Element ( doc , map , STRING , STRING , field . java Name ( ) , STRING , Generator Utils . box Primitive Type ( field . java Type Name ( ) ) ) ; } }
public void test Simple Valid String ( ) throws Exception { Json Factory json F = new Json Factory ( ) ; Data Format Detector detector = new Data Format Detector ( json F ) ; final String JSON = STRING ; Data Format Matcher matcher = detector . find Format ( new Byte Array Input Stream ( JSON . get Bytes ( STRING ) ) ) ; assert True ( matcher . has Match ( ) ) ; assert Equals ( STRING , matcher . get Matched Format Name ( ) ) ; assert Same ( json F , matcher . get Match ( ) ) ; assert Equals ( Match Strength . WEAK MATCH , matcher . get Match Strength ( ) ) ; Json Parser jp = matcher . create Parser With Match ( ) ; assert Token ( Json Token . VALUE STRING , jp . next Token ( ) ) ; assert Equals ( STRING , jp . get Text ( ) ) ; assert Null ( jp . next Token ( ) ) ; jp . close ( ) ; }
protected boolean do Start ( ) { if ( ! lifecycle . is Active ( ) ) { return BOOL ; } if ( ! is Enable ( ) ) { return BOOL ; } int starting Count = starting Count . get And Increment ( ) ; int thread Count = thread Count . get ( ) + starting Count ; if ( thread Max < thread Count ) { starting Count . decrement And Get ( ) ; on Thread Max ( ) ; return BOOL ; } else if ( is Idle Too Low ( starting Count ) ) { return BOOL ; } else { starting Count . decrement And Get ( ) ; return BOOL ; } }
@ Override public String global Info ( ) { return STRING + STRING ; }
public static long stream Skip ( Input Stream stream , long count ) throws IO Exception { long skipped = stream . skip ( count ) ; if ( skipped < NUM ) { final byte [ ] temp = new byte [ NUM ] ; skipped = stream . read ( temp , NUM , Math . min ( ( int ) count , NUM ) ) ; } return skipped ; }
public boolean managed Object Exists ( Managed Object Path < ? , ? > path ) { DN target DN = DN Builder . create ( path ) ; try { return config Repository . get Entry ( target DN ) != null ; } catch ( Config Exception e ) { return BOOL ; } }
public Vector 2 rotate ( double theta ) { double cos = Math . cos ( theta ) ; double sin = Math . sin ( theta ) ; double x = this . x ; double y = this . y ; this . x = x * cos - y * sin ; this . y = x * sin + y * cos ; return this ; }
private static int [ ] [ ] regroup Histogram ( int [ ] [ ] matrix , int [ ] groups ) { long old Entries = NUM ; for ( int i = NUM ; i < matrix . length ; i ++ ) { old Entries += matrix [ i ] . length - NUM ; } long new Entries = NUM ; for ( int ni = NUM ; ni < groups . length ; ni ++ ) { new Entries += groups [ ni ] ; } if ( new Entries > old Entries ) { int newlen = groups . length ; long ok = old Entries ; for ( int ni = NUM ; ni < groups . length ; ni ++ ) { if ( ok < groups [ ni ] ) { int [ ] new Groups = new int [ ni + NUM ] ; System . arraycopy ( groups , NUM , new Groups , NUM , ni + NUM ) ; groups = new Groups ; groups [ ni ] = ( int ) ok ; ok = NUM ; break ; } ok -= groups [ ni ] ; } } else { long excess = old Entries - new Entries ; int [ ] new Groups = new int [ groups . length + NUM ] ; System . arraycopy ( groups , NUM , new Groups , NUM , groups . length ) ; new Groups [ groups . length ] = ( int ) excess ; groups = new Groups ; } int [ ] [ ] new Matrix = new int [ groups . length ] [ ] ; int i = NUM ; int j Min = NUM ; int j Max = matrix [ i ] . length ; for ( int ni = NUM ; ni < groups . length ; ni ++ ) { int group Length = groups [ ni ] ; int [ ] group = new int [ NUM + group Length ] ; long group Weight = NUM ; new Matrix [ ni ] = group ; int nj Fill = NUM ; while ( nj Fill < group . length ) { int len = group . length - nj Fill ; while ( j Min == j Max ) { j Min = NUM ; j Max = matrix [ ++ i ] . length ; } if ( len > j Max - j Min ) len = j Max - j Min ; group Weight += ( long ) matrix [ i ] [ NUM ] * len ; System . arraycopy ( matrix [ i ] , j Max - len , group , nj Fill , len ) ; j Max -= len ; nj Fill += len ; } Arrays . sort ( group , NUM , group . length ) ; group [ NUM ] = ( int ) ( ( group Weight + group Length / NUM ) / group Length ) ; } assert ( j Min == j Max ) ; assert ( i == matrix . length - NUM ) ; return new Matrix ; }
public void remove Permission ( Permission Type permission ) { removed Permissions . add ( permission ) ; }
static void export Prefs ( Preferences prefs , Output Stream stream , boolean with Sub Tree ) throws IO Exception , Backing Store Exception { indent = - NUM ; Buffered Writer out = new Buffered Writer ( new Output Stream Writer ( stream , STRING ) ) ; out . write ( HEADER ) ; out . new Line ( ) ; out . new Line ( ) ; out . write ( DOCTYPE ) ; out . write ( STRING ) ; out . write ( PREFS DTD NAME ) ; out . write ( STRING ) ; out . new Line ( ) ; out . new Line ( ) ; flush Start Tag ( STRING , new String [ ] { STRING } , new String [ ] { String . value Of ( XML VERSION ) } , out ) ; flush Start Tag ( STRING , new String [ ] { STRING } , new String [ ] { prefs . is User Node ( ) ? STRING : STRING } , out ) ; flush Empty Element ( STRING , out ) ; String Tokenizer ancestors = new String Tokenizer ( prefs . absolute Path ( ) , STRING ) ; export Node ( ancestors , prefs , with Sub Tree , out ) ; flush End Tag ( STRING , out ) ; flush End Tag ( STRING , out ) ; out . flush ( ) ; out = null ; }
protected void store In Profiles Map ( Client client ) { Set parent Set = client . get Properties ( PARENT ID ) ; String client Type = client . get Client Type ( ) ; Map m = get Styles Profile Map ( client Type , parent Set ) ; if ( m != null ) { m . put ( client Type , client ) ; } return ; }
public int size ( ) { return data . size ( ) ; }
public void test Bug 4808 ( ) throws Exception { Mysql Connection Pool Data Source ds = new Mysql Connection Pool Data Source ( ) ; ds . set URL ( Base Test Case . db Url ) ; Pooled Connection close Me Twice = ds . get Pooled Connection ( ) ; close Me Twice . close ( ) ; close Me Twice . close ( ) ; }
public void test Compute Z Na N ( ) { Geometry linear Geom = read ( STRING ) ; Length Indexed Line indexed Line = new Length Indexed Line ( linear Geom ) ; double proj Index = indexed Line . project ( new Coordinate ( NUM , NUM ) ) ; Coordinate proj Pt = indexed Line . extract Point ( proj Index ) ; assert True ( Double . is Na N ( proj Pt . z ) ) ; }
public static int option Length ( String option ) { if ( option . equals ( STRING ) ) return NUM ; if ( option . equals ( STRING ) ) return NUM ; if ( option . equals ( STRING ) ) return NUM ; return NUM ; }
public final double cos ( ) { return Math . cos ( this . radians ) ; }
public static Float Buffer create Float Buffer ( float [ ] coords ) { Byte Buffer bb = Byte Buffer . allocate Direct ( coords . length * SIZEOF FLOAT ) ; bb . order ( Byte Order . native Order ( ) ) ; Float Buffer fb = bb . as Float Buffer ( ) ; fb . put ( coords ) ; fb . position ( NUM ) ; return fb ; }
public Int Stream Ex remove ( Int Predicate predicate ) { return filter ( predicate . negate ( ) ) ; }
static void send Raw Line ( Pirc Bot bot , Buffered Writer bwriter , String line ) { if ( line . length ( ) > bot . get Max Line Length ( ) - NUM ) { line = line . substring ( NUM , bot . get Max Line Length ( ) - NUM ) ; } synchronized ( bwriter ) { try { bwriter . write ( line + STRING ) ; bwriter . flush ( ) ; } catch ( Exception e ) { } } }
Entry kill ( ) { Entry entry ; for ( int i = entries . size ( ) - NUM ; i >= NUM ; i -- ) { entry = entries . get ( i ) ; if ( ! entry . dead ) { entry . dead = BOOL ; return entry ; } } throw new Illegal State Exception ( STRING ) ; }
public void slot From Loco Address ( int i , Slot Listener l ) { m Loco Addr Hash . put ( Integer . value Of ( i ) , l ) ; Loco Net Message m = new Loco Net Message ( NUM ) ; m . set Op Code ( Ln Constants . OPC LOCO ADR ) ; m . set Element ( NUM , ( i / NUM ) & NUM ) ; m . set Element ( NUM , i & NUM ) ; tc . send Loco Net Message ( m ) ; }
protected void uninstall Components ( ) { if ( scrollable Tab Layout Enabled ( ) ) { tab Pane . remove ( tab Scroller . viewport ) ; tab Pane . remove ( tab Scroller . scroll Forward Button ) ; tab Pane . remove ( tab Scroller . scroll Backward Button ) ; tab Scroller = null ; } }
public void reset ( ) { forms = null ; }
public static Map < String , String > populate Request Properties ( Map < String , String > request Properties , int body Length , Media Type content Type , Media Type accept Type ) { Map < String , String > properties ; if ( request Properties == null || request Properties . is Empty ( ) ) { properties = new Hash Map < > ( ) ; } else { properties = new Hash Map < > ( request Properties ) ; } if ( accept Type != null ) { properties . put ( Header Names . ACCEPT , accept Type . to String ( ) ) ; } if ( content Type != null ) { properties . put ( Header Names . CONTENT TYPE , content Type . to String ( ) ) ; } if ( body Length > - NUM ) { properties . put ( Header Names . CONTENT LENGTH , String . value Of ( body Length ) ) ; } return properties ; }
public static Block Snapshot Delete Completer create Completer ( Db Client db Client , Block Snapshot snapshot , String task ) { Block Snapshot Delete Completer completer = new Block Snapshot Delete Completer ( snapshot , task ) ; if ( snapshot . get Consistency Group ( ) != null ) { List < URI > snap Ids = new Array List < URI > ( ) ; List < Block Snapshot > snaps = Controller Utils . get Snapshots Part Of Replication Group ( snapshot , db Client ) ; for ( Block Snapshot snap : snaps ) { snap Ids . add ( snap . get Id ( ) ) ; } completer . add Ids ( snap Ids ) ; } return completer ; }
private void check Protocol Already Exists ( Set < String > protocols , String protocol Type ) { if ( ! protocols . contains ( protocol Type ) ) { protocols . add ( protocol Type ) ; } }
private static char Call Char Method V ( JNI Environment env , int obj JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object obj = env . get JNI Ref ( obj JREF ) ; Object return Obj = JNI Helpers . invoke With Var Arg ( obj , method ID , arg Address , Type Reference . Char , BOOL ) ; return Reflection . unwrap Char ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
public void test Constr String With Exponent With Point 3 ( ) { String a = STRING ; int a Scale = NUM ; Big Integer bA = new Big Integer ( STRING ) ; Big Decimal a Number = new Big Decimal ( a ) ; assert Equals ( STRING , bA , a Number . unscaled Value ( ) ) ; assert Equals ( STRING , a Scale , a Number . scale ( ) ) ; }
public static boolean is Composition Playlist ( Resource Byte Range Provider resource Byte Range Provider ) throws IO Exception { return IMF Composition Playlist Type . is Composition Playlist ( resource Byte Range Provider ) ; }
public static Master Private Key decrypt ( String passphrase , byte [ ] encrypted ) throws Hyper Ledger Exception { try { byte [ ] key = S Crypt . generate ( passphrase . get Bytes ( STRING ) , BITCOIN SEED , NUM , NUM , NUM , NUM ) ; Secret Key Spec keyspec = new Secret Key Spec ( key , STRING ) ; Cipher cipher = Cipher . get Instance ( STRING , STRING ) ; byte [ ] iv = Arrays . copy Of Range ( encrypted , NUM , NUM ) ; byte [ ] data = Arrays . copy Of Range ( encrypted , NUM , encrypted . length ) ; cipher . init ( Cipher . DECRYPT MODE , keyspec , new Iv Parameter Spec ( iv ) ) ; return Master Private Key . parse ( new String ( cipher . do Final ( data ) ) ) ; } catch ( Unsupported Encoding Exception | Invalid Algorithm Parameter Exception | No Such Padding Exception | No Such Provider Exception | No Such Algorithm Exception | Invalid Key Exception | Bad Padding Exception | Illegal Block Size Exception e ) { throw new Hyper Ledger Exception ( e ) ; } }
protected boolean before Release ( ) { return deque . size ( ) < max Size ; }
final boolean transfer After Cancelled Wait ( Node node ) { if ( compare And Set Wait Status ( node , Node . CONDITION , NUM ) ) { enq ( node ) ; return BOOL ; } while ( ! is On Sync Queue ( node ) ) Thread . yield ( ) ; return BOOL ; }
public void reset ( ) { System . arraycopy ( initial State , NUM , chain , NUM , chain . length ) ; ubi Init ( PARAM TYPE MESSAGE ) ; }
public int update With On Conflict ( String table , Content Values values , String where Clause , String [ ] where Args , @ Conflict Algorithm int conflict Algorithm ) { if ( values == null || values . size ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } acquire Reference ( ) ; try { String Builder sql = new String Builder ( NUM ) ; sql . append ( STRING ) ; sql . append ( CONFLICT VALUES [ conflict Algorithm ] ) ; sql . append ( table ) ; sql . append ( STRING ) ; int set Values Size = values . size ( ) ; int bind Args Size = ( where Args == null ) ? set Values Size : ( set Values Size + where Args . length ) ; Object [ ] bind Args = new Object [ bind Args Size ] ; int i = NUM ; for ( Map . Entry < String , Object > entry : values . value Set ( ) ) { sql . append ( ( i > NUM ) ? STRING : STRING ) ; sql . append ( entry . get Key ( ) ) ; bind Args [ i ++ ] = entry . get Value ( ) ; sql . append ( STRING ) ; } if ( where Args != null ) { for ( i = set Values Size ; i < bind Args Size ; i ++ ) { bind Args [ i ] = where Args [ i - set Values Size ] ; } } if ( ! Text Utils . is Empty ( where Clause ) ) { sql . append ( STRING ) ; sql . append ( where Clause ) ; } SQ Lite Statement statement = new SQ Lite Statement ( this , sql . to String ( ) , bind Args ) ; try { return statement . execute Update Delete ( ) ; } finally { statement . close ( ) ; } } finally { release Reference ( ) ; } }
public synchronized void add UR Ls ( List < URL > urls ) { for ( URL url : urls ) super . add URL ( url ) ; Array List search List = new Array List ( ) ; search List . add All ( search Path ) ; search List . add All ( urls ) ; search Path = Collections . unmodifiable List ( search Path ) ; }
protected byte [ ] http Get ( final String url ) { Http Get http Request = null ; Http Response http Response = null ; Closeable Http Client client = null ; try { final URI uri = new URI ( url . trim ( ) ) ; http Request = new Http Get ( uri ) ; if ( content Type != null ) { http Request . set Header ( CONTENT TYPE , content Type ) ; } client = get Http Client ( url ) ; http Response = get Http Response ( client , http Request , url ) ; final byte [ ] returned Bytes = read Http Response ( url , http Response ) ; return returned Bytes ; } catch ( URI Syntax Exception e ) { throw new DSS Exception ( e ) ; } finally { try { if ( http Request != null ) { http Request . release Connection ( ) ; } if ( http Response != null ) { Entity Utils . consume Quietly ( http Response . get Entity ( ) ) ; } } finally { close Client ( client ) ; } } }
@ Override public String to String ( ) { return as String ; }
public final int read Char ( ) throws IO Exception { if ( read Encoding != null ) { int ch = read Encoding . read ( ) ; return ch ; } if ( read Length <= read Offset ) { if ( ! read Buffer ( ) ) return - NUM ; } return read Buffer [ read Offset ++ ] & NUM ; }
public void write Exif ( String jpeg File Name , String exif Out File Name ) throws File Not Found Exception , IO Exception { if ( jpeg File Name == null || exif Out File Name == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Input Stream is = null ; try { is = new File Input Stream ( jpeg File Name ) ; write Exif ( is , exif Out File Name ) ; } catch ( IO Exception e ) { close Silently ( is ) ; throw e ; } is . close ( ) ; }
public void exec Non Query ( String sql , String [ ] selection Args ) { for ( int i = NUM , count = selection Args . length ; i < count ; i ++ ) sql = sql . replace First ( STRING , selection Args [ i ] ) ; Log Utils . d ( sql ) ; database . exec SQL ( sql ) ; }
public D General Subtree Chooser ( J Frame parent , String title , General Subtree general Subtree ) { super ( parent , title , Modality Type . DOCUMENT MODAL ) ; init Components ( general Subtree ) ; }
public void insert ( Undo Object Storable p object ) { if ( p object == null ) throw new Illegal Argument Exception ( classname + STRING ) ; disable redo ( ) ; Undo Object Node undoable object = new Undo Object Node ( p object , stack level ) ; objects map . put ( p object , undoable object ) ; }
protected abstract Simple Entry entry Data Matched ( Entry Hierarchy Data ehd ) ;
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = enum To Vector ( super . list Options ( ) ) ; result . add ( new Option ( STRING + default Noise Percent ( ) + STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
private void write Attribute ( java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( namespace . equals ( STRING ) ) { xml Writer . write Attribute ( att Name , att Value ) ; } else { register Prefix ( xml Writer , namespace ) ; xml Writer . write Attribute ( namespace , att Name , att Value ) ; } }
@ Suppress Warnings ( STRING ) protected void notify Property Change Listener ( String property , Object old Value , Object new Value ) { if ( ( old Value != null && old Value . equals ( new Value ) ) || old Value == new Value ) { log . error ( STRING ) ; } Vector < Property Change Listener > v ; synchronized ( this ) { v = ( Vector < Property Change Listener > ) listeners . clone ( ) ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + v . size ( ) + STRING + property ) ; } int cnt = v . size ( ) ; for ( int i = NUM ; i < cnt ; i ++ ) { Property Change Listener client = v . element At ( i ) ; client . property Change ( new Property Change Event ( this , property , old Value , new Value ) ) ; } }
protected final void refresh Loading Views Size ( ) { final int maximum Pull Scroll = ( int ) ( get Maximum Pull Scroll ( ) * NUM ) ; int p Left = get Padding Left ( ) ; int p Top = get Padding Top ( ) ; int p Right = get Padding Right ( ) ; int p Bottom = get Padding Bottom ( ) ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Width ( maximum Pull Scroll ) ; p Left = - maximum Pull Scroll ; } else { p Left = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Width ( maximum Pull Scroll ) ; p Right = - maximum Pull Scroll ; } else { p Right = NUM ; } break ; case VERTICAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Height ( maximum Pull Scroll ) ; p Top = - maximum Pull Scroll ; } else { p Top = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Height ( maximum Pull Scroll ) ; p Bottom = - maximum Pull Scroll ; } else { p Bottom = NUM ; } break ; } if ( DEBUG ) { Log . d ( LOG TAG , String . format ( STRING , p Left , p Top , p Right , p Bottom ) ) ; } set Padding ( p Left , p Top , p Right , p Bottom ) ; }
public Element write Bean Visual ( Element parent , Object o , String name ) throws Exception { Element node ; Bean Visual visual ; if ( DEBUG ) { trace ( new Throwable ( ) , name ) ; } m Current Node = parent ; visual = ( Bean Visual ) o ; node = write To XML ( parent , o , name ) ; invoke Write To XML ( node , visual . get Icon Path ( ) , VAL ICONPATH ) ; invoke Write To XML ( node , visual . get Animated Icon Path ( ) , VAL ANIMATEDICONPATH ) ; return node ; }
private String display Nameto Back Compat Name ( String query Name ) { final int last Back Slash = query Name . last Index Of ( STRING ) ; if ( last Back Slash > NUM && last Back Slash < query Name . length ( ) - NUM ) { query Name = ( char ) NUM + query Name ; query Name = query Name . substring ( NUM , last Back Slash + NUM ) + ( char ) NUM + STRING + query Name . substring ( last Back Slash + NUM ) ; query Name = query Name . replace ( STRING , ( char ) NUM ) ; } return query Name ; }
public SQ Lite Database Configuration ( String path , int open Flags ) { if ( path == null ) { throw new Illegal Argument Exception ( STRING ) ; } this . path = path ; label = strip Path For Logs ( path ) ; this . open Flags = open Flags ; max Sql Cache Size = NUM ; locale = Locale . get Default ( ) ; }
@ Override public void draw Range Gridline ( Graphics 2 D g2 , Category Plot plot , Value Axis axis , Rectangle 2 D data Area , double value ) { Range range = axis . get Range ( ) ; if ( ! range . contains ( value ) ) { return ; } Rectangle 2 D adjusted = new Rectangle 2 D . Double ( data Area . get X ( ) , data Area . get Y ( ) + get Y Offset ( ) , data Area . get Width ( ) - get X Offset ( ) , data Area . get Height ( ) - get Y Offset ( ) ) ; Line 2 D line 1 = null ; Line 2 D line 2 = null ; Plot Orientation orientation = plot . get Orientation ( ) ; if ( orientation == Plot Orientation . HORIZONTAL ) { double x0 = axis . value To Java 2 D ( value , adjusted , plot . get Range Axis Edge ( ) ) ; double x1 = x0 + get X Offset ( ) ; double y0 = data Area . get Max Y ( ) ; double y1 = y0 - get Y Offset ( ) ; double y2 = data Area . get Min Y ( ) ; line 1 = new Line 2 D . Double ( x0 , y0 , x1 , y1 ) ; line 2 = new Line 2 D . Double ( x1 , y1 , x1 , y2 ) ; } else if ( orientation == Plot Orientation . VERTICAL ) { double y0 = axis . value To Java 2 D ( value , adjusted , plot . get Range Axis Edge ( ) ) ; double y1 = y0 - get Y Offset ( ) ; double x0 = data Area . get Min X ( ) ; double x1 = x0 + get X Offset ( ) ; double x2 = data Area . get Max X ( ) ; line 1 = new Line 2 D . Double ( x0 , y0 , x1 , y1 ) ; line 2 = new Line 2 D . Double ( x1 , y1 , x2 , y1 ) ; } Paint paint = plot . get Range Gridline Paint ( ) ; Stroke stroke = plot . get Range Gridline Stroke ( ) ; g2 . set Paint ( paint != null ? paint : Plot . DEFAULT OUTLINE PAINT ) ; g2 . set Stroke ( stroke != null ? stroke : Plot . DEFAULT OUTLINE STROKE ) ; g2 . draw ( line 1 ) ; g2 . draw ( line 2 ) ; }
public static String dump ( final Endpoint Descriptor descriptor ) { return String . format ( STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING , descriptor . b Length ( ) , descriptor . b Descriptor Type ( ) , String . format ( STRING , descriptor . b Endpoint Address ( ) & NUM ) , descriptor . b Endpoint Address ( ) & NUM , get Direction Name ( descriptor . b Endpoint Address ( ) ) , descriptor . bm Attributes ( ) & NUM , get Transfer Type Name ( descriptor . bm Attributes ( ) ) , get Synch Type Name ( descriptor . bm Attributes ( ) ) , get Usage Type Name ( descriptor . bm Attributes ( ) ) , descriptor . w Max Packet Size ( ) & NUM , descriptor . b Interval ( ) & NUM ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static void print Padding ( Print Writer out , int padding ) { for ( int i = NUM ; i < padding ; ++ i ) { out . print ( STRING ) ; } }
protected void sneaky Clear ( ) { List < E Object > collection = new Unmodifiable E List < > ( size , data ) ; sneaky Do Clear ( ) ; for ( Iterator < E Object > i = collection . iterator ( ) ; i . has Next ( ) ; ) { inverse Remove ( i . next ( ) , null ) ; } }
@ Called By Native public static Bitmap create Home Screen Icon From Web Icon ( Context context , Bitmap web Icon ) { Activity Manager am = ( Activity Manager ) context . get System Service ( Context . ACTIVITY SERVICE ) ; int max Inner Size = Math . round ( am . get Launcher Large Icon Size ( ) * MAX INNER SIZE RATIO ) ; int inner Size = Math . min ( max Inner Size , Math . max ( web Icon . get Width ( ) , web Icon . get Height ( ) ) ) ; int padding = Math . round ( ICON PADDING RATIO * inner Size ) ; int outer Size = inner Size + NUM * padding ; Bitmap bitmap = null ; try { bitmap = Bitmap . create Bitmap ( outer Size , outer Size , Bitmap . Config . ARGB 8888 ) ; } catch ( Out Of Memory Error e ) { Log . w ( TAG , STRING ) ; return web Icon ; } Canvas canvas = new Canvas ( bitmap ) ; Rect inner Bounds = new Rect ( padding , padding , outer Size - padding , outer Size - padding ) ; Paint paint = new Paint ( Paint . ANTI ALIAS FLAG ) ; paint . set Filter Bitmap ( BOOL ) ; canvas . draw Bitmap ( web Icon , null , inner Bounds , paint ) ; int corner Radius = Math . round ( ICON CORNER RADIUS RATIO * outer Size ) ; Path path = new Path ( ) ; path . set Fill Type ( Path . Fill Type . INVERSE WINDING ) ; Rect F inner Bounds F = new Rect F ( inner Bounds ) ; path . add Round Rect ( inner Bounds F , corner Radius , corner Radius , Path . Direction . CW ) ; paint . set Xfermode ( new Porter Duff Xfermode ( Porter Duff . Mode . CLEAR ) ) ; canvas . draw Path ( path , paint ) ; return bitmap ; }
private static boolean is In Overflow ( Menu Item item ) { return ! is Action Button ( item ) ; }
private static int determine Consecutive Binary Count ( Char Sequence msg , byte [ ] bytes , int startpos ) throws Writer Exception { int len = msg . length ( ) ; int idx = startpos ; while ( idx < len ) { char ch = msg . char At ( idx ) ; int numeric Count = NUM ; while ( numeric Count < NUM && is Digit ( ch ) ) { numeric Count ++ ; int i = idx + numeric Count ; if ( i >= len ) { break ; } ch = msg . char At ( i ) ; } if ( numeric Count >= NUM ) { return idx - startpos ; } int text Count = NUM ; while ( text Count < NUM && is Text ( ch ) ) { text Count ++ ; int i = idx + text Count ; if ( i >= len ) { break ; } ch = msg . char At ( i ) ; } if ( text Count >= NUM ) { return idx - startpos ; } ch = msg . char At ( idx ) ; if ( bytes [ idx ] == NUM && ch != STRING ) { throw new Writer Exception ( STRING + ch + STRING + ( int ) ch + STRING ) ; } idx ++ ; } return idx - startpos ; }
void plugin Message ( Throwable ex ) { log . print Lines ( Prefix Kind . JAVAC , STRING ) ; ex . print Stack Trace ( log . get Writer ( Writer Kind . NOTICE ) ) ; }
public Builder map ( String fully Qualified Column Names , Column Mapper mapper ) { Predicate < Column Id > column Matcher = Predicates . includes ( fully Qualified Column Names , null ) ; rules . add ( new Mapper Rule ( column Matcher , mapper ) ) ; return this ; }
public double theta ( ) { return Math . atan 2 ( y , x ) ; }
public static int hash 32 ( final String text , int from , int length ) { return hash 32 ( text . substring ( from , from + length ) ) ; }
protected void send Closing Message ( ) { try { send ( Connection Message . CLOSING , Network Protocol . TCP ) ; } catch ( Exception e ) { log . warning ( STRING + e . get Message ( ) ) ; } try { send ( Connection Message . CLOSING , Network Protocol . UDP ) ; } catch ( Exception e ) { log . warning ( STRING + e . get Message ( ) ) ; } }
public static String parse Number To String ( int a Number ) { boolean temp = BOOL , negative = BOOL ; if ( a Number < NUM ) { a Number *= - NUM ; negative = BOOL ; } String Builder t String B = new String Builder ( ) ; for ( int i = NUM ; i > NUM ; i /= NUM ) { int t Digit = ( a Number / i ) % NUM ; if ( temp && t Digit != NUM ) temp = BOOL ; if ( ! temp ) { t String B . append ( t Digit ) ; if ( i != NUM ) for ( int j = i ; j > NUM ; j /= NUM ) if ( j == NUM ) t String B . append ( STRING ) ; } } String t String = t String B . to String ( ) ; if ( t String . equals ( E ) ) t String = STRING ; return negative ? STRING + t String : t String ; }
public void remove ( T graphic ) { synchronized ( m Lock ) { m Graphics . remove ( graphic ) ; if ( m First Graphic != null && m First Graphic . equals ( graphic ) ) { m First Graphic = null ; } } post Invalidate ( ) ; }
public boolean valid System Name Config ( String system Name ) { return ( BOOL ) ; }
public int read ( ) throws IO Exception { ensure Open ( ) ; if ( next >= length ) { return - NUM ; } return str . char At ( next ++ ) ; }
void add Hidden Channel Listener ( Hidden Channel Listener listener ) { listeners . add ( listener ) ; }
public boolean next To ( final Entity entity , final double step ) { final Rectangle 2 D this Area = new Rectangle 2 D . Double ( x - step , y - step , area . get Width ( ) + NUM * step , area . get Height ( ) + NUM * step ) ; return this Area . intersects ( entity . get Area ( ) ) ; }
private long rebalance nl ( final long n Parent , final long n , Long Array unlinked ) { final long nL = unshared Left ( n , unlinked ) ; final long nR = unshared Right ( n , unlinked ) ; if ( ( nL == NUM || nR == NUM ) && v Opt Is Null ( n ) ) { if ( attempt Unlink nl ( n Parent , n , unlinked ) ) { return fix Height nl ( n Parent ) ; } else { return n ; } } final int hN = height ( n ) ; final int hL 0 = height ( nL ) ; final int hR 0 = height ( nR ) ; final int hN Repl = NUM + Math . max ( hL 0 , hR 0 ) ; final int bal = hL 0 - hR 0 ; if ( bal > NUM ) { return rebalance To Right nl ( n Parent , n , nL , hR 0 , unlinked ) ; } else if ( bal < - NUM ) { return rebalance To Left nl ( n Parent , n , nR , hL 0 , unlinked ) ; } else if ( hN Repl != hN ) { height ( n , hN Repl ) ; return fix Height nl ( n Parent ) ; } else { return NUM ; } }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
private void add Conversations ( ) { TPP Phase myphase = AWAITING ; main NPC . add ( Conversation States . ATTENDING , Arrays . as List ( STRING , STRING ) , new TPP Quest In Phase Condition ( myphase ) , Conversation States . ATTENDING , STRING + STRING + STRING , null ) ; main NPC . add ( Conversation States . ATTENDING , STRING , new TPP Quest In Phase Condition ( myphase ) , Conversation States . ATTENDING , null , new Details Killings Action ( ) ) ; main NPC . add ( Conversation States . ATTENDING , STRING , new TPP Quest In Phase Condition ( myphase ) , Conversation States . ATTENDING , null , new Reward Player Action ( ) ) ; }
public static void w ( String tag , String s , Object ... args ) { if ( LOG . WARN >= LOGLEVEL ) Log . w ( tag , String . format ( s , args ) ) ; }
@ edu . umd . cs . findbugs . annotations . Suppress Warnings ( value = STRING , justification = STRING ) public void handle Notification ( Notification notification , Object handback ) { if ( handback instanceof Agent Impl ) { Agent Impl agent = ( Agent Impl ) handback ; JMX Connection Notification jmx Notifn = ( JMX Connection Notification ) notification ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING , jmx Notifn . get Connection Id ( ) ) ; } agent . update Rmi Clients Count ( ) ; } }
public static boolean is Blank ( String s ) { if ( s == null ) { return BOOL ; } int s Len = s . length ( ) ; for ( int i = NUM ; i < s Len ; i ++ ) { if ( ! Character . is Whitespace ( s . char At ( i ) ) ) { return BOOL ; } } return BOOL ; }
public Plain Text Dictionary ( Path path ) throws IO Exception { in = Files . new Buffered Reader ( path , Standard Charsets . UTF 8 ) ; }
public boolean add Alias By Number ( String alias Name , String number ) { if ( alias Name . contains ( STRING ) ) return BOOL ; String contact Name = Contacts Manager . get Contact Name Or Null ( ctx , number ) ; add Or Update ( alias Name , number , contact Name ) ; return BOOL ; }
void split Data ( Node node , Node new Node , int offset ) { if ( ranges != null ) { notify Ranges Split Data ( node , new Node , offset ) ; } }
@ Not Null @ Objective C Name ( STRING ) public Configuration Builder add Trusted Key ( String trusted Key ) { trusted Keys . add ( new Trusted Key ( trusted Key ) ) ; return this ; }
private void check Is Correct Class ( ) { if ( check Is Sub Class ( ACT NAME ) ) { type = Element Type . ACTTIVITY ; } else if ( check Is Sub Class ( FRAG NAME ) || check Is Sub Class ( V4 FRAG NAME ) ) { type = Element Type . FRAGMENT ; } else { throw new Illegal Argument Exception ( String . format ( STRING , element . get Qualified Name ( ) , ACT NAME , FRAG NAME , V4 FRAG NAME ) ) ; } }
String transform Resource Id To File Name ( final String resource Name ) { return resource Name . replace ( STRING , STRING ) ; }
public void disable ( Rich Formatter Feature feature ) { features . remove ( feature ) ; }
public boolean is Critical ( ) { return BOOL ; }
public final boolean is Secure ( Socket sock ) throws Illegal Argument Exception { if ( sock == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( sock . get Class ( ) != Socket . class ) { throw new Illegal Argument Exception ( STRING ) ; } if ( sock . is Closed ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } return BOOL ; }
public synchronized void add ( String name , long thread Id ) { if ( m Finished ) { throw new Illegal State Exception ( STRING ) ; } m Markers . add ( new Marker ( name , thread Id , System Clock . elapsed Realtime ( ) ) ) ; }
private void skip Whitespace ( ) { matcher . use Pattern ( WHITESPACE ) ; if ( matcher . looking At ( ) ) { matcher . region ( matcher . end ( ) , matcher . region End ( ) ) ; } }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return SUCCESS ; case NUM : return MSG ; default : return null ; } }
public void push Stylesheet ( Stylesheet s ) { if ( m stylesheets . size ( ) == NUM ) m stylesheet Root = ( Stylesheet Root ) s ; m stylesheets . push ( s ) ; }
private void fill Nodes In Context ( Site Node root Node , List < Site Node > nodes List ) { @ Suppress Warnings ( STRING ) Enumeration < Site Node > en = root Node . children ( ) ; while ( en . has More Elements ( ) ) { Site Node sn = en . next Element ( ) ; if ( is In Context ( sn ) ) { nodes List . add ( sn ) ; } fill Nodes In Context ( sn , nodes List ) ; } }
@ Suppress Warnings ( { STRING , STRING } ) public boolean matches ( Inventory Crafting p 77569 1 , World p 77569 2 ) { Array List arraylist = new Array List ( this . recipe Items ) ; for ( int i = NUM ; i < NUM ; ++ i ) { for ( int j = NUM ; j < NUM ; ++ j ) { Item Stack itemstack = p 77569 1 . get Stack In Row And Column ( j , i ) ; if ( itemstack != null ) { boolean flag = BOOL ; Iterator iterator = arraylist . iterator ( ) ; while ( iterator . has Next ( ) ) { Item Stack itemstack 1 = ( Item Stack ) iterator . next ( ) ; if ( itemstack . get Item ( ) == itemstack 1 . get Item ( ) && ( itemstack 1 . get Item Damage ( ) == NUM || itemstack . get Item Damage ( ) == itemstack 1 . get Item Damage ( ) ) ) { flag = BOOL ; arraylist . remove ( itemstack 1 ) ; break ; } } if ( ! flag ) { return BOOL ; } } } } return arraylist . is Empty ( ) ; }
public String Builder dump Statements ( final I Access Path < ISPO > access Path ) { final String Builder sb = new String Builder ( ) ; final Bigdata Statement Iterator itr = as Statement Iterator ( access Path . iterator ( ) ) ; try { while ( itr . has Next ( ) ) { sb . append ( STRING + itr . next ( ) ) ; } return sb ; } finally { itr . close ( ) ; } }
public static Element svg Wait Icon ( Document document , double x , double y , double w , double h ) { Element g = SVG Util . svg Element ( document , SVG Constants . SVG G TAG ) ; set Att ( g , SVG Constants . SVG TRANSFORM ATTRIBUTE , STRING + x + STRING + y + STRING + w + STRING + h + STRING ) ; Element thro = SVG Util . svg Element ( document , SVG Constants . SVG PATH TAG ) ; set Att ( thro , SVG Constants . SVG D ATTRIBUTE , THROBBER PATH ) ; set Style ( thro , THROBBER STYLE ) ; Element anim = SVG Util . svg Element ( document , SVG Constants . SVG ANIMATE TRANSFORM TAG ) ; set Att ( anim , SVG Constants . SVG ATTRIBUTE NAME ATTRIBUTE , SVG Constants . SVG TRANSFORM ATTRIBUTE ) ; set Att ( anim , SVG Constants . SVG ATTRIBUTE TYPE ATTRIBUTE , STRING ) ; set Att ( anim , SVG Constants . SVG TYPE ATTRIBUTE , SVG Constants . SVG ROTATE ATTRIBUTE ) ; set Att ( anim , SVG Constants . SVG FROM ATTRIBUTE , STRING ) ; set Att ( anim , SVG Constants . SVG TO ATTRIBUTE , STRING ) ; set Att ( anim , SVG Constants . SVG BEGIN ATTRIBUTE , fmt ( Math . random ( ) * NUM ) + STRING ) ; set Att ( anim , SVG Constants . SVG DUR ATTRIBUTE , STRING ) ; set Att ( anim , SVG Constants . SVG REPEAT COUNT ATTRIBUTE , STRING ) ; set Att ( anim , SVG Constants . SVG FILL ATTRIBUTE , STRING ) ; thro . append Child ( anim ) ; g . append Child ( thro ) ; return g ; }
protected void on End ( Pcap pcap ) { this . end = BOOL ; }
public void cd ( String dir ) { String Builder buf = new String Builder ( ) ; String command = String . format ( Image Server Dialog Properties . get String ( STRING ) , dir ) ; send Wait For ( command , default Timeout , prompts , buf ) ; log . debug ( buf . to String ( ) ) ; }
public void add Request Property ( String key , String value ) { jar File URL Connection . add Request Property ( key , value ) ; }
public static String number To String ( Number number ) throws JSON Exception { if ( number == null ) { throw new JSON Exception ( STRING ) ; } test Validity ( number ) ; String string = number . to String ( ) ; if ( string . index Of ( STRING ) > NUM && string . index Of ( STRING ) < NUM && string . index Of ( STRING ) < NUM ) { while ( string . ends With ( STRING ) ) { string = string . substring ( NUM , string . length ( ) - NUM ) ; } if ( string . ends With ( STRING ) ) { string = string . substring ( NUM , string . length ( ) - NUM ) ; } } return string ; }
public static void write Spec Info To Files ( Security Spec Model security Spec Model , String app ROOT DIR ) { write Info Flow Summary To File ( security Spec Model , Config . v ( ) . APP ROOT DIR ) ; write Info Flow Details To File ( security Spec Model , Config . v ( ) . APP ROOT DIR ) ; write Value Info To File ( security Spec Model , Config . v ( ) . APP ROOT DIR ) ; write Points To Info To File ( security Spec Model , Config . v ( ) . APP ROOT DIR ) ; }
private int measure Short ( int measure Spec ) { int result ; int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; if ( spec Mode == Measure Spec . EXACTLY ) { result = spec Size ; } else { result = ( int ) ( NUM * m Radius + get Padding Top ( ) + get Padding Bottom ( ) + NUM ) ; if ( spec Mode == Measure Spec . AT MOST ) { result = Math . min ( result , spec Size ) ; } } return result ; }
private void handle Command ( int id , String command , String params ) { String origin Command = command Id . get ( id ) ; if ( origin Command == null ) { origin Command = STRING ; } handler . handle Command ( id , command , params , origin Command ) ; if ( command . equals ( STRING ) ) { LOGGER . warning ( STRING + params ) ; } }
private void close All Dumps ( ) { Object [ ] options = { STRING , STRING } ; int select Value = J Option Pane . show Option Dialog ( null , STRING , STRING , J Option Pane . DEFAULT OPTION , J Option Pane . QUESTION MESSAGE , null , options , options [ NUM ] ) ; if ( select Value == NUM ) { top Nodes = new Vector ( ) ; reset Main Panel ( ) ; } }
private void close Counter Data Input Stream ( ) throws Data Fallback Exception { if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STRING + counter File . get Name ( ) ) ; if ( d Input != null ) { try { d Input . close ( ) ; } catch ( IO Exception e ) { throw new Data Fallback Exception ( e . get Message ( ) ) ; } finally { d Input = null ; } } }
private static String remove File Name Extension ( String file Name ) { if ( file Name . last Index Of ( STRING ) == - NUM ) return file Name ; return file Name . substring ( NUM , file Name . last Index Of ( STRING ) ) ; }
public void clear ( ) { read = write = count = NUM ; Arrays . fill ( buffer , null ) ; }
private Response < Bitmap > do Parse ( Network Response response ) { byte [ ] data = response . data ; Bitmap Factory . Options decode Options = new Bitmap Factory . Options ( ) ; Bitmap bitmap = null ; if ( m Max Width == NUM && m Max Height == NUM ) { decode Options . in Preferred Config = m Decode Config ; bitmap = Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; } else { decode Options . in Just Decode Bounds = BOOL ; Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; int actual Width = decode Options . out Width ; int actual Height = decode Options . out Height ; int desired Width = get Resized Dimension ( m Max Width , m Max Height , actual Width , actual Height , m Scale Type ) ; int desired Height = get Resized Dimension ( m Max Height , m Max Width , actual Height , actual Width , m Scale Type ) ; decode Options . in Just Decode Bounds = BOOL ; decode Options . in Sample Size = find Best Sample Size ( actual Width , actual Height , desired Width , desired Height ) ; Bitmap temp Bitmap = Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; if ( temp Bitmap != null && ( temp Bitmap . get Width ( ) > desired Width || temp Bitmap . get Height ( ) > desired Height ) ) { bitmap = Bitmap . create Scaled Bitmap ( temp Bitmap , desired Width , desired Height , BOOL ) ; temp Bitmap . recycle ( ) ; } else { bitmap = temp Bitmap ; } } if ( bitmap == null ) { return Response . error ( new Parse Error ( response ) ) ; } else { return Response . success ( bitmap , Http Header Parser . parse Cache Headers ( response ) ) ; } }
private List < Entry > reduce With Douglas Peuker ( List < Entry > entries , double epsilon ) { if ( epsilon <= NUM || entries . size ( ) < NUM ) { return entries ; } keep [ NUM ] = BOOL ; keep [ entries . size ( ) - NUM ] = BOOL ; algorithm Douglas Peucker ( entries , epsilon , NUM , entries . size ( ) - NUM ) ; List < Entry > reduced Entries = new Array List < > ( ) ; for ( int i = NUM ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { Entry cur Entry = entries . get ( i ) ; reduced Entries . add ( new Entry ( cur Entry . get Val ( ) , cur Entry . get X Index ( ) ) ) ; } } return reduced Entries ; }
static int hi Bit Pos ( long num ) { return NUM - Long . number Of Leading Zeros ( num ) ; }
public Adaptive Grid Archive ( int capacity , Problem problem , int number Of Divisions ) { this . capacity = capacity ; this . problem = problem ; this . number Of Divisions = number Of Divisions ; minimum = new double [ problem . get Number Of Objectives ( ) ] ; maximum = new double [ problem . get Number Of Objectives ( ) ] ; density = new int [ ( int ) Math . pow ( number Of Divisions , problem . get Number Of Objectives ( ) ) ] ; adapt Grid ( ) ; }
Begin Line Action ( String nm , boolean select ) { super ( nm ) ; this . select = select ; }
public static boolean occupy ( int wait Ms ) { if ( occupied Until != null && occupied Until . after ( new Date ( ) ) ) { return BOOL ; } occupied Until = Date Utils . add Milliseconds ( new Date ( ) , wait Ms ) ; return BOOL ; }
private void adjust Window Size ( Container Wrapper parent ) { Bound Size w Bounds = lc . get Pack Width ( ) ; Bound Size h Bounds = lc . get Pack Height ( ) ; if ( w Bounds == null && h Bounds == null ) return ; Window win = ( ( Window ) Swing Utilities . get Ancestor Of Class ( Window . class , ( Component ) parent . get Component ( ) ) ) ; if ( win == null ) return ; Dimension pref Size = win . get Preferred Size ( ) ; int targ W = constrain ( check Parent ( win ) , win . get Width ( ) , pref Size . width , w Bounds ) ; int targ H = constrain ( check Parent ( win ) , win . get Height ( ) , pref Size . height , h Bounds ) ; int x = Math . round ( win . get X ( ) - ( ( targ W - win . get Width ( ) ) * ( NUM - lc . get Pack Width Align ( ) ) ) ) ; int y = Math . round ( win . get Y ( ) - ( ( targ H - win . get Height ( ) ) * ( NUM - lc . get Pack Height Align ( ) ) ) ) ; win . set Bounds ( x , y , targ W , targ H ) ; }
@ Override public void write ( List < byte [ ] > value List ) throws IO Exception { if ( is First Time ) { init ( ) ; is First Time = BOOL ; } for ( byte [ ] value : value List ) { one Dictionary Chunk List . add ( Byte Buffer . wrap ( value ) ) ; total Record Count ++ ; } }
public void proceed ( ) { idle . set ( BOOL ) ; subject . on Next ( null ) ; }
private static boolean ns Equals ( String ns URI 1 , String ns URI 2 ) { if ( ns URI 1 == null ) { return ( ns URI 2 == null ) ; } else { return ns URI 1 . equals ( ns URI 2 ) ; } }
private boolean link First ( Node < E > node ) { if ( count >= capacity ) return BOOL ; Node < E > f = first ; node . next = f ; first = node ; if ( last == null ) last = node ; else f . prev = node ; ++ count ; not Empty . signal ( ) ; return BOOL ; }
public static void sleep ( long millis ) { if ( mock Sleep Queue == null ) { sleep Uninterruptibly ( millis , Time Unit . MILLISECONDS ) ; } else { try { boolean is Multi Pass = mock Sleep Queue . take ( ) ; roll Mock Clock Millis ( millis ) ; if ( is Multi Pass ) mock Sleep Queue . offer ( BOOL ) ; } catch ( Interrupted Exception e ) { } } }
public boolean is Handle ( String handle ) { return client Handle . equals ( handle ) ; }
public static void is GTE ( String arg Name , long i , long min ) { if ( i < min ) { throw new Illegal Argument Exception ( String . format ( STRING , arg Name , min , i ) ) ; } }
int adjust Text Offset ( int offset ) { max Text Offset = Math . max ( max Text Offset , offset ) ; return max Text Offset ; }
public static Object value From Class Constant ( String key , Object default Value ) { Configuration conf = instance ( ) ; String val = value For ( key ) ; if ( val == null ) { return default Value ; } int idx = val . last Index Of ( STRING ) ; String klassname ; String cnst ; try { klassname = val . substring ( NUM , idx ) ; cnst = val . substring ( idx + NUM ) ; } catch ( Index Out Of Bounds Exception e ) { conf . warning ( STRING + key + STRING + STRING + val ) ; return default Value ; } Class klass ; try { klass = Class . for Name ( klassname ) ; } catch ( Class Not Found Exception e ) { conf . warning ( STRING + key + STRING + klassname ) ; return default Value ; } Object cnst Val ; try { Field fld = klass . get Declared Field ( cnst ) ; try { cnst Val = fld . get ( klass ) ; } catch ( Illegal Access Exception e ) { conf . warning ( STRING + key + STRING + klassname + STRING + cnst ) ; return default Value ; } } catch ( No Such Field Exception e ) { conf . warning ( STRING + key + STRING + klassname ) ; return default Value ; } return cnst Val ; }
public static boolean is Wifi Connected ( Context context ) { Connectivity Manager connectivity Manager = ( Connectivity Manager ) context . get System Service ( Context . CONNECTIVITY SERVICE ) ; Network Info network Info = connectivity Manager . get Active Network Info ( ) ; return network Info != null && network Info . get Type ( ) == Connectivity Manager . TYPE WIFI ; }
public Str Builder insert ( final int index , final char value ) { validate Index ( index ) ; ensure Capacity ( size + NUM ) ; System . arraycopy ( buffer , index , buffer , index + NUM , size - index ) ; buffer [ index ] = value ; size ++ ; return this ; }
public List < byte [ ] > try Decode ( final String target Token ) { final Byte Buffer payload Buf = extract Valid Payload Fields ( target Token ) ; if ( payload Buf == null ) { return null ; } final List < byte [ ] > fields = new Array List < > ( ) ; try { byte [ ] field = null ; while ( ( field = try Read Payload Next Field ( payload Buf ) ) . length > NUM ) { fields . add ( field ) ; if ( fields . size ( ) > MAX FIELD SIZE ) { return null ; } } return fields ; } catch ( final Buffer Underflow Exception e ) { return null ; } }
@ Namespace Permission ( fields = STRING , permissions = Namespace Permission Enum . WRITE ) @ Override public Business Object Definition create Business Object Definition ( Business Object Definition Create Request request ) { validate Business Object Definition Create Request ( request ) ; Namespace Entity namespace Entity = namespace Dao Helper . get Namespace Entity ( request . get Namespace ( ) ) ; Data Provider Entity data Provider Entity = data Provider Dao Helper . get Data Provider Entity ( request . get Data Provider Name ( ) ) ; Business Object Definition Key business Object Definition Key = new Business Object Definition Key ( request . get Namespace ( ) , request . get Business Object Definition Name ( ) ) ; Business Object Definition Entity business Object Definition Entity = business Object Definition Dao . get Business Object Definition By Key ( business Object Definition Key ) ; if ( business Object Definition Entity != null ) { throw new Already Exists Exception ( String . format ( STRING , business Object Definition Key . get Business Object Definition Name ( ) , business Object Definition Key . get Namespace ( ) ) ) ; } business Object Definition Entity = create Business Object Definition Entity ( request , namespace Entity , data Provider Entity ) ; return create Business Object Definition From Entity ( business Object Definition Entity ) ; }
public void end Block ( ) throws IO Exception { if ( indent . length ( ) <= NUM ) { indent = STRING ; } else if ( indent . length ( ) >= NUM ) { indent = indent . substring ( NUM ) ; } print ( STRING , null ) ; printer . println ( ) ; }
private void migrate Block Volumes ( ) { log . info ( STRING ) ; Db Client db Client = get Db Client ( ) ; List < URI > volume UR Is = db Client . query By Type ( Volume . class , BOOL ) ; Iterator < Volume > volumes = db Client . query Iterative Objects ( Volume . class , volume UR Is , BOOL ) ; List < Block Object > block Objects = new Array List < Block Object > ( ) ; while ( volumes . has Next ( ) ) { block Objects . add ( volumes . next ( ) ) ; } migrate Block Objects ( block Objects ) ; }
public static String decode ( String s , String enc , boolean plus To Space ) { boolean modified = BOOL ; if ( enc == null || enc . length ( ) == NUM ) { enc = STRING ; } int num Chars = s . length ( ) ; String Builder sb = new String Builder ( num Chars > NUM ? num Chars / NUM : num Chars ) ; int i = NUM ; char c ; byte [ ] bytes = null ; while ( i < num Chars ) { c = s . char At ( i ) ; switch ( c ) { case STRING : if ( plus To Space ) { sb . append ( STRING ) ; } else { sb . append ( STRING ) ; } i ++ ; modified = BOOL ; break ; case STRING : try { if ( bytes == null ) { bytes = new byte [ ( num Chars - i ) / NUM ] ; } int pos = NUM ; while ( ( ( i + NUM ) < num Chars ) && ( c == STRING ) ) { bytes [ pos ++ ] = ( byte ) Integer . parse Int ( s . substring ( i + NUM , i + NUM ) , NUM ) ; i += NUM ; if ( i < num Chars ) { c = s . char At ( i ) ; } } if ( ( i < num Chars ) && ( c == STRING ) ) { throw new Illegal Argument Exception ( STRING + s ) ; } try { sb . append ( new String ( bytes , NUM , pos , enc ) ) ; } catch ( Unsupported Encoding Exception e ) { throw new Runtime Exception ( e . to String ( ) ) ; } } catch ( Number Format Exception e ) { throw new Illegal Argument Exception ( STRING + s ) ; } modified = BOOL ; break ; default : sb . append ( c ) ; i ++ ; break ; } } if ( modified ) { return sb . to String ( ) ; } return s ; }
public Server Controller Test ( String name ) { super ( name ) ; this . base Dir = System . get Property ( STRING ) ; }
@ Override public String encode ( ) { return value == int Value ( ) ? Integer . to String ( int Value ( ) ) + unit . encode ( ) : Double . to String ( value ) + unit . encode ( ) ; }
public Host Name Parser ( Lexer Core lexer ) { this . lexer = lexer ; lexer . select Lexer ( STRING ) ; strip Address Scope Zones = Boolean . get Boolean ( STRING ) ; }
private void load Text ( Input Stream is ) { Buffered Reader reader ; String line ; if ( is == null ) { throw new Error ( STRING ) ; } reader = new Buffered Reader ( new Input Stream Reader ( is ) ) ; try { line = reader . read Line ( ) ; line Count ++ ; while ( line != null ) { if ( ! line . starts With ( STRING ) ) { parse And Add ( line , reader ) ; } line = reader . read Line ( ) ; } reader . close ( ) ; } catch ( IO Exception e ) { throw new Error ( e . get Message ( ) + STRING + line Count ) ; } finally { } }
public void add Email Adress ( String an Email Address ) { if ( m Emails . index Of ( an Email Address ) < NUM ) { m Emails . add ( an Email Address ) ; } }
public static Instances load Dataset ( String options [ ] , char T ) throws Exception { Instances D = null ; String filename = Utils . get Option ( T , options ) ; if ( filename == null || filename . is Empty ( ) ) throw new Exception ( STRING ) ; File file = new File ( filename ) ; if ( ! file . exists ( ) ) throw new Exception ( STRING + filename ) ; if ( file . is Directory ( ) ) throw new Exception ( STRING + filename + STRING ) ; try { Data Source source = new Data Source ( filename ) ; D = source . get Data Set ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new Exception ( STRING + filename + STRING ) ; } return D ; }
private boolean is Typed Time Fully Legal ( ) { if ( m Is 24 Hour Mode ) { int [ ] values = get Entered Time ( null ) ; return ( values [ NUM ] >= NUM && values [ NUM ] >= NUM && values [ NUM ] < NUM ) ; } else { return ( m Typed Times . contains ( get Am Or Pm Key Code ( AM ) ) || m Typed Times . contains ( get Am Or Pm Key Code ( PM ) ) ) ; } }
public void test group Commit ( ) throws Exception { final int write Service Core Pool Size = NUM ; final Properties properties = get Properties ( ) ; properties . set Property ( Test Options . TIMEOUT , STRING ) ; properties . set Property ( Test Options . NTASKS , STRING ) ; properties . set Property ( Options . WRITE SERVICE CORE POOL SIZE , STRING + write Service Core Pool Size ) ; properties . set Property ( Options . WRITE SERVICE MAXIMUM POOL SIZE , STRING ) ; properties . set Property ( Options . WRITE SERVICE PRESTART ALL CORE THREADS , STRING ) ; properties . set Property ( Options . WRITE SERVICE QUEUE CAPACITY , STRING ) ; do Comparison Test ( properties ) ; }
@ Override public void operate ( Population pop ) throws Exception { List < Individual > new Individuals = new Linked List < Individual > ( ) ; for ( int i = NUM ; i < pop . get Number Of Individuals ( ) ; i ++ ) { List < Individual > individuals = operate ( pop . get ( i ) ) ; new Individuals . add All ( individuals ) ; } pop . clear ( ) ; pop . add All Individuals ( new Individuals ) ; }
public int size ( ) { return encoded Names . size ( ) ; }
public static byte [ ] to Seed ( List < String > words , String passphrase ) { return to Seed ( words , passphrase , Version . V0 6 ) ; }
private Array List < Interval > find Or Create Interval Set ( Register r ) { Array List < Interval > v = map . get ( r ) ; if ( v == null ) { v = new Array List < Interval > ( ) ; map . put ( r , v ) ; } return v ; }
protected void remove Columns ( Collection < String > remove Column Names , String table Name ) { if ( remove Column Names != null && ! remove Column Names . is Empty ( ) ) { execute ( get Remove Column SQ Ls ( remove Column Names , table Name ) , m Db ) ; } }
@ Override public double [ ] [ ] predict Intervals ( double conf ) { update Boundaries And Or Weights ( ) ; double val = Statistics . normal Inverse ( NUM - ( NUM - conf ) / NUM ) ; double min = m TM . first Key ( ) - val * m Width ; double max = m TM . last Key ( ) + val * m Width ; double delta = ( max - min ) / m Num Intervals ; double [ ] probabilities = new double [ m Num Intervals ] ; double left Val = Math . exp ( log Density ( min ) ) ; for ( int i = NUM ; i < m Num Intervals ; i ++ ) { double right Val = Math . exp ( log Density ( min + ( i + NUM ) * delta ) ) ; probabilities [ i ] = NUM * ( left Val + right Val ) * delta ; left Val = right Val ; } int [ ] sorted Indices = Utils . sort ( probabilities ) ; double sum = NUM ; boolean [ ] to Use = new boolean [ probabilities . length ] ; int k = NUM ; while ( ( sum < conf ) && ( k < to Use . length ) ) { to Use [ sorted Indices [ to Use . length - ( k + NUM ) ] ] = BOOL ; sum += probabilities [ sorted Indices [ to Use . length - ( k + NUM ) ] ] ; k ++ ; } probabilities = null ; Array List < double [ ] > intervals = new Array List < double [ ] > ( ) ; double [ ] interval = null ; boolean have Started Interval = BOOL ; for ( int i = NUM ; i < m Num Intervals ; i ++ ) { if ( to Use [ i ] ) { if ( have Started Interval == BOOL ) { have Started Interval = BOOL ; interval = new double [ NUM ] ; interval [ NUM ] = min + i * delta ; } interval [ NUM ] = min + ( i + NUM ) * delta ; } else { if ( have Started Interval ) { have Started Interval = BOOL ; intervals . add ( interval ) ; } } } if ( have Started Interval ) { intervals . add ( interval ) ; } return intervals . to Array ( new double [ NUM ] [ NUM ] ) ; }
public void register Atmosphere ( I Atmosphere atmosphere ) { atmosphere Registration . put ( atmosphere . get Unlocalized Name ( ) , atmosphere ) ; atmosphere List . add ( atmosphere ) ; }
public JX Search Field ( ) { this ( STRING ) ; }
private static void reply Login 2 Role ( body body , Mobile Session Ctx wsc , String role Id ) { String form = null ; Login login = new Login ( wsc . ctx ) ; Key Name Pair [ ] clients = login . get Clients ( new Key Name Pair ( Integer . parse Int ( role Id ) , role Id ) ) ; String Buffer script = new String Buffer ( STRING ) ; for ( int i = NUM ; i < clients . length ; i ++ ) { if ( i > NUM ) script . append ( STRING ) ; Key Name Pair p = clients [ i ] ; script . append ( STRING ) ; script . append ( p . get Name ( ) ) ; script . append ( STRING ) ; script . append ( p . get Key ( ) ) ; script . append ( STRING ) ; } script . append ( STRING ) ; }
public void test Create Document Type 1 ( ) throws Throwable { Document doc ; DOM Implementation dom Impl ; Document Type new Doc Type ; Document owner Document ; String qualified Name = STRING ; String public Id ; String system Id ; List < String > public Ids = new Array List < String > ( ) ; public Ids . add ( STRING ) ; public Ids . add ( STRING ) ; List < String > system Ids = new Array List < String > ( ) ; system Ids . add ( STRING ) ; system Ids . add ( STRING ) ; doc = ( Document ) load ( STRING , builder ) ; dom Impl = doc . get Implementation ( ) ; for ( int index N 1005 D = NUM ; index N 1005 D < public Ids . size ( ) ; index N 1005 D ++ ) { public Id = ( String ) public Ids . get ( index N 1005 D ) ; for ( int index N 10061 = NUM ; index N 10061 < system Ids . size ( ) ; index N 10061 ++ ) { system Id = ( String ) system Ids . get ( index N 10061 ) ; new Doc Type = dom Impl . create Document Type ( qualified Name , public Id , system Id ) ; assert Not Null ( STRING , new Doc Type ) ; owner Document = new Doc Type . get Owner Document ( ) ; assert Null ( STRING , owner Document ) ; } } }
public final void run ( ) { if ( m start == NUM ) m start = System . current Time Millis ( ) ; m can Continue = BOOL ; while ( m can Continue ) { if ( is Interrupted ( ) ) return ; m last Start = System . current Time Millis ( ) ; m working = BOOL ; try { m poll Count ++ ; if ( can Do Work ( ) ) { m can Continue = do Work ( ) ; m count ++ ; } } catch ( Exception e ) { log . log ( Level . SEVERE , STRING , e ) ; } m working = BOOL ; long end = System . current Time Millis ( ) ; m time += ( end - m last Start ) ; if ( is Interrupted ( ) ) return ; try { log . fine ( STRING + m sleep Seconds ) ; sleep ( m sleep Seconds * NUM ) ; } catch ( Interrupted Exception e1 ) { log . warning ( STRING + e1 . get Localized Message ( ) ) ; return ; } } }
public static Solr Document assert Search One Doc ( Solr Params p ) throws Exception { Solr Document List docs = assert Search ( p ) ; assert Equals ( STRING + p . to String ( ) + STRING + docs . to String ( ) , NUM , docs . get Num Found ( ) ) ; assert Equals ( STRING + p . to String ( ) + STRING + docs . to String ( ) , NUM , docs . size ( ) ) ; return docs . get ( NUM ) ; }
private static Value Source build Source Tree ( Index Schema schema , String expression , int source Type ) { int expression Type = get Source Type ( expression ) ; if ( source Type != FIELD TYPE && expression Type != FIELD TYPE && expression Type != FILTER TYPE && expression Type != source Type ) { return null ; } switch ( expression Type ) { case NUMBER TYPE : return build Numeric Source ( schema , expression ) ; case DATE TYPE : return build Date Source ( schema , expression ) ; case STRING TYPE : return build String Source ( schema , expression ) ; case FIELD TYPE : return build Field Source ( schema , expression , source Type ) ; case FILTER TYPE : return build Filter Source ( schema , expression . substring ( expression . index Of ( STRING ) + NUM , expression . last Index Of ( STRING ) ) , source Type ) ; default : throw new Solr Exception ( Error Code . BAD REQUEST , expression + STRING ) ; } }
public Value predecessor ( ) { return predecessor . get ( ) ; }
public static double log Pdf ( double x , double m , double sd ) { double a = NUM / ( Math . sqrt ( NUM * Math . PI ) * sd ) ; double b = - ( x - m ) * ( x - m ) / ( NUM * sd * sd ) ; return Math . log ( a ) + b ; }
public int value Sparse Int ( int index Of Index ) throws Exception { return Integer . parse Int ( actual Value ( index Of Index ) ) ; }
public void test To Engineering String Zero Pos Exponent ( ) { String a = STRING ; Big Decimal a Number = new Big Decimal ( a ) ; String result = STRING ; assert Equals ( STRING , result , a Number . to Engineering String ( ) ) ; }
public static int scan ( long v ) { return NUM - Long . number Of Leading Zeros ( v ) ; }
public static boolean is All Upper Case ( String str ) { if ( str == null ) return BOOL ; boolean has Letters = BOOL ; char c ; for ( int i = str . length ( ) - NUM ; i >= NUM ; i -- ) { c = str . char At ( i ) ; if ( Character . is Letter ( c ) ) { if ( ! Character . is Upper Case ( c ) ) return BOOL ; has Letters = BOOL ; } } return has Letters ; }
public static Class Path create Class Path ( String class Path String , String sys Class Path String , String ext Dirs String ) { Path path = new Path ( ) ; if ( sys Class Path String == null ) { sys Class Path String = System . get Property ( STRING ) ; } if ( sys Class Path String != null ) { path . add Files ( sys Class Path String ) ; } path . expand Jar Class Paths ( BOOL ) ; if ( ext Dirs String == null ) { ext Dirs String = System . get Property ( STRING ) ; } if ( ext Dirs String != null ) { path . add Directories ( ext Dirs String ) ; } path . empty Path Default ( STRING ) ; if ( class Path String == null ) { class Path String = System . get Property ( STRING ) ; if ( class Path String == null ) { class Path String = STRING ; } } path . add Files ( class Path String ) ; return new Class Path ( path . to Array ( new String [ path . size ( ) ] ) ) ; }
protected Abstract Spined Buffer ( int initial Capacity ) { if ( initial Capacity < NUM ) throw new Illegal Argument Exception ( STRING + initial Capacity ) ; this . initial Chunk Power = Math . max ( MIN CHUNK POWER , Integer . SIZE - Integer . number Of Leading Zeros ( initial Capacity - NUM ) ) ; }
public static void UF 9 ( double [ ] x , double [ ] f , int nx ) { int count 1 = NUM ; int count 2 = NUM ; int count 3 = NUM ; double sum 1 = NUM ; double sum 2 = NUM ; double sum 3 = NUM ; double yj ; double E = NUM ; for ( int j = NUM ; j <= nx ; j ++ ) { yj = x [ j - NUM ] - NUM * x [ NUM ] * Math . sin ( NUM * PI * x [ NUM ] + j * PI / nx ) ; if ( j % NUM == NUM ) { sum 1 += yj * yj ; count 1 ++ ; } else if ( j % NUM == NUM ) { sum 2 += yj * yj ; count 2 ++ ; } else { sum 3 += yj * yj ; count 3 ++ ; } } yj = ( NUM + E ) * ( NUM - NUM * ( NUM * x [ NUM ] - NUM ) * ( NUM * x [ NUM ] - NUM ) ) ; if ( yj < NUM ) { yj = NUM ; } f [ NUM ] = NUM * ( yj + NUM * x [ NUM ] ) * x [ NUM ] + NUM * sum 1 / ( double ) count 1 ; f [ NUM ] = NUM * ( yj - NUM * x [ NUM ] + NUM ) * x [ NUM ] + NUM * sum 2 / ( double ) count 2 ; f [ NUM ] = NUM - x [ NUM ] + NUM * sum 3 / ( double ) count 3 ; }
private void cleaning Text ( ) { int latin Count = NUM , non Latin Count = NUM ; for ( int i = NUM ; i < text . length ( ) ; ++ i ) { char c = text . char At ( i ) ; if ( c <= STRING && c >= STRING ) { ++ latin Count ; } else if ( c >= STRING && Unicode Block . of ( c ) != Unicode Block . LATIN EXTENDED ADDITIONAL ) { ++ non Latin Count ; } } if ( latin Count * NUM < non Latin Count ) { String Buffer text Without Latin = new String Buffer ( ) ; for ( int i = NUM ; i < text . length ( ) ; ++ i ) { char c = text . char At ( i ) ; if ( c > STRING || c < STRING ) text Without Latin . append ( c ) ; } text = text Without Latin ; } }
public void begin Apply Interval ( ) { interval Start Millis = System . current Time Millis ( ) ; end Millis = interval Start Millis ; state = Task State . apply ; }
void handshake ( ) throws Ignite Checked Exception , SSL Exception { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + handshake Status + STRING + ses + STRING ) ; lock ( ) ; try { boolean loop = BOOL ; while ( loop ) { switch ( handshake Status ) { case NOT HANDSHAKING : case FINISHED : { SSL Session ssl Ses = ssl Engine . get Session ( ) ; if ( log . is Debug Enabled ( ) ) log . debug ( STRING + ssl Ses . get Protocol ( ) + STRING + ssl Ses . get Cipher Suite ( ) + STRING + ses + STRING ) ; handshake Finished = BOOL ; if ( ! init Handshake Complete ) { init Handshake Complete = BOOL ; Grid Nio Future Impl < ? > fut = ses . remove Meta ( HANDSHAKE FUT META KEY ) ; if ( fut != null ) fut . on Done ( ) ; parent . proceed Session Opened ( ses ) ; } loop = BOOL ; break ; } case NEED TASK : { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + ses ) ; handshake Status = run Tasks ( ) ; break ; } case NEED UNWRAP : { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + ses ) ; Status status = unwrap Handshake ( ) ; if ( status == BUFFER UNDERFLOW && handshake Status != FINISHED || ssl Engine . is Inbound Done ( ) ) loop = BOOL ; break ; } case NEED WRAP : { if ( out Net Buf . has Remaining ( ) ) U . warn ( log , STRING + ses ) ; out Net Buf . clear ( ) ; SSL Engine Result res = ssl Engine . wrap ( handshake Buf , out Net Buf ) ; out Net Buf . flip ( ) ; handshake Status = res . get Handshake Status ( ) ; if ( log . is Debug Enabled ( ) ) log . debug ( STRING + res . get Status ( ) + STRING + handshake Status + STRING + ses + STRING ) ; write Net Buffer ( ) ; break ; } default : { throw new Illegal State Exception ( STRING + handshake Status + STRING + ses + STRING ) ; } } } } finally { unlock ( ) ; } if ( log . is Debug Enabled ( ) ) log . debug ( STRING + handshake Status + STRING + ses + STRING ) ; }
public void send Messages ( List < Producer Record < String , String > > records ) { Producer < String , String > producer = new Kafka Producer < > ( get Producer Config ( ) ) ; for ( Producer Record < String , String > rec : records ) producer . send ( rec ) ; producer . flush ( ) ; producer . close ( ) ; }
private static J Free Chart create Chart ( ) { XY Series series 1 = new XY Series ( STRING ) ; series 1 . add ( NUM , NUM ) ; series 1 . add ( NUM , NUM ) ; series 1 . add ( NUM , NUM ) ; XY Dataset dataset = new XY Series Collection ( series 1 ) ; return Chart Factory . create XY Step Chart ( STRING , STRING , STRING , dataset , Plot Orientation . VERTICAL , BOOL , BOOL , BOOL ) ; }
public void append To Nal Unit ( byte [ ] data , int offset , int limit ) { if ( ! is Filling ) { return ; } int read Length = limit - offset ; if ( nal Data . length < nal Length + read Length ) { nal Data = Arrays . copy Of ( nal Data , ( nal Length + read Length ) * NUM ) ; } System . arraycopy ( data , offset , nal Data , nal Length , read Length ) ; nal Length += read Length ; }
public boolean is Number Geographical ( Phone Number phone Number ) { return is Number Geographical ( get Number Type ( phone Number ) , phone Number . get Country Code ( ) ) ; }
protected final void refresh Loading Views Size ( ) { final int maximum Pull Scroll = ( int ) ( get Maximum Pull Scroll ( ) * NUM ) ; int p Left = get Padding Left ( ) ; int p Top = get Padding Top ( ) ; int p Right = get Padding Right ( ) ; int p Bottom = get Padding Bottom ( ) ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Width ( maximum Pull Scroll ) ; p Left = - maximum Pull Scroll ; } else { p Left = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Width ( maximum Pull Scroll ) ; p Right = - maximum Pull Scroll ; } else { p Right = NUM ; } break ; case VERTICAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Height ( maximum Pull Scroll ) ; p Top = - maximum Pull Scroll ; } else { p Top = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Height ( maximum Pull Scroll ) ; p Bottom = - maximum Pull Scroll ; } else { p Bottom = NUM ; } break ; } if ( DEBUG ) { Log . d ( LOG TAG , String . format ( STRING , p Left , p Top , p Right , p Bottom ) ) ; } set Padding ( p Left , p Top , p Right , p Bottom ) ; }
protected int weighted Distribution ( int [ ] weights ) { int sum = NUM ; for ( int weight : weights ) { sum += weight ; } int val = ( int ) Math . floor ( m random . next Double ( ) * sum ) ; for ( int i = NUM ; i < weights . length ; i ++ ) { val -= weights [ i ] ; if ( val < NUM ) { return i ; } } return - NUM ; }
protected String clean Up ( String classname ) { String result ; result = classname ; if ( result . index Of ( STRING ) > - NUM ) { result = result . replace ( STRING , STRING ) ; } if ( result . index Of ( STRING ) > - NUM ) { result = result . replace ( STRING , STRING ) ; } if ( result . ends With ( STRING ) ) { result = result . substring ( NUM , result . length ( ) - NUM ) ; } return result ; }
public static boolean is Assignable ( Class target Type , Class value Type ) { Assert . not Null ( target Type , STRING ) ; Assert . not Null ( value Type , STRING ) ; return ( target Type . is Assignable From ( value Type ) || target Type . equals ( primitive Wrapper Type Map . get ( value Type ) ) ) ; }
public Dialog Check Box add Dialog Check Box ( String description , String label Text , boolean initial State ) { String [ ] args = new String [ NUM ] ; args [ NUM ] = STRING ; args [ NUM ] = description ; args [ NUM ] = label Text ; args [ NUM ] = Boolean . to String ( initial State ) ; Dialog Check Box dcb = new Dialog Check Box ( ) ; dcb . set Args ( args ) ; components . add ( dcb ) ; main Panel . add ( dcb ) ; return dcb ; }
private void perform Restore ( File member Dir , File backup Dir ) throws Exception { List < File > if Files = File Util . find All ( member Dir , STRING ) ; for ( File file : if Files ) { file . delete ( ) ; } List < File > oplogs = File Util . find All ( member Dir , OPLOG REGEX ) ; for ( File file : oplogs ) { file . delete ( ) ; } File restore Script = new File ( backup Dir , STRING ) ; if ( ! restore Script . exists ( ) ) { restore Script = new File ( backup Dir , STRING ) ; } assert True ( restore Script . exists ( ) ) ; assert Equals ( NUM , execute ( restore Script . get Absolute Path ( ) ) ) ; }
public static boolean download Url To Stream ( String url String , Output Stream output Stream ) { disable Connection Reuse If Necessary ( ) ; Http URL Connection url Connection = null ; Buffered Output Stream out = null ; Buffered Input Stream in = null ; try { final URL url = new URL ( url String ) ; url Connection = ( Http URL Connection ) url . open Connection ( ) ; in = new Buffered Input Stream ( url Connection . get Input Stream ( ) , IO BUFFER SIZE ) ; out = new Buffered Output Stream ( output Stream , IO BUFFER SIZE ) ; int b ; while ( ( b = in . read ( ) ) != - NUM ) { out . write ( b ) ; } return BOOL ; } catch ( final IO Exception e ) { Log . e ( TAG , STRING + e ) ; } finally { if ( url Connection != null ) { url Connection . disconnect ( ) ; } try { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } catch ( final IO Exception e ) { } } return BOOL ; }
public boolean is Payments Adequate ( ) { return is Payments Adequate ( this . cart ) ; }
@ Override public void transaction Commited ( final long commit Time ) { if ( listeners . is Empty ( ) ) { records . reset ( ) ; } else { records . flush ( ) ; listeners . for Each ( null ) ; } }
public static M Warehouse Price [ ] find ( MB Partner b Partner , boolean Is SO Trx , Timestamp valid , int M Warehouse ID , String Value , String Name , String UPC , String SKU , String trx Name ) { int M Price List ID = Is SO Trx ? b Partner . get M Price List ID ( ) : b Partner . get PO Price List ID ( ) ; M Price List pl = null ; if ( M Price List ID == NUM ) pl = M Price List . get Default ( b Partner . get Ctx ( ) , Is SO Trx ) ; else pl = M Price List . get ( b Partner . get Ctx ( ) , M Price List ID , trx Name ) ; if ( pl == null ) { s log . severe ( STRING ) ; return null ; } M Price List Version plv = pl . get Price List Version ( valid ) ; if ( plv == null ) { s log . severe ( STRING + pl . get M Price List ID ( ) ) ; return null ; } return find ( b Partner . get Ctx ( ) , plv . get M Price List Version ID ( ) , M Warehouse ID , Value , Name , UPC , SKU , trx Name ) ; }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { COUNTER = new Atomic Integer ( ) ; serializers = new Hash Map < Class , Serializer Wrapper > ( ) ; serializers Array = new Serializer [ NUM ] ; deserialize ( in , this ) ; }
public static Date translate Time ( Date date , Time Zone src , Time Zone dest ) { Date new Date = new Date ( ) ; int offset = ( dest . get Offset ( date . get Time ( ) ) - src . get Offset ( date . get Time ( ) ) ) ; new Date . set Time ( date . get Time ( ) - offset ) ; return new Date ; }
private void show Popup Menu ( final Mouse Event event ) { final C Traces Table Filter Menu menu = new C Traces Table Filter Menu ( get Filter Field ( ) ) ; menu . show ( event . get Component ( ) , event . get X ( ) , event . get Y ( ) ) ; }
private Task Resource Rep finish Deactivate Task ( Block Consistency Group consistency Group , String task ) { URI id = consistency Group . get Id ( ) ; Operation op = new Operation ( ) ; op . ready ( ) ; op . set Progress ( NUM ) ; op . set Resource Type ( Resource Operation Type Enum . DELETE CONSISTENCY GROUP ) ; Operation status = db Client . create Task Op Status ( Block Consistency Group . class , id , task , op ) ; return to Task ( consistency Group , task , status ) ; }
public static Severity parse Severity ( String str ) throws Illegal Severity Exception { if ( str . equals Ignore Case ( Messages . ERROR ) ) { return ERROR ; } else if ( str . equals Ignore Case ( Messages . WARNING ) ) { return WARNING ; } else { throw new Illegal Severity Exception ( ) ; } }
private void restore From Keypress ( final Key Event key Event , final int key Number ) { if ( key Event . is Alt Down ( ) ) { final int array Index = ( key Number > NUM ? key Number : MAX RECENT MESSAGES ) - NUM ; if ( array Index < recent Messages . size ( ) ) { display Message ( recent Messages . get ( array Index ) ) ; } key Event . consume ( ) ; } }
public void remove Scrolling Listener ( On Wheel Scroll Listener listener ) { scrolling Listeners . remove ( listener ) ; }
public void fire ( Session session , int type , boolean before Action ) { if ( row Based || before != before Action || ( type Mask & type ) == NUM ) { return ; } load ( ) ; Connection c2 = session . create Connection ( BOOL ) ; boolean old = BOOL ; if ( type != Trigger . SELECT ) { old = session . set Commit Or Rollback Disabled ( BOOL ) ; } Value identity = session . get Last Scope Identity ( ) ; try { trigger Callback . fire ( c2 , null , null ) ; } catch ( Throwable e ) { throw Db Exception . get ( Error Code . ERROR EXECUTING TRIGGER 3 , e , get Name ( ) , trigger Class Name != null ? trigger Class Name : STRING , e . to String ( ) ) ; } finally { if ( session . get Last Trigger Identity ( ) != null ) { session . set Last Scope Identity ( session . get Last Trigger Identity ( ) ) ; session . set Last Trigger Identity ( null ) ; } else { session . set Last Scope Identity ( identity ) ; } if ( type != Trigger . SELECT ) { session . set Commit Or Rollback Disabled ( old ) ; } } }
public static void close Quietly ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( Runtime Exception rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
public Mqtt Device mqtt Device ( ) { return mqtt Device ; }
public boolean skips Location ( String location Id ) { return skip Locations List . contains ( location Id ) ; }
private List < Race > parse Races ( String json ) { List < Race > result = new Array List < > ( ) ; if ( json == null ) { return null ; } JSON Parser parser = new JSON Parser ( ) ; try { JSON Object root = ( JSON Object ) parser . parse ( json . trim ( ) ) ; JSON Array races = ( JSON Array ) root . get ( STRING ) ; for ( Object o : races ) { if ( o instanceof JSON Object ) { Race race = parse Race ( ( JSON Object ) o ) ; if ( race != null ) { result . add ( race ) ; } } } } catch ( Parse Exception | Class Cast Exception | Null Pointer Exception ex ) { LOGGER . warning ( STRING + ex ) ; return null ; } return result ; }
public boolean is Connected ( short node Id ) { Node Connection nc = connections . get ( node Id ) ; return ( nc != null && nc . state == Node Connection State . CONNECTED ) ; }
public Object Name manage System Member ( Distributed Member distributed Member ) throws Admin Exception , Malformed Object Name Exception { try { System Member member = lookup System Member ( distributed Member ) ; if ( member == null ) return null ; System Member Jmx Impl jmx = ( System Member Jmx Impl ) member ; Object Name oname = new Object Name ( jmx . get M Bean Name ( ) ) ; return oname ; } catch ( Admin Exception e ) { logger . warn ( e . get Message ( ) , e ) ; throw e ; } catch ( Runtime Exception e ) { logger . warn ( e . get Message ( ) , e ) ; throw e ; } catch ( Virtual Machine Error err ) { System Failure . initiate Failure ( err ) ; throw err ; } catch ( Error e ) { System Failure . check Failure ( ) ; logger . error ( e . get Message ( ) , e ) ; throw e ; } }
private void connect ( ) throws IO Exception { JMX Service URL jmx Url = new JMX Service URL ( String . format ( fmt Url , host , port ) ) ; jmxc = JMX Connector Factory . connect ( jmx Url , null ) ; M Bean Server Connection mbean Server Conn = jmxc . get M Bean Server Connection ( ) ; try { Object Name name = new Object Name ( DOMAINLIST OBJECT NAME ) ; domain List Proxy = M Bean Server Invocation Handler . new Proxy Instance ( mbean Server Conn , name , Domain List Management M Bean . class , BOOL ) ; name = new Object Name ( VIRTUALUSERTABLE OBJECT NAME ) ; virtual User Table Proxy = M Bean Server Invocation Handler . new Proxy Instance ( mbean Server Conn , name , Recipient Rewrite Table Management M Bean . class , BOOL ) ; name = new Object Name ( USERSREPOSITORY OBJECT NAME ) ; users Repository Proxy = M Bean Server Invocation Handler . new Proxy Instance ( mbean Server Conn , name , Users Repository Management M Bean . class , BOOL ) ; name = new Object Name ( MAILBOXCOPIER OBJECT NAME ) ; mailbox Copier Management = M Bean Server Invocation Handler . new Proxy Instance ( mbean Server Conn , name , Mailbox Copier Management M Bean . class , BOOL ) ; name = new Object Name ( MAILBOXMANAGER OBJECT NAME ) ; mailbox Manager Management = M Bean Server Invocation Handler . new Proxy Instance ( mbean Server Conn , name , Mailbox Manager Management M Bean . class , BOOL ) ; name = new Object Name ( QUOTAMANAGER OBJECT NAME ) ; quota Management = M Bean Server Invocation Handler . new Proxy Instance ( mbean Server Conn , name , Quota Management M Bean . class , BOOL ) ; name = new Object Name ( REINDEXER OBJECT NAME ) ; re Indexer Management = M Bean Server Invocation Handler . new Proxy Instance ( mbean Server Conn , name , Re Indexer Management M Bean . class , BOOL ) ; name = new Object Name ( SIEVEMANAGER OBJECT NAME ) ; sieve Repository Management = M Bean Server Invocation Handler . new Proxy Instance ( mbean Server Conn , name , Sieve Repository Management M Bean . class , BOOL ) ; } catch ( Malformed Object Name Exception e ) { throw new Runtime Exception ( STRING , e ) ; } }
public static void show ( @ Not Null final J Component data Component , @ Nullable final J Component action Listener Component , @ Not Null final String title , @ Not Null final Project project , @ Nullable final Collection < Runnable > close Listeners , @ Not Null final An Action ... custom Actions ) { final Tool Window Api api = new Tool Window Api ( project , title ) ; final Collection < Runnable > close Listeners To Add = new Array List < Runnable > ( Collections . singleton ( new My Tool Window Closer ( api ) ) ) ; if ( close Listeners != null ) { close Listeners To Add . add All ( close Listeners ) ; } api . add ( Panel With Actions . wrap ( data Component , close Listeners To Add , action Listener Component , custom Actions ) ) ; }
public Intent Builder add Email Cc ( String address ) { if ( m Cc Addresses == null ) { m Cc Addresses = new Array List < String > ( ) ; } m Cc Addresses . add ( address ) ; return this ; }
private Array List < String > extract N Grams ( ) { Array List < String > list = new Array List < String > ( ) ; N Gram ngram = new N Gram ( ) ; for ( int i = NUM ; i < text . length ( ) ; ++ i ) { ngram . add Char ( text . char At ( i ) ) ; for ( int n = NUM ; n <= N Gram . N GRAM ; ++ n ) { String w = ngram . get ( n ) ; if ( w != null && word Lang Prob Map . contains Key ( w ) ) list . add ( w ) ; } } return list ; }
protected void update Keys ( ) { Button Info [ ] buttons = Navigation Buttons . load Button Map ( m Context ) ; int visible Count = NUM ; for ( int i = NUM ; i < buttons . length ; i ++ ) { int id = BUTTON IDS [ i ] ; Button Info info = buttons [ m Vertical ? buttons . length - i - NUM : i ] ; Key Button View button = ( Key Button View ) m Parent . find View By Id ( id ) ; boolean is Small Button = Navigation Buttons . IS SLOT SMALL [ i ] ; button . set Info ( info , m Vertical , is Small Button ) ; if ( ! info . equals ( Navigation Buttons . EMPTY ) && ! is Small Button ) { visible Count ++ ; } button . set Translation X ( NUM ) ; m Button Views . set ( i , button ) ; } if ( is Device Phone ( m Context ) ) { adjust Padding ( visible Count ) ; } update Low Lights ( visible Count ) ; }
public static final String read String ( byte [ ] bytes , String charset ) throws IO Exception { return read String ( bytes , NUM , bytes . length , Charset . for Name ( charset ) ) ; }
private void update Command Cache ( String group , String command , boolean need Notify ) { String old Command = command Cache . get ( group ) ; if ( ! command . equals ( old Command ) ) { command Cache . put ( group , command ) ; if ( need Notify ) { notify Executor . execute ( new Notify Command ( group , command ) ) ; Logger Util . info ( String . format ( STRING , group , command ) ) ; } } else { Logger Util . info ( String . format ( STRING , group , command ) ) ; } }
public void update Language ( ) { create Legend Panel ( legend Panel ) ; directory Tree Model . change Root Text ( I18 n . tr ( STRING ) ) ; }
private synchronized void rebuild Journal ( ) throws IO Exception { if ( journal Writer != null ) { journal Writer . close ( ) ; } Writer writer = new Buffered Writer ( new Output Stream Writer ( new File Output Stream ( journal File Tmp ) , Util . US ASCII ) ) ; try { writer . write ( MAGIC ) ; writer . write ( STRING ) ; writer . write ( VERSION 1 ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( app Version ) ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( value Count ) ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; for ( Entry entry : lru Entries . values ( ) ) { if ( entry . current Editor != null ) { writer . write ( DIRTY + STRING + entry . key + STRING ) ; } else { writer . write ( CLEAN + STRING + entry . key + entry . get Lengths ( ) + STRING ) ; } } } finally { writer . close ( ) ; } if ( journal File . exists ( ) ) { rename To ( journal File , journal File Backup , BOOL ) ; } rename To ( journal File Tmp , journal File , BOOL ) ; journal File Backup . delete ( ) ; journal Writer = new Buffered Writer ( new Output Stream Writer ( new File Output Stream ( journal File , BOOL ) , Util . US ASCII ) ) ; }
public static byte [ ] decompress For Zlib ( byte [ ] bytes To Decompress ) { byte [ ] return Values = null ; Inflater inflater = new Inflater ( ) ; int number Of Bytes To Decompress = bytes To Decompress . length ; inflater . set Input ( bytes To Decompress , NUM , number Of Bytes To Decompress ) ; int buffer Size In Bytes = number Of Bytes To Decompress ; int number Of Bytes Decompressed So Far = NUM ; List < Byte > bytes Decompressed So Far = new Array List < Byte > ( ) ; try { while ( inflater . needs Input ( ) == BOOL ) { byte [ ] bytes Decompressed Buffer = new byte [ buffer Size In Bytes ] ; int number Of Bytes Decompressed This Time = inflater . inflate ( bytes Decompressed Buffer ) ; number Of Bytes Decompressed So Far += number Of Bytes Decompressed This Time ; for ( int b = NUM ; b < number Of Bytes Decompressed This Time ; b ++ ) { bytes Decompressed So Far . add ( bytes Decompressed Buffer [ b ] ) ; } } return Values = new byte [ bytes Decompressed So Far . size ( ) ] ; for ( int b = NUM ; b < return Values . length ; b ++ ) { return Values [ b ] = ( byte ) ( bytes Decompressed So Far . get ( b ) ) ; } } catch ( Data Format Exception dfe ) { dfe . print Stack Trace ( ) ; } inflater . end ( ) ; return return Values ; }
protected boolean accept Chunk ( final I Chunk Message < I Binding Set > msg ) { if ( msg == null ) throw new Illegal Argument Exception ( ) ; if ( ! msg . is Materialized ( ) ) throw new Illegal State Exception ( ) ; final Abstract Running Query q = get Running Query ( msg . get Query Id ( ) ) ; if ( q == null ) { throw new Illegal State Exception ( ) ; } if ( ! q . accept Chunk ( msg ) ) { msg . release ( ) ; return BOOL ; } if ( ! is Running ( ) ) { msg . release ( ) ; return BOOL ; } priority Queue . add ( q ) ; return BOOL ; }
public String format ( Object obj , String Buffer to Append To ) throws Illegal Argument Exception { return format ( ( Date ) obj , to Append To ) ; }
void add Member ( final Type Member member ) { Preconditions . check Not Null ( member , STRING ) ; Preconditions . check Argument ( member . get Parent Type ( ) == this , STRING ) ; members . add ( member ) ; }
public synchronized void remove Incremental Classifier Listener ( Incremental Classifier Listener cl ) { m incremental Classifier Listeners . remove ( cl ) ; }
public static boolean cancel Potential Work ( Object data , Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . m Data ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( BOOL ) ; if ( Build Config . DEBUG ) { Log . d ( TAG , STRING + data ) ; } } else { return BOOL ; } } return BOOL ; }
public static Number asinh ( Number a ) { return Fast Math . asinh ( a . double Value ( ) ) ; }
private String format Names ( String [ ] names , int start Index ) { String Builder sb = new String Builder ( ) ; if ( names != null ) { for ( String name : names ) { sb . append ( name . substring ( start Index ) ) ; sb . append ( STRING ) ; } } return sb . to String ( ) ; }
public String lookup Prefix ( String uri ) { String found Prefix = null ; Enumeration prefixes = m namespaces . keys ( ) ; while ( prefixes . has More Elements ( ) ) { String prefix = ( String ) prefixes . next Element ( ) ; String uri 2 = lookup Namespace ( prefix ) ; if ( uri 2 != null && uri 2 . equals ( uri ) ) { found Prefix = prefix ; break ; } } return found Prefix ; }
public void remove All Trailers ( ) { trailer . clear ( ) ; fire Property Change ( TRAILER , null , trailer ) ; }
public Builder clear ( ) { locale Builder . clear ( ) ; return this ; }
private static boolean version Matches ( Integer v1 , Integer v2 ) { if ( v1 == null || v1 == NUM || v2 == null || v2 == NUM ) { return BOOL ; } return v1 . equals ( v2 ) ; }
public static Optional < String > package Name ( String long Name ) { if ( long Name . contains ( DOT ) ) { return Optional . of ( long Name . substring ( NUM , long Name . last Index Of ( DOT ) ) ) ; } else { return Optional . empty ( ) ; } }
public int [ ] [ ] e2 f ( ) { int e Dim = tgt End Exclusive - tgt Start Inclusive ; int [ ] [ ] e2 f = new int [ e Dim ] [ ] ; for ( int i = tgt Start Inclusive ; i < tgt End Exclusive ; ++ i ) { int local Idx = i - tgt Start Inclusive ; int [ ] e2 f I = sentence Pair . e2 f ( i ) ; int src Align Dim = e2 f I . length ; e2 f [ local Idx ] = new int [ src Align Dim ] ; if ( src Align Dim > NUM ) { System . arraycopy ( e2 f I , NUM , e2 f [ local Idx ] , NUM , src Align Dim ) ; for ( int j = NUM ; j < src Align Dim ; ++ j ) { e2 f [ local Idx ] [ j ] -= src Start Inclusive ; } } } return e2 f ; }
public void read Exif ( String in File Name ) throws File Not Found Exception , IO Exception { if ( in File Name == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Input Stream is = null ; try { is = ( Input Stream ) new Buffered Input Stream ( new File Input Stream ( in File Name ) ) ; read Exif ( is ) ; } catch ( IO Exception e ) { close Silently ( is ) ; throw e ; } is . close ( ) ; }
private void assert Write Result ( int size ) throws IO Exception { Byte Buffer buf = Byte Buffer . allocate ( size + NUM ) ; int count = NUM ; int total = NUM ; long begin Time = System . current Time Millis ( ) ; while ( ( count = client Channel . read ( buf ) ) != - NUM ) { total = total + count ; if ( System . current Time Millis ( ) - begin Time > NUM ) { break ; } } assert Equals ( total , size ) ; buf . flip ( ) ; for ( int i = NUM ; i < count ; i ++ ) { assert Equals ( ( byte ) i , buf . get ( i ) ) ; } }
public static boolean is File Upload Available ( final boolean needs Correct Mime Type ) { if ( Build . VERSION . SDK INT == NUM ) { final String platform Version = ( Build . VERSION . RELEASE == null ) ? STRING : Build . VERSION . RELEASE ; return ! needs Correct Mime Type && ( platform Version . starts With ( STRING ) || platform Version . starts With ( STRING ) ) ; } else { return BOOL ; } }
@ Override public String to String ( ) { if ( m b Generate Net ) { return to XMLBIF 03 ( ) ; } return m Instances . to String ( ) ; }
private boolean menu Item Action ( int screen X , int screen Y , int action ) { List View list View = m App Menu . get Popup ( ) . get List View ( ) ; Array List < View > item Views = new Array List < View > ( ) ; for ( int i = NUM ; i < list View . get Child Count ( ) ; ++ i ) { boolean has Image Buttons = BOOL ; if ( list View . get Child At ( i ) instanceof Linear Layout ) { Linear Layout layout = ( Linear Layout ) list View . get Child At ( i ) ; for ( int j = NUM ; j < layout . get Child Count ( ) ; ++ j ) { item Views . add ( layout . get Child At ( j ) ) ; if ( layout . get Child At ( j ) instanceof Image Button ) has Image Buttons = BOOL ; } } if ( ! has Image Buttons ) item Views . add ( list View . get Child At ( i ) ) ; } boolean did Perform Click = BOOL ; for ( int i = NUM ; i < item Views . size ( ) ; ++ i ) { View item View = item Views . get ( i ) ; boolean should Perform = item View . is Enabled ( ) && item View . is Shown ( ) && get Screen Visible Rect ( item View ) . contains ( screen X , screen Y ) ; switch ( action ) { case ITEM ACTION HIGHLIGHT : item View . set Pressed ( should Perform ) ; break ; case ITEM ACTION PERFORM : if ( should Perform ) { item View . perform Click ( ) ; did Perform Click = BOOL ; } break ; case ITEM ACTION CLEAR HIGHLIGHT ALL : item View . set Pressed ( BOOL ) ; break ; default : assert BOOL ; break ; } } return did Perform Click ; }
public void toggle ( JFX Drawer drawer ) { if ( ! drawers . contains ( drawer ) ) add Drawer ( drawer ) ; if ( drawer . is Shown ( ) || drawer . is Showing ( ) ) drawer . close ( ) ; else { update Drawer Position ( drawer ) ; drawer . open ( ) ; } }
public static boolean is V Mware Vapp ( ) { if ( is V Mware Vapp != null ) { log . info ( STRING , is V Mware Vapp . boolean Value ( ) ) ; return is V Mware Vapp . boolean Value ( ) ; } final String [ ] cmd = { GET OVF PROPERTY CMD , IS VAPP } ; Exec . Result result = Exec . sudo ( CMD TIMEOUT , cmd ) ; if ( ! result . exited Normally ( ) ) { log . error ( STRING , result . get Std Error ( ) ) ; throw new Illegal State Exception ( STRING ) ; } if ( result . get Exit Value ( ) == NUM ) { log . info ( STRING ) ; is V Mware Vapp = Boolean . TRUE ; return is V Mware Vapp . boolean Value ( ) ; } log . info ( STRING , result . get Exit Value ( ) ) ; is V Mware Vapp = Boolean . FALSE ; return is V Mware Vapp . boolean Value ( ) ; }
protected String to Base 64 ( byte [ ] data ) { return Base 64 . encode To String ( data , Base 64 . DEFAULT ) ; }
@ Override public String to Verbose String ( ) { final String Builder sb = new String Builder ( ) ; print ( sb , NUM , Verbosity . LOG WITH STACKTRACE ) ; return sb . to String ( ) ; }
public static long quantile ( long [ ] values , double quantile ) { if ( values == null ) throw new Illegal Argument Exception ( STRING ) ; if ( quantile < NUM || quantile > NUM ) throw new Illegal Argument Exception ( STRING ) ; long [ ] copy = new long [ values . length ] ; System . arraycopy ( values , NUM , copy , NUM , copy . length ) ; Arrays . sort ( copy ) ; int index = ( int ) ( copy . length * quantile ) ; return copy [ index ] ; }
public void add Tree Update ( SLD Tree Updated Interface sld Tree ) { tree Update List . add ( sld Tree ) ; }
public static double distance ( Visual Item vi 1 , Visual Item vi 2 ) { double dx = vi 1 . get X ( ) - vi 2 . get X ( ) ; double dy = vi 1 . get Y ( ) - vi 2 . get Y ( ) ; return Math . sqrt ( dx * dx + dy * dy ) ; }
@ Override public void validate Request ( Generic Attribute Resolve Request request ) throws Bad Attribute Resolve Request Exception { if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STRING ) ; String site Id = request . get Site ( ) ; if ( null == site Id ) throw new Bad Attribute Resolve Request Exception ( HDFS Resource Constants . HDFS RESOURCE RESOLVE FORMAT HINT ) ; String file Path = request . get Query ( ) ; if ( null == file Path || ! file Path . starts With ( STRING ) ) throw new Bad Attribute Resolve Request Exception ( HDFS Resource Constants . HDFS RESOURCE RESOLVE FORMAT HINT ) ; if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STRING ) ; }
public void clear ( ) { ored Criteria . clear ( ) ; order By Clause = null ; distinct = BOOL ; }
public Trigger when ( Criterion criterion ) { if ( criterion != null ) { criterions . add ( criterion ) ; } return this ; }
private static Pair < String , String > offset ROR ( final long offset , final I Translation Environment environment , final List < Reil Instruction > instructions , final String register Node Value 1 , final String register Node Value 2 , final String immediate Node Value ) { final String address = environment . get Next Variable String ( ) ; final String index = environment . get Next Variable String ( ) ; final String tmp Var = environment . get Next Variable String ( ) ; final String tmp Var 1 = environment . get Next Variable String ( ) ; final String tmp Var 2 = environment . get Next Variable String ( ) ; final String tmp Var 3 = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value 2 , dw , STRING + Integer . decode ( immediate Node Value ) , dw , tmp Var 1 ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value 2 , dw , String . value Of ( NUM - Integer . decode ( immediate Node Value ) ) , dw , tmp Var 2 ) ) ; instructions . add ( Reil Helpers . create Or ( base Offset ++ , dw , tmp Var 1 , dw , tmp Var 2 , dw , tmp Var 3 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , dw , tmp Var 3 , dw , d Word Bit Mask , dw , index ) ) ; instructions . add ( Reil Helpers . create Add ( base Offset ++ , dw , register Node Value 1 , dw , index , dw , tmp Var ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , dw , tmp Var , dw , d Word Bit Mask , dw , address ) ) ; return new Pair < String , String > ( address , register Node Value 1 ) ; }
public void clear ( ) { m Read Methods . clear ( ) ; m Write Methods . clear ( ) ; try { add Methods ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
public static String join ( Char Sequence delimiter , Object [ ] tokens ) { String Builder sb = new String Builder ( ) ; boolean first Time = BOOL ; for ( Object token : tokens ) { if ( first Time ) { first Time = BOOL ; } else { sb . append ( delimiter ) ; } sb . append ( token ) ; } return sb . to String ( ) ; }
private void fill In ( Class Symbol c ) { if ( completion Failure Name == c . fullname ) { throw new Completion Failure ( c , STRING ) ; } current Owner = c ; warned Attrs . clear ( ) ; Java File Object classfile = c . classfile ; if ( classfile != null ) { Java File Object previous Class File = current Class File ; try { if ( filling ) { Assert . error ( STRING + classfile . to Uri ( ) + STRING + previous Class File ) ; } current Class File = classfile ; if ( verbose ) { log . print Verbose ( STRING , current Class File . to String ( ) ) ; } if ( classfile . get Kind ( ) == Java File Object . Kind . CLASS ) { filling = BOOL ; try { bp = NUM ; buf = read Input Stream ( buf , classfile . open Input Stream ( ) ) ; read Class File ( c ) ; if ( ! missing Type Variables . is Empty ( ) && ! found Type Variables . is Empty ( ) ) { List < Type > missing = missing Type Variables ; List < Type > found = found Type Variables ; missing Type Variables = List . nil ( ) ; found Type Variables = List . nil ( ) ; filling = BOOL ; Class Type ct = ( Class Type ) current Owner . type ; ct . supertype field = types . subst ( ct . supertype field , missing , found ) ; ct . interfaces field = types . subst ( ct . interfaces field , missing , found ) ; } else if ( missing Type Variables . is Empty ( ) != found Type Variables . is Empty ( ) ) { Name name = missing Type Variables . head . tsym . name ; throw bad Class File ( STRING , name ) ; } } finally { missing Type Variables = List . nil ( ) ; found Type Variables = List . nil ( ) ; filling = BOOL ; } } else { if ( source Completer != null ) { source Completer . complete ( c ) ; } else { throw new Illegal State Exception ( STRING + classfile . to Uri ( ) ) ; } } return ; } catch ( IO Exception ex ) { throw bad Class File ( STRING , ex . get Message ( ) ) ; } finally { current Class File = previous Class File ; } } else { JC Diagnostic diag = diag Factory . fragment ( STRING , c . flatname ) ; throw new Completion Failure ( c , diag ) ; } }
public static Packet to Packet ( Byte Buffer data ) { final byte code = data . get ( ) ; final short id = ( short ) ( ( data . get ( ) ) & NUM ) ; final short datalen = data . get Short ( ) ; final byte [ ] auth Data = new byte [ NUM ] ; data . get ( auth Data ) ; final Packet Type type = Packet Type . get Packet Type ( code ) ; Packet pkt = null ; switch ( type ) { case ACCESS ACCEPT : pkt = new Access Accept ( ) ; pkt . set Authenticator ( new Response Authenticator ( auth Data ) ) ; break ; case ACCESS CHALLENGE : pkt = new Access Challenge ( ) ; pkt . set Authenticator ( new Response Authenticator ( auth Data ) ) ; break ; case ACCESS REJECT : pkt = new Access Reject ( ) ; pkt . set Authenticator ( new Response Authenticator ( auth Data ) ) ; break ; case ACCESS REQUEST : pkt = new Access Request ( ) ; pkt . set Authenticator ( new Request Authenticator ( auth Data ) ) ; break ; case UNKNOWN : default : LOG . log ( Level . WARNING , STRING + code + STRING ) ; return null ; } pkt . set Identifier ( id ) ; Attribute a = null ; while ( ( a = Packet Factory . next Attribute ( data ) ) != null ) { pkt . add Attribute ( a ) ; } return pkt ; }
public void unlock Read Locks ( ) { if ( database . is Multi Version ( ) ) { return ; } for ( int i = NUM ; i < locks . size ( ) ; i ++ ) { Table t = locks . get ( i ) ; if ( ! t . is Locked Exclusively ( ) ) { synchronized ( database ) { t . unlock ( this ) ; locks . remove ( i ) ; } i -- ; } } }
protected void process Attributes ( ) { for ( final String tag : tags ) { for ( final String inherit : inherits ) { style Sheet . add Styles ( tag , style Sheet . get Styles ( inherit ) ) ; } style Sheet . add Styles ( tag , attributes ) ; } }
private boolean is Image ( String url ) { return url . matches ( Regex . IMAGE PATTERN ) ; }
public void add Attribute ( Attributed Character Iterator . Attribute attribute , Object value , int start , int end ) { if ( attribute == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( start < NUM || end > text . length ( ) || start >= end ) { throw new Illegal Argument Exception ( ) ; } if ( value == null ) { return ; } List < Range > ranges = attribute Map . get ( attribute ) ; if ( ranges == null ) { ranges = new Array List < Range > ( NUM ) ; ranges . add ( new Range ( start , end , value ) ) ; attribute Map . put ( attribute , ranges ) ; return ; } List Iterator < Range > it = ranges . list Iterator ( ) ; while ( it . has Next ( ) ) { Range range = it . next ( ) ; if ( end <= range . start ) { it . previous ( ) ; break ; } else if ( start < range . end || ( start == range . end && value . equals ( range . value ) ) ) { Range r1 = null , r3 ; it . remove ( ) ; r1 = new Range ( range . start , start , range . value ) ; r3 = new Range ( end , range . end , range . value ) ; while ( end > range . end && it . has Next ( ) ) { range = it . next ( ) ; if ( end <= range . end ) { if ( end > range . start || ( end == range . start && value . equals ( range . value ) ) ) { it . remove ( ) ; r3 = new Range ( end , range . end , range . value ) ; break ; } } else { it . remove ( ) ; } } if ( value . equals ( r1 . value ) ) { if ( value . equals ( r3 . value ) ) { it . add ( new Range ( r1 . start < start ? r1 . start : start , r3 . end > end ? r3 . end : end , r1 . value ) ) ; } else { it . add ( new Range ( r1 . start < start ? r1 . start : start , end , r1 . value ) ) ; if ( r3 . start < r3 . end ) { it . add ( r3 ) ; } } } else { if ( value . equals ( r3 . value ) ) { if ( r1 . start < r1 . end ) { it . add ( r1 ) ; } it . add ( new Range ( start , r3 . end > end ? r3 . end : end , r3 . value ) ) ; } else { if ( r1 . start < r1 . end ) { it . add ( r1 ) ; } it . add ( new Range ( start , end , value ) ) ; if ( r3 . start < r3 . end ) { it . add ( r3 ) ; } } } return ; } } it . add ( new Range ( start , end , value ) ) ; }
public static boolean point In Rotated Rect ( float [ ] point , Rect F bound , float rot ) { Matrix m = new Matrix ( ) ; float [ ] p = Arrays . copy Of ( point , NUM ) ; m . set Rotate ( rot , bound . center X ( ) , bound . center Y ( ) ) ; Matrix m0 = new Matrix ( ) ; if ( ! m . invert ( m0 ) ) return BOOL ; m0 . map Points ( p ) ; return inclusive Contains ( bound , p [ NUM ] , p [ NUM ] ) ; }
@ Override public void warning ( String domain , String key , XML Parse Exception exception ) throws XNI Exception { if ( f Error Handler != null ) { SAX Parse Exception sax Exception = create SAX Parse Exception ( exception ) ; try { f Error Handler . warning ( sax Exception ) ; } catch ( SAX Parse Exception e ) { throw create XML Parse Exception ( e ) ; } catch ( SAX Exception e ) { throw create XNI Exception ( e ) ; } } }
public void modify All ( Map < String , Collection < Dynamic Modification > > modifications , Collection < Throwable > problems ) throws Cannot Compile Exception { for ( String class Name : modifications . key Set ( ) ) { try { modify ( class Name , modifications . get ( class Name ) ) ; } catch ( Not Found Exception e ) { log . warn ( STRING + class Name , e ) ; problems . add ( e ) ; } catch ( Class Not Found Exception e ) { log . warn ( STRING + class Name , e ) ; problems . add ( e ) ; } catch ( IO Exception e ) { log . warn ( STRING + class Name , e ) ; problems . add ( e ) ; } } }
public Mutable Location to Mutable Location ( World w ) { return new Mutable Location ( x , y , z , w ) ; }
public boolean verify ( General Name Interface name ) throws IO Exception { if ( name == null ) { throw new IO Exception ( STRING ) ; } if ( excluded != null && excluded . size ( ) > NUM ) { for ( int i = NUM ; i < excluded . size ( ) ; i ++ ) { General Subtree gs = excluded . get ( i ) ; if ( gs == null ) continue ; General Name gn = gs . get Name ( ) ; if ( gn == null ) continue ; General Name Interface ex Name = gn . get Name ( ) ; if ( ex Name == null ) continue ; switch ( ex Name . constrains ( name ) ) { case General Name Interface . NAME DIFF TYPE : case General Name Interface . NAME WIDENS : case General Name Interface . NAME SAME TYPE : break ; case General Name Interface . NAME MATCH : case General Name Interface . NAME NARROWS : return BOOL ; } } } if ( permitted != null && permitted . size ( ) > NUM ) { boolean same Type = BOOL ; for ( int i = NUM ; i < permitted . size ( ) ; i ++ ) { General Subtree gs = permitted . get ( i ) ; if ( gs == null ) continue ; General Name gn = gs . get Name ( ) ; if ( gn == null ) continue ; General Name Interface per Name = gn . get Name ( ) ; if ( per Name == null ) continue ; switch ( per Name . constrains ( name ) ) { case General Name Interface . NAME DIFF TYPE : continue ; case General Name Interface . NAME WIDENS : case General Name Interface . NAME SAME TYPE : same Type = BOOL ; continue ; case General Name Interface . NAME MATCH : case General Name Interface . NAME NARROWS : return BOOL ; } } if ( same Type ) { return BOOL ; } } return BOOL ; }
public void read Graphics ( Object Input Stream objstream ) throws IO Exception { Debug . message ( STRING , STRING ) ; try { while ( BOOL ) { try { OM Graphic omg = ( OM Graphic ) objstream . read Object ( ) ; graphics . add ( omg ) ; } catch ( Class Not Found Exception e ) { e . print Stack Trace ( ) ; } catch ( Optional Data Exception ode ) { ode . print Stack Trace ( ) ; } } } catch ( EOF Exception e ) { } }
public void create Topics ( int num Partitions , int replication Factor , Set < String > topics ) { create Topics ( num Partitions , replication Factor , topics . to Array ( new String [ topics . size ( ) ] ) ) ; }
public synchronized void remove Listener ( Listener l ) { listeners . remove ( l ) ; }
public Command Line add ( String ... args ) { if ( args != null && args . length > NUM ) { Collections . add All ( arguments , args ) ; } return this ; }
private void restore Icon ( Backup Protos . Key key , byte [ ] buffer , int data Size ) throws IO Exception { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base 64 . encode To String ( buffer , NUM , data Size , Base 64 . NO WRAP ) ) ; Backup Protos . Resource res = unpack Proto ( new Backup Protos . Resource ( ) , buffer , data Size ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = Bitmap Factory . decode Byte Array ( res . data , NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } else { if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; m Icon Cache . preload Icon ( Component Name . unflatten From String ( key . name ) , icon , res . dpi , STRING , m User Serial , m Idp ) ; } }
public static int determine Consecutive Digit Count ( Char Sequence msg , int startpos ) { int count = NUM ; int len = msg . length ( ) ; int idx = startpos ; if ( idx < len ) { char ch = msg . char At ( idx ) ; while ( is Digit ( ch ) && idx < len ) { count ++ ; idx ++ ; if ( idx < len ) { ch = msg . char At ( idx ) ; } } } return count ; }
public Event Store Builder use Ssl Connection ( String certificate Common Name ) { settings Builder . ssl Settings ( Ssl Settings . trust Certificate CN ( certificate Common Name ) ) ; return this ; }
Action Map create Action Map ( ) { Action Map map = new Action Map UI Resource ( ) ; map . put ( STRING , new Show System Menu Action ( BOOL ) ) ; map . put ( STRING , new Show System Menu Action ( BOOL ) ) ; return map ; }
protected void paint Content Border Left Edge ( Graphics g , int x , int y , int w , int h , boolean draw Broken , Rectangle sel Rect , boolean is Content Border Painted ) { if ( is Content Border Painted ) { g . set Color ( select Highlight ) ; g . fill Rect ( x , y , NUM , h - NUM ) ; } }
private String field Param Comment ( Field field , String param Comment ) { String comment Type = field Type Cardinality Comment ( field ) ; String comment = String . format ( STRING , wrap If Keyword Or Built In ( field . get Simple Name ( ) ) , comment Type ) ; if ( param Comment == null ) { param Comment = Documentation Util . get Scoped Description ( field ) ; } if ( ! Strings . is Null Or Empty ( param Comment ) ) { param Comment = R Doc Comment Fixer . rdocify ( param Comment ) ; comment += STRING + param Comment . replace All ( STRING , STRING ) ; } return comment + STRING ; }
public static long period End ( long now , long period ) { Local Date Time time = Local Date Time . of Epoch Second ( now / NUM , NUM , Zone Offset . UTC ) ; long end Time = period End ( now , period , time ) ; return end Time ; }
public void test Then Combine source Cancelled ( ) throws Throwable { for ( Execution Mode m : Execution Mode . values ( ) ) for ( boolean may Interrupt If Running : new boolean [ ] { BOOL , BOOL } ) for ( boolean f First : new boolean [ ] { BOOL , BOOL } ) for ( boolean fail First : new boolean [ ] { BOOL , BOOL } ) for ( Integer v1 : new Integer [ ] { NUM , null } ) { final Completable Future < Integer > f = new Completable Future < > ( ) ; final Completable Future < Integer > g = new Completable Future < > ( ) ; final Subtract Function r1 = new Subtract Function ( m ) ; final Subtract Function r2 = new Subtract Function ( m ) ; final Subtract Function r3 = new Subtract Function ( m ) ; final Completable Future < Integer > fst = f First ? f : g ; final Completable Future < Integer > snd = ! f First ? f : g ; final Callable < Boolean > complete 1 = fail First ? null : null ; final Callable < Boolean > complete 2 = fail First ? null : null ; final Completable Future < Integer > h1 = m . then Combine ( f , g , r1 ) ; assert True ( complete 1 . call ( ) ) ; final Completable Future < Integer > h2 = m . then Combine ( f , g , r2 ) ; check Incomplete ( h1 ) ; check Incomplete ( h2 ) ; assert True ( complete 2 . call ( ) ) ; final Completable Future < Integer > h3 = m . then Combine ( f , g , r3 ) ; check Completed With Wrapped Cancellation Exception ( h1 ) ; check Completed With Wrapped Cancellation Exception ( h2 ) ; check Completed With Wrapped Cancellation Exception ( h3 ) ; r1 . assert Not Invoked ( ) ; r2 . assert Not Invoked ( ) ; r3 . assert Not Invoked ( ) ; check Completed Normally ( fail First ? snd : fst , v1 ) ; check Cancelled ( fail First ? fst : snd ) ; } }
public static String generate Chat Id ( final String receiver Id , final String sender Id ) { String combined = null ; if ( receiver Id . compare To ( sender Id ) < NUM ) { combined = String . format ( Locale . US , App Constants . CHAT ID FORMAT , receiver Id , sender Id ) ; } else { combined = String . format ( Locale . US , App Constants . CHAT ID FORMAT , sender Id , receiver Id ) ; } String hashed = null ; try { hashed = Utils . sha 1 ( combined ) ; } catch ( final No Such Algorithm Exception e ) { hashed = combined ; } return hashed ; }
void extract ( String fname , String files [ ] ) throws IO Exception { Zip File zf = new Zip File ( fname ) ; Set < Zip Entry > dirs = new Dir Set ( ) ; Enumeration < ? extends Zip Entry > zes = zf . entries ( ) ; while ( zes . has More Elements ( ) ) { Zip Entry e = zes . next Element ( ) ; if ( files == null ) { dirs . add ( extract File ( zf . get Input Stream ( e ) , e ) ) ; } else { String name = e . get Name ( ) ; for ( String file : files ) { if ( name . starts With ( file ) ) { dirs . add ( extract File ( zf . get Input Stream ( e ) , e ) ) ; break ; } } } } zf . close ( ) ; update Last Modified Time ( dirs ) ; }
public void remove ( Menu Component m ) { synchronized ( get Tree Lock ( ) ) { int index = menus . index Of ( m ) ; if ( index >= NUM ) { remove ( index ) ; } } }
public void test Identity ( ) { assert Not Null ( new Identity Stub ( ) ) ; }
public void key Released ( final Key Event k ) { }
public XML Importer ( Progress Listener listener ) { progress Listener = listener ; }
private static Tree Map < Integer , Long > load Workspace Screens Db ( Context context ) { final Content Resolver content Resolver = context . get Content Resolver ( ) ; final Uri screens Uri = Launcher Settings . Workspace Screens . CONTENT URI ; final Cursor sc = content Resolver . query ( screens Uri , null , null , null , null ) ; Tree Map < Integer , Long > ordered Screens = new Tree Map < Integer , Long > ( ) ; try { final int id Index = sc . get Column Index Or Throw ( Launcher Settings . Workspace Screens . ID ) ; final int rank Index = sc . get Column Index Or Throw ( Launcher Settings . Workspace Screens . SCREEN RANK ) ; while ( sc . move To Next ( ) ) { try { long screen Id = sc . get Long ( id Index ) ; int rank = sc . get Int ( rank Index ) ; ordered Screens . put ( rank , screen Id ) ; } catch ( Exception e ) { Launcher . add Dump Log ( TAG , STRING + e , BOOL ) ; } } } finally { sc . close ( ) ; } Launcher . add Dump Log ( TAG , STRING , BOOL ) ; Array List < String > ordered Screens Pairs = new Array List < String > ( ) ; for ( Integer i : ordered Screens . key Set ( ) ) { ordered Screens Pairs . add ( STRING + i + STRING + ordered Screens . get ( i ) + STRING ) ; } Launcher . add Dump Log ( TAG , STRING + Text Utils . join ( STRING , ordered Screens Pairs ) , BOOL ) ; return ordered Screens ; }
public Observable < Drive Id > create File ( Drive Folder folder , final File file ) { return create File ( folder , file , file . get Name ( ) ) ; }
public static void validate Context ( Accel Surface src Data , Accel Surface dst Data , Region clip , Composite comp , Affine Transform xform , Paint paint , Sun Graphics 2 D sg 2 d , int flags ) { Buffered Context context = dst Data . get Context ( ) ; context . validate ( src Data , dst Data , clip , comp , xform , paint , sg 2 d , flags ) ; }
public void add Certificates And CR Ls ( Cert Store cert Store ) throws Cert Store Exception , CMS Exception { certs . add All ( CMS Utils . get Certificates From Store ( cert Store ) ) ; crls . add All ( CMS Utils . get CR Ls From Store ( cert Store ) ) ; }
public void change Default Names ( String type ) { String [ ] convert = CONVERT TYPES . split ( STRING ) ; String [ ] types = TYPES . split ( STRING ) ; if ( convert . length != types . length ) { log . error ( STRING , types . length , convert . length ) ; return ; } if ( type . equals ( Setup . DESCRIPTIVE ) ) { for ( int i = NUM ; i < convert . length ; i ++ ) { replace Name ( convert [ i ] , types [ i ] ) ; } String [ ] aar Types = ARR TYPES . split ( STRING ) ; for ( int i = NUM ; i < aar Types . length ; i ++ ) { list . remove ( aar Types [ i ] ) ; } for ( int i = NUM ; i < types . length ; i ++ ) { if ( ! list . contains ( types [ i ] ) ) { list . add ( types [ i ] ) ; } } } else { for ( int i = NUM ; i < convert . length ; i ++ ) { replace Name ( types [ i ] , convert [ i ] ) ; } for ( int i = NUM ; i < types . length ; i ++ ) { list . remove ( types [ i ] ) ; } types = ARR TYPES . split ( STRING ) ; for ( int i = NUM ; i < types . length ; i ++ ) { if ( ! list . contains ( types [ i ] ) ) { list . add ( types [ i ] ) ; } } } }
public Label Value Comparator ( final Locale locale ) { c = Collator . get Instance ( locale ) ; }
public Refresher ( GL Scene scene ) { Preconditions . check Not Null ( scene ) ; this . scene = scene ; }
public Rect update Fast Scroller Bounds ( int last Touch Y ) { m Invalidate Rect . set ( m Bg Bounds ) ; if ( is Visible ( ) ) { int edge Padding = m Rv . get Max Scrollbar Width ( ) ; int bg Padding = ( m Bg Original Size - m Text Bounds . height ( ) ) / NUM ; int bg Height = m Bg Original Size ; int bg Width = Math . max ( m Bg Original Size , m Text Bounds . width ( ) + ( NUM * bg Padding ) ) ; if ( Utilities . is Rtl ( m Res ) ) { m Bg Bounds . left = m Rv . get Background Padding ( ) . left + ( NUM * m Rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . right = m Bg Bounds . left + bg Width ; } else { m Bg Bounds . right = m Rv . get Width ( ) - m Rv . get Background Padding ( ) . right - ( NUM * m Rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . left = m Bg Bounds . right - bg Width ; } m Bg Bounds . top = last Touch Y - ( int ) ( FAST SCROLL OVERLAY Y OFFSET FACTOR * bg Height ) ; m Bg Bounds . top = Math . max ( edge Padding , Math . min ( m Bg Bounds . top , m Rv . get Height ( ) - edge Padding - bg Height ) ) ; m Bg Bounds . bottom = m Bg Bounds . top + bg Height ; } else { m Bg Bounds . set Empty ( ) ; } m Invalidate Rect . union ( m Bg Bounds ) ; return m Invalidate Rect ; }
public void build Unique Id ( ) throws V Plex Api Exception { String name = get Name ( ) ; if ( ! name . contains ( VPLEX NAME DELIM ) ) { s logger . warn ( STRING + name ) ; unique Id = name ; return ; } int last Delim Index = name . last Index Of ( VPLEX NAME DELIM ) ; String suffix = name . substring ( last Delim Index + NUM ) ; s logger . info ( STRING , name , suffix ) ; unique Id = suffix ; }
public static String create Base 64 ( Bitmap m Bitmap ) { Byte Array Output Stream baos 1 = new Byte Array Output Stream ( ) ; m Bitmap . compress ( Bitmap . Compress Format . JPEG , NUM , baos 1 ) ; byte [ ] b1 = baos 1 . to Byte Array ( ) ; return Base 64 . encode To String ( b1 , Base 64 . DEFAULT ) ; }
public Dice Server Editor ( final I Remote Dice Server dice Server ) { m bean = dice Server ; final int bottom Space = NUM ; final int label Space = NUM ; int row = NUM ; if ( m bean . sends Email ( ) ) { add ( m to Label , new Grid Bag Constraints ( NUM , row , NUM , NUM , NUM , NUM , Grid Bag Constraints . WEST , Grid Bag Constraints . NONE , new Insets ( NUM , NUM , bottom Space , label Space ) , NUM , NUM ) ) ; add ( m to Address , new Grid Bag Constraints ( NUM , row , NUM , NUM , NUM , NUM , Grid Bag Constraints . EAST , Grid Bag Constraints . HORIZONTAL , new Insets ( NUM , NUM , bottom Space , NUM ) , NUM , NUM ) ) ; m to Address . set Text ( m bean . get To Address ( ) ) ; row ++ ; add ( m cc Label , new Grid Bag Constraints ( NUM , row , NUM , NUM , NUM , NUM , Grid Bag Constraints . WEST , Grid Bag Constraints . NONE , new Insets ( NUM , NUM , bottom Space , label Space ) , NUM , NUM ) ) ; add ( m cc Address , new Grid Bag Constraints ( NUM , row , NUM , NUM , NUM , NUM , Grid Bag Constraints . EAST , Grid Bag Constraints . HORIZONTAL , new Insets ( NUM , NUM , bottom Space , NUM ) , NUM , NUM ) ) ; m cc Address . set Text ( m bean . get Cc Address ( ) ) ; row ++ ; } if ( m bean . supports Game Id ( ) ) { final J Label m game Id Label = new J Label ( STRING ) ; add ( m game Id Label , new Grid Bag Constraints ( NUM , row , NUM , NUM , NUM , NUM , Grid Bag Constraints . WEST , Grid Bag Constraints . NONE , new Insets ( NUM , NUM , bottom Space , label Space ) , NUM , NUM ) ) ; add ( m game Id , new Grid Bag Constraints ( NUM , row , NUM , NUM , NUM , NUM , Grid Bag Constraints . EAST , Grid Bag Constraints . HORIZONTAL , new Insets ( NUM , NUM , bottom Space , NUM ) , NUM , NUM ) ) ; m game Id . set Text ( m bean . get Game Id ( ) ) ; row ++ ; } add ( m test Dicey Button , new Grid Bag Constraints ( NUM , row , NUM , NUM , NUM , NUM , Grid Bag Constraints . EAST , Grid Bag Constraints . NONE , new Insets ( NUM , NUM , bottom Space , NUM ) , NUM , NUM ) ) ; setup Listeners ( ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL ; } if ( ! ( obj instanceof Candlestick Renderer ) ) { return BOOL ; } Candlestick Renderer that = ( Candlestick Renderer ) obj ; if ( this . candle Width != that . candle Width ) { return BOOL ; } if ( ! Paint Utilities . equal ( this . up Paint , that . up Paint ) ) { return BOOL ; } if ( ! Paint Utilities . equal ( this . down Paint , that . down Paint ) ) { return BOOL ; } if ( this . draw Volume != that . draw Volume ) { return BOOL ; } if ( this . max Candle Width In Milliseconds != that . max Candle Width In Milliseconds ) { return BOOL ; } if ( this . auto Width Method != that . auto Width Method ) { return BOOL ; } if ( this . auto Width Factor != that . auto Width Factor ) { return BOOL ; } if ( this . auto Width Gap != that . auto Width Gap ) { return BOOL ; } if ( this . use Outline Paint != that . use Outline Paint ) { return BOOL ; } if ( ! Paint Utilities . equal ( this . volume Paint , that . volume Paint ) ) { return BOOL ; } return super . equals ( obj ) ; }
public Header Iterator iterator ( ) { return new Basic List Header Iterator ( this . headers , null ) ; }
public static void w ( String tag , String msg , Object ... args ) { if ( s Level > LEVEL WARNING ) { return ; } if ( args . length > NUM ) { msg = String . format ( msg , args ) ; } Log . w ( tag , msg ) ; }
@ Suppress Warnings ( STRING ) @ Suppress Lint ( STRING ) @ Override public boolean on Touch Event ( Motion Event event ) { Point F v Center End ; float v Dist End ; if ( anim != null && ! anim . interruptible ) { return BOOL ; } else { anim = null ; } if ( v Translate == null ) { return BOOL ; } if ( detector == null || detector . on Touch Event ( event ) ) { return BOOL ; } int touch Count = event . get Pointer Count ( ) ; switch ( event . get Action ( ) ) { case Motion Event . ACTION DOWN : case Motion Event . ACTION POINTER 1 DOWN : case Motion Event . ACTION POINTER 2 DOWN : anim = null ; max Touch Count = Math . max ( max Touch Count , touch Count ) ; if ( touch Count >= NUM ) { if ( zoom Enabled ) { float distance = distance ( event . get X ( NUM ) , event . get X ( NUM ) , event . get Y ( NUM ) , event . get Y ( NUM ) ) ; scale Start = scale ; v Dist Start = distance ; v Translate Start = new Point F ( v Translate . x , v Translate . y ) ; v Center Start = new Point F ( ( event . get X ( NUM ) + event . get X ( NUM ) ) / NUM , ( event . get Y ( NUM ) + event . get Y ( NUM ) ) / NUM ) ; } else { max Touch Count = NUM ; } handler . remove Messages ( MESSAGE LONG CLICK ) ; } else { v Translate Start = new Point F ( v Translate . x , v Translate . y ) ; v Center Start = new Point F ( event . get X ( ) , event . get Y ( ) ) ; handler . send Empty Message Delayed ( MESSAGE LONG CLICK , NUM ) ; } return BOOL ; case Motion Event . ACTION MOVE : boolean consumed = BOOL ; if ( max Touch Count > NUM ) { if ( touch Count >= NUM ) { v Dist End = distance ( event . get X ( NUM ) , event . get X ( NUM ) , event . get Y ( NUM ) , event . get Y ( NUM ) ) ; v Center End = new Point F ( ( event . get X ( NUM ) + event . get X ( NUM ) ) / NUM , ( event . get Y ( NUM ) + event . get Y ( NUM ) ) / NUM ) ; if ( zoom Enabled && ( distance ( v Center Start . x , v Center End . x , v Center Start . y , v Center End . y ) > NUM || Math . abs ( v Dist End - v Dist Start ) > NUM || is Panning ) ) { is Zooming = BOOL ; is Panning = BOOL ; consumed = BOOL ; scale = Math . min ( max Scale , ( v Dist End / v Dist Start ) * scale Start ) ; if ( scale <= min Scale ( ) ) { v Dist Start = v Dist End ; scale Start = min Scale ( ) ; v Center Start = v Center End ; v Translate Start = v Translate ; } else if ( pan Enabled ) { float v Left Start = v Center Start . x - v Translate Start . x ; float v Top Start = v Center Start . y - v Translate Start . y ; float v Left Now = v Left Start * ( scale / scale Start ) ; float v Top Now = v Top Start * ( scale / scale Start ) ; v Translate . x = v Center End . x - v Left Now ; v Translate . y = v Center End . y - v Top Now ; } else if ( s Requested Center != null ) { v Translate . x = ( get Width ( ) / NUM ) - ( scale * s Requested Center . x ) ; v Translate . y = ( get Height ( ) / NUM ) - ( scale * s Requested Center . y ) ; } else { v Translate . x = ( get Width ( ) / NUM ) - ( scale * ( s Width ( ) / NUM ) ) ; v Translate . y = ( get Height ( ) / NUM ) - ( scale * ( s Height ( ) / NUM ) ) ; } fit To Bounds ( BOOL ) ; refresh Required Tiles ( BOOL ) ; } } else if ( ! is Zooming ) { float dx = Math . abs ( event . get X ( ) - v Center Start . x ) ; float dy = Math . abs ( event . get Y ( ) - v Center Start . y ) ; if ( dx > NUM || dy > NUM || is Panning ) { consumed = BOOL ; v Translate . x = v Translate Start . x + ( event . get X ( ) - v Center Start . x ) ; v Translate . y = v Translate Start . y + ( event . get Y ( ) - v Center Start . y ) ; float last X = v Translate . x ; float last Y = v Translate . y ; fit To Bounds ( BOOL ) ; if ( last X == v Translate . x || ( last Y == v Translate . y && dy > NUM ) || is Panning ) { is Panning = BOOL ; } else if ( dx > NUM ) { max Touch Count = NUM ; handler . remove Messages ( MESSAGE LONG CLICK ) ; } if ( ! pan Enabled ) { v Translate . x = v Translate Start . x ; v Translate . y = v Translate Start . y ; } refresh Required Tiles ( BOOL ) ; } } } if ( consumed ) { handler . remove Messages ( MESSAGE LONG CLICK ) ; invalidate ( ) ; return BOOL ; } break ; case Motion Event . ACTION UP : case Motion Event . ACTION POINTER UP : case Motion Event . ACTION POINTER 2 UP : handler . remove Messages ( MESSAGE LONG CLICK ) ; if ( max Touch Count > NUM && ( is Zooming || is Panning ) ) { if ( is Zooming && touch Count == NUM ) { is Panning = BOOL ; v Translate Start = new Point F ( v Translate . x , v Translate . y ) ; if ( event . get Action Index ( ) == NUM ) { v Center Start = new Point F ( event . get X ( NUM ) , event . get Y ( NUM ) ) ; } else { v Center Start = new Point F ( event . get X ( NUM ) , event . get Y ( NUM ) ) ; } } if ( touch Count < NUM ) { is Zooming = BOOL ; } if ( touch Count < NUM ) { is Panning = BOOL ; max Touch Count = NUM ; } refresh Required Tiles ( BOOL ) ; return BOOL ; } if ( touch Count == NUM ) { is Zooming = BOOL ; is Panning = BOOL ; max Touch Count = NUM ; } return BOOL ; } return super . on Touch Event ( event ) ; }
public static < T1 , T2 > void transform ( Collection < T1 > from , Collection < T2 > to , Transformer < T1 , T2 > transformer ) { for ( T1 instance : from ) { to . add ( transformer . transform ( instance ) ) ; } }
public static String generate Code ( ) { return generate Code ( CODESIZE ) ; }
public static boolean is Book Search Url ( String url ) { return url . starts With ( STRING ) || url . starts With ( STRING ) ; }
public void flush ( ) throws java . io . IO Exception { m os . flush ( ) ; }
private void combine Entries ( Array List < long [ ] > list , int total ) { Collections . sort ( list , this ) ; for ( int min Gap = NUM ; min Gap < total ; min Gap += min Gap / NUM ) { for ( int i = NUM ; i < list . size ( ) - NUM ; i ++ ) { long [ ] current = list . get ( i ) ; long [ ] next = list . get ( i + NUM ) ; if ( current [ NUM ] + min Gap >= next [ NUM ] ) { current [ NUM ] = next [ NUM ] ; list . remove ( i + NUM ) ; i -- ; } } int searched = NUM ; for ( long [ ] range : list ) { searched += range [ NUM ] - range [ NUM ] + NUM ; } if ( searched > NUM * total || list . size ( ) < NUM ) { break ; } } }
@ Override public void write String ( byte [ ] str , int offset , int length ) throws IO Exception { if ( str == null ) write Int ( NUM ) ; else { if ( use Compression && length >= Compressor . MIN SIZE FOR DEFLATION ) { if ( byte Buffer . length < length ) byte Buffer = new byte [ NUM * length ] ; int number Of Bytes = compressor . deflate String 2 Byte Array ( str , offset , length , byte Buffer ) ; write Int ( number Of Bytes ) ; io . write ( byte Buffer , NUM , Math . abs ( number Of Bytes ) ) ; } else { write Int ( length ) ; io . write ( str , offset , length ) ; } } }
public void test Generate Domain Limit ( ) throws Exception { Array List < URL Crawl Datum > list = new Array List < URL Crawl Datum > ( ) ; list . add ( create URL Crawl Datum ( STRING , NUM , NUM ) ) ; list . add ( create URL Crawl Datum ( STRING , NUM , NUM ) ) ; list . add ( create URL Crawl Datum ( STRING , NUM , NUM ) ) ; create Crawl DB ( list ) ; Configuration my Configuration = new Configuration ( conf ) ; my Configuration . set Int ( Generator . GENERATOR MAX COUNT , NUM ) ; my Configuration . set ( Generator . GENERATOR COUNT MODE , Generator . GENERATOR COUNT VALUE DOMAIN ) ; Path generated Segment = generate Fetchlist ( Integer . MAX VALUE , my Configuration , BOOL ) ; Path fetchlist Path = new Path ( new Path ( generated Segment , Crawl Datum . GENERATE DIR NAME ) , STRING ) ; Array List < URL Crawl Datum > fetch List = read Contents ( fetchlist Path ) ; assert Equals ( NUM , fetch List . size ( ) ) ; my Configuration = new Configuration ( my Configuration ) ; my Configuration . set Int ( Generator . GENERATOR MAX COUNT , NUM ) ; generated Segment = generate Fetchlist ( Integer . MAX VALUE , my Configuration , BOOL ) ; fetchlist Path = new Path ( new Path ( generated Segment , Crawl Datum . GENERATE DIR NAME ) , STRING ) ; fetch List = read Contents ( fetchlist Path ) ; assert Equals ( NUM , fetch List . size ( ) ) ; my Configuration = new Configuration ( my Configuration ) ; my Configuration . set Int ( Generator . GENERATOR MAX COUNT , NUM ) ; generated Segment = generate Fetchlist ( Integer . MAX VALUE , my Configuration , BOOL ) ; fetchlist Path = new Path ( new Path ( generated Segment , Crawl Datum . GENERATE DIR NAME ) , STRING ) ; fetch List = read Contents ( fetchlist Path ) ; assert Equals ( NUM , fetch List . size ( ) ) ; }
protected void write Column Not Nullable Stmt ( String Builder ddl ) { ddl . append ( STRING ) ; }
private static Output Stream wrap Output Stream ( final Output Stream stream ) { String os = System . get Property ( STRING ) ; if ( os . starts With ( STRING ) ) { try { return new Windows Ansi Output Stream ( stream ) ; } catch ( Throwable ignore ) { } return new Ansi Output Stream ( stream ) ; } return stream ; }
@ Override public Set < Location > unmarshal ( Locations Type locations Type ) { Set < Location > locations = new Linked Hash Set < Location > ( ) ; locations . add All ( locations Type . get Rps Blast Locations ( ) ) ; locations . add All ( locations Type . get Hmmer 2 Locations ( ) ) ; locations . add All ( locations Type . get Hmmer 3 Locations ( ) ) ; locations . add All ( locations Type . get Super Family Hmmer 3 Locations ( ) ) ; locations . add All ( locations Type . get Finger Prints Locations ( ) ) ; locations . add All ( locations Type . get Blast Pro Dom Locations ( ) ) ; locations . add All ( locations Type . get Pattern Scan Locations ( ) ) ; locations . add All ( locations Type . get Profile Scan Locations ( ) ) ; locations . add All ( locations Type . get Phobius Locations ( ) ) ; locations . add All ( locations Type . get Coils Locations ( ) ) ; locations . add All ( locations Type . get Panther Locations ( ) ) ; locations . add All ( locations Type . get Signal P Locations ( ) ) ; locations . add All ( locations Type . get TMHMM Locations ( ) ) ; return locations ; }
public int write Key ( Output Stream out ) throws IO Exception { out . write ( block Buffer , key Offset , klen ) ; return klen ; }
boolean descends From ( Class File cf ) { return descends From ( cf . to String ( ) ) ; }
protected Object write Pre Process ( Object o ) throws Exception { return o ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public Expression Parser Builder with Dynamics ( Resolver resolver ) { dynamics Resolvers . add ( resolver ) ; return this ; }
void warn Missing Names ( File file ) { String result = check Missing Names ( file ) ; if ( result . equals ( STRING ) ) { J Option Pane . show Message Dialog ( who , STRING ) ; } else { J Option Pane . show Message Dialog ( who , result ) ; } }
public void add ( int position , Wishlist Item wishlist Item ) { notify Item Inserted ( position ) ; wishlist Items . add ( position , wishlist Item ) ; }
protected void print Band ( byte [ ] bgr Data , int x , int y , int width , int height ) throws Printer Exception { mPS Stream . println ( IMAGE SAVE ) ; int ps Bytes Per Row = NUM * width ; while ( ps Bytes Per Row > MAX PSSTR ) { ps Bytes Per Row /= NUM ; } mPS Stream . println ( ps Bytes Per Row + IMAGE STR ) ; mPS Stream . println ( STRING + width + STRING + STRING + height + STRING + x + STRING + y + STRING ) ; mPS Stream . println ( width + STRING + height + STRING + NUM + STRING + width + STRING + STRING + - height + STRING + height + STRING + STRING ) ; int index = NUM ; byte [ ] rgb Data = new byte [ width * NUM ] ; try { for ( int i = NUM ; i < height ; i ++ ) { index = swap BG Rto RGB ( bgr Data , index , rgb Data ) ; byte [ ] encoded Data = rl Encode ( rgb Data ) ; byte [ ] ascii Data = ascii 85 Encode ( encoded Data ) ; mPS Stream . write ( ascii Data ) ; mPS Stream . println ( STRING ) ; } } catch ( IO Exception e ) { throw new Printer IO Exception ( e ) ; } mPS Stream . println ( IMAGE RESTORE ) ; }
private void init Panel ( final I Tree Node < C Tag > root Tag ) { final J Panel main Panel = new J Panel ( new Border Layout ( ) ) ; main Panel . set Border ( new Titled Border ( STRING ) ) ; create Tree ( root Tag ) ; final J Scroll Pane pane = new J Scroll Pane ( m tag Tree ) ; pane . set Vertical Scroll Bar Policy ( Scroll Pane Constants . VERTICAL SCROLLBAR AS NEEDED ) ; pane . set Horizontal Scroll Bar Policy ( Scroll Pane Constants . HORIZONTAL SCROLLBAR AS NEEDED ) ; final J Panel any Tag Panel = new J Panel ( ) ; any Tag Panel . add ( m any Tag Box ) ; main Panel . add ( pane , Border Layout . CENTER ) ; main Panel . add ( m any Tag Box , Border Layout . SOUTH ) ; add ( main Panel , Border Layout . CENTER ) ; }
public final void append ( String value ) { if ( value == null ) return ; int strlen = value . length ( ) ; if ( NUM == strlen ) return ; int copyfrom = NUM ; char [ ] chunk = m array [ m last Chunk ] ; int available = m chunk Size - m first Free ; while ( strlen > NUM ) { if ( available > strlen ) available = strlen ; value . get Chars ( copyfrom , copyfrom + available , m array [ m last Chunk ] , m first Free ) ; strlen -= available ; copyfrom += available ; if ( strlen > NUM ) { int i = m array . length ; if ( m last Chunk + NUM == i ) { char [ ] [ ] newarray = new char [ i + NUM ] [ ] ; System . arraycopy ( m array , NUM , newarray , NUM , i ) ; m array = newarray ; } chunk = m array [ ++ m last Chunk ] ; if ( chunk == null ) { if ( m last Chunk == NUM << m rebundle Bits && m chunk Bits < m max Chunk Bits ) { m inner FSB = new Fast String Buffer ( this ) ; } chunk = m array [ m last Chunk ] = new char [ m chunk Size ] ; } available = m chunk Size ; m first Free = NUM ; } } m first Free += available ; }
protected void add Prefix Match ( String Builder sb , String surface , String analyzed , String prefix Token ) { if ( prefix Token . length ( ) >= surface . length ( ) ) { add Whole Match ( sb , surface , analyzed ) ; return ; } sb . append ( STRING ) ; sb . append ( surface . substring ( NUM , prefix Token . length ( ) ) ) ; sb . append ( STRING ) ; sb . append ( surface . substring ( prefix Token . length ( ) ) ) ; }
public Wallet Data add Wallet ( final Bitcoin Controller bitcoin Controller , Wallet wallet , String wallet Filename ) { if ( wallet Filename == null ) { return null ; } for ( Wallet Data loop Model Data : per Wallet Model Data List ) { if ( wallet Filename . equals ( loop Model Data . get Wallet Filename ( ) ) ) { return loop Model Data ; } } Wallet Data new Per Wallet Model Data = new Wallet Data ( ) ; new Per Wallet Model Data . set Wallet ( wallet ) ; new Per Wallet Model Data . set Wallet Filename ( wallet Filename ) ; new Per Wallet Model Data . set Wallet Table Data List ( new Array List < Wallet Table Data > ( ) ) ; if ( there Is No Active Wallet ( ) ) { per Wallet Model Data List . remove ( active Wallet Model Data ) ; active Wallet Model Data = new Per Wallet Model Data ; } per Wallet Model Data List . add ( new Per Wallet Model Data ) ; if ( wallet != null ) { wallet . add Event Listener ( bitcoin Controller ) ; } create Wallet Table Data ( bitcoin Controller , wallet Filename ) ; create Address Book Receiving Addresses ( wallet Filename ) ; return new Per Wallet Model Data ; }
public E push ( E object ) { add Element ( object ) ; return object ; }
public void add ( T object ) { synchronized ( m Lock ) { if ( m Original Values != null ) { m Original Values . add ( object ) ; } else { m Objects . add ( object ) ; } } if ( m Notify On Change ) notify Data Set Changed ( ) ; }
public static String to Human Size ( long bytes Value ) { if ( NUM == bytes Value ) { return STRING ; } boolean power Of Two = BOOL ; if ( ( bytes Value & ( bytes Value - NUM ) ) == NUM ) { power Of Two = BOOL ; } long multiple = ( long ) ( bytes Value / NUM ) ; if ( ( multiple & ( multiple - NUM ) ) == NUM ) { power Of Two = BOOL ; } Unit unit = Unit . B ; if ( power Of Two ) { if ( bytes Value >= Unit . Ei B . value ) { unit = Unit . Ei B ; } else if ( bytes Value >= Unit . Pi B . value ) { unit = Unit . Pi B ; } else if ( bytes Value >= Unit . Ti B . value ) { unit = Unit . Ti B ; } else if ( bytes Value >= Unit . Gi B . value ) { unit = Unit . Gi B ; } else if ( bytes Value >= Unit . Mi B . value ) { unit = Unit . Mi B ; } else if ( bytes Value >= Unit . Ki B . value ) { unit = Unit . Ki B ; } } else { if ( bytes Value >= Unit . EB . value ) { unit = Unit . EB ; } else if ( bytes Value >= Unit . PB . value ) { unit = Unit . PB ; } else if ( bytes Value >= Unit . TB . value ) { unit = Unit . TB ; } else if ( bytes Value >= Unit . GB . value ) { unit = Unit . GB ; } else if ( bytes Value >= Unit . MB . value ) { unit = Unit . MB ; } else if ( bytes Value >= Unit . KB . value ) { unit = Unit . KB ; } } double val = ( bytes Value / unit . get Value ( ) ) ; double rounded Value = Math . round ( val * NUM ) / NUM ; Big Decimal my Decimal = Big Decimal . value Of ( rounded Value ) ; Big Decimal updated = my Decimal . strip Trailing Zeros ( ) ; return updated . to Plain String ( ) + unit . name ( ) ; }
public boolean equals ( Object another ) { if ( another instanceof Permission ) { Permission p = ( Permission ) another ; return permission . equals ( p . to String ( ) ) ; } else { return BOOL ; } }
public static Intent build Start In Terminal Intent ( File script ) { final Component Name component Name = Constants . SL 4 A SERVICE LAUNCHER COMPONENT NAME ; Intent intent = new Intent ( ) ; intent . set Component ( component Name ) ; intent . set Action ( Constants . ACTION LAUNCH FOREGROUND SCRIPT ) ; intent . put Extra ( Constants . EXTRA SCRIPT PATH , script . get Absolute Path ( ) ) ; return intent ; }
public Document load Document ( Resource file ) throws SAX Exception , IO Exception { DOM Parser parser = new DOM Parser ( ) ; Input Stream in = null ; try { in = file . get Input Stream ( ) ; Input Source source = new Input Source ( in ) ; parser . parse ( source ) ; } finally { IO Util . close EL ( in ) ; } return parser . get Document ( ) ; }
public void reset Filters ( Boolean enabled ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + enabled ) ; } Set keys = filters . key Set ( ) ; for ( Iterator it = keys . iterator ( ) ; it . has Next ( ) ; ) { String title = ( String ) it . next ( ) ; set Filter Value ( title , enabled ) ; } update Interface ( ) ; }
private String [ ] diff half Match I ( String longtext , String shorttext , int i ) { String seed = longtext . substring ( i , i + longtext . length ( ) / NUM ) ; int j = - NUM ; String best common = STRING ; String best longtext a = STRING , best longtext b = STRING ; String best shorttext a = STRING , best shorttext b = STRING ; while ( ( j = shorttext . index Of ( seed , j + NUM ) ) != - NUM ) { int prefix Length = diff common Prefix ( longtext . substring ( i ) , shorttext . substring ( j ) ) ; int suffix Length = diff common Suffix ( longtext . substring ( NUM , i ) , shorttext . substring ( NUM , j ) ) ; if ( best common . length ( ) < suffix Length + prefix Length ) { best common = shorttext . substring ( j - suffix Length , j ) + shorttext . substring ( j , j + prefix Length ) ; best longtext a = longtext . substring ( NUM , i - suffix Length ) ; best longtext b = longtext . substring ( i + prefix Length ) ; best shorttext a = shorttext . substring ( NUM , j - suffix Length ) ; best shorttext b = shorttext . substring ( j + prefix Length ) ; } } if ( best common . length ( ) * NUM >= longtext . length ( ) ) { return new String [ ] { best longtext a , best longtext b , best shorttext a , best shorttext b , best common } ; } else { return null ; } }
@ Override public boolean generate Event ID ( ) { return BOOL ; }
private void update Utility ( ) { for ( Individual individual : population ) { double old Fitness = individual . get Fitness ( ) ; double new Fitness = fitness ( individual . get Solution ( ) , ideal Point ) ; double relative Decrease = old Fitness - new Fitness ; if ( relative Decrease > NUM ) { individual . set Utility ( NUM ) ; } else { double utility = Math . min ( NUM , NUM * ( NUM + delta / NUM ) * individual . get Utility ( ) ) ; individual . set Utility ( utility ) ; } individual . set Fitness ( new Fitness ) ; } }
private void write Keys With Prefix ( String prefix ) { for ( String key : keys ) { if ( key . starts With ( prefix ) ) { ps . println ( key + STRING + prop . get Property ( key ) ) ; } } ps . println ( ) ; }
public List < Operation > send And Wait ( List < Operation > ops ) { return send And Wait ( ops , BOOL ) ; }
public static void copy ( byte [ ] in , Output Stream out ) throws IO Exception { Assert . not Null ( in , STRING ) ; Assert . not Null ( out , STRING ) ; try { out . write ( in ) ; } finally { try { out . close ( ) ; } catch ( IO Exception ex ) { } } }
public Action map To XACML Action ( String native Action Name , String service Name ) throws XACML Exception { return null ; }
private int next Int ( String Tokenizer tok , String error Msg ) throws SAX Exception { if ( ! tok . has More Tokens ( ) ) { throw new SAX Exception ( error Msg ) ; } try { return Integer . parse Int ( tok . next Token ( ) ) ; } catch ( Number Format Exception nfe ) { throw new SAX Exception ( error Msg ) ; } }
public Calculable ( String id , double value ) { set Id ( id ) ; set Value ( value ) ; set When ( System . current Time Millis ( ) ) ; }
public static boolean bookmark Node Exists ( Context context , long node Id ) { Boolean result = chrome Browser Provider Call ( Boolean . class , Chrome Browser Provider . CLIENT API BOOKMARK NODE EXISTS , context , args To Bundle ( node Id ) ) ; return result != null ? result . boolean Value ( ) : BOOL ; }
private void execute Tasks Simultaneously With Barrier ( Runnable ... tasks ) throws Interrupted Exception { Count Down Latch latch = new Count Down Latch ( tasks . length ) ; for ( Runnable task : tasks ) { executor . execute ( null ) ; } latch . await ( ) ; }
private boolean is Operator ( char tok ) { if ( OPERATORS . index Of ( tok ) == - NUM ) { return BOOL ; } return BOOL ; }
protected String format Iterable ( JC Diagnostic d , Iterable < ? > it , Locale l ) { String Builder sbuf = new String Builder ( ) ; String sep = STRING ; for ( Object o : it ) { sbuf . append ( sep ) ; sbuf . append ( format Argument ( d , o , l ) ) ; sep = STRING ; } return sbuf . to String ( ) ; }
public void end Representation ( ) { if ( ! representation Protections Set ) { if ( current Representation Protections != null ) { Collections . sort ( current Representation Protections , this ) ; } representation Protections = current Representation Protections ; representation Protections Set = BOOL ; } else { if ( current Representation Protections == null ) { Assertions . check State ( representation Protections == null ) ; } else { Collections . sort ( current Representation Protections , this ) ; Assertions . check State ( current Representation Protections . equals ( representation Protections ) ) ; } } current Representation Protections = null ; }
private static char [ ] zz Unpack C Map ( String packed ) { char [ ] map = new char [ NUM ] ; int i = NUM ; int j = NUM ; while ( i < NUM ) { int count = packed . char At ( i ++ ) ; char value = packed . char At ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM ) ; } return map ; }
public static Module Version value Of ( String string ) { return parse Version ( string ) ; }
static void check Type Ref And Path ( int type Ref , Type Path type Path ) { int mask = NUM ; switch ( type Ref > > > NUM ) { case Type Reference . CLASS TYPE PARAMETER : case Type Reference . METHOD TYPE PARAMETER : case Type Reference . METHOD FORMAL PARAMETER : mask = NUM ; break ; case Type Reference . FIELD : case Type Reference . METHOD RETURN : case Type Reference . METHOD RECEIVER : case Type Reference . LOCAL VARIABLE : case Type Reference . RESOURCE VARIABLE : case Type Reference . INSTANCEOF : case Type Reference . NEW : case Type Reference . CONSTRUCTOR REFERENCE : case Type Reference . METHOD REFERENCE : mask = NUM ; break ; case Type Reference . CLASS EXTENDS : case Type Reference . CLASS TYPE PARAMETER BOUND : case Type Reference . METHOD TYPE PARAMETER BOUND : case Type Reference . THROWS : case Type Reference . EXCEPTION PARAMETER : mask = NUM ; break ; case Type Reference . CAST : case Type Reference . CONSTRUCTOR INVOCATION TYPE ARGUMENT : case Type Reference . METHOD INVOCATION TYPE ARGUMENT : case Type Reference . CONSTRUCTOR REFERENCE TYPE ARGUMENT : case Type Reference . METHOD REFERENCE TYPE ARGUMENT : mask = NUM ; break ; default : throw new Illegal Argument Exception ( STRING + Integer . to Hex String ( type Ref > > > NUM ) ) ; } if ( ( type Ref & ~ mask ) != NUM ) { throw new Illegal Argument Exception ( STRING + Integer . to Hex String ( type Ref ) ) ; } if ( type Path != null ) { for ( int i = NUM ; i < type Path . get Length ( ) ; ++ i ) { int step = type Path . get Step ( i ) ; if ( step != Type Path . ARRAY ELEMENT && step != Type Path . INNER TYPE && step != Type Path . TYPE ARGUMENT && step != Type Path . WILDCARD BOUND ) { throw new Illegal Argument Exception ( STRING + i + STRING + type Path ) ; } if ( step != Type Path . TYPE ARGUMENT && type Path . get Step Argument ( i ) != NUM ) { throw new Illegal Argument Exception ( STRING + i + STRING + type Path ) ; } } } }
@ Override public boolean equals ( Object other Obj ) { if ( other Obj instanceof P2 Model ) { return content . equals ( ( ( P2 Model ) other Obj ) . content ) ; } else { return BOOL ; } }
public boolean show Icons ( ) { return preferences . get Boolean ( resources . get String ( R . string . key show icons ) , Boolean . parse Boolean ( resources . get String ( R . string . default show icons ) ) ) ; }
public static < V > boolean add List Not Null Value ( List < V > source List , V value ) { return ( source List != null && value != null ) ? source List . add ( value ) : BOOL ; }
private boolean check For Key ( ) throws Exception { String query = m query ; query = query . replace All ( STRING , STRING ) ; if ( ! query . starts With ( STRING ) ) { return BOOL ; } m order By . clear ( ) ; if ( ! m Data Base Connection . is Connected ( ) ) { m Data Base Connection . connect To Database ( ) ; } Database Meta Data dmd = m Data Base Connection . get Meta Data ( ) ; String table = end Of Query ( BOOL ) ; Result Set rs = dmd . get Primary Keys ( null , null , table ) ; while ( rs . next ( ) ) { m order By . add ( rs . get String ( NUM ) ) ; } rs . close ( ) ; if ( m order By . size ( ) != NUM ) { return BOOL ; } rs = dmd . get Best Row Identifier ( null , null , table , Database Meta Data . best Row Session , BOOL ) ; Result Set Meta Data rmd = rs . get Meta Data ( ) ; int help = NUM ; while ( rs . next ( ) ) { m order By . add ( rs . get String ( NUM ) ) ; help ++ ; } rs . close ( ) ; if ( help == rmd . get Column Count ( ) ) { m order By . clear ( ) ; } if ( m order By . size ( ) != NUM ) { return BOOL ; } return BOOL ; }
public Ignite Striped Thread Pool Executor ( int concurrent Lvl , String grid Name , String thread Name Prefix ) { execs = new Executor Service [ concurrent Lvl ] ; Thread Factory factory = new Ignite Thread Factory ( grid Name , thread Name Prefix ) ; for ( int i = NUM ; i < concurrent Lvl ; i ++ ) execs [ i ] = Executors . new Single Thread Executor ( factory ) ; }
public static boolean is Zip ( Buffered Input Stream in ) { in . mark ( NUM ) ; byte [ ] b = new byte [ NUM ] ; byte [ ] zip Sig = new byte [ NUM ] ; zip Sig [ NUM ] = NUM ; zip Sig [ NUM ] = NUM ; zip Sig [ NUM ] = NUM ; zip Sig [ NUM ] = NUM ; try { in . read ( b , NUM , NUM ) ; } catch ( Exception ex ) { throw new Runtime Exception ( STRING , ex ) ; } try { in . reset ( ) ; } catch ( Exception ex ) { throw new Runtime Exception ( STRING , ex ) ; } return Arrays . equals ( b , zip Sig ) ; }
public List < String > extract ( Configuration config ) { List < String > features = new Array List < String > ( ) ; for ( Extractor fe : extractors ) { features . add ( fe . extract ( config ) ) ; } return features ; }
public String to String ( ) { String Buffer path = new String Buffer ( ) ; if ( absolute ) path . append ( STRING ) ; for ( int i = NUM ; i < elements . size ( ) ; i ++ ) { if ( i > NUM ) path . append ( STRING ) ; path . append ( elements . get ( i ) ) ; } return path . to String ( ) ; }
public void handle Tbl Data Action Href Request ( Request Invocation Event event ) { Agents Model model = ( Agents Model ) get Model ( ) ; String agent Type = get Display ID Type ( ) ; String universal Id = hex To String ( ( String ) get Display Field Value ( TBL DATA ACTION HREF ) ) ; set Page Session Attribute ( Agent Profile View Bean . UNIVERSAL ID , universal Id ) ; SSO Token sso Token = model . get User SSO Token ( ) ; String realm = ( String ) get Page Session Attribute ( AM Admin Constants . CURRENT REALM ) ; String Tokenizer st = new String Tokenizer ( universal Id , STRING ) ; st . next Token ( ) ; String agent Name = st . next Token ( ) ; try { AM Identity amid = new AM Identity ( sso Token , agent Name , Id Type . AGENTONLY , realm , null ) ; if ( agent Type . equals ( Agents View Bean . AGENT WEB ) || ( agent Type . equals ( Agents View Bean . DEFAULT ID TYPE ) ) ) { if ( is Properties Locally Stored ( amid ) ) { set Page Session Attribute ( LOCAL OR NOT , PROP LOCAL ) ; } else { set Page Session Attribute ( LOCAL OR NOT , PROP CENTRAL ) ; } } Class clazz = get Agent Customized View Bean ( model . get Agent Type ( amid ) ) ; AM View Bean Base vb = ( AM View Bean Base ) get View Bean ( clazz ) ; set Page Session Attribute ( PG SESSION SUPERCEDE AGENT TYPE , model . get Agent Type ( amid ) ) ; remove Page Session Attribute ( Generic Agent Profile View Bean . PS TABNAME ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( Id Repo Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , model . get Error String ( e ) ) ; forward To ( ) ; } catch ( SSO Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , model . get Error String ( e ) ) ; forward To ( ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , model . get Error String ( e ) ) ; forward To ( ) ; } catch ( Class Not Found Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , model . get Error String ( e ) ) ; forward To ( ) ; } }
@ Override protected boolean check ( File item ) { return item . exists ( ) ; }
public Property Value Editor ( Console Application app , Management Context context ) { this . app = app ; this . context = context ; }
@ Override public void to Data ( Data Output out ) throws IO Exception { out . write Int ( max Inactive Interval ) ; out . write Long ( last Accessed Time ) ; synchronized ( attributes ) { out . write Int ( attributes . size ( ) ) ; for ( Map . Entry < String , Object > entry : attributes . entry Set ( ) ) { Delta Event delta = new Delta Event ( BOOL , entry . get Key ( ) , entry . get Value ( ) ) ; Data Serializer . write Object ( delta , out ) ; } } out . write UTF ( jvm Owner Id ) ; }
public void create Victory Conditions ( ) { victory = vf . create Victory ( STRING ) ; }
public static I Status validate Qualified Module Name ( String qualified Name ) { String pckg = Signature . get Qualifier ( qualified Name ) ; if ( ! Util . is Valid Package Name ( pckg ) ) { return Util . new Error Status ( STRING ) ; } return validate Simple Module Name ( Signature . get Simple Name ( qualified Name ) ) ; }
public static < T1 , T2 > Map < T1 , T2 > synchronized Map ( ) { return Collections . synchronized Map ( new Hash Map < T1 , T2 > ( ) ) ; }
private final int filter Status Bytes ( byte [ ] src , byte [ ] dest , int total Bytes Read , int max Packet Size ) { final int packets Count = total Bytes Read / max Packet Size + ( total Bytes Read % max Packet Size == NUM ? NUM : NUM ) ; for ( int packet Idx = NUM ; packet Idx < packets Count ; ++ packet Idx ) { final int count = ( packet Idx == ( packets Count - NUM ) ) ? ( total Bytes Read % max Packet Size ) - MODEM STATUS HEADER LENGTH : max Packet Size - MODEM STATUS HEADER LENGTH ; if ( count > NUM ) { System . arraycopy ( src , packet Idx * max Packet Size + MODEM STATUS HEADER LENGTH , dest , packet Idx * ( max Packet Size - MODEM STATUS HEADER LENGTH ) , count ) ; } } return total Bytes Read - ( packets Count * NUM ) ; }
public boolean contains ( String key ) { return m Shared Preferences . contains ( key ) ; }
int register Miss ( ) { return misses . increment And Get ( ) ; }
private void update Base Matrix ( Drawable d ) { Image View image View = get Image View ( ) ; if ( null == image View || null == d ) { return ; } final float view Width = image View . get Width ( ) ; final float view Height = image View . get Height ( ) ; final int drawable Width = d . get Intrinsic Width ( ) ; final int drawable Height = d . get Intrinsic Height ( ) ; m Base Matrix . reset ( ) ; final float width Scale = view Width / drawable Width ; final float height Scale = view Height / drawable Height ; if ( m Scale Type == Scale Type . CENTER ) { m Base Matrix . post Translate ( ( view Width - drawable Width ) / NUM , ( view Height - drawable Height ) / NUM ) ; } else if ( m Scale Type == Scale Type . CENTER CROP ) { float scale = Math . max ( width Scale , height Scale ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM , ( view Height - drawable Height * scale ) / NUM ) ; } else if ( m Scale Type == Scale Type . CENTER INSIDE ) { float scale = Math . min ( NUM , Math . min ( width Scale , height Scale ) ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM , ( view Height - drawable Height * scale ) / NUM ) ; } else { Rect F m Temp Src = new Rect F ( NUM , NUM , drawable Width , drawable Height ) ; Rect F m Temp Dst = new Rect F ( NUM , NUM , view Width , view Height ) ; switch ( m Scale Type ) { case FIT CENTER : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . CENTER ) ; break ; case FIT START : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . START ) ; break ; case FIT END : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . END ) ; break ; case FIT XY : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . FILL ) ; break ; default : break ; } } reset Matrix ( ) ; }
public static Char Sequence partial Escape ( Char Sequence s ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; if ( c == STRING || c == STRING || c == STRING || c == STRING || c == STRING || c == STRING || c == STRING || c == STRING || c == STRING || c == STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; } sb . append ( c ) ; } return sb ; }
public void finished ( long work , long latency ) { finished Updater . get And Increment ( this ) ; total Work Updater . get And Add ( this , work ) ; total Work Squared Updater . get And Add ( this , work * work ) ; total Latency Updater . get And Add ( this , latency ) ; total Latency Squared Updater . get And Add ( this , latency * latency ) ; }
public void close ( ) throws IO Exception { if ( m Input Stream != null ) { m Input Stream . close ( ) ; } else { throw new IO Exception ( STRING ) ; } m Input Stream = null ; }
private Windows Security Descriptor ( ) { this . sid List = null ; this . acl Buffer = null ; this . sd Buffer = null ; }
public void print Usage ( Output Stream os ) { int count = NUM ; Print Stream out = UTF 8 . print Stream ( os ) ; for ( String option : option List ) { if ( option Groups . contains Key ( count ) ) { out . println ( STRING + option Groups . get ( count ) ) ; } count ++ ; if ( unlisted Options . contains ( option ) ) { continue ; } out . print ( STRING ) ; String Builder buf = new String Builder ( ) ; buf . append ( option ) ; if ( option Extra Part Synopsis Map . get ( option ) != null ) { String option Extra Part Synopsis = option Extra Part Synopsis Map . get ( option ) ; buf . append ( STRING ) ; buf . append ( option Extra Part Synopsis ) ; buf . append ( STRING ) ; } if ( requires Argument Set . contains ( option ) ) { buf . append ( STRING ) ; buf . append ( argument Description Map . get ( option ) ) ; buf . append ( STRING ) ; } print Field ( out , buf . to String ( ) , max Width + NUM ) ; out . println ( option Description Map . get ( option ) ) ; } out . flush ( ) ; }
public void clear Shared Variables ( ) { shared Variables . clear ( ) ; load Built In Shared Variables ( ) ; }
public void remove ( Video video ) { video List . remove ( video ) ; notify Data Set Changed ( ) ; }
public final void send Packet ( Ls Server Packet bp ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } log . debug ( STRING + bp ) ; send Msg Queue . add Last ( bp ) ; enable Write Interest ( ) ; } }
private static Map < String , Object > process Section ( String section , Collection < Map < String , Object > > hosts , Map < String , Object > dflts , Map < String , Object > props ) throws Ignite Checked Exception { if ( section == null || props == null ) return null ; if ( DFLT SECTION . equals Ignore Case ( section ) ) { if ( dflts != null ) throw new Ignite Checked Exception ( STRING + DFLT SECTION + STRING ) ; return props ; } else { hosts . add ( props ) ; return null ; } }
public boolean is Set ( final OPTION option ) { return options == null ? BOOL : options . contains ( option ) ; }
public void handle Button 1 Request ( Request Invocation Event event ) throws Model Control Exception { List option Data = restore Options Data ( ) ; CC Check Box cb Force Reset Pwd = ( CC Check Box ) get Child ( CB FORCE RESET PWD ) ; boolean force Reset Pwd = cb Force Reset Pwd . is Checked ( ) ; UM User Password Reset Options Model model = ( UM User Password Reset Options Model ) get Model ( ) ; String user Id = ( String ) get Page Session Attribute ( Entity Edit View Bean . UNIVERSAL ID ) ; try { model . modify User Option ( option Data , user Id , force Reset Pwd ) ; set Inline Alert Message ( CC Alert . TYPE INFO , STRING , model . get Localized String ( STRING ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } forward To ( ) ; }
Number Strategy ( final int field ) { this . field = field ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
@ Override public boolean queue Request ( Operation op ) { Authorization Context ctx = op . get Authorization Context ( ) ; if ( ctx == null ) { op . fail ( new Illegal Argument Exception ( STRING ) ) ; return BOOL ; } Claims claims = ctx . get Claims ( ) ; if ( claims == null ) { op . fail ( new Illegal Argument Exception ( STRING ) ) ; return BOOL ; } String subject = claims . get Subject ( ) ; if ( subject == null ) { op . fail ( new Illegal Argument Exception ( STRING ) ) ; return BOOL ; } if ( op . has Pragma Directive ( Operation . PRAGMA DIRECTIVE CLEAR AUTH CACHE ) ) { return handle Cache Clear Request ( op , subject ) ; } if ( subject . equals ( System User Service . SELF LINK ) ) { op . complete ( ) ; return BOOL ; } if ( ctx . get Resource Query Filter ( op . get Action ( ) ) != null ) { op . complete ( ) ; return BOOL ; } return BOOL ; }
public Spannable String Builder ( Char Sequence text ) { this ( text , NUM , text . length ( ) ) ; }
public boolean has Extra Fields ( Pdx Type other ) { for ( Pdx Field ft : this . fields ) { if ( ! ft . is Deleted ( ) && other . get Pdx Field ( ft . get Field Name ( ) ) == null ) { return BOOL ; } } return BOOL ; }
public void put ( String id , String str ) { tab . put ( id , str ) ; if ( str . ends With ( STRING ) ) { int i = str . last Index Of ( File . separator ) ; if ( i >= NUM ) { tab . put ( str . substring ( i + NUM , str . length ( ) - NUM ) , str ) ; } } }
private void assert Read Varint ( byte [ ] data , long value ) throws Exception { Coded Input Stream input = Coded Input Stream . new Instance ( data ) ; assert Equals ( ( int ) value , input . read Raw Varint 32 ( ) ) ; assert Data Consumed ( data , input ) ; input = Coded Input Stream . new Instance ( data ) ; assert Equals ( value , input . read Raw Varint 64 ( ) ) ; assert Data Consumed ( data , input ) ; input = Coded Input Stream . new Instance ( data ) ; assert Equals ( value , input . read Raw Varint 64 Slow Path ( ) ) ; assert Data Consumed ( data , input ) ; input = Coded Input Stream . new Instance ( data ) ; assert True ( input . skip Field ( Wire Format . WIRETYPE VARINT ) ) ; assert Data Consumed ( data , input ) ; for ( int block Size = NUM ; block Size <= NUM ; block Size *= NUM ) { input = Coded Input Stream . new Instance ( new Small Block Input Stream ( data , block Size ) ) ; assert Equals ( ( int ) value , input . read Raw Varint 32 ( ) ) ; assert Data Consumed ( data , input ) ; input = Coded Input Stream . new Instance ( new Small Block Input Stream ( data , block Size ) ) ; assert Equals ( value , input . read Raw Varint 64 ( ) ) ; assert Data Consumed ( data , input ) ; input = Coded Input Stream . new Instance ( new Small Block Input Stream ( data , block Size ) ) ; assert Equals ( value , input . read Raw Varint 64 Slow Path ( ) ) ; assert Data Consumed ( data , input ) ; input = Coded Input Stream . new Instance ( new Small Block Input Stream ( data , block Size ) ) ; assert True ( input . skip Field ( Wire Format . WIRETYPE VARINT ) ) ; assert Data Consumed ( data , input ) ; } byte [ ] longer Data = new byte [ data . length + NUM ] ; System . arraycopy ( data , NUM , longer Data , NUM , data . length ) ; Input Stream raw Input = new Byte Array Input Stream ( longer Data ) ; assert Equals ( ( int ) value , Coded Input Stream . read Raw Varint 32 ( raw Input ) ) ; assert Equals ( NUM , raw Input . available ( ) ) ; }
public void report Occurences ( List < Map < Id < Vehicle > , Integer > > maps ) { for ( int m = NUM ; m < maps . size ( ) ; m ++ ) { Map < Id < Vehicle > , Integer > the Map = maps . get ( m ) ; log . info ( STRING + ( m + NUM ) + STRING + the Map . size ( ) + STRING ) ; Integer min = Integer . MAX VALUE ; Integer max = Integer . MIN VALUE ; for ( Id < Vehicle > id : the Map . key Set ( ) ) { min = Math . min ( min , the Map . get ( id ) ) ; max = Math . max ( max , the Map . get ( id ) ) ; } log . info ( STRING + min + STRING + max ) ; List < Id < Link > > hist List = new Array List < > ( ) ; Map < Id < Link > , Integer > hist Map = new Hash Map < Id < Link > , Integer > ( ) ; for ( long h = min ; h <= max ; h ++ ) { Id < Link > id = Id . create ( h , Link . class ) ; hist List . add ( id ) ; hist Map . put ( id , new Integer ( NUM ) ) ; } for ( Id < Vehicle > id : the Map . key Set ( ) ) { int value = the Map . get ( id ) ; hist Map . put ( Id . create ( value , Link . class ) , new Integer ( hist Map . get ( Id . create ( value , Link . class ) ) + NUM ) ) ; } String s = STRING ; for ( Id < Link > id : hist List ) { s += id . to String ( ) + STRING + hist Map . get ( id ) + STRING ; } log . info ( STRING ) ; log . info ( STRING + s ) ; } }
public static List < URI > ref Ids ( Collection < ? extends Related Resource Rep > refs ) { List < URI > ids = new Array List < URI > ( ) ; if ( refs != null ) { for ( Related Resource Rep ref : refs ) { ids . add ( ref . get Id ( ) ) ; } } return ids ; }
public static boolean has Top Category ( Http Servlet Request request , String category Id , List < String > path Elements ) { if ( Category Worker . is Category Top ( request , category Id ) ) { return BOOL ; } String top Category Id = Category Worker . get Top Category From Trail ( request , path Elements ) ; if ( top Category Id != null ) { return BOOL ; } List < String > trail = Category Worker . get Trail ( request ) ; top Category Id = Category Worker . get Top Category From Trail ( request , trail ) ; if ( top Category Id == null ) { return BOOL ; } return BOOL ; }
@ Override public String append ( String path , Input Stream is ) throws Malformed URL Exception , IO Exception , Authentication Exception { String resp = null ; ensure Valid Token ( ) ; String redirect Url = null ; Http URL Connection conn = authenticated URL . open Connection ( new URL ( new URL ( httpfs Url ) , Message Format . format ( STRING , path ) ) , token ) ; conn . set Request Method ( STRING ) ; conn . set Instance Follow Redirects ( BOOL ) ; conn . connect ( ) ; logger . info ( STRING + conn . get Header Field ( STRING ) ) ; resp = result ( conn , BOOL ) ; if ( conn . get Response Code ( ) == NUM ) redirect Url = conn . get Header Field ( STRING ) ; conn . disconnect ( ) ; if ( redirect Url != null ) { conn = authenticated URL . open Connection ( new URL ( redirect Url ) , token ) ; conn . set Request Method ( STRING ) ; conn . set Do Output ( BOOL ) ; conn . set Do Input ( BOOL ) ; conn . set Use Caches ( BOOL ) ; conn . set Request Property ( STRING , STRING ) ; final int SIZE = is . available ( ) ; conn . set Request Property ( STRING , STRING + SIZE ) ; conn . set Fixed Length Streaming Mode ( SIZE ) ; conn . connect ( ) ; Output Stream os = conn . get Output Stream ( ) ; copy ( is , os ) ; is . close ( ) ; os . close ( ) ; resp = result ( conn , BOOL ) ; conn . disconnect ( ) ; } return resp ; }
public static void cache Imgs ( String skin Img Dir , Iterable < String > base Image UR Ls ) { String skin Dir = get Skin Dir ( ) ; for ( String img : base Image UR Ls ) { img = img . replace ( STRING , skin Dir + STRING ) ; img = img . replace ( STRING , skin Dir + skin Img Dir ) ; Image . prefetch ( img ) ; } }
public static String separators To Unix ( String path ) { if ( path == null || path . index Of ( WINDOWS SEPARATOR ) == - NUM ) { return path ; } return path . replace ( WINDOWS SEPARATOR , UNIX SEPARATOR ) ; }
public void clear Buffer ( ) { buffer . clear ( ) ; }
@ Override public final void perform ( IR ir ) { java . util . Hash Map < Register , Register > new Map = new java . util . Hash Map < Register , Register > ( NUM ) ; for ( Enumeration < Basic Block > be = ir . get Basic Blocks ( ) ; be . has More Elements ( ) ; ) { Basic Block bb = be . next Element ( ) ; for ( Enumeration < Instruction > ie = bb . forward Instr Enumerator ( ) ; ie . has More Elements ( ) ; ) { Instruction s = ie . next Element ( ) ; ; new Map . clear ( ) ; if ( s . is PEI ( ) && s . operator ( ) != IR PROLOGUE ) { if ( bb . has Applicable Exceptional Out ( s ) || ! Register Restrictions . SCRATCH IN PEI ) { split All Live Ranges ( s , new Map , ir , BOOL ) ; } } switch ( s . get Opcode ( ) ) { case MIR LOWTABLESWITCH opcode : { Register Operand r Op = MIR Low Table Switch . get Index ( s ) ; Register Operand temp = find Or Create Temp ( r Op , new Map , ir ) ; insert Move Before ( temp , r Op . copy RO ( ) , s ) ; r Op . set Register ( temp . get Register ( ) ) ; } break ; } } } }
protected void append String ( final String text ) { final HTML Document doc = ( HTML Document ) text Pane . get Document ( ) ; try { final Element root = doc . get Paragraph Element ( NUM ) ; doc . insert Before End ( root , text ) ; } catch ( final Bad Location Exception e ) { logger . error ( e , e ) ; } catch ( final IO Exception e ) { logger . error ( e , e ) ; } }
public void scale To Samples ( int usr Samples ) { double ratio ; ratio = ( double ) usr Samples / count ; count = NUM ; for ( int i = NUM ; i <= limits . length ; ++ i ) { results [ i ] = ( int ) Math . round ( results [ i ] * ratio ) ; count += results [ i ] ; } }
private void refresh Selected ( int offset X ) { int offset = ( int ) ( offset X + m Max Over Scroll Distance ) ; int temp Index = Math . round ( offset / m Interval Dis ) ; temp Index = clamp Selected Index ( temp Index ) ; if ( m Selected Index == temp Index ) { return ; } m Selected Index = temp Index ; if ( null != on Value Change Listener ) { on Value Change Listener . on Change ( this , m Selected Index , Float . parse Float ( format ( m Selected Index * m Interval Value + m Min Value ) ) ) ; } }
@ Override @ Suppress Warnings ( STRING ) public void reset Frame ( ) { synchronized ( lock ) { sys Name . set Text ( STRING + counter ++ ) ; } user Name . set Text ( null ) ; url . set Text ( null ) ; stream . set Selected ( BOOL ) ; stream . set Enabled ( BOOL ) ; loop Start . set Value ( Long . value Of ( NUM ) ) ; loop End . set Value ( Long . value Of ( NUM ) ) ; this . new Buffer = BOOL ; }
public Expected Records < T > repeat All ( int times ) { List < T > to Append = new Array List < > ( ) ; for ( int i = NUM ; i < times ; i ++ ) { to Append . add All ( expected Records ) ; } expected Records . add All ( to Append ) ; return this ; }
public void add Attributes ( Attributes atts ) throws SAX Exception { int n Atts = atts . get Length ( ) ; for ( int i = NUM ; i < n Atts ; i ++ ) { String uri = atts . get URI ( i ) ; if ( null == uri ) uri = STRING ; add Attribute Always ( uri , atts . get Local Name ( i ) , atts . get Q Name ( i ) , atts . get Type ( i ) , atts . get Value ( i ) , BOOL ) ; } }
protected static Geo Point parse Kml Coord ( String input ) { int end 1 = input . index Of ( STRING ) ; int end 2 = input . index Of ( STRING , end 1 + NUM ) ; try { if ( end 2 == - NUM ) { double lon = Double . parse Double ( input . substring ( NUM , end 1 ) ) ; double lat = Double . parse Double ( input . substring ( end 1 + NUM , input . length ( ) ) ) ; return new Geo Point ( lat , lon ) ; } else { double lon = Double . parse Double ( input . substring ( NUM , end 1 ) ) ; double lat = Double . parse Double ( input . substring ( end 1 + NUM , end 2 ) ) ; double alt = Double . parse Double ( input . substring ( end 2 + NUM , input . length ( ) ) ) ; return new Geo Point ( lat , lon , alt ) ; } } catch ( Number Format Exception e ) { return null ; } catch ( Index Out Of Bounds Exception e ) { return null ; } }
@ Nullable public Calendar detect Date ( String input ) { check Not Null ( input ) ; Time . set Time Zone ( get Time Zone ( ) ) ; Options opt = new com . sk 89 q . jchronic . Options ( ) ; opt . set Now ( Calendar . get Instance ( get Time Zone ( ) ) ) ; Span date = Chronic . parse ( input , opt ) ; if ( date == null ) { return null ; } else { return date . get Begin Calendar ( ) ; } }
public synchronized void save Commit Point ( Long index Commit Gen ) { Atomic Integer reserve Count = saved Commits . get ( index Commit Gen ) ; if ( reserve Count == null ) reserve Count = new Atomic Integer ( ) ; reserve Count . increment And Get ( ) ; saved Commits . put ( index Commit Gen , reserve Count ) ; }
public void remove Searchable ( Search Result searchable ) { if ( searchables . contains ( searchable ) ) searchables . remove ( search ) ; }
public static boolean is 64 bit ( ) { boolean is 64 bit = BOOL ; if ( is Windows ( ) ) { is 64 bit = ( System . getenv ( STRING ) != null ) ; } else { is 64 bit = ( OS ARCH . contains ( STRING ) ) ; } return is 64 bit ; }
private int resolve Size And State Respecting Min Size ( int min Size , int measured Size , int measure Spec ) { if ( min Size != SIZE UNSPECIFIED ) { final int desired Width = Math . max ( min Size , measured Size ) ; return resolve Size And State ( desired Width , measure Spec , NUM ) ; } else { return measured Size ; } }
@ Override public void on Song Update ( Provider Identifier provider , final Song s ) throws Remote Exception { if ( s == null ) { Log . w ( TAG , STRING + provider . m Name + STRING ) ; return ; } try { Song cached = m Cache . get Song ( s . get Ref ( ) ) ; boolean was Loaded = BOOL ; boolean changed = BOOL ; if ( cached == null ) { m Cache . put Song ( provider , s ) ; changed = BOOL ; cached = s ; } else { was Loaded = cached . is Loaded ( ) ; if ( s . is Loaded ( ) && ! cached . is Identical ( s ) ) { cached . set Album ( s . get Album ( ) ) ; cached . set Artist ( s . get Artist ( ) ) ; cached . set Source Logo ( s . get Logo ( ) ) ; cached . set Duration ( s . get Duration ( ) ) ; cached . set Title ( s . get Title ( ) ) ; cached . set Year ( s . get Year ( ) ) ; cached . set Offline Status ( s . get Offline Status ( ) ) ; cached . set Available ( s . is Available ( ) ) ; cached . set Is Loaded ( s . is Loaded ( ) ) ; changed = BOOL ; } } if ( ! was Loaded && cached . is Loaded ( ) ) { Artist artist = m Cache . get Artist ( s . get Artist ( ) ) ; if ( artist == null && s . get Artist ( ) != null ) { artist = retrieve Artist ( s . get Artist ( ) , provider ) ; } if ( artist != null ) { Album album = m Cache . get Album ( s . get Album ( ) ) ; if ( album == null && s . get Album ( ) != null ) { album = retrieve Album ( s . get Album ( ) , provider ) ; } if ( album != null ) { artist . add Album ( album . get Ref ( ) ) ; } } } if ( changed ) { post Song For Update ( cached ) ; } } catch ( Exception e ) { Log . e ( TAG , STRING , e ) ; } }
public static boolean delete Directory And Contents ( File root Directory ) { if ( ( root Directory == null ) || ! root Directory . is Directory ( ) ) { return BOOL ; } try { String [ ] directory Contents = root Directory . list ( ) ; for ( int i = NUM ; i < directory Contents . length ; i ++ ) { boolean success = delete Directory And Contents ( new File ( root Directory , directory Contents [ i ] ) ) ; if ( ! success ) { return BOOL ; } } return root Directory . delete ( ) ; } catch ( Exception e ) { logger . debug ( e . to String ( ) + System . line Separator ( ) + Stack Trace . get String From Stack Trace ( e ) ) ; return BOOL ; } }
public static void nanosleep ( long nanos ) throws Interrupted Exception { if ( Thread . interrupted ( ) ) throw new Interrupted Exception ( ) ; if ( nanos <= NUM ) { return ; } if ( nanos >= NUM ) { Thread . sleep ( nanos / NUM , ( int ) ( nanos % NUM ) ) ; } else { if ( pure Mode ) { Thread . yield ( ) ; } else { nanosleep ( ( int ) nanos ) ; } } }
@ Override public boolean connection Allowed ( Event Set Descriptor esd ) { return connection Allowed ( esd . get Name ( ) ) ; }
int pure Length ( ) { return length - delimiter . length ( ) ; }
protected void draw Arrow ( Graphics g , int x1 , int y1 , int x2 , int y2 ) { if ( x1 == x2 ) { if ( y1 < y2 ) { g . draw Line ( x2 , y2 , x2 + NUM , y2 - NUM ) ; g . draw Line ( x2 , y2 , x2 - NUM , y2 - NUM ) ; } else { g . draw Line ( x2 , y2 , x2 + NUM , y2 + NUM ) ; g . draw Line ( x2 , y2 , x2 - NUM , y2 + NUM ) ; } } else { double hyp = NUM , base = NUM , perp = NUM , theta , beta ; int x3 = NUM , y3 = NUM ; if ( x2 < x1 ) { base = x1 - x2 ; hyp = Math . sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) ; theta = Math . acos ( base / hyp ) ; } else { base = x1 - x2 ; hyp = Math . sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) ; theta = Math . acos ( base / hyp ) ; } beta = NUM * Math . PI / NUM ; hyp = NUM ; base = Math . cos ( theta - beta ) * hyp ; perp = Math . sin ( theta - beta ) * hyp ; x3 = ( int ) ( x2 + base ) ; if ( y1 < y2 ) { y3 = ( int ) ( y2 - perp ) ; } else { y3 = ( int ) ( y2 + perp ) ; } g . draw Line ( x2 , y2 , x3 , y3 ) ; base = Math . cos ( theta + beta ) * hyp ; perp = Math . sin ( theta + beta ) * hyp ; x3 = ( int ) ( x2 + base ) ; if ( y1 < y2 ) { y3 = ( int ) ( y2 - perp ) ; } else { y3 = ( int ) ( y2 + perp ) ; } g . draw Line ( x2 , y2 , x3 , y3 ) ; } }
private void add Elements ( int value , int number Of Elements ) { if ( m first Free + number Of Elements < m blocksize ) for ( int i = NUM ; i < number Of Elements ; i ++ ) { m map 0 [ m first Free ++ ] = value ; } else { int index = m first Free > > > m SHIFT ; int offset = m first Free & m MASK ; m first Free += number Of Elements ; while ( number Of Elements > NUM ) { if ( index >= m map . length ) { int newsize = index + m numblocks ; int [ ] [ ] new Map = new int [ newsize ] [ ] ; System . arraycopy ( m map , NUM , new Map , NUM , m map . length ) ; m map = new Map ; } int [ ] block = m map [ index ] ; if ( null == block ) block = m map [ index ] = new int [ m blocksize ] ; int copied = ( m blocksize - offset < number Of Elements ) ? m blocksize - offset : number Of Elements ; number Of Elements -= copied ; while ( copied -- > NUM ) block [ offset ++ ] = value ; ++ index ; offset = NUM ; } } }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
public static String Builder format To ( String Builder buf , double [ ] d , String sep ) { if ( d == null ) { return buf . append ( STRING ) ; } if ( d . length == NUM ) { return buf ; } buf . append ( d [ NUM ] ) ; for ( int i = NUM ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( d [ i ] ) ; } return buf ; }
@ Suppress Warnings ( STRING ) private static void merge Sort ( Object [ ] in , Object [ ] out , int start , int end , Comparator c ) { int len = end - start ; if ( len <= SIMPLE LENGTH ) { for ( int i = start + NUM ; i < end ; i ++ ) { Object current = out [ i ] ; Object prev = out [ i - NUM ] ; if ( c . compare ( prev , current ) > NUM ) { int j = i ; do { out [ j -- ] = prev ; } while ( j > start && ( c . compare ( prev = out [ j - NUM ] , current ) > NUM ) ) ; out [ j ] = current ; } } return ; } int med = ( end + start ) > > > NUM ; merge Sort ( out , in , start , med , c ) ; merge Sort ( out , in , med , end , c ) ; if ( c . compare ( in [ med - NUM ] , in [ med ] ) <= NUM ) { System . arraycopy ( in , start , out , start , len ) ; return ; } int r = med , i = start ; do { Object from Val = in [ start ] ; Object r Val = in [ r ] ; if ( c . compare ( from Val , r Val ) <= NUM ) { int l 1 = find ( in , r Val , - NUM , start + NUM , med - NUM , c ) ; int to Copy = l 1 - start + NUM ; System . arraycopy ( in , start , out , i , to Copy ) ; i += to Copy ; out [ i ++ ] = r Val ; r ++ ; start = l 1 + NUM ; } else { int r 1 = find ( in , from Val , NUM , r + NUM , end - NUM , c ) ; int to Copy = r 1 - r + NUM ; System . arraycopy ( in , r , out , i , to Copy ) ; i += to Copy ; out [ i ++ ] = from Val ; start ++ ; r = r 1 + NUM ; } } while ( ( end - r ) > NUM && ( med - start ) > NUM ) ; if ( ( end - r ) <= NUM ) { System . arraycopy ( in , start , out , i , med - start ) ; } else { System . arraycopy ( in , r , out , i , end - r ) ; } }
private View fill From Left ( int next Left ) { m First Position = Math . min ( m First Position , m Selected Position ) ; m First Position = Math . min ( m First Position , m Item Count - NUM ) ; if ( m First Position < NUM ) { m First Position = NUM ; } return fill Right ( m First Position , next Left ) ; }
public Tomcat Slf 4 j Logback Factory Accessor ( Class Loader cl ) throws Class Not Found Exception , Illegal Access Exception , Illegal Argument Exception , Invocation Target Exception { Class clazz = cl . load Class ( STRING ) ; Method get Singleton = Method Utils . get Accessible Method ( clazz , STRING , new Class [ NUM ] ) ; Object singleton = get Singleton . invoke ( null ) ; Method get Logger Factory = Method Utils . get Accessible Method ( clazz , STRING , new Class [ NUM ] ) ; Object logger Factory = get Logger Factory . invoke ( singleton ) ; Class logger Factory Class = cl . load Class ( STRING ) ; if ( ! logger Factory Class . is Instance ( logger Factory ) ) { throw new Runtime Exception ( STRING ) ; } set Target ( logger Factory ) ; }
public Quarter Date Format ( Time Zone zone , String [ ] quarter Symbols , boolean quarter First ) { Param Checks . null Not Permitted ( zone , STRING ) ; this . calendar = new Gregorian Calendar ( zone ) ; this . quarters = quarter Symbols ; this . quarter First = quarter First ; this . number Format = Number Format . get Number Instance ( ) ; }
public long restart ( ) { long start = start Time Nanos ; start Time Nanos = System . nano Time ( ) ; return start Time Nanos - start ; }
private static byte [ ] string To Byte Array ( String str ) { byte [ ] result = new byte [ str . length ( ) + NUM ] ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) { result [ i ] = ( byte ) str . char At ( i ) ; } result [ str . length ( ) ] = NUM ; return result ; }
@ Override public void action Performed ( Action Event e ) { Object o ; o = e . get Source ( ) ; if ( o == menu File Open ) { load File ( ) ; } else if ( o == menu File Save ) { save File ( ) ; } else if ( o == menu File Save As ) { save File As ( ) ; } else if ( o == menu File Close ) { close File ( ) ; } else if ( o == menu File Close All ) { close All Files ( ) ; } else if ( o == menu File Properties ) { show Properties ( ) ; } else if ( o == menu File Exit ) { close ( ) ; } else if ( o == menu Edit Undo ) { undo ( ) ; } else if ( o == menu Edit Copy ) { copy Content ( ) ; } else if ( o == menu Edit Search ) { search ( ) ; } else if ( o == menu Edit Clear Search ) { clear Search ( ) ; } else if ( o == menu Edit Delete Attribute ) { delete Attribute ( BOOL ) ; } else if ( o == menu Edit Delete Attributes ) { delete Attribute ( BOOL ) ; } else if ( o == menu Edit Rename Attribute ) { rename Attribute ( ) ; } else if ( o == menu Edit Attribute As Class ) { attribute As Class ( ) ; } else if ( o == menu Edit Delete Instance ) { delete Instance ( BOOL ) ; } else if ( o == menu Edit Delete Instances ) { delete Instance ( BOOL ) ; } else if ( o == menu Edit Sort Instances ) { sort Instances ( ) ; } else if ( o == menu View Attributes ) { show Attributes ( ) ; } else if ( o == menu View Values ) { show Values ( ) ; } else if ( o == menu View Optimal Col Widths ) { set Optimal Col Widths ( ) ; } update Menu ( ) ; }
public static boolean has Joda ( ) { try { Class . for Name ( STRING ) ; return BOOL ; } catch ( Class Not Found Exception e ) { return BOOL ; } }
public Remote Service Descriptor ( String base Url , Http Json Request Factory request Factory ) throws Illegal Argument Exception { this . base Url = base Url ; try { base Url URL = new URL ( base Url ) ; final String protocol = base Url URL . get Protocol ( ) ; if ( ! ( protocol . equals ( STRING ) || protocol . equals ( STRING ) ) ) { throw new Illegal Argument Exception ( String . format ( STRING , base Url ) ) ; } } catch ( Malformed URL Exception e ) { throw new Illegal Argument Exception ( String . format ( STRING , base Url ) ) ; } this . request Factory = request Factory ; }
private int find Activity Element ( int activity Index ) { for ( int element Index = NUM ; element Index < m Activity List . size ( ) ; element Index ++ ) { if ( m Activity List . get ( element Index ) . m Activity Index == activity Index ) { return element Index ; } } return - NUM ; }
void add Fill Components ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM , NUM ) ; boolean filled cell 11 = BOOL ; Cell Constraints cc = new Cell Constraints ( ) ; if ( cols . length > NUM && rows . length > NUM ) { if ( cols [ NUM ] == NUM && rows [ NUM ] == NUM ) { panel . add ( Box . create Rigid Area ( filler ) , cc . xy ( NUM , NUM ) ) ; filled cell 11 = BOOL ; } } for ( int index = NUM ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM && filled cell 11 ) { continue ; } panel . add ( Box . create Rigid Area ( filler ) , cc . xy ( cols [ index ] , NUM ) ) ; } for ( int index = NUM ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM && filled cell 11 ) { continue ; } panel . add ( Box . create Rigid Area ( filler ) , cc . xy ( NUM , rows [ index ] ) ) ; } }
public void map Volume To SDC ( String volume Id , String sdc Id ) throws Exception { log . info ( STRING ) ; String uri = Scale IO Constants . get Map Volume To SDCURI ( volume Id ) ; Scale IO Map Volume To SDC map Parm = new Scale IO Map Volume To SDC ( ) ; map Parm . set Sdc Id ( sdc Id ) ; map Parm . set Allow Multiple Mappings ( STRING ) ; post ( URI . create ( uri ) , get Json For Entity ( map Parm ) ) ; }
public void add Obscured Recipient ( String player Name ) { obscured Recipients . add Element ( player Name ) ; }
private static void replace Collapsed By Eclipse Source Roots ( Element lib Element , Library . Modifiable Model modifiable Model ) { String [ ] src Urls From Classpath = modifiable Model . get Urls ( Order Root Type . SOURCES ) ; LOG . assert True ( src Urls From Classpath . length <= NUM ) ; final String eclipse Url = src Urls From Classpath . length > NUM ? src Urls From Classpath [ NUM ] : null ; for ( Element r : lib Element . get Children ( SRCROOT ATTR ) ) { final String url = r . get Attribute Value ( STRING ) ; final String bind Attr = r . get Attribute Value ( SRCROOT BIND ATTR ) ; boolean not Bind = bind Attr != null && ! Boolean . parse Boolean ( bind Attr ) ; if ( not Bind ) { modifiable Model . add Root ( url , Order Root Type . SOURCES ) ; } else if ( eclipse Url != null && are Urls Point The Same ( url , eclipse Url ) && ! Comparing . str Equal ( url , eclipse Url ) ) { modifiable Model . add Root ( url , Order Root Type . SOURCES ) ; if ( src Urls From Classpath != null && src Urls From Classpath . length == NUM ) { modifiable Model . remove Root ( eclipse Url , Order Root Type . SOURCES ) ; src Urls From Classpath = null ; } } } }
public static byte [ ] hex To Bytes ( String hex String ) { byte [ ] result = new byte [ hex String . length ( ) / NUM ] ; for ( int i = NUM ; i < result . length ; ++ i ) { int offset = i * NUM ; result [ i ] = ( byte ) Integer . parse Int ( hex String . substring ( offset , offset + NUM ) , NUM ) ; } return result ; }
public void test Set Bit Negative Outside 1 ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = - NUM ; int number = NUM ; byte r Bytes [ ] = { - NUM , NUM , - NUM , - NUM , NUM , NUM , - NUM , - NUM , - NUM , - NUM , NUM , - NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . set Bit ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , result . signum ( ) ) ; }
private static String replace Last ( String str , char from , char to ) { int index = str . last Index Of ( from ) ; if ( index == - NUM ) return str ; return str . substring ( NUM , index ) + to + str . substring ( index + NUM ) ; }
public static String value Of ( long value ) { return Long . to String ( value ) ; }
private static void clean Stale Initiator References ( Export Group export Group , Db Client db Client ) { String Set export Group Initiators = export Group . get Initiators ( ) ; if ( ! Collection Utils . is Empty ( export Group Initiators ) && ! Collection Utils . is Empty ( export Group . get Export Masks ( ) ) ) { Set < String > all Mask Initiators = new Hash Set < > ( ) ; for ( String mask : export Group . get Export Masks ( ) ) { Export Mask mask Obj = db Client . query Object ( Export Mask . class , URI . create ( mask ) ) ; if ( mask Obj != null && ! Collection Utils . is Empty ( mask Obj . get Initiators ( ) ) ) { all Mask Initiators . add All ( mask Obj . get Initiators ( ) ) ; } } Set < String > stale Initiators = Sets . difference ( export Group Initiators , all Mask Initiators ) ; if ( ! Collection Utils . is Empty ( stale Initiators ) ) { Collection < URI > stale Initiator URIS = Collections 2 . transform ( stale Initiators , Common Transformer Functions . FCTN STRING TO URI ) ; export Group . remove Initiators ( new Array List < > ( stale Initiator URIS ) ) ; log . info ( STRING , stale Initiator URIS , export Group . get Id ( ) ) ; } } }
public static < T > T find Resource By Name ( Iterable < Has Metadata > entities , Class < T > clazz , String name ) { if ( entities != null ) { for ( Has Metadata entity : entities ) { if ( clazz . is Instance ( entity ) && Objects . equals ( name , get Name ( entity ) ) ) { return clazz . cast ( entity ) ; } } } return null ; }
public static Map ordinal Map ( Iterator tuples , String field , Comparator cmp ) { Object [ ] o = ordinal Array ( tuples , field , cmp ) ; Hash Map map = new Hash Map ( ) ; for ( int i = NUM ; i < o . length ; ++ i ) map . put ( o [ i ] , new Integer ( i ) ) ; return map ; }
void add Line Monitor ( Line Monitor lm ) { if ( Printer . trace ) Printer . trace ( STRING + lm + STRING ) ; synchronized ( line Monitors ) { if ( line Monitors . index Of ( lm ) >= NUM ) { if ( Printer . trace ) Printer . trace ( STRING ) ; return ; } if ( Printer . debug ) Printer . debug ( STRING + lm ) ; line Monitors . add ( lm ) ; } synchronized ( this ) { notify All ( ) ; } if ( Printer . debug ) Printer . debug ( STRING + line Monitors . size ( ) + STRING ) ; }
public static String to Char ( byte b ) { if ( b >= NUM ) { return Character . to String ( ( char ) b ) ; } else { return String . format ( STRING , b ) ; } }
public void add Nodes ( Node Iterator iterator ) { if ( ! m mutable ) throw new Runtime Exception ( XSL Messages . create XPATH Message ( XPATH Error Resources . ER NODESET NOT MUTABLE , null ) ) ; if ( null != iterator ) { Node obj ; while ( null != ( obj = iterator . next Node ( ) ) ) { add Element ( obj ) ; } } }
public static double pt Seg Dist ( double x1 , double y1 , double x2 , double y2 , double px , double py ) { return Math . sqrt ( pt Seg Dist Sq ( x1 , y1 , x2 , y2 , px , py ) ) ; }
Method Type as Spreader Type ( Class < ? > array Type , int array Length ) { assert ( parameter Count ( ) >= array Length ) ; int spread Pos = ptypes . length - array Length ; if ( array Length == NUM ) return this ; if ( array Type == Object [ ] . class ) { if ( is Generic ( ) ) return this ; if ( spread Pos == NUM ) { Method Type res = generic Method Type ( array Length ) ; if ( rtype != Object . class ) { res = res . change Return Type ( rtype ) ; } return res ; } } Class < ? > elem Type = array Type . get Component Type ( ) ; assert ( elem Type != null ) ; for ( int i = spread Pos ; i < ptypes . length ; i ++ ) { if ( ptypes [ i ] != elem Type ) { Class < ? > [ ] fixed Ptypes = ptypes . clone ( ) ; Arrays . fill ( fixed Ptypes , i , ptypes . length , elem Type ) ; return method Type ( rtype , fixed Ptypes ) ; } } return this ; }
public void put ( E e ) throws Interrupted Exception { if ( e == null ) throw new Null Pointer Exception ( ) ; int c = - NUM ; Node < E > node = new Node < E > ( e ) ; final Reentrant Lock put Lock = this . put Lock ; final Atomic Integer count = this . count ; put Lock . lock Interruptibly ( ) ; try { while ( count . get ( ) == capacity ) { not Full . await ( ) ; } enqueue ( node ) ; c = count . get And Increment ( ) ; if ( c + NUM < capacity ) not Full . signal ( ) ; } finally { put Lock . unlock ( ) ; } if ( c == NUM ) signal Not Empty ( ) ; }
public static mx I Cell resolve ( mx I Cell root , String path ) { mx I Cell parent = root ; String [ ] tokens = path . split ( Pattern . quote ( PATH SEPARATOR ) ) ; for ( int i = NUM ; i < tokens . length ; i ++ ) { parent = parent . get Child At ( Integer . parse Int ( tokens [ i ] ) ) ; } return parent ; }
private static int next Non Quote Index ( String trimmed , int i , boolean forward ) { while ( trimmed . char At ( i ) == STRING || trimmed . char At ( i ) == STRING || trimmed . char At ( i ) == STRING || trimmed . char At ( i ) == STRING || trimmed . char At ( i ) == STRING || trimmed . char At ( i ) == STRING || trimmed . char At ( i ) == STRING || trimmed . char At ( i ) == STRING ) { if ( forward ) i ++ ; else i -- ; } return i ; }
public static void reset ( ) { trace State . remove ( ) ; suspended State . clear ( ) ; }
private String inclusive Slice ( ) { if ( mark >= pos ) { return STRING ; } return sign . substring ( mark , pos + NUM ) ; }
public byte [ ] to Bytecode ( ) throws IO Exception , Cannot Compile Exception { Byte Array Output Stream barray = new Byte Array Output Stream ( ) ; Data Output Stream out = new Data Output Stream ( barray ) ; try { to Bytecode ( out ) ; } finally { out . close ( ) ; } return barray . to Byte Array ( ) ; }
public static void serialize Path ( final Object Output os , final Path Iterator pi ) throws IO Exception { os . write Object ( pi . get Winding Rule ( ) ) ; final List < java . io . Serializable > list = new Array List < java . io . Serializable > ( ) ; while ( ! pi . is Done ( ) ) { final float [ ] array = new float [ NUM ] ; final int type = pi . current Segment ( array ) ; list . add ( type ) ; list . add ( array ) ; pi . next ( ) ; } os . write Object ( list ) ; }
public double calculate Local Swap Total Capacity ( int hostcount , int hostlocalswapsize ) { double d = ( double ) ( hostcount * hostlocalswapsize ) / NUM ; d *= - NUM ; d = ( double ) Math . round ( d * NUM ) / NUM ; return d ; }
boolean find Marker ( ) throws IO Exception { if ( marker Index == marker . length ) { return BOOL ; } if ( log . is Debug Enabled ( ) ) log . debug ( STRING + Bytes Util . to Hex String ( marker ) + STRING + nreads ) ; while ( marker Index < marker . length ) { final int remtok = marker . length - marker Index ; marker BB . limit ( remtok ) ; marker BB . position ( NUM ) ; final int rd Len = client . read ( marker BB ) ; if ( rd Len == - NUM ) { throw new IO Exception ( STRING + nreads + STRING + bytes Read ) ; } nreads ++ ; bytes Read += rd Len ; for ( int i = NUM ; i < rd Len ; i ++ ) { if ( marker Buffer [ i ] != marker [ marker Index ] ) { if ( found Marker In Initial Position ) { found Marker In Initial Position = BOOL ; log . error ( STRING ) ; } marker Index = NUM ; if ( marker Buffer [ i ] == marker [ marker Index ] ) { marker Index ++ ; } } else { marker Index ++ ; nmarkerbytematches ++ ; } } if ( nreads % NUM == NUM ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + nreads + STRING + bytes Read ) ; } } if ( marker Index != marker . length ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING ) ; return BOOL ; } else { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + nreads + STRING + nmarkerbytematches + STRING ) ; return BOOL ; } }
public void parse Loggc File ( Input Stream loggc File Stream , Default Mutable Tree Node root ) { Buffered Reader bis = new Buffered Reader ( new Input Stream Reader ( loggc File Stream ) ) ; Vector histograms = new Vector ( ) ; try { while ( bis . ready ( ) ) { bis . mark ( get Mark Size ( ) ) ; String next Line = bis . read Line ( ) ; if ( next Line . starts With ( STRING ) ) { bis . reset ( ) ; histograms . add ( parse Next Class Histogram ( bis ) ) ; } } for ( int i = histograms . size ( ) - NUM ; i >= NUM ; i -- ) { Default Mutable Tree Node dump = get Next Dump For Histogram ( root ) ; if ( dump != null ) { add Histogram To Dump ( dump , ( Histogram Table Model ) histograms . get ( i ) ) ; } } } catch ( IO Exception ex ) { ex . print Stack Trace ( ) ; } }
private void resolve Time Macro ( String Buffer result ) { Calendar calendar = new Gregorian Calendar ( ) ; result . append ( calendar . get ( Calendar . YEAR ) + STRING ) ; String month = calendar . get ( Calendar . MONTH ) + NUM + STRING ; if ( month . length ( ) < NUM ) { month = STRING + month ; } result . append ( month + STRING ) ; String day = calendar . get ( Calendar . DAY OF MONTH ) + STRING ; if ( day . length ( ) < NUM ) { day = STRING + day ; } result . append ( day + STRING ) ; int am Pm = calendar . get ( Calendar . AM PM ) ; String am Pm String = am Pm == Calendar . AM ? STRING : STRING ; result . append ( am Pm String + STRING ) ; String hour = calendar . get ( Calendar . HOUR ) + STRING ; if ( hour . length ( ) < NUM ) { hour = STRING + hour ; } result . append ( hour + STRING ) ; String minute = calendar . get ( Calendar . MINUTE ) + STRING ; if ( minute . length ( ) < NUM ) { minute = STRING + minute ; } result . append ( minute + STRING ) ; String second = calendar . get ( Calendar . SECOND ) + STRING ; if ( second . length ( ) < NUM ) { second = STRING + second ; } result . append ( second ) ; }
public boolean is Empty ( ) { synchronized ( lock ) { return annotations Draw Order . is Empty ( ) ; } }
default B append 8 bit ( @ Not Null Char Sequence cs , int start , int end ) throws Illegal Argument Exception , Buffer Overflow Exception , Buffer Underflow Exception , Index Out Of Bounds Exception { if ( cs instanceof Bytes Store ) { return write ( ( Bytes Store ) cs , ( long ) start , end ) ; } for ( int i = start ; i < end ; i ++ ) { char c = cs . char At ( i ) ; if ( c > NUM ) c = STRING ; write Byte ( ( byte ) c ) ; } return ( B ) this ; }
static void zero ( float [ ] [ ] array ) { for ( float [ ] a Float : array ) { Arrays . fill ( a Float , - NUM ) ; } }
@ Override public boolean contains ( Point 2 D . Double p ) { Round Rectangle 2 D . Double r = ( Round Rectangle 2 D . Double ) roundrect . clone ( ) ; double grow = Attribute Keys . get Perpendicular Hit Growth ( this ) ; r . x -= grow ; r . y -= grow ; r . width += grow * NUM ; r . height += grow * NUM ; r . arcwidth += grow * NUM ; r . archeight += grow * NUM ; return r . contains ( p ) ; }
private void download Update Prop ( final boolean initial Download ) { if ( boot Prop != null ) { server Folder = boot Prop . get Property ( STRING , Client Game Configuration . get ( STRING ) ) + STRING ; String update Properties File = boot Prop . get Property ( STRING , server Folder + STRING ) ; final Http Client http Client = new Http Client ( update Properties File , initial Download ) ; update Prop = http Client . fetch Properties ( ) ; if ( update Prop != null && update Prop . contains Key ( STRING ) ) { return ; } } String update Properties File = Client Game Configuration . get ( STRING ) + STRING ; Http Client http Client = new Http Client ( update Properties File , initial Download ) ; update Prop = http Client . fetch Properties ( ) ; if ( update Prop != null && update Prop . contains Key ( STRING ) ) { return ; } update Properties File = Client Game Configuration . get ( STRING ) + STRING ; http Client = new Http Client ( update Properties File , initial Download ) ; update Prop = http Client . fetch Properties ( ) ; }
private void merge Method Handle Store ( final int index , final Method Handle method Handle ) { local Variables . merge ( index , new Method Handle ( method Handle ) , null ) ; }
public final int read ( byte ba [ ] , int off , int len ) throws IO Exception { return is . read ( ba , off , len ) ; }
public Context Suggest Field ( String name , String value , int weight , Char Sequence ... contexts ) { super ( name , value , weight ) ; validate ( value ) ; this . contexts = new Hash Set < > ( ( contexts != null ) ? contexts . length : NUM ) ; if ( contexts != null ) { Collections . add All ( this . contexts , contexts ) ; } }
@ Override protected byte [ ] decrypt ( byte type , byte [ ] fragment , int offset , int len ) { byte [ ] data = dec Cipher . update ( fragment , offset , len ) ; byte [ ] content ; if ( block size != NUM ) { int padding length = data [ data . length - NUM ] & NUM ; for ( int i = NUM ; i < padding length ; i ++ ) { if ( ( data [ data . length - NUM - i ] & NUM ) != padding length ) { throw new Alert Exception ( Alert Protocol . DECRYPTION FAILED , new SSL Protocol Exception ( STRING ) ) ; } } content = new byte [ data . length - hash size - padding length - NUM ] ; } else { content = new byte [ data . length - hash size ] ; } byte [ ] mac value ; mac material part [ NUM ] = type ; mac material part [ NUM ] = ( byte ) ( ( NUM & content . length ) > > NUM ) ; mac material part [ NUM ] = ( byte ) ( NUM & content . length ) ; message Digest . update ( mac read secret ) ; message Digest . update ( pad 1 ) ; message Digest . update ( read seq num ) ; message Digest . update ( mac material part ) ; message Digest . update ( data , NUM , content . length ) ; mac value = message Digest . digest ( ) ; message Digest . update ( mac read secret ) ; message Digest . update ( pad 2 ) ; message Digest . update ( mac value ) ; mac value = message Digest . digest ( ) ; if ( logger != null ) { logger . println ( STRING ) ; logger . print ( data ) ; logger . println ( STRING ) ; logger . print ( mac value ) ; } for ( int i = NUM ; i < hash size ; i ++ ) { if ( mac value [ i ] != data [ i + content . length ] ) { throw new Alert Exception ( Alert Protocol . BAD RECORD MAC , new SSL Protocol Exception ( STRING ) ) ; } } System . arraycopy ( data , NUM , content , NUM , content . length ) ; inc Sequence Number ( read seq num ) ; return content ; }
public Activity put ( String key , Activity activity ) { return ( Activity ) m map . put ( key , activity ) ; }
public boolean is Abstract ( ) { return Modifier . is Abstract ( get Access Flags ( ) ) ; }
private boolean journal Rebuild Required ( ) { final int redundant Op Compact Threshold = NUM ; return redundant Op Count >= redundant Op Compact Threshold && redundant Op Count >= lru Entries . size ( ) ; }
public void clear Current Request Timed Out ( ) { if ( current Request Timed Out != null ) current Request Timed Out . clear ( ) ; current Request Timed Out = null ; }
protected void show Page ( int page ) { boolean is Empty = page == PAGE EMPTY ; Control control = is Empty ? ( Control ) f Empty Page Label : get Control ( ) ; if ( is Empty ) { set Content Description ( STRING ) ; clear Viewer ( ) ; } f Pagebook . show Page ( control ) ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) return BOOL ; if ( o == null || get Class ( ) != o . get Class ( ) ) return BOOL ; Insets insets = ( Insets ) o ; if ( bottom != insets . bottom ) return BOOL ; if ( left != insets . left ) return BOOL ; if ( right != insets . right ) return BOOL ; if ( top != insets . top ) return BOOL ; return BOOL ; }
public void remove Documents ( List < Query > queries ) { Index Writer writer = get Writer ( ) ; for ( Query query : queries ) { try { writer . delete Documents ( query ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; close Writer ( writer ) ; throw new Runtime Exception ( e ) ; } } close Writer ( writer ) ; }
protected String to String ( Object parameter ) { if ( parameter == null ) { return NULL STR ; } try { String result = Misc . get As String ( parameter ) ; if ( result . length ( ) > DEFAULT ARG STRING MAX LENGTH ) { result = result . substring ( NUM , DEFAULT ARG STRING MAX LENGTH ) + DEFAULT MAX STRING ENDING ; } return result ; } catch ( Throwable e ) { return UNKNOWN ; } }
public static Secret Key generate Secret Key ( Secret Key Type secret Key Type , int key Size ) throws Crypto Exception { try { Key Generator key Generator = Key Generator . get Instance ( secret Key Type . jce ( ) , BOUNCY CASTLE . jce ( ) ) ; key Generator . init ( key Size , Secure Random . get Instance ( STRING ) ) ; return key Generator . generate Key ( ) ; } catch ( General Security Exception ex ) { throw new Crypto Exception ( Message Format . format ( res . get String ( STRING ) , secret Key Type ) , ex ) ; } }
public CML delete CML ( I Sicres Abstract Document VO document ) { String id = document . get Id ( ) ; Reference reference = new Reference ( STORE , id , null ) ; Predicate predicate = new Predicate ( new Reference [ ] { reference } , null , null ) ; CML Delete delete = new CML Delete ( predicate ) ; CML cml = new CML ( ) ; cml . set Delete ( new CML Delete [ ] { delete } ) ; return cml ; }
private synchronized void eval ( ) throws Metadata Evaluation Exception { if ( cache Strategy == Cache Strategy . NEVER CACHE || internal Value . get ( ) == null ) { try { Object value = lazy Value . call ( ) ; if ( value == null ) { value = ACTUALLY NULL ; } internal Value = new Soft Reference < Object > ( value ) ; } catch ( Exception e ) { throw new Metadata Evaluation Exception ( e ) ; } } }
public void add Edge To Bounds ( S2 Point from , S2 Point to ) { if ( ! bound Set ) { bound Set = BOOL ; xmin = xmax = from . x ; ymin = ymax = from . y ; zmin = zmax = from . z ; } xmin = Math . min ( xmin , Math . min ( to . x , from . x ) ) ; ymin = Math . min ( ymin , Math . min ( to . y , from . y ) ) ; zmin = Math . min ( zmin , Math . min ( to . z , from . z ) ) ; xmax = Math . max ( xmax , Math . max ( to . x , from . x ) ) ; ymax = Math . max ( ymax , Math . max ( to . y , from . y ) ) ; zmax = Math . max ( zmax , Math . max ( to . z , from . z ) ) ; double approx Arc Len = Math . abs ( from . x - to . x ) + Math . abs ( from . y - to . y ) + Math . abs ( from . z - to . z ) ; if ( approx Arc Len < NUM ) { max Deformation = Math . max ( max Deformation , approx Arc Len * NUM ) ; } else if ( approx Arc Len < NUM ) { max Deformation = Math . max ( max Deformation , approx Arc Len * NUM ) ; } else { max Deformation = approx Arc Len * NUM ; } }
@ Override public void write ( byte [ ] buffer , int offset , int length ) throws IO Exception { while ( ( m Byte To Skip > NUM || m Byte To Copy > NUM || m State != STATE JPEG DATA ) && length > NUM ) { if ( m Byte To Skip > NUM ) { int byte To Process = length > m Byte To Skip ? m Byte To Skip : length ; length -= byte To Process ; m Byte To Skip -= byte To Process ; offset += byte To Process ; } if ( m Byte To Copy > NUM ) { int byte To Process = length > m Byte To Copy ? m Byte To Copy : length ; out . write ( buffer , offset , byte To Process ) ; length -= byte To Process ; m Byte To Copy -= byte To Process ; offset += byte To Process ; } if ( length == NUM ) { return ; } switch ( m State ) { case STATE SOI : int byte Read = request Byte To Buffer ( NUM , buffer , offset , length ) ; offset += byte Read ; length -= byte Read ; if ( m Buffer . position ( ) < NUM ) { return ; } m Buffer . rewind ( ) ; if ( m Buffer . get Short ( ) != Jpeg Header . SOI ) { throw new IO Exception ( STRING ) ; } out . write ( m Buffer . array ( ) , NUM , NUM ) ; m State = STATE FRAME HEADER ; m Buffer . rewind ( ) ; write Exif Data ( ) ; break ; case STATE FRAME HEADER : byte Read = request Byte To Buffer ( NUM , buffer , offset , length ) ; offset += byte Read ; length -= byte Read ; if ( m Buffer . position ( ) == NUM ) { short tag = m Buffer . get Short ( ) ; if ( tag == Jpeg Header . EOI ) { out . write ( m Buffer . array ( ) , NUM , NUM ) ; m Buffer . rewind ( ) ; } } if ( m Buffer . position ( ) < NUM ) { return ; } m Buffer . rewind ( ) ; short marker = m Buffer . get Short ( ) ; if ( marker == Jpeg Header . APP 1 ) { m Byte To Skip = ( m Buffer . get Short ( ) & NUM ) - NUM ; m State = STATE JPEG DATA ; } else if ( ! Jpeg Header . is Sof Marker ( marker ) ) { out . write ( m Buffer . array ( ) , NUM , NUM ) ; m Byte To Copy = ( m Buffer . get Short ( ) & NUM ) - NUM ; } else { out . write ( m Buffer . array ( ) , NUM , NUM ) ; m State = STATE JPEG DATA ; } m Buffer . rewind ( ) ; } } if ( length > NUM ) { out . write ( buffer , offset , length ) ; } }
public static String hash ( String string ) { try { Message Digest sha 1 = Message Digest . get Instance ( STRING ) ; sha 1 . update ( string . get Bytes ( STRING ) ) ; return Base 64 . encode ( sha 1 . digest ( ) ) ; } catch ( Exception ex ) { Debug debug = Debug . get Instance ( STRING ) ; if ( debug . warning Enabled ( ) ) { debug . warning ( STRING , ex ) ; } return null ; } }
static List < String > read Extensions ( final Substring Reader reader ) throws Decode Exception { int length = NUM ; List < String > values ; reader . skip Whitespaces ( ) ; reader . mark ( ) ; try { char c = reader . read ( ) ; if ( c == STRING ) { reader . mark ( ) ; while ( reader . read ( ) != STRING ) { length ++ ; } reader . reset ( ) ; values = Collections . singleton List ( reader . read ( length ) ) ; reader . read ( ) ; } else if ( c == STRING ) { reader . skip Whitespaces ( ) ; reader . mark ( ) ; c = reader . read ( ) ; if ( c == STRING ) { values = Collections . empty List ( ) ; } else { values = new Array List < > ( ) ; do { reader . reset ( ) ; values . add ( read Quoted String ( reader ) ) ; reader . skip Whitespaces ( ) ; reader . mark ( ) ; } while ( reader . read ( ) != STRING ) ; values = Collections . unmodifiable List ( values ) ; } } else { do { length ++ ; } while ( reader . read ( ) != STRING ) ; reader . reset ( ) ; values = Collections . singleton List ( reader . read ( length ) ) ; } return values ; } catch ( final String Index Out Of Bounds Exception e ) { throw Decode Exception . error ( ERR ATTR SYNTAX TRUNCATED VALUE 1 . get ( ) ) ; } }
private void NV 21 to I 420 Semi Planar ( byte [ ] nv 21 bytes , byte [ ] i420 bytes , int width , int height ) { System . arraycopy ( nv 21 bytes , NUM , i420 bytes , NUM , width * height ) ; for ( int i = width * height ; i < nv 21 bytes . length ; i += NUM ) { i420 bytes [ i ] = nv 21 bytes [ i + NUM ] ; i420 bytes [ i + NUM ] = nv 21 bytes [ i ] ; } }
public int read ( Byte Buffer dst ) throws IO Exception { if ( ! dst . has Remaining ( ) ) return NUM ; if ( ! is Hand Shake Complete ( ) ) { if ( is Blocking ( ) ) { while ( ! is Hand Shake Complete ( ) ) { process Handshake ( ) ; } } else { process Handshake ( ) ; if ( ! is Hand Shake Complete ( ) ) { return NUM ; } } } int purged = read Remaining ( dst ) ; if ( purged != NUM ) return purged ; assert ( in Data . position ( ) == NUM ) ; in Data . clear ( ) ; if ( ! in Crypt . has Remaining ( ) ) in Crypt . clear ( ) ; else in Crypt . compact ( ) ; if ( is Blocking ( ) || read Engine Result . get Status ( ) == Status . BUFFER UNDERFLOW ) if ( socket Channel . read ( in Crypt ) == - NUM ) { return - NUM ; } in Crypt . flip ( ) ; unwrap ( ) ; int transfered = transfere To ( in Data , dst ) ; if ( transfered == NUM && is Blocking ( ) ) { return read ( dst ) ; } return transfered ; }
private List < Facet Result > search ( ) throws IO Exception { Directory Reader index Reader = Directory Reader . open ( index Dir ) ; Index Searcher searcher = new Index Searcher ( index Reader ) ; Sorted Set Doc Values Reader State state = new Default Sorted Set Doc Values Reader State ( index Reader ) ; Facets Collector fc = new Facets Collector ( ) ; Facets Collector . search ( searcher , new Match All Docs Query ( ) , NUM , fc ) ; Facets facets = new Sorted Set Doc Values Facet Counts ( state , fc ) ; List < Facet Result > results = new Array List < > ( ) ; results . add ( facets . get Top Children ( NUM , STRING ) ) ; results . add ( facets . get Top Children ( NUM , STRING ) ) ; index Reader . close ( ) ; return results ; }
public Resource map Relations ( Resource object , JSON Object json Object , List < Resource > included ) throws Exception { Hash Map < String , String > relationship Names = get Relationship Names ( object . get Class ( ) ) ; for ( String relationship : relationship Names . key Set ( ) ) { JSON Object relation Json Object = null ; try { relation Json Object = json Object . get JSON Object ( relationship ) ; } catch ( JSON Exception e ) { Logger . debug ( STRING + relationship + STRING ) ; continue ; } JSON Object relation Data Object = null ; try { relation Data Object = relation Json Object . get JSON Object ( STRING ) ; Resource relation Object = Factory . new Object From JSON Object ( relation Data Object , null ) ; relation Object = match Included To Relation ( relation Object , included ) ; m Deserializer . set Field ( object , relationship Names . get ( relationship ) , relation Object ) ; } catch ( JSON Exception e ) { Logger . debug ( STRING ) ; } JSON Array relation Data Array = null ; try { relation Data Array = relation Json Object . get JSON Array ( STRING ) ; List < Resource > relation Array = Factory . new Object From JSON Array ( relation Data Array , null ) ; relation Array = match Included To Relation ( relation Array , included ) ; m Deserializer . set Field ( object , relationship Names . get ( relationship ) , relation Array ) ; } catch ( JSON Exception e ) { Logger . debug ( STRING ) ; } } return object ; }
public int size ( ) { return rdns . size ( ) ; }
@ Override public void do Initialize ( Uima Context a Context ) throws Resource Initialization Exception { DB db = mongo Resource . get DB ( ) ; collection = db . get Collection ( collection Name ) ; collection . create Index ( new Basic DB Object ( FIELD UNIQUE ID , NUM ) ) ; collection . create Index ( new Basic DB Object ( FIELD PUBLISHEDIDS , NUM ) ) ; stop Features = new Hash Set < String > ( ) ; stop Features . add ( STRING ) ; stop Features . add ( STRING ) ; max Content Length = Config Utils . string To Integer ( max Content Length String , NUM ) ; }
protected void draw High Far Out ( double a Radius , Graphics 2 D g2 , double xx , double m ) { double side = a Radius * NUM ; g2 . draw ( new Line 2 D . Double ( xx - side , m + side , xx + side , m + side ) ) ; g2 . draw ( new Line 2 D . Double ( xx - side , m + side , xx , m ) ) ; g2 . draw ( new Line 2 D . Double ( xx + side , m + side , xx , m ) ) ; }
private void find Large Item Sets ( ) throws Exception { Array List < Object > k Minus One Sets , k Sets ; Hashtable < Item Set , Integer > hashtable ; int nec Support , i = NUM ; nec Support = ( int ) ( m min Support * m instances . num Instances ( ) + NUM ) ; k Sets = Apriori Item Set . singletons ( m instances , m treat Zero As Missing ) ; if ( m treat Zero As Missing ) { Apriori Item Set . up Date Counters Treat Zero As Missing ( k Sets , m instances ) ; } else { Apriori Item Set . up Date Counters ( k Sets , m instances ) ; } k Sets = Apriori Item Set . delete Item Sets ( k Sets , nec Support , m instances . num Instances ( ) ) ; if ( k Sets . size ( ) == NUM ) { return ; } do { m Ls . add ( k Sets ) ; k Minus One Sets = k Sets ; k Sets = Apriori Item Set . merge All Item Sets ( k Minus One Sets , i , m instances . num Instances ( ) ) ; hashtable = Apriori Item Set . get Hashtable ( k Minus One Sets , k Minus One Sets . size ( ) ) ; m hashtables . add ( hashtable ) ; k Sets = Apriori Item Set . prune Item Sets ( k Sets , hashtable ) ; if ( m treat Zero As Missing ) { Apriori Item Set . up Date Counters Treat Zero As Missing ( k Sets , m instances ) ; } else { Apriori Item Set . up Date Counters ( k Sets , m instances ) ; } k Sets = Apriori Item Set . delete Item Sets ( k Sets , nec Support , m instances . num Instances ( ) ) ; i ++ ; } while ( k Sets . size ( ) > NUM ) ; }
public boolean is In Allowed ( int x , int y ) { for ( Shape r : arriving Barriers ) { if ( r . contains ( x , y ) ) { return BOOL ; } } return BOOL ; }
public void remove Plugin Interface ( String interfacename ) throws SMS Exception , SSO Exception { SMS Entry . validate Token ( token ) ; validate Service Schema Manager Impl ( ) ; Document schema Doc = ssm . get Document Copy ( ) ; Node schema Node = XML Utils . get Root Node ( schema Doc , SMS Utils . SCHEMA ) ; Node plugin Node = XML Utils . get Named Child Node ( schema Node , SMS Utils . PLUGIN INTERFACE , SMS Utils . NAME , interfacename ) ; if ( plugin Node != null ) { schema Node . remove Child ( plugin Node ) ; replace Schema ( schema Doc ) ; } }
public IP Address Name ( String name ) throws IO Exception { if ( name == null || name . length ( ) == NUM ) { throw new IO Exception ( STRING ) ; } if ( name . char At ( name . length ( ) - NUM ) == STRING ) { throw new IO Exception ( STRING + name ) ; } if ( name . index Of ( STRING ) >= NUM ) { parse I Pv 6 ( name ) ; is I Pv 4 = BOOL ; } else if ( name . index Of ( STRING ) >= NUM ) { parse I Pv 4 ( name ) ; is I Pv 4 = BOOL ; } else { throw new IO Exception ( STRING + name ) ; } }
private boolean is Same File ( Path first , Path second ) throws IO Exception { boolean same File Size = Files . size ( first ) == Files . size ( second ) ; if ( ! same File Size ) { return BOOL ; } byte [ ] first Bytes = Files . read All Bytes ( first ) ; byte [ ] second Bytes = Files . read All Bytes ( second ) ; return Arrays . equals ( first Bytes , second Bytes ) ; }
public static org . opcfoundation . ua . transport . security . Key Pair load Key Pair From Protected Store ( String store Location , String alias , String store PW , String private PW ) throws Key Store Exception , IO Exception , No Such Algorithm Exception , Certificate Exception , Unrecoverable Key Exception { Key Store store = null ; store = Key Store . get Instance ( STRING ) ; File keystore File = new File ( store Location ) ; File Input Stream in = new File Input Stream ( keystore File ) ; store . load ( in , store PW . to Char Array ( ) ) ; in . close ( ) ; X509 Certificate cert = ( X509 Certificate ) store . get Certificate ( alias ) ; RSA Private Key key = ( RSA Private Key ) store . get Key ( alias , private PW . to Char Array ( ) ) ; return new org . opcfoundation . ua . transport . security . Key Pair ( new Cert ( cert ) , new Priv Key ( key ) ) ; }
@ Override public Graph Query has Not ( final String key , final Object value ) { criteria . add ( new Has Not ( key , value ) ) ; return this ; }
private void init Compute Program ( ) { Int Buffer work Group Size = Buffer Utils . create Int Buffer ( NUM ) ; gl Get Programiv ( compute Program , GL COMPUTE WORK GROUP SIZE , work Group Size ) ; work Group Size X = work Group Size . get ( NUM ) ; work Group Size Y = work Group Size . get ( NUM ) ; int boxes Resource Index = gl Get Program Resource Index ( compute Program , GL SHADER STORAGE BLOCK , STRING ) ; Int Buffer props = Buffer Utils . create Int Buffer ( NUM ) ; Int Buffer params = Buffer Utils . create Int Buffer ( NUM ) ; props . put ( NUM , GL BUFFER BINDING ) ; gl Get Program Resourceiv ( compute Program , GL SHADER STORAGE BLOCK , boxes Resource Index , props , null , params ) ; boxes Ssbo Binding = params . get ( NUM ) ; int uniforms Resource Index = gl Get Program Resource Index ( compute Program , GL UNIFORM BLOCK , STRING ) ; gl Get Program Resourceiv ( compute Program , GL UNIFORM BLOCK , uniforms Resource Index , props , null , params ) ; compute Ubo Binding = params . get ( NUM ) ; int loc = gl Get Uniform Location ( compute Program , STRING ) ; gl Get Uniformiv ( compute Program , loc , params ) ; framebuffer Image Binding = params . get ( NUM ) ; loc = gl Get Uniform Location ( compute Program , STRING ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Position Image Binding = params . get ( NUM ) ; loc = gl Get Uniform Location ( compute Program , STRING ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Normal Image Binding = params . get ( NUM ) ; }
TS Response ( byte [ ] ts Reply ) throws IO Exception { parse ( ts Reply ) ; }
public static void execute Command ( Process Builder p ) throws IO Exception { Process proc = p . start ( ) ; try ( Buffered Reader std Input = new Buffered Reader ( new Input Stream Reader ( proc . get Input Stream ( ) ) ) ; Buffered Reader std Error = new Buffered Reader ( new Input Stream Reader ( proc . get Error Stream ( ) ) ) ) { logger . info ( STRING ) ; String s ; while ( ( s = std Input . read Line ( ) ) != null ) { logger . info ( s ) ; } logger . info ( STRING ) ; while ( ( s = std Error . read Line ( ) ) != null ) { logger . info ( s ) ; } } }
public boolean page Setup Dialog ( Printer Job job ) { Print Request Attribute Set prats = get Print Request Attribute Set ( ) ; Page Format pf = job . page Dialog ( prats ) ; set Print Request Attribute Set ( prats ) ; return BOOL ; }
public static void assert Not Equals ( Buffered Image image 1 , Buffered Image image 2 ) { assert Not Equals ( STRING , image 1 , image 2 ) ; }
public Depend ( Path Impl source , long digest , boolean require Source ) { this ( source ) ; long new Digest = source . get Crc 64 ( ) ; require Source = require Source ; if ( new Digest == digest ) { } else if ( ! require Source && new Digest == NUM ) { } else if ( new Digest == NUM ) { if ( log . is Loggable ( Level . FINE ) ) log . fine ( source . get Native Path ( ) + STRING ) ; is Digest Modified = BOOL ; } else { is Digest Modified = BOOL ; } }
public static boolean string To File ( final String data , final File target File , final boolean do Append ) { if ( target File == null || ! is Writable ( target File , BOOL ) ) { Log . e ( File Utils . class , STRING ) ; return BOOL ; } boolean is Succeed = BOOL ; try { final File Writer out = new File Writer ( target File , do Append ) ; out . write ( data ) ; out . flush ( ) ; out . close ( ) ; } catch ( IO Exception e ) { is Succeed = BOOL ; } return is Succeed ; }
@ Override public void cascade Register New If Required ( Object object , Unit Of Work Impl uow , Map visited Objects ) { cascade Register New If Required ( object , uow , visited Objects , BOOL ) ; }
public void initialize ( Map config Params ) throws Policy Exception { if ( config Params == null ) { throw ( new Policy Exception ( Res Bundle Utils . rb Name , STRING , null , null ) ) ; } String configured Ldap Server = ( String ) config Params . get ( Policy Config . LDAP SERVER ) ; if ( configured Ldap Server == null ) { debug . error ( STRING + STRING + STRING + STRING + STRING ) ; throw ( new Policy Exception ( Res Bundle Utils . rb Name , STRING , null , null ) ) ; } ldap Server = configured Ldap Server . to Lower Case ( ) ; local DS = Policy Utils . is Local DS ( ldap Server ) ; alias Enabled = Boolean . value Of ( ( String ) config Params . get ( Policy Config . USER ALIAS ENABLED ) ) ; String authid = ( String ) config Params . get ( Policy Config . LDAP BIND DN ) ; String authpw = ( String ) config Params . get ( Policy Config . LDAP BIND PASSWORD ) ; if ( authpw != null ) { authpw = Policy Utils . decrypt ( authpw ) ; } base DN = ( String ) config Params . get ( Policy Config . LDAP USERS BASE DN ) ; user Search Filter = ( String ) config Params . get ( Policy Config . LDAP USERS SEARCH FILTER ) ; String scope = ( String ) config Params . get ( Policy Config . LDAP USERS SEARCH SCOPE ) ; if ( scope . equals Ignore Case ( LDAP SCOPE BASE ) ) { user Search Scope = Search Scope . BASE OBJECT ; } else if ( scope . equals Ignore Case ( LDAP SCOPE ONE ) ) { user Search Scope = Search Scope . SINGLE LEVEL ; } else { user Search Scope = Search Scope . WHOLE SUBTREE ; } user RDN Attr Name = ( String ) config Params . get ( Policy Config . LDAP USER SEARCH ATTRIBUTE ) ; int min Pool Size ; int max Pool Size ; try { time Limit = Integer . parse Int ( ( String ) config Params . get ( Policy Config . LDAP SEARCH TIME OUT ) ) ; max Results = Integer . parse Int ( ( String ) config Params . get ( Policy Config . LDAP SEARCH LIMIT ) ) ; min Pool Size = Integer . parse Int ( ( String ) config Params . get ( Policy Config . LDAP CONNECTION POOL MIN SIZE ) ) ; max Pool Size = Integer . parse Int ( ( String ) config Params . get ( Policy Config . LDAP CONNECTION POOL MAX SIZE ) ) ; } catch ( Number Format Exception nfe ) { throw ( new Policy Exception ( nfe ) ) ; } boolean ssl Enabled = Boolean . value Of ( ( String ) config Params . get ( Policy Config . LDAP SSL ENABLED ) ) ; Set org Name Set = ( Set ) config Params . get ( Policy Manager . ORGANIZATION NAME ) ; if ( ( org Name Set != null ) && ( ! org Name Set . is Empty ( ) ) ) { Iterator items = org Name Set . iterator ( ) ; org Name = ( String ) items . next ( ) ; } if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + ldap Server + STRING + authid + STRING + base DN + STRING + user Search Filter + STRING + user RDN Attr Name + STRING + time Limit + STRING + max Results + STRING + min Pool Size + STRING + max Pool Size + STRING + ssl Enabled + STRING + org Name ) ; } LDAP Connection Pools . init Connection Pool ( ldap Server , authid , authpw , ssl Enabled , min Pool Size , max Pool Size ) ; conn Pool = LDAP Connection Pools . get Connection Pool ( ldap Server ) ; initialized = BOOL ; }
public static boolean parse Bool ( String s ) { if ( s != null ) { if ( s . starts With ( STRING ) || s . starts With ( STRING ) || s . starts With ( STRING ) ) { return BOOL ; } if ( s . starts With ( STRING ) || s . starts With ( STRING ) || s . equals ( STRING ) ) { return BOOL ; } } throw new Solr Exception ( Solr Exception . Error Code . BAD REQUEST , STRING + s ) ; }
private static void read DNA ( String filename ) { try { Line Number Reader in = new Line Number Reader ( new File Reader ( filename ) ) ; process One Line ( in , STRING , compilation Rates ) ; process One Line ( in , STRING , speedup Rates ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; VM . sys Fail ( STRING ) ; } }
public void test Of EEEE ( ) { Enum Set < Enum With Inner Class > enum Set = Enum Set . of ( Enum With Inner Class . a , Enum With Inner Class . b , Enum With Inner Class . c , Enum With Inner Class . d ) ; assert Equals ( STRING , NUM , enum Set . size ( ) ) ; assert True ( STRING , enum Set . contains ( Enum With Inner Class . a ) ) ; assert True ( STRING , enum Set . contains ( Enum With Inner Class . d ) ) ; try { Enum Set . of ( ( Enum With Inner Class ) null , null , null , null ) ; fail ( STRING ) ; } catch ( Null Pointer Exception npe ) { } Enum Set < Huge Enum With Inner Class > huge Enum Set = Enum Set . of ( Huge Enum With Inner Class . a , Huge Enum With Inner Class . b , Huge Enum With Inner Class . c , Huge Enum With Inner Class . d ) ; assert Equals ( NUM , huge Enum Set . size ( ) ) ; assert True ( huge Enum Set . contains ( Huge Enum With Inner Class . a ) ) ; assert True ( huge Enum Set . contains ( Huge Enum With Inner Class . d ) ) ; try { Enum Set . of ( ( Huge Enum With Inner Class ) null , null , null , null ) ; fail ( STRING ) ; } catch ( Null Pointer Exception npe ) { } }
Builder ( URL swagger Url ) { try { this . swagger Location = swagger Url . to URI ( ) ; } catch ( URI Syntax Exception e ) { throw new Illegal Argument Exception ( STRING , e ) ; } this . swagger = read Swagger ( swagger Url . to String ( ) ) ; }
@ Override public void on Save Instance State ( @ Non Null Bundle saved Instance State ) { saved Instance State . put Parcelable ( LOCATION KEY , current Location ) ; if ( last Location Update Time != null ) { saved Instance State . put Long ( LAST LOCATION UPDATE TIME STRING KEY , last Location Update Time . get Time ( ) ) ; } if ( last Wifi Scan Time != null ) { saved Instance State . put Long ( LAST WIFI SCAN TIME STRING KEY , last Wifi Scan Time . get Time ( ) ) ; } saved Instance State . put Boolean ( LOGGING ENABLED KEY , logging Enabled ) ; super . on Save Instance State ( saved Instance State ) ; }
public static String remove Empty Lines ( String text ) { text = text . replace All ( STRING + Chinese Language Constants . SPACE [ NUM ] + STRING , STRING ) ; text = text . replace All ( STRING + Chinese Language Constants . SPACE [ NUM ] + STRING , STRING ) ; return text ; }
public void keep Only ( Set < I Var Abstraction > useful Pointers ) { Set < I Var Abstraction > reps = new Hash Set < I Var Abstraction > ( ) ; for ( I Var Abstraction pn : useful Pointers ) { reps . add ( pn . get Representative ( ) ) ; } useful Pointers . add All ( reps ) ; reps = null ; for ( I Var Abstraction pn : pointers ) { if ( ! useful Pointers . contains ( pn ) ) pn . delete All ( ) ; } System . gc ( ) ; }
public static String encrypt CFB ( final byte [ ] concatenated Hash Value , final Long turnover Counter , final Secret Key symmetric Key , int turn Over Counter Length In Bytes ) throws No Such Algorithm Exception , No Such Provider Exception , No Such Padding Exception , Invalid Key Exception , Invalid Algorithm Parameter Exception , Illegal Block Size Exception , Bad Padding Exception { final Byte Buffer byte Buffer IV = Byte Buffer . allocate ( NUM ) ; byte Buffer IV . put ( concatenated Hash Value ) ; final byte [ ] IV = byte Buffer IV . array ( ) ; final Byte Buffer byte Buffer Data = Byte Buffer . allocate ( NUM ) ; byte Buffer Data . put Long ( turnover Counter ) ; final byte [ ] data = byte Buffer Data . array ( ) ; byte [ ] turn Over Counter Byte Rep = get 2 Complement Rep For Long ( turnover Counter , turn Over Counter Length In Bytes ) ; System . arraycopy ( turn Over Counter Byte Rep , NUM , data , NUM , turn Over Counter Byte Rep . length ) ; final Iv Parameter Spec iv Spec = new Iv Parameter Spec ( IV ) ; final Cipher cipher = Cipher . get Instance ( STRING , STRING ) ; cipher . init ( Cipher . ENCRYPT MODE , symmetric Key , iv Spec ) ; final byte [ ] encrypted Turn Over Value Complete = cipher . do Final ( data ) ; final byte [ ] encrypted Turn Over Value = new byte [ turn Over Counter Length In Bytes ] ; System . arraycopy ( encrypted Turn Over Value Complete , NUM , encrypted Turn Over Value , NUM , turn Over Counter Length In Bytes ) ; final String base 64 Encrypted Turn Over Value = Cash Box Utils . base 64 Encode ( encrypted Turn Over Value , BOOL ) ; return base 64 Encrypted Turn Over Value ; }
public void reset Lockout Attempts ( String user DN , AM Identity am Identity , Account Lockout Info ac Info , boolean reset Duration ) { debug . message ( STRING ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + reset Duration ) ; } int fail count = NUM ; long last Fail Time = NUM ; long locked out at = NUM ; long actual Lockout Duration = failure Lockout Duration ; long current Lockout Duration = ac Info . get Actual Lockout Duration ( ) ; if ( ac Info != null ) { fail count = ac Info . get Fail Count ( ) ; last Fail Time = ac Info . get Last Fail Time ( ) ; locked out at = ac Info . get Lockout At ( ) ; long now = current Time Millis ( ) ; if ( ! reset Duration ) { actual Lockout Duration = current Lockout Duration ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + locked out at ) ; } if ( locked out at > NUM ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING ) ; } actual Lockout Duration = failure Lockout Multiplier * ( current Lockout Duration ) ; } } } if ( store Invalid Attempts In DS ) { try { if ( ( fail count != NUM ) || ( last Fail Time != NUM ) || ( locked out at != NUM ) || ( actual Lockout Duration != current Lockout Duration ) ) { Map attr Map = new Hash Map ( ) ; Set invalid Attempts = new Hash Set ( ) ; String invalid XML = create Invalid Attempts XML ( NUM , NUM , NUM , actual Lockout Duration ) ; invalid Attempts . add ( invalid XML ) ; attr Map . put ( invalid Attempts Data Attr Name , invalid Attempts ) ; set Lockout Object Class ( am Identity ) ; am Identity . set Attributes ( attr Map ) ; debug . message ( STRING + invalid XML ) ; am Identity . store ( ) ; } debug . message ( STRING ) ; } catch ( Exception exp ) { debug . message ( STRING ) ; } } ac Info . set Fail Count ( NUM ) ; ac Info . set Last Fail Time ( NUM ) ; ac Info . set Lockout At ( NUM ) ; ac Info . set Lockout ( BOOL ) ; ac Info . set Actual Lockout Duration ( actual Lockout Duration ) ; }
String public Name From Disk Name ( String disk Name ) { if ( ! should Disk Name Be Visible ( disk Name ) ) { throw new Illegal Argument Exception ( STRING + disk Name ) ; } return disk Name . substring ( m File Prefix . length ( ) , disk Name . length ( ) ) ; }
public double [ ] predict ( F Vec feat ) { return predict ( feat , BOOL ) ; }
public static < A > A [ ] append ( final A [ ] a , final A [ ] b ) { final int alen = a . length ; final int blen = b . length ; final A [ ] res = Arrays . copy Of ( a , alen + blen ) ; System . arraycopy ( b , NUM , res , alen , blen ) ; return res ; }
public boolean add Listener ( @ Not Null Soft Wrap Aware Document Parsing Listener listener ) { return my Listeners . add ( listener ) ; }
private void assert Array Equals ( double [ ] expected , double [ ] actual , double delta , boolean check Na N ) { Assert . assert Equals ( expected . length , actual . length ) ; for ( int index = NUM ; index < actual . length ; index ++ ) { double d1 = expected [ index ] ; double d2 = actual [ index ] ; if ( Double . is Na N ( d1 ) || Double . is Na N ( d2 ) ) { if ( check Na N ) { Assert . assert True ( Double . is Na N ( d1 ) == Double . is Na N ( d2 ) ) ; } Assert . assert True ( BOOL ) ; } else { Assert . assert Equals ( d1 , d2 , delta ) ; } } }
protected void add To Population ( Solution new Solution ) { List < Integer > dominates = new Array List < Integer > ( ) ; boolean dominated = BOOL ; for ( int i = NUM ; i < population . size ( ) ; i ++ ) { int flag = dominance Comparator . compare ( new Solution , population . get ( i ) ) ; if ( flag < NUM ) { dominates . add ( i ) ; } else if ( flag > NUM ) { dominated = BOOL ; } } if ( ! dominates . is Empty ( ) ) { population . remove ( dominates . get ( PRNG . next Int ( dominates . size ( ) ) ) ) ; population . add ( new Solution ) ; } else if ( ! dominated ) { population . remove ( PRNG . next Int ( population . size ( ) ) ) ; population . add ( new Solution ) ; } }
public void update Max Text Widths ( float required Width , float match Contents Width ) { m Max Required Width = Math . max ( m Max Required Width , required Width ) ; m Max Match Contents Width = Math . max ( m Max Match Contents Width , match Contents Width ) ; }
private String generate Blend Mode Import ( Blend Mode blend Mode ) { if ( blend Mode == Blend Mode . COLOR ) return STRING ; else if ( blend Mode == Blend Mode . COLORBURN ) return STRING ; else if ( blend Mode == Blend Mode . COLORDODGE ) return STRING ; else if ( blend Mode == Blend Mode . EXCLUSION ) return STRING ; else if ( blend Mode == Blend Mode . HUE ) return STRING ; else if ( blend Mode == Blend Mode . LUMINOSITY ) return STRING ; else if ( blend Mode == Blend Mode . SATURATION ) return STRING ; else if ( blend Mode == Blend Mode . SOFTLIGHT ) return STRING ; else return null ; }
public static String parse Int To Metric Suffix ( int x ) { String xint = String . value Of ( x ) ; if ( xint . ends With ( STRING ) ) { xint = xint . replace All ( STRING , STRING ) ; } else if ( xint . ends With ( STRING ) ) { xint = xint . replace All ( STRING , STRING ) ; } return xint ; }
public Sm Auth Status query ( String parameter , String secret , Sm Auth Query Code request , Sm Auth Query Response response ) { if ( null == response ) { return Sm Auth Status . SMAUTH FAILURE ; } if ( Sm Auth Query Code . SMAUTH QUERY DESCRIPTION == request ) { response . set Response Buffer ( SCHEME DESCRIPTION ) ; response . set Response Code ( SCHEME VERSION ) ; } else if ( Sm Auth Query Code . SMAUTH QUERY CREDENTIALS REQ == request ) { response . set Response Code ( Sm Auth Query Response . SMAUTH CRED BASIC ) ; } else { return Sm Auth Status . SMAUTH FAILURE ; } return Sm Auth Status . SMAUTH SUCCESS ; }
protected void add All Transitive Jars ( War Archive Merger wam ) throws Mojo Execution Exception { Dependency Calculator dc = new Dependency Calculator ( artifact Factory , resolver , local Repository , remote Repositories , maven Project , maven Project Builder , installer , container ) ; try { for ( File f : dc . execute ( ) ) { wam . add Merge Item ( f ) ; } } catch ( Exception ex ) { throw new Mojo Execution Exception ( STRING , ex ) ; } }
private void add ( int col , Graphical Node graphical Node ) { my Graphical Nodes . remove ( graphical Node ) ; if ( nb Cols - NUM < col ) { nb Cols = col + NUM ; } int row = NUM ; while ( is Occupied ( row , col ) ) { row ++ ; } graphical Node . row = row ; graphical Node . col = col ; my Graphical Nodes . add ( graphical Node ) ; }
private int add Tonal Components ( float [ ] spectrum , int num Components , Tonal Component [ ] components ) { int last Pos = - NUM ; for ( int i = NUM ; i < num Components ; i ++ ) { last Pos = Math . max ( components [ i ] . pos + components [ i ] . num Coefs , last Pos ) ; for ( int j = NUM ; j < components [ i ] . num Coefs ; j ++ ) { spectrum [ components [ i ] . pos + j ] += components [ i ] . coef [ j ] ; } } return last Pos ; }
public static List < User Layer > extract User Layers ( Styled Layer Descriptor sld ) { List < User Layer > user Layer List = new Array List < User Layer > ( ) ; if ( sld != null ) { for ( Styled Layer layer : sld . layers ( ) ) { if ( layer instanceof User Layer ) { User Layer user Layer = ( User Layer ) layer ; user Layer List . add ( user Layer ) ; } } } return user Layer List ; }
public static void close Quiet ( @ Nullable Selector rsrc ) { if ( rsrc != null ) try { if ( rsrc . is Open ( ) ) rsrc . close ( ) ; } catch ( IO Exception ignored ) { } }
private Linked List < Diff > diff main ( String text 1 , String text 2 , boolean checklines , long deadline ) { if ( text 1 == null || text 2 == null ) { throw new Illegal Argument Exception ( STRING ) ; } Linked List < Diff > diffs ; if ( text 1 . equals ( text 2 ) ) { diffs = new Linked List < Diff > ( ) ; if ( text 1 . length ( ) != NUM ) { diffs . add ( new Diff ( Operation . EQUAL , text 1 ) ) ; } return diffs ; } int commonlength = diff common Prefix ( text 1 , text 2 ) ; String commonprefix = text 1 . substring ( NUM , commonlength ) ; text 1 = text 1 . substring ( commonlength ) ; text 2 = text 2 . substring ( commonlength ) ; commonlength = diff common Suffix ( text 1 , text 2 ) ; String commonsuffix = text 1 . substring ( text 1 . length ( ) - commonlength ) ; text 1 = text 1 . substring ( NUM , text 1 . length ( ) - commonlength ) ; text 2 = text 2 . substring ( NUM , text 2 . length ( ) - commonlength ) ; diffs = diff compute ( text 1 , text 2 , checklines , deadline ) ; if ( commonprefix . length ( ) != NUM ) { diffs . add First ( new Diff ( Operation . EQUAL , commonprefix ) ) ; } if ( commonsuffix . length ( ) != NUM ) { diffs . add Last ( new Diff ( Operation . EQUAL , commonsuffix ) ) ; } diff cleanup Merge ( diffs ) ; return diffs ; }
public static boolean create Compaction Required File ( String meta Folder Path , Compaction Type compaction Type ) { String status File ; if ( compaction Type . equals ( Compaction Type . MINOR COMPACTION ) ) { status File = meta Folder Path + Carbon Common Constants . FILE SEPARATOR + Carbon Common Constants . minor Compaction Required File ; } else { status File = meta Folder Path + Carbon Common Constants . FILE SEPARATOR + Carbon Common Constants . major Compaction Required File ; } try { if ( ! File Factory . is File Exist ( status File , File Factory . get File Type ( status File ) ) ) { if ( File Factory . create New File ( status File , File Factory . get File Type ( status File ) ) ) { LOGGER . info ( STRING + status File ) ; return BOOL ; } else { LOGGER . error ( STRING + status File ) ; return BOOL ; } } else { LOGGER . info ( STRING + status File + STRING ) ; } } catch ( IO Exception e ) { LOGGER . error ( STRING + e . get Message ( ) ) ; } return BOOL ; }
private boolean allow Notification Emission ( Object Name name , Targeted Notification tn ) { try { if ( check Notification Emission ) { check M Bean Permission ( name , STRING ) ; } if ( notification Access Controller != null ) { notification Access Controller . fetch Notification ( connection Id , name , tn . get Notification ( ) , get Subject ( ) ) ; } return BOOL ; } catch ( Security Exception e ) { if ( logger . debug On ( ) ) { logger . debug ( STRING , STRING + tn . get Notification ( ) + STRING + STRING ) ; } return BOOL ; } catch ( Exception e ) { if ( logger . debug On ( ) ) { logger . debug ( STRING , STRING + tn . get Notification ( ) + STRING + STRING + e ) ; } return BOOL ; } }
public void update Throughput ( long current Time ) { throughput Calculation Lock . lock ( ) ; try { int interval = ( int ) ( current Time - last Throughput Calculation Time ) ; long min Interval = get Throughput Calculation Interval In Millis ( ) ; if ( ( min Interval == NUM ) || ( interval < min Interval ) ) { return ; } long read Bytes = this . read Bytes ; long written Bytes = this . written Bytes ; long read Messages = this . read Messages ; long written Messages = this . written Messages ; read Bytes Throughput = ( read Bytes - last Read Bytes ) * NUM / interval ; written Bytes Throughput = ( written Bytes - last Written Bytes ) * NUM / interval ; read Messages Throughput = ( read Messages - last Read Messages ) * NUM / interval ; written Messages Throughput = ( written Messages - last Written Messages ) * NUM / interval ; if ( read Bytes Throughput > largest Read Bytes Throughput ) { largest Read Bytes Throughput = read Bytes Throughput ; } if ( written Bytes Throughput > largest Written Bytes Throughput ) { largest Written Bytes Throughput = written Bytes Throughput ; } if ( read Messages Throughput > largest Read Messages Throughput ) { largest Read Messages Throughput = read Messages Throughput ; } if ( written Messages Throughput > largest Written Messages Throughput ) { largest Written Messages Throughput = written Messages Throughput ; } last Read Bytes = read Bytes ; last Written Bytes = written Bytes ; last Read Messages = read Messages ; last Written Messages = written Messages ; last Throughput Calculation Time = current Time ; } finally { throughput Calculation Lock . unlock ( ) ; } }
public List < Verification OK > verify ( X509 Certificate sign Cert , X509 Certificate issuer Cert , Date sign Date ) throws General Security Exception , IO Exception { Root Store Verifier root Store Verifier = new Root Store Verifier ( verifier ) ; root Store Verifier . set Root Store ( root Store ) ; CRL Verifier crl Verifier = new CRL Verifier ( root Store Verifier , get CR Ls From DSS ( ) ) ; crl Verifier . set Root Store ( root Store ) ; crl Verifier . set Online Checking Allowed ( latest Revision || online Checking Allowed ) ; OCSP Verifier ocsp Verifier = new OCSP Verifier ( crl Verifier , get OCSP Responses From DSS ( ) ) ; ocsp Verifier . set Root Store ( root Store ) ; ocsp Verifier . set Online Checking Allowed ( latest Revision || online Checking Allowed ) ; return ocsp Verifier . verify ( sign Cert , issuer Cert , sign Date ) ; }
protected boolean [ ] test WRT Zero R ( Classifier classifier , Evaluation evaluation , Instances train , Instances test ) throws Exception { boolean [ ] result = new boolean [ NUM ] ; evaluation . evaluate Model ( classifier , test ) ; try { Classifier zero R = new weka . classifiers . rules . Zero R ( ) ; zero R . build Classifier ( train ) ; Evaluation zero R Eval = new Evaluation ( train ) ; zero R Eval . evaluate Model ( zero R , test ) ; result [ NUM ] = Utils . gr Or Eq ( zero R Eval . error Rate ( ) , evaluation . error Rate ( ) ) ; } catch ( Exception ex ) { throw new Error ( STRING + ex . get Message ( ) ) ; } return result ; }
public void println ( ) { if ( add Newlines ) { try { out . write ( STRING ) ; } catch ( IO Exception ioe ) { throw new Groovy Runtime Exception ( ioe ) ; } } }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String child Data ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; child . delete Data ( NUM , NUM ) ; child Data = child . get Data ( ) ; assert Equals ( STRING , STRING , child Data ) ; }
public void delivery Complete ( final I Mqtt Delivery Token token ) { logger . trace ( STRING , token . get Message Id ( ) ) ; }
public D Export Public Key Open Ssl ( J Frame parent , String entry Alias ) { super ( parent , Dialog . Modality Type . DOCUMENT MODAL ) ; this . entry Alias = entry Alias ; init Components ( ) ; }
public static String escape Unicode ( String s ) { int len = s . length ( ) ; int i = NUM ; while ( i < len ) { char ch = s . char At ( i ) ; if ( ch > NUM ) { String Builder buf = new String Builder ( ) ; buf . append ( s . substring ( NUM , i ) ) ; while ( i < len ) { ch = s . char At ( i ) ; if ( ch > NUM ) { buf . append ( STRING ) ; buf . append ( Character . for Digit ( ( ch > > NUM ) % NUM , NUM ) ) ; buf . append ( Character . for Digit ( ( ch > > NUM ) % NUM , NUM ) ) ; buf . append ( Character . for Digit ( ( ch > > NUM ) % NUM , NUM ) ) ; buf . append ( Character . for Digit ( ( ch ) % NUM , NUM ) ) ; } else { buf . append ( ch ) ; } i ++ ; } s = buf . to String ( ) ; } else { i ++ ; } } return s ; }
public void key Pressed ( final int key Code ) { if ( impl . get Current Form ( ) == null ) { return ; } add Single Argument Event ( KEY PRESSED , key Code ) ; last Interaction Was Keypad = last Interaction Was Keypad || ( key Code != Menu Bar . left SK && key Code != Menu Bar . clear SK && key Code != Menu Bar . back SK ) ; key Repeat Charged = ( key Code >= NUM || get Game Action ( key Code ) > NUM ) || key Code == impl . get Clear Key Code ( ) ; long Press Charged = key Repeat Charged ; long Key Press Time = System . current Time Millis ( ) ; key Repeat Value = key Code ; next Key Repeat Event = System . current Time Millis ( ) + key Repeat Initial Interval Time ; previous Key Pressed = last Key Pressed ; last Key Pressed = key Code ; }
public boolean is Empty ( ) { return filter . is Empty ( ) && query . is Empty ( ) && sort . is Empty ( ) ; }
public String [ ] read Directory ( String dir ) { if ( dir == null ) { throw new Null Pointer Exception ( STRING ) ; } String Array Out list Out = new String Array Out ( ) ; try { check Result ( Lib I Mobile Device . afc read directory ( get Ref ( ) , dir , list Out ) ) ; String Array list = list Out . get Value ( ) ; Array List < String > result = new Array List < String > ( ) ; if ( list != null ) { for ( int i = NUM ; ; i ++ ) { String s = list . get ( i ) ; if ( s == null ) { break ; } result . add ( s ) ; } } return result . to Array ( new String [ result . size ( ) ] ) ; } finally { Lib I Mobile Device . delete String Array values z ( list Out . get Value ( ) ) ; list Out . delete ( ) ; } }
public void register Input ( String var Name , Java RDD < String > rdd In , String format , long rlen , long clen , File Format Properties props , List < Value Type > schema ) throws DML Runtime Exception { if ( ! ( DML Script . rtplatform == RUNTIME PLATFORM . SPARK || DML Script . rtplatform == RUNTIME PLATFORM . HYBRID SPARK ) ) { throw new DML Runtime Exception ( STRING ) ; } long nnz = - NUM ; if ( variables == null ) variables = new Local Variable Map ( ) ; if ( in Varnames == null ) in Varnames = new Array List < String > ( ) ; Java Pair RDD < Long Writable , Text > rdd Text = rdd In . map To Pair ( new Convert String To Long Text Pair ( ) ) ; int blksz = Configuration Manager . get Blocksize ( ) ; Matrix Characteristics mc = new Matrix Characteristics ( rlen , clen , blksz , blksz , nnz ) ; Frame Object fo = null ; if ( format . equals ( STRING ) ) { CSV File Format Properties csvprops = ( props != null ) ? ( CSV File Format Properties ) props : new CSV File Format Properties ( ) ; fo = new Frame Object ( Optimizer Utils . get Unique Temp File Name ( ) , new Matrix Format Meta Data ( mc , Output Info . CSV Output Info , Input Info . CSV Input Info ) ) ; fo . set File Format Properties ( csvprops ) ; } else if ( format . equals ( STRING ) ) { if ( rlen == - NUM || clen == - NUM ) { throw new DML Runtime Exception ( STRING + format ) ; } fo = new Frame Object ( null , new Matrix Format Meta Data ( mc , Output Info . Text Cell Output Info , Input Info . Text Cell Input Info ) ) ; } else { throw new DML Runtime Exception ( STRING + format ) ; } if ( props != null ) fo . set File Format Properties ( props ) ; fo . set RDD Handle ( new RDD Object ( rdd Text , var Name ) ) ; fo . set Schema ( STRING ) ; variables . put ( var Name , fo ) ; in Varnames . add ( var Name ) ; check If Registering Input Allowed ( ) ; }
public void check Number Args ( int arg Num ) throws Wrong Number Args Exception { if ( arg Num < NUM ) report Wrong Number Args ( ) ; }
public static String fix Line Feeds ( String sql ) { if ( sql . index Of ( STRING ) == - NUM ) { return sql ; } boolean has Fixes = BOOL ; char [ ] fixed = sql . to Char Array ( ) ; for ( int i = NUM ; i < fixed . length ; i ++ ) { if ( fixed [ i ] == STRING && ( i == fixed . length - NUM || fixed [ i + NUM ] != STRING ) ) { fixed [ i ] = STRING ; has Fixes = BOOL ; } } return has Fixes ? String . value Of ( fixed ) : sql ; }
public int compare To ( Object obj ) { int diff = - NUM ; if ( obj instanceof Parser Notice ) { Parser Notice p2 = ( Parser Notice ) obj ; diff = level - p2 . get Level ( ) ; if ( diff == NUM ) { diff = line - p2 . get Line ( ) ; if ( diff == NUM ) { diff = message . compare To ( p2 . get Message ( ) ) ; } } } return diff ; }
public static String merge Path ( String current , String real Path ) throws Malformed URL Exception { String curr Dir ; if ( current == null || current . index Of ( STRING ) == - NUM ) curr Dir = STRING ; else if ( current . ends With ( STRING ) ) curr Dir = current ; else curr Dir = current . substring ( NUM , current . last Index Of ( STRING ) + NUM ) ; String path ; if ( real Path . starts With ( STRING ) ) path = curr Dir + real Path . substring ( NUM ) ; else if ( real Path . starts With ( STRING ) ) path = real Path ; else if ( ! real Path . starts With ( STRING ) ) path = curr Dir + real Path ; else { while ( real Path . starts With ( STRING ) || curr Dir . length ( ) == NUM ) { real Path = real Path . substring ( NUM ) ; curr Dir = curr Dir . substring ( NUM , curr Dir . length ( ) - NUM ) ; int index = curr Dir . last Index Of ( STRING ) ; if ( index == - NUM ) throw new Malformed URL Exception ( STRING ) ; curr Dir = curr Dir . substring ( NUM , index + NUM ) ; } path = curr Dir + real Path ; } return path ; }
public void rollback ( ) throws SQL Exception { if ( use Connection == null ) { LOG . info ( STRING ) ; return ; } try { use Connection . rollback ( ) ; } catch ( SQL Exception e ) { LOG . warning ( STRING + e . get Message ( ) ) ; throw e ; } }
public byte [ ] to Byte Array ( ) { if ( header Nonce == null || header Tag == null ) { throw new Aws Crypto Exception ( STRING ) ; } final byte [ ] serialized Fields = serialize Authenticated Fields ( ) ; final int out Len = serialized Fields . length + header Nonce . length + header Tag . length ; final Byte Buffer serialized Bytes = Byte Buffer . allocate ( out Len ) ; serialized Bytes . put ( serialized Fields ) ; serialized Bytes . put ( header Nonce ) ; serialized Bytes . put ( header Tag ) ; return serialized Bytes . array ( ) ; }
public boolean contains Key ( Object key ) { return context . get Attribute ( ( String ) key ) != null ; }
private void update Limit ( int limit ) { current Cycle . set Limit ( limit ) ; update Plan Cycles ( ) ; confirm Update . set Text Color ( resources . get Color ( R . color . light gray ) ) ; }
@ Suppress Warnings ( STRING ) public Set < S > descendants ( ) { Set < S > perms = new Hash Set < > ( ) ; for ( S child : children ) { perms . add ( child ) ; perms . add All ( child . descendants ( ) ) ; } return perms ; }
private String extract Url ( String shared Url ) { String final Url ; final Url = shared Url . trim ( ) ; String [ ] possible urls = final Url . split ( STRING ) ; for ( String url : possible urls ) { if ( Network Manager . is Url ( url ) ) { final Url = url ; break ; } } final Url = final Url . substring ( final Url . last Index Of ( STRING ) + NUM ) ; final Url = final Url . substring ( final Url . last Index Of ( STRING ) + NUM ) ; if ( Network Manager . is Url ( STRING + final Url ) && ! Network Manager . is Url ( final Url ) ) { final Url = STRING + final Url ; } if ( final Url . contains ( STRING ) ) { final Url = final Url . substring ( NUM , final Url . index Of ( STRING ) ) ; } if ( final Url . contains ( STRING ) ) { final Url = final Url . substring ( NUM , final Url . index Of ( STRING ) ) ; } if ( final Url . contains ( STRING ) ) { final Url = final Url . substring ( NUM , final Url . index Of ( STRING ) ) ; } return final Url ; }
public Set entry Set ( ) { return map . entry Set ( ) ; }
public static String encode ( String input ) { return Base 64 . encode Base 64 String ( input . get Bytes ( Standard Charsets . UTF 8 ) ) ; }
protected static final String add Escapes ( String str ) { String Buffer retval = new String Buffer ( ) ; char ch ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) { switch ( str . char At ( i ) ) { case NUM : continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; default : if ( ( ch = str . char At ( i ) ) < NUM || ch > NUM ) { String s = STRING + Integer . to String ( ch , NUM ) ; retval . append ( STRING + s . substring ( s . length ( ) - NUM , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . to String ( ) ; }
public void add Split ( String split Label ) { if ( m Disabled ) return ; long now = System Clock . elapsed Realtime ( ) ; m Splits . add ( now ) ; m Split Labels . add ( split Label ) ; }
protected String encode ( final String value ) { try { return URL Encoder . encode ( value , STRING ) ; } catch ( Exception exp ) { return value ; } }
private void check Connect Permission ( ) throws Security Exception { Security Manager security = System . get Security Manager ( ) ; if ( security == null ) return ; if ( security != cache Security Manager ) { ok Context = null ; authcache = new Weak Hash Map < Access Control Context , Reference < Access Control Context > > ( ) ; cache Security Manager = security ; } Access Control Context ctx = Access Controller . get Context ( ) ; if ( ok Context == null || ! ( ok Context . equals ( ctx ) || authcache . contains Key ( ctx ) ) ) { security . check Connect ( ep . get Host ( ) , ep . get Port ( ) ) ; authcache . put ( ctx , new Soft Reference < Access Control Context > ( ctx ) ) ; } ok Context = ctx ; }
private boolean condition L 0 ( String value , int index ) { if ( index == value . length ( ) - NUM && contains ( value , index - NUM , NUM , STRING , STRING , STRING ) ) { return BOOL ; } else if ( ( contains ( value , index - NUM , NUM , STRING , STRING ) || contains ( value , value . length ( ) - NUM , NUM , STRING , STRING ) ) && contains ( value , index - NUM , NUM , STRING ) ) { return BOOL ; } else { return BOOL ; } }
public static Pagination Context from Context ( Routing Context context ) { Http Server Request request = context . request ( ) ; String page Str = request . get Param ( Pagination Context . CURRENT PAGE QUERY PARAM ) ; String per Page Str = request . get Param ( Pagination Context . PER PAGE QUERY PARAM ) ; Integer page = null ; Integer per Page = null ; try { if ( page Str != null ) { page = Integer . parse Int ( page Str ) ; } if ( per Page Str != null ) { per Page = Integer . parse Int ( per Page Str ) ; } } catch ( Number Format Exception e ) { Default Error Handler . bad Request ( context , STRING ) ; } if ( per Page != null && per Page > Pagination Context . MAX PER PAGE ) { Default Error Handler . bad Request ( context , STRING + Pagination Context . PER PAGE QUERY PARAM + STRING + Pagination Context . MAX PER PAGE ) ; } return new Pagination Context ( page , per Page ) ; }
private void update Data Type State ( ) { boolean is Sync Enabled = m Sync Switch Preference . is Checked ( ) ; boolean sync Everything = m Sync Everything . is Checked ( ) ; boolean password Sync Configurable = m Profile Sync Service . is Backend Initialized ( ) && m Profile Sync Service . is Cryptographer Ready ( ) ; for ( Check Box Preference pref : m All Types ) { boolean can Sync Type = pref != m Sync Passwords || password Sync Configurable ; if ( ! is Sync Enabled ) { pref . set Checked ( BOOL ) ; } else if ( sync Everything ) { pref . set Checked ( can Sync Type ) ; } pref . set Enabled ( is Sync Enabled && ! sync Everything && can Sync Type ) ; } if ( is Sync Enabled && ! sync Everything ) { Set < Integer > sync Types = m Profile Sync Service . get Preferred Data Types ( ) ; m Sync Autofill . set Checked ( sync Types . contains ( Model Type . AUTOFILL ) ) ; m Sync Bookmarks . set Checked ( sync Types . contains ( Model Type . BOOKMARKS ) ) ; m Sync Omnibox . set Checked ( sync Types . contains ( Model Type . TYPED URLS ) ) ; m Sync Passwords . set Checked ( password Sync Configurable && sync Types . contains ( Model Type . PASSWORDS ) ) ; m Sync Recent Tabs . set Checked ( sync Types . contains ( Model Type . PROXY TABS ) ) ; m Sync Settings . set Checked ( sync Types . contains ( Model Type . PRIORITY PREFERENCES ) ) ; } }
public static void write Protein Best Matches To File ( String file Path , Map < String , PIRSF Hmmer 2 Raw Match > protein Id Best Match Map ) throws IO Exception { Buffered Writer writer = null ; try { File file = create Tmp File ( file Path ) ; if ( ! file . exists ( ) ) { throw new Illegal State Exception ( STRING + file Path ) ; } writer = new Buffered Writer ( new File Writer ( file ) ) ; for ( String protein Id : protein Id Best Match Map . key Set ( ) ) { PIRSF Hmmer 2 Raw Match best Match = protein Id Best Match Map . get ( protein Id ) ; if ( best Match != null ) { writer . write ( protein Id ) ; writer . write ( STRING ) ; writer . write ( best Match . get Model Id ( ) ) ; writer . write ( STRING ) ; writer . write ( best Match . get Signature Library Release ( ) ) ; writer . write ( STRING ) ; writer . write ( String . value Of ( best Match . get Location Start ( ) ) ) ; writer . write ( STRING ) ; writer . write ( String . value Of ( best Match . get Location End ( ) ) ) ; writer . write ( STRING ) ; writer . write ( String . value Of ( best Match . get Evalue ( ) ) ) ; writer . write ( STRING ) ; writer . write ( String . value Of ( best Match . get Score ( ) ) ) ; writer . write ( STRING ) ; writer . write ( String . value Of ( best Match . get Hmm Start ( ) ) ) ; writer . write ( STRING ) ; writer . write ( String . value Of ( best Match . get Hmm End ( ) ) ) ; writer . write ( STRING ) ; writer . write ( best Match . get Hmm Bounds ( ) ) ; writer . write ( STRING ) ; writer . write ( String . value Of ( best Match . get Location Evalue ( ) ) ) ; writer . write ( STRING ) ; writer . write ( String . value Of ( best Match . get Location Score ( ) ) ) ; writer . write ( STRING ) ; } } } finally { if ( writer != null ) { writer . close ( ) ; } } }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
void refresh UI ( String xml , DOM Tree m tree ) { if ( ( xml == null ) || xml . equals ( STRING ) ) { set Error Message ( STRING , STRING ) ; return ; } final Document new Root = get Root ( xml ) ; if ( new Root == null ) { set Error Message ( STRING , STRING ) ; return ; } m tree . set Document ( new Root ) ; }
private void cleanup Protection Set Volumes ( Protection Set protection Set , List < String > volume I Ds , boolean mark Protection Set For Deletion ) { if ( protection Set != null ) { log . info ( STRING , protection Set . get Label ( ) , volume I Ds . to String ( ) ) ; String Set pset Volumes = protection Set . get Volumes ( ) ; pset Volumes . remove All ( volume I Ds ) ; protection Set . set Volumes ( pset Volumes ) ; if ( mark Protection Set For Deletion ) { protection Set . set Inactive ( BOOL ) ; } db Client . update Object ( protection Set ) ; } }
private static Normalization determine Normalization ( Element model ) { Normalization norm Method = Normalization . NONE ; String norm Name = model . get Attribute ( STRING ) ; if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . SIMPLEMAX ; } else if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . SOFTMAX ; } else if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . LOGIT ; } else if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . PROBIT ; } else if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . CLOGLOG ; } else if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . EXP ; } else if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . LOGLOG ; } else if ( norm Name . equals ( STRING ) ) { norm Method = Normalization . CAUCHIT ; } return norm Method ; }
Operand pop ( Register s ) { Stack < Operand > stack = get ( s ) ; if ( stack == null ) { throw new Optimizing Compiler Exception ( STRING ) ; } else { return stack . pop ( ) ; } }
@ Override public void start Element ( String uri , String local Name , String q Name , Attributes attributes ) throws SAX Exception { element Value = new String Builder ( STRING ) ; element On = BOOL ; if ( local Name . equals ( ITEM TITLE ) ) { episode = new Episode ( ) ; is Item = BOOL ; } if ( local Name . equals Ignore Case ( MP 3 1 ) && is Item ) { episode . set Length ( attributes . get Value ( LENGTH ) ) ; episode . set Audeo Url ( attributes . get Value ( MP 3 3 ) ) ; } }
public static void back And Forth ( HG Search Result < ? > rs , int window Size , int iteration ) { boolean advance = BOOL ; for ( int i = NUM ; i < iteration ; i ++ ) { Object x = rs . current ( ) ; int steps = random ( window Size ) ; steps = forward ( rs , steps ) ; if ( back ( rs , steps ) != steps ) throw new Runtime Exception ( STRING + steps + STRING ) ; if ( ! x . equals ( rs . current ( ) ) ) throw new Runtime Exception ( STRING + steps + STRING + x ) ; if ( advance ) { forward ( rs , random ( window Size ) ) ; if ( ! rs . has Next ( ) ) { back ( rs , random ( window Size ) ) ; advance = BOOL ; } } else { back ( rs , random ( window Size ) ) ; if ( ! rs . has Prev ( ) ) { forward ( rs , random ( window Size ) ) ; advance = BOOL ; } } } }
@ Override public void close ( ) throws IO Exception { synchronized ( lock ) { if ( decoder != null ) { decoder . reset ( ) ; } decoder = null ; if ( in != null ) { in . close ( ) ; in = null ; } } }
public List < String > provide White List ( ) { Linked List < String > white List = new Linked List < > ( ) ; white List . add ( STRING ) ; return white List ; }
public boolean has Name ( final String name ) { for ( final String n : names ) { if ( n . equals Ignore Case ( name ) ) { return BOOL ; } } return BOOL ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { check Is In Multi Or Pipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . get Bulk Reply ( ) ; return Double . value Of ( newscore ) ; }
private String Buffer to Pattern ( String Buffer result , boolean escape Unprintable ) { if ( pat != null ) { int i ; int backslash Count = NUM ; for ( i = NUM ; i < pat . length ( ) ; ) { int c = UTF 16 . char At ( pat , i ) ; i += UTF 16 . get Char Count ( c ) ; if ( escape Unprintable && Utility . is Unprintable ( c ) ) { if ( ( backslash Count % NUM ) == NUM ) { result . set Length ( result . length ( ) - NUM ) ; } Utility . escape Unprintable ( result , c ) ; backslash Count = NUM ; } else { UTF 16 . append ( result , c ) ; if ( c == STRING ) { ++ backslash Count ; } else { backslash Count = NUM ; } } } return result ; } return generate Pattern ( result , escape Unprintable , BOOL ) ; }
private static Version read Workspace Version ( final URL workspace ) { final File version File = get Version File ( workspace , BOOL ) ; if ( version File == null || ! version File . exists ( ) ) { return null ; } try { final Properties props = new Properties ( ) ; final File Input Stream is = new File Input Stream ( version File ) ; try { props . load ( is ) ; } finally { is . close ( ) ; } String version String = props . get Property ( WORKSPACE CHECK REFERENCE BUNDLE NAME ) ; if ( version String != null ) { return Version . parse Version ( version String ) ; } version String = props . get Property ( WORKSPACE CHECK REFERENCE BUNDLE NAME LEGACY ) ; if ( version String != null ) { return Version . parse Version ( version String ) ; } return null ; } catch ( final IO Exception e ) { IDE Workbench Plugin . log ( STRING + version File , new Status ( I Status . ERROR , IDE Workbench Plugin . IDE WORKBENCH , I Status . ERROR , e . get Message ( ) == null ? STRING : e . get Message ( ) , e ) ) ; return null ; } catch ( final Illegal Argument Exception e ) { IDE Workbench Plugin . log ( STRING + version File , new Status ( I Status . ERROR , IDE Workbench Plugin . IDE WORKBENCH , I Status . ERROR , e . get Message ( ) == null ? STRING : e . get Message ( ) , e ) ) ; return null ; } }
public Vector Approximation calculate Approximation ( DBID id , V dv ) { int [ ] approximation = new int [ dv . get Dimensionality ( ) ] ; for ( int d = NUM ; d < split Positions . length ; d ++ ) { final double val = dv . double Value ( d ) ; final int last Border Index = split Positions [ d ] . length - NUM ; if ( val < split Positions [ d ] [ NUM ] ) { approximation [ d ] = NUM ; if ( id != null ) { LOG . warning ( STRING ) ; } } else if ( val > split Positions [ d ] [ last Border Index ] ) { approximation [ d ] = last Border Index - NUM ; if ( id != null ) { LOG . warning ( STRING ) ; } } else { int pos = Arrays . binary Search ( split Positions [ d ] , val ) ; pos = ( pos >= NUM ) ? pos : ( ( - pos ) - NUM ) ; approximation [ d ] = pos ; } } return new Vector Approximation ( id , approximation ) ; }
private boolean check If Volume Size Exceeding Pool Size ( CIM Argument [ ] in Args , CIM Argument [ ] out Args ) { if ( get Volume Size ( in Args ) > get Volume Size ( out Args ) ) { return BOOL ; } return BOOL ; }
@ Suppress Warnings ( STRING ) private void log ( String label , Byte Buffer buffer ) { String Builder sb = new String Builder ( ) ; sb . append ( label ) ; sb . append ( STRING ) ; sb . append ( buffer . get ( NUM ) ) ; sb . append ( STRING ) ; for ( int x = NUM ; x < NUM ; x ++ ) { sb . append ( String . format ( STRING , ( int ) ( buffer . get ( x ) & NUM ) ) ) ; sb . append ( STRING ) ; } m Log . debug ( sb . to String ( ) ) ; }
private void read Object ( Object Input Stream ois ) throws Class Not Found Exception , IO Exception { ois . default Read Object ( ) ; boolean has Font = ois . read Boolean ( ) ; if ( has Font ) { String name = ( String ) ois . read Object ( ) ; int size = ois . read Int ( ) ; int style = ois . read Int ( ) ; font = new Font ( name , style , size ) ; } else { font = OM Text . DEFAULT FONT ; } }
public void add File ( String filename ) { if ( filename != null ) add File ( new File ( filename ) ) ; }
public String format ( Temporal Accessor temporal ) { String Builder buf = new String Builder ( NUM ) ; format To ( temporal , buf ) ; return buf . to String ( ) ; }
public void paint Toggle Button Background ( Synth Context context , Graphics g , int x , int y , int w , int h ) { paint Background ( context , g , x , y , w , h , null ) ; }
void save Device Profile ( @ Nonnull String user , @ Nonnull String realm , @ Nonnull Oath Device Settings device Settings ) throws Auth Login Exception { Reject . if Null ( user , realm , device Settings ) ; try { devices Dao . save Device Profiles ( user , realm , json Utils . to Json Values ( Collections . singleton List ( device Settings ) ) ) ; } catch ( IO Exception e ) { debug . error ( STRING , user , realm , e ) ; throw new Auth Login Exception ( e ) ; } }
protected List < String > parameters To String List ( List < Parameter > parameters ) { List < String > list = new Array List < > ( ) ; for ( Parameter parameter : parameters ) { list . add ( String . format ( STRING , parameter . get Name ( ) , parameter . get Value ( ) ) ) ; } return list ; }
public static boolean is Matching Name ( String name A , String name B ) { int a = name A . length ( ) ; int b = name B . length ( ) ; if ( a == b ) { return name A . equals ( name B ) ; } else if ( a < b - NUM ) { return name B . ends With ( name A ) && name B . char At ( b - a - NUM ) == STRING ; } else if ( b < a - NUM ) { return name A . ends With ( name B ) && name A . char At ( a - b - NUM ) == STRING ; } else { return BOOL ; } }
private void validate Will ( String dest , Object payload ) { if ( ( dest == null ) || ( payload == null ) ) { throw new Illegal Argument Exception ( ) ; } Mqtt Async Client . validate Topic ( dest ) ; }
public static float ccp Calc Rotate ( final CG Point from , final CG Point to ) { float o = to . x - from . x ; float a = to . y - from . y ; float at = cc Macros . CC RADIANS TO DEGREES ( ( float ) Math . atan ( o / a ) ) ; if ( a < NUM ) { if ( o < NUM ) at = NUM + Math . abs ( at ) ; else at = NUM - Math . abs ( at ) ; } return at ; }
public static String clean Tabs ( String yaml ) { if ( yaml . contains ( STRING ) ) { LOGGER . warn ( STRING + STRING + STRING , TAB AS SPACES . length ( ) ) ; List < String > lines = NEWLINE SPLITTER . split To List ( yaml ) ; String Builder sb = new String Builder ( ) ; for ( String line : lines ) { String clean Line = replace Starting Tabs With Spaces ( line ) ; sb . append ( clean Line ) ; sb . append ( STRING ) ; } return sb . to String ( ) ; } else { return yaml ; } }
private static Paint darker Radial Gradient Paint ( Radial Gradient Paint paint ) { final Color [ ] paint Colors = paint . get Colors ( ) ; for ( int i = NUM ; i < paint Colors . length ; i ++ ) { paint Colors [ i ] = darker ( paint Colors [ i ] ) ; } return new Radial Gradient Paint ( paint . get Center Point ( ) , paint . get Radius ( ) , paint . get Focus Point ( ) , paint . get Fractions ( ) , paint Colors , paint . get Cycle Method ( ) , paint . get Color Space ( ) , paint . get Transform ( ) ) ; }
private void check And Set Fast Path Status ( ) { boolean fast Path Was On = is Fast Path ; if ( ( rounding Mode == Rounding Mode . HALF EVEN ) && ( is Grouping Used ( ) ) && ( grouping Size == NUM ) && ( multiplier == NUM ) && ( ! decimal Separator Always Shown ) && ( ! use Exponential Notation ) ) { is Fast Path = ( ( minimum Integer Digits == NUM ) && ( maximum Integer Digits >= NUM ) ) ; if ( is Fast Path ) { if ( is Currency Format ) { if ( ( minimum Fraction Digits != NUM ) || ( maximum Fraction Digits != NUM ) ) is Fast Path = BOOL ; } else if ( ( minimum Fraction Digits != NUM ) || ( maximum Fraction Digits != NUM ) ) is Fast Path = BOOL ; } } else is Fast Path = BOOL ; if ( is Fast Path ) { if ( fast Path Data == null ) fast Path Data = new Fast Path Data ( ) ; fast Path Data . zero Delta = symbols . get Zero Digit ( ) - STRING ; fast Path Data . grouping Char = symbols . get Grouping Separator ( ) ; fast Path Data . fractional Max Int Bound = ( is Currency Format ) ? NUM : NUM ; fast Path Data . fractional Scale Factor = ( is Currency Format ) ? NUM : NUM ; fast Path Data . positive Affixes Required = ( positive Prefix . length ( ) != NUM ) || ( positive Suffix . length ( ) != NUM ) ; fast Path Data . negative Affixes Required = ( negative Prefix . length ( ) != NUM ) || ( negative Suffix . length ( ) != NUM ) ; int max Nb Integral Digits = NUM ; int max Nb Groups = NUM ; int container Size = Math . max ( positive Prefix . length ( ) , negative Prefix . length ( ) ) + max Nb Integral Digits + max Nb Groups + NUM + maximum Fraction Digits + Math . max ( positive Suffix . length ( ) , negative Suffix . length ( ) ) ; fast Path Data . fast Path Container = new char [ container Size ] ; fast Path Data . chars Positive Suffix = positive Suffix . to Char Array ( ) ; fast Path Data . chars Negative Suffix = negative Suffix . to Char Array ( ) ; fast Path Data . chars Positive Prefix = positive Prefix . to Char Array ( ) ; fast Path Data . chars Negative Prefix = negative Prefix . to Char Array ( ) ; int longest Prefix Length = Math . max ( positive Prefix . length ( ) , negative Prefix . length ( ) ) ; int decimal Point Index = max Nb Integral Digits + max Nb Groups + longest Prefix Length ; fast Path Data . integral Last Index = decimal Point Index - NUM ; fast Path Data . fractional First Index = decimal Point Index + NUM ; fast Path Data . fast Path Container [ decimal Point Index ] = is Currency Format ? symbols . get Monetary Decimal Separator ( ) : symbols . get Decimal Separator ( ) ; } else if ( fast Path Was On ) { fast Path Data . fast Path Container = null ; fast Path Data . chars Positive Suffix = null ; fast Path Data . chars Negative Suffix = null ; fast Path Data . chars Positive Prefix = null ; fast Path Data . chars Negative Prefix = null ; } fast Path Check Needed = BOOL ; }
public void test key Builder ascii order ( ) { Key Builder key Builder = ( Key Builder ) Key Builder . new Instance ( ) ; KVO < String > [ ] a = new KVO [ ] { new KVO < String > ( Test Key Builder . as Sort Key ( STRING ) , null , STRING ) , new KVO < String > ( Test Key Builder . as Sort Key ( STRING ) , null , STRING ) , new KVO < String > ( Test Key Builder . as Sort Key ( STRING ) , null , STRING ) , new KVO < String > ( Test Key Builder . as Sort Key ( STRING ) , null , STRING ) } ; Arrays . sort ( a ) ; assert Equals ( STRING , a [ NUM ] . obj ) ; assert Equals ( STRING , a [ NUM ] . obj ) ; assert Equals ( STRING , a [ NUM ] . obj ) ; assert Equals ( STRING , a [ NUM ] . obj ) ; }
public boolean is Click Touch Screen ( ) { String s = Device Info . get Software Version ( ) ; if ( s . length ( ) > NUM ) { int v = Integer . parse Int ( s . substring ( NUM , NUM ) ) ; return v <= NUM ; } return BOOL ; }
public DOM Test Document Builder Factory new Instance ( Document Builder Setting [ ] new Settings ) throws DOM Test Incompatible Exception { if ( new Settings == null ) { return this ; } Document Builder Setting [ ] merged Settings = merge Settings ( new Settings ) ; return new LS Document Builder Factory ( merged Settings ) ; }
public void reset ( ) { index = NUM ; if ( file != null ) { list Index = NUM ; if ( ! written ) { write All Rows ( ) ; written = BOOL ; } list . clear ( ) ; file . seek ( File Store . HEADER LENGTH ) ; } }
public void add ( Geometry Function func ) { functions . add ( func ) ; sorted Functions . put ( func . get Name ( ) , func ) ; categorized Functions . put ( func . get Category ( ) , func . get Name ( ) , func ) ; if ( has Geometry Result ( func ) ) categorized Geometry Functions . put ( func . get Category ( ) , func . get Name ( ) , func ) ; }
public void fire State Changed ( ) { Change Event e = new Change Event ( this ) ; for ( Change Listener listener : listeners ) { listener . state Changed ( e ) ; } }
public static Clusters convert To Clusters ( Graph cluster Graph , List < Node > measured Variables ) { List < String > latents = new Array List < > ( ) ; Clusters clusters = new Clusters ( ) ; cluster Graph = Graph Utils . replace Nodes ( cluster Graph , measured Variables ) ; for ( Node node : cluster Graph . get Nodes ( ) ) { if ( ! measured Variables . contains ( node ) ) { latents . add ( node . get Name ( ) ) ; } } Collections . sort ( latents ) ; for ( int i = NUM ; i < latents . size ( ) ; i ++ ) { String name = latents . get ( i ) ; clusters . set Cluster Name ( i , name ) ; Node latent = cluster Graph . get Node ( name ) ; List < Node > measured = cluster Graph . get Nodes Out To ( latent , Endpoint . ARROW ) ; for ( Node node : measured ) { if ( measured Variables . contains ( node ) ) { clusters . add To Cluster ( i , node . get Name ( ) ) ; } } } return clusters ; }
final short rlshort ( Data Input Stream dis ) throws IO Exception { short s = NUM ; short high , low ; s = dis . read Short ( ) ; high = ( short ) ( ( s & NUM ) << NUM ) ; low = ( short ) ( ( s & NUM ) > > > NUM ) ; s = ( short ) ( high | low ) ; return s ; }
public void encode Cell ( mx I Cell cell , Node node , boolean include Children ) { node . append Child ( encode ( cell ) ) ; if ( include Children ) { int child Count = cell . get Child Count ( ) ; for ( int i = NUM ; i < child Count ; i ++ ) { encode Cell ( cell . get Child At ( i ) , node , include Children ) ; } } }
public Date Time Formatter with Locale ( Locale locale ) { if ( locale == get Locale ( ) || ( locale != null && locale . equals ( get Locale ( ) ) ) ) { return this ; } return new Date Time Formatter ( i Printer , i Parser , locale , i Offset Parsed , i Chrono , i Zone , i Pivot Year , i Default Year ) ; }
public void test Iterate ( ) { final Range range = create Range ( NUM , NUM ) ; int next = NUM ; final Iterator iter = range . iterator ( ) ; while ( iter . has Next ( ) ) { final Object value = iter . next ( ) ; assert Equals ( STRING , create Value ( next ++ ) , value ) ; } assert Equals ( STRING , NUM , next ) ; try { iter . next ( ) ; fail ( STRING ) ; } catch ( No Such Element Exception ignore ) { } }
public String next String ( char quote ) throws JSON Exception { char c ; String Builder sb = new String Builder ( ) ; for ( ; ; ) { c = next ( ) ; switch ( c ) { case NUM : case STRING : case STRING : throw syntax Error ( STRING ) ; case STRING : c = next ( ) ; switch ( c ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( ( char ) Integer . parse Int ( next ( NUM ) , NUM ) ) ; break ; case STRING : case STRING : case STRING : case STRING : sb . append ( c ) ; break ; default : throw syntax Error ( STRING ) ; } break ; default : if ( c == quote ) { return sb . to String ( ) ; } sb . append ( c ) ; } } }
public static Response parse XML ( String xml ) throws SAML Exception { Document doc = XML Utils . to DOM Document ( xml , SAML Utils . debug ) ; Element root = doc . get Document Element ( ) ; return new Response ( root ) ; }
public static void d ( String tag , String msg , Object ... args ) { if ( s Level > LEVEL DEBUG ) { return ; } if ( args . length > NUM ) { msg = String . format ( msg , args ) ; } Log . d ( tag , msg ) ; }
public Compiled SQL register Param Type ( String param Name , String data Type ) { if ( param Types == null ) { param Types = new Hash Map ( ) ; } param Types . put ( param Name , data Type ) ; return this ; }
public void begin Step ( int step , String step Title , Logging logger ) { set Processed ( step - NUM ) ; this . step Title = step Title ; logger . progress ( this ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return BOOL ; } else if ( ! ( obj instanceof Method Desc ) ) { return BOOL ; } Method Desc od = ( Method Desc ) obj ; return ( ( name == null ? od . name == null : name . equals ( od . name ) ) && Arrays . equals ( types , od . types ) && ( constraints == null ? od . constraints == null : constraints . equals ( od . constraints ) ) ) ; }
public Set < String > add Content ( Dialogue State new State ) { if ( ! paused ) { cur State . add To State ( new State ) ; return update ( ) ; } else { log . info ( STRING + new State ) ; return Collections . empty Set ( ) ; } }
public long remove Index ( int index ) { if ( index >= size ) throw new Index Out Of Bounds Exception ( String . value Of ( index ) ) ; long [ ] items = this . items ; long value = items [ index ] ; size -- ; if ( ordered ) System . arraycopy ( items , index + NUM , items , index , size - index ) ; else items [ index ] = items [ size ] ; return value ; }
public FD Model load Model ( String filename , String cwd ) { String fn = filename ; if ( fn == null ) return null ; if ( ! fn . ends With ( STRING + file Extension ) ) { fn += STRING + file Extension ; } Model Persistence Handler persistence Handler = create Model Persistence Handler ( resource Set Provider . get ( ) ) ; return ( FD Model ) persistence Handler . load Model ( fn , cwd ) ; }
public boolean save Current Configuration ( ) { if ( current Config . to String ( ) == null ) { return ( BOOL ) ; } int answer = J Option Pane . show Confirm Dialog ( null , STRING , STRING , J Option Pane . YES NO CANCEL OPTION , J Option Pane . QUESTION MESSAGE , Icons . get Image Icon ( STRING ) ) ; if ( answer == J Option Pane . CANCEL OPTION ) { return ( BOOL ) ; } else if ( answer == J Option Pane . NO OPTION ) { return ( BOOL ) ; } return ( save Current Configuration As ( BOOL ) ) ; }
public static double [ ] normalise ( double [ ] init Probs ) { for ( int i = NUM ; i < init Probs . length ; i ++ ) { if ( init Probs [ i ] < NUM ) { init Probs [ i ] = NUM ; } } double sum = NUM ; for ( double prob : init Probs ) { sum += prob ; } double [ ] result = new double [ init Probs . length ] ; if ( sum > NUM ) { for ( int i = NUM ; i < init Probs . length ; i ++ ) { result [ i ] = init Probs [ i ] / sum ; } } else { for ( int i = NUM ; i < init Probs . length ; i ++ ) { result [ i ] = NUM / init Probs . length ; } } return result ; }
public void track ( File file , Object marker , File Delete Strategy delete Strategy ) { if ( file == null ) { throw new Null Pointer Exception ( STRING ) ; } add Tracker ( file . get Path ( ) , marker , delete Strategy ) ; }
protected String Builder append Search String Param If Necessary ( String Builder sb ) { String search String Param = get Encoded Search String Param ( ) ; if ( search String Param != null ) { if ( sb . index Of ( STRING ) == - NUM ) { sb . append ( STRING ) ; } else { sb . append ( STRING ) ; } sb . append ( search String Param ) ; } return sb ; }
public static Class Info find Or Create Class ( String full Name ) { Class Info u = find Class ( full Name ) ; if ( u == null ) { u = new Class Info ( full Name ) ; if ( u . is Array ( ) ) { find Or Create Class ( full Name . substring ( NUM ) ) ; } } return u ; }
Pla Point Rational ( Big Integer p x , Big Integer p y , Big Integer p z ) { rp x = p x ; rp y = p y ; rp z = p z ; is nan = p z . signum ( ) <= NUM ; }
public boolean is Null Value ( ) { return String Utils . trim To Null ( value ) == null && String Utils . trim To Null ( comment ) == null ; }
private Map < Long , Pair < String , Long > > recover Pending Large Messages ( ) throws Exception { Map < Long , Pair < String , Long > > large Messages = new Hash Map < > ( ) ; List < String > filenames = large Messages Factory . list Files ( STRING ) ; List < Long > id List = new Array List < > ( ) ; for ( String filename : filenames ) { Long id = get Large Message Id From Filename ( filename ) ; if ( ! large Messages To Delete . contains ( id ) ) { id List . add ( id ) ; Sequential File seq File = large Messages Factory . create Sequential File ( filename ) ; long size = seq File . size ( ) ; large Messages . put ( id , new Pair < > ( filename , size ) ) ; } } return large Messages ; }
private void check For Fragment ID ( Attributes attributes ) { if ( ! m should Process ) { if ( ( null != attributes ) && ( null != m fragment ID String ) ) { int n = attributes . get Length ( ) ; for ( int i = NUM ; i < n ; i ++ ) { String name = attributes . get Q Name ( i ) ; if ( name . equals ( Constants . ATTRNAME ID ) ) { String val = attributes . get Value ( i ) ; if ( val . equals Ignore Case ( m fragment ID String ) ) { m should Process = BOOL ; m fragment ID = m element ID ; } } } } } }
public void unparsed Entity Decl ( String name , XML Resource Identifier identifier , String notation , Augmentations augs ) throws XNI Exception { try { if ( fDTD Handler != null ) { String public Id = identifier . get Public Id ( ) ; String system Id = f Resolve DTDUR Is ? identifier . get Expanded System Id ( ) : identifier . get Literal System Id ( ) ; fDTD Handler . unparsed Entity Decl ( name , public Id , system Id , notation ) ; } } catch ( SAX Exception e ) { throw new XNI Exception ( e ) ; } }
public void wait For Paxos To Finish ( ) { propose Lock . lock ( ) ; can Propose . await Uninterruptibly ( ) ; propose Lock . unlock ( ) ; }
public static Response Data parse ( String response Data ) { int index = response Data . index Of ( STRING ) ; String main Data , extra Data ; if ( - NUM == index ) { main Data = response Data ; extra Data = STRING ; } else { main Data = response Data . substring ( NUM , index ) ; extra Data = index >= response Data . length ( ) ? STRING : response Data . substring ( index + NUM ) ; } String [ ] fields = Text Utils . split ( main Data , Pattern . quote ( STRING ) ) ; if ( fields . length < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } Response Data data = new Response Data ( ) ; data . extra = extra Data ; data . response Code = Integer . parse Int ( fields [ NUM ] ) ; data . nonce = Integer . parse Int ( fields [ NUM ] ) ; data . package Name = fields [ NUM ] ; data . version Code = fields [ NUM ] ; data . user Id = fields [ NUM ] ; data . timestamp = Long . parse Long ( fields [ NUM ] ) ; return data ; }
public static double [ ] vector Box Corner ( double [ ] center , double [ ] result , double distance , boolean upper Right ) { if ( result == null || result . length != center . length ) { result = new double [ center . length ] ; } if ( upper Right == BOOL ) { distance = - distance ; } distance = SIN PI DIV 4 * distance ; for ( int i = NUM ; i < center . length ; i ++ ) { result [ i ] = center [ i ] + distance ; } return result ; }
public void test Set Login Config Adding ( ) throws Exception { String xml = WEBAPP TEST HEADER + STRING ; Web Xml web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( xml . get Bytes ( STRING ) ) , get Entity Resolver ( ) ) ; Web Xml Utils . set Login Config ( web Xml , STRING , STRING ) ; assert True ( Web Xml Utils . has Login Config ( web Xml ) ) ; assert Equals ( STRING , Web Xml Utils . get Login Config Auth Method ( web Xml ) ) ; }
public void validate ( ) throws AM Console Exception { if ( is Selected ( ) ) { if ( is Personal Question ( ) ) { if ( ( question . length ( ) == NUM ) || ( answer . length ( ) == NUM ) ) { throw new AM Console Exception ( STRING ) ; } } else { if ( answer . length ( ) == NUM ) { throw new AM Console Exception ( STRING ) ; } } } }
public static void assert True ( boolean b , Object message ) { if ( ! b ) { throw Error ( message ) ; } }
private String [ ] spliterator ( String phrase ) { String [ ] split = phrase . split ( STRING ) ; String [ ] out = new String [ split . length ] ; for ( int ix = NUM ; ix < split . length ; ix ++ ) { String temp = split [ ix - NUM ] ; temp += STRING + split [ ix ] ; out [ ix - NUM ] = temp ; } return out ; }
protected Signature ( String algorithm ) { this . algorithm = algorithm ; }
private final void augment Token List ( ) { Token [ ] temp = new Token [ size + increment ] ; System . arraycopy ( token List , NUM , temp , NUM , size ) ; size += increment ; token List = temp ; for ( int i = NUM ; i < increment ; i ++ ) { token List [ size - i - NUM ] = create Internal Use Only Token ( ) ; } }
public String calculate From String ( String data ) throws Exception { log . trace ( STRING , algo URI , data ) ; return calculate From Bytes ( data . get Bytes ( Standard Charsets . UTF 8 ) ) ; }
public void add Channels ( List < Channel > channels ) { for ( Channel channel : channels ) { add Channel ( channel ) ; } }
public static String [ ] merge String Arrays ( String [ ] array 1 , String [ ] array 2 ) { if ( Object Utils . is Empty ( array 1 ) ) { return array 2 ; } if ( Object Utils . is Empty ( array 2 ) ) { return array 1 ; } List < String > result = new Array List < String > ( ) ; result . add All ( Arrays . as List ( array 1 ) ) ; for ( String str : array 2 ) { if ( ! result . contains ( str ) ) { result . add ( str ) ; } } return to String Array ( result ) ; }
public void test Run After Both exceptional Completion ( ) throws Throwable { for ( Execution Mode m : Execution Mode . values ( ) ) for ( boolean f First : new boolean [ ] { BOOL , BOOL } ) for ( boolean fail First : new boolean [ ] { BOOL , BOOL } ) for ( Integer v1 : new Integer [ ] { NUM , null } ) { final Completable Future < Integer > f = new Completable Future < > ( ) ; final Completable Future < Integer > g = new Completable Future < > ( ) ; final CF Exception ex = new CF Exception ( ) ; final Noop r1 = new Noop ( m ) ; final Noop r2 = new Noop ( m ) ; final Noop r3 = new Noop ( m ) ; final Completable Future < Integer > fst = f First ? f : g ; final Completable Future < Integer > snd = ! f First ? f : g ; final Callable < Boolean > complete 1 = fail First ? null : null ; final Callable < Boolean > complete 2 = fail First ? null : null ; final Completable Future < Void > h1 = m . run After Both ( f , g , r1 ) ; assert True ( complete 1 . call ( ) ) ; final Completable Future < Void > h2 = m . run After Both ( f , g , r2 ) ; check Incomplete ( h1 ) ; check Incomplete ( h2 ) ; assert True ( complete 2 . call ( ) ) ; final Completable Future < Void > h3 = m . run After Both ( f , g , r3 ) ; check Completed With Wrapped Exception ( h1 , ex ) ; check Completed With Wrapped Exception ( h2 , ex ) ; check Completed With Wrapped Exception ( h3 , ex ) ; r1 . assert Not Invoked ( ) ; r2 . assert Not Invoked ( ) ; r3 . assert Not Invoked ( ) ; check Completed Normally ( fail First ? snd : fst , v1 ) ; check Completed Exceptionally ( fail First ? fst : snd , ex ) ; } }
private double damp ( double value ) { return Math . sqrt ( value ) ; }
public void add Measurement ( double measurement ) { double keep Constant = NUM - m Decay Constant ; if ( m Count > m Cutover ) { m Value = Math . exp ( keep Constant * Math . log ( m Value ) + m Decay Constant * Math . log ( measurement ) ) ; } else if ( m Count > NUM ) { double retained = keep Constant * m Count / ( m Count + NUM ) ; double newcomer = NUM - retained ; m Value = Math . exp ( retained * Math . log ( m Value ) + newcomer * Math . log ( measurement ) ) ; } else { m Value = measurement ; } m Count ++ ; }
@ Suppress Warnings ( STRING ) private String next Unquoted Value ( ) throws IO Exception { String Builder builder = null ; int i = NUM ; find Non Literal Character : while ( BOOL ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case STRING : case STRING : case STRING : case STRING : case STRING : check Lenient ( ) ; case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : break find Non Literal Character ; } } if ( i < buffer . length ) { if ( fill Buffer ( i + NUM ) ) { continue ; } else { break ; } } if ( builder == null ) { builder = new String Builder ( ) ; } builder . append ( buffer , pos , i ) ; pos += i ; i = NUM ; if ( ! fill Buffer ( NUM ) ) { break ; } } String result ; if ( builder == null ) { result = new String ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . to String ( ) ; } pos += i ; return result ; }
public long arg end ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
static List < I Runtime Classpath Entry > compute Classpath ( I Java Project java Project ) throws Core Exception { I Runtime Classpath Entry [ ] unresolved Runtime Classpath = Java Runtime . compute Unresolved Runtime Classpath ( java Project ) ; List < I Runtime Classpath Entry > resolved Runtime Classpath = new Array List < I Runtime Classpath Entry > ( ) ; for ( I Runtime Classpath Entry unresolved Classpath Entry : unresolved Runtime Classpath ) { if ( Java Runtime . is VM Install Reference ( unresolved Classpath Entry ) ) { continue ; } resolved Runtime Classpath . add All ( Arrays . as List ( Java Runtime . resolve Runtime Classpath Entry ( unresolved Classpath Entry , java Project ) ) ) ; } try { resolved Runtime Classpath . add All ( NUM , GWT Project Utilities . get GWT Source Folder Paths From Project And Dependencies ( java Project , BOOL ) ) ; } catch ( Sdk Exception e ) { throw new Core Exception ( new Status ( I Status . ERROR , GWT Plugin . PLUGIN ID , e . get Localized Message ( ) , e ) ) ; } Gwt Sdk gwt Runtime = Gwt Sdk . find Sdk For ( java Project ) ; if ( gwt Runtime == null ) { GWT Plugin Log . log Warning ( STRING + java Project . get Element Name ( ) + STRING ) ; return resolved Runtime Classpath ; } I Status validation Status = gwt Runtime . validate ( ) ; if ( ! validation Status . is OK ( ) ) { GWT Plugin Log . log Warning ( STRING + java Project . get Element Name ( ) + STRING + validation Status . get Message ( ) + STRING ) ; return resolved Runtime Classpath ; } try { File gwt Dev Jar = gwt Runtime . get Dev Jar ( ) ; resolved Runtime Classpath . add ( Java Runtime . new Archive Runtime Classpath Entry ( Path . from OS String ( gwt Dev Jar . get Absolute Path ( ) ) ) ) ; } catch ( Sdk Exception e ) { GWT Plugin Log . log Warning ( e , STRING ) ; } return resolved Runtime Classpath ; }
@ Suppress Warnings ( STRING ) public Throwing Mock Token Filter Factory ( Map < String , String > args ) { super ( args ) ; String exception Class Name = args . get ( STRING ) ; if ( exception Class Name == null ) { throw new Runtime Exception ( STRING ) ; } try { exception Class = ( Class < ? extends Runtime Exception > ) Class . for Name ( exception Class Name ) ; } catch ( Class Not Found Exception e ) { throw new Runtime Exception ( e ) ; } }
public boolean is Navigation At Bottom ( ) { return ( m Smallest Width Dp >= NUM || m In Portrait ) ; }
public Pattern Guard Expr ( String namespace , String name , List < Expression > parameters , Pattern Expr guarded Pattern ) { super ( namespace , name , parameters ) ; this . guarded = new Array List < Pattern Expr > ( ) ; guarded . add ( guarded Pattern ) ; }
private long start New Track ( ) { if ( is Recording ( ) ) { Log . d ( TAG , STRING ) ; return - NUM ; } long now = System . current Time Millis ( ) ; track Trip Statistics Updater = new Trip Statistics Updater ( now ) ; marker Trip Statistics Updater = new Trip Statistics Updater ( now ) ; Track track = new Track ( ) ; Uri uri = my Tracks Provider Utils . insert Track ( track ) ; long track Id = Long . parse Long ( uri . get Last Path Segment ( ) ) ; update Recording State ( track Id , BOOL ) ; Preferences Utils . set Int ( this , R . string . auto resume track current retry key , NUM ) ; Preferences Utils . set Int ( this , R . string . activity recognition type key , Preferences Utils . ACTIVITY RECOGNITION TYPE DEFAULT ) ; track . set Id ( track Id ) ; track . set Name ( Track Name Utils . get Track Name ( this , track Id , now , null ) ) ; String category = Preferences Utils . get String ( this , R . string . default activity key , Preferences Utils . DEFAULT ACTIVITY DEFAULT ) ; track . set Category ( category ) ; track . set Icon ( Track Icon Utils . get Icon Value ( this , category ) ) ; track . set Trip Statistics ( track Trip Statistics Updater . get Trip Statistics ( ) ) ; my Tracks Provider Utils . update Track ( track ) ; insert Waypoint ( Waypoint Creation Request . DEFAULT START TRACK ) ; start Recording ( BOOL ) ; return track Id ; }
protected Abstract MR Message poll Message ( ) { if ( disable Poll ) { return null ; } if ( ! poll Queue . is Empty ( ) ) { Poll Message pm = poll Queue . peek ( ) ; if ( pm != null ) { return pm . get Message ( ) ; } } return null ; }
public static byte [ ] read Fully ( Input Stream in ) throws IO Exception { try { return read Fully No Close ( in ) ; } finally { in . close ( ) ; } }
private boolean is Suppress Warnings Test ( String base Name ) { return base Name . equals ( STRING ) ; }
protected static String apply Limit Clause ( final String query , int limit , final int query Result Set Limit ) { Matcher matcher = SELECT EXPR PATTERN . matcher ( query ) ; if ( matcher . matches ( ) ) { Matcher limit matcher = SELECT WITH LIMIT EXPR PATTERN . matcher ( query ) ; boolean query Already Has Limit Clause = limit matcher . matches ( ) ; if ( ! query Already Has Limit Clause ) { if ( limit == NUM ) { limit = query Result Set Limit ; } String result = query ; result += STRING + limit ; return result ; } } return query ; }
public void unmaximise Component ( ) { if ( maximised Component == null ) { return ; } container . remove ( maximised Component ) ; container . add ( container Child ) ; parent Maximised Component . add ( maximised Component ) ; container . validate ( ) ; container Child = null ; parent Maximised Component = null ; maximised Component = null ; }
default Char Seq join ( Char Sequence delimiter , Char Sequence prefix , Char Sequence suffix ) { String Builder string Builder = new String Builder ( prefix ) ; for Each ( null ) ; string Builder . append ( suffix ) ; return Char Seq . of ( string Builder . to String ( ) ) ; }
public void remove Listener ( T listener ) { if ( listeners != null ) { List < T > newlisteners = new Array List < T > ( ) ; newlisteners . add All ( listeners ) ; newlisteners . remove ( listener ) ; listeners = newlisteners ; } }
public static void save As ASCII ( NS Array root , File out ) throws IO Exception { Output Stream Writer w = new Output Stream Writer ( new File Output Stream ( out ) , STRING ) ; w . write ( root . to ASCII Property List ( ) ) ; w . close ( ) ; }
public XS Wildcard Decl perform Intersection With ( XS Wildcard Decl wildcard , short process Contents ) { if ( wildcard == null ) return null ; XS Wildcard Decl intersect Wildcard = new XS Wildcard Decl ( ) ; intersect Wildcard . f Process Contents = process Contents ; if ( are Same ( wildcard ) ) { intersect Wildcard . f Type = f Type ; intersect Wildcard . f Namespace List = f Namespace List ; } else if ( ( f Type == NSCONSTRAINT ANY ) || ( wildcard . f Type == NSCONSTRAINT ANY ) ) { XS Wildcard Decl other = this ; if ( f Type == NSCONSTRAINT ANY ) other = wildcard ; intersect Wildcard . f Type = other . f Type ; intersect Wildcard . f Namespace List = other . f Namespace List ; } else if ( ( ( f Type == NSCONSTRAINT NOT ) && ( wildcard . f Type == NSCONSTRAINT LIST ) ) || ( ( f Type == NSCONSTRAINT LIST ) && ( wildcard . f Type == NSCONSTRAINT NOT ) ) ) { String [ ] list = null ; String [ ] other = null ; if ( f Type == NSCONSTRAINT NOT ) { other = f Namespace List ; list = wildcard . f Namespace List ; } else { other = wildcard . f Namespace List ; list = f Namespace List ; } int list Size = list . length ; String [ ] intersect = new String [ list Size ] ; int new Size = NUM ; for ( int i = NUM ; i < list Size ; i ++ ) { if ( list [ i ] != other [ NUM ] && list [ i ] != ABSENT ) intersect [ new Size ++ ] = list [ i ] ; } intersect Wildcard . f Type = NSCONSTRAINT LIST ; intersect Wildcard . f Namespace List = new String [ new Size ] ; System . arraycopy ( intersect , NUM , intersect Wildcard . f Namespace List , NUM , new Size ) ; } else if ( ( f Type == NSCONSTRAINT LIST ) && ( wildcard . f Type == NSCONSTRAINT LIST ) ) { intersect Wildcard . f Type = NSCONSTRAINT LIST ; intersect Wildcard . f Namespace List = intersect 2 sets ( f Namespace List , wildcard . f Namespace List ) ; } else if ( f Type == NSCONSTRAINT NOT && wildcard . f Type == NSCONSTRAINT NOT ) { if ( f Namespace List [ NUM ] != ABSENT && wildcard . f Namespace List [ NUM ] != ABSENT ) return null ; XS Wildcard Decl other = this ; if ( f Namespace List [ NUM ] == ABSENT ) other = wildcard ; intersect Wildcard . f Type = other . f Type ; intersect Wildcard . f Namespace List = other . f Namespace List ; } return intersect Wildcard ; }
public static void filter Outbound ( String Builder message ) { for ( int i = NUM ; i < message . length ( ) ; i ++ ) { char current Char = message . char At ( i ) ; if ( LEGAL CHARACTERS . index Of ( current Char ) == - NUM ) { if ( current Char > NUM ) { int char As Int = current Char ; String string Version = Integer . to String ( char As Int , NUM ) ; String replacement = STRING + string Version + STRING ; message . replace ( i , i + NUM , replacement ) ; i += replacement . length ( ) - NUM ; } else { message . delete Char At ( i ) ; i -- ; } } } }
private void draw Days ( Canvas canvas ) { final Text Paint p = m Day Paint ; final int header Height = m Month Height + m Day Of Week Height ; final int row Height = m Day Height ; final int col Width = m Cell Width ; final float half Line Height = ( p . ascent ( ) + p . descent ( ) ) / NUM ; int row Center = header Height + row Height / NUM ; for ( int day = NUM , col = find Day Offset ( ) ; day <= m Days In Month ; day ++ ) { final int col Center = col Width * col + col Width / NUM ; final int col Center Rtl ; if ( View Compat Utils . is Layout Rtl ( this ) ) { col Center Rtl = m Padded Width - col Center ; } else { col Center Rtl = col Center ; } int state = NUM ; final boolean is Day Enabled = is Day Enabled ( day ) ; final boolean is Day Activated = m Activated Day == day ; if ( is Day Activated ) { state = VIEW STATE SELECTED ; canvas . draw Circle ( col Center Rtl , row Center , m Day Selector Radius , m Day Selector Paint ) ; } else if ( m Touched Item == day ) { state = VIEW STATE PRESSED ; if ( is Day Enabled ) { canvas . draw Circle ( col Center Rtl , row Center , m Day Selector Radius , m Day Highlight Paint ) ; } } final boolean is Day Today = m Today == day ; final int day Text Color ; if ( is Day Today && ! is Day Activated ) { day Text Color = m Day Selector Paint . get Color ( ) ; } else { final int [ ] state Set = build State ( is Day Enabled , state ) ; day Text Color = m Day Text Color . get Color For State ( state Set , NUM ) ; } p . set Color ( day Text Color ) ; canvas . draw Text ( m Day Formatter . format ( day ) , col Center Rtl , row Center - half Line Height , p ) ; col ++ ; if ( col == DAYS IN WEEK ) { col = NUM ; row Center += row Height ; } } }
public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAX Exception { if ( ch == null || start < NUM || length >= ( ch . length - start ) || length < NUM ) return ; append ( m doc . create Comment ( new String ( ch , start , length ) ) ) ; }
public boolean is Empty ( ) { return array List . is Empty ( ) ; }
public Arbitrary Length Path Node ( final Term Node left , final Term Node right , final Var Node t Var Left , final Var Node t Var Right , final Path Mod mod ) { this ( new B Op [ ] { new Join Group Node ( ) } , NV . as Map ( new NV ( Annotations . LEFT TERM , left ) , new NV ( Annotations . RIGHT TERM , right ) , new NV ( Annotations . TRANSITIVITY VAR LEFT , t Var Left ) , new NV ( Annotations . TRANSITIVITY VAR RIGHT , t Var Right ) , new NV ( Annotations . LOWER BOUND , mod == Path Mod . ONE OR MORE ? NUM : NUM ) , new NV ( Annotations . UPPER BOUND , mod == Path Mod . ZERO OR ONE ? NUM : Long . MAX VALUE ) ) ) ; final Set < Var Node > drop Vars = new Linked Hash Set < > ( ) ; drop Vars . add ( t Var Left ) ; drop Vars . add ( t Var Right ) ; set Property ( Annotations . DROP VARS , drop Vars ) ; }
static void check Flags ( int flags ) { int allowed Flags = READ ONLY FLAG MASK | EMPTY FLAG MASK | COMPACT FLAG MASK | ORDERED FLAG MASK ; int flags Mask = ~ allowed Flags ; if ( ( flags & flags Mask ) > NUM ) { throw new Sketches Argument Exception ( STRING + Integer . to Binary String ( flags ) ) ; } }
public boolean can Get Int ( ) { return can Get ( int . class ) ; }
public static Array List < Object > delete Item Sets ( Array List < Object > item Sets , int min Support , int max Support ) { Array List < Object > new Vector = new Array List < Object > ( item Sets . size ( ) ) ; for ( int i = NUM ; i < item Sets . size ( ) ; i ++ ) { Labeled Item Set current = ( Labeled Item Set ) item Sets . get ( i ) ; if ( ( current . m rule Sup Counter >= min Support ) && ( current . m rule Sup Counter <= max Support ) ) { new Vector . add ( current ) ; } } return new Vector ; }
private static synchronized String make Date String ( Date date ) { return sdf Default . format ( date ) ; }
public static String generate Native Guid ( Db Client db Client , File Share file Share ) throws IO Exception { Storage System device = db Client . query Object ( Storage System . class , file Share . get Storage Device ( ) ) ; return String . format ( STRING + FILESYSTEM + STRING , device Type Map . get ( device . get System Type ( ) ) , device . get Serial Number ( ) , file Share . get Native Id ( ) ) ; }
public String to String ( ) { String Buffer result = new String Buffer ( ) ; int temp ; temp = ip Address & NUM ; result . append ( temp ) ; result . append ( STRING ) ; temp = ( ip Address > > NUM ) & NUM ; result . append ( temp ) ; result . append ( STRING ) ; temp = ( ip Address > > NUM ) & NUM ; result . append ( temp ) ; result . append ( STRING ) ; temp = ( ip Address > > NUM ) & NUM ; result . append ( temp ) ; return result . to String ( ) ; }
public void log Purchase ( Big Decimal purchase Amount , Currency currency , Bundle parameters ) { if ( purchase Amount == null ) { notify Developer Error ( STRING ) ; return ; } else if ( currency == null ) { notify Developer Error ( STRING ) ; return ; } if ( parameters == null ) { parameters = new Bundle ( ) ; } parameters . put String ( App Events Constants . EVENT PARAM CURRENCY , currency . get Currency Code ( ) ) ; log Event ( App Events Constants . EVENT NAME PURCHASED , purchase Amount . double Value ( ) , parameters ) ; eager Flush ( ) ; }
private static double distance ( Point p1 , Point p2 ) { double x = p1 . x - p2 . x ; double y = p1 . y - p2 . y ; return Math . sqrt ( x * x + y * y ) ; }
public void add Hyperedge In Node ( Hyper Edge hyper Edge ) { if ( hyper Edge != null ) { if ( null == hyperedges ) hyperedges = new Array List < > ( ) ; hyperedges . add ( hyper Edge ) ; semiring Plus ( hyper Edge ) ; } }
public Rotated Problems ( ) { super ( ) ; }
public Docker Port Mapping with Host Port ( int host Port ) { Docker Port Mapping new Mapping = new Docker Port Mapping ( ) ; new Mapping . protocol = protocol ; new Mapping . container Port = container Port ; new Mapping . host Ip = host Ip ; new Mapping . host Port = String . value Of ( host Port ) ; return new Mapping ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return ID 1 ; case NUM : return ID 2 ; default : return null ; } }
@ Override public int length ( ) { return str . length ( ) ; }
public void clear All Haptics ( ) { m Haptics . clear ( ) ; }
public void encode ( final Active MQ Buffer buffer ) { buffer . write String ( name ) ; buffer . write String ( factory Class Name ) ; buffer . write Int ( params == null ? NUM : params . size ( ) ) ; if ( params != null ) { encode Map ( buffer , params ) ; } if ( extra Props != null ) { encode Map ( buffer , extra Props ) ; } }
@ Override public void write ( byte [ ] b , int off , int len ) throws IO Exception { flush Bits ( ) ; out . write ( b , off , len ) ; }
public static double log 2 ( double x ) { return Math . log ( x ) / LOG 2 ; }
boolean is Name Used ( String name ) { List < Integer > columns With Name = column Names . get ( name ) ; return columns With Name != null && ! columns With Name . is Empty ( ) ; }
public State Interactive complete ( ) { if ( return state != this && actlog != null ) { actlog . start scope ( Logfile Scope . COMPLETE SCOPE ) ; } return return state ; }
private Work Queue find Non Empty Steal Queue ( ) { Work Queue [ ] ws ; int wl ; int r = TL Random . next Secondary Seed ( ) ; if ( ( ws = work Queues ) != null && ( wl = ws . length ) > NUM ) { int m = wl - NUM , origin = r & m ; for ( int k = origin , old Sum = NUM , check Sum = NUM ; ; ) { Work Queue q ; int b ; if ( ( q = ws [ k ] ) != null ) { if ( ( b = q . base ) - q . top < NUM ) return q ; check Sum += b ; } if ( ( k = ( k + NUM ) & m ) == origin ) { if ( old Sum == ( old Sum = check Sum ) ) break ; check Sum = NUM ; } } } return null ; }
public void test Pseudo Legal Moves ( ) throws Chess Parse Error { String fen = STRING ; Position pos = Text IO . read FEN ( fen ) ; assert Equals ( fen , Text IO . to FEN ( pos ) ) ; List < String > str Moves = get Move List ( pos , BOOL ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( ! str Moves . contains ( STRING ) ) ; assert True ( ! str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( ! str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( ! str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert Equals ( NUM , str Moves . size ( ) ) ; pos . set Piece ( Position . get Square ( NUM , NUM ) , Piece . BROOK ) ; str Moves = get Move List ( pos , BOOL ) ; assert True ( ! str Moves . contains ( STRING ) ) ; assert True ( ! str Moves . contains ( STRING ) ) ; pos . set Piece ( Position . get Square ( NUM , NUM ) , Piece . EMPTY ) ; pos . set Piece ( Position . get Square ( NUM , NUM ) , Piece . BROOK ) ; str Moves = get Move List ( pos , BOOL ) ; assert True ( ! str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; pos . set Piece ( Position . get Square ( NUM , NUM ) , Piece . EMPTY ) ; pos . set Piece ( Position . get Square ( NUM , NUM ) , Piece . BBISHOP ) ; str Moves = get Move List ( pos , BOOL ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( ! str Moves . contains ( STRING ) ) ; pos . set Piece ( Position . get Square ( NUM , NUM ) , Piece . EMPTY ) ; pos . set Castle Mask ( NUM << Position . A1 CASTLE ) ; str Moves = get Move List ( pos , BOOL ) ; assert True ( ! str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; }
private void do Ddp Orientation ( Node d , Node a , Node b , Node c , Graph graph ) { List < Node > sepset = get Sepset ( d , c ) ; if ( sepset == null ) { return ; } if ( sepset . contains ( b ) ) { graph . set Endpoint ( c , b , Endpoint . TAIL ) ; if ( verbose ) { logger . log ( STRING , Search Log Utils . edge Oriented Msg ( STRING + d , graph . get Edge ( b , c ) ) ) ; out . println ( Search Log Utils . edge Oriented Msg ( STRING + d , graph . get Edge ( b , c ) ) ) ; } change Flag = BOOL ; } else { if ( ! is Arrowpoint Allowed ( a , b , graph ) ) { return ; } if ( ! is Arrowpoint Allowed ( c , b , graph ) ) { return ; } graph . set Endpoint ( a , b , Endpoint . ARROW ) ; graph . set Endpoint ( c , b , Endpoint . ARROW ) ; logger . log ( STRING , Search Log Utils . collider Oriented Msg ( STRING + d , a , b , c ) ) ; change Flag = BOOL ; } }
public void handle Tbl Bootstrap Res Off Href Action Request ( Request Invocation Event event ) throws Model Control Exception { try { Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute ( PROPERTY ATTRIBUTE , ( Hash Map ) values ) ; SM Discovery Bootstrap Ref Off Edit View Bean vb = ( SM Discovery Bootstrap Ref Off Edit View Bean ) get View Bean ( SM Discovery Bootstrap Ref Off Edit View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . populate Values ( ( String ) get Display Field Value ( TBL BOOTSTRAP RES OFF HREF ACTION ) ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } }
@ Visible For Testing String post Request ( long timestamp , String xml ) throws Request Failure Exception { String response = null ; Http URL Connection url Connection = null ; try { url Connection = create Connection ( ) ; set Up Post Request ( timestamp , url Connection , xml ) ; send Request To Server ( url Connection , xml ) ; response = read Response From Server ( url Connection ) ; } finally { if ( url Connection != null ) { url Connection . disconnect ( ) ; } } return response ; }
private void generate Key ( ) throws Exception { Key Generator keygen = Key Generator . get Instance ( ALGO ) ; Secret Key key = keygen . generate Key ( ) ; persist Key ( key ) ; }
public Http Request Event fire Http Request Event ( String request , Output Stream output ) throws IO Exception { Http Request Event event = new Http Request Event ( this , request , output ) ; Http Request Listener listener ; Vector list = ( Vector ) listeners . clone ( ) ; Enumeration e = list . elements ( ) ; while ( e . has More Elements ( ) ) { listener = ( Http Request Listener ) e . next Element ( ) ; listener . http Request ( event ) ; } return event ; }
private void parse Record ( Element unit Node ) { Node List nl = unit Node . get Child Nodes ( ) ; for ( int i = NUM ; i < nl . get Length ( ) ; i ++ ) { Node curr Node = nl . item ( i ) ; if ( curr Node . get Parent Node ( ) != unit Node ) { continue ; } int node Type = curr Node . get Node Type ( ) ; if ( node Type == Node . ELEMENT NODE ) { String node Name = curr Node . get Node Name ( ) ; if ( node Name . equals Ignore Case ( UNIT ) ) { parse Unit ( ( Element ) curr Node , entities ) ; } else if ( node Name . equals Ignore Case ( SURVIVORS ) ) { parse Unit ( ( Element ) curr Node , survivors ) ; } else if ( node Name . equals Ignore Case ( ALLIES ) ) { parse Unit ( ( Element ) curr Node , allies ) ; } else if ( node Name . equals Ignore Case ( SALVAGE ) ) { parse Unit ( ( Element ) curr Node , salvage ) ; } else if ( node Name . equals Ignore Case ( DEVASTATED ) ) { parse Unit ( ( Element ) curr Node , devastated ) ; } else if ( node Name . equals Ignore Case ( KILLS ) ) { parse Kills ( ( Element ) curr Node ) ; } else if ( node Name . equals Ignore Case ( ENTITY ) ) { parse Unit ( ( Element ) curr Node , entities ) ; } else if ( node Name . equals Ignore Case ( PILOT ) ) { parse Pilot ( ( Element ) curr Node ) ; } } else { continue ; } } }
public void cancel ( ) { synchronized ( lock ) { if ( this . latency == NO TARGET ) { throw new Illegal State Exception ( STRING + STRING ) ; } if ( ! requests . remove ( this ) ) { throw new Internal Error ( STRING + this + STRING ) ; } if ( requests . is Empty ( ) ) requests = null ; this . latency = NO TARGET ; adjust Latency If Needed ( ) ; } }
void merge Success ( Merge Policy . One Merge merge ) { }
void start Event Tracker ( ) { List < Event Tracking Service > services = get Enabled Services For Type ( Event Tracking Service . class ) ; if ( services != null && ! services . is Empty ( ) ) { if ( event Tracker == null ) { event Tracker = new Event Tracker ( context , services , foam Api Keys . wifi Only ( ) ) ; } if ( ! event Tracker . is Running ( ) ) { event Tracker . start ( ) ; } } }
@ Override public int preceding ( int offset ) { Character Iterator text = get Text ( ) ; check Offset ( offset , text ) ; if ( cached Break Positions == null || offset <= cached Break Positions [ NUM ] || offset > cached Break Positions [ cached Break Positions . length - NUM ] ) { cached Break Positions = null ; return super . preceding ( offset ) ; } else { position In Cache = NUM ; while ( position In Cache < cached Break Positions . length && offset > cached Break Positions [ position In Cache ] ) { ++ position In Cache ; } -- position In Cache ; text . set Index ( cached Break Positions [ position In Cache ] ) ; return text . get Index ( ) ; } }
protected static boolean signed Fits In Nibble ( int value ) { return ( value >= - NUM ) && ( value <= NUM ) ; }
@ Override public void mouse Pressed ( Mouse Event e ) { events . clear ( ) ; if ( map Drag Operation From Modifiers ( e ) != Dn D Constants . ACTION NONE ) { try { motion Threshold = Drag Source . get Drag Threshold ( ) ; } catch ( Exception exc ) { motion Threshold = NUM ; } append Event ( e ) ; } }
public void simple Element ( String name , String value ) throws IO Exception { simple Element ( null , name , null , value ) ; }
public static boolean is Valid I Pv 4 ( String address ) { if ( address . length ( ) == NUM ) { return BOOL ; } int octet ; int octets = NUM ; String temp = address + STRING ; int pos ; int start = NUM ; while ( start < temp . length ( ) && ( pos = temp . index Of ( STRING , start ) ) > start ) { if ( octets == NUM ) { return BOOL ; } try { octet = Integer . parse Int ( temp . substring ( start , pos ) ) ; } catch ( Number Format Exception ex ) { return BOOL ; } if ( octet < NUM || octet > NUM ) { return BOOL ; } start = pos + NUM ; octets ++ ; } return octets == NUM ; }
private void validate Dimension CSV ( Schema Info schema Info , String fact Table Name , String dim Table Name , Carbon File dim File , String partition Id , Carbon Data Load Schema schema , String delimiter ) throws Data Loading Exception { String [ ] column Names = get Dim Column Names ( schema Info , fact Table Name , dim Table Name , partition Id , schema ) ; if ( null == column Names || column Names . length < NUM ) { return ; } if ( ! check All Columns Present ( column Names , dim File . get Absolute Path ( ) , delimiter ) ) { LOGGER . error ( STRING + STRING + dim File . get Name ( ) ) ; throw new Data Loading Exception ( Data Processor Constants . CSV VALIDATION ERRROR CODE , STRING + STRING + dim File . get Name ( ) ) ; } }
private Data Point is Unique ( Node from , Data Point point , double tolerance ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + tolerance + STRING + point ) ; while ( from . type == Type . branch ) { Branch branch = ( Branch ) from ; double d = point . get ( branch . split Dimension ) ; if ( Math . abs ( d - branch . mid Point ) < tolerance ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + branch + STRING ) ; Data Point left Check = is Unique ( branch . left , point , tolerance ) ; Data Point right Check = is Unique ( branch . right , point , tolerance ) ; if ( ( left Check == null ) && ( right Check == null ) ) { return null ; } else { if ( left Check != null ) { return left Check ; } else { return right Check ; } } } else if ( point . get Vector ( ) [ branch . split Dimension ] < branch . mid Point ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + branch + STRING ) ; from = branch . left ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + branch + STRING ) ; from = branch . right ; } } Leaf leaf = ( Leaf ) from ; for ( Data Point p : leaf . points ) { for ( int i = NUM ; i < p . get Dimension ( ) ; i ++ ) { if ( Math . abs ( p . get ( i ) - point . get ( i ) ) >= tolerance ) { break ; } } if ( get Distance ( p , point ) < tolerance ) { return p ; } } return null ; }
public boolean remove Tuple ( Tuple t ) { Table table = t . get Table ( ) ; if ( m sets . contains ( table ) ) { return table . remove Tuple ( t ) ; } else { return BOOL ; } }
private boolean is Dark Theme Set ( ) { Shared Preferences shared Preferences = Preference Manager . get Default Shared Preferences ( get Activity ( ) ) ; String key = get String ( R . string . theme preference key ) ; String default Value = get String ( R . string . theme preference default value ) ; return Integer . value Of ( shared Preferences . get String ( key , default Value ) ) != NUM ; }
public String visit ( Type t , Locale locale ) { return t . accept ( this , locale ) ; }
public synchronized void add ( String name , long thread Id ) { if ( m Finished ) { throw new Illegal State Exception ( STRING ) ; } m Markers . add ( new Marker ( name , thread Id , System Clock . elapsed Realtime ( ) ) ) ; }
@ Deprecated public void add Prefix NS Mapping ( String prefix , String ns URI ) { if ( ns URI . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( prefix . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( prefix . equals ( NO NS PREFIX ) ) { throw new Illegal Argument Exception ( STRING + prefix + STRING ) ; } if ( prefix To Namespace URI Lookup . contains Key ( prefix ) ) { throw new Illegal Argument Exception ( STRING + prefix + STRING ) ; } if ( namespace URI To Prefix Lookup . contains Key ( ns URI ) ) { throw new Illegal Argument Exception ( STRING + ns URI + STRING ) ; } if ( prefix . equals ( DEFAULT NAMESPACE PREFIX ) ) { this . default NS = ns URI ; } else { prefix To Namespace URI Lookup . put ( prefix , ns URI ) ; namespace URI To Prefix Lookup . put ( ns URI , prefix ) ; } }
protected Message create Response Message ( ) { return new Message ( NUM , Version . CURRENT ) ; }
public static void o ( double a ) { o ( a , Parameters . Output Field Width , Parameters . Output Frac Places ) ; }
public void write Field ( String name , String value ) throws IO Exception { if ( name == null ) { throw new Illegal Argument Exception ( STRING ) ; } out . write Bytes ( PREFIX ) ; out . write Bytes ( boundary ) ; out . write Bytes ( NEWLINE ) ; out . write Bytes ( STRING + name + STRING ) ; out . write Bytes ( NEWLINE ) ; out . write Bytes ( NEWLINE ) ; if ( value != null ) { out . write Bytes ( value ) ; } out . write Bytes ( NEWLINE ) ; out . flush ( ) ; }
public int drain To ( Collection < ? super E > c ) { int result = buffer . drain To ( c ) ; if ( producer != null ) { producer . wake Up ( ) ; } return result ; }
protected void grow ( ) { if ( dists == EMPTY DISTS ) { dists = new double [ INITIAL SIZE ] ; ids = new int [ INITIAL SIZE ] ; return ; } final int len = dists . length ; final int newlength = len + ( len > > NUM ) ; double [ ] odists = dists ; dists = new double [ newlength ] ; System . arraycopy ( odists , NUM , dists , NUM , odists . length ) ; int [ ] oids = ids ; ids = new int [ newlength ] ; System . arraycopy ( oids , NUM , ids , NUM , oids . length ) ; }
Igfs Input Stream Impl ( Igfs Context igfs Ctx , Igfs Path path , @ Nullable Igfs Entry Info file Info , int prefetch Blocks , int seq Reads Before Prefetch , @ Nullable Igfs Secondary File System Positioned Readable sec Reader , long len , int block Size , long blocks Cnt , boolean proxy ) { assert igfs Ctx != null ; assert path != null ; this . igfs Ctx = igfs Ctx ; this . path = path ; this . file Info = file Info ; this . prefetch Blocks = prefetch Blocks ; this . seq Reads Before Prefetch = seq Reads Before Prefetch ; this . sec Reader = sec Reader ; this . len = len ; this . block Size = block Size ; this . blocks Cnt = blocks Cnt ; this . proxy = proxy ; log = igfs Ctx . kernal Context ( ) . log ( Igfs Input Stream . class ) ; max Loc Cache Size = ( prefetch Blocks > NUM ? prefetch Blocks : NUM ) * NUM / NUM ; loc Cache = new Linked Hash Map < > ( max Loc Cache Size , NUM ) ; pending Futs = new Grid Concurrent Hash Set < > ( prefetch Blocks > NUM ? prefetch Blocks : NUM ) ; igfs Ctx . metrics ( ) . increment Files Opened For Read ( ) ; }
public Abstract Scale Out Client Index View ( final Abstract Scale Out Federation fed , final String name , final long timestamp , final I Metadata Index metadata Index ) { if ( fed == null ) throw new Illegal Argument Exception ( ) ; if ( name == null ) throw new Illegal Argument Exception ( ) ; if ( metadata Index == null ) throw new Illegal Argument Exception ( ) ; this . fed = fed ; this . name = name ; this . timestamp = timestamp ; this . metadata Index = metadata Index ; this . metadata Index Metadata = metadata Index . get Index Metadata ( ) ; final Abstract Client < ? > client = fed . get Client ( ) ; this . capacity = client . get Default Range Query Capacity ( ) ; this . batch Only = client . get Batch Api Only ( ) ; this . task Timeout = client . get Task Timeout ( ) ; this . read Consistent = client . is Read Consistent ( ) ; }
public boolean can Send Event ( ) { try { validate Send Event ( ) ; return BOOL ; } catch ( Exception e ) { return BOOL ; } }
public static final String capitalize ( String str , char ... delimiters ) { final int delim Len = delimiters == null ? - NUM : delimiters . length ; if ( Text Utils . is Empty ( str ) || delim Len == NUM ) { return str ; } final char [ ] buffer = str . to Char Array ( ) ; boolean capitalize Next = BOOL ; for ( int i = NUM ; i < buffer . length ; i ++ ) { char ch = buffer [ i ] ; if ( is Delimiter ( ch , delimiters ) ) { capitalize Next = BOOL ; } else if ( capitalize Next ) { buffer [ i ] = Character . to Title Case ( ch ) ; capitalize Next = BOOL ; } } return new String ( buffer ) ; }
public void test Compare To Neg Zero ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = Big Integer . ZERO ; assert Equals ( - NUM , a Number . compare To ( b Number ) ) ; }
public void write ( Output Stream out ) throws Socks Exception , IO Exception { if ( data == null ) { Socks 5 Message msg ; if ( addr Type == SOCKS ATYP DOMAINNAME ) msg = new Socks 5 Message ( command , host , port ) ; else { if ( ip == null ) { try { ip = Inet Address . get By Name ( host ) ; } catch ( Unknown Host Exception uh ex ) { throw new Socks Exception ( Socks Constants . SOCKS JUST ERROR ) ; } } msg = new Socks 5 Message ( command , ip , port ) ; } data = msg . data ; } out . write ( data ) ; }
public boolean is Connected ( short node Id ) { Node Connection nc = connections . get ( node Id ) ; return ( nc != null && nc . state == Node Connection State . CONNECTED ) ; }
Template Sub Pattern Association ( Elem Template template , Step Pattern pattern , String pat ) { m pattern = pat ; m template = template ; m step Pattern = pattern ; m target String = m step Pattern . get Target String ( ) ; m wild = m target String . equals ( STRING ) ; }
public static byte [ ] compress For Zlib ( byte [ ] bytes To Compress ) { Deflater deflater = new Deflater ( ) ; deflater . set Input ( bytes To Compress ) ; deflater . finish ( ) ; byte [ ] bytes Compressed = new byte [ Short . MAX VALUE ] ; int number Of Bytes After Compression = deflater . deflate ( bytes Compressed ) ; byte [ ] return Values = new byte [ number Of Bytes After Compression ] ; System . arraycopy ( bytes Compressed , NUM , return Values , NUM , number Of Bytes After Compression ) ; return return Values ; }
private static Byte Buffer generate Wav Data ( int sample Count , int freq Hz ) { final int num Data Bytes = sample Count * NUM CHANNELS * BITS PER SAMPLE / NUM ; final double freq = freq Hz ; Byte Buffer buf = Byte Buffer . allocate ( num Data Bytes ) ; buf . order ( Byte Order . LITTLE ENDIAN ) ; if ( BITS PER SAMPLE == NUM ) { final double peak = NUM ; for ( int i = NUM ; i < sample Count ; i ++ ) { double time Sec = i / ( double ) SAMPLE RATE ; double sin Value = Math . sin ( NUM * Math . PI * freq * time Sec ) ; if ( Game Surface Renderer . EXTRA CHECK ) { int output = ( int ) ( peak * sin Value + NUM ) ; if ( output < NUM || output >= NUM ) { throw new Runtime Exception ( STRING ) ; } } buf . put ( ( byte ) ( peak * sin Value + NUM ) ) ; } } else if ( BITS PER SAMPLE == NUM ) { final double peak = NUM ; Short Buffer sbuf = buf . as Short Buffer ( ) ; for ( int i = NUM ; i < sample Count ; i ++ ) { double time Sec = i / ( double ) SAMPLE RATE ; double sin Value = Math . sin ( NUM * Math . PI * freq * time Sec ) ; sbuf . put ( ( short ) ( peak * sin Value ) ) ; } } buf . position ( NUM ) ; return buf ; }
protected static String h2 c ( String hyphenated , boolean studly ) { String Builder b = new String Builder ( hyphenated . length ( ) ) ; boolean cap Next = studly ; for ( int i = NUM ; i < hyphenated . length ( ) ; ++ i ) { char c = hyphenated . char At ( i ) ; if ( c == STRING ) cap Next = BOOL ; else { b . append ( cap Next ? Character . to Upper Case ( c ) : c ) ; cap Next = BOOL ; } } return b . to String ( ) ; }
public synchronized void on Write Event ( ) throws IO Exception { LRMI Invocation Trace trace = null ; try { while ( ! contexts . is Empty ( ) ) { Context current = contexts . peek ( ) ; trace = current . get Trace ( ) ; if ( trace != null ) LRMI Invocation Context . update Context ( trace , null , null , null , null , BOOL , null , null ) ; none Blocking Write ( current ) ; if ( current . get Phase ( ) != Context . Phase . FINISH ) { set Write Interest ( ) ; break ; } else { trace Context Total Write Time ( current ) ; contexts . poll ( ) ; pending Writes . decrement ( ) ; } } if ( contexts . is Empty ( ) ) { remove Write Interest ( BOOL ) ; } } finally { if ( trace != null ) LRMI Invocation Context . reset Context ( ) ; } }
public static void add ( Object spy ) { SPIES . add ( spy ) ; }
void init Leaf Calc ( byte [ ] seed 0 ) { this . i = NUM ; this . j = NUM ; byte [ ] dummy = new byte [ mdsize ] ; System . arraycopy ( seed 0 , NUM , dummy , NUM , seed . length ) ; this . seed = gmss Random . next Seed ( dummy ) ; }
@ Override public boolean download File ( String path , String dest ) { try { File Output Stream fos = new File Output Stream ( new File ( dest ) ) ; mDB Api . get File ( path , null , fos , null ) ; fos . close ( ) ; return BOOL ; } catch ( Dropbox Exception e ) { e . print Stack Trace ( ) ; return BOOL ; } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; return BOOL ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; return BOOL ; } }
boolean does Occur ( Q Name ref Name ) { return m refs . contains ( ref Name ) ; }
public long loop ( ) { final long current Timestamp = System . current Time Millis ( ) ; final long time Diff = current Timestamp - last Run Timestamp ; final int shutdown Diff = ( int ) ( System . current Time Millis ( ) - game Shutdown Request Timestamp ) ; final float shutdown Progress = shutdown Diff >= FLYING SUPERMAN DELAY && game State . equals ( Game State . SHUTDOWN REQUESTED ) ? ( shutdown Diff - FLYING SUPERMAN DELAY ) / ( float ) ( GAME SHUTDOWN DELAY - FLYING SUPERMAN DELAY ) : NUM ; snowflakes Collection . on Time Passed ( time Diff ) ; presents Collection . on Time Passed ( time Diff ) ; if ( game State . equals ( Game State . SHUTDOWN REQUESTED ) ) { player . sety Pos ( get Default Player Height ( ) * ( NUM - shutdown Progress ) - ( player . get Height ( ) * shutdown Progress ) ) ; superman Clouds . sety Pos ( superman Clouds . get Height ( ) * ( NUM - shutdown Progress ) - ( ( superman Clouds . get Height ( ) - field Height ) * shutdown Progress ) ) ; if ( shutdown Progress >= NUM ) { game State = Game State . STOPPED ; } } else { if ( player . is In State ( Player State . CHEWING ) && player . get Chewing Duration ( ) >= PLAYER CHEWING DURATION IN MS ) { player . set State ( Player State . DEFAULT ) ; } if ( player . is In State ( Player State . HIT ) && player . get Hit Duration ( ) >= PLAYER HIT DURATION IN MS ) { player . set State ( Player State . DEFAULT ) ; } if ( new Player Location != null ) { player . setx Pos ( new Player Location . x ) ; player . sety Pos ( new Player Location . y ) ; new Player Location = null ; } } boolean player Below Object = update Falling Objects ( time Diff , shutdown Progress , snowflakes Collection , BOOL , BOOL ) | update Falling Objects ( time Diff , shutdown Progress , presents Collection , BOOL , BOOL ) ; if ( player . is In State ( Player State . DEFAULT ) || player . is In State ( Player State . LOOKING UP ) ) { if ( player Below Object ) { player . set State ( Player State . LOOKING UP ) ; } else { player . set State ( Player State . DEFAULT ) ; } } last Run Timestamp = current Timestamp ; return time Diff ; }
public static Date Format to Date Format ( String date Format , Time Zone tz , Locale locale ) { Date Format df = null ; if ( Util Validate . is Empty ( date Format ) ) { df = Date Format . get Date Instance ( Date Format . SHORT , locale ) ; } else { df = new Simple Date Format ( date Format , locale == null ? Locale . get Default ( ) : locale ) ; } df . set Time Zone ( tz ) ; return df ; }
public Integer load Id Name Values ( Db Output Statement statement , Integer idx ) throws Exception { int index = idx . int Value ( ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING ) ; id = statement . get Long Integer ( index ++ ) ; name = statement . get Short Text ( index ++ ) ; return new Integer ( index ) ; }
private byte [ ] pad Password ( byte [ ] password ) { if ( password == null ) { password = new byte [ NUM ] ; } byte [ ] padded = new byte [ NUM ] ; final int num Contributing Password Bytes = password . length > padded . length ? padded . length : password . length ; System . arraycopy ( password , NUM , padded , NUM , num Contributing Password Bytes ) ; if ( password . length < padded . length ) { System . arraycopy ( PW PADDING , NUM , padded , password . length , padded . length - password . length ) ; } return padded ; }
private double max Dist Level ( DBID id , int level ) { final Number Vector obj = relation . get ( id ) ; final double r = NUM / ( NUM << ( level - NUM ) ) ; double dist ; if ( t == NUM ) { dist = NUM ; for ( int dim = NUM ; dim < d ; dim ++ ) { final double p m r = get Dim For Object ( obj , dim ) % r ; dist += Math . max ( p m r , r - p m r ) ; } } else if ( t == NUM ) { dist = NUM ; for ( int dim = NUM ; dim < d ; dim ++ ) { final double p m r = get Dim For Object ( obj , dim ) % r ; double a = Math . max ( p m r , r - p m r ) ; dist += a * a ; } dist = Math . sqrt ( dist ) ; } else if ( ! Double . is Infinite ( t ) ) { dist = NUM ; for ( int dim = NUM ; dim < d ; dim ++ ) { final double p m r = get Dim For Object ( obj , dim ) % r ; dist += Math . pow ( Math . max ( p m r , r - p m r ) , t ) ; } dist = Math . pow ( dist , NUM / t ) ; } else { dist = Double . NEGATIVE INFINITY ; for ( int dim = NUM ; dim < d ; dim ++ ) { final double p m r = get Dim For Object ( obj , dim ) % r ; dist = Math . max ( dist , Math . max ( p m r , r - p m r ) ) ; } } return dist * diameter ; }
public final int move Made ( long now , boolean use Increment ) { stop Timer ( now ) ; Array List < Time Control Field > tc = tc Data . get TC ( white To Move ) ; Pair < Integer , Integer > tc Info = get Current TC ( white To Move ) ; int tc Idx = tc Info . first ; int moves To Tc = tc Info . second ; int remaining = get Remaining Time ( white To Move , now ) ; if ( use Increment ) { remaining += tc . get ( tc Idx ) . increment ; if ( moves To Tc == NUM ) { if ( tc Idx + NUM < tc . size ( ) ) tc Idx ++ ; remaining += tc . get ( tc Idx ) . time Control ; } } elapsed = NUM ; return remaining ; }
public static Properties prefix Properties ( Properties props , String prefix ) { Properties prefix Props = new Properties ( ) ; for ( String key : props . string Property Names ( ) ) { if ( key . starts With ( prefix ) ) { String key Without Prefix = key . substring ( prefix . length ( ) ) ; prefix Props . set Property ( key Without Prefix , props . get Property ( key ) ) ; } } return prefix Props ; }
public final void test Set Regex ( ) { Regex Constraint regex Constraint = new Regex Constraint ( Pattern . compile ( STRING ) ) ; regex Constraint . set Regex ( REGEX ) ; assert Equals ( REGEX , regex Constraint . get Regex ( ) ) ; }
public synchronized void start ( ) { if ( is Started ) { return ; } if ( is Stopped ) { throw new Illegal State Exception ( STRING ) ; } logger . info ( STRING + Tor . get Full Version ( ) + STRING ) ; verify Unlimited Strength Policy Installed ( ) ; directory Downloader . start ( directory ) ; circuit Manager . start Building Circuits ( ) ; if ( dashboard . is Enabled By Property ( ) ) { dashboard . start Listening ( ) ; } is Started = BOOL ; }
public static Cipher Parameters make PBE Parameters ( PBE Key Spec key Spec , int type , int hash , int key Size , int iv Size ) { PBE Parameters Generator generator = make PBE Generator ( type , hash ) ; byte [ ] key ; Cipher Parameters param ; key = convert Password ( type , key Spec ) ; generator . init ( key , key Spec . get Salt ( ) , key Spec . get Iteration Count ( ) ) ; if ( iv Size != NUM ) { param = generator . generate Derived Parameters ( key Size , iv Size ) ; } else { param = generator . generate Derived Parameters ( key Size ) ; } for ( int i = NUM ; i != key . length ; i ++ ) { key [ i ] = NUM ; } return param ; }
@ Override public double value ( int att Index ) { int index = locate Index ( att Index ) ; if ( ( index >= NUM ) && ( m Indices [ index ] == att Index ) ) { return NUM ; } else { return NUM ; } }
private void fetch Filter Seeds ( ) { if ( seed List == null || seed List . is Empty ( ) ) { return ; } for ( Iterator < URI > it = seed List . iterator ( ) ; it . has Next ( ) ; ) { URI seed = it . next ( ) ; for ( Fetch Filter filter : controller . get Fetch Filters ( ) ) { Fetch Status filter Reason = filter . check Filter ( seed ) ; if ( filter Reason != Fetch Status . VALID ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + seed + STRING + filter Reason ) ; } it . remove ( ) ; break ; } } } }
public XY Area Renderer 2 ( XY Tool Tip Generator label Generator , XYURL Generator url Generator ) { super ( ) ; this . show Outline = BOOL ; set Base Tool Tip Generator ( label Generator ) ; set URL Generator ( url Generator ) ; General Path area = new General Path ( ) ; area . move To ( NUM , - NUM ) ; area . line To ( NUM , - NUM ) ; area . line To ( NUM , NUM ) ; area . line To ( - NUM , NUM ) ; area . line To ( - NUM , - NUM ) ; area . close Path ( ) ; this . legend Area = area ; }
public static boolean is Primitive Or Wrapper ( Class < ? > clazz ) { Assert . not Null ( clazz , STRING ) ; return ( clazz . is Primitive ( ) || is Primitive Wrapper ( clazz ) ) ; }
private void assert File Contains ( List < String > expected , String filename ) throws Exception { try ( Buffered Reader reader = new Buffered Reader ( new File Reader ( filename ) ) ) { List < String > actual = new Array List < > ( ) ; for ( ; ; ) { String line = reader . read Line ( ) ; if ( line == null ) { break ; } actual . add ( line ) ; } assert Equals ( expected , actual ) ; } }
private void report Exception ( Kind kind , Element element , Throwable t ) { String Writer buf = new String Writer ( ) ; t . print Stack Trace ( new Print Writer ( buf ) ) ; buf . to String ( ) ; message ( kind , element , STRING , buf . to String ( ) ) ; }
public void add ( String [ ] titles , double [ ] values ) { add ( m Categories . size ( ) + STRING , titles , values ) ; }
static String parse Authority ( String uri String , int ssi ) { int length = uri String . length ( ) ; if ( length > ssi + NUM && uri String . char At ( ssi + NUM ) == STRING && uri String . char At ( ssi + NUM ) == STRING ) { int end = ssi + NUM ; LOOP : while ( end < length ) { switch ( uri String . char At ( end ) ) { case STRING : case STRING : case STRING : break LOOP ; } end ++ ; } return uri String . substring ( ssi + NUM , end ) ; } else { return null ; } }
public static void sort ( List < ? > list ) { if ( list . size ( ) > NUM ) { Collections . sort ( list , INSTANCE ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public void add Datatransfer Progress Listener ( On Datatransfer Progress Listener listener , OC Upload oc Upload ) { if ( oc Upload == null || listener == null ) return ; String target Key = build Remote Name ( oc Upload . get Account Name ( ) , oc Upload . get Remote Path ( ) ) ; m Bound Listeners . put ( target Key , listener ) ; }
private static char [ ] zz Unpack C Map ( String packed ) { char [ ] map = new char [ NUM ] ; int i = NUM ; int j = NUM ; while ( i < NUM ) { int count = packed . char At ( i ++ ) ; char value = packed . char At ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM ) ; } return map ; }
protected String [ ] read Next ( Line Number Reader reader ) throws IO Exception { String [ ] row Def = null ; do { String next Line = reader . read Line ( ) ; if ( next Line == null ) { has Next = BOOL ; return row Def ; } String [ ] r = parser . parse Line Multi ( next Line ) ; if ( r . length > NUM ) { if ( row Def == null ) { row Def = r ; } else { String [ ] t = new String [ row Def . length + r . length ] ; System . arraycopy ( row Def , NUM , t , NUM , row Def . length ) ; System . arraycopy ( r , NUM , t , row Def . length , r . length ) ; row Def = t ; } } } while ( parser . is Pending ( ) ) ; return row Def ; }
public Class < ? > type ( ) { if ( is Class ) { return ( Class < ? > ) object ; } else { return object . get Class ( ) ; } }
private void verify Property Source Value ( Reloadable Property Source reloadable Property Source , String expected Value ) { logger . debug ( STRING + TEST KEY + STRING + expected Value ) ; logger . debug ( STRING + properties . get ( TEST KEY ) + STRING + reloadable Property Source . get Property ( TEST KEY ) ) ; String value = ( String ) reloadable Property Source . get Property ( TEST KEY ) ; assert Equals ( expected Value , value ) ; }
private void update Center Panel ( ) { long now = System . current Time Millis ( ) ; if ( next Update Time > now ) return ; next Update Time = now + NUM * NUM ; center Panel . remove All ( ) ; center Component = new J Label ( ) ; Grid Bag Constraints gbc = new Grid Bag Constraints ( ) ; gbc . gridx = NUM ; gbc . gridy = NUM ; gbc . weightx = NUM ; gbc . fill = Grid Bag Constraints . NONE ; gbc . anchor = Grid Bag Constraints . CENTER ; center Panel . add ( center Component , gbc ) ; refresh ( ) ; }
public void service Request Queue ( ) throws CLI Exception { if ( is Verbose ( ) ) { output Writer . println Message ( rb Messages . get String ( STRING ) ) ; } try { while ( ! request Queue . is Empty ( ) ) { CLI Request req = ( CLI Request ) request Queue . remove ( NUM ) ; try { req . process ( this ) ; if ( status OS != null ) { String status = format Status ( req . get Options ( ) , NUM ) ; status OS . write ( status . get Bytes ( ) ) ; } } catch ( CLI Exception e ) { if ( is Verbose ( ) ) { e . print Stack Trace ( System . out ) ; } if ( status OS != null ) { String status = format Status ( req . get Options ( ) , e . get Exit Code ( ) ) ; status OS . write ( status . get Bytes ( ) ) ; } if ( b Continue ) { output Writer . println Error ( e . get Message ( ) ) ; } else { throw e ; } } } } catch ( IO Exception e ) { throw new CLI Exception ( e , Exit Codes . REQUEST CANNOT BE PROCESSED ) ; } finally { if ( status OS != null ) { try { status OS . close ( ) ; } catch ( IO Exception ex ) { } status OS = null ; } } }
Always Identical Key Store State ( ) { super ( ) ; }
public static byte [ ] pack Byte Buffer Into Single Byte Array ( Byte Buffer [ ] byte Buffer Arr ) { if ( null == byte Buffer Arr || byte Buffer Arr . length == NUM ) { return null ; } int no Of Col = byte Buffer Arr . length ; short offset Len = ( short ) ( no Of Col * NUM ) ; int total Bytes = calculate Total Bytes ( byte Buffer Arr ) + offset Len ; Byte Buffer buffer = Byte Buffer . allocate ( total Bytes ) ; buffer . put Short ( offset Len ) ; for ( int index = NUM ; index < byte Buffer Arr . length - NUM ; index ++ ) { Byte Buffer individual Col = byte Buffer Arr [ index ] ; int no Of Bytes = individual Col . capacity ( ) ; buffer . put Short ( ( short ) ( offset Len + no Of Bytes ) ) ; offset Len += no Of Bytes ; individual Col . rewind ( ) ; } for ( int index = NUM ; index < byte Buffer Arr . length ; index ++ ) { Byte Buffer individual Col = byte Buffer Arr [ index ] ; buffer . put ( individual Col . array ( ) ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }
public void stop ( ) { m Cancel = BOOL ; if ( m Running . compare And Set ( BOOL , BOOL ) ) { if ( m Sample Dispatcher Task != null ) { m Thread Pool Manager . cancel ( m Sample Dispatcher Task ) ; m Sample Dispatcher Task = null ; m Filled Buffers . clear ( ) ; } } }
public void add ( Simple Name ref ) { String type Name = ref . get Identifier ( ) ; if ( f Imports Added . contains ( type Name ) ) { return ; } I Binding binding = ref . resolve Binding ( ) ; if ( binding != null ) { if ( binding . get Kind ( ) != I Binding . TYPE ) { return ; } I Type Binding type Binding = ( I Type Binding ) binding ; if ( type Binding . is Array ( ) ) { type Binding = type Binding . get Element Type ( ) ; } type Binding = type Binding . get Type Declaration ( ) ; if ( ! type Binding . is Recovered ( ) ) { if ( needs Import ( type Binding , ref ) ) { f Imp Structure . add Import ( type Binding ) ; f Imports Added . add ( type Name ) ; } return ; } } else { if ( f Do Ignore Lower Case Names && type Name . length ( ) > NUM ) { char ch = type Name . char At ( NUM ) ; if ( Strings . is Lower Case ( ch ) && Character . is Letter ( ch ) ) { return ; } } } f Imports Added . add ( type Name ) ; f Unresolved Types . put ( type Name , new Unresolved Type Data ( ref ) ) ; }
private static boolean check Font ( String font Name , String new Name , String test String , boolean force ) { boolean displayable = BOOL ; Font f = UI Manager . get Font ( font Name ) ; if ( f != null && ! new Name . equals Ignore Case ( f . get Name ( ) ) ) { if ( ! GUI Utils . can Display ( f , test String ) || force ) { f = new Font ( new Name , f . get Style ( ) , f . get Size ( ) ) ; if ( GUI Utils . can Display ( f , test String ) ) UI Manager . put ( font Name , f ) ; else displayable = BOOL ; } } else if ( f != null ) { displayable = GUI Utils . can Display ( f , test String ) ; } else { displayable = BOOL ; } return displayable ; }
public void add All Searchables ( Array List < ? extends Search Result > searchable ) { m Searchable List . add All ( searchable ) ; }
public List < Value Box > add Argument Hotspots ( String signature , int arg ) { List < Value Box > sig Spots = String Analysis . get Argument Expressions ( signature , arg ) ; return add Argument Hotspots ( signature , arg , sig Spots ) ; }
public boolean is Full ( ) { return counter . get ( ) == q Size ; }
public static String JQ ( String request ) throws Exception { int query Start Pos = request . index Of ( STRING ) ; String query ; String path ; if ( - NUM == query Start Pos ) { query = STRING ; path = request ; } else { query = request . substring ( query Start Pos + NUM ) ; path = request . substring ( NUM , query Start Pos ) ; } query = set Param ( query , STRING , STRING ) ; request = path + STRING + set Param ( query , STRING , STRING ) ; String response ; boolean failed = BOOL ; try { response = rest Test Harness . query ( request ) ; failed = BOOL ; } finally { if ( failed ) { log . error ( STRING + request ) ; } } return response ; }
static void sort ( int [ ] a , int left , int right , int [ ] work , int work Base , int work Len ) { if ( right - left < QUICKSORT THRESHOLD ) { sort ( a , left , right , BOOL ) ; return ; } int [ ] run = new int [ MAX RUN COUNT + NUM ] ; int count = NUM ; run [ NUM ] = left ; for ( int k = left ; k < right ; run [ count ] = k ) { while ( k < right && a [ k ] == a [ k + NUM ] ) k ++ ; if ( k == right ) break ; if ( a [ k ] < a [ k + NUM ] ) { while ( ++ k <= right && a [ k - NUM ] <= a [ k ] ) ; } else if ( a [ k ] > a [ k + NUM ] ) { while ( ++ k <= right && a [ k - NUM ] >= a [ k ] ) ; for ( int lo = run [ count ] - NUM , hi = k ; ++ lo < -- hi ; ) { int t = a [ lo ] ; a [ lo ] = a [ hi ] ; a [ hi ] = t ; } } if ( run [ count ] > left && a [ run [ count ] ] >= a [ run [ count ] - NUM ] ) { count -- ; } if ( ++ count == MAX RUN COUNT ) { sort ( a , left , right , BOOL ) ; return ; } } if ( count == NUM ) { return ; } else if ( count == NUM && run [ count ] > right ) { return ; } right ++ ; if ( run [ count ] < right ) { run [ ++ count ] = right ; } byte odd = NUM ; for ( int n = NUM ; ( n <<= NUM ) < count ; odd ^= NUM ) ; int [ ] b ; int ao , bo ; int blen = right - left ; if ( work == null || work Len < blen || work Base + blen > work . length ) { work = new int [ blen ] ; work Base = NUM ; } if ( odd == NUM ) { System . arraycopy ( a , left , work , work Base , blen ) ; b = a ; bo = NUM ; a = work ; ao = work Base - left ; } else { b = work ; ao = NUM ; bo = work Base - left ; } for ( int last ; count > NUM ; count = last ) { for ( int k = ( last = NUM ) + NUM ; k <= count ; k += NUM ) { int hi = run [ k ] , mi = run [ k - NUM ] ; for ( int i = run [ k - NUM ] , p = i , q = mi ; i < hi ; ++ i ) { if ( q >= hi || p < mi && a [ p + ao ] <= a [ q + ao ] ) { b [ i + bo ] = a [ p ++ + ao ] ; } else { b [ i + bo ] = a [ q ++ + ao ] ; } } run [ ++ last ] = hi ; } if ( ( count & NUM ) != NUM ) { for ( int i = right , lo = run [ count - NUM ] ; -- i >= lo ; b [ i + bo ] = a [ i + ao ] ) ; run [ ++ last ] = right ; } int [ ] t = a ; a = b ; b = t ; int o = ao ; ao = bo ; bo = o ; } }
protected void shift End ( int new Size ) { int old Size = get Array Length ( ) ; int old Gap End = g1 ; int upper Size = old Size - old Gap End ; int array Length = get New Array Size ( new Size ) ; int new Gap End = array Length - upper Size ; resize ( array Length ) ; g1 = new Gap End ; if ( upper Size != NUM ) { System . arraycopy ( array , old Gap End , array , new Gap End , upper Size ) ; } }
protected void process Style 12 Examine And Setup Adjustment ( Game game , Style 12 Message message , Game Service service , String entire Message ) { if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING ) ; } if ( game . is In State ( Game . OBSERVING EXAMINED STATE ) && message . relation == Style 12 Message . EXAMINING GAME RELATION ) { if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING ) ; } examine Games Waiting On Moves . put ( game . get Id ( ) , message ) ; connector . send Message ( STRING + message . game Id , BOOL , Chat Type . MOVES ) ; } else if ( entire Message . contains ( STRING ) || entire Message . contains ( STRING ) ) { if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING ) ; } Game examine Game = Ics Utils . create Game ( message , entire Message ) ; if ( message . relation == Style 12 Message . EXAMINING GAME RELATION && ! examine Game . is In State ( Game . SETUP STATE ) ) { examine Games Waiting On Moves . put ( game . get Id ( ) , message ) ; connector . send Message ( STRING + message . game Id , BOOL , Chat Type . MOVES ) ; } } else if ( game . is In State ( Game . EXAMINING STATE ) && ( entire Message . contains ( STRING ) || entire Message . contains ( STRING ) ) ) { if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING ) ; } process Examined Game Became Setup ( ) ; } else if ( entire Message . contains ( STRING ) || entire Message . contains ( STRING ) ) { examine Games Waiting On Moves . put ( game . get Id ( ) , message ) ; connector . send Message ( STRING + message . game Id , BOOL , Chat Type . MOVES ) ; } else { Ics Utils . reset Game ( game , message ) ; service . fire Game State Changed ( message . game Id , BOOL ) ; connector . send Message ( STRING + message . game Id , BOOL , Chat Type . MOVES ) ; } }
public Sam Filter Chain ( Collection < Sam Filter > filters ) { m Filters = filters . to Array ( new Sam Filter [ filters . size ( ) ] ) ; }
Previous Word Action ( String nm , boolean select ) { super ( nm ) ; this . select = select ; }
static Unix Stream < String > cat ( final String file Path ) throws IO Exception { Objects . require Non Null ( file Path , STRING ) ; return new Unix Stream Impl < > ( lines ( Paths . get ( file Path ) ) ) ; }
private static String encode base 64 ( byte d [ ] , int len ) throws Illegal Argument Exception { int off = NUM ; String Buffer rs = new String Buffer ( ) ; int c1 , c2 ; if ( len <= NUM || len > d . length ) { throw new Illegal Argument Exception ( STRING ) ; } while ( off < len ) { c1 = d [ off ++ ] & NUM ; rs . append ( base 64 code [ ( c1 > > NUM ) & NUM ] ) ; c1 = ( c1 & NUM ) << NUM ; if ( off >= len ) { rs . append ( base 64 code [ c1 & NUM ] ) ; break ; } c2 = d [ off ++ ] & NUM ; c1 |= ( c2 > > NUM ) & NUM ; rs . append ( base 64 code [ c1 & NUM ] ) ; c1 = ( c2 & NUM ) << NUM ; if ( off >= len ) { rs . append ( base 64 code [ c1 & NUM ] ) ; break ; } c2 = d [ off ++ ] & NUM ; c1 |= ( c2 > > NUM ) & NUM ; rs . append ( base 64 code [ c1 & NUM ] ) ; rs . append ( base 64 code [ c2 & NUM ] ) ; } return rs . to String ( ) ; }
protected void eleminate Redundent ( Elem Template Element psuedo Var Recipient , Vector paths ) { int n = paths . size ( ) ; int num Paths Eliminated = NUM ; int num Unique Paths Eliminated = NUM ; for ( int i = NUM ; i < n ; i ++ ) { Expression Owner owner = ( Expression Owner ) paths . element At ( i ) ; if ( null != owner ) { int found = find And Eliminate Redundant ( i + NUM , i , owner , psuedo Var Recipient , paths ) ; if ( found > NUM ) num Unique Paths Eliminated ++ ; num Paths Eliminated += found ; } } eleminate Shared Partial Paths ( psuedo Var Recipient , paths ) ; if ( DIAGNOSE NUM PATHS REDUCED ) diagnose Num Paths ( paths , num Paths Eliminated , num Unique Paths Eliminated ) ; }
public void commercial Result ( String stream , String result Text , Request Result result ) { set Commercial Result ( Date Time . current Time ( ) + STRING + result Text ) ; last Commercial Run Attempt = System . current Time Millis ( ) ; set Loading Commercial ( BOOL ) ; if ( result == Twitch Api . Request Result . RUNNING COMMERCIAL ) { last Commercial . put ( stream , System . current Time Millis ( ) ) ; if ( stream != null && stream . equals ( current Channel ) ) { last Commercial Run = System . current Time Millis ( ) ; } } }
void add Fill Components ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( NUM , NUM ) ; boolean filled cell 11 = BOOL ; Cell Constraints cc = new Cell Constraints ( ) ; if ( cols . length > NUM && rows . length > NUM ) { if ( cols [ NUM ] == NUM && rows [ NUM ] == NUM ) { panel . add ( Box . create Rigid Area ( filler ) , cc . xy ( NUM , NUM ) ) ; filled cell 11 = BOOL ; } } for ( int index = NUM ; index < cols . length ; index ++ ) { if ( cols [ index ] == NUM && filled cell 11 ) { continue ; } panel . add ( Box . create Rigid Area ( filler ) , cc . xy ( cols [ index ] , NUM ) ) ; } for ( int index = NUM ; index < rows . length ; index ++ ) { if ( rows [ index ] == NUM && filled cell 11 ) { continue ; } panel . add ( Box . create Rigid Area ( filler ) , cc . xy ( NUM , rows [ index ] ) ) ; } }
public void done ( ) throws IO Exception { if ( ! initial Styles ) { write Initial Styles ( ) ; initial Styles = BOOL ; } out . write U Bits ( NUM , NUM ) ; out . flush Bits ( ) ; if ( bout != null && glyph Count > NUM ) { byte [ ] glyph Bytes = bout . to Byte Array ( ) ; glyph Byte Arrays . add ( glyph Bytes ) ; } if ( glyph Count > NUM ) { bout = new Byte Array Output Stream ( ) ; out = new Out Stream ( bout ) ; glyph Count -- ; fill 1 Index = NUM ; line Index = NUM ; outstanding Changes = BOOL ; initial Styles = BOOL ; } else { if ( bout != null ) { finish Font ( ) ; } writer . complete Tag ( ) ; } }
private static Detach ISO Response check Detach ISO Response ( Detach ISO Response detach ISO Response ) throws Rpc Exception { logger . info ( STRING , detach ISO Response ) ; switch ( detach ISO Response . get Result ( ) ) { case OK : break ; case ISO NOT ATTACHED : logger . warn ( STRING , detach ISO Response ) ; throw new Iso Not Attached Exception ( detach ISO Response . get Error ( ) ) ; case SYSTEM ERROR : logger . warn ( STRING , detach ISO Response ) ; throw new System Error Exception ( detach ISO Response . get Error ( ) ) ; case VM NOT FOUND : logger . warn ( STRING , detach ISO Response ) ; throw new Vm Not Found Exception ( detach ISO Response . get Error ( ) ) ; default : throw new Rpc Exception ( String . format ( STRING , detach ISO Response . get Result ( ) ) ) ; } return detach ISO Response ; }
public boolean is terminal ( Method Or Method Context mc ) { Stack < Soot Method > sys stack = new Stack < Soot Method > ( ) ; boolean result ; if ( ! is system ( mc . method ( ) ) ) result = BOOL ; else { if ( ! process callbacks ) result = BOOL ; else { if ( ( stack . size ( ) > NUM ) && is system ( stack . peek ( ) ) ) result = ! calls app method ( mc , sys stack ) ; else { if ( can have callbacks ( mc . method ( ) ) ) result = ! calls app method ( mc , sys stack ) ; else result = BOOL ; } } } logger . info ( STRING , mc . method ( ) , result ) ; return result ; }
boolean try Match ( S Node s ) { if ( match == null && UNSAFE . compare And Swap Object ( this , match Offset , null , s ) ) { Thread w = waiter ; if ( w != null ) { waiter = null ; Lock Support . unpark ( w ) ; } return BOOL ; } return match == s ; }
public void add Item ( int position , M model ) { m Datas . add ( position , model ) ; notify Item Inserted ( position ) ; }
public final Set < String > aliases ( ) { return Collections . unmodifiable Set ( this . aliases Set ) ; }
public void encode ( Output Stream out ) throws IO Exception { Der Output Stream tmp = new Der Output Stream ( ) ; if ( this . extension Value == null ) { this . extension Id = PKIX Extensions . Issuing Distribution Point Id ; this . critical = BOOL ; encode This ( ) ; } super . encode ( tmp ) ; out . write ( tmp . to Byte Array ( ) ) ; }
public final void read Children ( Object Input Stream ois ) throws IO Exception , Class Not Found Exception { int count = serializable ; while ( count -- > NUM ) { Object child = null ; Bean Context Support . BCS Child bscc = null ; try { child = ois . read Object ( ) ; bscc = ( Bean Context Support . BCS Child ) ois . read Object ( ) ; } catch ( IO Exception ioe ) { continue ; } catch ( Class Not Found Exception cnfe ) { continue ; } synchronized ( child ) { Bean Context Child bcc = null ; try { bcc = ( Bean Context Child ) child ; } catch ( Class Cast Exception cce ) { } if ( bcc != null ) { try { bcc . set Bean Context ( get Bean Context Peer ( ) ) ; bcc . add Property Change Listener ( STRING , child PCL ) ; bcc . add Vetoable Change Listener ( STRING , child VCL ) ; } catch ( Property Veto Exception pve ) { continue ; } } child Deserialized Hook ( child , bscc ) ; } } }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return SUCCESS ; default : return null ; } }
static boolean is Christmas Time ( Calendar cal ) { int month = cal . get ( Calendar . MONTH ) ; int day = cal . get ( Calendar . DAY OF MONTH ) ; if ( month >= NUM && month < NUM ) { return BOOL ; } if ( month == NUM ) { return day <= NUM ; } if ( month == NUM ) { return day >= NUM ; } return BOOL ; }
@ Override public void zoom Range Axes ( double factor , Plot Rendering Info info , Point 2 D source ) { zoom Range Axes ( factor , info , source , BOOL ) ; }
@ Override public boolean connection Allowed ( Event Set Descriptor esd ) { return connection Allowed ( esd . get Name ( ) ) ; }
private void board Save Image ( ) { if ( curfile Image == null ) { board Save As Image ( ) ; return ; } J Dialog wait D = new J Dialog ( frame , Messages . get String ( STRING ) ) ; wait D . add ( new J Label ( Messages . get String ( STRING ) ) ) ; wait D . set Size ( NUM , NUM ) ; wait D . set Location ( ( frame . get Size ( ) . width / NUM ) - ( wait D . get Size ( ) . width / NUM ) , ( frame . get Size ( ) . height / NUM ) - ( wait D . get Size ( ) . height / NUM ) ) ; wait D . set Visible ( BOOL ) ; frame . set Cursor ( Cursor . get Predefined Cursor ( Cursor . WAIT CURSOR ) ) ; wait D . set Cursor ( Cursor . get Predefined Cursor ( Cursor . WAIT CURSOR ) ) ; try { Image IO . write ( bv . get Entire Board Image ( ) , STRING , curfile Image ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } wait D . set Visible ( BOOL ) ; frame . set Cursor ( Cursor . get Default Cursor ( ) ) ; }
public boolean contains Name ( String type , String name ) { List < String > names = get Names ( type ) ; return names . contains ( name ) ; }
@ Suppress Warnings ( STRING ) public static < C extends Result > Array List < C > filter Results ( Result Hierarchy hier , Result r , Class < ? super C > restriction Class ) { Array List < C > res = new Array List < > ( ) ; if ( restriction Class . is Instance ( r ) ) { res . add ( ( C ) restriction Class . cast ( r ) ) ; } for ( Hierarchy . Iter < Result > iter = hier . iter Descendants ( r ) ; iter . valid ( ) ; iter . advance ( ) ) { Result result = iter . get ( ) ; if ( restriction Class . is Instance ( result ) ) { res . add ( ( C ) restriction Class . cast ( result ) ) ; } } return res ; }
private boolean has Next Proxy ( ) { return next Proxy Index < proxies . size ( ) ; }
@ Pure @ Causes Error ( { Incorrect Pure 4 J Immutable Call Exception . class , Pure Method Parameter Not Immutable Exception . class } ) public String test Param 1 Bad ( Object in 1 , Object in 2 ) { Object in 3 = in 2 ; Pure 4 J . immutable ( in 1 , in 2 ) ; return in 3 . to String ( ) ; }
protected boolean [ ] can Handle Missing ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing , int missing Level ) { if ( missing Level == NUM ) { print ( STRING ) ; } print ( STRING ) ; if ( predictor Missing ) { print ( STRING ) ; if ( class Missing ) { print ( STRING ) ; } } if ( class Missing ) { print ( STRING ) ; } print ( STRING ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( STRING ) ; Array List < String > accepts = new Array List < String > ( ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; int num Train = get Num Instances ( ) , num Classes = NUM ; return run Basic Test ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type , missing Level , predictor Missing , class Missing , num Train , num Classes , accepts ) ; }
public Set < Brd Item > pick items ( Pla Point p location , int p layer , Item Selection Filter p filter ) { Set < Brd Item > result = new Tree Set < Brd Item > ( ) ; Shape Tile Box point shape = p location . to box ( ) ; Collection < Awtree Object > overlaps = overlapping objects ( point shape , p layer ) ; for ( Awtree Object curr object : overlaps ) { if ( ! ( curr object instanceof Brd Item ) ) continue ; Brd Item curr item = ( Brd Item ) curr object ; if ( ! curr item . is selected by filter ( p filter ) ) continue ; result . add ( curr item ) ; } return result ; }
public boolean is Collinear With ( Vector other ) { if ( x == NUM && y == NUM && z == NUM ) { return BOOL ; } final double other X = other . x ; final double other Y = other . y ; final double other Z = other . z ; if ( other X == NUM && other Y == NUM && other Z == NUM ) { return BOOL ; } if ( ( x == NUM ) != ( other X == NUM ) ) return BOOL ; if ( ( y == NUM ) != ( other Y == NUM ) ) return BOOL ; if ( ( z == NUM ) != ( other Z == NUM ) ) return BOOL ; final double quotient X = other X / x ; if ( ! Double . is Na N ( quotient X ) ) { return other . equals ( multiply ( quotient X ) ) ; } final double quotient Y = other Y / y ; if ( ! Double . is Na N ( quotient Y ) ) { return other . equals ( multiply ( quotient Y ) ) ; } final double quotient Z = other Z / z ; if ( ! Double . is Na N ( quotient Z ) ) { return other . equals ( multiply ( quotient Z ) ) ; } throw new Runtime Exception ( STRING ) ; }
public void receive ( float [ ] current FFT Bins ) { if ( Float . is Infinite ( current FFT Bins [ NUM ] ) || Float . is Na N ( current FFT Bins [ NUM ] ) ) { current FFT Bins = new float [ current FFT Bins . length ] ; } if ( m Display FFT Bins == null || m Display FFT Bins . length != current FFT Bins . length ) { m Display FFT Bins = current FFT Bins ; } float [ ] smoothed Bins = m Smoothing Filter . filter ( current FFT Bins ) ; if ( m Averaging > NUM ) { float gain = NUM / ( float ) m Averaging ; for ( int x = NUM ; x < m Display FFT Bins . length ; x ++ ) { m Display FFT Bins [ x ] += ( smoothed Bins [ x ] - m Display FFT Bins [ x ] ) * gain ; } } else { m Display FFT Bins = smoothed Bins ; } repaint ( ) ; }
@ Override public void execution Unit Imported ( final Execution Unit process , final Element element ) { Node List children = element . get Child Nodes ( ) ; children = element . get Child Nodes ( ) ; for ( int i = NUM ; i < children . get Length ( ) ; i ++ ) { Node child = children . item ( i ) ; if ( child instanceof Element ) { Element background Element = ( Element ) child ; if ( XML TAG BACKGROUND . equals ( background Element . get Tag Name ( ) ) ) { String x Str = background Element . get Attribute ( XML ATTRIBUTE X POSITION ) ; String y Str = background Element . get Attribute ( XML ATTRIBUTE Y POSITION ) ; String w Str = background Element . get Attribute ( XML ATTRIBUTE WIDTH ) ; String h Str = background Element . get Attribute ( XML ATTRIBUTE HEIGHT ) ; String img Loc Str = background Element . get Attribute ( XML ATTRIBUTE LOCATION ) ; try { int x Loc = Integer . parse Int ( x Str ) ; int y Loc = Integer . parse Int ( y Str ) ; int w Loc = Integer . parse Int ( w Str ) ; int h Loc = Integer . parse Int ( h Str ) ; Process Background Image bg Img = new Process Background Image ( x Loc , y Loc , w Loc , h Loc , img Loc Str , process ) ; set Background Image ( bg Img ) ; } catch ( Null Pointer Exception | Illegal Argument Exception e ) { } } } } }
private void send Mail To Queue ( String to , String subject , String content , boolean is Multipart , boolean is Html ) { Email Params email Params = new Email Params ( to , subject , content , is Multipart , is Html ) ; rabbit Template . convert And Send ( Rabbitmq Configuration . QUEUE SEND EMAIL , email Params ) ; }
public Mersenne Twister RNG ( final byte [ ] seed ) { if ( seed == null || seed . length != SEED SIZE BYTES ) { throw new Illegal Argument Exception ( STRING ) ; } this . seed = seed . clone ( ) ; final int [ ] seed Ints = convert Bytes To Ints ( this . seed ) ; mt [ NUM ] = BOOTSTRAP SEED ; for ( mt Index = NUM ; mt Index < N ; mt Index ++ ) { mt [ mt Index ] = BOOTSTRAP FACTOR * ( mt [ mt Index - NUM ] ^ mt [ mt Index - NUM ] > > > NUM ) + mt Index ; } int i = NUM ; int j = NUM ; for ( int k = Math . max ( N , seed Ints . length ) ; k > NUM ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( mt [ i - NUM ] ^ mt [ i - NUM ] > > > NUM ) * SEED FACTOR 1 ) + seed Ints [ j ] + j ; i ++ ; j ++ ; if ( i >= N ) { mt [ NUM ] = mt [ N - NUM ] ; i = NUM ; } if ( j >= seed Ints . length ) { j = NUM ; } } for ( int k = N - NUM ; k > NUM ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( mt [ i - NUM ] ^ mt [ i - NUM ] > > > NUM ) * SEED FACTOR 2 ) - i ; i ++ ; if ( i >= N ) { mt [ NUM ] = mt [ N - NUM ] ; i = NUM ; } } mt [ NUM ] = UPPER MASK ; }
private Set < Object Instance > filter List Of Object Instances ( Set < Object Instance > list , Query Exp query ) { if ( query == null ) { return list ; } else { Set < Object Instance > result = new Hash Set < Object Instance > ( ) ; for ( Object Instance oi : list ) { boolean res = BOOL ; M Bean Server old Server = Query Eval . get M Bean Server ( ) ; query . set M Bean Server ( server ) ; try { res = query . apply ( oi . get Object Name ( ) ) ; } catch ( Exception e ) { res = BOOL ; } finally { query . set M Bean Server ( old Server ) ; } if ( res ) { result . add ( oi ) ; } } return result ; } }
private void translate Matrix After Rotate ( int axis , float trans , float prev Image Size , float image Size , int prev View Size , int view Size , int drawable Size ) { if ( image Size < view Size ) { m [ axis ] = ( view Size - ( drawable Size * m [ Matrix . MSCALE X ] ) ) * NUM ; } else if ( trans > NUM ) { m [ axis ] = - ( ( image Size - view Size ) * NUM ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM * prev View Size ) ) / prev Image Size ; m [ axis ] = - ( ( percentage * image Size ) - ( view Size * NUM ) ) ; } }
@ Path ( STRING ) @ Timed @ Exception Metered @ GET public Automation Secret Response read Secret By Id ( @ Auth Automation Client automation Client , @ Path Param ( STRING ) Long Param secret Id ) { Optional < Secret > secret = secret Controller . get Secret By Id ( secret Id . get ( ) ) ; if ( ! secret . is Present ( ) ) { throw new Not Found Exception ( STRING ) ; } Immutable List < Group > groups = Immutable List . copy Of ( acl DAO . get Groups For ( secret . get ( ) ) ) ; return Automation Secret Response . from Secret ( secret . get ( ) , groups ) ; }
protected void add Action Exception Warning ( Exception e ) { String msg = e . get Message ( ) ; if ( msg != null ) { warnings . add ( msg ) ; } }
private void generate Field Infos ( I Type type , I Binary Type type Info , Hash Map new Elements , Array List children Handles ) { I Binary Field [ ] fields = type Info . get Fields ( ) ; if ( fields == null ) { return ; } Java Model Manager manager = ( ( Java Element ) type ) . manager ; for ( int i = NUM , field Count = fields . length ; i < field Count ; i ++ ) { I Binary Field field Info = fields [ i ] ; Binary Field field = new Binary Field ( ( Java Element ) type , manager , manager . intern ( new String ( field Info . get Name ( ) ) ) ) ; new Elements . put ( field , field Info ) ; children Handles . add ( field ) ; generate Annotations Infos ( field , field Info . get Annotations ( ) , field Info . get Tag Bits ( ) , new Elements ) ; } }
public void test Formatting Year ( ) { Format Tester test = new Format Tester ( ) ; Calendar cal = new Gregorian Calendar ( NUM , Calendar . JUNE , NUM , NUM , NUM , NUM ) ; test . test ( STRING , cal , STRING , Date Format . YEAR FIELD ) ; test . test ( STRING , cal , STRING , Date Format . YEAR FIELD ) ; test . test ( STRING , new Gregorian Calendar ( NUM , Calendar . JUNE , NUM ) , STRING , Date Format . YEAR FIELD ) ; test . test ( STRING , new Gregorian Calendar ( NUM , Calendar . JUNE , NUM ) , STRING , Date Format . YEAR FIELD ) ; test . test ( STRING , new Gregorian Calendar ( NUM , Calendar . JUNE , NUM ) , STRING , Date Format . YEAR FIELD ) ; test . test ( STRING , cal , STRING , Date Format . YEAR FIELD ) ; test . test ( STRING , cal , STRING , Date Format . YEAR FIELD ) ; test . test ( STRING , cal , STRING , Date Format . YEAR FIELD ) ; assert False ( test . tests Failed ) ; }
public List < String > generate Model ( String schema , String table , String package Name , boolean annotate Schema , boolean trim Strings ) { try { List < String > models = New . array List ( ) ; List < Table Inspector > tables = get Tables ( schema , table ) ; for ( Table Inspector t : tables ) { t . read ( meta Data ) ; String model = t . generate Model ( package Name , annotate Schema , trim Strings ) ; models . add ( model ) ; } return models ; } catch ( SQL Exception s ) { throw new Runtime Exception ( s ) ; } }
public static Ed 25519 Encoded Field Element to Encoded Field Element ( final Big Integer b ) { return new Ed 25519 Encoded Field Element ( to Byte Array ( b ) ) ; }
private void merge Collapse ( ) { while ( stack Size > NUM ) { int n = stack Size - NUM ; if ( n > NUM && run Len [ n - NUM ] <= run Len [ n ] + run Len [ n + NUM ] ) { if ( run Len [ n - NUM ] < run Len [ n + NUM ] ) n -- ; merge At ( n ) ; } else if ( run Len [ n ] <= run Len [ n + NUM ] ) { merge At ( n ) ; } else { break ; } } }
protected Array List < Key Name Pair > load RMA Data ( int C B Partner ID ) { Array List < Key Name Pair > list = new Array List < Key Name Pair > ( ) ; String sql Stmt = STRING + STRING + STRING + STRING + STRING + STRING ; Prepared Statement pstmt = null ; try { pstmt = DB . prepare Statement ( sql Stmt , null ) ; pstmt . set Int ( NUM , C B Partner ID ) ; Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { list . add ( new Key Name Pair ( rs . get Int ( NUM ) , rs . get String ( NUM ) ) ) ; } rs . close ( ) ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql Stmt . to String ( ) , e ) ; } finally { if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( Exception ex ) { log . severe ( STRING ) ; } } } return list ; }
private void check Send Track To Google ( ) { if ( ! send To Google ( activity My Tracks . get String ( R . string . export google maps ) ) || ! send To Google ( activity My Tracks . get String ( R . string . export google fusion tables ) ) || ! send To Google ( activity My Tracks . get String ( R . string . export google spreadsheets ) ) ) { return ; } assert True ( Google Utils . delete Maps ( activity My Tracks . get Application Context ( ) , Google Utils . ACCOUNT 1 , End To End Test Utils . track Name ) ) ; assert True ( Google Utils . delete Fusion Tables ( activity My Tracks . get Application Context ( ) , Google Utils . ACCOUNT 1 , End To End Test Utils . track Name ) ) ; assert True ( Google Utils . delete Spreadsheets Row ( activity My Tracks . get Application Context ( ) , Google Utils . ACCOUNT 1 , End To End Test Utils . track Name ) ) ; }
private void check Bounded Type Parameter ( Method method ) { Type Variable < Method > type Parameter = get Type Parameter ( method ) ; assert Equals ( STRING , type Parameter . get Name ( ) ) ; assert Equals ( method , type Parameter . get Generic Declaration ( ) ) ; Type [ ] bounds = type Parameter . get Bounds ( ) ; assert Lenght One ( bounds ) ; Type bound = bounds [ NUM ] ; assert Equals ( Bounded Wildcards Generic Methods . class , bound ) ; }
private byte [ ] entity To Bytes ( Http Entity entity ) throws IO Exception , Server Error { Pooling Byte Array Output Stream bytes = new Pooling Byte Array Output Stream ( m Pool , ( int ) entity . get Content Length ( ) ) ; byte [ ] buffer = null ; try { Input Stream in = entity . get Content ( ) ; if ( in == null ) { throw new Server Error ( ) ; } buffer = m Pool . get Buf ( NUM ) ; int count ; while ( ( count = in . read ( buffer ) ) != - NUM ) { bytes . write ( buffer , NUM , count ) ; } return bytes . to Byte Array ( ) ; } finally { try { entity . consume Content ( ) ; } catch ( IO Exception e ) { Volley Log . v ( STRING ) ; } m Pool . return Buf ( buffer ) ; bytes . close ( ) ; } }
public void on Dependency Changed ( Preference dependency , boolean disable Dependent ) { if ( m Dependency Met == disable Dependent ) { m Dependency Met = ! disable Dependent ; notify Dependency Change ( should Disable Dependents ( ) ) ; notify Changed ( ) ; } }
@ Override public Double analyse ( double [ ] frame ) { if ( frame . length != get Frame Length Samples ( ) ) throw new Illegal Argument Exception ( STRING + get Frame Length Samples ( ) + STRING + frame . length ) ; double total Energy = NUM ; for ( int i = NUM ; i < frame . length ; i ++ ) { total Energy += frame [ i ] * frame [ i ] ; } remember Frame Energy ( total Energy ) ; return new Double ( total Energy ) ; }
public static Element first Child Element ( Element element ) { if ( element == null ) return null ; Node node = element . get First Child ( ) ; if ( node != null ) { do { if ( node . get Node Type ( ) == Node . ELEMENT NODE ) { Element child Element = ( Element ) node ; return child Element ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; } return null ; }
private static void partial Match ( Dimensional Node node , boolean [ ] relevant , double [ ] keys , Array List < I Multi Point > results ) { I Multi Point pt = node . point ; boolean match = BOOL ; for ( int i = NUM ; i < relevant . length ; i ++ ) { if ( ! relevant [ i ] ) continue ; if ( ! Floating Point . same ( pt . get Coordinate ( i + NUM ) , keys [ i ] ) ) { match = BOOL ; break ; } } if ( match ) { results . add ( pt ) ; } int d = node . dimension ; if ( relevant [ d - NUM ] ) { if ( Floating Point . lesser Equals ( keys [ d - NUM ] , pt . get Coordinate ( d ) ) ) { Dimensional Node below = node . get Below ( ) ; if ( below != null ) { partial Match ( below , relevant , keys , results ) ; } } if ( Floating Point . greater Equals ( keys [ d - NUM ] , pt . get Coordinate ( d ) ) ) { Dimensional Node above = node . get Above ( ) ; if ( above != null ) { partial Match ( above , relevant , keys , results ) ; } } } else { Dimensional Node below = node . get Below ( ) ; if ( below != null ) { partial Match ( below , relevant , keys , results ) ; } Dimensional Node above = node . get Above ( ) ; if ( above != null ) { partial Match ( above , relevant , keys , results ) ; } } }
public int decrypt Block ( byte [ ] in , int in Off , byte [ ] out , int out Off ) throws Data Length Exception , Illegal State Exception { if ( ( in Off + block Size ) > in . length ) { throw new Data Length Exception ( STRING ) ; } if ( ( out Off + block Size ) > out . length ) { throw new Data Length Exception ( STRING ) ; } cipher . process Block ( cfb V , NUM , cfb Out V , NUM ) ; System . arraycopy ( cfb V , block Size , cfb V , NUM , cfb V . length - block Size ) ; System . arraycopy ( in , in Off , cfb V , cfb V . length - block Size , block Size ) ; for ( int i = NUM ; i < block Size ; i ++ ) { out [ out Off + i ] = ( byte ) ( cfb Out V [ i ] ^ in [ in Off + i ] ) ; } return block Size ; }
public static String encode For Redirect ( final String str ) { String class Method = STRING ; byte [ ] input ; try { input = str . get Bytes ( STRING ) ; } catch ( Unsupported Encoding Exception uee ) { debug . error ( class Method + STRING , uee ) ; return null ; } Deflater deflater = new Deflater ( Deflater . DEFAULT COMPRESSION , BOOL ) ; Byte Array Output Stream out = new Byte Array Output Stream ( ) ; Deflater Output Stream deflater Output Stream = new Deflater Output Stream ( out , deflater ) ; try { deflater Output Stream . write ( input ) ; } catch ( IO Exception e ) { debug . error ( class Method + STRING , e ) ; return null ; } finally { IO Utils . close If Not Null ( deflater Output Stream ) ; } String encoded = URL Enc Dec . encode ( Base 64 . encode ( out . to Byte Array ( ) ) ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING + encoded . length ( ) ) ; debug . message ( class Method + STRING + encoded + STRING ) ; } return encoded ; }
private void save Touch Start ( Motion Event event ) { m Saved Matrix . set ( m Matrix ) ; m Touch Start Point . set ( event . get X ( ) , event . get Y ( ) ) ; m Closest Data Set To Touch = m Chart . get Data Set By Touch Point ( event . get X ( ) , event . get Y ( ) ) ; }
public static boolean is Nested Mapping ( String regex ) { return regex . starts With ( NESTED MAPPING STARTS SYMBOL ) && regex . ends With ( NESTED MAPPING ENDS SYMBOL ) ; }
@ Override public Writer append ( Char Sequence value ) { builder . append ( value ) ; return this ; }
public static boolean null Equals ( String s1 , String s2 ) { return ( s1 == null ? s2 == null : s1 . equals ( s2 ) ) ; }
public String to String ( ) { return super . to String ( ) + STRING + String . value Of ( date ) ; }
private boolean has Images ( I Action action To Check ) { return action To Check . get Image Descriptor ( ) != null || action To Check . get Hover Image Descriptor ( ) != null || action To Check . get Disabled Image Descriptor ( ) != null ; }
public double calc Angle Between Lines ( Entry start 1 , Entry end 1 , Entry start 2 , Entry end 2 ) { double angle 1 = calc Angle With Ratios ( start 1 , end 1 ) ; double angle 2 = calc Angle With Ratios ( start 2 , end 2 ) ; return Math . abs ( angle 1 - angle 2 ) ; }
public Byte Vector put Byte Array ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b != null ) { System . arraycopy ( b , off , data , length , len ) ; } length += len ; return this ; }
public double convert To Attrib X ( double scx ) { double temp = m Xaxis End - m Xaxis Start ; double temp 2 = ( ( scx - m Xaxis Start ) * ( m max X - m min X ) ) / temp ; temp 2 = temp 2 + m min X ; return temp 2 ; }
public void complete Executor Task ( ) { Executor Queue Item item = null ; synchronized ( executor Lock ) { executor Task Count -- ; assert ( executor Task Count >= NUM ) ; if ( executor Queue Head != null ) { item = executor Queue Head ; executor Queue Head = item . next ; if ( executor Queue Head == null ) executor Queue Tail = null ; } } if ( item != null ) { Runnable task = item . get Runnable ( ) ; Class Loader loader = item . get Loader ( ) ; boolean is Priority = BOOL ; boolean is Queue = BOOL ; boolean is Wake = BOOL ; schedule Impl ( task , loader , MAX EXPIRE , is Priority , is Queue , is Wake ) ; } }
public static void force Mkdir ( File directory ) throws IO Exception { if ( directory . exists ( ) ) { if ( ! directory . is Directory ( ) ) { String message = STRING + directory + STRING + STRING ; throw new IO Exception ( message ) ; } } else { if ( ! directory . mkdirs ( ) ) { if ( ! directory . is Directory ( ) ) { String message = STRING + directory ; throw new IO Exception ( message ) ; } } } }
private < T > int count Cleared Refs ( List < Weak Reference < T > > refs ) { final Iterator < Weak Reference < T > > itr = refs . iterator ( ) ; int n = NUM ; while ( itr . has Next ( ) ) { final Weak Reference < T > ref = itr . next ( ) ; if ( ref . get ( ) == null ) n ++ ; } return n ; }
protected void read Image ( ) { ix = read Short ( ) ; iy = read Short ( ) ; iw = read Short ( ) ; ih = read Short ( ) ; int packed = read ( ) ; lct Flag = ( packed & NUM ) != NUM ; interlace = ( packed & NUM ) != NUM ; lct Size = NUM << ( packed & NUM ) ; if ( lct Flag ) { lct = read Color Table ( lct Size ) ; act = lct ; } else { act = gct ; if ( bg Index == trans Index ) bg Color = NUM ; } int save = NUM ; if ( transparency ) { save = act [ trans Index ] ; act [ trans Index ] = NUM ; } if ( act == null ) { status = STATUS FORMAT ERROR ; } if ( err ( ) ) return ; decode Image Data ( ) ; skip ( ) ; if ( err ( ) ) return ; frame Count ++ ; image = new Buffered Image ( width , height , Buffered Image . TYPE INT ARGB PRE ) ; set Pixels ( ) ; frames . add ( new Gif Frame ( image , delay ) ) ; if ( transparency ) { act [ trans Index ] = save ; } reset Frame ( ) ; }
protected void add Projected Field ( String s ) { try { Field f = in Clazz . get Declared Field ( s ) ; Type Info t = new Type Info ( f . get Name ( ) , Class Utils . primitive To Wrapper ( f . get Type ( ) ) ) ; t . getter = Pojo Utils . create Getter ( in Clazz , t . name , t . type ) ; t . setter = Pojo Utils . create Setter ( projected Clazz , t . name , t . type ) ; projected Fields . add ( t ) ; } catch ( No Such Field Exception e ) { throw new Runtime Exception ( STRING + s + STRING + in Clazz , e ) ; } }
protected Object evaluate Left Greater Right ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Left Greater Right ( ( Structured Content ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM ) { return ( Structured Content ) array . get ( NUM ) ; } return array ; }
public Optional < Double > avg ( ) { if ( is Empty ( ) ) return Optional . empty ( ) ; return Optional . of ( sum ( ) / get Event Count ( ) ) ; }
public static boolean is SU ( String shell ) { int pos = shell . index Of ( STRING ) ; if ( pos >= NUM ) { shell = shell . substring ( NUM , pos ) ; } pos = shell . last Index Of ( STRING ) ; if ( pos >= NUM ) { shell = shell . substring ( pos + NUM ) ; } return shell . equals ( STRING ) ; }
private boolean is Valid ( int type , String value ) { if ( value == null ) { return BOOL ; } if ( ALLOWED STRINGS [ type ] != null ) { return verify String Group ( value , ALLOWED STRINGS [ type ] ) ; } switch ( type ) { case TYPE NUMBER : return verify ( value , DIGITS , null ) ; case TYPE PIXELS OR PERCENTAGE : if ( value . ends With ( STRING ) ) { value = value . substring ( NUM , value . length ( ) - NUM ) ; } else if ( value . ends With ( STRING ) ) { value = value . substring ( NUM , value . length ( ) - NUM ) ; } return verify ( value , DIGITS , null ) ; case TYPE CHAR : return verify ( value , DIGITS | ABC , null , NUM , NUM ) ; case TYPE COLOR : if ( value . length ( ) == NUM ) { return BOOL ; } if ( value . char At ( NUM ) != STRING ) { return verify String Group ( value , COLOR STRINGS ) ; } else { return verify ( value . substring ( NUM ) , HEX , null , NUM , NUM ) ; } default : return BOOL ; } }
protected synchronized Class load Class ( String name , boolean resolve ) throws Class Not Found Exception { Class c = find Loaded Class ( name ) ; if ( c == null ) c = find Class ( name ) ; if ( c == null ) throw new Class Not Found Exception ( name ) ; if ( resolve ) resolve Class ( c ) ; return c ; }
private int parse Streams ( String json , Set < Stream Info > stream Infos ) { try { JSON Parser parser = new JSON Parser ( ) ; JSON Array streams Array ; try { JSON Object root = ( JSON Object ) parser . parse ( json ) ; streams Array = ( JSON Array ) root . get ( STRING ) ; } catch ( Class Cast Exception ex ) { LOGGER . warning ( STRING ) ; streams Request Error ( stream Infos ) ; return - NUM ; } if ( streams Array == null ) { LOGGER . warning ( STRING ) ; streams Request Error ( stream Infos ) ; return - NUM ; } for ( Object obj : streams Array ) { if ( obj instanceof JSON Object ) { Stream Info parsed Info = parse Stream ( ( JSON Object ) obj , stream Infos == null ) ; if ( parsed Info == null ) { LOGGER . warning ( STRING + ( JSON Object ) obj ) ; } if ( stream Infos != null ) { stream Infos . remove ( parsed Info ) ; } } else { LOGGER . warning ( STRING + obj ) ; } } if ( stream Infos != null ) { for ( Stream Info info : stream Infos ) { info . set Offline ( ) ; } } return streams Array . size ( ) ; } catch ( Parse Exception ex ) { LOGGER . warning ( STRING + ex . get Localized Message ( ) ) ; streams Request Error ( stream Infos ) ; return - NUM ; } }
public Str Tokenizer reset ( String input ) { reset ( ) ; if ( input != null ) { this . chars = input . to Char Array ( ) ; } else { this . chars = null ; } return this ; }
public void run Test ( ) throws Throwable { Document doc ; Entity Reference ent Ref ; Character Data ent Text ; doc = ( Document ) load ( STRING , BOOL ) ; ent Ref = doc . create Entity Reference ( STRING ) ; assert Not Null ( STRING , ent Ref ) ; ent Text = ( Character Data ) ent Ref . get First Child ( ) ; assert Not Null ( STRING , ent Text ) ; { boolean success = BOOL ; try { ent Text . set Node Value ( STRING ) ; } catch ( DOM Exception ex ) { success = ( ex . code == DOM Exception . NO MODIFICATION ALLOWED ERR ) ; } assert True ( STRING , success ) ; } }
public void remove Listener ( final I Visual Coverage Listener listener ) { listeners . remove ( listener ) ; }
@ Objective C Name ( STRING ) public boolean is Large Dialog Message ( Content Type content Type ) { switch ( content Type ) { case SERVICE : case SERVICE AVATAR : case SERVICE AVATAR REMOVED : case SERVICE CREATED : case SERVICE TITLE : case SERVICE LEAVE : case SERVICE REGISTERED : case SERVICE KICK : case SERVICE ADD : case SERVICE JOINED : case SERVICE CALL ENDED : case SERVICE CALL MISSED : case SERVICE ABOUT : case SERVICE TOPIC : return BOOL ; default : return BOOL ; } }
public static boolean is Logging Behavior Enabled ( Logging Behavior behavior ) { synchronized ( logging Behaviors ) { return Facebook Sdk . is Debug Enabled ( ) && logging Behaviors . contains ( behavior ) ; } }
private void on Attacked ( final Entity attacker ) { attackers . remove ( attacker ) ; attackers . add ( attacker ) ; }
private void handle Disallow ( Parse State state , Robot Token token ) { if ( state . is Skip Agents ( ) ) { return ; } state . set Finished Agent Fields ( BOOL ) ; if ( ! state . is Adding Rules ( ) ) { return ; } String path = token . get Data ( ) ; try { path = URL Decoder . decode ( path , STRING ) ; if ( path . length ( ) == NUM ) { state . clear Rules ( ) ; } else { state . add Rule ( path , BOOL ) ; } } catch ( Exception e ) { report Warning ( STRING + path , state . get Url ( ) ) ; } }
public void hide Column ( Object column Name ) { if ( column Name == null ) { return ; } for ( int i = NUM ; i < column Model . get Column Count ( ) ; i ++ ) { Table Column column = column Model . get Column ( i ) ; if ( column Name . equals ( column . get Header Value ( ) ) ) { hide Column ( column ) ; break ; } } }
public static < T > Set < T > to Set ( T obj 1 , T obj 2 , T obj 3 , T obj 4 , T obj 5 , T obj 6 ) { Set < T > the Set = new Linked Hash Set < T > ( ) ; the Set . add ( obj 1 ) ; the Set . add ( obj 2 ) ; the Set . add ( obj 3 ) ; the Set . add ( obj 4 ) ; the Set . add ( obj 5 ) ; the Set . add ( obj 6 ) ; return the Set ; }
private boolean is ASCII Digit ( char c ) { return ( c >= STRING && c <= STRING ) ; }
public static String separators To Windows ( String path ) { if ( path == null || path . index Of ( UNIX SEPARATOR ) == - NUM ) { return path ; } return path . replace ( UNIX SEPARATOR , WINDOWS SEPARATOR ) ; }
public void accumulate All ( List < Tagged Log API Entity > entities ) throws Exception { for ( Tagged Log API Entity entity : entities ) { accumulate ( entity ) ; } }
protected void print Identifier ( String identifier , String Builder ddl ) { ddl . append ( get Delimited Identifier ( identifier ) ) ; }
public static int darker ( int c ) { return rgba ( Math . max ( NUM , ( int ) ( scale * red ( c ) ) ) , Math . max ( NUM , ( int ) ( scale * green ( c ) ) ) , Math . max ( NUM , ( int ) ( scale * blue ( c ) ) ) , alpha ( c ) ) ; }
private String to String ( final int size ) { if ( size < NUM ) { return String . format ( STRING , size ) ; } else if ( size < NUM * NUM ) { return String . format ( Locale . ENGLISH , STRING , NUM * size / NUM ) ; } else { return String . format ( Locale . ENGLISH , STRING , NUM * size / NUM / NUM ) ; } }
@ Known Failure ( STRING ) public void test get Columns Arbitrary ( ) throws SQL Exception { Result Set set All Null = null ; Result Set set Mixed = null ; Result Set all Arbitrary = null ; String [ ] tables Name = { Database Creator . TEST TABLE 1 , Database Creator . TEST TABLE 3 } ; Arrays . sort ( tables Name ) ; int set Size = NUM ; try { all Arbitrary = meta . get Columns ( STRING , STRING , STRING , STRING ) ; assert Not Null ( all Arbitrary ) ; check Columns Shape ( all Arbitrary ) ; set Size = cross Check Get Columns And Result Set Meta Data ( all Arbitrary , BOOL ) ; assert Equals ( NUM , set Size ) ; set Mixed = meta . get Columns ( null , null , STRING , STRING ) ; assert Not Null ( set Mixed ) ; check Columns Shape ( set Mixed ) ; set Size = cross Check Get Columns And Result Set Meta Data ( set Mixed , BOOL ) ; assert Equals ( NUM , set Size ) ; } catch ( SQL Exception e ) { fail ( STRING + e . get Message ( ) ) ; } conn . close ( ) ; try { meta . get Columns ( null , null , Database Creator . TEST TABLE 1 , STRING ) ; fail ( STRING ) ; } catch ( SQL Exception e ) { } }
static public Sdf Macro decode Instruction ( Sdf Buffer buff ) { Sdf Macro m ; if ( ( m = Channel Start . match ( buff ) ) != null ) { return m ; } else if ( ( m = Sdl Version . match ( buff ) ) != null ) { return m ; } else if ( ( m = Skeme Start . match ( buff ) ) != null ) { return m ; } else if ( ( m = Generate Trigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = End Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Delay Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Skip On Trigger . match ( buff ) ) != null ) { return m ; } else if ( ( m = Initiate Sound . match ( buff ) ) != null ) { return m ; } else if ( ( m = Mask Compare . match ( buff ) ) != null ) { return m ; } else if ( ( m = Load Modifier . match ( buff ) ) != null ) { return m ; } else if ( ( m = Branch To . match ( buff ) ) != null ) { return m ; } else if ( ( m = Play . match ( buff ) ) != null ) { return m ; } else if ( ( m = Four Byte Macro . match ( buff ) ) != null ) { return m ; } else if ( ( m = Two Byte Macro . match ( buff ) ) != null ) { return m ; } log . warn ( STRING ) ; return null ; }
public SIP Date ( long time Millis ) { java Cal = new Gregorian Calendar ( Time Zone . get Time Zone ( STRING ) , Locale . get Default ( ) ) ; java . util . Date date = new java . util . Date ( time Millis ) ; java Cal . set Time ( date ) ; wkday = java Cal . get ( Calendar . DAY OF WEEK ) ; switch ( wkday ) { case Calendar . MONDAY : sip Wk Day = MON ; break ; case Calendar . TUESDAY : sip Wk Day = TUE ; break ; case Calendar . WEDNESDAY : sip Wk Day = WED ; break ; case Calendar . THURSDAY : sip Wk Day = THU ; break ; case Calendar . FRIDAY : sip Wk Day = FRI ; break ; case Calendar . SATURDAY : sip Wk Day = SAT ; break ; case Calendar . SUNDAY : sip Wk Day = SUN ; break ; default : Internal Error Handler . handle Exception ( STRING + wkday ) ; } day = java Cal . get ( Calendar . DAY OF MONTH ) ; month = java Cal . get ( Calendar . MONTH ) ; switch ( month ) { case Calendar . JANUARY : sip Month = JAN ; break ; case Calendar . FEBRUARY : sip Month = FEB ; break ; case Calendar . MARCH : sip Month = MAR ; break ; case Calendar . APRIL : sip Month = APR ; break ; case Calendar . MAY : sip Month = MAY ; break ; case Calendar . JUNE : sip Month = JUN ; break ; case Calendar . JULY : sip Month = JUL ; break ; case Calendar . AUGUST : sip Month = AUG ; break ; case Calendar . SEPTEMBER : sip Month = SEP ; break ; case Calendar . OCTOBER : sip Month = OCT ; break ; case Calendar . NOVEMBER : sip Month = NOV ; break ; case Calendar . DECEMBER : sip Month = DEC ; break ; default : Internal Error Handler . handle Exception ( STRING + month ) ; } year = java Cal . get ( Calendar . YEAR ) ; hour = java Cal . get ( Calendar . HOUR OF DAY ) ; minute = java Cal . get ( Calendar . MINUTE ) ; second = java Cal . get ( Calendar . SECOND ) ; }
public static Type Mirror upper Bound ( Type Mirror type ) { do { if ( type instanceof Type Variable ) { Type Variable tvar = ( Type Variable ) type ; if ( tvar . get Upper Bound ( ) != null ) { type = tvar . get Upper Bound ( ) ; } else { break ; } } else if ( type instanceof Wildcard Type ) { Wildcard Type wc = ( Wildcard Type ) type ; if ( wc . get Extends Bound ( ) != null ) { type = wc . get Extends Bound ( ) ; } else { break ; } } else { break ; } } while ( BOOL ) ; return type ; }
public synchronized Object remove ( Object key ) { remove Blanks ( ) ; Weak Key Reference key Ref = new Weak Key Reference ( key ) ; Weak Reference ref = ( Weak Reference ) table . remove ( key Ref ) ; if ( ref == null ) return null ; return ref . get ( ) ; }
public boolean remove Element ( Node s ) { if ( ! m mutable ) throw new Runtime Exception ( XSL Messages . create XPATH Message ( XPATH Error Resources . ER NODESET NOT MUTABLE , null ) ) ; if ( null == m map ) return BOOL ; for ( int i = NUM ; i < m first Free ; i ++ ) { Node node = m map [ i ] ; if ( ( null != node ) && node . equals ( s ) ) { if ( i < m first Free - NUM ) System . arraycopy ( m map , i + NUM , m map , i , m first Free - i - NUM ) ; m first Free -- ; m map [ m first Free ] = null ; return BOOL ; } } return BOOL ; }
@ Override public Inet Address address Local ( ) { Socket s = get Socket ( ) ; if ( s != null ) { return s . get Local Address ( ) ; } else { return null ; } }
public boolean start Connection ( ) { State state = state . get ( ) ; if ( state . is Active ( ) ) { connection Count . increment And Get ( ) ; return BOOL ; } long now = Current Time . current Time ( ) ; long last Fail Time = last Fail Time ; long recover Timeout = dynamic Recover Timeout . get ( ) ; if ( now < last Fail Time + recover Timeout ) { return BOOL ; } int count ; do { count = connection Count . get ( ) ; if ( count > NUM ) { return BOOL ; } } while ( ! connection Count . compare And Set ( count , count + NUM ) ) ; return BOOL ; }
public Abstract Nary Operator ( final Expr ... args ) { this ( Arrays . as List ( args ) ) ; }
static boolean is Registered ( Object Name object Name ) { return mbean Server != null && mbean Server . is Registered ( object Name ) ; }
public static int find Best Sample Size ( int actual Width , int actual Height , int desired Width , int desired Height ) { double wr = ( double ) actual Width / desired Width ; double hr = ( double ) actual Height / desired Height ; double ratio = Math . min ( wr , hr ) ; float n = NUM ; while ( ( n * NUM ) <= ratio ) { n *= NUM ; } return ( int ) n ; }
public Socket Reader ( final Socket socket ) throws IO Exception { Preconditions . check Not Null ( socket , STRING ) ; m Input Stream = new Buffered Input Stream ( socket . get Input Stream ( ) ) ; }
private boolean move To Final Scroller Position ( Scroller scroller ) { scroller . force Finished ( BOOL ) ; if ( is Horizontal Mode ( ) ) { int amount To Scroll = scroller . get Final X ( ) - scroller . get Curr X ( ) ; int future Scroll Offset = ( m Current Scroll Offset + amount To Scroll ) % m Selector Element Size ; int overshoot Adjustment = m Initial Scroll Offset - future Scroll Offset ; if ( overshoot Adjustment != NUM ) { if ( Math . abs ( overshoot Adjustment ) > m Selector Element Size / NUM ) { if ( overshoot Adjustment > NUM ) { overshoot Adjustment -= m Selector Element Size ; } else { overshoot Adjustment += m Selector Element Size ; } } amount To Scroll += overshoot Adjustment ; scroll By ( amount To Scroll , NUM ) ; return BOOL ; } } else { int amount To Scroll = scroller . get Final Y ( ) - scroller . get Curr Y ( ) ; int future Scroll Offset = ( m Current Scroll Offset + amount To Scroll ) % m Selector Element Size ; int overshoot Adjustment = m Initial Scroll Offset - future Scroll Offset ; if ( overshoot Adjustment != NUM ) { if ( Math . abs ( overshoot Adjustment ) > m Selector Element Size / NUM ) { if ( overshoot Adjustment > NUM ) { overshoot Adjustment -= m Selector Element Size ; } else { overshoot Adjustment += m Selector Element Size ; } } amount To Scroll += overshoot Adjustment ; scroll By ( NUM , amount To Scroll ) ; return BOOL ; } } return BOOL ; }
public void add Lon Line ( double min Lat , double max Lat , double lon ) { String name = STRING + next Shape ; next Shape ++ ; b . append ( STRING + name + STRING ) ; double lat ; int steps = get Step Count ( min Lat , lon , max Lat , lon ) ; for ( lat = min Lat ; lat <= max Lat ; lat += ( max Lat - min Lat ) / steps ) { b . append ( STRING + lat + STRING + lon + STRING ) ; } b . append ( STRING + max Lat + STRING + lon + STRING ) ; lat -= ( max Lat - min Lat ) / NUM ; for ( ; lat >= min Lat ; lat -= ( max Lat - min Lat ) / steps ) { b . append ( STRING + lat + STRING + lon + STRING ) ; } b . append ( STRING ) ; b . append ( STRING + name + STRING ) ; }
@ Override public double calculate K ( int [ ] x index , double [ ] x att , int [ ] y index , double [ ] y att ) { double result = NUM ; double tmp ; int xpos = x index . length - NUM ; int ypos = y index . length - NUM ; int zeros = dim ; while ( ( xpos >= NUM ) && ( ypos >= NUM ) ) { if ( x index [ xpos ] == y index [ ypos ] ) { tmp = x att [ xpos ] - y att [ ypos ] ; result += Math . exp ( - sigma * tmp * tmp ) ; xpos -- ; ypos -- ; } else if ( x index [ xpos ] > y index [ ypos ] ) { tmp = x att [ xpos ] ; result += Math . exp ( - sigma * tmp * tmp ) ; xpos -- ; } else { tmp = y att [ ypos ] ; result += Math . exp ( - sigma * tmp * tmp ) ; ypos -- ; } zeros -- ; } while ( xpos >= NUM ) { tmp = x att [ xpos ] ; result += Math . exp ( - sigma * tmp * tmp ) ; xpos -- ; zeros -- ; } while ( ypos >= NUM ) { tmp = y att [ ypos ] ; result += Math . exp ( - sigma * tmp * tmp ) ; ypos -- ; zeros -- ; } result += zeros ; return Math . pow ( result , degree ) ; }
private float sweep ( float tan 1 X , float tan 1 Y , float tan 2 X , float tan 2 Y ) { final float minor Sweep = ( float ) Math . to Degrees ( NUM * ( Math . asin ( NUM * Geometry . distance ( tan 1 X , tan 1 Y , tan 2 X , tan 2 Y ) / m Scaled Touch Slop ) ) ) ; return NUM - minor Sweep ; }
Sun Cert Path Builder Result ( Cert Path cert Path , Trust Anchor trust Anchor , Policy Node policy Tree , Public Key subject Public Key , Adjacency List adj List ) { super ( cert Path , trust Anchor , policy Tree , subject Public Key ) ; this . adj List = adj List ; }
public static void attach ( final J Frame parent , final I Debugger debugger , final C Debug Event Notifier notifier ) { try { notifier . start ( ) ; debugger . connect ( ) ; } catch ( final Debug Exception Wrapper exception ) { notifier . stop ( ) ; C Utility Functions . log Exception ( exception ) ; final String inner Message = STRING + STRING ; final String inner Description = C Utility Functions . create Description ( STRING , new String [ ] { STRING } , new String [ ] { STRING + STRING } ) ; Navi Error Dialog . show ( parent , inner Message , inner Description , exception ) ; } }
public boolean check Addr Pattern ( final String the Addr Pattern ) { return the Addr Pattern . equals ( addr Pattern ( ) ) ; }
@ Medium Test public void test Stability In Space ( ) { long t = System . current Time Millis ( ) ; Velocity Tracker vt = Velocity Tracker . obtain ( ) ; drag ( vt , NUM , NUM , NUM , NUM , NUM , t , NUM ) ; vt . compute Current Velocity ( NUM ) ; float first X = vt . get X Velocity ( ) ; float first Y = vt . get Y Velocity ( ) ; vt . clear ( ) ; drag ( vt , NUM , NUM , NUM , NUM , NUM , t , NUM ) ; vt . compute Current Velocity ( NUM ) ; float second X = vt . get X Velocity ( ) ; float second Y = vt . get Y Velocity ( ) ; assert Equal Fuzzy ( first X , second X , NUM ) ; assert Equal Fuzzy ( first Y , second Y , NUM ) ; vt . recycle ( ) ; }
private View fill From Top ( int next Top ) { if ( DEBUG ) Log . i ( TAG , STRING + next Top + M FIRST POSITION + m First Position ) ; m First Position = Math . min ( m First Position , m Selected Position ) ; m First Position = Math . min ( m First Position , m Item Count - NUM ) ; if ( m First Position < NUM ) { m First Position = NUM ; } m First Position -= m First Position % m Num Columns ; return fill Down ( m First Position , next Top ) ; }
public static String SIT Info ( Enum Map < SIT , Enum Map < CIT , Boolean > > shp ) { String Builder result = new String Builder ( ) ; for ( SIT key : shp . key Set ( ) ) { result . append ( STRING + key . to String ( ) + STRING + CIT Info ( shp . get ( key ) ) + STRING ) ; } return result . to String ( ) ; }
public static Map < String , Object > update Binary File ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Map < String , Object > result = null ; try { result = update Binary File Method ( dctx , context ) ; } catch ( Generic Service Exception e ) { return Service Util . return Error ( e . get Message ( ) ) ; } return result ; }
public List < byte [ ] > write ( List < Internal Log > logs ) throws IO Exception { final List < Put > puts = new Array List < Put > ( logs . size ( ) ) ; final List < byte [ ] > result = new Array List < byte [ ] > ( logs . size ( ) ) ; for ( Internal Log log : logs ) { final byte [ ] rowkey = Rowkey Builder . build Rowkey ( log ) ; final Put p = new Put ( rowkey ) ; populate Column Values ( p , log ) ; puts . add ( p ) ; final List < byte [ ] > index Rowkeys = log . get Index Rowkeys ( ) ; if ( index Rowkeys != null ) { write Indexes ( rowkey , index Rowkeys , puts ) ; } result . add ( rowkey ) ; } tbl . put ( puts ) ; return result ; }
public int read ( long file Offset , byte [ ] buffer , int offset , int length ) throws IO Exception { log . info ( STRING + Long . to Hex String ( file Offset ) + STRING + length + STRING ) ; return file . read ( file Offset , buffer , offset , length ) ; }
public boolean validate Current Step ( int current Step , int new Step ) { return BOOL ; }
@ Non Null protected static List < Rave Error > must Be True ( boolean input , @ Non Null Validation Context validation Context ) { return input ? Collections . < Rave Error > empty List ( ) : create New List ( new Rave Error ( validation Context , Rave Error Strings . MUST BE TRUE ERROR ) ) ; }
private void signal Not Full ( ) { final Reentrant Lock put Lock = this . put Lock ; put Lock . lock ( ) ; try { not Full . signal ( ) ; } finally { put Lock . unlock ( ) ; } }
@ Log Message Doc ( level = STRING , message = STRING , explanation = STRING + STRING , recommendation = Log Message Doc . REPORT CONTROLLER BUG ) public void queue Hint ( String store Name , Byte Array key , Versioned < byte [ ] > value ) { try { Hint Key hk = new Hint Key ( store Name , key ) ; hint Lock . lock ( ) ; try { boolean needed = ! hints . contains Key ( hk ) ; needed &= hints . doput ( hk , value ) ; if ( needed ) { hint Queue . add ( hk ) ; hints Available . signal ( ) ; } } finally { hint Lock . unlock ( ) ; } } catch ( Sync Exception e ) { logger . error ( STRING + store Name , e ) ; } }
public static DBID Var random Sample ( DBI Ds ids , Random Factory random ) { return random Sample ( ids , random . get Single Threaded Random ( ) ) ; }
public void test Add Listener ( ) { Simple Listener listener 1 = create Mock Simple Listener ( NUM ) ; Simple Listener listener 2 = create Mock Simple Listener ( NUM ) ; assert Equals ( NUM , adaptor . get Num Listeners ( ) ) ; adaptor . add Listener ( listener 1 ) ; assert Equals ( NUM , adaptor . get Num Listeners ( ) ) ; adaptor . add Listener ( listener 2 ) ; assert Equals ( NUM , adaptor . get Num Listeners ( ) ) ; adaptor . add Listener ( listener 1 ) ; assert Equals ( NUM , adaptor . get Num Listeners ( ) ) ; List < Simple Listener > listeners = Lists . as List ( adaptor . get Listeners ( ) ) ; assert Equals ( NUM , listeners . size ( ) ) ; assert True ( listeners . contains ( listener 1 ) ) ; assert True ( listeners . contains ( listener 2 ) ) ; Easy Mock . verify ( listener 1 , listener 2 ) ; }
public void on Response ( Discovery Node node ) { boolean found = pending Nodes . remove ( node ) ; assert found : STRING + node + STRING ; latch . count Down ( ) ; }
@ Override public synchronized boolean add ( E object ) { if ( element Count == element Data . length ) { grow By One ( ) ; } element Data [ element Count ++ ] = object ; mod Count ++ ; return BOOL ; }
private static long copy ( Input Stream from , Output Stream to ) throws IO Exception { byte [ ] buf = new byte [ Settings . BUFFER SIZE ] ; long total = NUM ; while ( BOOL ) { int r = from . read ( buf ) ; if ( r == - NUM ) { break ; } to . write ( buf , NUM , r ) ; total += r ; } return total ; }
public Byte Vector put Byte Array ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b != null ) { System . arraycopy ( b , off , data , length , len ) ; } length += len ; return this ; }
public void add Value ( String value ) { if ( string Values == null ) { setup String Values ( ) ; } if ( ! string Values . contains ( value ) ) { string Values . add ( value ) ; } }
public void write Raw Little Endian 32 ( final int value ) throws IO Exception { if ( buffer . remaining ( ) < NUM ) { throw new Out Of Space Exception ( buffer . position ( ) , buffer . limit ( ) ) ; } buffer . put Int ( value ) ; }
private static URL [ ] path To UR Ls ( String path ) throws Malformed URL Exception { if ( path == null ) { return null ; } synchronized ( path To UR Ls Cache ) { Object [ ] v = ( Object [ ] ) path To UR Ls Cache . get ( path ) ; if ( v != null ) { return ( ( URL [ ] ) v [ NUM ] ) ; } } String Tokenizer st = new String Tokenizer ( path ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; for ( int i = NUM ; st . has More Tokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . next Token ( ) ) ; } synchronized ( path To UR Ls Cache ) { path To UR Ls Cache . put ( path , new Object [ ] { urls , new Soft Reference ( path ) } ) ; } return urls ; }
public static int hash 4 ( int hash , Object x , Object y , Object z , Object w ) { return NUM | ( hash + NUM * System . identity Hash Code ( x ) + NUM * System . identity Hash Code ( y ) + NUM * System . identity Hash Code ( z ) + NUM * System . identity Hash Code ( w ) ) ; }
public long skip ( long n ) throws IO Exception { if ( n < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } ensure Open ( ) ; int max = ( int ) Math . min ( n , Integer . MAX VALUE ) ; int total = NUM ; while ( total < max ) { int len = max - total ; if ( len > b . length ) { len = b . length ; } len = read ( b , NUM , len ) ; if ( len == - NUM ) { reach EOF = BOOL ; break ; } total += len ; } return total ; }
private V do Put ( K kkey , V value , boolean only If Absent ) { Comparable < ? super K > key = comparable ( kkey ) ; for ( ; ; ) { Node < K , V > b = find Predecessor ( key ) ; Node < K , V > n = b . next ; for ( ; ; ) { if ( n != null ) { Node < K , V > f = n . next ; if ( n != b . next ) break ; Object v = n . value ; if ( v == null ) { n . help Delete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; int c = key . compare To ( n . key ) ; if ( c > NUM ) { b = n ; n = f ; continue ; } if ( c == NUM ) { if ( only If Absent || n . cas Value ( v , value ) ) return ( V ) v ; else break ; } } Node < K , V > z = new Node < K , V > ( kkey , value , n ) ; if ( ! b . cas Next ( n , z ) ) break ; int level = random Level ( ) ; if ( level > NUM ) insert Index ( z , level ) ; return null ; } } }
public void add Fill Outside Line ( Fill Outside Line fill ) { m Fill Below Line . add ( fill ) ; }
public void add ( final Position Change Listener listener ) { listeners . add ( listener ) ; }
public void choose ( boolean enable , String what ) ;
public void test Duplicate Entries ( ) throws Exception { String name 1 = STRING ; String name 2 = STRING ; Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; Zip Output Stream out = new Zip Output Stream ( baos ) ; out . put Next Entry ( new Zip Entry ( name 2 ) ) ; out . close Entry ( ) ; out . put Next Entry ( new Zip Entry ( name 1 ) ) ; out . close Entry ( ) ; out . close ( ) ; byte [ ] buffer = baos . to Byte Array ( ) ; replace Bytes ( buffer , name 2 . get Bytes ( ) , name 1 . get Bytes ( ) ) ; File bad Zip = create Temporary Zip File ( ) ; write Bytes ( bad Zip , buffer ) ; try { Zip File bad = new Zip File ( bad Zip ) ; fail ( ) ; } catch ( Zip Exception expected ) { } }
private void rehash ( ) { int size = symbols . length ; int new Size = size + size ; if ( new Size > MAX TABLE SIZE ) { size = NUM ; Arrays . fill ( symbols , null ) ; Arrays . fill ( buckets , null ) ; dirty = BOOL ; return ; } String [ ] old Syms = symbols ; Bucket [ ] old Buckets = buckets ; symbols = new String [ new Size ] ; buckets = new Bucket [ new Size > > NUM ] ; index Mask = new Size - NUM ; size Threshold = threshold Size ( new Size ) ; int count = NUM ; int max Coll = NUM ; for ( int i = NUM ; i < size ; ++ i ) { String symbol = old Syms [ i ] ; if ( symbol != null ) { ++ count ; int index = hash To Index ( calc Hash ( symbol ) ) ; if ( symbols [ index ] == null ) { symbols [ index ] = symbol ; } else { int bix = ( index > > NUM ) ; Bucket new B = new Bucket ( symbol , buckets [ bix ] ) ; buckets [ bix ] = new B ; max Coll = Math . max ( max Coll , new B . length ( ) ) ; } } } size >>= NUM ; for ( int i = NUM ; i < size ; ++ i ) { Bucket b = old Buckets [ i ] ; while ( b != null ) { ++ count ; String symbol = b . get Symbol ( ) ; int index = hash To Index ( calc Hash ( symbol ) ) ; if ( symbols [ index ] == null ) { symbols [ index ] = symbol ; } else { int bix = ( index > > NUM ) ; Bucket new B = new Bucket ( symbol , buckets [ bix ] ) ; buckets [ bix ] = new B ; max Coll = Math . max ( max Coll , new B . length ( ) ) ; } b = b . get Next ( ) ; } } longest Collision List = max Coll ; if ( count != size ) { throw new Error ( STRING + size + STRING + count + STRING ) ; } }
private void check Size ( final int i ) { if ( i >= max size ) { final int old size = max size ; max size += increment size ; if ( max size <= i ) { max size = i + increment size + NUM ; } final int [ ] temp = items ; items = new int [ max size ] ; System . arraycopy ( temp , NUM , items , NUM , old size ) ; increment size = increment Size ( increment size ) ; } }
public Component Print Service ( Component c , Page Format format ) { set Page Format ( format ) ; set Printable ( this ) ; set Component ( c ) ; Rectangle component Bounds = c . get Bounds ( null ) ; set Size ( component Bounds . width , component Bounds . height ) ; set Scale ( NUM , NUM ) ; }
@ Override public void reconcile Flow ( OF Match Reconcile ofm Rc In , Event Priority priority ) { if ( ofm Rc In == null ) return ; OF Match Reconcile my Ofm Rc = new OF Match Reconcile ( ofm Rc In ) ; flow Queue . offer ( my Ofm Rc , priority ) ; ctr Flow Reconcile Request . increment ( ) ; Date curr Time = new Date ( ) ; long delay = NUM ; if ( curr Time . after ( new Date ( last Reconcile Time . get Time ( ) + NUM ) ) ) { delay = NUM ; } else { delay = FLOW RECONCILE DELAY MILLISEC ; } flow Reconcile Task . reschedule ( delay , Time Unit . MILLISECONDS ) ; if ( logger . is Trace Enabled ( ) ) { logger . trace ( STRING , my Ofm Rc . to String ( ) , flow Queue . size ( ) ) ; } }
public static Optional < String > create Input Dialog ( final Window owner , final String title , final String label ) { final Text Input Dialog dialog = new Text Input Dialog ( ) ; dialog . set Title ( title ) ; dialog . set Header Text ( null ) ; dialog . set Content Text ( label ) ; dialog . init Owner ( owner ) ; return dialog . show And Wait ( ) ; }
public void flush ( ) throws IO Exception { if ( writer != null ) { writer . flush ( ) ; } outstr . flush ( ) ; }
@ Suppress Warnings ( STRING ) protected synchronized V remove Internal ( Object key , boolean count Remove ) { if ( key == null ) { if ( Debug . verbose On ( ) ) Debug . log Verbose ( STRING + this . name , module ) ; } Object nulled Key = from Key ( key ) ; Cache Line < V > old Cache Line ; V old Value ; if ( file Table != null ) { try { synchronized ( this ) { try { old Value = file Table . get ( nulled Key ) ; } catch ( IO Exception e ) { old Value = null ; throw e ; } file Table . remove ( nulled Key ) ; jdbm Mgr . commit ( ) ; } } catch ( IO Exception e ) { old Value = null ; Debug . log Error ( e , module ) ; } old Cache Line = memory Table . remove ( nulled Key ) ; } else { old Cache Line = memory Table . remove ( nulled Key ) ; old Value = old Cache Line != null ? old Cache Line . get Value ( ) : null ; } if ( old Cache Line != null ) { cancel ( old Cache Line ) ; } if ( old Value != null ) { note Removal ( ( K ) key , old Value ) ; if ( count Remove ) remove Hit Count . increment And Get ( ) ; return old Value ; } else { if ( count Remove ) remove Miss Count . increment And Get ( ) ; return null ; } }
public void remove ( double value ) { if ( Double . is Na N ( value ) ) { return ; } int index = find Insert Index ( value ) ; if ( index == - NUM ) { throw new Illegal State Exception ( STRING ) ; } Double value At Index = values . get ( index ) ; if ( ( value At Index != null ) && ( ! value At Index . equals ( value ) ) ) { throw new Illegal State Exception ( STRING ) ; } values . remove ( index ) ; }
public void children Removed ( Bean Context Membership Event bcme ) { Iterator < ? > it = bcme . iterator ( ) ; while ( it . has Next ( ) ) { find And Undo ( it . next ( ) ) ; } }
void lightweight Paint ( Graphics g ) { super . lightweight Paint ( g ) ; paint Heavyweight Components ( g ) ; }
public JSON Array names ( ) { JSON Array ja = new JSON Array ( ) ; Iterator keys = keys ( ) ; while ( keys . has Next ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == NUM ? null : ja ; }
private final void remove Channel ( String channel ) { channel = channel . to Lower Case ( ) ; synchronized ( channels ) { channels . remove ( channel ) ; } }
public void add Change Listener ( Change Listener cl ) { if ( ! listeners . contains ( cl ) ) listeners . add ( cl ) ; }
public static void expand Number ( String number String , Word Relation word Relation , Item token Item ) { int num Digits = number String . length ( ) ; if ( num Digits == NUM ) { } else if ( num Digits == NUM ) { expand Digits ( number String , word Relation , token Item ) ; } else if ( num Digits == NUM ) { expand 2 Digit Number ( number String , word Relation , token Item ) ; } else if ( num Digits == NUM ) { expand 3 Digit Number ( number String , word Relation , token Item ) ; } else if ( num Digits < NUM ) { expand Below 7 Digit Number ( number String , word Relation , token Item ) ; } else if ( num Digits < NUM ) { expand Below 10 Digit Number ( number String , word Relation , token Item ) ; } else if ( num Digits < NUM ) { expand Below 13 Digit Number ( number String , word Relation , token Item ) ; } else { expand Digits ( number String , word Relation , token Item ) ; } }
private void translate Matrix After Rotate ( int axis , float trans , float prev Image Size , float image Size , int prev View Size , int view Size , int drawable Size ) { if ( image Size < view Size ) { m [ axis ] = ( view Size - ( drawable Size * m [ Matrix . MSCALE X ] ) ) * NUM ; } else if ( trans > NUM ) { m [ axis ] = - ( ( image Size - view Size ) * NUM ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM * prev View Size ) ) / prev Image Size ; m [ axis ] = - ( ( percentage * image Size ) - ( view Size * NUM ) ) ; } }
private int measure Short ( int measure Spec ) { int result = NUM ; int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; if ( spec Mode == Measure Spec . EXACTLY ) { result = spec Size ; } else { result = ( int ) ( NUM * m Radius + get Padding Top ( ) + get Padding Bottom ( ) + NUM ) ; if ( spec Mode == Measure Spec . AT MOST ) { result = Math . min ( result , spec Size ) ; } } return result ; }
protected boolean can Trigger Walking ( ) { return BOOL ; }
private void write Attribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( xml Writer . get Prefix ( namespace ) == null ) { xml Writer . write Namespace ( prefix , namespace ) ; xml Writer . set Prefix ( prefix , namespace ) ; } xml Writer . write Attribute ( namespace , att Name , att Value ) ; }
public static String encrypt ECB ( final byte [ ] concatenated Hash Value , final Long turnover Counter , final Secret Key symmetric Key , int turn Over Counter Length In Bytes ) throws No Such Algorithm Exception , No Such Provider Exception , No Such Padding Exception , Invalid Key Exception , Illegal Block Size Exception , Bad Padding Exception { final Byte Buffer byte Buffer IV = Byte Buffer . allocate ( NUM ) ; byte Buffer IV . put ( concatenated Hash Value ) ; final byte [ ] IV = byte Buffer IV . array ( ) ; final Byte Buffer byte Buffer Data = Byte Buffer . allocate ( NUM ) ; byte Buffer Data . put Long ( turnover Counter ) ; final byte [ ] data = byte Buffer Data . array ( ) ; byte [ ] turn Over Counter Byte Rep = get 2 Complement Rep For Long ( turnover Counter , turn Over Counter Length In Bytes ) ; System . arraycopy ( turn Over Counter Byte Rep , NUM , data , NUM , turn Over Counter Byte Rep . length ) ; final Cipher cipher = Cipher . get Instance ( STRING , STRING ) ; cipher . init ( Cipher . ENCRYPT MODE , symmetric Key ) ; final byte [ ] intermediate Result = cipher . do Final ( IV ) ; final byte [ ] result = new byte [ data . length ] ; for ( int i = NUM ; i < data . length ; i ++ ) { result [ i ] = ( byte ) ( ( data [ i ] ) ^ ( intermediate Result [ i ] ) ) ; } final byte [ ] encrypted Turn Over Value = new byte [ turn Over Counter Length In Bytes ] ; System . arraycopy ( result , NUM , encrypted Turn Over Value , NUM , turn Over Counter Length In Bytes ) ; return Cash Box Utils . base 64 Encode ( encrypted Turn Over Value , BOOL ) ; }
private static boolean is Frost Wire Old ( String message Version ) { if ( message Version == null ) return BOOL ; String current Version = Frost Wire Utils . get Frost Wire Version ( ) ; if ( current Version . equals ( message Version ) ) { return BOOL ; } try { String [ ] fw Version Parts = current Version . split ( STRING ) ; int fw major = Integer . parse Int ( fw Version Parts [ NUM ] ) ; int fw release = Integer . parse Int ( fw Version Parts [ NUM ] ) ; int fw service = Integer . parse Int ( fw Version Parts [ NUM ] ) ; String [ ] msg Version Parts = message Version . split ( STRING ) ; int msg major = Integer . parse Int ( msg Version Parts [ NUM ] ) ; int msg release = Integer . parse Int ( msg Version Parts [ NUM ] ) ; int msg service = Integer . parse Int ( msg Version Parts [ NUM ] ) ; if ( fw major < msg major ) { return BOOL ; } if ( fw major == msg major && fw release < msg release ) { return BOOL ; } if ( fw major == msg major && fw release == msg release && fw service < msg service ) { return BOOL ; } } catch ( Exception e ) { return BOOL ; } return BOOL ; }
public synchronized void draw Map ( ) { last Draw Map Req = System . current Time Millis ( ) ; Swing Utilities . invoke Later ( draw Mapable ) ; }
public void select Table 2 Column ( Index column ) { table 2 Columns . add ( column ) ; }
public List < String > extract UR Ls ( final String text ) { if ( text == null || text . length ( ) == NUM ) return Collections . empty List ( ) ; final Array List < String > urls = new Array List < String > ( ) ; for ( final Entity entity : extract UR Ls With Indices ( text ) ) { urls . add ( entity . value ) ; } return urls ; }
public void find And Undo ( Iterator it ) { while ( it . has Next ( ) ) { find And Undo ( it . next ( ) ) ; } }
public static int [ ] scale Down Inside ( int in Width , int in Height , int max Width , int max Height ) { int scaled Width ; int scaled Height ; if ( in Width <= max Width && in Height <= max Height ) { scaled Width = in Width ; scaled Height = in Height ; } else { double width Ratio = ( double ) in Width / ( double ) max Width ; double height Ratio = ( double ) in Height / ( double ) max Height ; if ( width Ratio > height Ratio ) { scaled Width = max Width ; scaled Height = ( int ) Math . round ( ( double ) in Height / width Ratio ) ; } else { scaled Height = max Height ; scaled Width = ( int ) Math . round ( ( double ) in Width / height Ratio ) ; } } return new int [ ] { scaled Width , scaled Height } ; }
public void rm ( String file Or Dir ) { String Builder buf = new String Builder ( ) ; String command = String . format ( Image Server Dialog Properties . get String ( STRING ) , file Or Dir ) ; send Wait For ( command , default Timeout , prompts , buf ) ; log . debug ( buf . to String ( ) ) ; }
private MGRS Components break MGRS String ( String MGRS String ) { int num digits ; int num letters ; int i = NUM ; int j = NUM ; long error code = MGRS NO ERROR ; int zone = NUM ; int [ ] letters = new int [ NUM ] ; long easting = NUM ; long northing = NUM ; int precision = NUM ; while ( i < MGRS String . length ( ) && MGRS String . char At ( i ) == STRING ) { i ++ ; } j = i ; while ( i < MGRS String . length ( ) && Character . is Digit ( MGRS String . char At ( i ) ) ) { i ++ ; } num digits = i - j ; if ( num digits <= NUM ) if ( num digits > NUM ) { zone = Integer . parse Int ( MGRS String . substring ( j , i ) ) ; if ( ( zone < NUM ) || ( zone > NUM ) ) error code |= MGRS STRING ERROR ; } else error code |= MGRS STRING ERROR ; j = i ; while ( i < MGRS String . length ( ) && Character . is Letter ( MGRS String . char At ( i ) ) ) { i ++ ; } num letters = i - j ; if ( num letters == NUM ) { letters [ NUM ] = alphabet . index Of ( Character . to Upper Case ( MGRS String . char At ( j ) ) ) ; if ( ( letters [ NUM ] == LETTER I ) || ( letters [ NUM ] == LETTER O ) ) error code |= MGRS STRING ERROR ; letters [ NUM ] = alphabet . index Of ( Character . to Upper Case ( MGRS String . char At ( j + NUM ) ) ) ; if ( ( letters [ NUM ] == LETTER I ) || ( letters [ NUM ] == LETTER O ) ) error code |= MGRS STRING ERROR ; letters [ NUM ] = alphabet . index Of ( Character . to Upper Case ( MGRS String . char At ( j + NUM ) ) ) ; if ( ( letters [ NUM ] == LETTER I ) || ( letters [ NUM ] == LETTER O ) ) error code |= MGRS STRING ERROR ; } else error code |= MGRS STRING ERROR ; j = i ; while ( i < MGRS String . length ( ) && Character . is Digit ( MGRS String . char At ( i ) ) ) { i ++ ; } num digits = i - j ; if ( ( num digits <= NUM ) && ( num digits % NUM == NUM ) ) { int n ; double multiplier ; n = num digits / NUM ; precision = n ; if ( n > NUM ) { easting = Integer . parse Int ( MGRS String . substring ( j , j + n ) ) ; northing = Integer . parse Int ( MGRS String . substring ( j + n , j + n + n ) ) ; multiplier = Math . pow ( NUM , NUM - n ) ; easting *= multiplier ; northing *= multiplier ; } else { easting = NUM ; northing = NUM ; } } else error code |= MGRS STRING ERROR ; last error = error code ; if ( error code == MGRS NO ERROR ) return new MGRS Components ( zone , letters [ NUM ] , letters [ NUM ] , letters [ NUM ] , easting , northing , precision ) ; return null ; }
public void put Map ( Map < String , List < String > > m ) { for ( String key : m . key Set ( ) ) { Sorted Set < String > vals = get ( key ) ; if ( vals == null ) { vals = new Tree Set < String > ( ) ; put ( key , vals ) ; } vals . add All ( m . get ( key ) ) ; } }
protected void throw Parse Exception ( Parse Exception e ) throws Parse Exception { if ( locator != null ) { String element Location = STRING ; if ( cur Handler != null ) { element Location += STRING + cur Handler . q Name ; } String location = STRING + String . value Of ( locator . get Line Number ( ) ) + STRING + String . value Of ( locator . get Column Number ( ) ) + element Location + STRING ; Log Utils . log Exception ( logger , Level . FINE , location , e ) ; throw new Parse Exception ( location + e . get Message ( ) , e ) ; } else { Log Utils . log Exception ( logger , Level . FINE , null , e ) ; throw e ; } }
public void add Asset Listener ( @ Not Null Action Listener listener ) { my Asset Listeners . add ( listener ) ; }
public Undoable Edit insert String ( int where , String str ) throws Bad Location Exception { if ( where > length ( ) || where < NUM ) { throw new Bad Location Exception ( STRING , length ( ) ) ; } char [ ] chars = str . to Char Array ( ) ; replace ( where , NUM , chars , chars . length ) ; return new Insert Undo ( where , str . length ( ) ) ; }
public static Java Pair RDD < Matrix Indexes , Matrix Block > to Matrix Java Pair RDD ( Java Spark Context sc , Matrix Block src , int brlen , int bclen ) throws DML Runtime Exception { long t0 = DML Script . STATISTICS ? System . nano Time ( ) : NUM ; Linked List < Tuple 2 < Matrix Indexes , Matrix Block > > list = new Linked List < Tuple 2 < Matrix Indexes , Matrix Block > > ( ) ; if ( src . get Num Rows ( ) <= brlen && src . get Num Columns ( ) <= bclen ) { list . add Last ( new Tuple 2 < Matrix Indexes , Matrix Block > ( new Matrix Indexes ( NUM , NUM ) , src ) ) ; } else { boolean sparse = src . is In Sparse Format ( ) ; for ( int block Row = NUM ; block Row < ( int ) Math . ceil ( src . get Num Rows ( ) / ( double ) brlen ) ; block Row ++ ) for ( int block Col = NUM ; block Col < ( int ) Math . ceil ( src . get Num Columns ( ) / ( double ) bclen ) ; block Col ++ ) { int max Row = ( block Row * brlen + brlen < src . get Num Rows ( ) ) ? brlen : src . get Num Rows ( ) - block Row * brlen ; int max Col = ( block Col * bclen + bclen < src . get Num Columns ( ) ) ? bclen : src . get Num Columns ( ) - block Col * bclen ; Matrix Block block = new Matrix Block ( max Row , max Col , sparse ) ; int row offset = block Row * brlen ; int col offset = block Col * bclen ; src . slice Operations ( row offset , row offset + max Row - NUM , col offset , col offset + max Col - NUM , block ) ; Matrix Indexes indexes = new Matrix Indexes ( block Row + NUM , block Col + NUM ) ; list . add Last ( new Tuple 2 < Matrix Indexes , Matrix Block > ( indexes , block ) ) ; } } Java Pair RDD < Matrix Indexes , Matrix Block > result = sc . parallelize Pairs ( list ) ; if ( DML Script . STATISTICS ) { Statistics . acc Spark Parallelize Time ( System . nano Time ( ) - t0 ) ; Statistics . inc Spark Parallelize Count ( NUM ) ; } return result ; }
public static boolean is You Tube Url ( String url ) { if ( Text Utils . is Empty ( url ) ) { return BOOL ; } Uri uri = Uri . parse ( url ) ; String authority = uri . get Authority ( ) ; if ( ! Text Utils . is Empty ( authority ) && authority . contains ( STRING ) ) { return BOOL ; } else { return BOOL ; } }
public List < Namespace VO > find Namespaces ( String app Id , Env env , String cluster Name ) { List < Namespace DTO > namespaces = namespace API . find Namespace By Cluster ( app Id , env , cluster Name ) ; if ( namespaces == null || namespaces . size ( ) == NUM ) { throw new Bad Request Exception ( STRING ) ; } List < Namespace VO > namespace V Os = new Linked List < > ( ) ; for ( Namespace DTO namespace : namespaces ) { Namespace VO namespace VO = null ; try { namespace VO = parse Namespace ( app Id , env , cluster Name , namespace ) ; namespace V Os . add ( namespace VO ) ; } catch ( Exception e ) { logger . error ( STRING , app Id , env , cluster Name , namespace . get Namespace Name ( ) , e ) ; throw e ; } } return namespace V Os ; }
void unlink ( Node < E > p , Node < E > trail ) { p . item = null ; trail . next = p . next ; if ( last == p ) last = trail ; if ( count . get And Decrement ( ) == capacity ) not Full . signal ( ) ; }
public static void open Share Dialog ( Context context , String title , @ Suppress Warnings ( STRING ) String uri , String share Text , String share Subject ) { Intent share = new Intent ( Intent . ACTION SEND ) ; share . set Type ( STRING ) ; share . put Extra ( Intent . EXTRA TEXT , share Text ) ; share . put Extra ( Intent . EXTRA SUBJECT , share Subject ) ; if ( ! Text Utils . is Empty ( uri ) ) { share . set Type ( STRING ) ; share . put Extra ( Intent . EXTRA STREAM , Uri . parse ( uri ) ) ; } context . start Activity ( Intent . create Chooser ( share , title ) ) ; }
public void add Matching ( final Conversation States state , final String trigger String , final Expression Matcher matcher , final Chat Condition condition , boolean secondary , final Conversation States next State , final String reply , final Chat Action action ) { Collection < Expression > trigger Expressions = create Unique Trigger Expressions ( state , Arrays . as List ( trigger String ) , matcher , condition , reply , action ) ; add ( trigger Expressions , state , condition , secondary , next State , reply , action ) ; }
boolean drop Items ( final Player player , int item Count ) { boolean result = BOOL ; final Item Collection items Todo = new Item Collection ( ) ; items Todo . add From Quest State String ( player . get Quest ( quest Slot ) ) ; if ( player . drop ( item Name , item Count ) ) { if ( items Todo . remove Item ( item Name , item Count ) ) { result = BOOL ; } } else { final List < Item > items = player . get All Equipped ( item Name ) ; if ( items != null ) { for ( final Item item : items ) { final int quantity = item . get Quantity ( ) ; final int n = Math . min ( item Count , quantity ) ; if ( player . drop ( item Name , n ) ) { item Count -= n ; if ( items Todo . remove Item ( item Name , n ) ) { result = BOOL ; } } if ( item Count == NUM ) { result = BOOL ; break ; } } } } if ( result ) { player . set Quest ( quest Slot , items Todo . to String For Quest State ( ) ) ; } return result ; }
public void encode Octet String ( byte tb [ ] , int tag , int tboffset , int length ) throws Encode Exception { encode Byte ( tag ) ; encode Length ( length ) ; if ( length > NUM ) { ensure Free Bytes ( length ) ; System . arraycopy ( tb , tboffset , buf , offset , length ) ; offset += length ; } }
private void swap Blocks ( int from , int second , int to ) { int len 1 = second - from , len 2 = to - second + NUM ; if ( len 1 == NUM || len 2 == NUM ) { return ; } if ( len 1 < temp . length ) { System . arraycopy ( data , from , temp , NUM , len 1 ) ; System . arraycopy ( data , second , data , from , len 2 ) ; System . arraycopy ( temp , NUM , data , from + len 2 , len 1 ) ; return ; } else if ( len 2 < temp . length ) { System . arraycopy ( data , second , temp , NUM , len 2 ) ; System . arraycopy ( data , from , data , from + len 2 , len 1 ) ; System . arraycopy ( temp , NUM , data , from , len 2 ) ; return ; } reverse Block ( from , second - NUM ) ; reverse Block ( second , to ) ; reverse Block ( from , to ) ; }
private static long total Size ( Map < String , Long > rel Path To Size ) { long total = NUM ; for ( Long l : rel Path To Size . values ( ) ) { total += l ; } return total ; }
public boolean has Next ( ) { return iterator . has Next ( ) ; }
public static boolean is Valid ( Timestamp valid From , Timestamp valid To , Timestamp test Date ) { if ( test Date == null ) return BOOL ; if ( valid From == null && valid To == null ) return BOOL ; if ( valid From != null && valid From . after ( test Date ) ) return BOOL ; if ( valid To != null && valid To . before ( test Date ) ) return BOOL ; return BOOL ; }
public Pattern Tokenizer ( Attribute Factory factory , Pattern pattern , int group ) { super ( factory ) ; this . group = group ; matcher = pattern . matcher ( STRING ) ; if ( group >= NUM && group > matcher . group Count ( ) ) { throw new Illegal Argument Exception ( STRING + matcher . group Count ( ) + STRING ) ; } }
@ Override public double total Estimated Quantity For Previous R Es ( final Long wo Activity Id , Long estimate Id , final Long activity Id , final Work Order work Order ) { if ( estimate Id == null ) estimate Id = - NUM ; Object [ ] params = null ; Double est Quantity = null ; params = new Object [ ] { estimate Id , work Order , work Order , wo Activity Id , activity Id } ; est Quantity = ( Double ) generic Service . find By Named Query ( STRING , params ) ; Double est Quantity RE = null ; params = new Object [ ] { estimate Id , work Order , work Order , activity Id } ; est Quantity RE = ( Double ) generic Service . find By Named Query ( STRING , params ) ; if ( est Quantity != null && est Quantity RE != null ) est Quantity = est Quantity + est Quantity RE ; if ( est Quantity == null && est Quantity RE != null ) est Quantity = est Quantity RE ; if ( est Quantity == null ) return NUM ; else return est Quantity . double Value ( ) ; }
protected long write Data To File ( Node Holder node Holder , File Channel channel ) throws Carbon Data Writer Exception { byte [ ] [ ] compressed Index = node Holder . get Compressed Index ( ) ; byte [ ] [ ] compressed Index Map = node Holder . get Compressed Index Map ( ) ; byte [ ] [ ] compressed Data Index = node Holder . get Compressed Data Index ( ) ; int index Block Size = NUM ; int index = NUM ; for ( int i = NUM ; i < node Holder . get Key Block Index Length ( ) . length ; i ++ ) { index Block Size += node Holder . get Key Block Index Length ( ) [ index ++ ] + Carbon Common Constants . INT SIZE IN BYTE ; } for ( int i = NUM ; i < node Holder . get Data Index Map Length ( ) . length ; i ++ ) { index Block Size += node Holder . get Data Index Map Length ( ) [ i ] ; } Byte Buffer byte Buffer = Byte Buffer . allocate ( node Holder . get Key Array ( ) . length + node Holder . get Data Array ( ) . length + index Block Size ) ; long offset = NUM ; try { offset = channel . size ( ) ; byte Buffer . put ( node Holder . get Key Array ( ) ) ; byte Buffer . put ( node Holder . get Data Array ( ) ) ; Byte Buffer buffer 1 = null ; for ( int i = NUM ; i < compressed Index . length ; i ++ ) { buffer 1 = Byte Buffer . allocate ( node Holder . get Key Block Index Length ( ) [ i ] ) ; buffer 1 . put Int ( compressed Index [ i ] . length ) ; buffer 1 . put ( compressed Index [ i ] ) ; if ( compressed Index Map [ i ] . length > NUM ) { buffer 1 . put ( compressed Index Map [ i ] ) ; } buffer 1 . rewind ( ) ; byte Buffer . put ( buffer 1 . array ( ) ) ; } for ( int i = NUM ; i < compressed Data Index . length ; i ++ ) { byte Buffer . put ( compressed Data Index [ i ] ) ; } byte Buffer . flip ( ) ; channel . write ( byte Buffer ) ; } catch ( IO Exception exception ) { throw new Carbon Data Writer Exception ( STRING , exception ) ; } return offset ; }
public boolean eval ( ) { if ( source File Sets . size ( ) == NUM && source Resources . size ( ) == NUM && source File == null ) { throw new Build Exception ( STRING ) ; } if ( ( source File Sets . size ( ) > NUM || source Resources . size ( ) > NUM ) && source File != null ) { throw new Build Exception ( STRING ) ; } if ( urlbase == null ) { throw new Build Exception ( STRING ) ; } if ( source File != null && ! source File . exists ( ) ) { throw new Build Exception ( source File . get Absolute Path ( ) + STRING ) ; } boolean up To Date = BOOL ; if ( source File != null ) { Resource file Resource = new File Resource ( source File ) ; up To Date = is Up To Date ( file Resource ) ; } if ( up To Date ) { Enumeration e = source File Sets . elements ( ) ; while ( up To Date && e . has More Elements ( ) ) { File Set fs = ( File Set ) e . next Element ( ) ; Iterator it = fs . iterator ( ) ; while ( up To Date && it . has Next ( ) ) { Resource r = ( Resource ) it . next ( ) ; up To Date = is Up To Date ( r ) ; } } } if ( up To Date ) { Resource [ ] r = source Resources . list Resources ( ) ; for ( int i = NUM ; up To Date && i < r . length ; i ++ ) { up To Date = is Up To Date ( r [ i ] ) ; } } return up To Date ; }
private int handle Aggregation Packet ( Buffer input , Buffer output ) { byte [ ] buffer Data = ( byte [ ] ) input . get Data ( ) ; if ( aggregation Positon + NUM >= buffer Data . length ) { aggregation Positon = NUM ; output . set Discard ( BOOL ) ; return BUFFER PROCESSED OK ; } int nalu size = ( ( ( buffer Data [ aggregation Positon ] & NUM ) << NUM ) | ( buffer Data [ aggregation Positon + NUM ] & NUM ) ) ; aggregation Positon += NUM ; if ( aggregation Positon + nalu size > buffer Data . length ) { aggregation Positon = NUM ; return BUFFER PROCESSED FAILED ; } extract Nal Unit Header ( aggregation Positon , input ) ; if ( m Nal Unit Header . is Single Nal Unit Packet ( ) ) { byte [ ] data = new byte [ nalu size ] ; System . arraycopy ( buffer Data , aggregation Positon , data , NUM , nalu size ) ; aggregation Positon += nalu size ; output . set Data ( data ) ; output . set Length ( data . length ) ; output . set Offset ( NUM ) ; output . set Timestamp ( input . get Timestamp ( ) ) ; output . set Sequence Number ( input . get Sequence Number ( ) ) ; output . set Video Orientation ( input . get Video Orientation ( ) ) ; output . set Format ( input . get Format ( ) ) ; output . set Flags ( input . get Flags ( ) ) ; return INPUT BUFFER NOT CONSUMED ; } aggregation Positon = NUM ; return BUFFER PROCESSED FAILED ; }
public double calculate Cost For String AVM ( Regex Graph graph ) { final int ROWS = graph . get Number Of Rows ( ) ; final int COLUMNS = graph . get Number Of Columns ( ) ; final double [ ] [ ] [ ] matrix = new double [ ROWS ] [ COLUMNS ] [ NUM ] ; calculate Insertion Cost On First Row ( graph , matrix ) ; for ( int i = NUM ; i < ROWS ; i ++ ) { for ( int col = NUM ; col < COLUMNS ; col ++ ) { matrix [ i ] [ col ] [ DEL ] = Double . MAX VALUE ; matrix [ i ] [ col ] [ REP ] = Double . MAX VALUE ; matrix [ i ] [ col ] [ INS ] = Double . MAX VALUE ; for ( Graph Transition t : graph . get Incoming Transitions ( i , col ) ) { int other Col = graph . get Column ( t . from State ) ; int other Row = t . from Row ; if ( t . type . equals ( Graph Transition . Transition Type . INSERTION ) ) { assert other Row == i ; matrix [ i ] [ col ] [ INS ] = Math . min ( matrix [ i ] [ col ] [ INS ] , get Sub Path Cost ( matrix [ other Row ] [ other Col ] [ DEL ] , t . cost ) ) ; matrix [ i ] [ col ] [ INS ] = Math . min ( matrix [ i ] [ col ] [ INS ] , get Sub Path Cost ( matrix [ other Row ] [ other Col ] [ REP ] , t . cost ) ) ; matrix [ i ] [ col ] [ INS ] = Math . min ( matrix [ i ] [ col ] [ INS ] , get Sub Path Cost ( matrix [ other Row ] [ other Col ] [ INS ] , t . cost ) ) ; } else if ( t . type . equals ( Graph Transition . Transition Type . REPLACEMENT ) ) { matrix [ i ] [ col ] [ REP ] = Math . min ( matrix [ i ] [ col ] [ REP ] , get Sub Path Cost ( matrix [ other Row ] [ other Col ] [ DEL ] , t . cost ) ) ; matrix [ i ] [ col ] [ REP ] = Math . min ( matrix [ i ] [ col ] [ REP ] , get Sub Path Cost ( matrix [ other Row ] [ other Col ] [ REP ] , t . cost ) ) ; matrix [ i ] [ col ] [ INS ] = Math . min ( matrix [ i ] [ col ] [ INS ] , get Sub Path Cost ( matrix [ other Row ] [ other Col ] [ DEL ] , t . cost ) ) ; matrix [ i ] [ col ] [ INS ] = Math . min ( matrix [ i ] [ col ] [ INS ] , get Sub Path Cost ( matrix [ other Row ] [ other Col ] [ REP ] , t . cost ) ) ; } else if ( t . type . equals ( Graph Transition . Transition Type . DELETION ) ) { matrix [ i ] [ col ] [ DEL ] = Math . min ( matrix [ i ] [ col ] [ DEL ] , get Sub Path Cost ( matrix [ other Row ] [ other Col ] [ DEL ] , t . cost ) ) ; matrix [ i ] [ col ] [ REP ] = Math . min ( matrix [ i ] [ col ] [ REP ] , get Sub Path Cost ( matrix [ other Row ] [ other Col ] [ DEL ] , t . cost ) ) ; matrix [ i ] [ col ] [ INS ] = Math . min ( matrix [ i ] [ col ] [ INS ] , get Sub Path Cost ( matrix [ other Row ] [ other Col ] [ DEL ] , t . cost ) ) ; } else if ( t . type . equals ( Graph Transition . Transition Type . PHANTOM ) ) { assert t . cost == NUM ; matrix [ i ] [ col ] [ DEL ] = Math . min ( matrix [ i ] [ col ] [ DEL ] , matrix [ other Row ] [ other Col ] [ DEL ] ) ; matrix [ i ] [ col ] [ REP ] = Math . min ( matrix [ i ] [ col ] [ REP ] , matrix [ other Row ] [ other Col ] [ REP ] ) ; matrix [ i ] [ col ] [ INS ] = Math . min ( matrix [ i ] [ col ] [ INS ] , matrix [ other Row ] [ other Col ] [ INS ] ) ; } } } } double min = Double . MAX VALUE ; for ( double value : matrix [ ROWS - NUM ] [ COLUMNS - NUM ] ) { if ( value < min ) { min = value ; } } return min ; }
protected int decode Line Prefix ( Pushback Input Stream in Stream , Output Stream out Stream ) throws IO Exception { int i ; int n Len , n Seq ; byte xtmp [ ] ; int c ; crc . value = NUM ; while ( BOOL ) { c = in Stream . read ( tmp , NUM , NUM ) ; if ( c == - NUM ) { throw new CE Stream Exhausted ( ) ; } if ( tmp [ NUM ] == STRING ) { break ; } } line And Seq . reset ( ) ; decode Atom ( in Stream , line And Seq , NUM ) ; xtmp = line And Seq . to Byte Array ( ) ; n Len = xtmp [ NUM ] & NUM ; n Seq = xtmp [ NUM ] & NUM ; if ( n Seq != sequence ) { throw new CE Format Exception ( STRING ) ; } sequence = ( sequence + NUM ) & NUM ; return ( n Len ) ; }
public void append Nodes ( Node Set nodes ) { int n Nodes = nodes . size ( ) ; if ( null == m map ) { m map Size = n Nodes + m blocksize ; m map = new Node [ m map Size ] ; } else if ( ( m first Free + n Nodes ) >= m map Size ) { m map Size += ( n Nodes + m blocksize ) ; Node new Map [ ] = new Node [ m map Size ] ; System . arraycopy ( m map , NUM , new Map , NUM , m first Free + n Nodes ) ; m map = new Map ; } System . arraycopy ( nodes . m map , NUM , m map , m first Free , n Nodes ) ; m first Free += n Nodes ; }
protected void update Cached AWT Sizes ( final Dimension min , final Dimension pref , final Dimension max ) { assert Event Queue . is Dispatch Thread ( ) ; if ( verbose Size Layout ) { System . err . println ( STRING + min + STRING + pref + STRING + max ) ; } last Validated AWT Time = ++ current AWT Time ; boolean must Notify ; synchronized ( this ) { must Notify = cached Sizes Initialized == NUM ; if ( ! must Notify ) { must Notify = ! ( min . equals ( cached Min Size ) && pref . equals ( cached Pref Size ) && max . equals ( cached Max Size ) ) ; } if ( cached Sizes Initialized == NUM ) { cached Sizes Initialized = NUM ; } cached Min Size = min ; cached Pref Size = pref ; cached Max Size = max ; if ( INITIAL CLIENT AREA WORKAROUND && initial Client Area != null ) { initial Client Area . width = cached Pref Size . width ; initial Client Area . height = cached Pref Size . height ; } } if ( must Notify ) { final int on Behalf AWT Time = last Validated AWT Time ; Threading Handler . get Instance ( ) . async Exec ( display , null ) ; } }
public boolean is Decimal Point ( ) { if ( m decimal Point == null ) { Decimal Format Symbols dfs = new Decimal Format Symbols ( m locale ) ; m decimal Point = new Boolean ( dfs . get Decimal Separator ( ) == STRING ) ; } return m decimal Point . boolean Value ( ) ; }
public void remove Layer ( Layer layer ) { if ( layer != null && layer . is Removable ( ) ) { List < Layer > current Layers = get Layer List ( ) ; current Layers . remove ( layer ) ; set Layer List ( current Layers ) ; } else { if ( layer != null ) { logger . warning ( STRING + layer . get Name ( ) + STRING ) ; throw new com . bbn . openmap . util . Handle Error ( STRING + layer . get Name ( ) + STRING ) ; } } }
public Option [ ] find All Option Types ( final Class option Class ) { Check . not Null ( option Class , STRING ) ; return find All Option Types ( new Class [ ] { option Class } ) ; }
public int via padstack count ( ) { return via padstacks . size ( ) ; }
public static boolean is Earlier Transaction ( M Cost Detail cd , int C Acct Schema ID , int M Cost Type ID , int M Cost Element ID , String costing Level ) { M Transaction trx = new M Transaction ( cd . get Ctx ( ) , cd . get M Transaction ID ( ) , cd . get Trx Name ( ) ) ; M Cost Detail last cd = get Last Transaction ( trx , C Acct Schema ID , M Cost Type ID , M Cost Element ID , costing Level ) ; if ( last cd == null ) return BOOL ; if ( cd . get Seq No ( ) <= last cd . get Seq No ( ) && cd . get M Transaction ID ( ) != last cd . get M Transaction ID ( ) ) { return BOOL ; } return BOOL ; }
private void draw Translated Rendered Image ( Rendered Image img , Rectangle region , int i2 u Trans X , int i2 u Trans Y ) { int tile Grid X Offset = img . get Tile Grid X Offset ( ) ; int tile Grid Y Offset = img . get Tile Grid Y Offset ( ) ; int tile Width = img . get Tile Width ( ) ; int tile Height = img . get Tile Height ( ) ; int min Tile X = get Tile Index ( region . x , tile Grid X Offset , tile Width ) ; int min Tile Y = get Tile Index ( region . y , tile Grid Y Offset , tile Height ) ; int max Tile X = get Tile Index ( region . x + region . width - NUM , tile Grid X Offset , tile Width ) ; int max Tile Y = get Tile Index ( region . y + region . height - NUM , tile Grid Y Offset , tile Height ) ; Color Model color Model = img . get Color Model ( ) ; Rectangle tile Rect = new Rectangle ( ) ; for ( int ty = min Tile Y ; ty <= max Tile Y ; ty ++ ) { for ( int tx = min Tile X ; tx <= max Tile X ; tx ++ ) { Raster raster = img . get Tile ( tx , ty ) ; tile Rect . x = tx * tile Width + tile Grid X Offset ; tile Rect . y = ty * tile Height + tile Grid Y Offset ; tile Rect . width = tile Width ; tile Rect . height = tile Height ; clip To ( tile Rect , region ) ; Writable Raster w Raster = null ; if ( raster instanceof Writable Raster ) { w Raster = ( Writable Raster ) raster ; } else { w Raster = Raster . create Writable Raster ( raster . get Sample Model ( ) , raster . get Data Buffer ( ) , null ) ; } w Raster = w Raster . create Writable Child ( tile Rect . x , tile Rect . y , tile Rect . width , tile Rect . height , NUM , NUM , null ) ; Buffered Image buf Img = new Buffered Image ( color Model , w Raster , color Model . is Alpha Premultiplied ( ) , null ) ; copy Image ( buf Img , tile Rect . x + i2 u Trans X , tile Rect . y + i2 u Trans Y , NUM , NUM , tile Rect . width , tile Rect . height , null , null ) ; } } }
public void add Out Of Context Message ( Consensus Message m ) { out Of Context Lock . lock ( ) ; if ( m . get Type ( ) == Message Factory . PROPOSE ) { Logger . println ( STRING + m ) ; out Of Context Proposes . put ( m . get Number ( ) , m ) ; } else { List < Consensus Message > messages = out Of Context . get ( m . get Number ( ) ) ; if ( messages == null ) { messages = new Linked List < Consensus Message > ( ) ; out Of Context . put ( m . get Number ( ) , messages ) ; } Logger . println ( STRING + m ) ; messages . add ( m ) ; } out Of Context Lock . unlock ( ) ; }
private long calculate Capacity ( long minimum Capacity ) { long new Capacity = Math . min ( Math . max ( capacity , NUM ) , minimum Capacity ) ; while ( new Capacity < Math . min ( minimum Capacity , max Capacity ) ) { new Capacity <<= NUM ; } return Math . min ( new Capacity , max Capacity ) ; }
protected Object create Resource ( ) throws Resource Unavailable Exception { Object resource = create ( ) ; freed . add ( resource ) ; num Created ++ ; return ( resource ) ; }
public void upgrade ( ) throws Exception { if ( ! check Upgrade Preconditions ( ) ) { return ; } backup Manager . create Open DJ Backup ( ) ; try ( Buffered Writer out = new Buffered Writer ( new File Writer ( upgrade Marker ) ) ) { out . write ( current Version . to String ( ) ) ; out . write ( STRING ) ; } if ( current Version . is Older Than ( DJ 245 VERSION ) ) { backup File ( STRING ) ; backup File ( STRING ) ; backup File ( STRING ) ; unpack Zip File ( BOOL ) ; call Old DJ Upgrade ( ) ; } else { unpack Zip File ( BOOL ) ; if ( current Version . equals ( DJ 246 VERSION ) ) { try { File bad Schema = new File ( install Root + File . separator + STRING + File . separator + STRING + File . separator + STRING ) ; delete ( bad Schema ) ; } catch ( Runtime Exception e ) { } File good Schema = new File ( servlet Ctx . get Real Path ( File . separator + STRING + File . separator + STRING + File . separator + STRING + File . separator + STRING + File . separator + STRING ) ) ; File move To = new File ( install Root + File . separator + STRING + File . separator + STRING + File . separator + STRING ) ; copy ( good Schema . to Path ( ) , move To . to Path ( ) ) ; } int ret = call DJ Upgrade Mechanism ( ) ; if ( ret == NUM ) { message ( STRING ) ; delete ( upgrade Marker ) ; final String lock File = Lock File Manager . get Server Lock File Name ( ) ; Lock File Manager . release Lock ( lock File , new String Builder ( ) ) ; } else { throw new Upgrade Exception ( STRING + ret ) ; } } }
public static final Optional < File > find Steam VR Manifest ( final Array List < File > indexed Steam Folders ) { for ( final File f : indexed Steam Folders ) { final File current File = new File ( f . get Absolute Path ( ) + Steam Constants . STEAM VR APPS MANIFEST FILE LOCATION ) ; if ( current File . exists ( ) ) return Optional . of Nullable ( current File ) ; } return Optional . empty ( ) ; }
private static boolean is Close ( float value , float target Value ) { return Math . abs ( value - target Value ) < NUM ; }
public int size ( ) { return my Tcp Clients . size ( ) ; }
public static M Movement Cart Bean add To Movement Cart ( Properties ctx , Stock Movement Bean bean , M Movement Cart Bean cart Bean , boolean is Sales , boolean if Add ) throws Operation Exception , Product Not Found Exception , Product Not On Price List Exception { Array List < Item Bean > old Items ; if ( cart Bean == null ) { cart Bean = new M Movement Cart Bean ( ) ; old Items = new Array List < Item Bean > ( ) ; } else { old Items = cart Bean . get Items ( ) ; } Array List < Item Bean > old Items Clone = ( Array List ) old Items . clone ( ) ; Array List items To Be Added = get M Movement Items ( ctx , bean ) ; old Items = add To M Movement List ( ctx , old Items Clone , items To Be Added , if Add ) ; Integer price List Id = POS Terminal Manager . get Price List Id ( ctx , is Sales ) ; old Items = set M Movement Item Costs ( ctx , price List Id , old Items , is Sales ) ; cart Bean . set Items ( old Items ) ; cart Bean . set Pricelist Id ( price List Id ) ; return cart Bean ; }
private static List < Field > filter Field List ( List < Field > fields , Class < ? > filter Class ) { List < Field > filtered Fields = new Linked List < > ( ) ; for ( Field f : fields ) { if ( ( filter Class == null ) || filter Class . is Assignable From ( f . get Type ( ) ) ) { filtered Fields . add ( f ) ; } } return filtered Fields ; }
public static void render Pairwise Orthogonal ( Complex Vector vec 1 , Complex Vector vec 2 ) { Incompatible Vectors Exception . check Vectors Compatible ( vec 1 , vec 2 ) ; if ( vec 1 . get Op Mode ( ) != Complex Vector . Mode . CARTESIAN ) vec 1 . to Cartesian ( ) ; if ( vec 2 . get Op Mode ( ) != Complex Vector . Mode . CARTESIAN ) vec 2 . to Cartesian ( ) ; float [ ] coordinates 1 = vec 1 . get Coordinates ( ) ; float [ ] coordinates 2 = vec 2 . get Coordinates ( ) ; for ( int i = NUM ; i < vec 1 . get Dimension ( ) * NUM ; i += NUM ) { double result This Pair = coordinates 1 [ i ] * coordinates 2 [ i ] ; result This Pair += coordinates 1 [ i + NUM ] * coordinates 2 [ i + NUM ] ; double norm 1 = coordinates 1 [ i ] * coordinates 1 [ i ] ; norm 1 += coordinates 1 [ i + NUM ] * coordinates 1 [ i + NUM ] ; double norm 2 = coordinates 2 [ i ] * coordinates 2 [ i ] ; norm 2 += coordinates 2 [ i + NUM ] * coordinates 2 [ i + NUM ] ; norm 1 = Math . sqrt ( norm 1 ) ; norm 2 = Math . sqrt ( norm 2 ) ; double cosine = NUM ; if ( norm 1 > NUM && norm 2 > NUM ) cosine = result This Pair / ( norm 1 * norm 2 ) ; coordinates 1 [ i ] = ( float ) ( coordinates 1 [ i ] - cosine * coordinates 2 [ i ] ) ; coordinates 1 [ i + NUM ] = ( float ) ( coordinates 1 [ i + NUM ] - cosine * coordinates 2 [ i + NUM ] ) ; } }
protected Simple Java File Object ( URI uri , Kind kind ) { uri . get Class ( ) ; kind . get Class ( ) ; if ( uri . get Path ( ) == null ) throw new Illegal Argument Exception ( STRING + uri ) ; this . uri = uri ; this . kind = kind ; }
public int increment ( int val ) { if ( val < NUM ) { return decrement ( - val ) ; } lock . lock ( ) ; int new Value = ( value += val ) ; lock . unlock ( ) ; return new Value ; }
protected void release Internal ( ) { Context Translator . pts 1cfa map = null ; Context Translator . objs 1cfa map = null ; }
public static void add Constraint Violations RDF ( List < Constraint Violation > cvs , Model result , boolean create Source ) { for ( Constraint Violation cv : cvs ) { Resource r = result . create Resource ( SPIN . Constraint Violation ) ; String message = cv . get Message ( ) ; if ( message != null && message . length ( ) > NUM ) { r . add Property ( RDFS . label , message ) ; } if ( cv . get Root ( ) != null ) { r . add Property ( SPIN . violation Root , cv . get Root ( ) ) ; } r . add Property ( SPIN . violation Level , cv . get Level ( ) ) ; for ( Simple Property Path path : cv . get Paths ( ) ) { if ( path instanceof Object Property Path ) { r . add Property ( SPIN . violation Path , path . get Predicate ( ) ) ; } else { Resource p = result . create Resource ( SP . Reverse Path ) ; p . add Property ( SP . path , path . get Predicate ( ) ) ; r . add Property ( SPIN . violation Path , p ) ; } } if ( create Source && cv . get Source ( ) != null ) { r . add Property ( SPIN . violation Source , cv . get Source ( ) ) ; } if ( cv . get Value ( ) != null ) { r . add Property ( SPIN . violation Value , cv . get Value ( ) ) ; } } }
public Page copy ( long version ) { Page new Page = create ( map , version , keys , values , children , total Count , get Memory ( ) ) ; remove Page ( ) ; new Page . cached Compare = cached Compare ; return new Page ; }
public boolean start Busytone ( final String busytone Uri Type ) { if ( busytone Uri Type . is Empty ( ) ) { return BOOL ; } try { Log . d ( TAG , STRING + busytone Uri Type ) ; if ( m Busytone != null ) { if ( m Busytone . is Playing ( ) ) { Log . d ( TAG , STRING ) ; return BOOL ; } else { stop Busytone ( ) ; } } Uri busytone Uri ; Map data = new Hash Map < String , Object > ( ) ; data . put ( STRING , STRING ) ; if ( busytone Uri Type . equals ( STRING ) ) { m Busytone = new my Tone Generator ( my Tone Generator . BUSY ) ; m Busytone . start Play ( data ) ; return BOOL ; } else { busytone Uri = get Busytone Uri ( busytone Uri Type ) ; if ( busytone Uri == null ) { Log . d ( TAG , STRING ) ; return BOOL ; } } m Busytone = new my Media Player ( ) ; data . put ( STRING , busytone Uri ) ; data . put ( STRING , BOOL ) ; data . put ( STRING , Audio Manager . STREAM VOICE CALL ) ; set Media Player Events ( ( Media Player ) m Busytone , STRING ) ; m Busytone . start Play ( data ) ; return BOOL ; } catch ( Exception e ) { Log . d ( TAG , STRING ) ; Log . d ( TAG , e . get Message ( ) ) ; return BOOL ; } }
private String move To Folder ( final String file , final String folder ) { final File source = new File ( file ) ; final File destination = new File ( folder + File . separator + source . get Name ( ) ) ; Log . i ( TAG , file + STRING + destination . get Absolute Path ( ) ) ; try { File Utils . move File ( source , destination ) ; } catch ( final IO Exception e ) { Log . e ( TAG , STRING ) ; } return destination . get Absolute Path ( ) ; }
public void put All ( Map m ) { Set keys = m . key Set ( ) ; for ( Iterator iter = keys . iterator ( ) ; iter . has Next ( ) ; ) { Object key = iter . next ( ) ; put ( key , m . get ( key ) ) ; } }
public void read Old Format ( Reader reader ) throws Exception { Stream Tokenizer tokenizer ; int current Token ; double first Index , second Index , weight ; tokenizer = new Stream Tokenizer ( reader ) ; initialize ( ) ; tokenizer . comment Char ( STRING ) ; tokenizer . eol Is Significant ( BOOL ) ; while ( Stream Tokenizer . TT EOF != ( current Token = tokenizer . next Token ( ) ) ) { if ( current Token == Stream Tokenizer . TT EOL ) { continue ; } if ( current Token != Stream Tokenizer . TT NUMBER ) { throw new Exception ( STRING + STRING ) ; } first Index = tokenizer . nval ; if ( ! Utils . eq ( ( int ) first Index , first Index ) ) { throw new Exception ( STRING + STRING ) ; } if ( ( int ) first Index >= size ( ) ) { throw new Exception ( STRING ) ; } if ( Stream Tokenizer . TT EOF == ( current Token = tokenizer . next Token ( ) ) ) { throw new Exception ( STRING ) ; } if ( current Token == Stream Tokenizer . TT EOL ) { throw new Exception ( STRING ) ; } if ( current Token != Stream Tokenizer . TT NUMBER ) { throw new Exception ( STRING + STRING ) ; } second Index = tokenizer . nval ; if ( ! Utils . eq ( ( int ) second Index , second Index ) ) { throw new Exception ( STRING + STRING ) ; } if ( ( int ) second Index >= size ( ) ) { throw new Exception ( STRING ) ; } if ( ( int ) second Index == ( int ) first Index ) { throw new Exception ( STRING ) ; } if ( Stream Tokenizer . TT EOF == ( current Token = tokenizer . next Token ( ) ) ) { throw new Exception ( STRING ) ; } if ( current Token == Stream Tokenizer . TT EOL ) { throw new Exception ( STRING ) ; } if ( current Token != Stream Tokenizer . TT NUMBER ) { throw new Exception ( STRING + STRING ) ; } weight = tokenizer . nval ; if ( ! Utils . gr ( weight , NUM ) ) { throw new Exception ( STRING ) ; } set Cell ( ( int ) first Index , ( int ) second Index , new Double ( weight ) ) ; } }
protected String handle Date ( Result Set rs , int column Index , String date Format String ) throws SQL Exception { java . sql . Date date = rs . get Date ( column Index ) ; String value = null ; if ( date != null ) { Simple Date Format date Format = new Simple Date Format ( date Format String ) ; value = date Format . format ( date ) ; } return value ; }
@ Override public Random Access Stream open File Random Access ( ) throws IO Exception { if ( is Windows && is Aux ( ) ) throw new File Not Found Exception ( file . to String ( ) ) ; return new File Random Access Stream ( new Random Access File ( get File ( ) , STRING ) ) ; }
public Q Date ( Time Zone zone , long now ) { time Zone = zone ; if ( zone == gmt Time Zone ) { std Name = gmt Std Name ; dst Name = gmt Dst Name ; } else if ( zone == local Time Zone ) { std Name = local Std Name ; dst Name = local Dst Name ; } else { std Name = time Zone . get Display Name ( BOOL , Time Zone . SHORT ) ; dst Name = time Zone . get Display Name ( BOOL , Time Zone . SHORT ) ; } calendar = new Gregorian Calendar ( time Zone ) ; if ( zone == gmt Time Zone ) set GMT Time ( now ) ; else set Local Time ( now ) ; }
public static void serialize ( Serializable obj , Byte Array Output Stream bout ) { try { Object Output Stream out = new Object Output Stream ( bout ) ; out . write Object ( obj ) ; out . close ( ) ; } catch ( IO Exception e ) { throw new Illegal State Exception ( STRING + obj , e ) ; } }
private static void decode Edifact Segment ( Bit Source bits , String Builder result ) { do { if ( bits . available ( ) <= NUM ) { return ; } for ( int i = NUM ; i < NUM ; i ++ ) { int edifact Value = bits . read Bits ( NUM ) ; if ( edifact Value == NUM ) { int bits Left = NUM - bits . get Bit Offset ( ) ; if ( bits Left != NUM ) { bits . read Bits ( bits Left ) ; } return ; } if ( ( edifact Value & NUM ) == NUM ) { edifact Value |= NUM ; } result . append ( ( char ) edifact Value ) ; } } while ( bits . available ( ) > NUM ) ; }
public static Stream < String > words Of ( String text ) { require Non Null ( text ) ; return WORDS . split As Stream ( text ) ; }
public static String upper ( String s ) { return s . to Upper Case ( Locale . ENGLISH ) ; }
private void accept ( Socket socket ) { log . info ( STRING , socket . get Inet Address ( ) ) ; try { Inet Address server Address = dns . get Address ( STRING ) ; try ( Connection client Connection = new Connection ( socket ) ; Connection server Connection = new Connection ( new Socket ( server Address , CLASH PORT ) ) ) { Proxy Session session = Proxy Session . new Session ( services . get Message Factory ( ) , client Connection , server Connection , filter Chain ) ; log . info ( STRING , socket ) ; Village Analyzer . log Session ( session ) ; } } catch ( IO Exception e ) { log . info ( STRING , socket . get Inet Address ( ) , e . to String ( ) ) ; } finally { try { socket . close ( ) ; } catch ( IO Exception e ) { } } }
public void remove Process Listener ( Process Listener l ) { listener List . remove ( l ) ; }
public final static boolean is Valid Java Identifier ( String s ) { if ( s == null || s . length ( ) == NUM ) { return BOOL ; } char [ ] c = s . to Char Array ( ) ; if ( ! Character . is Java Identifier Start ( c [ NUM ] ) ) { return BOOL ; } for ( int i = NUM ; i < c . length ; i ++ ) { if ( ! Character . is Java Identifier Part ( c [ i ] ) ) { return BOOL ; } } return BOOL ; }
final void send Help ( ) { Array List < String > help = help ( ) ; if ( help . is Empty ( ) ) { return ; } Xmpp Msg msg = new Xmpp Msg ( ) ; msg . add String Array ( help . to Array ( new String [ help . size ( ) ] ) ) ; send ( msg ) ; }
protected void init ( ) { LOG . info ( STRING ) ; long start Time = System . current Time Millis ( ) ; bughouse Sound Keys = get Sounds Keys ( STRING ) ; sound Keys = get Sounds Keys ( STRING ) ; init Sound Player ( ) ; init Speech ( ) ; LOG . info ( STRING + ( System . current Time Millis ( ) - start Time ) + STRING ) ; }
private static void run Conf Client ( final Process Builder pb ) throws Exception { int exit Code = - NUM ; try { Process process = pb . start ( ) ; exit Code = process . wait For ( ) ; } catch ( IO Exception e ) { log . error ( STRING , e ) ; exit Code = NUM ; throw e ; } catch ( Exception e ) { log . error ( STRING , e ) ; throw e ; } switch ( exit Code ) { case SUCCESS : break ; case ERROR CODE CANNOT DOWNLOAD CONF : throw new Exception ( STRING + exit Code + STRING ) ; case ERROR CODE EXPIRED CONF : throw new Exception ( STRING + exit Code + STRING ) ; case ERROR CODE INVALID SIGNATURE VALUE : throw new Exception ( STRING + exit Code + STRING ) ; case ERROR CODE INTERNAL : throw new Exception ( STRING + exit Code + STRING ) ; default : throw new Exception ( STRING + STRING + exit Code + STRING + STRING + STRING ) ; } }
protected final void accept Annotations ( final Method Visitor mv ) { int n = visible Type Annotations == null ? NUM : visible Type Annotations . size ( ) ; for ( int i = NUM ; i < n ; ++ i ) { Type Annotation Node an = visible Type Annotations . get ( i ) ; an . accept ( mv . visit Insn Annotation ( an . type Ref , an . type Path , an . desc , BOOL ) ) ; } n = invisible Type Annotations == null ? NUM : invisible Type Annotations . size ( ) ; for ( int i = NUM ; i < n ; ++ i ) { Type Annotation Node an = invisible Type Annotations . get ( i ) ; an . accept ( mv . visit Insn Annotation ( an . type Ref , an . type Path , an . desc , BOOL ) ) ; } }
public boolean do Check Site Status ( URL url ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + url ) ; } URL Checker checker = get URL Checker ( url ) ; if ( checker != null && ( checker . get Status ( ) == URL Status . STATUS UNKNOWN ) ) { synchronized ( checker ) { checker . cancel ( ) ; checker . notify ( ) ; } synchronized ( url Checkers ) { url Checkers . remove ( get Thread Name ( url ) ) ; } debug . error ( STRING + STRING + get Thread Name ( url ) ) ; return BOOL ; } else if ( ( checker != null ) && ( checker . get Status ( ) == URL Status . STATUS AVAILABLE ) ) { return BOOL ; } else { return BOOL ; } }
protected void fill ( ) throws IO Exception { ensure Open ( ) ; len = in . read ( buf , NUM , buf . length ) ; if ( len == - NUM ) { throw new EOF Exception ( STRING ) ; } inf . set Input ( buf , NUM , len ) ; }
@ Ignore ( STRING ) @ Test public void test P 2 P View Change Reject ( ) throws Exception { final Host host = Host . get Host ( NUM ) ; final VM peer 2 = host . get VM ( NUM ) ; final VM peer 3 = host . get VM ( NUM ) ; Credential Generator gen = new Ldap User Credential Generator ( ) ; gen . init ( ) ; Properties extra Props = gen . get System Properties ( ) ; String authenticator = gen . get Authenticator ( ) ; String auth Init = gen . get Auth Init ( ) ; if ( extra Props == null ) { extra Props = new Properties ( ) ; } Credential Generator gen 2 = new Dummy Credential Generator ( ) ; gen 2 . init ( ) ; Properties extra Props 2 = gen 2 . get System Properties ( ) ; String authenticator 2 = gen 2 . get Authenticator ( ) ; if ( extra Props 2 == null ) { extra Props 2 = new Properties ( ) ; } Properties props = new Properties ( ) ; int port = get Random Available Port ( SOCKET ) ; final String locators = get IP Literal ( ) + STRING + port + STRING ; props . set Property ( SECURITY PEER AUTH INIT , auth Init ) ; props . set Property ( SECURITY PEER AUTHENTICATOR , authenticator ) ; Properties credentials = gen . get Valid Credentials ( NUM ) ; Properties java Props = gen . get Java Properties ( ) ; props . put All ( credentials ) ; props . put All ( extra Props ) ; start The Locator ( props , java Props , port ) ; try { props = new Properties ( ) ; props . set Property ( MCAST PORT , STRING ) ; props . set Property ( LOCATORS , locators ) ; props . set Property ( SECURITY PEER AUTH INIT , auth Init ) ; props . set Property ( SECURITY PEER AUTHENTICATOR , authenticator 2 ) ; credentials = gen . get Valid Credentials ( NUM ) ; Properties java Props 2 = gen 2 . get Java Properties ( ) ; props . put All ( credentials ) ; props . put All ( extra Props 2 ) ; create DS ( props , java Props 2 ) ; props = new Properties ( ) ; props . set Property ( MCAST PORT , STRING ) ; props . set Property ( LOCATORS , locators ) ; props . set Property ( SECURITY PEER AUTH INIT , auth Init ) ; props . set Property ( SECURITY PEER AUTHENTICATOR , authenticator ) ; credentials = gen . get Valid Credentials ( NUM ) ; java Props = gen . get Java Properties ( ) ; props . put All ( credentials ) ; props . put All ( extra Props ) ; create DS ( peer 2 , props , java Props ) ; create DS ( peer 3 , props , java Props ) ; pause ( NUM ) ; locator VM . invoke ( null ) ; verify Members ( NUM ) ; peer 2 . invoke ( null ) ; peer 3 . invoke ( null ) ; disconnect From DS ( ) ; pause ( NUM ) ; locator VM . invoke ( null ) ; peer 2 . invoke ( null ) ; peer 3 . invoke ( null ) ; peer 2 . invoke ( null ) ; pause ( NUM ) ; locator VM . invoke ( null ) ; peer 3 . invoke ( null ) ; peer 3 . invoke ( null ) ; pause ( NUM ) ; locator VM . invoke ( null ) ; } finally { locator VM . invoke ( null ) ; } }
private boolean overrides ( Executable Element e , Class < ? > clazz , String method ) { Type Element clazz Elt = elements . get Type Element ( clazz . get Canonical Name ( ) ) ; assert clazz Elt != null ; for ( Executable Element elt : Element Filter . methods In ( clazz Elt . get Enclosed Elements ( ) ) ) { if ( elt . get Simple Name ( ) . content Equals ( method ) && elements . overrides ( e , elt , clazz Elt ) ) { return BOOL ; } } return BOOL ; }
public Element sign XML ( Document doc , String cert Alias , String algorithm , String id Attr Name , String id , boolean include Cert , String xpath ) throws XML Signature Exception { return sign XML Using Key Pass ( doc , cert Alias , null , algorithm , id Attr Name , id , include Cert , xpath ) ; }
public int size ( ) { return attrs . size ( ) ; }
protected Socket open Passive Data Connection ( int command , String arg ) throws IO Exception , Ftp Exception Can Not Have Data Connection { Socket socket ; if ( pasv ( ) != FTP Reply . ENTERING PASSIVE MODE ) throw new Ftp Exception Can Not Have Data Connection ( STRING + get Reply String ( ) ) ; try { parse Passive Mode Reply ( get Reply Strings ( ) [ NUM ] ) ; } catch ( Malformed Server Reply Exception e ) { throw new Ftp Exception Can Not Have Data Connection ( e . get Message ( ) ) ; } socket = socket Factory . create Socket ( passive Host , passive Port ) ; if ( ! FTP Reply . is Positive Preliminary ( send Command ( command , arg ) ) ) { socket . close ( ) ; return null ; } if ( remote Verification Enabled && ! verify Remote ( socket ) ) { Inet Address host 1 , host 2 ; host 1 = socket . get Inet Address ( ) ; host 2 = get Remote Address ( ) ; socket . close ( ) ; throw new Ftp Exception Can Not Have Data Connection ( STRING + host 1 . get Host Address ( ) + STRING + host 2 . get Host Address ( ) + STRING ) ; } if ( data Timeout >= NUM ) socket . set So Timeout ( data Timeout ) ; return socket ; }
public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { Monitor mon = null ; if ( params . is Interface Enabled && params . is Enabled ) { mon = Monitor Factory . start ( labeler Int . get Summary Label ( method ) ) ; } try { if ( method . equals ( EQUALS METHOD ) ) return Boolean . value Of ( equals ( args [ NUM ] ) ) ; else return method . invoke ( monitored Obj , args ) ; } catch ( Invocation Target Exception e ) { if ( params . is Enabled ) { String sql Message = STRING ; String detail Stack Trace = null ; Throwable root Cause = e . get Cause ( ) ; if ( root Cause instanceof SQL Exception ) { SQL Exception sql Exception = ( SQL Exception ) root Cause ; sql Message = STRING + sql Exception . get Error Code ( ) + STRING + sql Exception . get SQL State ( ) ; } track Exception ( root Cause , method , sql Message ) ; } throw e . get Cause ( ) ; } finally { if ( mon != null ) mon . stop ( ) ; } }
public static void copy Stream ( final Input Stream from Stream , final Output Stream to Stream ) throws IO Exception { byte [ ] buffer = new byte [ NUM ] ; int bytes Read ; while ( ( bytes Read = from Stream . read ( buffer ) ) != - NUM ) { to Stream . write ( buffer , NUM , bytes Read ) ; } }
public static int prob Round ( double value , Random rand ) { if ( value >= NUM ) { double lower = Math . floor ( value ) ; double prob = value - lower ; if ( rand . next Double ( ) < prob ) { return ( int ) lower + NUM ; } else { return ( int ) lower ; } } else { double lower = Math . floor ( Math . abs ( value ) ) ; double prob = Math . abs ( value ) - lower ; if ( rand . next Double ( ) < prob ) { return - ( ( int ) lower + NUM ) ; } else { return - ( int ) lower ; } } }
private void load String Value ( J Text Field comp , final String element Name ) { String prop Value = properties . get Value ( element Name ) ; if ( prop Value != null && ! prop Value . is Empty ( ) ) { comp . set Text ( prop Value ) ; } }
public static Ed 25519 Group Element to Representation ( final Ed 25519 Group Element g , final Coordinate System new Coordinate System ) { final Big Integer x ; final Big Integer y ; final Big Integer gX = to Big Integer ( g . get X ( ) . encode ( ) ) ; final Big Integer gY = to Big Integer ( g . get Y ( ) . encode ( ) ) ; final Big Integer gZ = to Big Integer ( g . get Z ( ) . encode ( ) ) ; final Big Integer gT = null == g . get T ( ) ? null : to Big Integer ( g . get T ( ) . encode ( ) ) ; switch ( g . get Coordinate System ( ) ) { case AFFINE : x = gX ; y = gY ; break ; case P2 : case P3 : x = gX . multiply ( gZ . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; y = gY . multiply ( gZ . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; break ; case P1 x P 1 : x = gX . multiply ( gZ . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; assert gT != null ; y = gY . multiply ( gT . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; break ; case CACHED : x = gX . subtract ( gY ) . multiply ( gZ . multiply ( new Big Integer ( STRING ) ) . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; y = gX . add ( gY ) . multiply ( gZ . multiply ( new Big Integer ( STRING ) ) . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; break ; case PRECOMPUTED : x = gX . subtract ( gY ) . multiply ( new Big Integer ( STRING ) . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; y = gX . add ( gY ) . multiply ( new Big Integer ( STRING ) . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; break ; default : throw new Unsupported Operation Exception ( ) ; } switch ( new Coordinate System ) { case AFFINE : return Ed 25519 Group Element . affine ( to Field Element ( x ) , to Field Element ( y ) , Ed 25519 Field . ONE ) ; case P2 : return Ed 25519 Group Element . p2 ( to Field Element ( x ) , to Field Element ( y ) , Ed 25519 Field . ONE ) ; case P3 : return Ed 25519 Group Element . p3 ( to Field Element ( x ) , to Field Element ( y ) , Ed 25519 Field . ONE , to Field Element ( x . multiply ( y ) . mod ( Ed 25519 Field . P ) ) ) ; case P1 x P 1 : return Ed 25519 Group Element . p1 xp 1 ( to Field Element ( x ) , to Field Element ( y ) , Ed 25519 Field . ONE , Ed 25519 Field . ONE ) ; case CACHED : return Ed 25519 Group Element . cached ( to Field Element ( y . add ( x ) . mod ( Ed 25519 Field . P ) ) , to Field Element ( y . subtract ( x ) . mod ( Ed 25519 Field . P ) ) , Ed 25519 Field . ONE , to Field Element ( D . multiply ( new Big Integer ( STRING ) ) . multiply ( x ) . multiply ( y ) . mod ( Ed 25519 Field . P ) ) ) ; case PRECOMPUTED : return Ed 25519 Group Element . precomputed ( to Field Element ( y . add ( x ) . mod ( Ed 25519 Field . P ) ) , to Field Element ( y . subtract ( x ) . mod ( Ed 25519 Field . P ) ) , to Field Element ( D . multiply ( new Big Integer ( STRING ) ) . multiply ( x ) . multiply ( y ) . mod ( Ed 25519 Field . P ) ) ) ; default : throw new Unsupported Operation Exception ( ) ; } }
private void end Formals ( ) { if ( has Formals ) { has Formals = BOOL ; buf . append ( STRING ) ; } }
public Builder label ( char label ) { this . label = Character . to Upper Case ( label ) ; return this ; }
public static boolean is Letter Or Digit ( char c ) { return Character . is Letter Or Digit ( c ) ; }
public static int put Long ( byte [ ] bytes , int offset , long val ) { if ( little Endian ) { val = Long . reverse Bytes ( val ) ; } the Unsafe . put Long ( bytes , offset + BYTE ARRAY BASE OFFSET , val ) ; return offset + Bytes . SIZEOF LONG ; }
private Instruction schedule Scalar Defs Early ( Enumeration < Operand > e , Instruction early Pos , Instruction inst ) { while ( e . has More Elements ( ) ) { Operand op = e . next Element ( ) ; Instruction def = defining Instruction ( op ) ; schedule Early ( def ) ; if ( def . is Branch ( ) ) def = dominance Successor ( def , inst ) ; early Pos = max Dominator Depth ( def , early Pos ) ; } return early Pos ; }
public void make Unique ( String [ ] columns , String conflict Policy ) { uniques . add ( CONSTRAINT UNIQUE + Text Utils . join ( STRING , columns ) + UNIQUE + Text Utils . join ( STRING , columns ) + ON CONFLICT + conflict Policy + COMMA ) ; }
default < T > void for Each Matching Field Name With Boolean ( String regex , Bi Consumer < String , Boolean > function ) { for Each Matching Field Name With Boolean ( Pattern . compile ( regex ) , NUM , function ) ; }
protected boolean is Valid Domain ( String domain ) { Matcher ip Domain Matcher = IP DOMAIN PATTERN . matcher ( domain ) ; if ( ip Domain Matcher . matches ( ) ) { Inet Address Validator inet Address Validator = Inet Address Validator . get Instance ( ) ; return inet Address Validator . is Valid ( ip Domain Matcher . group ( NUM ) ) ; } Domain Validator domain Validator = Domain Validator . get Instance ( allow Local ) ; return domain Validator . is Valid ( domain ) || domain Validator . is Valid Tld ( domain ) ; }
public void exit ( ) { cancel ( ) ; final float radius = lerp ( NUM , m Outer Radius , m Tween Radius ) ; final float remaining ; if ( m Anim Radius != null && m Anim Radius . is Running ( ) ) { remaining = m Outer Radius - radius ; } else { remaining = m Outer Radius ; } final int radius Duration = ( int ) ( NUM * Math . sqrt ( remaining / ( WAVE TOUCH UP ACCELERATION + WAVE TOUCH DOWN ACCELERATION ) * m Density ) + NUM ) ; final int opacity Duration = ( int ) ( NUM * m Opacity / WAVE OPACITY DECAY VELOCITY + NUM ) ; exit Software ( radius Duration , opacity Duration ) ; }
public void test Sealed Object 2 ( ) throws Exception { try { new Sealed Object ( null ) { } ; fail ( STRING + STRING ) ; } catch ( Null Pointer Exception e ) { } String secret = STRING ; Cipher cipher = new Null Cipher ( ) ; Sealed Object so 1 = new Sealed Object ( secret , cipher ) ; Sealed Object so 2 = new Sealed Object ( so 1 ) { } ; assert Equals ( STRING + STRING , secret , so 2 . get Object ( cipher ) ) ; assert Equals ( STRING + STRING + STRING , so 1 . get Algorithm ( ) , so 2 . get Algorithm ( ) ) ; }
@ Override public void handle Request Body ( Solr Query Request req , Solr Query Response rsp ) throws Parse Exception , IO Exception , Syntax Error { String deletion Query = get Deletion Query ( ) ; LOGGER . info ( STRING , deletion Query ) ; if ( older Documents Exists ( deletion Query , req , rsp ) ) { Update Request Processor processor = get Processor ( req , rsp ) ; delete Old Documents ( deletion Query , processor , req ) ; commit Deletions ( processor , req ) ; } }
public < V extends Comparable < ? super V > > Optional Long max By ( Long Function < V > key Extractor ) { Obj Long Box < V > result = collect ( null , null , null ) ; return result . a == null ? Optional Long . empty ( ) : Optional Long . of ( result . b ) ; }
public void query And Compare Shards ( Solr Params params ) throws Exception { update Mappings From Zk ( jettys , clients ) ; List < String > shards = new Array List < > ( shard To Jetty . key Set ( ) ) ; for ( String shard : shards ) { query And Compare Replicas ( params , shard ) ; } }
public int index Of ( int ch ) { return index Of ( ch , NUM ) ; }
private Watcher init Watcher ( Solr Zk Client zk Client ) { wrapped Watcher = new Buffer State Watcher ( ) ; return zk Client . wrap Watcher ( wrapped Watcher ) ; }
public Configuration ( ) { super ( ) ; }
public static < K , V > Map < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 , K k6 , V v6 , K k7 , V v7 ) { Map map = of ( ) ; map . put ( k1 , v1 ) ; map . put ( k2 , v2 ) ; map . put ( k3 , v3 ) ; map . put ( k4 , v4 ) ; map . put ( k5 , v5 ) ; map . put ( k6 , v6 ) ; map . put ( k7 , v7 ) ; return map ; }
public long long At ( int index ) { lb . position ( index ) ; return lb . get ( ) ; }
private String start Set To String ( ) { String Buffer F String = new String Buffer ( ) ; boolean did Print ; if ( m starting == null ) { return get Start Set ( ) ; } for ( int i = NUM ; i < m starting . length ; i ++ ) { did Print = BOOL ; if ( ( m has Class == BOOL ) || ( m has Class == BOOL && i != m class Index ) ) { F String . append ( ( m starting [ i ] + NUM ) ) ; did Print = BOOL ; } if ( i == ( m starting . length - NUM ) ) { F String . append ( STRING ) ; } else { if ( did Print ) { F String . append ( STRING ) ; } } } return F String . to String ( ) ; }
public static String make Tag Class Name ( String component Family , String renderer Type ) { if ( component Family == null ) { return null ; } String tag Class Name = component Family ; if ( renderer Type != null ) { if ( ! component Family . equals ( renderer Type ) ) { tag Class Name = tag Class Name + renderer Type ; } } return tag Class Name + STRING ; }
public void register Service ( String service Name , boolean create Template , boolean activate ) throws AM Exception , SSO Exception { if ( debug . message Enabled ( ) ) { debug . message ( STRING + service Name + STRING + create Template + STRING + activate + STRING ) ; } ds Services . register Service ( super . token , super . entry DN , service Name ) ; Set service Status = get Attribute ( SERVICE STATUS ATTRIBUTE ) ; if ( ! service Status . equals ( Collections . EMPTY SET ) ) { Iterator iter = service Status . iterator ( ) ; while ( iter . has Next ( ) ) { String status = ( String ) iter . next ( ) ; if ( status . equals Ignore Case ( service Name ) ) { Object args [ ] = { service Name } ; throw new AM Exception ( AMSDK Bundle . get String ( STRING , args , super . locale ) , STRING , args ) ; } } } else { service Status = new Hash Set ( ) ; } service Status . add ( service Name ) ; set Attribute ( SERVICE STATUS ATTRIBUTE , service Status ) ; try { store ( ) ; } catch ( AM Exception le ) { try { Set object Class = get Attribute ( STRING ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + object Class ) ; } if ( ! object Class . contains ( STRING ) ) { object Class . add ( STRING ) ; set Attribute ( STRING , object Class ) ; set Attribute ( SERVICE STATUS ATTRIBUTE , service Status ) ; store ( ) ; } else { throw le ; } } catch ( Exception e ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING , e ) ; } throw le ; } } if ( create Template ) { try { if ( AM Service Utils . service Has Sub Schema ( super . token , service Name , Schema Type . POLICY ) ) { create Template ( AM Template . POLICY TEMPLATE , service Name , null ) ; } if ( AM Service Utils . service Has Sub Schema ( super . token , service Name , Schema Type . DYNAMIC ) ) { create Template ( AM Template . DYNAMIC TEMPLATE , service Name , null ) ; } } catch ( SMS Exception smsex ) { throw new AM Exception ( AMSDK Bundle . get String ( STRING , super . locale ) , STRING ) ; } } }
public static void assert Almost Equals ( double expected , double actual , int decimals ) { assert Almost Equals ( null , new Double ( expected ) , new Double ( actual ) , decimals ) ; }
private static int snap Vertical ( Collection < Constraint Widget > widgets , Constraint Widget widget , Constraint Anchor anchor , int position , Array List < Snap Candidate > snap Candidates ) { Snap Candidate candidate = new Snap Candidate ( ) ; Constraint Handle handle = Widget Interaction Targets . constraint Handle ( anchor ) ; if ( handle == null ) { return position ; } handle . set Draw Y ( position ) ; Snap Placement . snap Anchor ( widgets , widget , anchor , candidate ) ; if ( candidate . target != null ) { Constraint Handle target Handle = Widget Interaction Targets . constraint Handle ( candidate . target ) ; int ty = candidate . y ; if ( target Handle != null ) { ty = target Handle . get Draw Y ( ) ; } position = ty + candidate . margin ; snap Candidates . add ( candidate ) ; } return position ; }
public int send ( Output Stream out ) throws IO Exception { out . write ( this . file Buff , this . offset , this . length ) ; return NUM ; }
private double sin ( double angle ) { while ( angle >= NUM ) { angle -= NUM ; } double value = ( angle / NUM * Math . PI ) ; return Math . sin ( value ) ; }
public static String last ( String list , String delimiter , boolean ignore Empty ) { if ( String Util . is Empty ( list ) ) return STRING ; int len = list . length ( ) ; char [ ] del ; if ( String Util . is Empty ( delimiter ) ) { del = new char [ ] { STRING } ; } else del = delimiter . to Char Array ( ) ; int index ; int x ; while ( BOOL ) { index = - NUM ; for ( int i = NUM ; i < del . length ; i ++ ) { x = list . last Index Of ( del [ i ] ) ; if ( x > index ) index = x ; } if ( index == - NUM ) { return list ; } else if ( index + NUM == len ) { if ( ! ignore Empty ) return STRING ; list = list . substring ( NUM , len - NUM ) ; len -- ; } else { return list . substring ( index + NUM ) ; } } }
private void try Parse Type Attribute ( IDOM Element element ) { IDOM Attr type Attr = ( IDOM Attr ) Ui Binder Xml Model Utilities . get Type Attribute ( element ) ; if ( type Attr == null ) { return ; } I Region value Region = Xml Utilities . get Attribute Value Region ( type Attr ) ; if ( value Region == null ) { return ; } String fq Type = type Attr . get Node Value ( ) ; if ( fq Type == null ) { return ; } final I Type type = Java Model Search . find Type ( java Project , fq Type ) ; if ( ! Java Model Search . is Valid Element ( type ) ) { problem Marker Manager . set Type Undefined Error ( value Region , fq Type ) ; } else { if ( Ui Binder Xml Model Utilities . is Style Element ( element ) ) { I Type css Resource Type = Client Bundle Utilities . find Css Resource Type ( java Project ) ; if ( css Resource Type != null ) { try { if ( ! Java Utilities . is Subtype ( css Resource Type , type ) ) { problem Marker Manager . set Not Css Resource Subtype Error ( value Region , fq Type ) ; } } catch ( Java Model Exception e ) { GWT Plugin Log . log Warning ( e , STRING ) ; } } } } java Type References . add ( fq Type ) ; }
private void clear Dictionary Cache ( ) { Map < String , Dictionary > dictionary Caches = surrogate Key Gen . get Dictionary Caches ( ) ; List < Dictionary > reverse Dictionaries = new Array List < > ( dictionary Caches . values ( ) ) ; for ( int i = NUM ; i < reverse Dictionaries . size ( ) ; i ++ ) { Dictionary dictionary = reverse Dictionaries . get ( i ) ; dictionary . clear ( ) ; } }
private void pull Event ( ) { final int new Scroll Value ; final int item Dimension ; final float initial Motion Value , last Motion Value ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : initial Motion Value = m Initial Motion X ; last Motion Value = m Last Motion X ; break ; case VERTICAL : default : initial Motion Value = m Initial Motion Y ; last Motion Value = m Last Motion Y ; break ; } switch ( m Current Mode ) { case PULL FROM END : new Scroll Value = Math . round ( Math . max ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Footer Size ( ) ; break ; case PULL FROM START : default : new Scroll Value = Math . round ( Math . min ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Header Size ( ) ; break ; } set Header Scroll ( new Scroll Value ) ; if ( new Scroll Value != NUM && ! is Refreshing ( ) ) { float scale = Math . abs ( new Scroll Value ) / ( float ) item Dimension ; switch ( m Current Mode ) { case PULL FROM END : m Footer Layout . on Pull ( scale ) ; break ; case PULL FROM START : default : m Header Layout . on Pull ( scale ) ; break ; } if ( m State != State . PULL TO REFRESH && item Dimension >= Math . abs ( new Scroll Value ) ) { set State ( State . PULL TO REFRESH ) ; } else if ( m State == State . PULL TO REFRESH && item Dimension < Math . abs ( new Scroll Value ) ) { set State ( State . RELEASE TO REFRESH ) ; } } }
public static List < M Relation Type > retrieve Types ( final PO po , final int window Id ) { if ( po . get Key Columns ( ) . length != NUM ) { logger . severe ( po + STRING + po . get Key Columns ( ) . length + STRING ) ; PO Relation Exception . throw Wrong Key Column Count ( po ) ; } final String key Column = po . get Key Columns ( ) [ NUM ] ; final int col Id = M Column . get Column ID ( po . get Table Name ( ) , key Column ) ; final Prepared Statement pstmt = DB . prepare Statement ( SQL , po . get Trx Name ( ) ) ; Result Set rs = null ; try { pstmt . set Int ( NUM , po . get Table ID ( ) ) ; pstmt . set Int ( NUM , col Id ) ; rs = pstmt . execute Query ( ) ; final List < M Relation Type > result = eval Result Set ( po , window Id , rs ) ; logger . info ( STRING + result . size ( ) + STRING + po ) ; return result ; } catch ( SQL Exception e ) { logger . severe ( e . get Message ( ) ) ; throw new Adempiere Exception ( e ) ; } finally { DB . close ( rs , pstmt ) ; } }
public Jdp Jmx Packet ( byte [ ] data ) throws Jdp Exception { Jdp Packet Reader reader ; reader = new Jdp Packet Reader ( data ) ; Map < String , String > p = reader . get Discovery Data As Map ( ) ; String s Id = p . get ( UUID KEY ) ; this . id = ( s Id == null ) ? null : UUID . from String ( s Id ) ; this . jmx Service Url = p . get ( JMX SERVICE URL KEY ) ; this . main Class = p . get ( MAIN CLASS KEY ) ; this . instance Name = p . get ( INSTANCE NAME KEY ) ; this . process Id = p . get ( PROCESS ID KEY ) ; this . rmi Hostname = p . get ( RMI HOSTNAME KEY ) ; this . broadcast Interval = p . get ( BROADCAST INTERVAL KEY ) ; }
private Uid Range parse Uid Range ( String range ) throws Decoding Exception { int pos = range . index Of ( STRING ) ; try { if ( pos == - NUM ) { if ( range . length ( ) == NUM && range . char At ( NUM ) == STRING ) { return new Uid Range ( Message Uid . MAX VALUE ) ; } else { long value = parse Unsigned Integer ( range ) ; return new Uid Range ( Message Uid . of ( value ) ) ; } } else { long val 1 = parse Unsigned Integer ( range . substring ( NUM , pos ) ) ; long val 2 = parse Unsigned Integer ( range . substring ( pos + NUM ) ) ; if ( val 1 == Long . MAX VALUE && val 2 == Long . MAX VALUE ) { return new Uid Range ( Message Uid . MAX VALUE ) ; } else if ( val 1 <= val 2 ) { return new Uid Range ( Message Uid . of ( val 1 ) , Message Uid . of ( val 2 ) ) ; } else if ( val 1 == Long . MAX VALUE ) { return new Uid Range ( Message Uid . of ( val 2 ) , Message Uid . MAX VALUE ) ; } else { return new Uid Range ( Message Uid . of ( val 2 ) , Message Uid . of ( val 1 ) ) ; } } } catch ( Number Format Exception e ) { throw new Decoding Exception ( Human Readable Text . INVALID MESSAGESET , STRING , e ) ; } }
public void add FXGL Listener ( FXGL Listener listener ) { system Listeners . add ( listener ) ; }
public void add Definition ( String definition ) { if ( ! String Utils . is Empty ( definition ) ) { definitions . add ( definition ) ; } }
@ Override public void receive Event ( Client State Information information ) { if ( information . get State ( ) != current State ) { logger . info ( STRING + information ) ; if ( information . get State ( ) == Client State . SEARCH ) { search Start Time = System . current Time Millis ( ) ; for ( Sequence Output Variable Factory < ? > factory : sequence Output Variable Factories . values ( ) ) { factory . set Start Time ( search Start Time ) ; } } Output Variable < Long > time = new Output Variable < Long > ( STRING + current State . get Name ( ) , System . current Time Millis ( ) - current State Started ) ; output Variables . put ( time . get Name ( ) , time ) ; current State = information . get State ( ) ; current State Started = System . current Time Millis ( ) ; } }
public void test Case 11 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( NUM , result . signum ( ) ) ; }
public void add Bug Code ( Bug Code bug Code ) { bug Code List . add ( bug Code ) ; }
@ Override public final void write ( int b ) { if ( this . ignore Writes ) return ; check If Writable ( ) ; ensure Capacity ( NUM ) ; buffer . put ( ( byte ) b ) ; }
public void test Nested Allocation Contexts ( ) { final I Allocation Context context = manager . new Allocation Context ( BOOL ) ; final String test = STRING ; final long addr 1 = allocate ( manager , context , test ) ; final long addr 2 = allocate ( manager , context , test ) ; assert True ( addr 1 != addr 2 ) ; final String res = get String ( addr 1 ) ; assert True ( res . equals ( test ) ) ; manager . free ( addr 1 , context ) ; final long addr 3 = allocate ( manager , context , test ) ; assert True ( addr 1 != addr 3 ) ; manager . detach Context ( context ) ; final I Allocation Context context 2 = manager . new Allocation Context ( BOOL ) ; final long addr 4 = allocate ( manager , context 2 , test ) ; assert True ( addr 1 == addr 4 ) ; }
public static String underlines To Camel Case ( String string ) { String Builder sb = new String Builder ( string . length ( ) ) ; int n = string . length ( ) ; int i = NUM ; boolean upcase Next = BOOL ; for ( ; i < n ; i ++ ) { char c = string . char At ( i ) ; if ( c == STRING ) { upcase Next = BOOL ; } else { if ( upcase Next ) { c = Character . to Upper Case ( c ) ; } upcase Next = BOOL ; sb . append ( c ) ; } } return sb . to String ( ) ; }
protected Best Match Finder ( String pattern ) { search Pattern = pattern . to Lower Case ( ) ; }
public int index Of ( Object key ) { return key == null ? index Of Null ( ) : index Of ( key , key . hash Code ( ) ) ; }
public long next Action Millis ( long now , long next Retry Time Millis ) { for ( File Download Info info : downloads ) { long individual Retry Time Millis = get Next Action Millis For ( now , info ) ; next Retry Time Millis = Math . min ( individual Retry Time Millis , next Retry Time Millis ) ; } return next Retry Time Millis ; }
private void pop ( final String desc ) { char c = desc . char At ( NUM ) ; if ( c == STRING ) { pop ( ( Type . get Arguments And Return Sizes ( desc ) > > NUM ) - NUM ) ; } else if ( c == STRING || c == STRING ) { pop ( NUM ) ; } else { pop ( NUM ) ; } }
public Integer count Pages Containing Template Names ( List < String > template Names ) throws Wiki Api Exception { return count Filtered Pages ( template Names , BOOL ) ; }
static URL fix Pure Query Targets ( URL base , String target ) throws Malformed URL Exception { if ( ! target . starts With ( STRING ) ) return new URL ( base , target ) ; String base Path = base . get Path ( ) ; String base Right Most = STRING ; int base Right Most Idx = base Path . last Index Of ( STRING ) ; if ( base Right Most Idx != - NUM ) { base Right Most = base Path . substring ( base Right Most Idx + NUM ) ; } if ( target . starts With ( STRING ) ) target = base Right Most + target ; return new URL ( base , target ) ; }
synchronized void add ( Object obj ) { if ( obj List != null ) { obj List . add ( obj ) ; } }
public void sort ( ) { Collections . sort ( individuals , PERFORMANCE COMPARATOR ) ; }
void free Interval ( Spill Location Interval i ) { free Intervals . add ( i ) ; }
private void check And Write Dictionary Chunk To File ( ) throws IO Exception { if ( one Dictionary Chunk List . size ( ) >= dictionary one chunk size ) { write Dictionary File ( ) ; create Chunk List ( ) ; } }
private void ctrl Select ( D node Data ) { int insertion Index = get Insertion Index ( node Data ) ; insert And Select Node ( node Data , insertion Index , ! node Data . equals ( selected Nodes . get ( insertion Index ) ) ) ; }
private void read Object ( Object Input Stream ois ) throws IO Exception , Class Not Found Exception { byte [ ] asn 1 Enc Principal = ( byte [ ] ) ois . read Object ( ) ; byte [ ] enc Realm = ( byte [ ] ) ois . read Object ( ) ; try { Realm realm Object = new Realm ( new Der Value ( enc Realm ) ) ; Principal Name krb 5 Principal = new Principal Name ( new Der Value ( asn 1 Enc Principal ) , realm Object ) ; realm = realm Object . to String ( ) ; full Name = krb 5 Principal . to String ( ) ; name Type = krb 5 Principal . get Name Type ( ) ; } catch ( Exception e ) { throw new IO Exception ( e ) ; } }
private static int read Swapped Integer ( final Data Input Stream input ) throws IO Exception { final int value 1 = input . read Byte ( ) ; final int value 2 = input . read Byte ( ) ; final int value 3 = input . read Byte ( ) ; final int value 4 = input . read Byte ( ) ; return ( ( value 1 & NUM ) << NUM ) + ( ( value 2 & NUM ) << NUM ) + ( ( value 3 & NUM ) << NUM ) + ( ( value 4 & NUM ) << NUM ) ; }
private void consume Pre Nested Scroll ( int dx , int dy , int [ ] consumed ) { if ( m Over Scroll Effect == Over Scroll Effect . BOUNCE && m Unconsumed Over Scroll Offset != NUM ) { int dest Offset = m Unconsumed Over Scroll Offset - dy ; if ( ! Math Utils . same Sign ( dest Offset , m Unconsumed Over Scroll Offset ) ) { dest Offset = NUM ; } else if ( Math . abs ( dest Offset ) > Math . abs ( m Unconsumed Over Scroll Offset ) ) { dest Offset = m Unconsumed Over Scroll Offset ; } consumed [ NUM ] = NUM ; consumed [ NUM ] = m Unconsumed Over Scroll Offset - dest Offset ; m Unconsumed Over Scroll Offset = dest Offset ; set Scrolling Offset ( get Unconsumed Scrolling Offset ( ) ) ; } }
private static native void init I Ds ( ) ;
public Str Builder replace ( final int start Index , int end Index , final String replace Str ) { end Index = validate Range ( start Index , end Index ) ; final int insert Len = ( replace Str == null ? NUM : replace Str . length ( ) ) ; replace Impl ( start Index , end Index , end Index - start Index , replace Str , insert Len ) ; return this ; }
public void close File ( ) { close File ( BOOL ) ; }
public boolean is Valid ( int value ) { return min <= value && value <= max ; }
public Plugins Info info ( ) { return info ; }
public void fire Property Change ( String property Name , int old Value , int new Value ) { fire Property Change ( property Name , Integer . value Of ( old Value ) , Integer . value Of ( new Value ) ) ; }
static Array List < Field > all Fields ( final Class < ? > clazz ) { final Array List < Field > res = new Array List < > ( ) ; Class < ? > cl = clazz ; while ( cl != null ) { final Field [ ] fields = cl . get Declared Fields ( ) ; Collections . add All ( res , fields ) ; cl = cl . get Superclass ( ) ; } return res ; }
private void update Weather States ( ) { boolean changed = temperature . update ( ) ; changed |= rain . update ( ) ; changed |= fog . update ( ) ; changed |= thunder . update ( ) ; if ( changed ) { update Zones ( ) ; } }
public static Render Loops make Render Loops ( Surface Type src , Composite Type comp , Surface Type dst ) { Render Loops loops = new Render Loops ( ) ; loops . draw Line Loop = Draw Line . locate ( src , comp , dst ) ; loops . fill Rect Loop = Fill Rect . locate ( src , comp , dst ) ; loops . draw Rect Loop = Draw Rect . locate ( src , comp , dst ) ; loops . draw Polygons Loop = Draw Polygons . locate ( src , comp , dst ) ; loops . draw Path Loop = Draw Path . locate ( src , comp , dst ) ; loops . fill Path Loop = Fill Path . locate ( src , comp , dst ) ; loops . fill Spans Loop = Fill Spans . locate ( src , comp , dst ) ; loops . fill Parallelogram Loop = Fill Parallelogram . locate ( src , comp , dst ) ; loops . draw Parallelogram Loop = Draw Parallelogram . locate ( src , comp , dst ) ; loops . draw Glyph List Loop = Draw Glyph List . locate ( src , comp , dst ) ; loops . draw Glyph List AA Loop = Draw Glyph List AA . locate ( src , comp , dst ) ; loops . draw Glyph List LCD Loop = Draw Glyph List LCD . locate ( src , comp , dst ) ; return loops ; }
public void edit ( Object plot Canvas ) { String label = J Option Pane . show Input Dialog ( ( Plot Canvas ) plot Canvas , STRING , label ) ; if ( label != null ) { set Legend ( label ) ; } }
protected boolean exclude File ( String file ) { if ( excluded == null ) return BOOL ; Iterator < String > iter = excluded . iterator ( ) ; while ( iter . has Next ( ) ) if ( file . ends With ( iter . next ( ) ) ) return BOOL ; return BOOL ; }
public Builder delete User Type ( ) { delete Fields . add ( STRING ) ; return this ; }
public final static boolean ends With Ignore Case ( String str , String end ) { int str Length = str == null ? NUM : str . length ( ) ; int end Length = end == null ? NUM : end . length ( ) ; if ( end Length > str Length ) return BOOL ; for ( int i = NUM ; i <= end Length ; i ++ ) { if ( Scanner Helper . to Lower Case ( end . char At ( end Length - i ) ) != Scanner Helper . to Lower Case ( str . char At ( str Length - i ) ) ) return BOOL ; } return BOOL ; }
private void translate Matrix After Rotate ( int axis , float trans , float prev Image Size , float image Size , int prev View Size , int view Size , int drawable Size ) { if ( image Size < view Size ) { m [ axis ] = ( view Size - ( drawable Size * m [ Matrix . MSCALE X ] ) ) * NUM ; } else if ( trans > NUM ) { m [ axis ] = - ( ( image Size - view Size ) * NUM ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM * prev View Size ) ) / prev Image Size ; m [ axis ] = - ( ( percentage * image Size ) - ( view Size * NUM ) ) ; } }
public void write ( int c ) throws IO Exception { internal Out . write ( c ) ; }
private < T extends Client Request Result > Collection < T > execute Request ( final Collection < Long > ids , final Class < T > clazz , final Client Request Report Listener report Listener , final String request Queue ) { LOGGER . debug ( STRING ) ; Client Request Impl < T > client Request = new Client Request Impl < T > ( clazz ) ; Iterator < Long > it = ids . iterator ( ) ; Collection < Future < Collection < T > > > results = new Array List < Future < Collection < T > > > ( ) ; int counter = NUM ; while ( it . has Next ( ) ) { while ( it . has Next ( ) && counter < max Request Size ) { client Request . add Tag Id ( it . next ( ) ) ; counter ++ ; } Request Values Task < T > task = new Request Values Task < T > ( client Request , report Listener , request Queue ) ; results . add ( executor . submit ( task ) ) ; client Request = new Client Request Impl < T > ( clazz ) ; counter = NUM ; } Collection < T > final Collection = new Array List < T > ( ) ; for ( Future < Collection < T > > result : results ) { try { final Collection . add All ( result . get ( ) ) ; } catch ( Interrupted Exception e ) { LOGGER . error ( STRING , e ) ; throw new Runtime Exception ( e ) ; } catch ( Execution Exception e ) { LOGGER . error ( STRING , e ) ; throw new Runtime Exception ( e ) ; } } LOGGER . debug ( STRING ) ; return final Collection ; }
public static Map < String , Integer > class Names To Mapping ( List < String > labels ) { Map < String , Integer > mapping = new Hash Map < String , Integer > ( ) ; for ( int i = NUM ; i < labels . size ( ) ; i ++ ) { mapping . put ( labels . get ( i ) , i ) ; } return mapping ; }
public static String short Number ( int number ) { if ( number >= NUM ) { int hundred = number % NUM / NUM ; if ( hundred != NUM ) return String . format ( STRING , number / NUM ) + STRING ; else return ( number / NUM ) + STRING ; } else return number + STRING ; }
public static void put Unsigned Short ( Byte Buffer bb , int v ) { bb . put Short ( ( short ) ( v & NUM ) ) ; }
public static String read File To String ( File f ) throws IO Exception { String Writer sw = new String Writer ( ) ; IO . copy And Close Both ( Common . as Reader UTF 8 Lenient ( new File Input Stream ( f ) ) , sw ) ; return sw . to String ( ) ; }
public void test wrap Byte Buffer$ Byte Buffer 05 ( ) { String host = STRING ; int port = NUM ; Byte Buffer bb = Byte Buffer . allocate ( NUM ) ; Byte Buffer [ ] bb A = { Byte Buffer . allocate ( NUM ) , Byte Buffer . allocate ( NUM ) , Byte Buffer . allocate ( NUM ) } ; SSL Engine sse = get Engine ( host , port ) ; sse . set Use Client Mode ( BOOL ) ; try { SSL Engine Result res = sse . wrap ( bb A , bb ) ; assert Equals ( NUM , res . bytes Consumed ( ) ) ; assert Equals ( NUM , res . bytes Produced ( ) ) ; } catch ( Exception ex ) { fail ( STRING + ex ) ; } }
private boolean link Last ( Node < E > node ) { if ( count >= capacity ) return BOOL ; Node < E > l = last ; node . prev = l ; last = node ; if ( first == null ) first = node ; else l . next = node ; ++ count ; not Empty . signal ( ) ; return BOOL ; }
public void test Topic Dinamically Included Behavior ( ) throws Exception { start All Brokers ( ) ; Destination dest = create Destination ( STRING , BOOL ) ; Message Consumer client A = create Consumer ( STRING , dest ) ; Message Consumer client B = create Consumer ( STRING , dest ) ; Thread . sleep ( NUM * NUM ) ; send Messages ( STRING , dest , MESSAGE COUNT ) ; Message Id List msgs A = get Consumer Messages ( STRING , client A ) ; msgs A . wait For Messages To Arrive ( MESSAGE COUNT ) ; assert Equals ( MESSAGE COUNT , msgs A . get Message Count ( ) ) ; Message Id List msgs B = get Consumer Messages ( STRING , client B ) ; msgs B . wait For Messages To Arrive ( MESSAGE COUNT ) ; assert Equals ( NUM , msgs B . get Message Count ( ) ) ; }
private File create Capture File ( int encoding Type , String file Name ) { if ( file Name . is Empty ( ) ) { file Name = STRING ; } if ( encoding Type == JPEG ) { file Name = file Name + STRING ; } else if ( encoding Type == PNG ) { file Name = file Name + STRING ; } else { throw new Illegal Argument Exception ( STRING + encoding Type ) ; } return new File ( get Temp Directory Path ( ) , file Name ) ; }
@ Override public void action Performed ( Action Event e ) { Object o ; o = e . get Source ( ) ; if ( o == m Menu File Open ) { load File ( ) ; } else if ( o == m Menu File Save ) { save File ( ) ; } else if ( o == m Menu File Save As ) { save File As ( ) ; } else if ( o == m Menu File Close ) { close File ( ) ; } else if ( o == m Menu File Close All ) { close All Files ( ) ; } else if ( o == m Menu File Properties ) { show Properties ( ) ; } else if ( o == m Menu File Exit ) { close ( ) ; } else if ( o == m Menu Edit Undo ) { undo ( ) ; } else if ( o == m Menu Edit Copy ) { copy Content ( ) ; } else if ( o == m Menu Edit Search ) { search ( ) ; } else if ( o == m Menu Edit Clear Search ) { clear Search ( ) ; } else if ( o == m Menu Edit Delete Attribute ) { delete Attribute ( BOOL ) ; } else if ( o == m Menu Edit Delete Attributes ) { delete Attribute ( BOOL ) ; } else if ( o == m Menu Edit Rename Attribute ) { rename Attribute ( ) ; } else if ( o == m Menu Edit Attribute As Class ) { attribute As Class ( ) ; } else if ( o == m Menu Edit Delete Instance ) { delete Instance ( BOOL ) ; } else if ( o == m Menu Edit Delete Instances ) { delete Instance ( BOOL ) ; } else if ( o == m Menu Edit Sort Instances ) { sort Instances ( ) ; } else if ( o == m Menu View Attributes ) { show Attributes ( ) ; } else if ( o == m Menu View Values ) { show Values ( ) ; } else if ( o == m Menu View Optimal Col Widths ) { set Optimal Col Widths ( ) ; } update Menu ( ) ; }
public boolean validate Token ( Endpoint Specification endpoint Specification , Security Token to Be Validated Token ) throws Soap STS Consumer Exception { STS Client client = get STS Client ( sts Instance Wsdl Url , endpoint Specification . service Q Name , endpoint Specification . port Q Name ) ; client . set Token Type ( STS Constants . STATUS ) ; try { client . validate Security Token ( to Be Validated Token ) ; return BOOL ; } catch ( Trust Exception e ) { return BOOL ; } catch ( Exception e ) { throw new Soap STS Consumer Exception ( e . get Message ( ) , e ) ; } }
public static String strip Function Tags ( String label ) { if ( label . index Of ( STRING ) > NUM ) return label . substring ( NUM , label . index Of ( STRING ) ) ; else return label ; }
@ Override public void play New Video ( Meta Data current Item Meta Data , Video Player View video Player View , String video Url ) { if ( SHOW LOGS ) Logger . v ( TAG , STRING + video Player View + STRING + m Current Player + STRING + video Player View ) ; m Player Handler . pause Queue Processing ( TAG ) ; boolean current Player Is Active = m Current Player == video Player View ; boolean is Already Playing The File = m Current Player != null && video Url . equals ( m Current Player . get Video Url Data Source ( ) ) ; if ( SHOW LOGS ) Logger . v ( TAG , STRING + is Already Playing The File ) ; if ( SHOW LOGS ) Logger . v ( TAG , STRING + current Player Is Active ) ; if ( current Player Is Active ) { if ( is In Playback State ( ) && is Already Playing The File ) { if ( SHOW LOGS ) Logger . v ( TAG , STRING + video Player View + STRING + m Current Player State ) ; } else { start New Playback ( current Item Meta Data , video Player View , video Url ) ; } } else { start New Playback ( current Item Meta Data , video Player View , video Url ) ; } m Player Handler . resume Queue Processing ( TAG ) ; if ( SHOW LOGS ) Logger . v ( TAG , STRING + video Player View + STRING + video Url ) ; }
private void add Trace And Type ( String name ) { if ( traces Type . get ( name ) == null ) { traces . add ( create Trace ( name , Trace Type . REAL ) ) ; traces Type . put ( name , Trace Type . REAL ) ; } else { traces . add ( create Trace ( name , traces Type . get ( name ) ) ) ; } }
public static boolean is Reserved Stream Name ( String name ) { return name . starts With ( STRING ) ; }
public static Volume Mount [ ] format Original Container Volume Mount ( Log Draft log Draft ) { List < Volume Mount > volume Mounts = new Array List < > ( ) ; int idx Suffix = NUM ; for ( Log Item Draft log Item Draft : log Draft . get Log Item Drafts ( ) ) { if ( log Item Draft . is Auto Collect ( ) || log Item Draft . is Auto Delete ( ) ) { Volume Mount volume Mount = new Volume Mount ( ) ; volume Mount . set Name ( STRING + idx Suffix ) ; volume Mount . set Mount Path ( Log Item Draft . get Log Parent Path ( log Item Draft . get Log Path ( ) ) ) ; volume Mounts . add ( volume Mount ) ; idx Suffix ++ ; } } return volume Mounts . to Array ( new Volume Mount [ ] { } ) ; }
public static double dnorm ( double x ) { return Math . exp ( - x * x / NUM ) * PSI ; }
public static long checksum CRC 32 ( File file ) throws IO Exception { CRC 32 crc = new CRC 32 ( ) ; checksum ( file , crc ) ; return crc . get Value ( ) ; }
private void cmd annotate Difference ( ) { Big Decimal previous Value , actual Value , difference ; previous Value = ( Big Decimal ) v previous Balance . get Value ( ) ; actual Value = ( Big Decimal ) v Actual Balance . get Value ( ) ; difference = actual Value . subtract ( previous Value ) ; M Cash Book cash Book = new M Cash Book ( p ctx , p pos . get C Cash Book ID ( ) , null ) ; Timestamp today = Time Util . get Day ( System . current Time Millis ( ) ) ; M Cash cash = M Cash . get ( p ctx , cash Book . get C Cash Book ID ( ) , today , null ) ; if ( cash != null && cash . get ID ( ) != NUM && difference . compare To ( cash . get Statement Difference ( ) ) != NUM ) { M Cash Line cl = new M Cash Line ( cash ) ; cl . set Cash Type ( M Cash Line . CASHTYPE Difference ) ; cl . set Amount ( difference ) ; cl . set Description ( Msg . translate ( p pos . get Ctx ( ) , STRING ) + previous Value + STRING + actual Value ) ; cl . save Ex ( ) ; } cash = M Cash . get ( p pos . get Ctx ( ) , p pos . get C Cash Book ID ( ) , today , null ) ; v previous Balance . set Value ( cash . get Ending Balance ( ) ) ; v Actual Balance . set Value ( Env . ZERO ) ; v difference . set Value ( Env . ZERO ) ; }
public void write ( Output Stream out , java . util . List < Figure > figures ) throws IO Exception { Rectangle 2 D . Double drawing Rect = null ; for ( Figure f : figures ) { if ( drawing Rect == null ) { drawing Rect = f . get Bounds ( ) ; } else { drawing Rect . add ( f . get Bounds ( ) ) ; } } Affine Transform tx = new Affine Transform ( ) ; tx . translate ( - Math . min ( NUM , drawing Rect . x ) , - Math . min ( NUM , drawing Rect . y ) ) ; write ( out , figures , tx , new Dimension ( ( int ) ( Math . abs ( drawing Rect . x ) + drawing Rect . width ) , ( int ) ( Math . abs ( drawing Rect . y ) + drawing Rect . height ) ) ) ; }
Fixed Allocator ( final RW Store store , final int size ) { m disk Addr = NUM ; m store = store ; m size = size ; m bit Size = calc Bit Size ( BOOL , size , c Min Allocation , c Mod Allocation ) ; alloc Block Range = NUM * m bit Size ; final int num Blocks = NUM / ( m bit Size + NUM ) ; m alloc Blocks = new Array List < Alloc Block > ( num Blocks ) ; for ( int i = NUM ; i < num Blocks ; i ++ ) { m alloc Blocks . add ( new Alloc Block ( NUM , m bit Size , this ) ) ; } m free Transients = NUM ; m free Bits = NUM * m bit Size * num Blocks ; }
private void build Get Storage Response ( Mock Closeable Http Response response , URI uri ) throws JAXB Exception { Pattern pattern = Pattern . compile ( STRING ) ; Matcher matcher = pattern . matcher ( uri . get Path ( ) ) ; if ( matcher . find ( ) ) { Storage storage = get New Storage ( matcher . group ( NUM ) ) ; response . set Entity ( get Http Entity ( storage ) ) ; } }
public void assert Equals ( String assert ID , String expected , String actual ) { framework . assert Equals ( this , assert ID , expected , actual ) ; }
public boolean on Preference Change ( Preference preference , Object new Value ) { if ( Boolean . parse Boolean ( System Properties . get ( Telephony Properties . PROPERTY INECM MODE ) ) ) { } else { set Airplane Mode On ( ( Boolean ) new Value ) ; } return BOOL ; }
public static int estimate Band Pass Order ( int sample Rate , int pass Band Start , int pass Band End , double pass Band Ripple Db , double stop Band Ripple Db ) { double df = ( double ) Math . abs ( pass Band End - pass Band Start ) / ( double ) sample Rate ; double ddp = ( double ) Math . log 10 ( pass Band Ripple Db ) ; double dds = ( double ) Math . log 10 ( stop Band Ripple Db ) ; double a1 = NUM ; double a2 = NUM ; double a3 = - NUM ; double a4 = NUM ; double a5 = - NUM ; double a6 = - NUM ; double t1 = a1 * ddp * ddp ; double t2 = a2 * ddp ; double t3 = a4 * ddp * ddp ; double t4 = a5 * ddp ; double cinf = dds * ( t1 + t2 + a3 ) + t3 + t4 + a6 ; double ginf = - NUM * ( double ) Math . log 10 ( pass Band Ripple Db / stop Band Ripple Db ) - NUM ; double n = cinf / df + ginf * df + NUM ; return ( int ) Math . ceil ( n ) ; }
static public Object string To Value ( String s ) { if ( s . equals ( STRING ) ) { return s ; } if ( s . equals Ignore Case ( STRING ) ) { return Boolean . TRUE ; } if ( s . equals Ignore Case ( STRING ) ) { return Boolean . FALSE ; } if ( s . equals Ignore Case ( STRING ) ) { return JSON Object . NULL ; } char b = s . char At ( NUM ) ; if ( ( b >= STRING && b <= STRING ) || b == STRING || b == STRING || b == STRING ) { if ( b == STRING && s . length ( ) > NUM && ( s . char At ( NUM ) == STRING || s . char At ( NUM ) == STRING ) ) { try { return new Integer ( Integer . parse Int ( s . substring ( NUM ) , NUM ) ) ; } catch ( Exception ignore ) { } } try { if ( s . index Of ( STRING ) > - NUM || s . index Of ( STRING ) > - NUM || s . index Of ( STRING ) > - NUM ) { return Double . value Of ( s ) ; } else { Long my Long = new Long ( s ) ; if ( my Long . long Value ( ) == my Long . int Value ( ) ) { return new Integer ( my Long . int Value ( ) ) ; } else { return my Long ; } } } catch ( Exception ignore ) { } } return s ; }
public static void write Single Byte ( Output Stream out , int b ) throws IO Exception { byte [ ] buffer = new byte [ NUM ] ; buffer [ NUM ] = ( byte ) ( b & NUM ) ; out . write ( buffer ) ; }
private float [ ] calc Border Values ( ) { float max = Integer . MIN VALUE ; float min = Integer . MAX VALUE ; for ( Chart Set set : chart View . data ) { for ( Chart Entry e : set . get Entries ( ) ) { if ( e . get Value ( ) >= max ) max = e . get Value ( ) ; if ( e . get Value ( ) <= min ) min = e . get Value ( ) ; } } return new float [ ] { min , max } ; }
private void parse Name ( String Tokenizer st , boolean peer ) { List vals = new Array List ( NUM ) ; outer : while ( BOOL ) { String cls ; do { if ( ! st . has More Tokens ( ) ) { break outer ; } cls = st . next Token ( ) ; } while ( cls . equals ( STRING ) ) ; if ( ! peer && cls . equals Ignore Case ( STRING ) ) { parse Name ( st , BOOL ) ; break ; } if ( cls . equals ( STRING ) ) { if ( peer ) { throw new Illegal Argument Exception ( STRING ) ; } cls = null ; vals = null ; } String nm ; do { if ( ! st . has More Tokens ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } nm = st . next Token ( ) ; } while ( nm . equals ( STRING ) ) ; if ( ! nm . starts With ( STRING ) ) { throw new Illegal Argument Exception ( STRING ) ; } while ( ! nm . ends With ( STRING ) ) { if ( ! st . has More Tokens ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } nm = nm + st . next Token ( ) ; } if ( nm . equals ( STRING ) ) { if ( peer ) { throw new Illegal Argument Exception ( STRING ) ; } if ( cls == null ) { continue ; } nm = null ; } else if ( cls == null ) { throw new Illegal Argument Exception ( STRING ) ; } else { nm = nm . substring ( NUM , nm . length ( ) - NUM ) ; } if ( vals != null ) { for ( int i = vals . size ( ) ; i > NUM ; ) { String onm = ( String ) vals . get ( -- i ) ; String ocls = ( String ) vals . get ( -- i ) ; if ( cls . equals ( ocls ) ) { if ( onm == null || ( onm != null && onm . equals ( nm ) ) ) { continue outer ; } else if ( nm == null ) { vals . remove ( i ) ; vals . remove ( i ) ; } } } vals . add ( cls ) ; vals . add ( nm ) ; } } String [ ] res = null ; if ( vals != null ) { if ( vals . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } res = ( String [ ] ) vals . to Array ( new String [ vals . size ( ) ] ) ; } if ( peer ) { this . peer = res ; } else { this . me = res ; } }
public static Object apply Or Call ( boolean is Apply , Context cx , Scriptable scope , Scriptable this Obj , Object [ ] args ) { int L = args . length ; Callable function = get Callable ( this Obj ) ; Scriptable call This = null ; if ( L != NUM ) { call This = to Object Or Null ( cx , args [ NUM ] ) ; } if ( call This == null ) { call This = get Top Call Scope ( cx ) ; } Object [ ] call Args ; if ( is Apply ) { call Args = L <= NUM ? Script Runtime . empty Args : get Apply Arguments ( cx , args [ NUM ] ) ; } else { if ( L <= NUM ) { call Args = Script Runtime . empty Args ; } else { call Args = new Object [ L - NUM ] ; System . arraycopy ( args , NUM , call Args , NUM , L - NUM ) ; } } return function . call ( cx , scope , call This , call Args ) ; }
public void increment ( ) { counter . get And Increment ( ) ; }
public static void remove All Children ( Node node ) { Node List children = node . get Child Nodes ( ) ; for ( int i = NUM , length = children . get Length ( ) ; i < length ; i ++ ) { node . remove Child ( children . item ( i ) ) ; } }
private boolean is Mineshafter Present ( ) { try { Class . for Name ( STRING ) ; return BOOL ; } catch ( Exception e ) { return BOOL ; } }
private boolean link First ( Node < E > node ) { if ( count >= capacity ) return BOOL ; Node < E > f = first ; node . next = f ; first = node ; if ( last == null ) last = node ; else f . prev = node ; ++ count ; not Empty . signal ( ) ; return BOOL ; }
protected void deploy ( Http Servlet Response response , String context Path , String war URL ) throws IO Exception { String context = context Path ; boolean error = BOOL ; if ( context == null ) { File file = new File ( war URL ) ; String file Name = file . get Name ( ) ; if ( file Name . ends With ( STRING ) ) { file Name = file Name . substring ( NUM , file Name . last Index Of ( STRING ) ) ; } context = STRING + file Name ; } if ( get Context Handler ( context ) != null ) { send Error ( response , STRING + context ) ; error = BOOL ; } else if ( ! context . starts With ( STRING ) ) { send Error ( response , STRING ) ; error = BOOL ; } if ( error ) { return ; } else { File webapp Dest = new File ( web App Directory , context + STRING ) ; URI uri = null ; try { uri = new URI ( war URL ) ; } catch ( URI Syntax Exception e ) { send Error ( response , STRING + war URL ) ; Log . warn ( e ) ; return ; } File webapp Source = new File ( uri ) ; File Input Stream file Input Stream = new File Input Stream ( webapp Source ) ; File Output Stream file Output Stream = new File Output Stream ( webapp Dest ) ; int i = file Input Stream . read ( ) ; while ( i != - NUM ) { file Output Stream . write ( i ) ; i = file Input Stream . read ( ) ; } file Input Stream . close ( ) ; file Output Stream . flush ( ) ; file Output Stream . close ( ) ; Web App Context webappcontext = new Web App Context ( ) ; webappcontext . set Context Path ( context ) ; webappcontext . set War ( webapp Dest . get Path ( ) ) ; chc . add Handler ( webappcontext ) ; try { webappcontext . start ( ) ; } catch ( Exception e ) { send Error ( response , STRING ) ; Log . warn ( e ) ; return ; } } send Message ( response , STRING + context Path ) ; }
public Outlier Result run ( Relation < V > relation ) { final DBI Ds ids = relation . get DBI Ds ( ) ; Array List < Array DBI Ds > subspace Index = build One Dim Indexes ( relation ) ; Set < Hi CS Subspace > subspaces = calculate Subspaces ( relation , subspace Index , rnd . get Single Threaded Random ( ) ) ; if ( LOG . is Verbose ( ) ) { LOG . verbose ( STRING + subspaces . size ( ) ) ; } List < Double Relation > results = new Array List < > ( ) ; Finite Progress prog = LOG . is Verbose ( ) ? new Finite Progress ( STRING , subspaces . size ( ) , LOG ) : null ; for ( Hi CS Subspace dimset : subspaces ) { if ( LOG . is Verbose ( ) ) { LOG . verbose ( STRING + dimset ) ; } Proxy Database pdb = new Proxy Database ( ids ) ; pdb . add Relation ( new Projected View < > ( relation , new Numerical Feature Selection < V > ( dimset ) ) ) ; Outlier Result result = outlier Algorithm . run ( pdb ) ; results . add ( result . get Scores ( ) ) ; LOG . increment Processed ( prog ) ; } LOG . ensure Completed ( prog ) ; Writable Double Data Store scores = Data Store Util . make Double Storage ( relation . get DBI Ds ( ) , Data Store Factory . HINT STATIC ) ; Double Min Max minmax = new Double Min Max ( ) ; for ( DBID Iter iditer = relation . iter DBI Ds ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { double sum = NUM ; for ( Double Relation r : results ) { final double s = r . double Value ( iditer ) ; if ( ! Double . is Na N ( s ) ) { sum += s ; } } scores . put Double ( iditer , sum ) ; minmax . put ( sum ) ; } Outlier Score Meta meta = new Basic Outlier Score Meta ( minmax . get Min ( ) , minmax . get Max ( ) ) ; Double Relation scoreres = new Materialized Double Relation ( STRING , STRING , scores , relation . get DBI Ds ( ) ) ; return new Outlier Result ( meta , scoreres ) ; }
private void add Unit To External Qual Map ( final Class < ? extends Annotation > anno Class ) { Annotation Mirror mirror = Units Relations Tools . build Anno Mirror With No Prefix ( processing Env , anno Class ) ; if ( ! is Aliased Annotation ( mirror ) ) { String unit Class Name = anno Class . get Canonical Name ( ) ; if ( ! external Quals Map . contains Key ( unit Class Name ) ) { external Quals Map . put ( unit Class Name , anno Class ) ; } } else { Class < ? extends Annotation > base Unit Class = get Base Unit Anno Class ( mirror ) ; if ( base Unit Class != null ) { String base Unit Class Name = base Unit Class . get Canonical Name ( ) ; if ( ! external Quals Map . contains Key ( base Unit Class Name ) ) { load External Unit ( base Unit Class Name ) ; } aliased Annotation ( mirror ) ; } else { } } add Units Relations ( anno Class ) ; }
@ Override protected void on Progress Update ( Integer ... values ) { if ( parent != null ) { if ( values [ NUM ] == ON CACHE END ) { parent . on Cache End ( ) ; } else if ( values [ NUM ] == ON CACHE INTERRUPTED ) { Log . i ( TAG , STRING ) ; should Be Stopped = BOOL ; parent . on Cache Interrupted ( ) ; } else { parent . on Cache Progress ( task Count , values [ NUM ] ) ; } } }
public void check Number Args ( int arg Num ) throws Wrong Number Args Exception { if ( arg Num < NUM ) report Wrong Number Args ( ) ; }
public double dot Product ( Double Vector v ) { return x * v . x + y * v . y + z * v . z ; }
public Temporal OM Scaling Icon ( Object id , int render Type , boolean interpolate , Image Icon ii ) { this ( id , render Type , interpolate , ii . get Image ( ) , NUM ) ; set Max Scale ( NUM ) ; set Min Scale ( NUM ) ; }
@ Override public void characters ( char [ ] ch , int start , int length ) throws SAX Exception { m String Builder . append ( ch , start , length ) ; }
public int max Length ( ) { if ( m Is Paired ) { return ( int ) Math . max ( m Left . max Length ( ) , m Right . max Length ( ) ) ; } else { return ( int ) m Single . max Length ( ) ; } }
public boolean equals Ignore Case ( Str Builder other ) { if ( this == other ) { return BOOL ; } if ( this . size != other . size ) { return BOOL ; } char this Buf [ ] = this . buffer ; char other Buf [ ] = other . buffer ; for ( int i = size - NUM ; i >= NUM ; i -- ) { char c1 = this Buf [ i ] ; char c2 = other Buf [ i ] ; if ( c1 != c2 && Character . to Upper Case ( c1 ) != Character . to Upper Case ( c2 ) ) { return BOOL ; } } return BOOL ; }
public Path Parser ( String path String ) { this . path String = path String . to Char Array ( ) ; }
public Lua Table ( Varargs varargs , int firstarg ) { int nskip = firstarg - NUM ; int n = Math . max ( varargs . narg ( ) - nskip , NUM ) ; presize ( n , NUM ) ; set ( N , value Of ( n ) ) ; for ( int i = NUM ; i <= n ; i ++ ) set ( i , varargs . arg ( i + nskip ) ) ; }
public ID 3 v 24 Frame ( Byte Buffer byte Buffer , String logging Filename ) throws Invalid Frame Exception , Invalid Data Type Exception { set Logging Filename ( logging Filename ) ; read ( byte Buffer ) ; }
public void disable Pan ( Bluetooth Adapter adapter ) { if ( m Pan == null ) m Pan = ( Bluetooth Pan ) connect Proxy ( adapter , Bluetooth Profile . PAN ) ; assert Not Null ( m Pan ) ; long start = System . current Time Millis ( ) ; m Pan . set Bluetooth Tethering ( BOOL ) ; long stop = System . current Time Millis ( ) ; assert False ( m Pan . is Tethering On ( ) ) ; write Output ( String . format ( STRING , ( stop - start ) ) ) ; }
public Frame < V > init ( final Frame < ? extends V > src ) { return Value = src . return Value ; System . arraycopy ( src . values , NUM , values , NUM , values . length ) ; top = src . top ; return this ; }
public boolean ready ( ) throws IO Exception { if ( input == null ) throw new IO Exception ( STRING ) ; if ( index == input . length ( ) ) return BOOL ; return BOOL ; }
private Linked List < Diff > diff compute ( String text 1 , String text 2 , boolean checklines , long deadline ) { Linked List < Diff > diffs = new Linked List < Diff > ( ) ; if ( text 1 . length ( ) == NUM ) { diffs . add ( new Diff ( Operation . INSERT , text 2 ) ) ; return diffs ; } if ( text 2 . length ( ) == NUM ) { diffs . add ( new Diff ( Operation . DELETE , text 1 ) ) ; return diffs ; } String longtext = text 1 . length ( ) > text 2 . length ( ) ? text 1 : text 2 ; String shorttext = text 1 . length ( ) > text 2 . length ( ) ? text 2 : text 1 ; int i = longtext . index Of ( shorttext ) ; if ( i != - NUM ) { Operation op = ( text 1 . length ( ) > text 2 . length ( ) ) ? Operation . DELETE : Operation . INSERT ; diffs . add ( new Diff ( op , longtext . substring ( NUM , i ) ) ) ; diffs . add ( new Diff ( Operation . EQUAL , shorttext ) ) ; diffs . add ( new Diff ( op , longtext . substring ( i + shorttext . length ( ) ) ) ) ; return diffs ; } if ( shorttext . length ( ) == NUM ) { diffs . add ( new Diff ( Operation . DELETE , text 1 ) ) ; diffs . add ( new Diff ( Operation . INSERT , text 2 ) ) ; return diffs ; } String [ ] hm = diff half Match ( text 1 , text 2 ) ; if ( hm != null ) { String text 1 a = hm [ NUM ] ; String text 1 b = hm [ NUM ] ; String text 2 a = hm [ NUM ] ; String text 2 b = hm [ NUM ] ; String mid common = hm [ NUM ] ; Linked List < Diff > diffs a = diff main ( text 1 a , text 2 a , checklines , deadline ) ; Linked List < Diff > diffs b = diff main ( text 1 b , text 2 b , checklines , deadline ) ; diffs = diffs a ; diffs . add ( new Diff ( Operation . EQUAL , mid common ) ) ; diffs . add All ( diffs b ) ; return diffs ; } if ( checklines && text 1 . length ( ) > NUM && text 2 . length ( ) > NUM ) { return diff line Mode ( text 1 , text 2 , deadline ) ; } return diff bisect ( text 1 , text 2 , deadline ) ; }
public static long size Of Directory ( File directory ) { check Directory ( directory ) ; final File [ ] files = directory . list Files ( ) ; if ( files == null ) { return NUM ; } long size = NUM ; for ( final File file : files ) { try { if ( ! is Symlink ( file ) ) { size += size Of ( file ) ; if ( size < NUM ) { break ; } } } catch ( IO Exception ioe ) { } } return size ; }
protected void handle Match ( T mapping , String lookup Path , Server Web Exchange exchange ) { }
public boolean is Use SSL ( ) { return use SSL ; }
public void start ( ) { if ( ( m Prox Sensor == null ) || m Is Active ) { return ; } m Is Active = BOOL ; m Should Drop Events = BOOL ; m Sensor Manager . register Listener ( m Listener , m Prox Sensor , Sensor Manager . SENSOR DELAY UI ) ; Log Utils . log ( this , Log . VERBOSE , STRING , System . current Time Millis ( ) ) ; m Handler . post Delayed ( m Filter Runnable , REGISTRATION EVENT FILTER TIMEOUT ) ; }
public void test Entity Declarations ( ) { assert Not Null ( STRING , sp ) ; }
private Vector apply CSS ( HTML Element element , HTML Component html C , CSS Element [ ] css , Vector nested Selectors , Vector sibling Selectors ) { String id = element . get Attribute By Id ( HTML Element . ATTR ID ) ; String class Name = element . get Attribute By Id ( HTML Element . ATTR CLASS ) ; Vector next Nested Selectors = new Vector ( ) ; Vector next Sibling Selectors = null ; if ( ! HTML Component . PROCESS HTML MP 1 ONLY ) { next Sibling Selectors = new Vector ( ) ; } for ( int e = NUM ; e < css . length ; e ++ ) { CSS Element current Selector = css [ e ] ; check Selector ( current Selector , element , html C , class Name , id , next Nested Selectors , next Sibling Selectors ) ; } if ( nested Selectors != null ) { for ( Enumeration e = nested Selectors . elements ( ) ; e . has More Elements ( ) ; ) { CSS Element current Selector = ( CSS Element ) e . next Element ( ) ; check Selector ( current Selector , element , html C , class Name , id , next Nested Selectors , next Sibling Selectors ) ; } } if ( ( ! HTML Component . PROCESS HTML MP 1 ONLY ) && ( sibling Selectors != null ) ) { for ( Enumeration e = sibling Selectors . elements ( ) ; e . has More Elements ( ) ; ) { CSS Element current Selector = ( CSS Element ) e . next Element ( ) ; check Selector ( current Selector , element , html C , class Name , id , next Nested Selectors , next Sibling Selectors ) ; } } if ( next Nested Selectors . size ( ) == NUM ) { next Nested Selectors = null ; } if ( ( ! HTML Component . PROCESS HTML MP 1 ONLY ) && ( next Sibling Selectors . size ( ) == NUM ) ) { next Sibling Selectors = null ; } apply Style Attribute ( element , html C ) ; Vector cur Sibling Selectors = null ; for ( int i = NUM ; i < element . get Num Children ( ) ; i ++ ) { HTML Element child = ( HTML Element ) element . get Child At ( i ) ; Vector v = apply CSS ( child , html C , css , next Nested Selectors , cur Sibling Selectors ) ; if ( ! child . is Text Element ( ) ) { cur Sibling Selectors = v ; } } return next Sibling Selectors ; }
@ Nullable private Tcp Discovery Node resolve Coordinator ( @ Nullable Collection < Tcp Discovery Node > filter ) { synchronized ( mux ) { Collection < Tcp Discovery Node > excluded = F . concat ( BOOL , failed Nodes . key Set ( ) , leaving Nodes ) ; if ( ! F . is Empty ( filter ) ) excluded = F . concat ( BOOL , excluded , filter ) ; return ring . coordinator ( excluded ) ; } }
public static String [ ] splitc ( String src , String d ) { if ( ( d . length ( ) == NUM ) || ( src . length ( ) == NUM ) ) { return new String [ ] { src } ; } return splitc ( src , d . to Char Array ( ) ) ; }
public int deflate String 2 Byte Array ( byte [ ] input , int input Offset , int input Length , byte [ ] bytes ) { if ( input Length >= MIN SIZE FOR DEFLATION ) { deflater . set Input ( input , input Offset , input Length ) ; deflater . finish ( ) ; int compressed Data Length = deflater . deflate ( bytes ) ; deflater . reset ( ) ; return - compressed Data Length ; } else { System . arraycopy ( input , input Offset , bytes , NUM , input Length ) ; return input Length ; } }
private void double Capacity ( ) { int p = head ; int n = elements . length ; int r = n - p ; int new Capacity = n << NUM ; if ( new Capacity < NUM ) throw new Illegal State Exception ( STRING ) ; Object [ ] a = new Object [ new Capacity ] ; System . arraycopy ( elements , p , a , NUM , r ) ; System . arraycopy ( elements , NUM , a , r , p ) ; elements = a ; head = NUM ; tail = n ; }
public Marker back To ( int idx ) throws AM Console Exception { int size = trail . size ( ) ; if ( idx >= size ) { throw new AM Console Exception ( STRING ) ; } for ( int i = size - NUM ; i > idx ; -- i ) { trail . remove ( i ) ; } return ( Marker ) trail . get ( idx ) ; }
private static long copy ( Input Stream source , Output Stream sink ) throws IO Exception { long nread = NUM ; byte [ ] buf = new byte [ BUFFER SIZE ] ; int n ; while ( ( n = source . read ( buf ) ) > NUM ) { sink . write ( buf , NUM , n ) ; nread += n ; } return nread ; }
public byte [ ] pack ( ) { if ( entries . size ( ) == NUM ) return null ; int entry Length = owner . get Type ( ) . NODES ENTRY LENGTH ; byte [ ] buffer = new byte [ entries . size ( ) * entry Length ] ; int max items = buffer . length / NUM ; int j = NUM ; for ( K Bucket Entry e : entries ) { if ( j >= max items ) { break ; } Pack Util . Pack Bucket Entry ( e , buffer , j * entry Length , owner . get Type ( ) ) ; j ++ ; } return buffer ; }
public String to String ( ) { String Buffer sb = new String Buffer ( STRING ) ; for ( int i = NUM ; i < permissions . length ; i ++ ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( permissions [ i ] ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public void test Invalid After Close ( ) throws IO Exception { Path temp Path = create Temp Dir ( ) ; Directory dir = get Directory ( temp Path ) ; Lock l = dir . obtain Lock ( STRING ) ; l . close ( ) ; expect Throws ( Already Closed Exception . class , null ) ; dir . close ( ) ; }
public static Gds Type Rule excludes ( String ... excluded Types ) { final Set < String > excluded Types Set = new Hash Set < > ( Arrays . as List ( excluded Types ) ) ; return new Gds Type Rule ( not ( is In ( excluded Types Set ) ) ) ; }
public final Set < String > aliases ( ) { if ( alias Set != null ) return alias Set ; int n = aliases . length ; Hash Set < String > hs = new Hash Set < String > ( n ) ; for ( int i = NUM ; i < n ; i ++ ) hs . add ( aliases [ i ] ) ; alias Set = Collections . unmodifiable Set ( hs ) ; return alias Set ; }
public synchronized void unweave ( Byte String id ) { if ( woven . contains Key ( id ) ) { removed . add ( woven . remove ( id ) ) ; } }
private static Map < String , Virtual File > find Siblings ( @ Nullable Virtual File directory , Project project , Set < Virtual File > seen ) { if ( directory == null ) { return Collections . empty Map ( ) ; } else { if ( seen . contains ( directory ) ) { return find Siblings ( null , project , seen ) ; } seen . add ( directory ) ; Virtual File settings = directory . find Child ( Sdk Constants . FN SETTINGS GRADLE ) ; if ( settings == null ) { return find Siblings ( directory . get Parent ( ) , project , seen ) ; } else { return Gradle Module Importer . get Sub Projects ( settings , project ) ; } } }
public Authority Key Identifier Structure ( X509 Certificate certificate ) throws Certificate Parsing Exception { super ( from Certificate ( certificate ) ) ; }
@ Override public int hash Code ( ) { return Arrays . hash Code ( new Immutable Pair [ ] { ( Immutable Pair ) first , ( Immutable Pair ) second } ) ; }
private static char [ ] zz Unpack C Map ( String packed ) { char [ ] map = new char [ NUM ] ; int i = NUM ; int j = NUM ; while ( i < NUM ) { int count = packed . char At ( i ++ ) ; char value = packed . char At ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM ) ; } return map ; }
@ Suppress Lint ( STRING ) public static String replace Unicode Digits ( String number ) { String Builder normalized Digits = new String Builder ( number . length ( ) ) ; for ( char c : number . to Char Array ( ) ) { int digit = Character . digit ( c , NUM ) ; if ( digit != - NUM ) { normalized Digits . append ( digit ) ; } else { normalized Digits . append ( c ) ; } } return normalized Digits . to String ( ) ; }
public String Frie Name ( String value ) { if ( value == null || value . length ( ) == NUM ) return STRING ; String ret Value = value ; String SQL = STRING ; try { Prepared Statement pstmt = DB . prepare Statement ( SQL , null ) ; pstmt . set String ( NUM , value ) ; Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) ret Value = rs . get String ( NUM ) ; rs . close ( ) ; pstmt . close ( ) ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , SQL , e ) ; } return ret Value ; }
public static boolean is Compressed ( File file ) { Input Stream fis = null ; try { if ( file . exists ( ) ) { fis = new File Input Stream ( file ) ; int mag 1 = fis . read ( ) ; int mag 2 = fis . read ( ) ; fis . close ( ) ; return select Compression Provider ( mag 1 , mag 2 ) != null ; } } catch ( IO Exception e ) { LOG . log ( Level . FINEST , STRING + file + STRING , e ) ; return BOOL ; } finally { Safe Close . close ( fis ) ; } return BOOL ; }
@ Override public int read Int ( String file Path ) { File Channel file Channel = update Cache ( file Path ) ; Byte Buffer byte Bffer = read ( file Channel , Carbon Common Constants . INT SIZE IN BYTE ) ; return byte Bffer . get Int ( ) ; }
private synchronized void close Output Stream Quietly ( ) { if ( ! m Closed ) { try { m Output Stream . close ( ) ; report Decoded Size If Applicable ( ) ; } catch ( IO Exception e ) { C Log . write To Console ( m Network Peer Manager , Console . Message Level . ERROR , Console . Message Source . NETWORK , STRING + e ) ; } finally { m Closed = BOOL ; } } }
public void bind ( String address , Service Ref Amp link Service ) { link Service Map . put ( address , link Service ) ; service Close List . add ( link Service ) ; }
public boolean might Have Multi Font Metrics ( ) { return font Config != null ; }
private static boolean check Offset ( String value , int offset , char expected ) { return ( offset < value . length ( ) ) && ( value . char At ( offset ) == expected ) ; }
void add Split ( String split Path ) { String [ ] splits = split Path . split ( STRING ) ; for ( String split : splits ) { split = split . trim ( ) ; if ( split . starts With ( STRING ) ) throw new Runtime Exception ( STRING + split ) ; if ( split . length ( ) == NUM ) continue ; add Field ( split , split , BOOL , BOOL ) ; } }
public void to Lat Lon ( double v0 , double h0 ) { final double GX = NUM ; final double GY = - NUM ; final double A = NUM ; final double Q = - NUM ; final double Q2 = NUM ; final double EPSILON = NUM ; double v = ( double ) v0 ; double h = ( double ) h0 ; double t1 = ( v - TRANSV ) / RADIUS ; double t2 = ( h - TRANSH ) / RADIUS ; double vhat = ROTC * t2 - ROTS * t1 ; double hhat = ROTS * t2 + ROTC * t1 ; double e = Math . cos ( Math . sqrt ( vhat * vhat + hhat * hhat ) ) ; double w = Math . cos ( Math . sqrt ( vhat * vhat + ( hhat - NUM ) * ( hhat - NUM ) ) ) ; double fx = EY * w - WY * e ; double fy = EX * w - WX * e ; double b = fx * GX + fy * GY ; double c = fx * fx + fy * fy - Q2 ; double disc = b * b - A * c ; double x , y , z , delta ; if ( Math . abs ( disc ) < EPSILON ) { z = b / A ; x = ( GX * z - fx ) / Q ; y = ( fy - GY * z ) / Q ; } else { delta = Math . sqrt ( disc ) ; z = ( b + delta ) / A ; x = ( GX * z - fx ) / Q ; y = ( fy - GY * z ) / Q ; if ( vhat * ( PX * x + PY * y + PZ * z ) < NUM ) { z = ( b - delta ) / A ; x = ( GX * z - fx ) / Q ; y = ( fy - GY * z ) / Q ; } } double lat = Math . asin ( z ) ; final double [ ] bi = { NUM , - NUM , NUM , - NUM , NUM , - NUM , NUM } ; double lat 2 = lat * lat ; double earthlat = lat * ( bi [ NUM ] + lat 2 * ( bi [ NUM ] + lat 2 * ( bi [ NUM ] + lat 2 * ( bi [ NUM ] + lat 2 * ( bi [ NUM ] + lat 2 * ( bi [ NUM ] + lat 2 * ( bi [ NUM ] ) ) ) ) ) ) ) ; earthlat = Math . to Degrees ( earthlat ) ; double lon = Math . to Degrees ( Math . atan 2 ( x , y ) ) ; double earthlon = lon + NUM ; this . result Lat = earthlat ; this . result Lon = - earthlon ; }
public void sort Array ( T [ ] d , Comparator < T > c ) { this . data = d ; this . comp = c ; int len = Math . max ( ( int ) ( NUM * Math . log ( d . length ) ) , TEMP SIZE ) ; len = Math . min ( d . length , len ) ; @ Suppress Warnings ( STRING ) T [ ] t = ( T [ ] ) new Object [ len ] ; this . temp = t ; merge Sort ( NUM , d . length - NUM ) ; }
public static void close Quietly ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( Runtime Exception rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
public void cache Unit ( Unit Interface unit ) { all Units . add ( unit ) ; }
public Component find By Name ( String name , Component root Component ) { Component c = ( Component ) root Component . get Client Property ( STRING + name + STRING ) ; if ( c == null ) { Container new Root = get Root Ancestor ( root Component ) ; if ( new Root != null && root Component != new Root ) { return find By Name ( name , new Root ) ; } } return c ; }
protected void fetch Metadata ( ) throws IO Exception { remaining = period ; int size = in . read ( ) ; if ( size < NUM ) return ; size <<= NUM ; if ( mbuffer . length < size ) { mbuffer = null ; mbuffer = new byte [ size ] ; Log . d ( LOG , STRING + size + STRING ) ; } size = read Fully ( mbuffer , NUM , size ) ; for ( int i = NUM ; i < size ; i ++ ) { if ( mbuffer [ i ] == NUM ) { size = i ; break ; } } String s ; try { s = new String ( mbuffer , NUM , size , character Encoding ) ; } catch ( Exception e ) { Log . e ( LOG , STRING ) ; return ; } Log . d ( LOG , STRING + s ) ; parse Metadata ( s ) ; }
public void start Element ( ) { nss . push Context ( ) ; in Collecting Mode = BOOL ; }
private V replace Node ( Object key , V value , Object cv ) { int hash = hash ( ( K ) key ) ; for ( Node < K , V > [ ] tab = table ; ; ) { Node < K , V > f ; int n , i , fh ; if ( tab == null || ( n = tab . length ) == NUM || ( f = tab At ( tab , i = ( n - NUM ) & hash ) ) == null ) { break ; } else if ( ( fh = f . hash ) == MOVED ) { tab = help Transfer ( tab , f ) ; } else { V old Val = null ; boolean validated = BOOL ; synchronized ( f ) { if ( tab At ( tab , i ) == f ) { if ( fh >= NUM ) { validated = BOOL ; for ( Node < K , V > e = f , pred = null ; ; ) { if ( e . hash == hash && is Equal ( ( K ) key , e . key ) ) { V ev = e . val ; if ( cv == null || cv == ev || ( ev != null && cv . equals ( ev ) ) ) { old Val = ev ; if ( value != null ) { e . val = value ; } else if ( pred != null ) { pred . next = e . next ; } else { set Tab At ( tab , i , e . next ) ; } } break ; } pred = e ; if ( ( e = e . next ) == null ) { break ; } } } else if ( f instanceof Tree Bin ) { validated = BOOL ; Tree Bin < K , V > t = ( Tree Bin < K , V > ) f ; Tree Node < K , V > r , p ; if ( ( r = t . root ) != null && ( p = r . find Tree Node ( hash , key , null ) ) != null ) { V pv = p . val ; if ( cv == null || cv == pv || ( pv != null && cv . equals ( pv ) ) ) { old Val = pv ; if ( value != null ) { p . val = value ; } else if ( t . remove Tree Node ( p ) ) { set Tab At ( tab , i , untreeify ( t . first ) ) ; } } } } } } if ( validated ) { if ( old Val != null ) { if ( value == null ) { add Count ( - NUM , - NUM ) ; } return old Val ; } break ; } } } return null ; }
public final void remove Helper Text ( @ Non Null final Char Sequence helper Text ) { ensure Not Null ( helper Text , STRING ) ; ensure Not Empty ( helper Text , STRING ) ; helper Texts . remove ( helper Text ) ; verify Password Strength ( ) ; }
public final synchronized int max PV ( ) { if ( computer Player == null ) return NUM ; return computer Player . get Max PV ( ) ; }
private void display Simple ( Print Stream output ) { output . println ( STRING ) ; for ( int j = NUM ; j < P ; j ++ ) { double [ ] a0 = new double [ N ] ; double [ ] a1 = new double [ N ] ; double [ ] a2 = new double [ N ] ; for ( int i = NUM ; i < N ; i ++ ) { a0 [ i ] = A [ i ] ; a1 [ i ] = C A [ i ] [ j ] ; a2 [ i ] = B [ i ] ; } double value = compute First Order ( a0 , a1 , a2 , N ) ; output . print ( value < NUM ? NUM : value ) ; if ( j < P - NUM ) { output . print ( STRING ) ; } } output . println ( ) ; output . println ( STRING ) ; for ( int j = NUM ; j < P ; j ++ ) { double [ ] a0 = new double [ N ] ; double [ ] a1 = new double [ N ] ; double [ ] a2 = new double [ N ] ; for ( int i = NUM ; i < N ; i ++ ) { a0 [ i ] = A [ i ] ; a1 [ i ] = C A [ i ] [ j ] ; a2 [ i ] = B [ i ] ; } double value = compute Total Order ( a0 , a1 , a2 , N ) ; output . print ( value < NUM ? NUM : value ) ; if ( j < P - NUM ) { output . print ( STRING ) ; } } output . println ( ) ; }
public Object remove ( int index ) { Range Check ( index ) ; mod Count ++ ; Object old Value = element Data [ index ] ; int num Moved = size - index - NUM ; if ( num Moved > NUM ) System . arraycopy ( element Data , index + NUM , element Data , index , num Moved ) ; element Data [ -- size ] = null ; return old Value ; }
public String read Matching Flags ( String text ) { clear ( ) ; if ( text . starts With ( PM SEPARATOR ) ) { final String Tokenizer tok = new String Tokenizer ( text , PM SEPARATOR ) ; while ( tok . has More Tokens ( ) ) { final String flag = tok . next Token ( ) ; if ( flag . equals ( PM TYPE MATCH ) ) { type Matching = BOOL ; } else if ( flag . equals ( PM EXACT MATCH ) ) { exact Matching = BOOL ; } else if ( flag . equals ( PM SIMILAR MATCH ) ) { similar Matching = BOOL ; } else if ( flag . equals ( PM ICASE MATCH ) ) { case Insensitive = BOOL ; } else if ( flag . equals ( PM JOKER MATCH ) ) { joker Matching = BOOL ; } else { break ; } text = text . substring ( flag . length ( ) + NUM ) ; } if ( is Any Flag Set ( ) ) { text = text . substring ( NUM ) ; } } return text ; }
private Tiny Planet Image create Final Tiny Planet ( ) { m Result Lock . lock ( ) ; try { m Result Bitmap . recycle ( ) ; m Result Bitmap = null ; m Source Bitmap . recycle ( ) ; m Source Bitmap = null ; } finally { m Result Lock . unlock ( ) ; } Bitmap source Bitmap = create Padded Source Image ( m Source Image Uri , BOOL ) ; int width = source Bitmap . get Width ( ) ; int height = source Bitmap . get Height ( ) ; int output Size = width / NUM ; Bitmap result Bitmap = Bitmap . create Bitmap ( output Size , output Size , Bitmap . Config . ARGB 8888 ) ; Tiny Planet Native . process ( source Bitmap , width , height , result Bitmap , output Size , m Current Zoom , m Current Angle ) ; source Bitmap . recycle ( ) ; source Bitmap = null ; Byte Array Output Stream jpeg = new Byte Array Output Stream ( ) ; result Bitmap . compress ( Compress Format . JPEG , NUM , jpeg ) ; return new Tiny Planet Image ( add Exif ( jpeg . to Byte Array ( ) ) , output Size ) ; }
private static int New Float Array ( JNI Environment env , int length ) { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { float [ ] new Array = new float [ length ] ; return env . push JNI Ref ( new Array ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
static int create Shader ( String resource , int type ) throws IO Exception { return create Shader ( resource , type , null ) ; }
public Model validate Node Against Shape ( Dataset dataset , URI shapes Graph URI , Node focus Node , Node shape , Resource min Severity , Predicate < SH Constraint > constraint Filter , Function < RDF Node , String > label Function , Progress Monitor monitor ) { Model results = Jena Util . create Memory Model ( ) ; Model old Results = get Current Results Model ( ) ; set Current Results Model ( results ) ; add Resource Violations ( dataset , shapes Graph URI , focus Node , shape , SHACL Util . get All Constraint Properties ( BOOL ) , min Severity , constraint Filter , results , label Function , monitor ) ; set Current Results Model ( old Results ) ; return results ; }
@ Override public Volatile Image create Back Buffer ( W Component Peer peer ) { Component target = ( Component ) peer . get Target ( ) ; return new Sun Volatile Image ( target , target . get Width ( ) , target . get Height ( ) , Boolean . TRUE ) ; }
public void test single Resource Locking high Concurrency 100 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . set Property ( Test Options . NTHREADS , STRING ) ; properties . set Property ( Test Options . NTASKS , STRING ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; do Comparison Test ( properties ) ; }
public void push ( final double value ) { long bits = Double . double To Long Bits ( value ) ; if ( bits == NUM || bits == NUM ) { mv . visit Insn ( Opcodes . DCONST 0 + ( int ) value ) ; } else { mv . visit Ldc Insn ( value ) ; } }
protected abstract void assign Resource Requests ( ) ;
public synchronized void add ( int position , Abstract Option option ) { Abstract Option search = get By Name ( option . get Name ( ) ) ; if ( search != null ) { LOG . warn ( STRING ) ; } else { List < Abstract Option > old Options = new Array List < Abstract Option > ( options ) ; options . add ( position , option ) ; option . set Collection ( this ) ; List < Abstract Option > new Options = get Options ( ) ; fire Indexed Property Change ( PROP OPTIONS , position , old Options , new Options ) ; } }
public boolean write Header ( Output Stream os ) { try { write Int ( os , CACHE MAGIC ) ; write String ( os , key ) ; write String ( os , etag == null ? STRING : etag ) ; write Long ( os , server Date ) ; write Long ( os , last Modified ) ; write Long ( os , ttl ) ; write Long ( os , soft Ttl ) ; write String String Map ( response Headers , os ) ; os . flush ( ) ; return BOOL ; } catch ( IO Exception e ) { Volley Log . d ( STRING , e . to String ( ) ) ; return BOOL ; } }
public boolean visiting Method ( ) { return visiting Method ; }
protected Byte Array Output Stream parse Bytes ( Byte Array Output Stream bos ) throws IO Exception { int ch ; for ( ch = read ( ) ; ch >= NUM && ch != STRING ; ch = read ( ) ) { int b1 = ch ; int b2 = read ( ) ; int b3 = read ( ) ; int b4 = read ( ) ; if ( b4 != STRING ) { int chunk = ( ( base 64 Decode [ b1 ] << NUM ) + ( base 64 Decode [ b2 ] << NUM ) + ( base 64 Decode [ b3 ] << NUM ) + ( base 64 Decode [ b4 ] ) ) ; bos . write ( chunk > > NUM ) ; bos . write ( chunk > > NUM ) ; bos . write ( chunk ) ; } else if ( b3 != STRING ) { int chunk = ( ( base 64 Decode [ b1 ] << NUM ) + ( base 64 Decode [ b2 ] << NUM ) + ( base 64 Decode [ b3 ] ) ) ; bos . write ( chunk > > NUM ) ; bos . write ( chunk ) ; } else { int chunk = ( ( base 64 Decode [ b1 ] << NUM ) + ( base 64 Decode [ b2 ] ) ) ; bos . write ( chunk ) ; } } if ( ch == STRING ) peek = ch ; return bos ; }
private void write Attribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( xml Writer . get Prefix ( namespace ) == null ) { xml Writer . write Namespace ( prefix , namespace ) ; xml Writer . set Prefix ( prefix , namespace ) ; } xml Writer . write Attribute ( namespace , att Name , att Value ) ; }
public static void start Upload Activity For Result ( Activity activity , Account account , int request Code ) { Intent action = new Intent ( activity , Upload Files Activity . class ) ; action . put Extra ( EXTRA ACCOUNT , ( account ) ) ; activity . start Activity For Result ( action , request Code ) ; }
public void add Generic Attr ( Generic Attr g ) { generic . add Element ( g ) ; }
public void stop Trace Session ( int trace Session Id ) throws SQL Exception { try ( Fb Service service = attach Service Manager ( ) ) { service . start Service Action ( get Trace SPB ( service , isc action svc trace stop , trace Session Id ) ) ; queue Service ( service ) ; } catch ( IO Exception ioe ) { throw new SQL Exception ( ioe ) ; } }
String read Substring ( String source , int ofs ) { return read Substring ( source , ofs , source . length ( ) ) ; }
private synchronized boolean expunge Stale Entries ( ) { if ( this . size == NUM ) return BOOL ; Object r ; boolean result = BOOL ; while ( ( r = queue . poll ( ) ) != null ) { result = BOOL ; Single Entry e = ( Single Entry ) r ; this . size -= e . cleanup Pk Table ( this . table ) ; this . non Dated Entry Count -= e . cleanup Semi Unique Table ( this . non Dated Table ) ; } return result ; }
public void remove Listener ( Abstract Serial Transport Listener listener ) { if ( listener != null ) { listeners . remove ( listener ) ; } }
private String restore NBT Tags ( String str , Array List < String > nbttags ) { int nbtidx = NUM ; for ( String capture : nbttags ) { str = str . replace ( STRING + nbtidx ++ , capture ) ; } return str ; }
private void draw Offsets ( final Graphics g ) { if ( is Enabled ( ) ) { g . set Color ( m font Color Offsets ) ; } else { g . set Color ( m disabled Color != m bg Color Offset ? m disabled Color : Color . WHITE ) ; } final int x = ( - m first Column * m char Width ) + NUM ; final int bytes To Draw = get Maximum Visible Bytes ( ) ; final String format String = m address Mode == Address Mode . BIT 32 ? STRING : STRING ; for ( int i = NUM ; i < bytes To Draw ; i += m bytes Per Row ) { final long address = m base Address + ( m first Row * m bytes Per Row ) + i ; final String offset String = String . format ( format String , address ) ; final int current Row = i / m bytes Per Row ; g . draw String ( offset String , x , m padding Top + ( current Row * m row Height ) ) ; } }
@ Override public void write External ( Object Output out ) throws IO Exception { super . write External ( out ) ; out . write Double ( knn Distance ) ; }
public void touch ( Date date ) { last Seen = ( Date ) date . clone ( ) ; }
public void test Polyline ( ) throws Exception { Esri Layer layer = new Esri Layer ( STRING , SHAPE TYPE POLYLINE , NUM ) ; Dbf Table Model model = layer . get Model ( ) ; model . set Decimal Count ( NUM , ( byte ) NUM ) ; model . set Length ( NUM , ( byte ) NUM ) ; model . set Column Name ( NUM , STRING ) ; model . set Type ( NUM , ( byte ) Dbf Table Model . TYPE CHARACTER ) ; model . set Decimal Count ( NUM , ( byte ) NUM ) ; model . set Length ( NUM , ( byte ) NUM ) ; model . set Column Name ( NUM , STRING ) ; model . set Type ( NUM , ( byte ) Dbf Table Model . TYPE NUMERIC ) ; add Polyline Record 1 ( layer ) ; add Polyline Record 2 ( layer ) ; add Polyline Record 3 ( layer ) ; Esri Graphic List list = layer . get Esri Graphic List ( ) ; Shp Output Stream pos = new Shp Output Stream ( new File Output Stream ( STRING ) ) ; int [ ] [ ] index Data = pos . write Geometry ( list ) ; Shx Output Stream xos = new Shx Output Stream ( new File Output Stream ( STRING ) ) ; xos . write Index ( index Data , list . get Type ( ) , list . get Extents ( ) ) ; Dbf Output Stream dos = new Dbf Output Stream ( new File Output Stream ( STRING ) ) ; dos . write Model ( model ) ; }
public static int random ( int i , int j ) { return i + ( int ) ( Math . random ( ) * ( j - i ) ) ; }
public void remove ( String name ) { feature Map . remove ( name ) ; }
private List < Column Model > find Columns To Add ( ) { List < Column Model > columns To Add = new Array List < Column Model > ( ) ; for ( Column Model column Model : m Table Model . get Column Models ( ) ) { String column Name = column Model . get Column Name ( ) ; if ( ! m Table Model DB . contains Column ( column Name ) ) { columns To Add . add ( column Model ) ; } } return columns To Add ; }
@ Override public Loader < Cursor > on Create Loader ( int id , Bundle args ) { Uri uri = Fm Radio Station . Station . CONTENT URI ; String select = Fm Radio Station . Station . COLUMN STATION TYPE + STRING ; String order = Fm Radio Station . Station . COLUMN STATION TYPE + STRING + Fm Radio Station . Station . COLUMN STATION FREQ ; Cursor Loader cursor Loader = new Cursor Loader ( this , uri , Fm Radio Station . COLUMNS , select , new String [ ] { String . value Of ( Fm Radio Station . STATION TYPE FAVORITE ) , String . value Of ( Fm Radio Station . STATION TYPE SEARCHED ) } , order ) ; return cursor Loader ; }
protected Map < String , Object > convert Named List To Map ( Named List < ? > args ) { Map < String , Object > args Map = new Linked Hash Map < > ( ) ; if ( args != null ) { for ( Map . Entry < String , ? > entry : args ) { args Map . put ( entry . get Key ( ) , entry . get Value ( ) ) ; } } return args Map ; }
@ Override public boolean equals ( final Object other ) { if ( this == other ) { return BOOL ; } else if ( other == null ) { return BOOL ; } else if ( other instanceof Expression Matcher ) { final Expression Matcher o = ( Expression Matcher ) other ; if ( type Matching != o . type Matching ) { return BOOL ; } else if ( exact Matching != o . exact Matching ) { return BOOL ; } else if ( similar Matching != o . similar Matching ) { return BOOL ; } else if ( case Insensitive != o . case Insensitive ) { return BOOL ; } else { return ( joker Matching == o . joker Matching ) ; } } else { return BOOL ; } }
public boolean has Capabilities ( List < String > capabilities ) { String [ ] arr = new String [ capabilities . size ( ) ] ; capabilities . to Array ( arr ) ; return has Capabilities ( arr ) ; }
private static double euclidean Norm ( double vector [ ] ) { int n = vector . length ; if ( n < NUM ) { return NUM ; } if ( n == NUM ) { return Math . abs ( vector [ NUM ] ) ; } double scale = NUM ; double sum = NUM ; for ( int i = NUM ; i < n ; i ++ ) { if ( vector [ i ] != NUM ) { double abs = Math . abs ( vector [ i ] ) ; if ( scale < abs ) { double t = scale / abs ; sum = NUM + sum * ( t * t ) ; scale = abs ; } else { double t = abs / scale ; sum += t * t ; } } } return scale * Math . sqrt ( sum ) ; }
public static void assign Buckets To Partitions ( Region < ? , ? > region ) { Partitioned Region pr = is Partitioned Check ( region ) ; Recovery Lock lock = null ; try { lock = pr . get Recovery Lock ( ) ; lock . lock ( ) ; for ( int i = NUM ; i < get Number Of Buckets ( pr ) ; i ++ ) { pr . create Bucket ( i , NUM , null ) ; } } finally { if ( lock != null ) { lock . unlock ( ) ; } } }
public synchronized void add Listener ( Listener l ) { listeners . add ( l ) ; }
public boolean ends With ( final String str ) { if ( str == null ) { return BOOL ; } final int len = str . length ( ) ; if ( len == NUM ) { return BOOL ; } if ( len > size ) { return BOOL ; } int pos = size - len ; for ( int i = NUM ; i < len ; i ++ , pos ++ ) { if ( buffer [ pos ] != str . char At ( i ) ) { return BOOL ; } } return BOOL ; }
public boolean find ( int start ) { if ( start < NUM || start > input . length ( ) ) { throw new Index Out Of Bounds Exception ( STRING + start + STRING + input . length ( ) ) ; } synchronized ( this ) { match Found = find Impl ( address , input , start , match Offsets ) ; } return match Found ; }
public void apply Pattern ( String pattern ) { this . pattern = pattern ; if ( pattern Tokens != null ) { pattern Tokens . clear ( ) ; pattern Tokens = null ; } }
public int number Of Replies ( final Resource comment ) { final Iterator < Resource > children = comment . list Children ( ) ; int size = NUM ; while ( children . has Next ( ) ) { children . next ( ) ; size ++ ; } return size ; }
public static < T > String to String ( Tree Def < T > tree Def , T root , Function < ? super T , String > to String , String indent ) { String Builder builder = new String Builder ( ) ; builder . append ( to String . apply ( root ) ) ; builder . append ( STRING ) ; to String Helper ( tree Def , root , to String , indent , builder , indent ) ; return builder . to String ( ) ; }
public void clean Up Remote Sessions ( ) { synchronized ( remote Session Set ) { for ( Iterator iter = remote Session Set . iterator ( ) ; iter . has Next ( ) ; ) { Session ID session ID = ( Session ID ) iter . next ( ) ; String host Server = null ; try { host Server = get Current Host Server ( session ID ) ; } catch ( Exception ex ) { } if ( ! server Config . is Local Server ( host Server ) ) { iter . remove ( ) ; } } } }
public boolean column Exists Case Sensitive ( Database Meta Data db Meta Data , String table Name , String column Name ) throws SQL Exception { Result Set rs Tables = db Meta Data . get Columns ( null , null , table Name , column Name ) ; try { return rs Tables . next ( ) ; } finally { close JDBC Result Set ( rs Tables ) ; } }
public void action Performed ( Action Event e ) { Caret c = text Area . get Caret ( ) ; if ( c . get Dot ( ) != c . get Mark ( ) ) { return ; } R Syntax Document doc = ( R Syntax Document ) text Area . get Document ( ) ; doc . read Lock ( ) ; try { remove Highlights ( ) ; int line = text Area . get Caret Line Number ( ) ; Token token List = text Area . get Token List For Line ( line ) ; int dot = c . get Dot ( ) ; Token t = R Syntax Utilities . get Token At Offset ( token List , dot ) ; if ( t == null || ! is Valid Type ( t ) || is Non Word Char ( t ) ) { dot -- ; try { if ( dot >= text Area . get Line Start Offset ( line ) ) { t = R Syntax Utilities . get Token At Offset ( token List , dot ) ; } } catch ( Bad Location Exception ble ) { ble . print Stack Trace ( ) ; } } if ( t != null && is Valid Type ( t ) && ! is Non Word Char ( t ) ) { R Syntax Text Area Highlighter h = ( R Syntax Text Area Highlighter ) text Area . get Highlighter ( ) ; String lexeme = t . get Lexeme ( ) ; int type = t . type ; for ( int i = NUM ; i < text Area . get Line Count ( ) ; i ++ ) { Token temp = text Area . get Token List For Line ( i ) ; while ( temp != null && temp . is Paintable ( ) ) { if ( temp . is ( type , lexeme ) ) { try { int end = temp . offset + temp . text Count ; Object tag = h . add Marked Occurrence Highlight ( temp . offset , end , p ) ; tags . add ( tag ) ; } catch ( Bad Location Exception ble ) { ble . print Stack Trace ( ) ; } } temp = temp . get Next Token ( ) ; } } } } finally { doc . read Unlock ( ) ; } text Area . fire Marked Occurrences Changed ( ) ; }
public int read ( ) throws IO Exception { if ( ! buf . has Remaining ( ) ) { return - NUM ; } return buf . get ( ) & NUM ; }
public void characters Raw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAX Exception { if ( is Outside Doc Elem ( ) && XML Character Recognizer . is White Space ( ch , start , length ) ) return ; String s = new String ( ch , start , length ) ; append ( m doc . create Processing Instruction ( STRING , STRING ) ) ; append ( m doc . create Text Node ( s ) ) ; }
private void handle Release ( ) { float speed = Math . max ( drag Helper . get Drag Speed ( ) , animation Speed ) ; if ( get Top Margin ( ) > initial Margin || ( drag Helper . get Drag Speed ( ) > animation Speed && drag Helper . get Distance ( ) > NUM ) || ( get Device Type ( get Context ( ) ) == Device Type . TABLET && is Maximized ( ) && get Top Margin ( ) > min Margin ) ) { animate Hide View ( parent Height - get Top Margin ( ) , speed , new Decelerate Interpolator ( ) , BOOL ) ; } else { animate Show View ( - ( get Top Margin ( ) - min Margin ) , speed , new Decelerate Interpolator ( ) ) ; } }
private String normalize Type Value ( String type ) { if ( INSERT . equals ( type ) ) return INSERT ; if ( REMOVE . equals ( type ) ) return REMOVE ; return null ; }
@ Override public Log Seq Num write To Log ( ) { List < Constant > rec = build Record ( ) ; return log Mgr . append ( rec . to Array ( new Constant [ rec . size ( ) ] ) ) ; }
public static double gaussian ( ) { double r , x , y ; do { x = uniform ( - NUM , NUM ) ; y = uniform ( - NUM , NUM ) ; r = x * x + y * y ; } while ( r >= NUM || r == NUM ) ; return x * Math . sqrt ( - NUM * Math . log ( r ) / r ) ; }
public void done With Parameters ( ) { if ( info . parameter Count == VAR ARGS ) { int len = var Args . size ( ) ; check Parameter Count ( len ) ; args = new Expression [ len ] ; var Args . to Array ( args ) ; var Args = null ; } else { int len = args . length ; if ( len > NUM && args [ len - NUM ] == null ) { throw Db Exception . get ( Error Code . INVALID PARAMETER COUNT 2 , info . name , STRING + len ) ; } } }
public void remove All X 509 Certificates ( ) { x509 Certificates . clear ( ) ; }
public void update Current State ( String what Happened ) { Undo Event undo Event = create Undo Event For Current State ( what Happened ) ; if ( undo Event != null && undo Stack != null ) { undo Stack . set The Way Things Are ( undo Event ) ; } }
@ Override protected void on Size Changed ( int w , int h , int oldw , int oldh ) { super . on Size Changed ( w , h , oldw , oldh ) ; setup Bounds ( w , h ) ; setup Paints ( ) ; invalidate ( ) ; }
protected void extend Element ( Element e ) { }
public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
public DTM Axis Iterator clone Iterator ( ) { is Restartable = BOOL ; try { final Preceding Iterator clone = ( Preceding Iterator ) super . clone ( ) ; final int [ ] stack Copy = new int [ stack . length ] ; System . arraycopy ( stack , NUM , stack Copy , NUM , stack . length ) ; clone . stack = stack Copy ; return clone ; } catch ( Clone Not Supported Exception e ) { throw new DTM Exception ( XML Messages . create XML Message ( XML Error Resources . ER ITERATOR CLONE NOT SUPPORTED , null ) ) ; } }
private String read Response From Server ( Http URL Connection url Connection ) throws Request Failure Exception { try { Input Stream Reader reader = new Input Stream Reader ( url Connection . get Input Stream ( ) ) ; Buffered Reader in = new Buffered Reader ( reader ) ; try { String Builder response = new String Builder ( ) ; for ( String line = in . read Line ( ) ; line != null ; line = in . read Line ( ) ) { response . append ( line ) ; } check Server Response Code ( url Connection ) ; return response . to String ( ) ; } finally { in . close ( ) ; } } catch ( IO Exception e ) { throw new Request Failure Exception ( STRING , e ) ; } }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( name == null ) { throw new Null Pointer Exception ( ) ; } if ( node Type == null ) { throw new Null Pointer Exception ( ) ; } }
public int contains ( Value Store Base vsb ) { final Vector values = vsb . f Values ; final int size 1 = values . size ( ) ; if ( f Field Count <= NUM ) { for ( int i = NUM ; i < size 1 ; ++ i ) { short val = vsb . get Value Type At ( i ) ; if ( ! value Type Contains ( val ) || ! f Values . contains ( values . element At ( i ) ) ) { return i ; } else if ( val == XS Constants . LIST DT || val == XS Constants . LISTOFUNION DT ) { Short List list 1 = vsb . get Item Value Type At ( i ) ; if ( ! item Value Type Contains ( list 1 ) ) { return i ; } } } } else { final int size 2 = f Values . size ( ) ; OUTER : for ( int i = NUM ; i < size 1 ; i += f Field Count ) { INNER : for ( int j = NUM ; j < size 2 ; j += f Field Count ) { for ( int k = NUM ; k < f Field Count ; ++ k ) { final Object value 1 = values . element At ( i + k ) ; final Object value 2 = f Values . element At ( j + k ) ; final short value Type 1 = vsb . get Value Type At ( i + k ) ; final short value Type 2 = get Value Type At ( j + k ) ; if ( value 1 != value 2 && ( value Type 1 != value Type 2 || value 1 == null || ! value 1 . equals ( value 2 ) ) ) { continue INNER ; } else if ( value Type 1 == XS Constants . LIST DT || value Type 1 == XS Constants . LISTOFUNION DT ) { Short List list 1 = vsb . get Item Value Type At ( i + k ) ; Short List list 2 = get Item Value Type At ( j + k ) ; if ( list 1 == null || list 2 == null || ! list 1 . equals ( list 2 ) ) { continue INNER ; } } } continue OUTER ; } return i ; } } return - NUM ; }
public boolean is Supported Option ( String name ) { boolean is Supported = BOOL ; for ( Iterator i = mandatory Options . iterator ( ) ; i . has Next ( ) && ! is Supported ; ) { String opt = ( String ) i . next ( ) ; is Supported = opt . equals ( name ) ; } for ( Iterator i = optional Options . iterator ( ) ; i . has Next ( ) && ! is Supported ; ) { String opt = ( String ) i . next ( ) ; is Supported = opt . equals ( name ) ; } return is Supported ; }
private boolean are All Node Ended ( ) { if ( protocol != null && protocol . has Protocol ( ) ) { final Collection < Protocol Node > protocol Nodes = protocol Node Participant Map . values ( ) ; if ( protocol Nodes . is Empty ( ) ) { return BOOL ; } for ( final Protocol Node node : protocol Nodes ) { if ( ! ( node != null && node . is Terminal ( ) ) ) { return BOOL ; } } return BOOL ; } final Collection < FIPA Message > final Msgs = no Protocol Node Participant Map . values ( ) ; if ( final Msgs . is Empty ( ) ) { return BOOL ; } for ( final FIPA Message final Msg : final Msgs ) { if ( final Msg . get Performative ( ) != FIPA Constants . Performatives . END CONVERSATION ) { return BOOL ; } } return BOOL ; }
public String Builder encode Body ( String Builder retval ) { return retval . append ( option Tag ) ; }
public void add Literal Result Attribute ( AVT avt ) { if ( null == m avts ) m avts = new Array List ( ) ; m avts . add ( avt ) ; }
protected void move Selection To First Position ( ) { if ( selection Table . get Selection Count ( ) == NUM ) { return ; } int index = NUM ; for ( final Table Item table Item : selection Table . get Selection ( ) ) { final DL Item item = ( DL Item ) table Item . get Data ( ) ; selection . remove ( item ) ; selection . add ( index ++ , item ) ; } redraw Tables ( ) ; selection Table . select ( NUM , index - NUM ) ; selection Table . force Focus ( ) ; }
private void items Array To Combined Buffer ( T [ ] items Array ) { final int extra = NUM ; min Value = items Array [ NUM ] ; max Value = items Array [ NUM ] ; System . arraycopy ( items Array , extra , combined Buffer , NUM , base Buffer Count ) ; long bits = bit Pattern ; if ( bits > NUM ) { int index = extra + base Buffer Count ; for ( int level = NUM ; bits != NUM ; level ++ , bits >>>= NUM ) { if ( ( bits & NUM ) > NUM ) { System . arraycopy ( items Array , index , combined Buffer , ( NUM + level ) * k , k ) ; index += k ; } } } }
public SQL Query ( Class < T > type , String sql Expression , Query Result Type query Result Type , Object ... parameters ) { this ( sql Expression , type . get Name ( ) , null , query Result Type , parameters ) ; }
public void bob ( Mowzie Model Renderer box , float speed , float degree , boolean bounce , float f , float f1 ) { float bob = ( float ) ( Math . sin ( f * speed ) * f1 * degree - f1 * degree ) ; if ( bounce ) bob = ( float ) - Math . abs ( ( Math . sin ( f * speed ) * f1 * degree ) ) ; box . rotation Point Y += bob ; }
private static void reject Unsupported Options ( Properties p ) throws SQL Feature Not Supported Exception { if ( p . contains Key ( Data Source Factory . JDBC ROLE NAME ) ) { throw new SQL Feature Not Supported Exception ( STRING + Data Source Factory . JDBC ROLE NAME + STRING ) ; } if ( p . contains Key ( Data Source Factory . JDBC DATASOURCE NAME ) ) { throw new SQL Feature Not Supported Exception ( STRING + Data Source Factory . JDBC DATASOURCE NAME + STRING ) ; } }
public IO Utils ( ) { super ( ) ; }
private int read Annotation Value ( int v , final char [ ] buf , final String name , final Annotation Visitor av ) { int i ; if ( av == null ) { switch ( b [ v ] & NUM ) { case STRING : return v + NUM ; case STRING : return read Annotation Values ( v + NUM , buf , BOOL , null ) ; case STRING : return read Annotation Values ( v + NUM , buf , BOOL , null ) ; default : return v + NUM ; } } switch ( b [ v ++ ] & NUM ) { case STRING : case STRING : case STRING : case STRING : av . visit ( name , read Const ( read Unsigned Short ( v ) , buf ) ) ; v += NUM ; break ; case STRING : av . visit ( name , ( byte ) read Int ( items [ read Unsigned Short ( v ) ] ) ) ; v += NUM ; break ; case STRING : av . visit ( name , read Int ( items [ read Unsigned Short ( v ) ] ) == NUM ? Boolean . FALSE : Boolean . TRUE ) ; v += NUM ; break ; case STRING : av . visit ( name , ( short ) read Int ( items [ read Unsigned Short ( v ) ] ) ) ; v += NUM ; break ; case STRING : av . visit ( name , ( char ) read Int ( items [ read Unsigned Short ( v ) ] ) ) ; v += NUM ; break ; case STRING : av . visit ( name , read UTF 8 ( v , buf ) ) ; v += NUM ; break ; case STRING : av . visit Enum ( name , read UTF 8 ( v , buf ) , read UTF 8 ( v + NUM , buf ) ) ; v += NUM ; break ; case STRING : av . visit ( name , Type . get Type ( read UTF 8 ( v , buf ) ) ) ; v += NUM ; break ; case STRING : v = read Annotation Values ( v + NUM , buf , BOOL , av . visit Annotation ( name , read UTF 8 ( v , buf ) ) ) ; break ; case STRING : int size = read Unsigned Short ( v ) ; v += NUM ; if ( size == NUM ) { return read Annotation Values ( v - NUM , buf , BOOL , av . visit Array ( name ) ) ; } switch ( this . b [ v ++ ] & NUM ) { case STRING : byte [ ] bv = new byte [ size ] ; for ( i = NUM ; i < size ; i ++ ) { bv [ i ] = ( byte ) read Int ( items [ read Unsigned Short ( v ) ] ) ; v += NUM ; } av . visit ( name , bv ) ; -- v ; break ; case STRING : boolean [ ] zv = new boolean [ size ] ; for ( i = NUM ; i < size ; i ++ ) { zv [ i ] = read Int ( items [ read Unsigned Short ( v ) ] ) != NUM ; v += NUM ; } av . visit ( name , zv ) ; -- v ; break ; case STRING : short [ ] sv = new short [ size ] ; for ( i = NUM ; i < size ; i ++ ) { sv [ i ] = ( short ) read Int ( items [ read Unsigned Short ( v ) ] ) ; v += NUM ; } av . visit ( name , sv ) ; -- v ; break ; case STRING : char [ ] cv = new char [ size ] ; for ( i = NUM ; i < size ; i ++ ) { cv [ i ] = ( char ) read Int ( items [ read Unsigned Short ( v ) ] ) ; v += NUM ; } av . visit ( name , cv ) ; -- v ; break ; case STRING : int [ ] iv = new int [ size ] ; for ( i = NUM ; i < size ; i ++ ) { iv [ i ] = read Int ( items [ read Unsigned Short ( v ) ] ) ; v += NUM ; } av . visit ( name , iv ) ; -- v ; break ; case STRING : long [ ] lv = new long [ size ] ; for ( i = NUM ; i < size ; i ++ ) { lv [ i ] = read Long ( items [ read Unsigned Short ( v ) ] ) ; v += NUM ; } av . visit ( name , lv ) ; -- v ; break ; case STRING : float [ ] fv = new float [ size ] ; for ( i = NUM ; i < size ; i ++ ) { fv [ i ] = Float . int Bits To Float ( read Int ( items [ read Unsigned Short ( v ) ] ) ) ; v += NUM ; } av . visit ( name , fv ) ; -- v ; break ; case STRING : double [ ] dv = new double [ size ] ; for ( i = NUM ; i < size ; i ++ ) { dv [ i ] = Double . long Bits To Double ( read Long ( items [ read Unsigned Short ( v ) ] ) ) ; v += NUM ; } av . visit ( name , dv ) ; -- v ; break ; default : v = read Annotation Values ( v - NUM , buf , BOOL , av . visit Array ( name ) ) ; } } return v ; }
private void decrement Worker Count ( ) { do { } while ( ! compare And Decrement Worker Count ( ctl . get ( ) ) ) ; }
public static float build Float ( int mant , int exp ) { if ( exp < - NUM || mant == NUM ) { return NUM ; } if ( exp >= NUM ) { return ( mant > NUM ) ? Float . POSITIVE INFINITY : Float . NEGATIVE INFINITY ; } if ( exp == NUM ) { return mant ; } if ( mant >= ( NUM << NUM ) ) { mant ++ ; } return ( float ) ( ( exp > NUM ) ? mant * pow 10 [ exp ] : mant / pow 10 [ - exp ] ) ; }
public void clear Values ( ) { m Data Sets . clear ( ) ; notify Data Changed ( ) ; }
public boolean has Mode Support ( ) { return is Available ( ) && m Capabilities . intersects ( m All Modes ) ; }
public void run Test ( ) throws Throwable { Document doc ; Node List gender List ; Node gender Node ; Entity Reference ent Ref ; Element ent Element ; Character Data ent Element Text ; int node Type ; doc = ( Document ) load ( STRING , BOOL ) ; gender List = doc . get Elements By Tag Name ( STRING ) ; gender Node = gender List . item ( NUM ) ; ent Ref = ( Entity Reference ) gender Node . get First Child ( ) ; assert Not Null ( STRING , ent Ref ) ; node Type = ( int ) ent Ref . get Node Type ( ) ; if ( equals ( NUM , node Type ) ) { ent Ref = doc . create Entity Reference ( STRING ) ; assert Not Null ( STRING , ent Ref ) ; } ent Element = ( Element ) ent Ref . get First Child ( ) ; assert Not Null ( STRING , ent Element ) ; ent Element Text = ( Character Data ) ent Element . get First Child ( ) ; assert Not Null ( STRING , ent Element Text ) ; { boolean success = BOOL ; try { ent Element Text . set Node Value ( STRING ) ; } catch ( DOM Exception ex ) { success = ( ex . code == DOM Exception . NO MODIFICATION ALLOWED ERR ) ; } assert True ( STRING , success ) ; } }
public void test Constr String With Exponent With Point 2 ( ) { String a = STRING ; int a Scale = NUM ; Big Integer bA = new Big Integer ( STRING ) ; Big Decimal a Number = new Big Decimal ( a ) ; assert Equals ( STRING , bA , a Number . unscaled Value ( ) ) ; assert Equals ( STRING , a Scale , a Number . scale ( ) ) ; }
public static void update Item In Database ( Context context , final Item Info item ) { final Content Values values = new Content Values ( ) ; item . on Add To Database ( context , values ) ; update Item In Database Helper ( context , values , item , STRING ) ; }
@ Override public String graph ( ) throws Exception { String Buffer text = new String Buffer ( ) ; text . append ( STRING ) ; m cobweb Tree . graph Tree ( text ) ; text . append ( STRING ) ; return text . to String ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = enum To Vector ( super . list Options ( ) ) ; result . add Element ( new Option ( STRING + default Num Attributes ( ) + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
public synchronized Reference < ? extends T > remove ( long timeout Millis ) throws Interrupted Exception { if ( timeout Millis < NUM ) { throw new Illegal Argument Exception ( STRING + timeout Millis ) ; } if ( head != null ) { return poll ( ) ; } if ( timeout Millis == NUM || ( timeout Millis > Long . MAX VALUE / NANOS PER MILLI ) ) { do { wait ( NUM ) ; } while ( head == null ) ; return poll ( ) ; } long nanos To Wait = timeout Millis * NANOS PER MILLI ; int timeout Nanos = NUM ; long start Time = System . nano Time ( ) ; while ( BOOL ) { wait ( timeout Millis , timeout Nanos ) ; if ( head != null ) { break ; } long nanos Elapsed = System . nano Time ( ) - start Time ; long nanos Remaining = nanos To Wait - nanos Elapsed ; if ( nanos Remaining <= NUM ) { break ; } timeout Millis = nanos Remaining / NANOS PER MILLI ; timeout Nanos = ( int ) ( nanos Remaining - timeout Millis * NANOS PER MILLI ) ; } return poll ( ) ; }
public Path Impl lookup Impl ( String user Path , Map < String , Object > new Attributes , boolean is Allow Root ) { if ( user Path == null ) { return lookup Impl ( get Path ( ) , new Attributes , is Allow Root ) ; } if ( ! is Allow Root ) { return scheme Walk ( user Path , new Attributes , user Path , NUM ) ; } String scheme = scan Scheme ( user Path ) ; if ( scheme == null ) { return scheme Walk ( user Path , new Attributes , user Path , NUM ) ; } Path Impl path ; Scheme Map scheme Map = scheme Map ; if ( is Windows ( ) ) { int length = scheme . length ( ) ; char ch ; if ( length == NUM && ( STRING <= ( ch = scheme . char At ( NUM ) ) && ch <= STRING || STRING <= ch && ch <= STRING ) ) { user Path = Character . to Lower Case ( ch ) + user Path . substring ( NUM ) ; if ( is Test Windows ) return scheme Walk ( user Path , new Attributes , STRING + user Path , NUM ) ; path = scheme Map . get ( STRING ) ; if ( path != null ) return path . scheme Walk ( user Path , new Attributes , STRING + user Path , NUM ) ; else return scheme Walk ( user Path , new Attributes , STRING + user Path , NUM ) ; } } path = scheme Map . get ( scheme ) ; if ( path == null ) { return scheme Walk ( user Path , new Attributes , user Path , NUM ) ; } else { return path . scheme Walk ( user Path , new Attributes , user Path , scheme . length ( ) + NUM ) ; } }
public void add Color ( int color ) { if ( m Colors == null ) m Colors = new Array List < Integer > ( ) ; m Colors . add ( color ) ; }
static Integer read Rule ID ( final Substring Reader reader ) throws Decode Exception { int length = NUM ; reader . skip Whitespaces ( ) ; reader . mark ( ) ; try { while ( reader . read ( ) != STRING ) { length ++ ; } if ( length == NUM ) { throw Decode Exception . error ( ERR ATTR SYNTAX RULE ID NO VALUE 1 . get ( reader . pos ( ) - NUM ) ) ; } reader . reset ( ) ; final String rule ID = reader . read ( length ) ; try { return Integer . value Of ( rule ID ) ; } catch ( final Number Format Exception e ) { throw Decode Exception . error ( ERR ATTR SYNTAX RULE ID INVALID 1 . get ( rule ID ) ) ; } } catch ( final String Index Out Of Bounds Exception e ) { throw Decode Exception . error ( ERR ATTR SYNTAX TRUNCATED VALUE 1 . get ( ) ) ; } }
public void remove Index ( I Index index ) { if ( index != null ) { indices . remove ( index ) ; } }
private Attribute Action Set process Attribute Section ( Mode Usage mode Usage , String ns , Int Set index Set , Attributes attributes ) throws SAX Exception { Mode mode = mode Usage . get Mode ( current Section . context ) ; Attribute Action Set actions = mode . get Attribute Actions ( ns ) ; if ( actions . get Reject ( ) && ! attribute Namespace Rejected ) { attribute Namespace Rejected = BOOL ; if ( eh != null ) eh . error ( new SAX Parse Exception ( localizer . message ( STRING , ns ) , locator ) ) ; } Schema [ ] schemas = actions . get Schemas ( ) ; for ( int j = NUM ; j < schemas . length ; j ++ ) { if ( attribute Schemas . contains ( schemas [ j ] ) ) continue ; attribute Schemas . add ( schemas [ j ] ) ; if ( filtered Attributes == null ) filtered Attributes = filter Attributes ( index Set , attributes ) ; validate Attributes ( schemas [ j ] , filtered Attributes ) ; } return actions ; }
public void initialize ( Context context , Haptic Feedback Controller haptic Feedback Controller , int initial Hours Of Day , int initial Minutes , boolean is 24 Hour Mode ) { if ( m Time Initialized ) { Log . e ( TAG , STRING ) ; return ; } m Haptic Feedback Controller = haptic Feedback Controller ; m Is 24 Hour Mode = is 24 Hour Mode ; m Hide Am Pm = m Accessibility Manager . is Touch Exploration Enabled ( ) ? BOOL : m Is 24 Hour Mode ; m Circle View . initialize ( context , m Hide Am Pm ) ; m Circle View . invalidate ( ) ; if ( ! m Hide Am Pm ) { m Am Pm Circles View . initialize ( context , initial Hours Of Day < NUM ? AM : PM ) ; m Am Pm Circles View . invalidate ( ) ; } Resources res = context . get Resources ( ) ; int [ ] hours = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int [ ] hours 24 = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int [ ] minutes = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; String [ ] hours Texts = new String [ NUM ] ; String [ ] inner Hours Texts = new String [ NUM ] ; String [ ] minutes Texts = new String [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { hours Texts [ i ] = is 24 Hour Mode ? String . format ( STRING , hours 24 [ i ] ) : String . format ( STRING , hours [ i ] ) ; inner Hours Texts [ i ] = String . format ( STRING , hours [ i ] ) ; minutes Texts [ i ] = String . format ( STRING , minutes [ i ] ) ; } m Hour Radial Texts View . initialize ( res , hours Texts , ( is 24 Hour Mode ? inner Hours Texts : null ) , m Hide Am Pm , BOOL ) ; m Hour Radial Texts View . invalidate ( ) ; m Minute Radial Texts View . initialize ( res , minutes Texts , null , m Hide Am Pm , BOOL ) ; m Minute Radial Texts View . invalidate ( ) ; set Value For Item ( HOUR INDEX , initial Hours Of Day ) ; set Value For Item ( MINUTE INDEX , initial Minutes ) ; int hour Degrees = ( initial Hours Of Day % NUM ) * HOUR VALUE TO DEGREES STEP SIZE ; m Hour Radial Selector View . initialize ( context , m Hide Am Pm , is 24 Hour Mode , BOOL , hour Degrees , is Hour Inner Circle ( initial Hours Of Day ) ) ; int minute Degrees = initial Minutes * MINUTE VALUE TO DEGREES STEP SIZE ; m Minute Radial Selector View . initialize ( context , m Hide Am Pm , BOOL , BOOL , minute Degrees , BOOL ) ; m Time Initialized = BOOL ; }
@ Override public double conf ( double total Weight , double delta ) { return inverse Normal ( NUM - delta / NUM ) / ( NUM * Math . sqrt ( total Weight ) ) ; }
@ Override public final int read Unsigned Byte ( ) throws IO Exception { return dis . read Unsigned Byte ( ) ; }
public synchronized static void ensure Security Manager ( @ Suppress Warnings ( STRING ) String [ ] args ) { Security Policy Loader . load ( System Boot . class , STRING ) ; System . set Security Manager ( new RMI Security Manager ( ) ) ; }
@ Override public Object clone ( ) throws Clone Not Supported Exception { return super . clone ( ) ; }
public String ridge Tip Text ( ) { return STRING ; }
public void update Enable State Swing Items ( ) { if ( Swing Utilities . is Event Dispatch Thread ( ) ) super . update Enable State ( ) ; }
public void reset ( ) { System . arraycopy ( IV , NUM , cbc V , NUM , IV . length ) ; Arrays . fill ( cbc Next V , ( byte ) NUM ) ; cipher . reset ( ) ; }
protected final boolean load To Have At Least ( int min Available ) throws IO Exception { if ( input Stream == null ) { return BOOL ; } int amount = input End - input Ptr ; if ( amount > NUM && input Ptr > NUM ) { curr Input Processed += input Ptr ; System . arraycopy ( input Buffer , input Ptr , input Buffer , NUM , amount ) ; input End = amount ; } else { input End = NUM ; } input Ptr = NUM ; while ( input End < min Available ) { int count = input Stream . read ( input Buffer , input End , input Buffer . length - input End ) ; if ( count < NUM ) { close Input ( ) ; if ( count == NUM ) { throw new IO Exception ( STRING + amount + STRING ) ; } return BOOL ; } input End += count ; } return BOOL ; }
public Data Type Parser register ( int jdbc Type , String grammar ) { Objects . require Non Null ( grammar , STRING ) ; Data Type Pattern pattern = parser . parse ( jdbc Type , grammar ) ; pattern . for Each First Token ( null ) ; return this ; }
public void close ( ) throws Generic Data Source Exception { if ( manual TX ) { if ( Debug . verbose On ( ) ) Debug . log Verbose ( STRING + manual TX , module ) ; commit ( ) ; } sql = null ; if ( rs != null ) { try { rs . close ( ) ; if ( Debug . verbose On ( ) ) Debug . log Verbose ( STRING + manual TX , module ) ; } catch ( SQL Exception sqle ) { Debug . log Warning ( sqle . get Message ( ) , module ) ; } rs = null ; } if ( ps != null ) { try { ps . close ( ) ; if ( Debug . verbose On ( ) ) Debug . log Verbose ( STRING + manual TX , module ) ; } catch ( SQL Exception sqle ) { Debug . log Warning ( sqle . get Message ( ) , module ) ; } ps = null ; } if ( ( connection != null ) && b Delete Connection ) { try { connection . close ( ) ; if ( Debug . verbose On ( ) ) Debug . log Verbose ( STRING + manual TX , module ) ; } catch ( SQL Exception sqle ) { Debug . log Warning ( sqle . get Message ( ) , module ) ; } connection = null ; } }
private Default Mutable Tree Node copy ( Tree Node node ) { return new Default Mutable Tree Node ( node ) ; }
public static void agentmain ( String args , Instrumentation inst ) throws Exception { logger . info ( STRING ) ; check Transformer State ( ) ; inst . add Transformer ( transformer , BOOL ) ; instrumentation = inst ; }
public byte [ ] data ( ) { Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; try { to Data ( bos ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } return bos . to Byte Array ( ) ; }
@ Safe Varargs public static < T > Reactive Seq < T > of ( final T ... elements ) { final Reversing Array Spliterator < T > array = new Reversing Array Spliterator < T > ( elements , BOOL , NUM ) ; return Stream Utils . reactive Seq ( Stream Support . stream ( array , BOOL ) , Optional . of Nullable ( array ) ) ; }
private void decode Ltp ( Long Term Prediction ltp , int max Sfb ) { ltp . lag = br . read ( NUM ) ; ltp . coef = ltp coef [ br . read ( NUM ) ] ; for ( int sfb = NUM ; sfb < Math . min ( max Sfb , MAX LTP LONG SFB ) ; sfb ++ ) { ltp . used [ sfb ] = br . read Bool ( ) ; } }
public static < T > List < T > instantiate All ( String [ ] classes , Class Loader class Loader ) { List < T > clazzes = new Array List < T > ( ) ; for ( String clazz : classes ) { if ( String Utils . has Length ( clazz ) ) { try { clazzes . add ( Class Utils . < T > instantiate ( clazz , class Loader ) ) ; } catch ( Exception e ) { throw new Cassandra Migration Exception ( STRING + clazz , e ) ; } } } return clazzes ; }
static void clear Instance Cache ( ) { synchronized ( INSTANCE CACHE ) { INSTANCE CACHE . clear ( ) ; } }
public static < E extends Enum < E > & Bitmapable Enum > Enum Set < E > to Enum Set ( Class < E > type , int bitmap ) { if ( type == null ) throw new Null Pointer Exception ( STRING ) ; Enum Set < E > s = Enum Set . none Of ( type ) ; int all Set Bitmap = NUM ; for ( E element : type . get Enum Constants ( ) ) { if ( Integer . bit Count ( element . get Value ( ) ) != NUM ) { String msg = String . format ( STRING + STRING + STRING , element . to String ( ) , element . get Value ( ) , type . get Name ( ) ) ; throw new Illegal Argument Exception ( msg ) ; } all Set Bitmap |= element . get Value ( ) ; if ( ( bitmap & element . get Value ( ) ) != NUM ) s . add ( element ) ; } if ( ( ( ~ all Set Bitmap ) & bitmap ) != NUM ) { String msg = String . format ( STRING + STRING , bitmap , type . get Name ( ) ) ; throw new Illegal Argument Exception ( msg ) ; } return s ; }
public Undirected Graph Node clone Graph B ( Undirected Graph Node node ) { Map < Integer , Undirected Graph Node > map = new Hash Map < > ( ) ; return dfs ( node , map ) ; }
public synchronized void notify Session Borrowed ( ) { if ( LOGGER . is Trace Enabled ( ) ) LOGGER . log Trace ( this + STRING ) ; current Context = new Transaction Context ( resource , xa Resource ) ; all Contexts . add ( current Context ) ; closed = BOOL ; }
@ Override public synchronized void close ( ) throws SQL Exception { try { debug Code Call ( STRING ) ; if ( session == null ) { return ; } Close Watcher . unregister ( watcher ) ; session . cancel ( ) ; if ( executing Statement != null ) { try { executing Statement . cancel ( ) ; } catch ( Null Pointer Exception e ) { } } synchronized ( session ) { try { if ( ! session . is Closed ( ) ) { try { if ( session . has Pending Transaction ( ) ) { if ( ! session . is Reconnect Needed ( BOOL ) ) { try { rollback Internal ( ) ; } catch ( Db Exception e ) { if ( e . get Error Code ( ) != Error Code . CONNECTION BROKEN 1 ) { throw e ; } } } session . after Writing ( ) ; } close Prepared Commands ( ) ; } finally { session . close ( ) ; } } } finally { session = null ; } } } catch ( Exception e ) { throw log And Convert ( e ) ; } }
public void test Plus Math Context Negative ( ) { String a = STRING ; int a Scale = NUM ; int precision = NUM ; Rounding Mode rm = Rounding Mode . CEILING ; Math Context mc = new Math Context ( precision , rm ) ; String c = STRING ; int c Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal res = a Number . plus ( mc ) ; assert Equals ( STRING , c , res . to String ( ) ) ; assert Equals ( STRING , c Scale , res . scale ( ) ) ; }
public static WKT Geometry create Empty ( WKT Type wkt Type ) { WKT Geometry wkt Geometry = new WKT Geometry ( ) ; wkt Geometry . set Geometry Type ( wkt Type ) ; return wkt Geometry ; }
public Peer Lookup Task create Peer Lookup ( byte [ ] info hash ) { if ( ! is Running ( ) ) { return null ; } Key id = new Key ( info hash ) ; RPC Server srv = server Manager . get Random Active Server ( BOOL ) ; if ( srv == null ) return null ; Peer Lookup Task lookup Task = new Peer Lookup Task ( srv , node , id ) ; return lookup Task ; }
public void add Child ( Node ... nodes ) { for ( Node node : nodes ) { node . detach From Parent ( ) ; node . parent Node = this ; init Child Nodes ( node ) ; child Nodes . add ( node ) ; } reindex Children On Add ( nodes . length ) ; }
public static void write String ASCII ( Byte Buf stream , String str ) throws Unsupported Encoding Exception { final byte [ ] bytes = str . get Bytes ( STRING ) ; stream . write Int ( str . length ( ) ) ; stream . write Bytes ( bytes ) ; }
private void need New Buffer ( int newcount ) { if ( current Buffer Index < buffers . size ( ) - NUM ) { filled Buffer Sum += current Buffer . length ; current Buffer Index ++ ; current Buffer = buffers . get ( current Buffer Index ) ; } else { int new Buffer Size ; if ( current Buffer == null ) { new Buffer Size = newcount ; filled Buffer Sum = NUM ; } else { new Buffer Size = Math . max ( current Buffer . length << NUM , newcount - filled Buffer Sum ) ; filled Buffer Sum += current Buffer . length ; } current Buffer Index ++ ; current Buffer = new byte [ new Buffer Size ] ; buffers . add ( current Buffer ) ; } }
public void test Write 3 ( ) throws Exception { byte [ ] data = new byte [ ] { - NUM , - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM } ; Test Output Stream tos = new Test Output Stream ( ) ; Cipher Output Stream cos = new Cipher Output Stream ( tos , new Null Cipher ( ) ) ; for ( int i = NUM ; i < data . length ; i ++ ) { cos . write ( data , i , NUM ) ; } cos . flush ( ) ; byte [ ] result = tos . to Byte Array ( ) ; if ( ! Arrays . equals ( result , data ) ) { fail ( STRING ) ; } }
public void add Listener ( Update Manager Listener listener ) { listeners . add ( listener ) ; }
@ Override public void on Detach ( ) { synchronized ( m Thread ) { m Progress Bar = null ; m Ready = BOOL ; m Thread . notify ( ) ; } super . on Detach ( ) ; }
public void output Source ( int module , int line , String s ) { String Builder sb = new String Builder ( ) ; append Source ( sb , module , line , s , BOOL ) ; out ( sb . to String ( ) ) ; }
Sorted Map < String , String > properties ( ) ;
public static String suppress White Space ( String str ) { int len = str . length ( ) ; String Builder sb = new String Builder ( len ) ; char c ; char buffer = NUM ; for ( int i = NUM ; i < len ; i ++ ) { c = str . char At ( i ) ; if ( c == STRING || c == STRING ) buffer = STRING ; else if ( is White Space ( c ) ) { if ( buffer == NUM ) buffer = c ; } else { if ( buffer != NUM ) { sb . append ( buffer ) ; buffer = NUM ; } sb . append ( c ) ; } } if ( buffer != NUM ) sb . append ( buffer ) ; return sb . to String ( ) ; }
private Node < K , V > find Predecessor ( Comparable < ? super K > key ) { if ( key == null ) throw new Null Pointer Exception ( ) ; for ( ; ; ) { Index < K , V > q = head ; Index < K , V > r = q . right ; for ( ; ; ) { if ( r != null ) { Node < K , V > n = r . node ; K k = n . key ; if ( n . value == null ) { if ( ! q . unlink ( r ) ) break ; r = q . right ; continue ; } if ( key . compare To ( k ) > NUM ) { q = r ; r = r . right ; continue ; } } Index < K , V > d = q . down ; if ( d != null ) { q = d ; r = d . right ; } else return q . node ; } } }
public static String read Fully ( Reader reader ) throws IO Exception { try { String Writer writer = new String Writer ( ) ; char [ ] buffer = new char [ NUM ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM ) { writer . write ( buffer , NUM , count ) ; } return writer . to String ( ) ; } finally { reader . close ( ) ; } }
protected Connection State SS Lv 3 ( SSL Session Impl session ) { try { Cipher Suite cipher Suite = session . cipher Suite ; boolean is exportabe = cipher Suite . is Exportable ( ) ; hash size = cipher Suite . get MAC Length ( ) ; int key size = ( is exportabe ) ? cipher Suite . key Material : cipher Suite . expanded Key Material ; int iv size = cipher Suite . iv Size ; block size = cipher Suite . get Block Size ( ) ; String alg Name = cipher Suite . get Bulk Encryption Algorithm ( ) ; String hash Name = cipher Suite . get Hash Name ( ) ; if ( logger != null ) { logger . println ( STRING ) ; logger . println ( STRING + session . get Cipher Suite ( ) ) ; logger . println ( STRING + alg Name ) ; logger . println ( STRING + hash Name ) ; logger . println ( STRING + hash size ) ; logger . println ( STRING + block size ) ; logger . println ( STRING + iv size ) ; logger . println ( STRING + key size ) ; } byte [ ] client Random = session . client Random ; byte [ ] server Random = session . server Random ; byte [ ] key block = new byte [ NUM * hash size + NUM * key size + NUM * iv size ] ; byte [ ] seed = new byte [ client Random . length + server Random . length ] ; System . arraycopy ( server Random , NUM , seed , NUM , server Random . length ) ; System . arraycopy ( client Random , NUM , seed , server Random . length , client Random . length ) ; PRF . compute PRF SS Lv 3 ( key block , session . master secret , seed ) ; byte [ ] client mac secret = new byte [ hash size ] ; byte [ ] server mac secret = new byte [ hash size ] ; byte [ ] client key = new byte [ key size ] ; byte [ ] server key = new byte [ key size ] ; boolean is client = ! session . is Server ; System . arraycopy ( key block , NUM , client mac secret , NUM , hash size ) ; System . arraycopy ( key block , hash size , server mac secret , NUM , hash size ) ; System . arraycopy ( key block , NUM * hash size , client key , NUM , key size ) ; System . arraycopy ( key block , NUM * hash size + key size , server key , NUM , key size ) ; Iv Parameter Spec client IV = null ; Iv Parameter Spec server IV = null ; if ( is exportabe ) { if ( logger != null ) { logger . println ( STRING ) ; } Message Digest md 5 = Message Digest . get Instance ( STRING ) ; md 5 . update ( client key ) ; md 5 . update ( client Random ) ; md 5 . update ( server Random ) ; client key = md 5 . digest ( ) ; md 5 . update ( server key ) ; md 5 . update ( server Random ) ; md 5 . update ( client Random ) ; server key = md 5 . digest ( ) ; key size = cipher Suite . expanded Key Material ; if ( block size != NUM ) { md 5 . update ( client Random ) ; md 5 . update ( server Random ) ; client IV = new Iv Parameter Spec ( md 5 . digest ( ) , NUM , iv size ) ; md 5 . update ( server Random ) ; md 5 . update ( client Random ) ; server IV = new Iv Parameter Spec ( md 5 . digest ( ) , NUM , iv size ) ; } } else if ( block size != NUM ) { client IV = new Iv Parameter Spec ( key block , NUM * hash size + NUM * key size , iv size ) ; server IV = new Iv Parameter Spec ( key block , NUM * hash size + NUM * key size + iv size , iv size ) ; } if ( logger != null ) { logger . println ( STRING + is exportabe ) ; logger . println ( STRING ) ; logger . print ( session . master secret ) ; logger . println ( STRING ) ; logger . print ( client Random ) ; logger . println ( STRING ) ; logger . print ( server Random ) ; logger . println ( STRING ) ; logger . print ( client mac secret ) ; logger . println ( STRING ) ; logger . print ( server mac secret ) ; logger . println ( STRING ) ; logger . print ( client key , NUM , key size ) ; logger . println ( STRING ) ; logger . print ( server key , NUM , key size ) ; if ( client IV != null ) { logger . println ( STRING ) ; logger . print ( client IV . get IV ( ) ) ; logger . println ( STRING ) ; logger . print ( server IV . get IV ( ) ) ; } else { logger . println ( STRING ) ; } } if ( alg Name == null ) { enc Cipher = new Null Cipher ( ) ; dec Cipher = new Null Cipher ( ) ; } else { enc Cipher = Cipher . get Instance ( alg Name ) ; dec Cipher = Cipher . get Instance ( alg Name ) ; if ( is client ) { enc Cipher . init ( Cipher . ENCRYPT MODE , new Secret Key Spec ( client key , NUM , key size , alg Name ) , client IV ) ; dec Cipher . init ( Cipher . DECRYPT MODE , new Secret Key Spec ( server key , NUM , key size , alg Name ) , server IV ) ; } else { enc Cipher . init ( Cipher . ENCRYPT MODE , new Secret Key Spec ( server key , NUM , key size , alg Name ) , server IV ) ; dec Cipher . init ( Cipher . DECRYPT MODE , new Secret Key Spec ( client key , NUM , key size , alg Name ) , client IV ) ; } } message Digest = Message Digest . get Instance ( hash Name ) ; if ( is client ) { mac write secret = client mac secret ; mac read secret = server mac secret ; } else { mac write secret = server mac secret ; mac read secret = client mac secret ; } if ( hash Name . equals ( STRING ) ) { pad 1 = SS Lv 3 Constants . MD 5 pad 1 ; pad 2 = SS Lv 3 Constants . MD 5 pad 2 ; } else { pad 1 = SS Lv 3 Constants . SH Apad 1 ; pad 2 = SS Lv 3 Constants . SH Apad 2 ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new Alert Exception ( Alert Protocol . INTERNAL ERROR , new SSL Protocol Exception ( STRING ) ) ; } }
public static void clean Directory ( File directory ) throws IO Exception { if ( ! directory . exists ( ) ) { String message = directory + STRING ; throw new Illegal Argument Exception ( message ) ; } if ( ! directory . is Directory ( ) ) { String message = directory + STRING ; throw new Illegal Argument Exception ( message ) ; } File [ ] files = directory . list Files ( ) ; if ( files == null ) { throw new IO Exception ( STRING + directory ) ; } IO Exception exception = null ; for ( File file : files ) { try { force Delete ( file ) ; } catch ( IO Exception ioe ) { exception = ioe ; } } if ( null != exception ) { throw exception ; } }
public void not Idle ( ) { if ( idle Timeout Msec . get ( ) > NUM ) last Action Msec . set ( System . current Time Millis ( ) ) ; }
public static byte [ ] gzip ( final String input ) { final Byte Array Output Stream baos = new Fast Byte Array Output Stream ( ) ; GZIP Output Stream gzos = null ; try { gzos = new GZIP Output Stream ( baos ) ; gzos . write ( input . get Bytes ( STRING ) ) ; } catch ( final IO Exception e ) { Main Util . handle Error ( e ) ; } finally { if ( gzos != null ) { try { gzos . close ( ) ; } catch ( final IO Exception ignore ) { } } } return baos . to Byte Array ( ) ; }
protected Abstract Composite Service Builder ( ) { }
@ Override public void end Document ( ) throws SAX Exception { if ( resource != null ) { resource . add All Resource ( js Vector ) ; for ( Object object : resource . get Resource Set ( ) ) { Resource r = ( Resource ) object ; if ( r . get Resource ( ) != null ) { parser . set Resource ( ( Resource ) r ) ; parser . run ( ) ; js Set . add ( parser . get Result ( ) ) ; } } } }
public void add Method To Display ( Method Ident method Ident ) { methods . add ( method Ident ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
private void select Connecting Edges ( List < Display Node > display Nodes ) { if ( ! is Allow Node Edge Selection ( ) ) { return ; } Component [ ] components = get Components ( ) ; for ( Component comp : components ) { if ( comp instanceof I Display Edge ) { I Display Edge graph Edge = ( I Display Edge ) comp ; Display Node node 1 = graph Edge . get Comp 1 ( ) ; Display Node node 2 = graph Edge . get Comp 2 ( ) ; if ( node 1 instanceof Graph Node Error ) { continue ; } if ( node 2 instanceof Graph Node Error ) { continue ; } if ( node 2 != null ) { boolean selected = display Nodes . contains ( node 1 ) && display Nodes . contains ( node 2 ) ; graph Edge . set Selected ( selected ) ; } } } }
public static String class Name Only ( String type Name ) { String dotted = descriptor To Dot ( type Name ) ; int start = dotted . last Index Of ( STRING ) ; if ( start < NUM ) { return dotted ; } else { return dotted . substring ( start + NUM ) ; } }
public Hyper Graph search ( ) { long start Time = System . current Time Millis ( ) ; Future future = new Future ( chart ) ; stacks = new Array List < > ( ) ; stacks . add ( null ) ; Compute Node Result result = new Compute Node Result ( this . feature Functions , Hypothesis . BEGIN RULE , null , - NUM , NUM , null , this . sentence ) ; Stack first Stack = new Stack ( sentence , config ) ; first Stack . add ( new Hypothesis ( result . get DP States ( ) , future . Full ( ) ) ) ; stacks . add ( first Stack ) ; for ( int source words = NUM ; source words <= sentence . length ( ) ; ++ source words ) { Stack target Stack = new Stack ( sentence , config ) ; stacks . add ( target Stack ) ; for ( int phrase length = NUM ; phrase length <= Math . min ( source words - NUM , chart . Max Source Phrase Length ( ) ) ; phrase length ++ ) { int from stack = source words - phrase length ; Stack tail Stack = stacks . get ( from stack ) ; LOG . debug ( STRING , source words , chart . Max Source Phrase Length ( ) , from stack , phrase length ) ; for ( Coverage coverage : tail Stack . get Coverages ( ) ) { Array List < Hypothesis > hypotheses = tail Stack . get ( coverage ) ; int begin = coverage . first Zero ( ) ; int last end = Math . min ( coverage . first Zero ( ) + config . reordering limit , chart . Sentence Length ( ) ) ; int last begin = ( last end > phrase length ) ? ( last end - phrase length ) : NUM ; for ( begin = coverage . first Zero ( ) ; begin <= last begin ; begin ++ ) { if ( ! coverage . compatible ( begin , begin + phrase length ) || ! permissible ( coverage , begin , begin + phrase length ) ) { continue ; } if ( begin == sentence . length ( ) - NUM && source words != sentence . length ( ) ) continue ; Phrase Nodes phrases = chart . get Range ( begin , begin + phrase length ) ; if ( phrases == null ) continue ; LOG . debug ( STRING , phrases . size ( ) , begin , begin + phrase length ) ; float future delta = future . Change ( coverage , begin , begin + phrase length ) ; Candidate cand = new Candidate ( feature Functions , sentence , hypotheses , phrases , future delta , new int [ ] { NUM , NUM } ) ; target Stack . add Candidate ( cand ) ; } } } target Stack . search ( ) ; } LOG . info ( STRING , sentence . id ( ) , ( System . current Time Millis ( ) - start Time ) / NUM ) ; return create Goal Node ( ) ; }
@ Override public synchronized String to String ( ) { final String Buffer sb Result = new String Buffer ( ) ; sb Result . append ( STRING ) ; sb Result . append ( get Credentials String Representation ( proxy Cred ) ) ; sb Result . append ( STRING ) ; sb Result . append ( get Credentials String Representation ( cred Map ) ) ; sb Result . append ( STRING ) ; sb Result . append ( get Cookies String Representation ( cookies ) ) ; sb Result . append ( STRING ) ; final String str Result = sb Result . to String ( ) ; return str Result ; }
public static List < Library Location > gather All Libraries ( String [ ] dir Paths ) { List < Library Location > libraries = new Array List < Library Location > ( ) ; for ( int i = NUM ; i < dir Paths . length ; i ++ ) { File ext Dir = new File ( dir Paths [ i ] ) ; if ( ext Dir . is Directory ( ) ) { String [ ] names = ext Dir . list ( fg Archive Filter ) ; if ( names != null ) { for ( int j = NUM ; j < names . length ; j ++ ) { File jar = new File ( ext Dir , names [ j ] ) ; if ( jar . is File ( ) ) { try { I Path lib Path = new Path ( jar . get Canonical Path ( ) ) ; I Path source Path = Path . EMPTY ; I Path package Root = Path . EMPTY ; URL javadoc Location = null ; URL index Location = null ; Library Location library = new Library Location ( lib Path , source Path , package Root , javadoc Location , index Location ) ; libraries . add ( library ) ; } catch ( IO Exception e ) { Launching . log ( e ) ; } } } } } } return libraries ; }
public void request Close ( ) { m Lock . lock ( ) ; try { if ( m Is Shutdown ) { return ; } m Target State = Target State . CLOSED ; update ( ) ; } finally { m Lock . unlock ( ) ; } }
private void reserve One Doc ( ) { if ( pending Num Docs . increment And Get ( ) > Index Writer . get Actual Max Docs ( ) ) { pending Num Docs . decrement And Get ( ) ; throw new Illegal Argument Exception ( STRING + Index Writer . get Actual Max Docs ( ) ) ; } }
public static void stream Content To Browser ( Http Servlet Response response , Input Stream in , int length , String content Type , String file Name ) throws IO Exception { set Response Browser Proxy No Cache ( response ) ; response . set Content Length ( length ) ; if ( content Type != null ) { response . set Content Type ( content Type ) ; } if ( file Name != null ) { response . set Header ( STRING , STRING + file Name + STRING ) ; } Output Stream out = response . get Output Stream ( ) ; try { stream Content ( out , in , length ) ; } catch ( IO Exception e ) { out . close ( ) ; throw e ; } out . flush ( ) ; out . close ( ) ; }
@ Override public String to String ( ) { return to String ( BOOL ) ; }
private static boolean is Valid Method Name ( String method Name ) { return method Name . matches ( STRING ) ; }
public static byte [ ] to UTF 8 ( String s ) { byte [ ] result = new byte [ utf Length ( s ) ] ; int result index = NUM ; for ( int i = NUM , n = s . length ( ) ; i < n ; ++ i ) { char c = s . char At ( i ) ; if ( ( ( ! WRITE PSEUDO UTF 8 ) || ( c >= NUM ) ) && ( c <= NUM ) ) { result [ result index ++ ] = ( byte ) c ; } else if ( c > NUM ) { result [ result index ++ ] = ( byte ) ( NUM | ( byte ) ( c > > NUM ) ) ; result [ result index ++ ] = ( byte ) ( NUM | ( ( c & NUM ) > > NUM ) ) ; result [ result index ++ ] = ( byte ) ( NUM | ( c & NUM ) ) ; } else { result [ result index ++ ] = ( byte ) ( NUM | ( byte ) ( c > > NUM ) ) ; result [ result index ++ ] = ( byte ) ( NUM | ( c & NUM ) ) ; } } return result ; }
public void pln ( Object o ) throws IO Exception { p ( o . to String ( ) ) ; pln ( ) ; }
public void test Reduce Task ( ) throws Exception { Hadoop Job grid Job = get Hadoop Job ( igfs Scheme ( ) + PATH INPUT , igfs Scheme ( ) + PATH OUTPUT ) ; run Task With Input ( grid Job , Hadoop Task Type . REDUCE , NUM , STRING , STRING , STRING , STRING ) ; run Task With Input ( grid Job , Hadoop Task Type . REDUCE , NUM , STRING , STRING , STRING , STRING ) ; assert Equals ( STRING + STRING , read And Sort File ( PATH OUTPUT + STRING + get Output File Name Prefix ( ) + STRING ) ) ; assert Equals ( STRING + STRING , read And Sort File ( PATH OUTPUT + STRING + get Output File Name Prefix ( ) + STRING ) ) ; }
public static double expm 1 ( double value ) { if ( USE JDK MATH ) { return STRICT MATH ? Strict Math . expm 1 ( value ) : Math . expm 1 ( value ) ; } if ( Math . abs ( value ) < EXP LO DISTANCE TO ZERO ) { int i = ( int ) ( value * EXP LO INDEXING ) ; double delta = value - i * ( NUM / EXP LO INDEXING ) ; return exp Lo Pos Tab [ i + EXP LO TAB MID INDEX ] * ( exp Lo Neg Tab [ i + EXP LO TAB MID INDEX ] + delta * ( NUM + delta * ( NUM / NUM + delta * ( NUM / NUM + delta * ( NUM / NUM + delta * ( NUM / NUM ) ) ) ) ) ) ; } else { return Fast Math . exp ( value ) - NUM ; } }
public void delete Conditional ( Conditional c ) { deregister ( c ) ; }
public static void parse Model To Content Values ( Object model , Content Values content Values ) { if ( content Values . size ( ) > NUM ) content Values . clear ( ) ; Class < ? > clazz = model . get Class ( ) ; Field [ ] fields = clazz . get Declared Fields ( ) ; Class < ? > field Type = null ; Object field Val = null ; for ( Field field : fields ) { try { if ( field . is Accessible ( ) == BOOL ) field . set Accessible ( BOOL ) ; Column column = field . get Annotation ( Column . class ) ; field Type = field . get Type ( ) ; field Val = field . get ( model ) ; if ( column == null || field Val == null ) continue ; if ( field Type . equals ( int . class ) ) { content Values . put ( column . name ( ) , field . get Int ( model ) ) ; } else if ( field Type . equals ( Integer . class ) ) { content Values . put ( column . name ( ) , ( Integer ) field . get ( model ) ) ; } else if ( field Type . equals ( short . class ) ) { content Values . put ( column . name ( ) , field . get Short ( model ) ) ; } else if ( field Type . equals ( Short . class ) ) { content Values . put ( column . name ( ) , ( Short ) field . get ( model ) ) ; } else if ( field Type . equals ( long . class ) ) { content Values . put ( column . name ( ) , field . get Long ( model ) ) ; } else if ( field Type . equals ( Long . class ) ) { content Values . put ( column . name ( ) , ( Long ) field . get ( model ) ) ; } else if ( field Type . equals ( float . class ) ) { content Values . put ( column . name ( ) , field . get Float ( model ) ) ; } else if ( field Type . equals ( Float . class ) ) { content Values . put ( column . name ( ) , ( Float ) field . get ( model ) ) ; } else if ( field Type . equals ( double . class ) ) { content Values . put ( column . name ( ) , field . get Double ( model ) ) ; } else if ( field Type . equals ( Double . class ) ) { content Values . put ( column . name ( ) , ( Double ) field . get ( model ) ) ; } else if ( field Type . equals ( boolean . class ) ) { if ( field . get Boolean ( model ) == BOOL ) { content Values . put ( column . name ( ) , STRING ) ; } else { content Values . put ( column . name ( ) , STRING ) ; } } else if ( field Type . equals ( Boolean . class ) ) { if ( ( Boolean ) field . get ( model ) == BOOL ) { content Values . put ( column . name ( ) , STRING ) ; } else { content Values . put ( column . name ( ) , STRING ) ; } } else if ( field Type . equals ( String . class ) ) { content Values . put ( column . name ( ) , ( String ) field . get ( model ) ) ; } else if ( field Type . equals ( byte [ ] . class ) ) { content Values . put ( column . name ( ) , ( byte [ ] ) field . get ( model ) ) ; } else if ( field Type . equals ( Date . class ) ) { Date date = ( Date ) field . get ( model ) ; content Values . put ( column . name ( ) , Date Utils . format Date 2 Str ( date ) ) ; } } catch ( Illegal Argument Exception e ) { e . print Stack Trace ( ) ; } catch ( Illegal Access Exception e ) { e . print Stack Trace ( ) ; } } }
private void add Block To Worklist ( Ssa Basic Block ssa Block ) { if ( ! executable Blocks . get ( ssa Block . get Index ( ) ) ) { cfg Worklist . add ( ssa Block ) ; executable Blocks . set ( ssa Block . get Index ( ) ) ; } else { cfg Phi Worklist . add ( ssa Block ) ; } }
private static boolean is 32 Bit Jvm ( ) { Integer bits = Integer . get Integer ( STRING ) ; return bits != null && bits == NUM ; }
public float angle ( ) { return ( float ) Math . atan 2 ( y ( ) , x ( ) ) ; }
public static String format Number ( double value , int number Of Digits , boolean grouping Characters ) { if ( Double . is Na N ( value ) ) { return STRING ; } int number Digits = number Of Digits ; if ( number Digits < NUM ) { number Digits = number Of Fraction Digits ; } NUMBER FORMAT . set Minimum Fraction Digits ( number Digits ) ; NUMBER FORMAT . set Maximum Fraction Digits ( number Digits ) ; NUMBER FORMAT . set Grouping Used ( grouping Characters ) ; return NUMBER FORMAT . format ( value ) ; }
private J Panel create Legend Panel ( J Panel base Panel ) { final J Panel panel ; if ( base Panel != null ) { base Panel . remove All ( ) ; base Panel . set Layout ( new Grid Bag Layout ( ) ) ; panel = base Panel ; } else { panel = new J Panel ( new Grid Bag Layout ( ) ) ; } panel . set Border ( Border Factory . create Titled Border ( I18 n . tr ( STRING ) ) ) ; Grid Bag Constraints gbc = new Grid Bag Constraints ( ) ; gbc . anchor = Grid Bag Constraints . WEST ; gbc . insets = new Insets ( NUM , NUM , NUM , NUM ) ; J Check Box check Box = new J Check Box ( ) ; check Box . set Selected ( BOOL ) ; panel . add ( create Icon Label ( check Box ) , gbc ) ; Multi Line Label label = new Multi Line Label ( I18 n . tr ( STRING ) , BOOL ) ; Grid Bag Constraints label Gbc = new Grid Bag Constraints ( ) ; label Gbc . anchor = Grid Bag Constraints . WEST ; label Gbc . fill = Grid Bag Constraints . HORIZONTAL ; label Gbc . gridwidth = Grid Bag Constraints . REMAINDER ; label Gbc . gridx = NUM ; label Gbc . weightx = NUM ; panel . add ( label , label Gbc ) ; check Box . set Selected ( BOOL ) ; gbc . gridy = NUM ; panel . add ( create Icon Label ( check Box ) , gbc ) ; label = new Multi Line Label ( I18 n . tr ( STRING ) , BOOL ) ; label Gbc . gridy = NUM ; panel . add ( label , label Gbc ) ; check Box . set Icon ( partially Included Icon ) ; gbc . gridy = NUM ; gbc . insets = new Insets ( NUM , NUM , NUM , NUM ) ; panel . add ( create Icon Label ( check Box ) , gbc ) ; label = new Multi Line Label ( I18 n . tr ( STRING ) , BOOL ) ; label Gbc . gridy = NUM ; gbc . insets = null ; panel . add ( label , label Gbc ) ; return panel ; }
private static boolean is Trash Id ( Ignite Uuid id ) { if ( id == null ) return BOOL ; UUID gid = id . global Id ( ) ; return id . local Id ( ) == NUM && gid . get Most Significant Bits ( ) == NUM && gid . get Least Significant Bits ( ) > NUM && gid . get Least Significant Bits ( ) <= TRASH CONCURRENCY ; }
private void on Time Element End ( ) throws SAX Exception { try { time Ms = XML DATE TIME FORMAT . parse Millis ( content . trim ( ) ) ; } catch ( Illegal Argument Exception e ) { throw new SAX Exception ( create Error Message ( STRING + content ) , e ) ; } }
public void add Change Listener ( Change Listener l ) { m Change Listeners . add ( l ) ; }
public static boolean is Class Present ( String fully Qualified Class Name ) { try { Class . for Name ( fully Qualified Class Name ) ; return BOOL ; } catch ( Class Not Found Exception e ) { return BOOL ; } }
void unlink ( Node < E > p , Node < E > trail ) { p . set Value ( null ) ; trail . next = p . next ; if ( last == p ) last = trail ; if ( count . get And Decrement ( ) == capacity ) not Full . signal ( ) ; }
@ Target Api ( Build . VERSION CODES . JELLY BEAN ) private int queue Input Buffer ( Media Codec codec , Byte Buffer [ ] input Buffers , int index , Speech Record speech Record ) { if ( speech Record == null || speech Record . get Recording State ( ) != Speech Record . RECORDSTATE RECORDING ) { return - NUM ; } if ( Build . VERSION . SDK INT >= Build . VERSION CODES . JELLY BEAN ) { Byte Buffer input Buffer = input Buffers [ index ] ; input Buffer . clear ( ) ; int size = input Buffer . limit ( ) ; byte [ ] buffer = new byte [ size ] ; int status = read ( speech Record , buffer ) ; if ( status < NUM ) { handle Error ( STRING + status ) ; return - NUM ; } input Buffer . put ( buffer ) ; codec . queue Input Buffer ( index , NUM , size , NUM , NUM ) ; return size ; } return - NUM ; }
@ Override public final void sample ( ) { long count = count . get And Set ( NUM ) ; long time = time . get And Set ( NUM ) ; if ( count == NUM ) value = NUM ; else value = time / ( double ) count ; }
protected void validate Properties ( final Object entity , final Entity Data Model edm ) throws O Data Exception { final Type type = edm . get Type ( entity . get Class ( ) ) ; if ( ! ( type instanceof Structured Type ) ) { return ; } visit Properties ( edm , ( Structured Type ) type , null ) ; }
public static String format Number ( float number , int digit Count , boolean separate Thousands , char separate Char ) { char [ ] out = new char [ NUM ] ; boolean neg = BOOL ; if ( number == NUM ) { return STRING ; } boolean zero = BOOL ; if ( number < NUM && number > - NUM ) { zero = BOOL ; } if ( number < NUM ) { neg = BOOL ; number = - number ; } if ( digit Count > POW 10 . length ) { digit Count = POW 10 . length - NUM ; } number *= POW 10 [ digit Count ] ; long lval = Math . round ( number ) ; int ind = out . length - NUM ; int char Count = NUM ; boolean decimal Point Added = BOOL ; while ( lval != NUM || char Count < ( digit Count + NUM ) ) { int digit = ( int ) ( lval % NUM ) ; lval = lval / NUM ; out [ ind -- ] = ( char ) ( digit + STRING ) ; char Count ++ ; if ( char Count == digit Count ) { out [ ind -- ] = STRING ; char Count ++ ; decimal Point Added = BOOL ; } else if ( separate Thousands && lval != NUM && char Count > digit Count ) { if ( decimal Point Added ) { if ( ( char Count - digit Count ) % NUM == NUM ) { out [ ind -- ] = separate Char ; char Count ++ ; } } else { if ( ( char Count - digit Count ) % NUM == NUM ) { out [ ind -- ] = separate Char ; char Count ++ ; } } } } if ( zero ) { out [ ind -- ] = STRING ; char Count += NUM ; } if ( neg ) { out [ ind -- ] = STRING ; char Count += NUM ; } int start = out . length - char Count ; return String . value Of ( out , start , out . length - start ) ; }
static Adb Response read Adb Response ( Socket Channel chan , boolean read Diag String ) throws Timeout Exception , IO Exception { Adb Response resp = new Adb Response ( ) ; byte [ ] reply = new byte [ NUM ] ; read ( chan , reply ) ; if ( is Okay ( reply ) ) { resp . okay = BOOL ; } else { read Diag String = BOOL ; resp . okay = BOOL ; } try { while ( read Diag String ) { byte [ ] len Buf = new byte [ NUM ] ; read ( chan , len Buf ) ; String len Str = reply To String ( len Buf ) ; int len ; try { len = Integer . parse Int ( len Str , NUM ) ; } catch ( Number Format Exception nfe ) { Log . w ( STRING , STRING + len Str + STRING + len Buf [ NUM ] + STRING + len Buf [ NUM ] + STRING + len Buf [ NUM ] + STRING + len Buf [ NUM ] ) ; Log . w ( STRING , STRING + reply To String ( reply ) ) ; break ; } byte [ ] msg = new byte [ len ] ; read ( chan , msg ) ; resp . message = reply To String ( msg ) ; Log . v ( STRING , STRING + reply To String ( reply ) + STRING + resp . message + STRING ) ; break ; } } catch ( Exception e ) { } return resp ; }
public void remove Mouse Mode ( String id ) { for ( Map Mouse Mode med : mouse Modes ) { if ( id . equals ( med . get ID ( ) ) ) { remove Mouse Mode ( med ) ; break ; } } }
private Boolean filter Existing Items ( List < Post Item > post Items , Post Item item ) { if ( post Items . contains ( item ) ) { int i = post Items . index Of ( item ) ; post Items . remove ( i ) ; post Items . add ( i , item ) ; return BOOL ; } return BOOL ; }
Date Range build Shifted Range ( Date Range raw Range , long cadence , long now ) { if ( raw Range . get Start ( ) > now ) { throw new Illegal Argument Exception ( STRING ) ; } final Date Range rounded = raw Range . rounded ( cadence ) ; final long now Delta = now - rounded . get End ( ) ; if ( now Delta > SHIFT TOLERANCE ) { return rounded ; } final long diff = Math . abs ( Math . min ( now Delta , NUM ) ) + SHIFT TOLERANCE ; return rounded . shift ( - tolerance Shift Period ( diff , cadence ) ) ; }
public static void upto ( Date self , Date to , Closure closure ) { if ( self . compare To ( to ) <= NUM ) { for ( Date i = ( Date ) self . clone ( ) ; i . compare To ( to ) <= NUM ; i = next ( i ) ) { closure . call ( i ) ; } } else throw new Groovy Runtime Exception ( STRING + to + STRING + self + STRING ) ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Element test Employee ; Node first C ; String child Name ; int node Type ; Character Data employee ID Node ; String employee ID ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; test Employee = ( Element ) element List . item ( NUM ) ; first C = test Employee . get First Child ( ) ; node Type = ( int ) first C . get Node Type ( ) ; while ( equals ( NUM , node Type ) ) { first C = first C . get Next Sibling ( ) ; node Type = ( int ) first C . get Node Type ( ) ; } child Name = first C . get Node Name ( ) ; assert Equals Auto Case ( STRING , STRING , STRING , child Name ) ; employee ID Node = ( Character Data ) first C . get First Child ( ) ; employee ID = employee ID Node . get Node Value ( ) ; assert Equals ( STRING , STRING , employee ID ) ; }
public Inference Context ( N4 JS Type System ts , Type System Helper tsh , Cancel Indicator cancel Indicator , Rule Environment G , Inference Variable ... inference Variables ) { Objects . require Non Null ( ts ) ; Objects . require Non Null ( tsh ) ; Objects . require Non Null ( cancel Indicator ) ; Objects . require Non Null ( G ) ; this . ts = ts ; this . tsh = tsh ; this . cancel Indicator = cancel Indicator ; this . G = G ; add Inference Variables ( BOOL , inference Variables ) ; this . reducer = new Reducer ( this , G , ts , tsh ) ; this . current Bounds = new Bound Set ( this , G , ts ) ; }
@ Override public void run ( ) throws Interrupted Exception , Camera Access Exception , Camera Capture Session Closed Exception , Resource Acquisition Failed Exception { Frame Server . Session session = m Frame Server . try Create Exclusive Session ( ) ; if ( session == null ) { return ; } try { AF Trigger Result af Scan Result = new AF Trigger Result ( ) ; Request Builder idle Builder = create AF Idle Request ( null ) ; session . submit Request ( Arrays . as List ( idle Builder . build ( ) ) , Frame Server . Request Type . REPEATING ) ; Request Builder cancel Builder = create AF Cancel Request ( null ) ; session . submit Request ( Arrays . as List ( cancel Builder . build ( ) ) , Frame Server . Request Type . NON REPEATING ) ; idle Builder = create AF Idle Request ( af Scan Result ) ; session . submit Request ( Arrays . as List ( idle Builder . build ( ) ) , Frame Server . Request Type . REPEATING ) ; Request Builder trigger Builder = create AF Trigger Request ( af Scan Result ) ; session . submit Request ( Arrays . as List ( trigger Builder . build ( ) ) , Frame Server . Request Type . NON REPEATING ) ; af Scan Result . get ( ) ; } finally { session . close ( ) ; } }
protected List < Node > create Discrete Variable List ( Discrete Variable Analysis variable Analysis ) { List < Node > nodes = new Array List < > ( variable Analysis . get Num Of Cols ( ) ) ; Discrete Var Info [ ] variables = variable Analysis . get Discrete Var Infos ( ) ; for ( Discrete Var Info variable : variables ) { if ( variable != null ) { nodes . add ( new Discrete Variable ( variable . get Name ( ) , variable . get Categories ( ) ) ) ; } } return nodes ; }
private void pull Event ( ) { final int new Scroll Value ; final int item Dimension ; final float initial Motion Value , last Motion Value ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : initial Motion Value = m Initial Motion X ; last Motion Value = m Last Motion X ; break ; case VERTICAL : default : initial Motion Value = m Initial Motion Y ; last Motion Value = m Last Motion Y ; break ; } switch ( m Current Mode ) { case PULL FROM END : new Scroll Value = Math . round ( Math . max ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Footer Size ( ) ; break ; case PULL FROM START : default : new Scroll Value = Math . round ( Math . min ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Header Size ( ) ; break ; } set Header Scroll ( new Scroll Value ) ; if ( new Scroll Value != NUM && ! is Refreshing ( ) ) { float scale = Math . abs ( new Scroll Value ) / ( float ) item Dimension ; switch ( m Current Mode ) { case PULL FROM END : m Footer Layout . on Pull ( scale ) ; break ; case PULL FROM START : default : m Header Layout . on Pull ( scale ) ; break ; } if ( m State != State . PULL TO REFRESH && item Dimension >= Math . abs ( new Scroll Value ) ) { set State ( State . PULL TO REFRESH ) ; } else if ( m State == State . PULL TO REFRESH && item Dimension < Math . abs ( new Scroll Value ) ) { set State ( State . RELEASE TO REFRESH ) ; } } }
public synchronized void remove Series ( XY Series series ) { m Series . remove ( series ) ; }
private void synchronize Tables ( ) { reset DB Objects ( DB Object Table . class ) ; s logger . log ( Level . CONFIG , STRING ) ; s logger . log ( Level . CONFIG , STRING , new Object [ ] { m object Types , m direction } ) ; m counter Drp = new Integer ( NUM ) ; m counter Add = new Integer ( NUM ) ; m counter Upd = new Integer ( NUM ) ; m total Drp = new Integer ( NUM ) ; m total Add = new Integer ( NUM ) ; m total Upd = new Integer ( NUM ) ; for ( Iterator < String > table Iterator = m object List . iterator ( ) ; table Iterator . has Next ( ) ; ) { String key = table Iterator . next ( ) ; DB Object source Obj = m source Map . get ( key ) ; DB Object target Obj = m target Map . get ( key ) ; if ( target Obj != null && source Obj == null ) { if ( target Obj . get Customization Level ( ) == s parameters . CUSTOMNONE ) { if ( target Obj . drop ( ) ) m counter Drp = new Integer ( m counter Drp . int Value ( ) + NUM ) ; m total Drp = new Integer ( m total Drp . int Value ( ) + NUM ) ; } else { s logger . log ( Level . WARNING , STRING , new Object [ ] { m object Type , target Obj . get Name ( ) } ) ; } } if ( target Obj != null && source Obj != null ) { if ( target Obj . update ( source Obj ) ) m counter Upd = new Integer ( m counter Upd . int Value ( ) + NUM ) ; m total Upd = new Integer ( m total Upd . int Value ( ) + NUM ) ; } if ( target Obj == null && source Obj != null ) { if ( source Obj . create ( m target ) ) m counter Add = new Integer ( m counter Add . int Value ( ) + NUM ) ; m total Add = new Integer ( m total Add . int Value ( ) + NUM ) ; } } log Results ( ) ; }
public void remote Restart Coordinator ( String node Id , String type ) throws Local Repository Exception { final String prefix = String . format ( STRING , type , node Id ) ; log . debug ( prefix ) ; final String [ ] cmd = { SYSTOOL CMD , SYSTOOL REMOTE SYSTOOL , node Id , SYSTOOL RESTART COORDINATOR , type } ; final Exec . Result result = Exec . sudo ( SYSTOOL TIMEOUT , cmd ) ; check Failure ( result , prefix ) ; }
private static String int To String ( int value , int digit ) { String Builder string Builder = new String Builder ( digit ) ; string Builder . append ( Integer . to String ( value ) ) ; while ( string Builder . length ( ) < digit ) { string Builder . insert ( NUM , STRING ) ; } return string Builder . to String ( ) ; }
void add ( int n ) { if ( v == null ) { v = new int [ INIT SIZE ] ; v [ NUM ] = n ; len = NUM ; return ; } if ( len == v . length ) { int [ ] newv = new int [ len * NUM ] ; System . arraycopy ( v , NUM , newv , NUM , len ) ; v = newv ; } if ( n > v [ len - NUM ] ) { v [ len ++ ] = n ; return ; } int i = NUM ; for ( ; i < len ; i ++ ) { if ( n <= v [ i ] ) { if ( n == v [ i ] ) return ; break ; } } for ( int j = len ; j >= i ; j -- ) v [ j + NUM ] = v [ j ] ; v [ i ] = n ; ++ len ; }
public static String replace ( String source , String target , String replacement ) { String Buffer output = new String Buffer ( ) ; int n = NUM ; while ( BOOL ) { int off = source . index Of ( target , n ) ; if ( off == - NUM ) { output . append ( source . substring ( n ) ) ; break ; } output . append ( source . substring ( n , off ) ) ; output . append ( replacement ) ; n = off + target . length ( ) ; } return output . to String ( ) ; }
public void correct Null Receiver ( ) { if ( args [ NUM ] != null ) return ; handle = handle . bind To ( Null Object . get Null Object ( ) ) ; handle = Method Handles . drop Arguments ( handle , NUM , target Type . parameter Type ( NUM ) ) ; if ( LOG ENABLED ) LOG . info ( STRING ) ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
public static String number To String ( Number number ) throws JSON Exception { if ( number == null ) { throw new JSON Exception ( STRING ) ; } test Validity ( number ) ; String string = number . to String ( ) ; if ( string . index Of ( STRING ) > NUM && string . index Of ( STRING ) < NUM && string . index Of ( STRING ) < NUM ) { while ( string . ends With ( STRING ) ) { string = string . substring ( NUM , string . length ( ) - NUM ) ; } if ( string . ends With ( STRING ) ) { string = string . substring ( NUM , string . length ( ) - NUM ) ; } } return string ; }
public static boolean is Paired End Directory ( final File dir ) { if ( dir == null || ! dir . exists ( ) || ! dir . is Directory ( ) ) { return BOOL ; } final File l Dir = new File ( dir , STRING ) ; final File r Dir = new File ( dir , STRING ) ; return l Dir . exists ( ) && r Dir . exists ( ) && l Dir . is Directory ( ) && r Dir . is Directory ( ) ; }
@ Suppress Warnings ( STRING ) private void check Class Not Found ( ) throws Exception { init Gar = BOOL ; try { Ignite ignite 1 = start Grid ( NUM ) ; Ignite ignite 2 = start Grid ( NUM ) ; Class task = ext Ldr . load Class ( TASK NAME ) ; try { ignite 1 . compute ( ) . execute ( task , ignite 2 . cluster ( ) . local Node ( ) . id ( ) ) ; assert BOOL ; } catch ( Ignite Exception e ) { info ( STRING + e ) ; } } finally { stop Grid ( NUM ) ; stop Grid ( NUM ) ; } }
public String drop Engine ( Engine engine ) { String Builder builder = new String Builder ( ) ; for ( String attribute : Setup . get Drop Engine Message Format ( ) ) { builder . append ( get Engine Attribute ( engine , attribute , ! PICKUP ) ) ; } return builder . to String ( ) ; }
public Iterator < Json Element > iterator ( ) { return elements . iterator ( ) ; }
protected void pop Write Context ( ) { write Context = write Context Stack . pop ( ) ; }
public long calculate End Time ( ) { if ( end Time == NUM ) { return System . current Time Millis ( ) ; } else if ( end Time < NUM ) { return System . current Time Millis ( ) - end Time ; } return end Time ; }
protected String extract Alternate Open Quote ( String token ) { return null ; }
private boolean remove Index Entry ( Service Type resource Type , String resource Name , String policy Name ) throws Policy Exception { Resource Index resource Index = ( Resource Index ) resource Indices . get ( resource Type . get Name ( ) ) ; if ( resource Index == null ) { resource Index = refresh Resource Index From Data Store ( resource Type ) ; } return resource Index . remove Index Entry ( resource Name , policy Name ) ; }
public static Text Block parse Text Block ( Parse Context parse Context ) { return Text Block Section Parser . parse Text Block ( parse Context ) ; }
public final static boolean in Long Range ( char [ ] digit Chars , int offset , int len , boolean negative ) { String cmp Str = negative ? MIN LONG STR NO SIGN : MAX LONG STR ; int cmp Len = cmp Str . length ( ) ; if ( len < cmp Len ) return BOOL ; if ( len > cmp Len ) return BOOL ; for ( int i = NUM ; i < cmp Len ; ++ i ) { if ( digit Chars [ offset + i ] > cmp Str . char At ( i ) ) { return BOOL ; } } return BOOL ; }
public static Collection < Debugger Exception > merge Exceptions Settings ( final Debug Target Settings target , final Collection < Debugger Exception > exceptions , final int debugger Id ) throws Couldnt Load Data Exception { final Map < Long , Debugger Exception > exceptions Map = get Exceptions Map ( exceptions ) ; for ( final Debugger Exception dbg Exception : exceptions ) { final String setting = target . read Setting ( Debugger Exception . get Setting Key ( dbg Exception , debugger Id ) ) ; if ( setting != null ) { final Debugger Exception Handling Action handling Action = Debugger Exception Handling Action . convert To Handling Action ( Integer . value Of ( setting ) ) ; final Debugger Exception new Exception = new Debugger Exception ( dbg Exception . get Exception Name ( ) , dbg Exception . get Exception Code ( ) , handling Action ) ; exceptions Map . put ( dbg Exception . get Exception Code ( ) , new Exception ) ; } } return exceptions Map . values ( ) ; }
public void verify Annotation ( String method Name , String annotation Name ) throws Exception { Class clazz = Class . for Name ( class Name ) ; Method method = clazz . get Declared Method ( method Name ) ; Class annotation Clazz = Class . for Name ( annotation Name ) ; java . lang . annotation . Annotation annotation = method . get Annotation ( annotation Clazz ) ; Assert . assert Not Null ( annotation ) ; }
public static < V > int add Distinct List ( List < V > source List , List < V > entry List ) { if ( source List == null || is Empty ( entry List ) ) { return NUM ; } int source Count = source List . size ( ) ; for ( V entry : entry List ) { if ( ! source List . contains ( entry ) ) { source List . add ( entry ) ; } } return source List . size ( ) - source Count ; }
public Publisher Amb < T > amb Additional Source ( Publisher < ? extends T > source ) { if ( array != null ) { int n = array . length ; @ Suppress Warnings ( STRING ) Publisher < ? extends T > [ ] new Array = new Publisher [ n + NUM ] ; System . arraycopy ( array , NUM , new Array , NUM , n ) ; new Array [ n ] = source ; return new Publisher Amb < > ( new Array ) ; } return null ; }
public void begin Display ( Display Event event ) throws Model Control Exception { super . begin Display ( event ) ; String site Name = ( String ) get Page Session Attribute ( PG ATTR SITE NAME ) ; Server Site Model model = ( Server Site Model ) get Model ( ) ; pt Model . set Page Title Text ( model . get Edit Site Page Title ( site Name ) ) ; try { set Display Field Value ( TF URL , model . get Site Primary URL ( site Name ) ) ; get Failover UR Ls ( site Name , model ) ; get Servers ( site Name , model ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } }
public boolean add ( Accessible State state ) { if ( states == null ) { states = new Vector ( ) ; } if ( ! states . contains ( state ) ) { states . add Element ( state ) ; return BOOL ; } else { return BOOL ; } }
public static final String read File ( File file ) throws IO Exception { Buffered Input Stream in = null ; try { in = new Buffered Input Stream ( new File Input Stream ( file ) ) ; Simple Byte Buffer buffer = new Simple Byte Buffer ( ) ; byte [ ] buf = new byte [ NUM ] ; int len ; while ( ( len = in . read ( buf ) ) != - NUM ) { buffer . put ( buf , len ) ; } return new String ( buffer . buffer , NUM , buffer . write ) ; } finally { if ( null != in ) { in . close ( ) ; } } }
void add Decimal Point ( ) { this . display Mode = DISPLAY MODE . INPUT ; if ( this . clear On Next Digit ) { set Display String ( EMPTY STRING ) ; } final String input String = get Display String ( ) ; if ( input String . index Of ( DOT CHARACTER ) < NUM ) { set Display String ( input String + DOT CHARACTER ) ; } }
public void close ( ) throws java . io . IO Exception { m os . close ( ) ; }
void show ( ) { if ( m Is Visible ) return ; m Is Visible = BOOL ; m Height Px = Math . round ( m Default Height Px ) ; invalidate ( ) ; }
public void record Mirror Operation ( Db Client db Client , Operation Type Enum op Type , Operation . Status status , Object ... ext Param ) { try { boolean op Status = ( Operation . Status . ready == status ) ? BOOL : BOOL ; String ev Type ; ev Type = op Type . get Ev Type ( op Status ) ; String ev Desc = op Type . get Description ( ) ; String op Stage = Audit Log Manager . AUDITOP END ; logger . info ( STRING , op Type . to String ( ) , ev Type . to String ( ) + STRING + ev Desc ) ; record Bourne Mirror Event ( db Client , get Id ( ) , ev Type , status , ev Desc ) ; switch ( op Type ) { case CREATE FILE MIRROR : case START FILE MIRROR : case SUSPEND FILE MIRROR : case DETACH FILE MIRROR : case PAUSE FILE MIRROR : case RESUME FILE MIRROR : case FAILOVER FILE MIRROR : case STOP FILE MIRROR : case FAILBACK FILE MIRROR : case RESYNC FILE MIRROR : case REFRESH FILE MIRROR : case MODIFY FILE MIRROR RPO : audit File ( db Client , op Type , op Status , op Stage , ext Param ) ; break ; default : logger . error ( STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , op Type . to String ( ) , e ) ; } }
private void cancel Take Image ( ) { m Shooted Picture Path = null ; m Selected Gallery Items List . clear ( ) ; Vector App . set Saved Camera Image Preview ( null ) ; start Camera Preview ( ) ; update Ui Configuration ( UI SHOW CAMERA PREVIEW , IMAGE ORIGIN CAMERA ) ; }
protected int next Grid To Restart ( ) { if ( curr Restart Grid Id == server Count ( ) ) curr Restart Grid Id = NUM ; return ++ curr Restart Grid Id ; }
public void characters Raw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAX Exception { if ( is Outside Doc Elem ( ) && XML Character Recognizer . is White Space ( ch , start , length ) ) return ; String s = new String ( ch , start , length ) ; append ( m doc . create Processing Instruction ( STRING , STRING ) ) ; append ( m doc . create Text Node ( s ) ) ; }
private void remove Stale Iterator References ( ) { remove Stale References ( iterator Reference Queue , iterators ) ; }
boolean destroy I Group ( boolean force ) { Na Element elem = new Na Element ( STRING ) ; elem . add New Child ( STRING , name ) ; elem . add New Child ( STRING , Boolean . to String ( force ) ) ; try { server . invoke Elem ( elem ) ; } catch ( Exception e ) { String msg = STRING + name ; log . error ( msg , e ) ; throw new Net App Exception ( msg , e ) ; } return BOOL ; }
@ Override public double finite Difference Epsilon ( ) { return NUM ; }
public void remove ( final Http Connection connection ) { log . debug ( STRING + connection . get ID ( ) ) ; connection To Added . remove ( connection ) ; }
public void put Byte ( long pos , byte val ) { unsafe . put Byte ( pos + addr , val ) ; }
public void add Reference ( Message Part reference ) { references . add ( reference ) ; }
protected boolean [ ] dataset Integrity ( Attr Types attr Types , int class Type , boolean attribute Missing , boolean class Missing ) { Estimator estimator = null ; print ( STRING ) ; print Attribute Summary ( attr Types , class Type ) ; print ( STRING ) ; int num Train = get Num Instances ( ) ; get Num Instances ( ) ; int num Classes = NUM , missing Level = NUM ; boolean [ ] result = new boolean [ NUM ] ; Instances train = null ; boolean built = BOOL ; try { train = make Test Dataset ( NUM , num Train , NUM , attr Types , num Classes , class Type ) ; int attr Index = NUM ; if ( missing Level > NUM ) { add Missing ( train , missing Level , attribute Missing , class Missing , attr Index ) ; } estimator = Estimator . make Copies ( get Estimator ( ) , NUM ) [ NUM ] ; } catch ( Exception ex ) { throw new Error ( STRING + ex . get Message ( ) ) ; } try { Instances train Copy = new Instances ( train ) ; int attr Index = NUM ; estimator . add Values ( train Copy , attr Index ) ; compare Datasets ( train , train Copy ) ; built = BOOL ; println ( STRING ) ; result [ NUM ] = BOOL ; } catch ( Exception ex ) { println ( STRING ) ; result [ NUM ] = BOOL ; if ( m Debug ) { println ( STRING ) ; print ( STRING ) ; if ( built ) { print ( STRING ) ; } else { print ( STRING ) ; } println ( STRING + ex . get Message ( ) + STRING ) ; println ( STRING ) ; println ( STRING + train . to String ( ) + STRING ) ; } } return result ; }
@ Override public void add Focusables ( Array List < View > views , int direction , int focusable Mode ) { final int focusable Count = views . size ( ) ; final int descendant Focusability = get Descendant Focusability ( ) ; if ( descendant Focusability != FOCUS BLOCK DESCENDANTS ) { for ( int i = NUM ; i < get Child Count ( ) ; i ++ ) { final View child = get Child At ( i ) ; if ( child . get Visibility ( ) == VISIBLE ) { Item Info ii = info For Child ( child ) ; if ( ii != null && ii . position == m Cur Item ) { child . add Focusables ( views , direction , focusable Mode ) ; } } } } if ( descendant Focusability != FOCUS AFTER DESCENDANTS || ( focusable Count == views . size ( ) ) ) { if ( ! is Focusable ( ) ) { return ; } if ( ( focusable Mode & FOCUSABLES TOUCH MODE ) == FOCUSABLES TOUCH MODE && is In Touch Mode ( ) && ! is Focusable In Touch Mode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }
protected Date Time Data parse ( String str ) throws Schema Date Time Exception { Date Time Data date = new Date Time Data ( str , this ) ; int len = str . length ( ) ; if ( str . char At ( NUM ) != STRING || str . char At ( NUM ) != STRING || str . char At ( NUM ) != STRING ) { throw new Schema Date Time Exception ( STRING ) ; } date . year = YEAR ; date . month = MONTH ; date . day = parse Int ( str , NUM , NUM ) ; if ( DAY SIZE < len ) { if ( ! is Next Char UTC Sign ( str , DAY SIZE , len ) ) { throw new Schema Date Time Exception ( STRING ) ; } else { get Time Zone ( str , date , DAY SIZE , len ) ; } } validate Date Time ( date ) ; save Unnormalized ( date ) ; if ( date . utc != NUM && date . utc != STRING ) { normalize ( date ) ; } date . position = NUM ; return date ; }
public static Map < String , Set < String > > parse ( final URI uri , boolean decode Query Param ) { Map < String , Set < String > > result = Collections . empty Map ( ) ; final String query = uri . get Raw Query ( ) ; if ( query != null && query . length ( ) > NUM ) { result = new Hash Map < > ( ) ; parse ( result , new Scanner ( query ) , null , decode Query Param ) ; } return result ; }
private void update Period ( ) { for ( int i = NUM ; i < m Conversion . size ( ) ; i ++ ) { int date Type = m Conversion . key At ( i ) ; Time Period Slider slider = m Time Period Sliders . get ( date Type ) ; slider . set Value ( m Period . get ( m Conversion . value At ( i ) ) ) ; } m Time . set Text ( get Formatted Period ( ) ) ; m Duration = m Period . to Standard Duration ( ) ; do Validation ( ) ; }
public long start brk ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
public static void validate Participant Ids Equal ( String expected Participant Id , String actual Participant Id ) throws Crypto Exception { if ( ! expected Participant Id . equals ( actual Participant Id ) ) { throw new Crypto Exception ( STRING + actual Participant Id + STRING + expected Participant Id + STRING ) ; } }
protected void encode Fields ( mx Codec enc , Object obj , Node node ) { Class type = obj . get Class ( ) ; while ( type != null ) { Field [ ] fields = type . get Declared Fields ( ) ; for ( int i = NUM ; i < fields . length ; i ++ ) { Field f = fields [ i ] ; if ( ( f . get Modifiers ( ) & Modifier . TRANSIENT ) != Modifier . TRANSIENT ) { String fieldname = f . get Name ( ) ; Object value = get Field Value ( obj , fieldname ) ; encode Value ( enc , obj , fieldname , value , node ) ; } } type = type . get Superclass ( ) ; } }
public void add Vetoable Change Listener ( String property Name , Vetoable Change Listener in vcl ) { bean Context Child Support . add Vetoable Change Listener ( property Name , in vcl ) ; }
private void log Missing Resource ( Faces Context ctx , String resource Id , Throwable t ) { Level level ; if ( ! ctx . is Project Stage ( Project Stage . Production ) ) { level = Level . WARNING ; } else { level = ( ( t != null ) ? Level . WARNING : Level . FINE ) ; } if ( LOGGER . is Loggable ( level ) ) { LOGGER . log ( level , STRING , new Object [ ] { resource Id } ) ; if ( t != null ) { LOGGER . log ( level , STRING , t ) ; } } }
private void append Aliased Column ( String Builder sb , String col Name , String t Alias ) { if ( t Alias != null ) { sb . append ( t Alias ) ; sb . append ( STRING ) ; } sb . append ( STRING ) ; sb . append ( col Name ) ; sb . append ( STRING ) ; }
private Midi Event create Scheduled Event ( byte [ ] msg , int offset , int count , long timestamp ) { Midi Event event ; if ( count > POOL EVENT SIZE ) { event = new Midi Event ( msg , offset , count , timestamp ) ; } else { event = ( Midi Event ) remove Eventfrom Pool ( ) ; if ( event == null ) { event = new Midi Event ( POOL EVENT SIZE ) ; } System . arraycopy ( msg , offset , event . data , NUM , count ) ; event . count = count ; event . set Timestamp ( timestamp ) ; } return event ; }
public void start Element ( String namespace URI , String local Name , String q Name , Attributes atts ) throws SAX Exception { try { elem Type = ( Sax Handler Base . Element Type ) element Types . get ( local Name ) ; if ( gather Mode ) { if ( gathering Element . gather Element ( local Name , atts ) ) { gather Buffer . add ( new Object [ ] { elem Type , new Attributes Impl ( atts ) } ) ; } } else { if ( elem Type == null ) { return ; } elem Type . start Element ( atts ) ; } elems . add ( elem Type ) ; } catch ( SAX Exception saxex ) { throw saxex ; } catch ( Exception ex ) { throw new SAX Exception ( ex ) ; } }
public static byte [ ] gzip ( String input ) { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; GZIP Output Stream gzos = null ; try { gzos = new GZIP Output Stream ( baos ) ; gzos . write ( input . get Bytes ( STRING ) ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } finally { if ( gzos != null ) try { gzos . close ( ) ; } catch ( IO Exception ignore ) { } } return baos . to Byte Array ( ) ; }
public static double log Pdf ( double x , double m , double shape ) { double a = Math . sqrt ( shape / ( NUM * Math . PI * x * x * x ) ) ; double b = ( ( - shape ) * ( x - m ) * ( x - m ) ) / ( NUM * m * m * x ) ; return Math . log ( a ) + b ; }
public void add Edge Connector ( ) { num Edge Connectors ++ ; String name = STRING ; boolean duplicate = BOOL ; while ( duplicate ) { name = STRING + num Edge Connectors ; if ( finder . find Positionable Point By Name ( name ) == null ) { duplicate = BOOL ; } if ( duplicate ) { num Edge Connectors ++ ; } } Positionable Point o = new Positionable Point ( name , Positionable Point . EDGE CONNECTOR , current Point , this ) ; point List . add ( o ) ; set Dirty ( BOOL ) ; }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . GET ) @ Response Body public Rest Wrapper list ( @ Request Param ( value = STRING , default Value = STRING ) int start Page , @ Request Param ( value = STRING , default Value = STRING ) int page Size , Principal principal ) { Rest Wrapper rest Wrapper = null ; try { Integer counter = workflow Type DAO . total Record Count ( ) ; List < Workflow Type > workflow Types = new Array List < Workflow Type > ( ) ; List < com . wipro . ats . bdre . md . dao . jpa . Workflow Type > jpa Workflow Types = workflow Type DAO . list ( start Page , page Size ) ; for ( com . wipro . ats . bdre . md . dao . jpa . Workflow Type wf Type : jpa Workflow Types ) { Workflow Type workflow Type = new Workflow Type ( ) ; workflow Type . set Workflow Id ( wf Type . get Workflow Id ( ) ) ; workflow Type . set Workflow Type Name ( wf Type . get Workflow Type Name ( ) ) ; workflow Type . set Counter ( counter ) ; workflow Types . add ( workflow Type ) ; } rest Wrapper = new Rest Wrapper ( workflow Types , Rest Wrapper . OK ) ; LOGGER . info ( STRING + principal . get Name ( ) ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
public synchronized void write To ( Output Stream out ) throws IO Exception { int remaining = count ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; out . write ( buf , NUM , c ) ; remaining -= c ; if ( remaining == NUM ) { break ; } } }
public void parse For Class ( Generic Declaration generic Decl , String signature ) { set Input ( generic Decl , signature ) ; if ( ! eof ) { parse Class Signature ( ) ; } else { if ( generic Decl instanceof Class ) { Class c = ( Class ) generic Decl ; this . formal Type Parameters = Empty Array . TYPE VARIABLE ; this . superclass Type = c . get Superclass ( ) ; Class < ? > [ ] interfaces = c . get Interfaces ( ) ; if ( interfaces . length == NUM ) { this . interface Types = List Of Types . EMPTY ; } else { this . interface Types = new List Of Types ( interfaces ) ; } } else { this . formal Type Parameters = Empty Array . TYPE VARIABLE ; this . superclass Type = Object . class ; this . interface Types = List Of Types . EMPTY ; } } }
static boolean try External Unpush ( Fork Join Task < ? > t ) { Fork Join Pool p ; Work Queue [ ] ws ; Work Queue q ; Submitter z ; Fork Join Task < ? > [ ] a ; int m , s ; if ( t != null && ( z = submitters . get ( ) ) != null && ( p = common Pool ) != null && ( ws = p . work Queues ) != null && ( m = ws . length - NUM ) >= NUM && ( q = ws [ m & z . seed & SQMASK ] ) != null && ( s = q . top ) != q . base && ( a = q . array ) != null ) { long j = ( ( ( a . length - NUM ) & ( s - NUM ) ) << ASHIFT ) + ABASE ; if ( U . get Object ( a , j ) == t && U . compare And Swap Int ( q , QLOCK , NUM , NUM ) ) { if ( q . array == a && q . top == s && U . compare And Swap Object ( a , j , t , null ) ) { q . top = s - NUM ; q . qlock = NUM ; return BOOL ; } q . qlock = NUM ; } } return BOOL ; }
public static double [ ] quantiles ( int n , double [ ] values ) { values = ( double [ ] ) values . clone ( ) ; Arrays . sort ( values ) ; double [ ] qtls = new double [ n + NUM ] ; for ( int i = NUM ; i <= n ; ++ i ) { qtls [ i ] = values [ ( ( values . length - NUM ) * i ) / n ] ; } return qtls ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String bad Substring ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; { boolean success = BOOL ; try { bad Substring = child . substring Data ( NUM , - NUM ) ; } catch ( DOM Exception ex ) { success = ( ex . code == DOM Exception . INDEX SIZE ERR ) ; } assert True ( STRING , success ) ; } }
public Query Exception ( String message , int error Code , Sql States sql State , Throwable cause ) { super ( message , cause ) ; this . message = message ; this . error Code = error Code ; this . sql State = sql State . get Sql State ( ) ; }
private void write Attribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( xml Writer . get Prefix ( namespace ) == null ) { xml Writer . write Namespace ( prefix , namespace ) ; xml Writer . set Prefix ( prefix , namespace ) ; } xml Writer . write Attribute ( namespace , att Name , att Value ) ; }
public void test Constructor String Radix 16 ( ) { String value = STRING ; int radix = NUM ; byte r Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , NUM , - NUM , - NUM } ; Big Integer a Number = new Big Integer ( value , radix ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
private CSV Data ( List < CSV Record > records ) { this . records = Objects . require Non Null ( records ) ; }
private Workflow . Method untag Volumes Method ( URI system URI , List < URI > volume UR Is ) { return new Workflow . Method ( STRING , system URI , volume UR Is ) ; }
private byte [ ] SHA 256 hash ( byte [ ] tobe Hashed ) { SHA 256 Digest digester = new SHA 256 Digest ( ) ; byte [ ] ret Value = new byte [ digester . get Digest Size ( ) ] ; digester . update ( tobe Hashed , NUM , tobe Hashed . length ) ; digester . do Final ( ret Value , NUM ) ; return ret Value ; }
@ Data Provider private static Object [ ] [ ] ok Resource Responses ( ) { return new Object [ ] [ ] { { new Response ( OK ) } , { new Response ( FOUND ) } , { new Response ( MOVED PERMANENTLY ) } , { new Response ( CREATED ) } } ; }
public synchronized void connect ( ) { if ( ! zk Connection . is Started ( ) ) { zk Connection . start ( ) ; } if ( String Utils . is Empty ( site Id ) ) { generate Site Id ( ) ; } }
static Object convert Java Time To Java Sql ( Object x ) { if ( x instanceof Local Date ) { return Date . value Of ( ( Local Date ) x ) ; } else if ( x instanceof Local Date Time ) { return Timestamp . value Of ( ( Local Date Time ) x ) ; } else if ( x instanceof Local Time ) { return Time . value Of ( ( Local Time ) x ) ; } return x ; }
@ Not Null private static Default Mutable Tree Node update Tree Structure ( @ Not Null Default Mutable Tree Node tree Node , @ Not Null Zip File compressed Apk ) { long compressed Size = NUM ; Apk Entry entry = Apk Entry . from Node ( tree Node ) ; assert entry != null ; if ( tree Node . get Child Count ( ) > NUM ) { for ( int i = NUM ; i < tree Node . get Child Count ( ) ; i ++ ) { Default Mutable Tree Node child Node = update Tree Structure ( ( Default Mutable Tree Node ) tree Node . get Child At ( i ) , compressed Apk ) ; compressed Size += ( ( Apk Entry ) child Node . get User Object ( ) ) . get Compressed Size ( ) ; } } else { Zip Entry ze = compressed Apk . get Entry ( Apk File System . get Instance ( ) . get Relative Path ( entry . get File ( ) ) ) ; if ( ze == null ) { compressed Size = - NUM ; } else { compressed Size = ze . get Compressed Size ( ) ; } } entry . set Compressed Size ( compressed Size ) ; return tree Node ; }
public long total Memory ( ) { return total Memory Impl ( ) ; }
public static void enable Sync ( String account Name ) { }
public static void scan ( ) { List < Scanner Registration > scanners = get Scanners To Run ( ) ; if ( scanners . size ( ) > NUM ) { URL [ ] urls = get Search UR Ls ( ) ; if ( urls == null ) { urls = fiter Libs ( Scanner URLS . get UR Ls For Search ( ) ) ; scan ( scanners , urls ) ; } else { scan ( scanners , urls ) ; } } }
public final void turn To ( double angle ) { angle = Geometric . clamp Angle Degree ( angle ) ; orientation = Geometric . clamp Angle Degree ( angle ) ; Geometric . rotate To ( velocity , Math . to Radians ( orientation ) ) ; }
void fully Lock ( ) { put Lock . lock ( ) ; take Lock . lock ( ) ; }
protected int start Bridge Server ( int port , boolean notify By Subscription ) throws IO Exception { Cache cache = get Cache ( ) ; Cache Server bridge = cache . add Cache Server ( ) ; bridge . set Port ( port ) ; bridge . set Notify By Subscription ( notify By Subscription ) ; bridge . start ( ) ; bridge Server Port = bridge . get Port ( ) ; return bridge . get Port ( ) ; }
public void add Action ( String action ) { Object [ ] args = new String [ NUM ] ; Simple Date Format sdf = new Simple Date Format ( context . get String ( R . string . date Format ) ) ; args [ NUM ] = sdf . format ( new Date ( ) ) ; String timestamp = context . get String ( R . string . timestamp , args ) ; history . add ( action + timestamp ) ; notify Listeners ( new Property Change Event ( this , Activity Constants . history Property , null , null ) ) ; }
protected Object to Type ( Calendar value ) { return value . get Time ( ) ; }
protected F restore Last Filter ( int dialog Type ) { F result ; List < F > list ; int i ; result = null ; if ( dialog Type == OPEN DIALOG ) list = get Open File Filters ( ) ; else list = get Save File Filters ( ) ; if ( list . size ( ) > NUM ) { result = get Default File Filter ( dialog Type ) ; set File Filter ( result ) ; if ( m Last Filter != null ) { for ( i = NUM ; i < list . size ( ) ; i ++ ) { if ( m Comparator . compare ( list . get ( i ) , m Last Filter ) == NUM ) { result = ( F ) m Last Filter ; set File Filter ( m Last Filter ) ; break ; } } } } return result ; }
public void test Char Based Collisions ( ) { Chars To Name Canonicalizer sym = Chars To Name Canonicalizer . create Root ( ) ; try { int first Hash = NUM ; for ( String str : CHAR COLLISIONS ) { int hash = sym . calc Hash ( str ) ; if ( first Hash == NUM ) { first Hash = hash ; } else { assert Equals ( first Hash , hash ) ; } sym . find Symbol ( str . to Char Array ( ) , NUM , str . length ( ) , hash ) ; } fail ( STRING ) ; } catch ( Illegal State Exception e ) { verify Exception ( e , STRING ) ; assert Equals ( Chars To Name Canonicalizer . MAX COLL CHAIN LENGTH + NUM , sym . max Collision Length ( ) ) ; assert Equals ( Chars To Name Canonicalizer . MAX COLL CHAIN LENGTH + NUM , sym . collision Count ( ) ) ; assert Equals ( Chars To Name Canonicalizer . MAX COLL CHAIN LENGTH + NUM , sym . size ( ) ) ; } }
public void handle Tbl Data Site Action Href Request ( Request Invocation Event event ) throws Model Control Exception { String site Name = hex To String ( ( String ) get Display Field Value ( TBL DATA SITE ACTION HREF ) ) ; set Page Session Attribute ( Site Edit View Bean . PG ATTR SITE NAME , site Name ) ; Site Edit View Bean vb = ( Site Edit View Bean ) get View Bean ( Site Edit View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; }
public static void normalize ( double [ ] doubles , double sum ) { if ( Double . is Na N ( sum ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( sum == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } for ( int i = NUM ; i < doubles . length ; i ++ ) { doubles [ i ] /= sum ; } }
private void expand Array ( int shard Id ) { int new Num Shards = Math . max ( ( int ) Math . ceil ( num Shards * SHARD GROWTH FACTOR ) , shard Id + NUM ) ; Preconditions . check Argument ( new Num Shards * shard Length < Integer . MAX VALUE , STRING ) ; int [ ] [ ] new Array = new int [ new Num Shards ] [ ] ; System . arraycopy ( reader Accessible Info . array , NUM , new Array , NUM , reader Accessible Info . array . length ) ; reader Accessible Info = new Reader Accessible Info ( new Array ) ; num Shards = new Num Shards ; }
protected < T > T wait For Property Value ( String document Self Link , Class < T > type , String prop Name , Object prop Value , boolean should Match , Atomic Integer count ) throws Throwable { @ Suppress Warnings ( STRING ) List < Object > prop = prop Value instanceof List ? ( List < Object > ) prop Value : Arrays . as List ( prop Value ) ; return wait For Property Value ( document Self Link , type , prop Name , prop , should Match , count ) ; }
public static String from I Pv 4 Address Collection ( Collection < Integer > ip Addresses ) { if ( ip Addresses == null ) return STRING ; String Buffer sb = new String Buffer ( ) ; sb . append ( STRING ) ; for ( Integer ip : ip Addresses ) { sb . append ( from I Pv 4 Address ( ip ) ) ; sb . append ( STRING ) ; } sb . replace ( sb . length ( ) - NUM , sb . length ( ) , STRING ) ; return sb . to String ( ) ; }
public static final String make Java Identifier ( String identifier ) { String Builder modified Identifier = new String Builder ( identifier . length ( ) ) ; if ( ! Character . is Java Identifier Start ( identifier . char At ( NUM ) ) ) { modified Identifier . append ( STRING ) ; } for ( int i = NUM ; i < identifier . length ( ) ; i ++ ) { char ch = identifier . char At ( i ) ; if ( Character . is Java Identifier Part ( ch ) && ch != STRING ) { modified Identifier . append ( ch ) ; } else if ( ch == STRING ) { modified Identifier . append ( STRING ) ; } else { modified Identifier . append ( mangle Char ( ch ) ) ; } } if ( is Java Keyword ( modified Identifier . to String ( ) ) ) { modified Identifier . append ( STRING ) ; } return modified Identifier . to String ( ) ; }
public static String encrypt ( String input ) { if ( encryption Service == null || input == null || input . length ( ) == NUM ) { return input ; } return ENCRYPTION PREFIX + encryption Service . encrypt ( input ) ; }
public static void create Federated Namespace ( URI namespace , Zoo Keeper Client zkc ) throws Interrupted Exception , Zoo Keeper Client . Zoo Keeper Connection Exception , Keeper Exception { String zk Sub Namespaces Path = namespace . get Path ( ) + STRING + ZNODE SUB NAMESPACES ; Utils . zk Create Full Path Optimistic ( zkc , zk Sub Namespaces Path , new byte [ NUM ] , zkc . get Default ACL ( ) , Create Mode . PERSISTENT ) ; }
public static Executor create Task Distributor ( ) { return Executors . new Cached Thread Pool ( create Thread Factory ( Thread . NORM PRIORITY , STRING ) ) ; }
public String process ( ) { while ( off < count ) { while ( off < count ) { char ch = text [ off ] ; if ( ! is Special ( ch ) ) { break ; } off ++ ; } if ( ! acronym ( ) ) { token ( ) ; number ( ) ; } } return builder . to String ( ) ; }
public static String bytes To Bin Hex ( byte [ ] data , int n Start Pos , int n Num Of Bytes ) { String Builder sbuf = new String Builder ( ) ; sbuf . set Length ( n Num Of Bytes << NUM ) ; int n Pos = NUM ; for ( int nI = NUM ; nI < n Num Of Bytes ; nI ++ ) { sbuf . set Char At ( n Pos ++ , HEXTAB [ ( data [ nI + n Start Pos ] > > NUM ) & NUM ] ) ; sbuf . set Char At ( n Pos ++ , HEXTAB [ data [ nI + n Start Pos ] & NUM ] ) ; } return sbuf . to String ( ) ; }
private static int [ ] mult 128 ( int [ ] a , int [ ] b ) { int [ ] result = new int [ NUM ] ; int [ ] a0 = new int [ NUM ] ; System . arraycopy ( a , NUM , a0 , NUM , Math . min ( NUM , a . length ) ) ; int [ ] a1 = new int [ NUM ] ; if ( a . length > NUM ) { System . arraycopy ( a , NUM , a1 , NUM , Math . min ( NUM , a . length - NUM ) ) ; } int [ ] b0 = new int [ NUM ] ; System . arraycopy ( b , NUM , b0 , NUM , Math . min ( NUM , b . length ) ) ; int [ ] b1 = new int [ NUM ] ; if ( b . length > NUM ) { System . arraycopy ( b , NUM , b1 , NUM , Math . min ( NUM , b . length - NUM ) ) ; } if ( a1 [ NUM ] == NUM && b1 [ NUM ] == NUM ) { if ( a1 [ NUM ] != NUM || b1 [ NUM ] != NUM ) { int [ ] c = mult 32 ( a1 [ NUM ] , b1 [ NUM ] ) ; result [ NUM ] ^= c [ NUM ] ; result [ NUM ] ^= c [ NUM ] ; result [ NUM ] ^= c [ NUM ] ; result [ NUM ] ^= c [ NUM ] ; } } else { int [ ] c = mult 64 ( a1 , b1 ) ; result [ NUM ] ^= c [ NUM ] ; result [ NUM ] ^= c [ NUM ] ; result [ NUM ] ^= c [ NUM ] ^ c [ NUM ] ; result [ NUM ] ^= c [ NUM ] ^ c [ NUM ] ; result [ NUM ] ^= c [ NUM ] ; result [ NUM ] ^= c [ NUM ] ; } a1 [ NUM ] ^= a0 [ NUM ] ; a1 [ NUM ] ^= a0 [ NUM ] ; b1 [ NUM ] ^= b0 [ NUM ] ; b1 [ NUM ] ^= b0 [ NUM ] ; if ( a1 [ NUM ] == NUM && b1 [ NUM ] == NUM ) { int [ ] d = mult 32 ( a1 [ NUM ] , b1 [ NUM ] ) ; result [ NUM ] ^= d [ NUM ] ; result [ NUM ] ^= d [ NUM ] ; } else { int [ ] d = mult 64 ( a1 , b1 ) ; result [ NUM ] ^= d [ NUM ] ; result [ NUM ] ^= d [ NUM ] ; result [ NUM ] ^= d [ NUM ] ; result [ NUM ] ^= d [ NUM ] ; } if ( a0 [ NUM ] == NUM && b0 [ NUM ] == NUM ) { int [ ] e = mult 32 ( a0 [ NUM ] , b0 [ NUM ] ) ; result [ NUM ] ^= e [ NUM ] ; result [ NUM ] ^= e [ NUM ] ; result [ NUM ] ^= e [ NUM ] ; result [ NUM ] ^= e [ NUM ] ; } else { int [ ] e = mult 64 ( a0 , b0 ) ; result [ NUM ] ^= e [ NUM ] ; result [ NUM ] ^= e [ NUM ] ; result [ NUM ] ^= e [ NUM ] ^ e [ NUM ] ; result [ NUM ] ^= e [ NUM ] ^ e [ NUM ] ; result [ NUM ] ^= e [ NUM ] ; result [ NUM ] ^= e [ NUM ] ; } return result ; }
public static void update Last ( ) { Client Utils . last Update = System . current Time Millis ( ) ; }
public Replica Sets ( Collection < Replica Set > rs Specs ) { if ( rs Specs != null ) { rs Specs . for Each ( null ) ; } Collections . sort ( non Replica Sets ) ; }
static private String BYTE Max ( ) { byte temp Value = Byte . MAX VALUE ; return String . value Of ( temp Value ) ; }
public static Executor create Task Distributor ( ) { return Executors . new Cached Thread Pool ( create Thread Factory ( Thread . NORM PRIORITY , STRING ) ) ; }
protected Path Node path Node ( String pattern ) { final String seq [ ] = pattern . split ( STRING ) ; final Path Elt elements [ ] = new Path Elt [ seq . length ] ; Path Mod mod = null ; for ( int i = NUM ; i < seq . length ; i ++ ) { final String s = seq [ i ] ; boolean inverse = s . char At ( NUM ) == STRING ; switch ( s . char At ( s . length ( ) - NUM ) ) { case STRING : mod = Path Mod . ZERO OR MORE ; break ; case STRING : mod = Path Mod . ONE OR MORE ; break ; case STRING : mod = Path Mod . ZERO OR ONE ; break ; } String c = s . substring ( inverse ? NUM : NUM , s . length ( ) - ( mod != null ? NUM : NUM ) ) ; elements [ i ] = new Path Elt ( constant Node ( c ) , inverse , mod ) ; } return new Path Node ( new Path Alternative ( new Path Sequence ( elements ) ) ) ; }
@ Override public int startup New Worker ( int priority ) { int actual Workers Started = startup New Worker ( priority , null , null ) ; return actual Workers Started ; }
public void add Impl Interface ( String iname ) { impl Interfaces . add ( iname ) ; }
private static synchronized boolean check Folder Permissions ( String Builder a String Builder , String a Directory ) { File directory = new File ( a Directory ) ; if ( ! directory . exists ( ) ) { directory . mkdirs ( ) ; } if ( ! directory . can Read ( ) ) { a String Builder . append ( STRING + directory + STRING + STRING ) ; return BOOL ; } if ( ! directory . can Write ( ) ) { a String Builder . append ( STRING + directory + STRING + STRING ) ; return BOOL ; } return BOOL ; }
protected Qualified Item [ ] parse Qualified Items ( final String [ ] arguments , final Version Spec default Version , final boolean allow Version Range , final int start Index ) { Check . not Null ( arguments , STRING ) ; final List < Qualified Item > items = new Array List < Qualified Item > ( arguments . length ) ; for ( int i = start Index ; i < arguments . length ; i ++ ) { final String arg = arguments [ i ] ; if ( ! String Util . is Null Or Empty ( arg ) ) { try { final Qualified Item qi = new Qualified Item ( arg , Version Control Constants . AUTHENTICATED USER , default Version , allow Version Range ) ; items . add ( qi ) ; } catch ( final Version Spec Parse Exception e ) { report Wrong Argument ( arg , e ) ; } catch ( final Label Spec Parse Exception e ) { report Wrong Argument ( arg , e ) ; } } } return items . to Array ( new Qualified Item [ items . size ( ) ] ) ; }
public Eip Editor ( ) { super ( ) ; initialize Editing Domain ( ) ; }
public boolean delete Entry ( Basic Pool Entry entry ) { final boolean found = free Entries . remove ( entry ) ; if ( found ) num Entries -- ; return found ; }
@ Deprecated public void request Contact Capabilities ( Contact Id contact ) throws Rcs Service Not Registered Exception , Rcs Service Not Available Exception , Rcs Generic Exception { if ( m Api == null ) { throw new Rcs Service Not Available Exception ( ) ; } try { List < Contact Id > list Of Contacts = new Array List < > ( ) ; list Of Contacts . add ( contact ) ; m Api . request Contact Capabilities 2 ( list Of Contacts ) ; } catch ( Exception e ) { Rcs Illegal Argument Exception . assert Exception ( e ) ; Rcs Service Not Registered Exception . assert Exception ( e ) ; throw new Rcs Generic Exception ( e ) ; } }
public Conversation Service ( final String version Date , String username , String password ) { this ( version Date ) ; set Username And Password ( username , password ) ; }
public Custom Optional < Kinesis Record > next ( ) throws Transient Kinesis Exception { read More If Necessary ( ) ; if ( data . is Empty ( ) ) { return Custom Optional . absent ( ) ; } else { Kinesis Record record = data . remove First ( ) ; checkpoint = checkpoint . move After ( record ) ; return Custom Optional . of ( record ) ; } }
@ Override public final synchronized void add Remove Statements ( Collection < Statement > added , Collection < Statement > removed ) throws IO Exception { Map Of List Maps < Resource , String , Statement > rs Added = new Map Of List Maps < Resource , String , Statement > ( ) ; Map Of List Maps < Resource , String , Statement > rs Removed = new Map Of List Maps < Resource , String , Statement > ( ) ; Hash Set < Resource > resources = new Hash Set < Resource > ( ) ; for ( Statement s : added ) { rs Added . add ( s . get Subject ( ) , Search Fields . get Context ID ( s . get Context ( ) ) , s ) ; resources . add ( s . get Subject ( ) ) ; } for ( Statement s : removed ) { rs Removed . add ( s . get Subject ( ) , Search Fields . get Context ID ( s . get Context ( ) ) , s ) ; resources . add ( s . get Subject ( ) ) ; } logger . debug ( STRING + removed . size ( ) + STRING + added . size ( ) + STRING ) ; Bulk Updater updater = new Bulk Update ( ) ; for ( Resource resource : resources ) { Map < String , List < Statement > > stmts To Remove = rs Removed . get ( resource ) ; Map < String , List < Statement > > stmts To Add = rs Added . get ( resource ) ; Set < String > contexts To Update = new Hash Set < String > ( stmts To Add . key Set ( ) ) ; contexts To Update . add All ( stmts To Remove . key Set ( ) ) ; Map < String , Search Document > docs By Context = new Hash Map < String , Search Document > ( ) ; String resource Id = Search Fields . get Resource ID ( resource ) ; Iterable < ? extends Search Document > documents = get Documents ( resource Id ) ; for ( Search Document doc : documents ) { docs By Context . put ( doc . get Context ( ) , doc ) ; } for ( String context Id : contexts To Update ) { String id = Search Fields . form Id String ( resource Id , context Id ) ; Search Document document = docs By Context . get ( context Id ) ; if ( document == null ) { document = new Document ( id , resource Id , context Id ) ; List < Statement > list = stmts To Add . get ( context Id ) ; if ( list != null ) { for ( Statement s : list ) { add Property ( s , document ) ; } } updater . add ( document ) ; if ( stmts To Remove . contains Key ( context Id ) ) logger . info ( STRING , resource , context Id ) ; } else { Map < String , Set < String > > removed Of Resource = null ; { List < Statement > removed Statements = stmts To Remove . get ( context Id ) ; if ( removed Statements != null && ! removed Statements . is Empty ( ) ) { removed Of Resource = new Hash Map < String , Set < String > > ( ) ; for ( Statement r : removed Statements ) { String val = Search Fields . get Literal Property Value As String ( r ) ; if ( val != null ) { String field = Search Fields . get Property Field ( r . get Predicate ( ) ) ; Set < String > removed Values = removed Of Resource . get ( field ) ; if ( removed Values == null ) { removed Values = new Hash Set < String > ( ) ; removed Of Resource . put ( field , removed Values ) ; } removed Values . add ( val ) ; } } } } Search Document new Document = new Document ( id , resource Id , context Id ) ; boolean mutated = copy Document ( new Document , document , removed Of Resource ) ; { List < Statement > added To Resource = stmts To Add . get ( context Id ) ; String val ; if ( added To Resource != null && ! added To Resource . is Empty ( ) ) { Property Cache property Cache = new Property Cache ( new Document ) ; for ( Statement s : added To Resource ) { val = Search Fields . get Literal Property Value As String ( s ) ; if ( val != null ) { String field = Search Fields . get Property Field ( s . get Predicate ( ) ) ; if ( ! property Cache . has Property ( field , val ) ) { add Property ( s , new Document ) ; mutated = BOOL ; } } } } } int nr Properties = count Property Values ( new Document ) ; if ( nr Properties > NUM ) { if ( mutated ) { updater . update ( new Document ) ; } } else { updater . delete ( document ) ; } } } } updater . end ( ) ; }
Object to Type ( String value , String pattern , Locale locale ) { Calendar calendar = to Calendar ( value , pattern , locale ) ; return to Type ( calendar ) ; }
private Snmp Pdu Packet execute Sub Request ( Snmp Pdu Packet req , Object user Data ) { int error Status = Snmp Definitions . snmp Rsp No Error ; int i ; if ( req . type == pdu Set Request Pdu ) { i = NUM ; for ( Enumeration < Snmp Sub Request Handler > e = subs . elements ( ) ; e . has More Elements ( ) ; i ++ ) { Snmp Sub Request Handler sub = e . next Element ( ) ; sub . set User Data ( user Data ) ; sub . type = pdu Walk Request ; sub . run ( ) ; sub . type = pdu Set Request Pdu ; if ( sub . get Error Status ( ) != Snmp Definitions . snmp Rsp No Error ) { if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING ) ; } return new Error Response Pdu ( req , error Status , sub . get Error Index ( ) + NUM ) ; } } } i = NUM ; for ( Enumeration < Snmp Sub Request Handler > e = subs . elements ( ) ; e . has More Elements ( ) ; i ++ ) { Snmp Sub Request Handler sub = e . next Element ( ) ; sub . set User Data ( user Data ) ; sub . run ( ) ; if ( sub . get Error Status ( ) != Snmp Definitions . snmp Rsp No Error ) { if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING ) ; } return new Error Response Pdu ( req , error Status , sub . get Error Index ( ) + NUM ) ; } } return null ; }
Method ( Method Doc method Doc ) { this . method Doc = method Doc ; exception Types = method Doc . thrown Exceptions ( ) ; Arrays . sort ( exception Types , new Class Doc Comparator ( ) ) ; operation String = compute Operation String ( ) ; name And Descriptor = method Doc . name ( ) + Util . method Descriptor Of ( method Doc ) ; method Hash = compute Method Hash ( ) ; }
public Deterministic Key ( Immutable List < Child Number > child Number Path , byte [ ] chain Code , Lazy EC Point public As Point , @ Nullable Big Integer priv , @ Nullable Deterministic Key parent ) { super ( priv , compress Point ( check Not Null ( public As Point ) ) ) ; check Argument ( chain Code . length == NUM ) ; this . parent = parent ; this . child Number Path = check Not Null ( child Number Path ) ; this . chain Code = Arrays . copy Of ( chain Code , chain Code . length ) ; this . depth = parent == null ? NUM : parent . depth + NUM ; this . parent Fingerprint = ( parent != null ) ? parent . get Fingerprint ( ) : NUM ; }
private static void s ua Col Sum Lt Ge ( Matrix Block in , Matrix Block out , double [ ] bv , Binary Operator b Op ) throws DML Runtime Exception { int agg 0 = sum Row Sum Gt Le Col Sum Lt Ge ( NUM , bv , b Op ) ; out . allocate Dense Block ( BOOL ) ; Arrays . fill ( out . get Dense Block ( ) , NUM , out . get Num Columns ( ) , agg 0 ) ; if ( agg 0 != NUM ) out . set Non Zeros ( out . get Num Columns ( ) ) ; if ( in . is Empty Block ( BOOL ) ) return ; Sparse Block sblock = in . get Sparse Block ( ) ; for ( int j = NUM ; j < sblock . num Rows ( ) ; j ++ ) if ( ! sblock . is Empty ( j ) ) { int apos = sblock . pos ( j ) ; int alen = sblock . size ( j ) ; int [ ] aix = sblock . indexes ( j ) ; double [ ] avals = sblock . values ( j ) ; for ( int i = apos ; i < apos + alen ; i ++ ) { int cnt = sum Row Sum Gt Le Col Sum Lt Ge ( avals [ i ] , bv , b Op ) ; out . quick Set Value ( NUM , aix [ i ] , cnt ) ; } } }
public Held Locks Grant ( Big Integer grant Id ) { this . grant Id = Preconditions . check Not Null ( grant Id ) ; creation Date Ms = System . current Time Millis ( ) ; expiration Date Ms = - NUM ; lock Map = Lock Collections . of ( ) ; lock Timeout = null ; version Id = null ; }
public void test Pos Neg First Shorter ( ) { byte a Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { - NUM , NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , - NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . and ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public void remove From All Listeners ( Map Bean map Bean ) { if ( map Bean != null ) { remove Zoom Listener ( ( Zoom Listener ) map Bean ) ; map Bean . remove Projection Listener ( this ) ; scale Field . set Text ( STRING ) ; } }
public void test Bug 19169 ( ) throws Exception { Mysql Data Source to Serialize = new Mysql Data Source ( ) ; to Serialize . set Zero Date Time Behavior ( STRING ) ; boolean test Boolean Flag = ! to Serialize . get Allow Load Local Infile ( ) ; to Serialize . set Allow Load Local Infile ( test Boolean Flag ) ; int test Int Flag = to Serialize . get Blob Send Chunk Size ( ) + NUM ; to Serialize . set Blob Send Chunk Size ( String . value Of ( test Int Flag ) ) ; Byte Array Output Stream b Out = new Byte Array Output Stream ( ) ; Object Output Stream obj Out = new Object Output Stream ( b Out ) ; obj Out . write Object ( to Serialize ) ; obj Out . flush ( ) ; Object Input Stream obj In = new Object Input Stream ( new Byte Array Input Stream ( b Out . to Byte Array ( ) ) ) ; Mysql Data Source thawed Ds = ( Mysql Data Source ) obj In . read Object ( ) ; assert Equals ( STRING , thawed Ds . get Zero Date Time Behavior ( ) ) ; assert Equals ( test Boolean Flag , thawed Ds . get Allow Load Local Infile ( ) ) ; assert Equals ( test Int Flag , thawed Ds . get Blob Send Chunk Size ( ) ) ; }
public static < T > Future W < T > of Supplier ( final Supplier < T > s ) { return Future W . of ( Completable Future . supply Async ( s ) ) ; }
@ Override public void to Data ( Data Output out ) throws IO Exception { super . to Data ( out ) ; out . write Long ( refresh Interval ) ; Data Serializer . write Object Array ( alert Defs , out ) ; }
public static boolean is String ( String str ) { return null != string Hash Table . get ( str ) ; }
public void add Changing Listener ( On Wheel Changed Listener listener ) { changing Listeners . add ( listener ) ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return BOOL ; } if ( obj == null ) { return BOOL ; } if ( get Class ( ) != obj . get Class ( ) ) { return BOOL ; } Diff other = ( Diff ) obj ; if ( operation != other . operation ) { return BOOL ; } if ( text == null ) { if ( other . text != null ) { return BOOL ; } } else if ( ! text . equals ( other . text ) ) { return BOOL ; } return BOOL ; }
protected abstract void perform Deployer Action On Single Deployable ( org . codehaus . cargo . container . deployer . Deployer deployer , org . codehaus . cargo . container . deployable . Deployable deployable , org . codehaus . cargo . container . deployer . Deployable Monitor monitor ) ;
@ Override public Tree < String > extract Best Max Rule Parse ( int start , int end , List < String > sentence ) { return extract Best Max Rule Parse 1 ( start , end , NUM , sentence ) ; }
@ Override public int hash Code ( ) { if ( hash == NUM ) { int result = NUM ; result = NUM * result + range . hash Code ( ) ; long bits Weight = Double . double To Long Bits ( weight ) ; result = NUM * result + ( int ) ( bits Weight ^ ( bits Weight > > > NUM ) ) ; hash = result ; } return hash ; }
private Instances vote Dataset ( Instances dataset ) throws Exception { for ( int i = NUM ; i < dataset . num Instances ( ) ; i ++ ) { Instance inst = dataset . first Instance ( ) ; inst = voted Reclassify Example ( inst ) ; dataset . add ( inst ) ; dataset . delete ( NUM ) ; } return dataset ; }
public void test Compare To Pos Pos 1 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; assert Equals ( NUM , a Number . compare To ( b Number ) ) ; }
@ Override public String choose Client Alias ( final String [ ] key Type , final Principal [ ] issuers , final Socket socket ) { if ( key Manager != null ) { return key Manager . choose Client Alias ( key Type , issuers , socket ) ; } return null ; }
CSS Element parse CSS ( Input Stream Reader r , HTML Component html C ) throws IO Exception { Ext Input Stream Reader er = new Ext Input Stream Reader ( r ) ; return parse CSS ( er , html C , null , null ) ; }
protected Pooled Connection create ( boolean increment Counter ) { if ( increment Counter ) size . increment And Get ( ) ; Pooled Connection con = new Pooled Connection ( get Pool Properties ( ) , this ) ; return con ; }
void release ( ) { if ( sd Buffer != null ) sd Buffer . release ( ) ; if ( acl Buffer != null ) acl Buffer . release ( ) ; if ( sid List != null ) { for ( Long sid : sid List ) { Local Free ( sid ) ; } } }
public static void write ( File file , Char Sequence data , Charset encoding , boolean append ) throws IO Exception { String str = data == null ? null : data . to String ( ) ; write String To File ( file , str , encoding , append ) ; }
private void parse Session Expiration Time Info ( Element sess ) { String sid = null ; Long exp Time = null ; String temp = sess . get Attribute ( STRING ) ; if ( temp != null ) { sid = temp ; } temp = sess . get Attribute ( STRING ) ; if ( temp != null ) { exp Time = new Long ( temp ) ; } session Response . add Session For Given UUID ( sid , exp Time ) ; }
public static long generate ( String value ) { int len = value . length ( ) ; long crc = NUM ; for ( int i = NUM ; i < len ; i ++ ) crc = next ( crc , value . char At ( i ) ) ; return crc ; }
public Replace Dialog ( J Text Component text , Find Replace Actions finder Actions ) { super ( Action Utils . get Frame For ( text ) , BOOL ) ; init Components ( ) ; register Key Action ( this ) ; text Component = text ; finder = finder Actions ; text Component . add Caret Listener ( this ) ; set Location Relative To ( text . get Root Pane ( ) ) ; }
public String dump ( X509 Certificate certificate ) throws Asn 1 Exception , IO Exception { try { return dump ( certificate . get Encoded ( ) ) ; } catch ( IO Exception ex ) { throw new Asn 1 Exception ( res . get String ( STRING ) , ex ) ; } catch ( Certificate Encoding Exception ex ) { throw new Asn 1 Exception ( res . get String ( STRING ) , ex ) ; } }
List < String > find In Package ( Test test , String package Name ) { List < String > local Clsss Or Pkgs = new Array List < String > ( ) ; package Name = package Name . replace ( STRING , STRING ) ; Enumeration < URL > urls ; try { urls = classloader . get Resources ( package Name ) ; if ( ! urls . has More Elements ( ) ) { log . warn ( STRING + package Name + STRING ) ; } } catch ( IO Exception ioe ) { log . warn ( STRING + package Name ) ; return local Clsss Or Pkgs ; } return find In Package With Urls ( test , package Name , urls ) ; }
protected abstract Element make Tooltip ( DBID Ref id , double x , double y , double dotsize ) ;
public Cloud Object ( String type , int permissions ) { access Permissions = permissions ; values . put ( Cloud Storage . TYPE FIELD , type ) ; }
private static Decoder Result create Decoder Result From Ambiguous Values ( int ec Level , int [ ] codewords , int [ ] erasure Array , int [ ] ambiguous Indexes , int [ ] [ ] ambiguous Index Values ) throws Format Exception , Checksum Exception { int [ ] ambiguous Index Count = new int [ ambiguous Indexes . length ] ; int tries = NUM ; while ( tries -- > NUM ) { for ( int i = NUM ; i < ambiguous Index Count . length ; i ++ ) { codewords [ ambiguous Indexes [ i ] ] = ambiguous Index Values [ i ] [ ambiguous Index Count [ i ] ] ; } try { return decode Codewords ( codewords , ec Level , erasure Array ) ; } catch ( Checksum Exception ignored ) { } if ( ambiguous Index Count . length == NUM ) { throw Checksum Exception . get Checksum Instance ( ) ; } for ( int i = NUM ; i < ambiguous Index Count . length ; i ++ ) { if ( ambiguous Index Count [ i ] < ambiguous Index Values [ i ] . length - NUM ) { ambiguous Index Count [ i ] ++ ; break ; } else { ambiguous Index Count [ i ] = NUM ; if ( i == ambiguous Index Count . length - NUM ) { throw Checksum Exception . get Checksum Instance ( ) ; } } } } throw Checksum Exception . get Checksum Instance ( ) ; }
public double distance ( Double Vector v ) { double delta X = v . x - x , delta Y = v . y - y , delta Z = v . z - z ; return Math . sqrt ( delta X * delta X + delta Y * delta Y + delta Z * delta Z ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add ( new Option ( STRING + STRING + STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
@ Override public void drop User ( User user , boolean ignore ) throws SQL Exception { String sql = String . format ( STRING , user . get Login ( ) ) ; try { execute ( sql ) ; } catch ( SQL Exception e ) { if ( ! ignore ) { throw e ; } else if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + sql , e ) ; } } }
@ Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case Information Model Package . FUNCTIONBLOCK PROPERTY NAME : return NAME EDEFAULT == null ? name != null : ! NAME EDEFAULT . equals ( name ) ; case Information Model Package . FUNCTIONBLOCK PROPERTY DESCRIPTION : return DESCRIPTION EDEFAULT == null ? description != null : ! DESCRIPTION EDEFAULT . equals ( description ) ; case Information Model Package . FUNCTIONBLOCK PROPERTY TYPE : return type != null ; } return super . e Is Set ( feature ID ) ; }
public double normalized Distance ( double [ ] point 1 , double [ ] point 2 ) throws Exception { return Math . sqrt ( distance 2 ( point 1 , point 2 ) ) / point 1 . length ; }
public static < T > void on Next Dropped ( T t ) { if ( t != null ) { Consumer < Object > hook = Hooks . on Next Dropped Hook ; if ( hook == null ) { throw Exceptions . fail With Cancel ( ) ; } hook . accept ( t ) ; } }
public static int [ ] random Ints ( int max , int count ) { int [ ] vals = new int [ count ] ; for ( int i = NUM ; i < count ; i ++ ) vals [ i ] = SEEDED RANDOM . next Int ( max ) ; return vals ; }
void load Strings ( ) throws IO Exception { int count = m Header Item . string Ids Size ; int string Offsets [ ] = new int [ count ] ; seek ( m Header Item . string Ids Off ) ; for ( int i = NUM ; i < count ; i ++ ) { string Offsets [ i ] = read Int ( ) ; } m Strings = new String [ count ] ; seek ( string Offsets [ NUM ] ) ; for ( int i = NUM ; i < count ; i ++ ) { seek ( string Offsets [ i ] ) ; m Strings [ i ] = read String ( ) ; } }
public boolean add Gps Date Time Stamp Tag ( long timestamp ) { Exif Tag t = build Tag ( TAG GPS DATE STAMP , mGPS Date Stamp Format . format ( timestamp ) ) ; if ( t == null ) { return BOOL ; } set Tag ( t ) ; mGPS Time Stamp Calendar . set Time In Millis ( timestamp ) ; t = build Tag ( TAG GPS TIME STAMP , new Rational [ ] { new Rational ( mGPS Time Stamp Calendar . get ( Calendar . HOUR OF DAY ) , NUM ) , new Rational ( mGPS Time Stamp Calendar . get ( Calendar . MINUTE ) , NUM ) , new Rational ( mGPS Time Stamp Calendar . get ( Calendar . SECOND ) , NUM ) } ) ; if ( t == null ) { return BOOL ; } set Tag ( t ) ; return BOOL ; }
public void add Area ( final Time Section AREA ) { if ( null == AREA ) return ; areas . add ( AREA ) ; Collections . sort ( areas , new Time Section Comparator ( ) ) ; fire Update Event ( SECTION EVENT ) ; }
public String to String ( ) { return Descriptor . to Class Name ( Character . to String ( descriptor ) ) ; }
private void raise IO Exception ( String host , int port , String protocol ) { IO Exception Event io Error = new IO Exception Event ( this , host , port , protocol ) ; sip Provider . handle Event ( io Error , null ) ; set State ( SIP Dialog . TERMINATED STATE ) ; }
public static double incomplete Gamma Complement ( double a , double x ) { double ans , ax , c , yc , r , t , y , z ; double pk , pkm 1 , pkm 2 , qk , qkm 1 , qkm 2 ; if ( x <= NUM || a <= NUM ) return NUM ; if ( x < NUM || x < a ) return NUM - incomplete Gamma ( a , x ) ; ax = a * Math . log ( x ) - x - ln Gamma ( a ) ; if ( ax < - MAXLOG ) return NUM ; ax = Math . exp ( ax ) ; y = NUM - a ; z = x + y + NUM ; c = NUM ; pkm 2 = NUM ; qkm 2 = x ; pkm 1 = x + NUM ; qkm 1 = z * x ; ans = pkm 1 / qkm 1 ; do { c += NUM ; y += NUM ; z += NUM ; yc = y * c ; pk = pkm 1 * z - pkm 2 * yc ; qk = qkm 1 * z - qkm 2 * yc ; if ( qk != NUM ) { r = pk / qk ; t = Math . abs ( ( ans - r ) / r ) ; ans = r ; } else t = NUM ; pkm 2 = pkm 1 ; pkm 1 = pk ; qkm 2 = qkm 1 ; qkm 1 = qk ; if ( Math . abs ( pk ) > big ) { pkm 2 *= biginv ; pkm 1 *= biginv ; qkm 2 *= biginv ; qkm 1 *= biginv ; } } while ( t > MACHEP ) ; return ans * ax ; }
@ Override public Object deserialize Typed From Object ( Json Parser jp , Deserialization Context ctxt ) throws IO Exception , Json Processing Exception { Json Token t = jp . get Current Token ( ) ; if ( t == Json Token . START OBJECT ) { t = jp . next Token ( ) ; } else if ( t == Json Token . START ARRAY ) { return deserialize Typed Using Default Impl ( jp , ctxt , null ) ; } else if ( t != Json Token . FIELD NAME ) { return deserialize Typed Using Default Impl ( jp , ctxt , null ) ; } Token Buffer tb = null ; for ( ; t == Json Token . FIELD NAME ; t = jp . next Token ( ) ) { String name = jp . get Current Name ( ) ; jp . next Token ( ) ; if ( type Property Name . equals ( name ) ) { String type Id = jp . get Text ( ) ; Json Deserializer < Object > deser = find Deserializer ( ctxt , type Id ) ; if ( tb != null ) { jp = Json Parser Sequence . create Flattened ( tb . as Parser ( jp ) , jp ) ; } jp . next Token ( ) ; return deser . deserialize ( jp , ctxt ) ; } if ( tb == null ) { tb = new Token Buffer ( null ) ; } tb . write Field Name ( name ) ; tb . copy Current Structure ( jp ) ; } return deserialize Typed Using Default Impl ( jp , ctxt , tb ) ; }
public boolean is Navigation At Bottom ( ) { return ( m Smallest Width Dp >= NUM || m In Portrait ) ; }
protected int layout Row ( Flow View fv , int row Index , int p0 ) { int p1 = super . layout Row ( fv , row Index , p0 ) ; View row = fv . get View ( row Index ) ; Document doc = fv . get Document ( ) ; Object i18 n Flag = doc . get Property ( Abstract Document . I18 N Property ) ; if ( ( i18 n Flag != null ) && i18 n Flag . equals ( Boolean . TRUE ) ) { int n = row . get View Count ( ) ; if ( n > NUM ) { Abstract Document d = ( Abstract Document ) fv . get Document ( ) ; Element bidi Root = d . get Bidi Root Element ( ) ; byte [ ] levels = new byte [ n ] ; View [ ] reorder = new View [ n ] ; for ( int i = NUM ; i < n ; i ++ ) { View v = row . get View ( i ) ; int bidi Index = bidi Root . get Element Index ( v . get Start Offset ( ) ) ; Element bidi Elem = bidi Root . get Element ( bidi Index ) ; levels [ i ] = ( byte ) Style Constants . get Bidi Level ( bidi Elem . get Attributes ( ) ) ; reorder [ i ] = v ; } Bidi Utils . reorder Visually ( levels , reorder ) ; row . replace ( NUM , n , reorder ) ; } } return p1 ; }
public Generator ( String prop File ) { try { Buffered Input Stream bi = null ; try { bi = new Buffered Input Stream ( new File Input Stream ( prop File ) ) ; props . load ( bi ) ; } finally { if ( bi != null ) { bi . close ( ) ; } } } catch ( Exception e ) { set Default Props ( ) ; } }
public static void clear Logging Behaviors ( ) { synchronized ( logging Behaviors ) { logging Behaviors . clear ( ) ; } }
protected void audit Op ( URI tenant Id , URI user Id , Operation Type Enum op Type , boolean operational Status , String operation Stage , Object ... descparams ) { audit Mgr . record Audit Log ( tenant Id , user Id , EVENT SERVICE TYPE , op Type , System . current Time Millis ( ) , operational Status ? Audit Log Manager . AUDITLOG SUCCESS : Audit Log Manager . AUDITLOG FAILURE , operation Stage , descparams ) ; }
@ Visible For Testing protected Process start Executor Process ( int container ) { return Shell Utils . run A Sync Process ( get Executor Command ( container ) , new File ( Local Context . working Directory ( config ) ) , Integer . to String ( container ) ) ; }
private boolean is Item At Position Selectable ( int position ) { return ! m Unselectable Items . contains ( position ) ; }
public Builder add Engine Settings ( final String engine Name , final List < String > imports , final List < String > static Imports , final List < String > scripts , final Map < String , Object > config ) { if ( null == imports ) throw new Illegal Argument Exception ( STRING ) ; if ( null == static Imports ) throw new Illegal Argument Exception ( STRING ) ; if ( null == scripts ) throw new Illegal Argument Exception ( STRING ) ; final Map < String , Object > m = null == config ? Collections . empty Map ( ) : config ; settings . put ( engine Name , new Engine Settings ( imports , static Imports , scripts , m ) ) ; return this ; }
private void display Popup Menu ( final Mouse Event event ) { final int selected Index = get Selection Index ( event ) ; if ( selected Index != - NUM ) { final J Popup Menu popup Menu = get Popup Menu ( event . get X ( ) , event . get Y ( ) , selected Index ) ; if ( popup Menu != null ) { popup Menu . show ( this , event . get X ( ) , event . get Y ( ) ) ; } } }
protected void handle Selected ( Structured Selection selection ) { I Status status = new Status ( I Status . OK , Platform UI . PLUGIN ID , I Status . OK , EMPTY STRING , null ) ; Object [ ] last Selection = current Selection ; current Selection = selection . to Array ( ) ; if ( selection . size ( ) == NUM ) { status = new Status ( I Status . ERROR , Platform UI . PLUGIN ID , I Status . ERROR , EMPTY STRING , null ) ; if ( last Selection != null && get List Selection Label Decorator ( ) != null ) { list . update ( last Selection , null ) ; } current Selection = null ; } else { status = new Status ( I Status . ERROR , Platform UI . PLUGIN ID , I Status . ERROR , EMPTY STRING , null ) ; List items = selection . to List ( ) ; Object item = null ; I Status temp Status = null ; for ( Iterator it = items . iterator ( ) ; it . has Next ( ) ; ) { Object o = it . next ( ) ; if ( o instanceof Items List Separator ) { continue ; } item = o ; temp Status = validate Item ( item ) ; if ( temp Status . is OK ( ) ) { status = new Status ( I Status . OK , Platform UI . PLUGIN ID , I Status . OK , EMPTY STRING , null ) ; } else { status = temp Status ; break ; } } if ( last Selection != null && get List Selection Label Decorator ( ) != null ) { list . update ( last Selection , null ) ; } if ( get List Selection Label Decorator ( ) != null ) { list . update ( current Selection , null ) ; } } refresh Details ( ) ; update Status ( status ) ; }
public Linked List < Diff > diff main ( String text 1 , String text 2 , boolean checklines ) { long deadline ; if ( Diff Timeout <= NUM ) { deadline = Long . MAX VALUE ; } else { deadline = System . current Time Millis ( ) + ( long ) ( Diff Timeout * NUM ) ; } return diff main ( text 1 , text 2 , checklines , deadline ) ; }
private void update Alt Deviceid ( Network FC Zone Info fabric Info , String fabric Id , String fabric WWN , String key , Map < String , Network Lite > fabric Id 2 Network ) { if ( fabric Info != null && fabric Info . get Alt Network Device Id ( ) == null ) { if ( fabric Id 2 Network . get ( key ) == null ) { Network Lite network = Network Util . get Network Lite By Fabric Id ( fabric Id , fabric WWN , db Client ) ; if ( network != null ) { fabric Id 2 Network . put ( key , network ) ; URI id = fabric Info . get Network Device Id ( ) ; for ( String str Uri : network . get Network Systems ( ) ) { if ( ! str Uri . equals ( id . to String ( ) ) ) { id = URI . create ( str Uri ) ; break ; } } fabric Info . set Alt Network Device Id ( id ) ; } } } }
public static Network Info from Version ( final byte version ) { for ( final Network Info info : KNOWN NETWORKS ) { if ( version == info . get Version ( ) ) { return info ; } } throw new Illegal Argument Exception ( String . format ( STRING , version ) ) ; }
public static String lcfirst ( String input ) { return with First ( input , null ) ; }
public void write ( Byte Code Writer out ) throws IO Exception { out . write UTF 8 Const ( get Name ( ) ) ; Temp Output Stream ts = new Temp Output Stream ( ) ; Byte Code Writer o2 = new Byte Code Writer ( ts , out . get Java Class ( ) ) ; o2 . write Short ( exceptions . size ( ) ) ; for ( int i = NUM ; i < exceptions . size ( ) ; i ++ ) { String exn = exceptions . get ( i ) ; o2 . write Class ( exn ) ; } ts . close ( ) ; out . write Int ( ts . get Length ( ) ) ; Temp Buffer ptr = ts . get Head ( ) ; for ( ; ptr != null ; ptr = ptr . next ( ) ) out . write ( ptr . buffer ( ) , NUM , ptr . length ( ) ) ; ts . destroy ( ) ; }
public synchronized Addressbook Entry remove ( String name , Set < String > categories To Remove ) { name = String Util . to Lower Case ( name ) ; Addressbook Entry current Entry = entries . get ( name ) ; if ( current Entry != null ) { Set < String > current Categories = current Entry . get Categories ( ) ; for ( String category : categories To Remove ) { current Categories . remove ( category ) ; } Addressbook Entry changed Entry = new Addressbook Entry ( name , current Categories ) ; entries . put ( name , changed Entry ) ; if ( ! current Entry . equals Fully ( changed Entry ) ) { save On Change ( ) ; } return changed Entry ; } return null ; }
public static byte [ ] decode ( byte [ ] input , int offset , int len , int flags ) { Decoder decoder = new Decoder ( flags , new byte [ len * NUM / NUM ] ) ; if ( ! decoder . process ( input , offset , len , BOOL ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( decoder . op == decoder . output . length ) { return decoder . output ; } byte [ ] temp = new byte [ decoder . op ] ; System . arraycopy ( decoder . output , NUM , temp , NUM , decoder . op ) ; return temp ; }
public String shortest Match ( String input ) { Trie Node node = root ; for ( int i = input . length ( ) - NUM ; i >= NUM ; i -- ) { node = node . get Child ( input . char At ( i ) ) ; if ( node == null ) return null ; if ( node . is Terminal ( ) ) return input . substring ( i ) ; } return null ; }
public static boolean is Windows 95 ( ) { return os Name . index Of ( STRING ) > - NUM && os Version . equals ( STRING ) ; }
public static RH Extension has RH Extensions ( Config Impl config , Extension Defintion ed ) throws Page Exception , SAX Exception , IO Exception { XML Config Admin admin = new XML Config Admin ( config , null ) ; return admin . has RH Extensions ( config , ed ) ; }
public void add Query To History ( String sql ) { query History . remove ( sql ) ; query History . add First ( sql ) ; while ( history Size >= NUM && query History . size ( ) > history Size ) { query History . remove Last ( ) ; } }
public String Builder encode Body ( String Builder retval ) { retval . append ( LESS THAN ) ; error Info . encode ( retval ) ; retval . append ( GREATER THAN ) ; if ( ! parameters . is Empty ( ) ) { retval . append ( SEMICOLON ) ; parameters . encode ( retval ) ; } return retval ; }
public final < R > Parallel Flux < R > reduce ( Supplier < R > initial Supplier , Bi Function < R , T , R > reducer ) { Objects . require Non Null ( initial Supplier , STRING ) ; Objects . require Non Null ( reducer , STRING ) ; return on Assembly ( new Parallel Reduce < > ( this , initial Supplier , reducer ) ) ; }
private void handle Button Event ( final Event event ) { switch ( event . type ) { case SWT . Focus In : { handle Focus Events ( SWT . Focus In ) ; break ; } case SWT . Selection : { change Visibility Of Popup Window ( ! is Dropped ( ) ) ; break ; } } }
private void perform Update Operations ( Context context , Request request , Json Value after Value , Json Value before Value ) throws Resource Exception { final String managed Id = get Managed Object Id ( context ) ; activity Logger . log ( context , request , STRING , get Managed Object Path ( context ) , before Value , after Value , Status . SUCCESS ) ; managed Object Set Service . update ( context , new Update Request ( managed Id , after Value ) , managed Id , null , before Value , after Value , new Hash Set < > ( Arrays . as List ( property Ptr ) ) , new Hash Set < > ( Arrays . as List ( property Ptr ) ) ) ; }
private boolean has Next Inet Socket Address ( ) { return next Inet Socket Address Index < inet Socket Addresses . size ( ) ; }
public static Boolean can String Be Inline Encoded ( String skey ) { if ( skey . length ( ) > get Max Inline String Key ( MAX LONGS USED FOR STRING KEY , BOOL ) ) { return null ; } if ( is Byte Encoding Ok ( skey ) ) { return Boolean . TRUE ; } else { if ( skey . length ( ) > get Max Inline String Key ( MAX LONGS USED FOR STRING KEY , BOOL ) ) { return null ; } else { return Boolean . FALSE ; } } }
public Builder ( Date created , Date last Modified ) { this . created = created != null ? new Date ( created . get Time ( ) ) : null ; this . last Modified = last Modified != null ? new Date ( last Modified . get Time ( ) ) : null ; }
@ Override public void write Byte Stream ( Input Stream is ) throws IO Exception { while ( BOOL ) { int len = SIZE - offset - NUM ; if ( len < NUM ) { flush Buffer ( ) ; len = SIZE - offset - NUM ; } len = is . read ( buffer , offset + NUM , len ) ; if ( len <= NUM ) { buffer [ offset ++ ] = BC BINARY DIRECT ; return ; } buffer [ offset + NUM ] = ( byte ) BC BINARY CHUNK ; buffer [ offset + NUM ] = ( byte ) ( len > > NUM ) ; buffer [ offset + NUM ] = ( byte ) ( len ) ; offset += len + NUM ; } }
public void remove Selection Change Listener ( final Selection Change Listener listener ) { check Widget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR NULL ARGUMENT ) ; } if ( selection Change Listeners == null ) { return ; } selection Change Listeners . remove ( listener ) ; }
protected final void refresh Loading Views Size ( ) { final int maximum Pull Scroll = ( int ) ( get Maximum Pull Scroll ( ) * NUM ) ; int p Left = get Padding Left ( ) ; int p Top = get Padding Top ( ) ; int p Right = get Padding Right ( ) ; int p Bottom = get Padding Bottom ( ) ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Width ( maximum Pull Scroll ) ; p Left = - maximum Pull Scroll ; } else { p Left = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Width ( maximum Pull Scroll ) ; p Right = - maximum Pull Scroll ; } else { p Right = NUM ; } break ; case VERTICAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Height ( maximum Pull Scroll ) ; p Top = - maximum Pull Scroll ; } else { p Top = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Height ( maximum Pull Scroll ) ; p Bottom = - maximum Pull Scroll ; } else { p Bottom = NUM ; } break ; } if ( DEBUG ) { Log . d ( LOG TAG , String . format ( STRING , p Left , p Top , p Right , p Bottom ) ) ; } set Padding ( p Left , p Top , p Right , p Bottom ) ; }
public Track add Track ( String name , String type ) { Track track = get Track By Name ( name , type ) ; if ( track == null ) { Id Number ++ ; String id = id + STRING + Integer . to String ( Id Number ) ; log . debug ( STRING , type , get Name ( ) , name , id ) ; track = new Track ( id , name , type , this ) ; register ( track ) ; } reset Moves ( ) ; return track ; }
SQ Lite Loader Observer register Loader ( final SQ Lite Loader loader , final String table ) { Logger . d ( TAG , STRING , table ) ; final SQ Lite Loader Observer entry = new SQ Lite Loader Observer ( loader , table ) ; m Active Loaders . add ( entry ) ; return entry ; }
public void unbind Tree ( Container ui ) { int component Count = ui . get Component Count ( ) ; for ( int iter = NUM ; iter < component Count ; iter ++ ) { Component c = ui . get Component At ( iter ) ; if ( c instanceof Container ) { unbind Tree ( ( Container ) c ) ; continue ; } String bind = c . get Cloud Bound Property ( ) ; if ( bind != null && bind . length ( ) > NUM ) { String attribute Name = c . get Cloud Destination Property ( ) ; if ( attribute Name != null ) { unbind Property ( c , bind ) ; } } } }
protected List < Item > to Items ( List < Model > models ) { if ( models == null ) { return Collections . empty List ( ) ; } int size = models . size ( ) ; List < Item > items = new Array List < > ( size ) ; for ( int i = NUM ; i < size ; i ++ ) { items . add ( to Item ( models . get ( i ) ) ) ; } return items ; }
public void apply ( Filter Set filter Set , Filter Service Granular Lock Factory lock Factory ) { for ( Filter Set Entry entry : filter Set . get Filters ( ) ) { add ( entry . get Filter Value Set ( ) , entry . get Handle ( ) , lock Factory ) ; } }
public void add Constraint Command ( Define Command command ) { if ( command instanceof Create Index ) { constraint Commands . add ( command ) ; } else { Alter Table Add Constraint con = ( Alter Table Add Constraint ) command ; boolean already Set ; if ( con . get Type ( ) == Command Interface . ALTER TABLE ADD CONSTRAINT PRIMARY KEY ) { already Set = set Primary Key Columns ( con . get Index Columns ( ) ) ; } else { already Set = BOOL ; } if ( ! already Set ) { constraint Commands . add ( command ) ; } } }
public void test Invite Cancel ( ) { do Cancel Test ( BOOL ) ; }
private static byte [ ] lmv 2 Response ( final byte [ ] hash , final byte [ ] challenge , final byte [ ] client Data ) throws Authentication Exception { final HMACMD 5 hmac MD 5 = new HMACMD 5 ( hash ) ; hmac MD 5 . update ( challenge ) ; hmac MD 5 . update ( client Data ) ; final byte [ ] mac = hmac MD 5 . get Output ( ) ; final byte [ ] lmv 2 Response = new byte [ mac . length + client Data . length ] ; System . arraycopy ( mac , NUM , lmv 2 Response , NUM , mac . length ) ; System . arraycopy ( client Data , NUM , lmv 2 Response , mac . length , client Data . length ) ; return lmv 2 Response ; }
static < E > E check Type ( E obj , Class < ? extends E > type ) { if ( obj != null && ! type . is Instance ( obj ) ) { throw new Class Cast Exception ( STRING + obj . get Class ( ) + STRING + type ) ; } return obj ; }
public void test Value Of Long Positive 1 ( ) { long long Val = NUM ; Big Integer a Number = Big Integer . value Of ( long Val ) ; byte r Bytes [ ] = { NUM , - NUM , - NUM , NUM , - NUM , - NUM , NUM , NUM } ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public void destroy ( ) { m filter Config = null ; }
@ Override public Parcelable on Save Instance State ( ) { String path = m Photo File Path . get ( ) ; if ( path == null ) return null ; Bundle bundle = new Bundle ( ) ; bundle . put String ( STRING , path ) ; return bundle ; }
public static boolean create Folder ( String folder Path ) { if ( ! Text Utils . is Empty ( folder Path ) ) { File folder = new File ( folder Path ) ; return create Folder ( folder ) ; } return BOOL ; }
public void test empty Journal ( ) throws IO Exception , Interrupted Exception , Execution Exception { final File out = File . create Temp File ( get Name ( ) , Options . JNL ) ; try { final Journal src = get Store ( get Properties ( ) ) ; try { final Future < Map < String , Base Index Stats > > f = src . warm Up ( null ) ; final Map < String , Base Index Stats > map = f . get ( ) ; assert Equals ( NUM , map . size ( ) ) ; } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
@ Override public void key Released ( Key Event e ) { char [ ] password 1 = null ; char [ ] password 2 = null ; if ( password Field != null ) { password 1 = password Field . get Password ( ) ; } if ( repeat Password Field != null ) { password 2 = repeat Password Field . get Password ( ) ; } boolean tick Label Visible = BOOL ; if ( password 1 != null && password 2 != null ) { if ( Arrays . equals ( password 1 , password 2 ) ) { tick Label Visible = BOOL ; } } tick Label . set Visible ( tick Label Visible ) ; clear Messages ( ) ; for ( int i = NUM ; i < password 1 . length ; i ++ ) { password 1 [ i ] = NUM ; } for ( int i = NUM ; i < password 2 . length ; i ++ ) { password 2 [ i ] = NUM ; } }
private static Period Formatter And Value select Formatter ( Period days Period ) { int days = days Period . get Days ( ) ; if ( days > NUM ) { return pav ( DAY FORMATTER , days ) ; } int hours = days Period . get Hours ( ) ; if ( hours > NUM ) { return pav ( HOUR FORMATTER , hours ) ; } int minutes = days Period . get Minutes ( ) ; if ( minutes > NUM ) { return pav ( MINUTE FORMATTER , minutes ) ; } int seconds = days Period . get Seconds ( ) ; if ( seconds > NUM ) { return pav ( SECOND FORMATTER , seconds ) ; } return null ; }
void add Arg ( String arg ) { args . add ( arg ) ; }
public java . lang . String Buffer insert ( int offset , float f ) { internal . insert ( offset , f ) ; return this ; }
private void update Gwt 27 On ( I Java Project java Project , List < String > program Args , int index Disabled , int index Enabled , boolean super Dev Mode Enabled ) { if ( index Enabled > - NUM ) { program Args . remove ( index Enabled ) ; } if ( index Disabled > - NUM ) { program Args . remove ( index Disabled ) ; } if ( ! super Dev Mode Enabled ) { program Args . add ( NUM , SUPERDEVMODE DISABLED ARG ) ; } }
default boolean smash Block ( Entity Player player , World world , Block Pos pos , I Block State state , Tool Tier tier ) { Tool Tier required = get Required Tier ( state ) ; if ( required != null && tier . is Greater Than Or Equal To ( required ) ) { float luck = tier . ordinal ( ) * NUM ; List < Item Stack > drops = get Drops ( player , world , pos , state , luck ) ; if ( drops . size ( ) > NUM ) { if ( ! world . is Remote ) { world . set Block To Air ( pos ) ; for ( Item Stack drop : drops ) { spawn As Entity ( world , pos , drop ) ; } } return BOOL ; } } return BOOL ; }
protected String fetch Native Id ( String native Guid ) { String [ ] token = native Guid . split ( VNX File Constants . PLUS SEPERATOR ) ; return token [ token . length - NUM ] ; }
public static String to String ( final double value ) { return Double . to String ( value ) ; }
public long rss ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
public static void init ( Context context , boolean is top ) { camera Manager = new Camera Manager ( context , is top ) ; }
public static Plain Text plain ( float text ) { return plain ( Float . to String ( text ) ) ; }
public final void append ( char value ) { char [ ] chunk ; if ( m first Free < m chunk Size ) chunk = m array [ m last Chunk ] ; else { int i = m array . length ; if ( m last Chunk + NUM == i ) { char [ ] [ ] newarray = new char [ i + NUM ] [ ] ; System . arraycopy ( m array , NUM , newarray , NUM , i ) ; m array = newarray ; } chunk = m array [ ++ m last Chunk ] ; if ( chunk == null ) { if ( m last Chunk == NUM << m rebundle Bits && m chunk Bits < m max Chunk Bits ) { m inner FSB = new Fast String Buffer ( this ) ; } chunk = m array [ m last Chunk ] = new char [ m chunk Size ] ; } m first Free = NUM ; } chunk [ m first Free ++ ] = value ; }
public Socket create Socket ( Inet Address address , int port , Inet Address my Address , int my Port ) throws IO Exception { if ( my Address != null ) { Socket sock = new Socket ( ) ; sock . bind ( new Inet Socket Address ( my Address , NUM ) ) ; try { sock . connect ( new Inet Socket Address ( address , port ) , NUM ) ; } catch ( Socket Timeout Exception e ) { throw new Connect Exception ( STRING + address + STRING + port ) ; } return sock ; } else { Socket sock = new Socket ( ) ; if ( my Port != NUM ) { sock . bind ( new Inet Socket Address ( port ) ) ; } try { sock . connect ( new Inet Socket Address ( address , port ) , NUM ) ; } catch ( Socket Timeout Exception e ) { throw new Connect Exception ( STRING + address + STRING + port ) ; } return sock ; } }
private static void update Cluster Tenant ( Db Client db Client , URI data Center Id , URI tenant Id ) { List < Named Element > clusters Uris = list Children ( db Client , data Center Id , Cluster . class , STRING , STRING ) ; for ( Named Element cluster Uri : clusters Uris ) { Cluster cluster = db Client . query Object ( Cluster . class , cluster Uri . get Id ( ) ) ; if ( cluster != null ) { cluster . set Tenant ( tenant Id ) ; db Client . persist Object ( cluster ) ; } } }
public static int prefix Length ( char [ ] s1 , char [ ] s2 ) { int len = NUM ; int max = Math . min ( s1 . length , s2 . length ) ; for ( int i = NUM ; i < max && s1 [ i ] == s2 [ i ] ; ++ i ) ++ len ; return len ; }
private static boolean is Less Than One Week ( Date date ) { Calendar calendar = Calendar . get Instance ( ) ; calendar . add ( Calendar . DAY OF MONTH , - NUM ) ; return date . after ( calendar . get Time ( ) ) ; }
private int col To Loc ( int col , Vector < Mapping Pair > vec ) { int loc = col ; for ( int i = NUM ; ( i < vec . size ( ) ) && ( vec . element At ( i ) . col <= col ) ; i ++ ) { loc = loc + vec . element At ( i ) . inc ; } return loc ; }
protected boolean [ ] can Handle N Classes ( Attr Types attr Types , int num Classes ) { print ( STRING ) ; print Attribute Summary ( attr Types , Attribute . NOMINAL ) ; print ( STRING ) ; Array List < String > accepts = new Array List < String > ( ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; int num Train = get Num Instances ( ) , num Test = get Num Instances ( ) , missing Level = NUM ; boolean attribute Missing = BOOL , class Missing = BOOL ; int num Attr = NUM , attr Index = NUM ; return run Basic Test ( attr Types , num Attr , attr Index , Attribute . NOMINAL , missing Level , attribute Missing , class Missing , num Train , num Test , num Classes , accepts ) ; }
public Type Variable type Variable ( ) { int id = type Variable List . size ( ) ; type Variable List . add ( null ) ; Type Variable result = new Type Variable ( id , this ) ; type Variable List . set ( id , result ) ; return result ; }
public static char [ ] create Type Parameter Signature ( char [ ] type Parameter Name , char [ ] [ ] bound Signatures ) { int length = bound Signatures . length ; if ( length == NUM ) { return Char Operation . append ( type Parameter Name , C COLON ) ; } int bounds Size = NUM ; for ( int i = NUM ; i < length ; i ++ ) { bounds Size += bound Signatures [ i ] . length + NUM ; } int name Length = type Parameter Name . length ; char [ ] result = new char [ name Length + bounds Size ] ; System . arraycopy ( type Parameter Name , NUM , result , NUM , name Length ) ; int index = name Length ; for ( int i = NUM ; i < length ; i ++ ) { result [ index ++ ] = C COLON ; int bound Length = bound Signatures [ i ] . length ; System . arraycopy ( bound Signatures [ i ] , NUM , result , index , bound Length ) ; index += bound Length ; } return result ; }
void cancel Statement ( String session Id , int statement Id ) { for ( Tcp Server Thread c : New . array List ( running ) ) { if ( c != null ) { c . cancel Statement ( session Id , statement Id ) ; } } }
public static double parse Double ( String s ) { if ( POSITIVE INFINITY . equals ( s ) ) { return Double . POSITIVE INFINITY ; } else if ( NEGATIVE INFINITY . equals ( s ) ) { return Double . NEGATIVE INFINITY ; } else if ( Na N . equals ( s ) ) { return Double . Na N ; } else { s = trim Plus Sign ( s ) ; return Double . parse Double ( s ) ; } }
public void finish Zombie Tasks With Error ( ) { List < Pollable Task > zombie Pollable Tasks ; do { logger . debug ( STRING ) ; Page Request pageable = new Page Request ( NUM , NUM ) ; zombie Pollable Tasks = pollable Task Repository . find Zombie Pollable Tasks ( pageable ) ; for ( Pollable Task zombie Pollable Task : zombie Pollable Tasks ) { mark As Finished With Error ( zombie Pollable Task ) ; } } while ( ! zombie Pollable Tasks . is Empty ( ) ) ; }
public Cookie Entity ( URI uri , Http Cookie cookie ) { this . uri = uri == null ? null : uri . to String ( ) ; this . name = cookie . get Name ( ) ; this . value = cookie . get Value ( ) ; this . comment = cookie . get Comment ( ) ; this . comment URL = cookie . get Comment URL ( ) ; this . discard = cookie . get Discard ( ) ; this . domain = cookie . get Domain ( ) ; long max Age = cookie . get Max Age ( ) ; if ( max Age != - NUM && max Age > NUM ) { this . expiry = ( max Age * NUM ) + System . current Time Millis ( ) ; if ( this . expiry < NUM ) this . expiry = Header Util . get Max Expiry Millis ( ) ; } else this . expiry = - NUM ; this . path = cookie . get Path ( ) ; if ( ! Text Utils . is Empty ( path ) && path . length ( ) > NUM && path . ends With ( STRING ) ) { this . path = path . substring ( NUM , path . length ( ) - NUM ) ; } this . port List = cookie . get Portlist ( ) ; this . secure = cookie . get Secure ( ) ; this . version = cookie . get Version ( ) ; }
public void add Value ( T value ) { list . add First ( value ) ; total += Double . value Of ( value . to String ( ) ) ; trim ( ) ; }
private void update Traffic Mask ( ) { int queue Size = traffic Controlling Sessions . size ( ) ; while ( queue Size > NUM ) { S session = traffic Controlling Sessions . poll ( ) ; if ( session == null ) { return ; } Session State state = get State ( session ) ; switch ( state ) { case OPENED : update Traffic Control ( session ) ; break ; case CLOSING : break ; case OPENING : traffic Controlling Sessions . add ( session ) ; break ; default : throw new Illegal State Exception ( String . value Of ( state ) ) ; } queue Size -- ; } }
public Object create Soft Weak Ref ( Object o ) { return new Weak Reference ( o ) ; }
public boolean has Entries ( ) { return ! f Entries . is Empty ( ) ; }
protected String convert To String ( Object value ) throws Throwable { String result = null ; if ( use Locale Format && value instanceof Number ) { Number Format format = get Format ( ) ; format . set Grouping Used ( BOOL ) ; result = format . format ( value ) ; } else { result = value . to String ( ) ; } return result ; }
private static void decode C 40 Segment ( Bit Source bits , String Builder result ) throws Format Exception { boolean upper Shift = BOOL ; int [ ] c Values = new int [ NUM ] ; int shift = NUM ; do { if ( bits . available ( ) == NUM ) { return ; } int first Byte = bits . read Bits ( NUM ) ; if ( first Byte == NUM ) { return ; } parse Two Bytes ( first Byte , bits . read Bits ( NUM ) , c Values ) ; for ( int i = NUM ; i < NUM ; i ++ ) { int c Value = c Values [ i ] ; switch ( shift ) { case NUM : if ( c Value < NUM ) { shift = c Value + NUM ; } else if ( c Value < C40 BASIC SET CHARS . length ) { char c40 char = C40 BASIC SET CHARS [ c Value ] ; if ( upper Shift ) { result . append ( ( char ) ( c40 char + NUM ) ) ; upper Shift = BOOL ; } else { result . append ( c40 char ) ; } } else { throw Format Exception . get Format Instance ( ) ; } break ; case NUM : if ( upper Shift ) { result . append ( ( char ) ( c Value + NUM ) ) ; upper Shift = BOOL ; } else { result . append ( ( char ) c Value ) ; } shift = NUM ; break ; case NUM : if ( c Value < C40 SHIFT 2 SET CHARS . length ) { char c40 char = C40 SHIFT 2 SET CHARS [ c Value ] ; if ( upper Shift ) { result . append ( ( char ) ( c40 char + NUM ) ) ; upper Shift = BOOL ; } else { result . append ( c40 char ) ; } } else if ( c Value == NUM ) { result . append ( ( char ) NUM ) ; } else if ( c Value == NUM ) { upper Shift = BOOL ; } else { throw Format Exception . get Format Instance ( ) ; } shift = NUM ; break ; case NUM : if ( upper Shift ) { result . append ( ( char ) ( c Value + NUM ) ) ; upper Shift = BOOL ; } else { result . append ( ( char ) ( c Value + NUM ) ) ; } shift = NUM ; break ; default : throw Format Exception . get Format Instance ( ) ; } } } while ( bits . available ( ) > NUM ) ; }
public Esri Shape Export ( OM Graphic List list , Projection proj , String path To File ) { set Graphic List ( list ) ; projection = proj ; file Path = path To File ; DEBUG = logger . is Loggable ( Level . FINE ) ; }
public void clear ( ) { ored Criteria . clear ( ) ; order By Clause = null ; distinct = BOOL ; }
private void check Log Folder ( ) { File folder = new File ( folder Path ) ; if ( ! folder . exists ( ) ) { folder . mkdirs ( ) ; } }
private void test Complete On Timeout times Out ( Integer v ) { long timeout Millis = timeout Millis ( ) ; Completable Future < Integer > f = new Completable Future < > ( ) ; long start Time = System . nano Time ( ) ; assert Same ( f , f . complete On Timeout ( v , timeout Millis , MILLISECONDS ) ) ; assert Same ( v , f . join ( ) ) ; assert True ( millis Elapsed Since ( start Time ) >= timeout Millis ) ; f . complete ( NUM ) ; check Completed Normally ( f , v ) ; }
private synchronized void reschedule ( long millis ) { current Fut = null ; if ( ! closed ) { SCHEDULER . schedule ( null , millis , Time Unit . MILLISECONDS ) ; } else { try { underlying . close ( ) ; } catch ( Exception ex ) { LOG . log ( Level . WARNING , STRING + underlying . config String ( ) , ex ) ; } } }
public static Content Verifier Provider create Default Content Verifier ( Public Key key ) throws Operator Creation Exception { if ( STRING == key . get Algorithm ( ) ) { return SUN VERIFICATION BUILDER . build ( key ) ; } else { return BC VERIFICATION BUILDER . build ( key ) ; } }
public static Uri from File ( File file ) { if ( file == null ) { throw new Null Pointer Exception ( STRING ) ; } Path Part path = Path Part . from Decoded ( file . get Absolute Path ( ) ) ; return new Hierarchical Uri ( STRING , Part . EMPTY , path , Part . NULL , Part . NULL ) ; }
public void add Rule ( final Rule rule ) { rule . set Id ( rule Id Counter ++ ) ; rules . add ( rule ) ; }
public static Object serialize Clone ( final Object obj ) throws IO Exception , Class Not Found Exception { Byte Array Output Stream mem Out = new Byte Array Output Stream ( ) ; Object Output Stream obj Out = new Object Output Stream ( mem Out ) ; obj Out . write Object ( obj ) ; obj Out . close ( ) ; Byte Array Input Stream src = new Byte Array Input Stream ( mem Out . to Byte Array ( ) ) ; Object Input Stream obj Is = new Object Input Stream ( src ) ; return obj Is . read Object ( ) ; }
private static String link For Class Name ( String name ) { return name . replace ( STRING , STRING ) + STRING ; }
protected void handle Element Deleted ( I Editor Input file Editor Input ) { fire Element Deleted ( file Editor Input ) ; }
public void assert Text Present ( String expected , String actual ) { if ( ( actual == null ) || ( ! actual . contains ( expected ) ) ) { throw new Assertion Failed Error ( STRING + expected + STRING + actual + STRING ) ; } }
public void test Using Proxy Selector ( ) throws Exception { Mock Server server = new Mock Server ( STRING ) ; Mock Server proxy = new Mock Server ( STRING ) ; URL url = new URL ( STRING + server . port ( ) ) ; Proxy Selector def PS = Proxy Selector . get Default ( ) ; Proxy Selector . set Default ( new Test Proxy Selector ( server . port ( ) , proxy . port ( ) ) ) ; try { Http URL Connection connection = ( Http URL Connection ) url . open Connection ( ) ; connection . set Connect Timeout ( NUM ) ; connection . set Read Timeout ( NUM ) ; server . start ( ) ; synchronized ( bound ) { if ( ! server . started ) bound . wait ( NUM ) ; } proxy . start ( ) ; synchronized ( bound ) { if ( ! proxy . started ) bound . wait ( NUM ) ; } connection . connect ( ) ; server . join ( ) ; proxy . join ( ) ; assert True ( STRING , connection . using Proxy ( ) ) ; assert True ( STRING , proxy . accepted ) ; connection . disconnect ( ) ; assert True ( STRING , connection . using Proxy ( ) ) ; } finally { Proxy Selector . set Default ( def PS ) ; } }
public String code Clean Pipeline ( String contents ) { if ( contents == null ) { return Values . EMPTYSTRING ; } String Builder index Contents = new String Builder ( ) ; char [ ] first Replacements = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; for ( char c : first Replacements ) { contents = contents . replace ( c , STRING ) ; } index Contents . append ( STRING ) ; index Contents . append ( contents ) ; char [ ] second Replacements = { STRING , STRING , STRING , STRING } ; for ( char c : second Replacements ) { contents = contents . replace ( c , STRING ) ; } index Contents . append ( STRING ) ; index Contents . append ( contents ) ; char [ ] forth Replacements = { STRING , STRING } ; for ( char c : forth Replacements ) { contents = contents . replace ( c , STRING ) ; } index Contents . append ( STRING ) ; index Contents . append ( contents ) ; char [ ] replacements = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; for ( char c : replacements ) { contents = contents . replace ( c , STRING ) ; } index Contents . append ( STRING ) ; index Contents . append ( contents ) ; char [ ] third Replacements = { STRING } ; for ( char c : third Replacements ) { contents = contents . replace ( c , STRING ) ; } index Contents . append ( STRING ) ; index Contents . append ( contents ) ; return index Contents . to String ( ) ; }
public static String mrpa 2 sampa ( String voice Phoneme ) { if ( mrpa 2 sampa . contains Key ( voice Phoneme ) ) return mrpa 2 sampa . get ( voice Phoneme ) ; else return voice Phoneme ; }
public static X Path 2 Filter Container new Instance Intersect ( Document doc , String xpath 2 filter ) { return new X Path 2 Filter Container ( doc , xpath 2 filter , X Path 2 Filter Container . ATT FILTER VALUE INTERSECT ) ; }
public int line To Y ( int line ) { Font Metrics fm = painter . get Font Metrics ( ) ; return ( line - first Line ) * fm . get Height ( ) - ( fm . get Leading ( ) + fm . get Max Descent ( ) ) ; }
public void remove Item Changed Listener ( Item Changed Listener listener ) { item Changed Listeners . remove ( listener ) ; }
public boolean has Ambig Prefix ( ) { return ( name . starts With ( ambig Prefix ) ) ; }
public Ordered Thread Pool Executor ( int maximum Pool Size ) { this ( DEFAULT INITIAL THREAD POOL SIZE , maximum Pool Size , DEFAULT KEEP ALIVE , Time Unit . SECONDS , Executors . default Thread Factory ( ) , null ) ; }
private String parse Malformed ( String url String ) { if ( parts != null && ! parts . is Empty ( ) ) { String ret ; for ( URL Part part : parts ) { switch ( part ) { case PROTOCOL : ret = apply Pattern ( REGEX PROTOCOL , url String ) ; break ; case PORT : ret = apply Pattern ( REGEX PORT , url String ) ; break ; case QUERY : ret = apply Pattern ( REGEX QUERY , url String ) ; break ; case WHOLE : ret = url String ; break ; default : ret = url String ; } if ( ! Strings . is Null Or Empty ( ret ) ) { return ret ; } } } return url String ; }
private boolean relocate ( ) { boolean finished = BOOL ; for ( Relocatable relocatable : this . relocatables ) { finished &= relocatable . relocate ( ) ; } return finished ; }
@ Suppress Warnings ( { STRING , STRING } ) private Map < K , Entry Processor Result > update With Batch ( Grid Cache Operation op , Collection < ? extends K > keys , @ Nullable Iterable < ? > vals , @ Nullable Object [ ] invoke Args , @ Nullable Expiry Policy expiry Plc , Grid Cache Version ver , @ Nullable Cache Entry Predicate [ ] filter , boolean keep Binary , UUID subj Id , String task Name ) throws Ignite Checked Exception { List < Grid Cache Entry Ex > locked = lock Entries ( keys ) ; try { int size = locked . size ( ) ; Map < Object , Object > put Map = null ; Collection < Object > rmv Keys = null ; List < Cache Object > write Vals = null ; Map < K , Entry Processor Result > invoke Res Map = op == TRANSFORM ? U . < K , Entry Processor Result > new Hash Map ( size ) : null ; List < Grid Cache Entry Ex > filtered = new Array List < > ( size ) ; Cache Partial Update Checked Exception err = null ; Iterator < ? > vals Iter = vals != null ? vals . iterator ( ) : null ; boolean intercept = ctx . config ( ) . get Interceptor ( ) != null ; for ( int i = NUM ; i < size ; i ++ ) { Grid Cache Entry Ex entry = locked . get ( i ) ; Object val = vals Iter != null ? vals Iter . next ( ) : null ; if ( val == null && op != DELETE ) throw new Null Pointer Exception ( STRING ) ; try { try { if ( ! ctx . is All Locked ( entry , filter ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + entry + STRING + Arrays . to String ( filter ) + STRING ) ; continue ; } } catch ( Ignite Checked Exception e ) { if ( err == null ) err = partial Update Exception ( ) ; err . add ( F . as List ( entry . key ( ) ) , e ) ; continue ; } if ( op == TRANSFORM ) { ctx . kernal Context ( ) . resource ( ) . inject ( val , Grid Resource Ioc . Annotation Set . ENTRY PROCESSOR , ctx . name ( ) ) ; Entry Processor < Object , Object , Object > entry Processor = ( Entry Processor < Object , Object , Object > ) val ; Cache Object old = entry . inner Get ( null , null , BOOL , BOOL , BOOL , BOOL , BOOL , subj Id , entry Processor , task Name , null , keep Binary ) ; Object old Val = null ; Cache Invoke Entry < Object , Object > invoke Entry = new Cache Invoke Entry < > ( entry . key ( ) , old , entry . version ( ) , keep Binary , entry ) ; Cache Object updated ; Object updated Val = null ; Cache Invoke Result invoke Res = null ; try { Object computed = entry Processor . process ( invoke Entry , invoke Args ) ; updated Val = ctx . unwrap Temporary ( invoke Entry . get Value ( ) ) ; updated = ctx . to Cache Object ( updated Val ) ; if ( computed != null ) invoke Res = Cache Invoke Result . from Result ( ctx . unwrap Temporary ( computed ) ) ; } catch ( Exception e ) { invoke Res = Cache Invoke Result . from Error ( e ) ; updated = old ; } if ( invoke Res != null ) invoke Res Map . put ( ( K ) entry . key ( ) . value ( ctx . cache Object Context ( ) , BOOL ) , invoke Res ) ; if ( updated == null ) { if ( intercept ) { Ignite Bi Tuple < Boolean , ? > interceptor Res = ctx . config ( ) . get Interceptor ( ) . on Before Remove ( new Cache Lazy Entry ( ctx , entry . key ( ) , invoke Entry . key ( ) , old , old Val , keep Binary ) ) ; if ( ctx . cancel Remove ( interceptor Res ) ) continue ; } if ( put Map != null ) { err = update Partial Batch ( filtered , ver , write Vals , put Map , null , expiry Plc , keep Binary , err , subj Id , task Name ) ; put Map = null ; write Vals = null ; filtered = new Array List < > ( ) ; } if ( rmv Keys == null ) rmv Keys = new Array List < > ( size ) ; rmv Keys . add ( entry . key ( ) . value ( ctx . cache Object Context ( ) , BOOL ) ) ; } else { if ( intercept ) { Object interceptor Val = ctx . config ( ) . get Interceptor ( ) . on Before Put ( new Cache Lazy Entry ( ctx , entry . key ( ) , invoke Entry . get Key ( ) , old , old Val , keep Binary ) , updated Val ) ; if ( interceptor Val == null ) continue ; updated = ctx . to Cache Object ( ctx . unwrap Temporary ( interceptor Val ) ) ; } if ( rmv Keys != null ) { err = update Partial Batch ( filtered , ver , null , null , rmv Keys , expiry Plc , keep Binary , err , subj Id , task Name ) ; rmv Keys = null ; filtered = new Array List < > ( ) ; } if ( put Map == null ) { put Map = new Linked Hash Map < > ( size , NUM ) ; write Vals = new Array List < > ( size ) ; } put Map . put ( CU . value ( entry . key ( ) , ctx , BOOL ) , CU . value ( updated , ctx , BOOL ) ) ; write Vals . add ( updated ) ; } } else if ( op == UPDATE ) { Cache Object cache Val = ctx . to Cache Object ( val ) ; if ( intercept ) { Cache Object old = entry . inner Get ( null , null , BOOL , ctx . load Previous Value ( ) , BOOL , BOOL , BOOL , subj Id , null , task Name , null , keep Binary ) ; Object interceptor Val = ctx . config ( ) . get Interceptor ( ) . on Before Put ( new Cache Lazy Entry ( ctx , entry . key ( ) , old , keep Binary ) , val ) ; if ( interceptor Val == null ) continue ; cache Val = ctx . to Cache Object ( ctx . unwrap Temporary ( interceptor Val ) ) ; } if ( put Map == null ) { put Map = new Linked Hash Map < > ( size , NUM ) ; write Vals = new Array List < > ( size ) ; } put Map . put ( CU . value ( entry . key ( ) , ctx , BOOL ) , CU . value ( cache Val , ctx , BOOL ) ) ; write Vals . add ( cache Val ) ; } else { assert op == DELETE ; if ( intercept ) { Cache Object old = entry . inner Get ( null , null , BOOL , ctx . load Previous Value ( ) , BOOL , BOOL , BOOL , subj Id , null , task Name , null , keep Binary ) ; Ignite Bi Tuple < Boolean , ? > interceptor Res = ctx . config ( ) . get Interceptor ( ) . on Before Remove ( new Cache Lazy Entry ( ctx , entry . key ( ) , old , keep Binary ) ) ; if ( ctx . cancel Remove ( interceptor Res ) ) continue ; } if ( rmv Keys == null ) rmv Keys = new Array List < > ( size ) ; rmv Keys . add ( entry . key ( ) . value ( ctx . cache Object Context ( ) , BOOL ) ) ; } filtered . add ( entry ) ; } catch ( Ignite Checked Exception e ) { if ( err == null ) err = partial Update Exception ( ) ; err . add ( F . as List ( entry . key ( ) ) , e ) ; } catch ( Grid Cache Entry Removed Exception ignore ) { assert BOOL : STRING ; } } if ( put Map != null || rmv Keys != null ) { err = update Partial Batch ( filtered , ver , write Vals , put Map , rmv Keys , expiry Plc , keep Binary , err , subj Id , task Name ) ; } else assert filtered . is Empty ( ) ; if ( err != null ) throw err ; return invoke Res Map ; } finally { unlock Entries ( locked ) ; } }
private static Set < Type Element > find All Members Injectors Recursively ( Collection < Type Element > members Injectors ) { Set < Type Element > result = new Hash Set < > ( ) ; for ( Type Element element : members Injectors ) { result . add All ( find All Members Injectors Recursively ( element ) ) ; } return result ; }
public Builder add Sub Button ( Context context , int drawable , int [ ] two Colors , String string ) { if ( drawables == null ) drawables = new Array List < > ( ) ; drawables . add ( Context Compat . get Drawable ( context , drawable ) ) ; if ( colors == null ) colors = new Array List < > ( ) ; colors . add ( two Colors ) ; if ( strings == null ) strings = new Array List < > ( ) ; strings . add ( string ) ; return this ; }
private void init Components ( ) { label Value = new Label ( ) ; label Value . set Value ( Util . clean Amp ( Msg . translate ( Env . get Ctx ( ) , STRING ) ) ) ; label Name = new Label ( ) ; label Name . set Value ( Util . clean Amp ( Msg . translate ( Env . get Ctx ( ) , STRING ) ) ) ; label Contact = new Label ( ) ; label Contact . set Value ( Msg . translate ( Env . get Ctx ( ) , STRING ) ) ; label E Mail = new Label ( ) ; label E Mail . set Value ( Msg . get Msg ( Env . get Ctx ( ) , STRING ) ) ; label Postal = new Label ( ) ; label Postal . set Value ( Msg . get Msg ( Env . get Ctx ( ) , STRING ) ) ; label Phone = new Label ( ) ; label Phone . set Value ( Msg . translate ( Env . get Ctx ( ) , STRING ) ) ; field ID = NUM ; field Value = new Textbox ( ) ; field Value . set Maxlength ( NUM ) ; field Value . set Attribute ( STRING , STRING ) ; field Value . add Event Listener ( Events . ON CHANGE , this ) ; field Name = new Textbox ( ) ; field Name . set Maxlength ( NUM ) ; field Name . set Attribute ( STRING , STRING ) ; field Name . add Event Listener ( Events . ON CHANGE , this ) ; field Contact = new Textbox ( ) ; field Contact . set Maxlength ( NUM ) ; field Contact . set Attribute ( STRING , STRING ) ; field Contact . add Event Listener ( Events . ON CHANGE , this ) ; field E Mail = new Textbox ( ) ; field E Mail . set Maxlength ( NUM ) ; field E Mail . set Attribute ( STRING , STRING ) ; field E Mail . add Event Listener ( Events . ON CHANGE , this ) ; field Postal = new Textbox ( ) ; field Postal . set Maxlength ( NUM ) ; field Postal . set Attribute ( STRING , STRING ) ; field Postal . add Event Listener ( Events . ON CHANGE , this ) ; field Phone = new Textbox ( ) ; field Phone . set Maxlength ( NUM ) ; field Phone . set Attribute ( STRING , STRING ) ; field Phone . add Event Listener ( Events . ON CHANGE , this ) ; check AND = new Checkbox ( ) ; check AND . set Text ( Msg . get Msg ( Env . get Ctx ( ) , STRING ) ) ; check AND . set Name ( STRING ) ; check AND . set Tooltiptext ( Msg . get Msg ( Env . get Ctx ( ) , STRING ) ) ; check AND . set Selected ( BOOL ) ; check AND . add Action Listener ( this ) ; check AND . set Attribute ( STRING , STRING ) ; check Customer = new Checkbox ( ) ; check Customer . add Action Listener ( this ) ; check Customer . set Attribute ( STRING , STRING ) ; check Customer . set Name ( STRING ) ; if ( m is SO Trx ) check Customer . set Label ( Msg . get Msg ( Env . get Ctx ( ) , STRING ) ) ; else check Customer . set Label ( Msg . get Msg ( Env . get Ctx ( ) , STRING ) ) ; check Customer . set Selected ( m is SO Match ) ; }
public static boolean is FM Instance ( ) { if ( instance Type == null ) { instance Type = ( String ) config Tags . get ( STRING ) ; } return ( instance Type != null && instance Type . equals Ignore Case ( STRING ) ) ; }
private boolean try Release ( long c , Work Queue v , long inc ) { int sp = ( int ) c , ns = sp & ~ UNSIGNALLED ; if ( v != null ) { int vs = v . scan State ; long nc = ( v . stack Pred & SP MASK ) | ( UC MASK & ( c + inc ) ) ; if ( sp == vs && U . compare And Swap Long ( this , CTL , c , nc ) ) { v . scan State = ns ; Lock Support . unpark ( v . parker ) ; return BOOL ; } } return BOOL ; }
public boolean execute ( String sql Statements , Connection conn ) { if ( conn == null ) throw new Illegal State Exception ( STRING ) ; String [ ] sql = convert ( sql Statements ) ; m exception = null ; if ( m conversion Error != null || sql == null ) return BOOL ; boolean ok = BOOL ; int i = NUM ; String statement = null ; try { if ( m stmt == null ) m stmt = conn . create Statement ( ) ; for ( i = NUM ; ok && i < sql . length ; i ++ ) { statement = sql [ i ] ; if ( statement . length ( ) == NUM ) { if ( m verbose ) log . finer ( STRING + i + STRING ) ; } else { if ( m verbose ) log . info ( STRING + i + STRING + statement + STRING ) ; else log . info ( STRING + i ) ; try { m stmt . clear Warnings ( ) ; int no = m stmt . execute Update ( statement ) ; SQL Warning warn = m stmt . get Warnings ( ) ; if ( warn != null ) { if ( m verbose ) log . info ( STRING + warn ) ; else { log . info ( STRING + i + STRING + statement + STRING ) ; log . info ( STRING + warn ) ; } } if ( m verbose ) log . fine ( STRING + no ) ; } catch ( SQL Exception ex ) { if ( ! statement . starts With ( STRING ) ) { ok = BOOL ; m exception = ex ; } if ( ! m verbose ) log . info ( STRING + i + STRING + statement + STRING ) ; log . info ( STRING + i + STRING + sql . length + STRING + ex ) ; } } } } catch ( SQL Exception e ) { m exception = e ; if ( ! m verbose ) log . info ( STRING + i + STRING + statement + STRING ) ; log . info ( STRING + i + STRING + sql . length + STRING + e ) ; return BOOL ; } return ok ; }
@ Override public Value sample ( Assignment condition ) { double prob = get Prob ( condition ) ; if ( sampler . next Double ( ) < prob ) { return Value Factory . create ( BOOL ) ; } else { return Value Factory . create ( BOOL ) ; } }
private void init Style ( Attribute Set attribute Set , int def Style Attribute ) { Typed Array typed Array = m Context . obtain Styled Attributes ( attribute Set , R . styleable . Material Search View , def Style Attribute , NUM ) ; if ( typed Array != null ) { if ( typed Array . has Value ( R . styleable . Material Search View search Background ) ) { set Background ( typed Array . get Drawable ( R . styleable . Material Search View search Background ) ) ; } if ( typed Array . has Value ( R . styleable . Material Search View android text Color ) ) { set Text Color ( typed Array . get Color ( R . styleable . Material Search View android text Color , Context Compat . get Color ( m Context , R . color . black ) ) ) ; } if ( typed Array . has Value ( R . styleable . Material Search View android text Color Hint ) ) { set Hint Text Color ( typed Array . get Color ( R . styleable . Material Search View android text Color Hint , Context Compat . get Color ( m Context , R . color . gray 50 ) ) ) ; } if ( typed Array . has Value ( R . styleable . Material Search View android hint ) ) { set Hint ( typed Array . get String ( R . styleable . Material Search View android hint ) ) ; } if ( typed Array . has Value ( R . styleable . Material Search View search Voice Icon ) ) { set Voice Icon ( typed Array . get Drawable ( R . styleable . Material Search View search Voice Icon ) ) ; } if ( typed Array . has Value ( R . styleable . Material Search View search Close Icon ) ) { set Clear Icon ( typed Array . get Drawable ( R . styleable . Material Search View search Close Icon ) ) ; } if ( typed Array . has Value ( R . styleable . Material Search View search Back Icon ) ) { set Back Icon ( typed Array . get Drawable ( R . styleable . Material Search View search Back Icon ) ) ; } if ( typed Array . has Value ( R . styleable . Material Search View search Suggestion Background ) ) { set Suggestion Background ( typed Array . get Resource Id ( R . styleable . Material Search View search Suggestion Background , R . color . search layover bg ) ) ; } if ( typed Array . has Value ( R . styleable . Material Search View android input Type ) ) { set Input Type ( typed Array . get Integer ( R . styleable . Material Search View android input Type , Input Type . TYPE CLASS TEXT ) ) ; } if ( typed Array . has Value ( R . styleable . Material Search View search Bar Height ) ) { set Search Bar Height ( typed Array . get Dimension Pixel Size ( R . styleable . Material Search View search Bar Height , get App Compat Action Bar Height ( ) ) ) ; } else { set Search Bar Height ( get App Compat Action Bar Height ( ) ) ; } View Compat . set Fits System Windows ( this , typed Array . get Boolean ( R . styleable . Material Search View android fits System Windows , BOOL ) ) ; typed Array . recycle ( ) ; } }
boolean validate ( Set attr Vals , String i18 n File Name , boolean encode Password ) throws SMS Exception { return validate ( attr Vals , i18 n File Name , encode Password , Collections . EMPTY MAP ) ; }
protected static void append Big Decimal Numeric Type ( String Builder sb ) { sb . append ( STRING ) ; }
void remove At ( final int remove Index ) { final Object [ ] items = this . items ; if ( remove Index == take Index ) { items [ take Index ] = null ; take Index = inc ( take Index ) ; count -- ; if ( itrs != null ) itrs . element Dequeued ( ) ; } else { final int put Index = this . put Index ; for ( int i = remove Index ; ; ) { int next = inc ( i ) ; if ( next != put Index ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . put Index = i ; break ; } } count -- ; if ( itrs != null ) itrs . removed At ( remove Index ) ; } not Full . signal ( ) ; }
private Access Grant create Access Grant ( Map < String , String > params ) { Access Grant access Grant = new Access Grant ( ) ; if ( params . get ( STRING ) != null ) { String access Token = params . get ( STRING ) ; Integer expires = null ; if ( params . get ( STRING ) != null ) { expires = Integer . value Of ( params . get ( STRING ) ) ; } access Grant . set Key ( access Token ) ; access Grant . set Attribute ( STRING , expires ) ; } access Grant . set Provider Id ( m Provider Name . to String ( ) ) ; return access Grant ; }
public double distance ( Vector other ) { return Math . sqrt ( Math . pow ( other . x - x , NUM ) + Math . pow ( other . y - y , NUM ) + Math . pow ( other . z - z , NUM ) ) ; }
private void parse ( File tmd ) throws IO Exception { Random Access File f = new Random Access File ( tmd , STRING ) ; f . seek ( NUM ) ; this . signature Type = f . read Int ( ) ; f . read ( signature , NUM , NUM ) ; f . seek ( NUM ) ; f . read ( issuer , NUM , NUM ) ; f . seek ( NUM ) ; this . version = f . read Byte ( ) ; this . CACRL Version = f . read Byte ( ) ; this . signer CRL Version = f . read Byte ( ) ; f . seek ( NUM ) ; this . system Version = f . read Long ( ) ; this . title ID = f . read Long ( ) ; this . title Type = f . read Int ( ) ; this . group ID = f . read Short ( ) ; f . seek ( NUM ) ; f . read ( reserved , NUM , NUM ) ; f . seek ( NUM ) ; this . access Rights = f . read Int ( ) ; this . title Version = f . read Short ( ) ; this . content Count = f . read Short ( ) ; this . boot Index = f . read Short ( ) ; f . seek ( NUM ) ; f . read ( SHA 2 , NUM , NUM ) ; f . seek ( NUM ) ; short index Offset ; short command Count ; for ( int i = NUM ; i < NUM ; i ++ ) { f . seek ( NUM + ( NUM * i ) ) ; index Offset = f . read Short ( ) ; command Count = f . read Short ( ) ; byte [ ] buffer = new byte [ NUM ] ; f . read ( buffer , NUM , NUM ) ; this . content Infos [ i ] = new Content Info ( index Offset , command Count , buffer ) ; } this . contents = new Content [ content Count ] ; int ID ; short index ; short type ; long size ; for ( int i = NUM ; i < content Count ; i ++ ) { f . seek ( NUM + ( NUM * i ) ) ; ID = f . read Int ( ) ; index = f . read Short ( ) ; type = f . read Short ( ) ; size = f . read Long ( ) ; byte [ ] buffer = new byte [ NUM ] ; f . read ( buffer , NUM , NUM ) ; this . contents [ i ] = new Content ( ID , index , type , size , buffer , this ) ; } if ( f . read ( cert 2 , NUM , NUM ) != NUM ) { Logger . log ( STRING ) ; } if ( f . read ( cert 1 , NUM , NUM ) != NUM ) { Logger . log ( STRING ) ; } f . close ( ) ; }
public void remove Vetoable Change Listener ( String property Name , Vetoable Change Listener in vcl ) { bean Context Child Support . remove Vetoable Change Listener ( property Name , in vcl ) ; }
public static void take Screenshot ( final String tag ) { if ( scenario == null ) { throw new Screenshot Exception ( STRING ) ; } Spoon Screenshot Action . perform ( tag ) ; final File screenshot = Spoon Screenshot Action . get Last Screenshot ( ) ; if ( screenshot == null ) { throw new Screenshot Exception ( STRING ) ; } File Input Stream screenshot Stream = null ; try { screenshot Stream = new File Input Stream ( screenshot ) ; final byte file Content [ ] = new byte [ ( int ) screenshot . length ( ) ] ; final int read Image Bytes = screenshot Stream . read ( file Content ) ; if ( read Image Bytes != - NUM ) { scenario . embed ( file Content , STRING ) ; } } catch ( final IO Exception ioe ) { throw new Screenshot Exception ( STRING + ioe ) ; } finally { try { if ( screenshot Stream != null ) { screenshot Stream . close ( ) ; } } catch ( final IO Exception ioe ) { throw new Screenshot Exception ( STRING + ioe ) ; } } }
private void import Runner Environment ( Import Project import Project , Folder Entry base Project Folder ) throws Forbidden Exception , Server Exception , Conflict Exception , IO Exception { import Runner Environment ( import Project , base Project Folder , null ) ; }
@ Override public void do Notify ( ) throws Exception { log . info ( STRING ) ; Scheduled Executor Service svc = service ; if ( svc != null ) { try { svc . schedule ( ( Callable < Object > ) this , NUM , Time Unit . MICROSECONDS ) ; } catch ( Rejected Execution Exception ex ) { if ( svc . is Shutdown ( ) ) { log . info ( STRING ) ; } else { throw ex ; } } } else { log . info ( STRING ) ; } }
public boolean check Root By Build Tags ( ) { String build Tags = android . os . Build . TAGS ; if ( build Tags != null && build Tags . contains ( SU TAG ) ) { return BOOL ; } return BOOL ; }
public boolean is User Active ( String realm ) { boolean active = BOOL ; try { AM Identity user = Id Utils . get Identity ( sso Token , user Id ) ; boolean is User Active = user . is Active ( ) ; String login Status = get User Attribute Value ( user , USER SERVICE LOGIN STATUS , ACTIVE ) ; String lockout = get User Attribute Value ( user , USER SERVICE NS LOCKOUT , STRING FALSE ) ; if ( ! is User Active || ! login Status . equals Ignore Case ( ACTIVE ) || ! lockout . equals Ignore Case ( STRING FALSE ) ) { error Msg = get Localized String ( STRING ) ; write Log ( STRING , user Id ) ; } else if ( is Account Expired ( user ) ) { error Msg = get Localized String ( STRING ) ; write Log ( STRING , user Id ) ; } else if ( is User Lockout ( user Id , realm ) ) { String obj [ ] = { user Id } ; information Msg = get Localized String ( STRING ) ; write Log ( STRING , user Id ) ; } else { active = BOOL ; } } catch ( SSO Exception e ) { debug . warning ( STRING , e ) ; error Msg = get Error String ( e ) ; } catch ( Id Repo Exception e ) { debug . warning ( STRING , e ) ; error Msg = get Error String ( e ) ; } return active ; }
@ Override public < U > Completable Future < U > fold Right ( final U seed , final Bi Function < ? super T , U , U > function ) { return Completable Future . supply Async ( null , exec ) ; }
private void algorithm Douglas Peucker ( List < Entry > entries , double epsilon , int start , int end ) { if ( end <= start + NUM ) { return ; } int max Dist Index = NUM ; double dist Max = NUM ; Entry first Entry = entries . get ( start ) ; Entry last Entry = entries . get ( end ) ; for ( int i = start + NUM ; i < end ; i ++ ) { double dist = calc Angle Between Lines ( first Entry , last Entry , first Entry , entries . get ( i ) ) ; if ( dist > dist Max ) { dist Max = dist ; max Dist Index = i ; } } if ( dist Max > epsilon ) { keep [ max Dist Index ] = BOOL ; algorithm Douglas Peucker ( entries , epsilon , start , max Dist Index ) ; algorithm Douglas Peucker ( entries , epsilon , max Dist Index , end ) ; } }
private void calc Interval Dis ( ) { if ( m Mark Text Paint == null ) { return ; } String default Text = STRING ; Rect temp = new Rect ( ) ; int max = NUM ; if ( m Items != null && m Items . size ( ) > NUM ) { for ( String i : m Items ) { m Mark Text Paint . get Text Bounds ( i , NUM , i . length ( ) , temp ) ; if ( temp . width ( ) > max ) { max = temp . width ( ) ; } } } else { m Mark Text Paint . get Text Bounds ( default Text , NUM , default Text . length ( ) , temp ) ; max = temp . width ( ) ; } if ( ! Text Utils . is Empty ( m Addition Center Mark ) ) { m Mark Text Paint . set Text Size ( m Normal Text Size ) ; m Mark Text Paint . get Text Bounds ( m Addition Center Mark , NUM , m Addition Center Mark . length ( ) , temp ) ; m Addition Center Mark Width = temp . width ( ) ; max += temp . width ( ) ; } m Interval Dis = max * m Interval Factor ; }
public static void sort ( Abstract List array , int [ ] indices ) { for ( int i = NUM ; i < indices . length ; i ++ ) { indices [ i ] = i ; } int temp ; int j , n = array . size ( ) ; for ( j = n / NUM ; j > NUM ; j -- ) { adjust ( array , indices , j , n ) ; } for ( j = n - NUM ; j > NUM ; j -- ) { temp = indices [ NUM ] ; indices [ NUM ] = indices [ j ] ; indices [ j ] = temp ; adjust ( array , indices , NUM , j ) ; } }
private float clamp Mag ( float value , float abs Min , float abs Max ) { final float abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }
public static boolean save String To File ( String data Input , String path ) { String filename = path ; File file = new File ( filename ) ; File Output Stream fos ; byte [ ] data = data Input . get Bytes ( ) ; try { fos = new File Output Stream ( file ) ; fos . write ( data ) ; fos . flush ( ) ; fos . close ( ) ; return BOOL ; } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } return BOOL ; }
public static String quote ( String input ) { if ( input . contains ( STRING ) ) { return STRING + input + STRING ; } else { return input ; } }
public void remove Swipe Listener ( Swipe Listener listener ) { if ( m Listeners == null ) { return ; } m Listeners . remove ( listener ) ; }
public static void assert Throws Completion Exception ( final Consumer < Void > consumer , final Class < ? > exception Class ) { try { consumer . accept ( null ) ; } catch ( final Completion Exception completion Ex ) { final Throwable ex = completion Ex . get Cause ( ) ; if ( ex . get Class ( ) == exception Class ) { return ; } Assert . fail ( String . format ( STRING , ex . get Class ( ) ) ) ; } Assert . fail ( String . format ( STRING , exception Class ) ) ; }
public Object put ( Object key , Object value ) { Object old Value = null ; synchronized ( map ) { old Value = map . put ( key , value ) ; if ( old Value != null ) { remove Element ( key ) ; } add Element ( key ) ; } return old Value ; }
public double run ( ) { try { Audio Input Stream in Input = Audio System . get Audio Input Stream ( files [ NUM ] ) ; Audio Feature audio Feature Input = ( Audio Feature ) feature Extractor Input . calculate ( in Input ) ; } catch ( Exception e ) { } double avg Distance = NUM ; for ( int i = NUM ; i < array Feature Extractor Train Set . size ( ) ; i ++ ) { double distance 2 DB = audio Thread Distance ( feature Extractor Input . get MFCC ( ) , array Feature Extractor Train Set . get ( i ) ) ; Log . i ( STRING , STRING + distance 2 DB ) ; avg Distance += distance 2 DB ; } Log . i ( STRING , STRING + ( avg Distance / array Feature Extractor Train Set . size ( ) ) ) ; return avg Distance / array Feature Extractor Train Set . size ( ) ; }
@ Override protected void on Size Changed ( int w , int h , int oldw , int oldh ) { super . on Size Changed ( w , h , oldw , oldh ) ; setup Bounds ( w , h ) ; setup Paints ( ) ; invalidate ( ) ; }
public Predicate ( Term t ) { terms . add ( t ) ; }
private void add Operations ( Set < String > method Signatures ) throws Operation Parse Exception { for ( String sig : method Signatures ) { Typed Operation operation = Operation Parser . parse ( sig ) ; operations . add ( operation ) ; } }
private void write Log ( String log ) { File file = new File ( Crash Handler Default . Log Default Path + STRING + formatter . format ( new Date ( ) ) + STRING ) ; try { File Output Stream file Output Stream = new File Output Stream ( file ) ; byte [ ] bytes = log . get Bytes ( ) ; file Output Stream . write ( bytes ) ; file Output Stream . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
public Rule ( String pattern , Object token Type , String next State ) { this . pattern = Pattern . compile ( pattern ) ; this . token Type = token Type ; this . next State = next State ; }
private void show Popup ( final Mouse Event event ) { int [ ] rows = get Selected Rows ( ) ; if ( ( rows . length == NUM ) || ( rows . length == NUM ) ) { final int row = row At Point ( event . get Point ( ) ) ; final int column = column At Point ( event . get Point ( ) ) ; if ( ( row == - NUM ) || ( column == - NUM ) ) { return ; } change Selection ( row , column , BOOL , BOOL ) ; rows = get Selected Rows ( ) ; } final J Popup Menu menu = new J Popup Menu ( ) ; menu . add ( new J Menu Item ( C Action Proxy . proxy ( new C Delete Bookmark Action ( m bookmark Manager , rows ) ) ) ) ; menu . show ( event . get Component ( ) , event . get X ( ) , event . get Y ( ) ) ; }
public int line To Y ( int line ) { Font Metrics fm = painter . get Font Metrics ( ) ; return ( line - first Line ) * fm . get Height ( ) - ( fm . get Leading ( ) + fm . get Max Descent ( ) ) ; }
public static boolean has Special Chars ( final String str ) { final Matcher matcher = SPL CHAR PATRN . matcher ( str ) ; return matcher . find ( ) ; }
@ Override public int read ( byte b [ ] , int off , int len ) throws IO Exception { if ( bb == null ) { throw new IO Exception ( STRING ) ; } if ( b == null ) { throw new Null Pointer Exception ( ) ; } else if ( off < NUM || len < NUM || len > b . length - off ) { throw new Index Out Of Bounds Exception ( ) ; } else if ( len == NUM ) { return NUM ; } int length = Math . min ( bb . remaining ( ) , len ) ; if ( length == NUM ) { return - NUM ; } bb . get ( b , off , length ) ; return length ; }
public void remove Event Listener ( Multimedia Messaging Session Listener listener ) throws Rcs Service Not Available Exception , Rcs Generic Exception { if ( m Api == null ) { throw new Rcs Service Not Available Exception ( ) ; } try { Weak Reference < I Multimedia Messaging Session Listener > weak Ref = m Multimedia Messaging Session Listeners . remove ( listener ) ; if ( weak Ref == null ) { return ; } I Multimedia Messaging Session Listener multimedia Messaging Session Listener = weak Ref . get ( ) ; if ( multimedia Messaging Session Listener != null ) { m Api . remove Event Listener 2 ( multimedia Messaging Session Listener ) ; } } catch ( Exception e ) { Rcs Illegal Argument Exception . assert Exception ( e ) ; throw new Rcs Generic Exception ( e ) ; } }
private static boolean date By Month ( Date Time Formatter Builder bld , Collection < Date Time Field Type > fields , boolean extended , boolean strict ISO ) { boolean reduced Prec = BOOL ; if ( fields . remove ( Date Time Field Type . year ( ) ) ) { bld . append ( Constants . ye ) ; if ( fields . remove ( Date Time Field Type . month Of Year ( ) ) ) { if ( fields . remove ( Date Time Field Type . day Of Month ( ) ) ) { append Separator ( bld , extended ) ; bld . append Month Of Year ( NUM ) ; append Separator ( bld , extended ) ; bld . append Day Of Month ( NUM ) ; } else { bld . append Literal ( STRING ) ; bld . append Month Of Year ( NUM ) ; reduced Prec = BOOL ; } } else { if ( fields . remove ( Date Time Field Type . day Of Month ( ) ) ) { check Not Strict ISO ( fields , strict ISO ) ; bld . append Literal ( STRING ) ; bld . append Literal ( STRING ) ; bld . append Day Of Month ( NUM ) ; } else { reduced Prec = BOOL ; } } } else if ( fields . remove ( Date Time Field Type . month Of Year ( ) ) ) { bld . append Literal ( STRING ) ; bld . append Literal ( STRING ) ; bld . append Month Of Year ( NUM ) ; if ( fields . remove ( Date Time Field Type . day Of Month ( ) ) ) { append Separator ( bld , extended ) ; bld . append Day Of Month ( NUM ) ; } else { reduced Prec = BOOL ; } } else if ( fields . remove ( Date Time Field Type . day Of Month ( ) ) ) { bld . append Literal ( STRING ) ; bld . append Literal ( STRING ) ; bld . append Literal ( STRING ) ; bld . append Day Of Month ( NUM ) ; } return reduced Prec ; }
public String [ ] parse Line ( String line , boolean with Label , boolean trace , boolean ignore Empty ) { if ( trace ) log . config ( STRING + line ) ; Array List < String > list = new Array List < String > ( ) ; for ( int i = NUM ; i < m rows . size ( ) ; i ++ ) { Imp Format Row row = ( Imp Format Row ) m rows . get ( i ) ; String Buffer entry = new String Buffer ( ) ; if ( with Label ) { entry . append ( row . get Column Name ( ) ) ; entry . append ( STRING ) ; if ( row . is String ( ) ) entry . append ( STRING ) ; else if ( row . is Date ( ) ) entry . append ( STRING ) ; } String info = null ; if ( row . is Constant ( ) ) info = STRING ; else if ( m format Type . equals ( X AD Imp Format . FORMATTYPE Fixed Position ) ) { if ( row . get Start No ( ) > NUM && row . get End No ( ) <= line . length ( ) ) info = line . substring ( row . get Start No ( ) - NUM , row . get End No ( ) ) ; } else { info = parse Flex Format ( line , m format Type , row . get Start No ( ) ) ; } if ( Util . is Empty ( info , BOOL ) ) { if ( row . get Default Value ( ) != null ) info = row . get Default Value ( ) ; else info = STRING ; } entry . append ( row . parse ( info ) ) ; if ( with Label ) { if ( row . is String ( ) ) entry . append ( STRING ) ; else if ( row . is Date ( ) ) entry . append ( STRING ) ; } if ( ! ignore Empty || ( ignore Empty && info . length ( ) != NUM ) ) list . add ( entry . to String ( ) ) ; if ( trace ) log . fine ( info + STRING + entry . to String ( ) + STRING + info . length ( ) + STRING ) ; } String [ ] ret Value = new String [ list . size ( ) ] ; list . to Array ( ret Value ) ; return ret Value ; }
public Widget Proposal Computer ( String text , int offset , Element root Element , Element parent Element , I Java Project java Project ) throws Java Model Exception , Ui Binder Exception { super ( java Project , text , offset , text . length ( ) ) ; this . root Element = root Element ; this . parent Element = parent Element ; package Manager . read From Element ( root Element ) ; }
public List < Predicate < T > > parse ( final List < String > queries ) throws Query Parse Exception { List < Predicate < T > > predicates = new Array List < > ( queries . size ( ) ) ; for ( String query : queries ) { predicates . add ( parse ( query ) ) ; } return predicates ; }
public static Object deserialize Stream ( final String witness ) throws Exception { File Input Stream file Is = new File Input Stream ( witness ) ; Object Input Stream obj Is = new Object Input Stream ( file Is ) ; return obj Is . read Object ( ) ; }
public static void rollback ( boolean began Transaction , String cause Message , Throwable cause Throwable ) throws Generic Transaction Exception { if ( began Transaction ) { Transaction Util . rollback ( cause Throwable ) ; } else { Transaction Util . set Rollback Only ( cause Message , cause Throwable ) ; } }
public Long Array ( Long Array array ) { this . ordered = array . ordered ; size = array . size ; items = new long [ size ] ; System . arraycopy ( array . items , NUM , items , NUM , size ) ; }
private static < T > T report Get ( Object r ) throws Interrupted Exception , Execution Exception { if ( r == null ) throw new Interrupted Exception ( ) ; if ( r instanceof Alt Result ) { Throwable x , cause ; if ( ( x = ( ( Alt Result ) r ) . ex ) == null ) return null ; if ( x instanceof Cancellation Exception ) throw ( Cancellation Exception ) x ; if ( ( x instanceof Completion Exception ) && ( cause = x . get Cause ( ) ) != null ) x = cause ; throw new Execution Exception ( x ) ; } @ Suppress Warnings ( STRING ) T t = ( T ) r ; return t ; }
protected void garbage Collect ( Visual Table labels ) { Iterator iter = labels . tuples ( ) ; while ( iter . has Next ( ) ) { Visual Item item = ( Visual Item ) iter . next ( ) ; if ( ! item . is Start Visible ( ) && ! item . is End Visible ( ) ) { labels . remove Tuple ( item ) ; } } }
public boolean shares Variable With ( Def Use du ) { return var Name . equals ( du . var Name ) ; }
private void populate Nav Drawer ( ) { m Nav Drawer Items . clear ( ) ; m Nav Drawer Items . add ( NAVDRAWER ITEM ACTIVITY 1 ) ; m Nav Drawer Items . add ( NAVDRAWER ITEM SEPARATOR ) ; m Nav Drawer Items . add ( NAVDRAWER ITEM ACTIVITY 2 ) ; m Nav Drawer Items . add ( NAVDRAWER ITEM SEPARATOR SPECIAL ) ; m Nav Drawer Items . add ( NAVDRAWER ITEM ACTIVITY 3 ) ; create Nav Drawer Items ( ) ; }
public Artifact Coordinates ( final String group Id , final String artifact Id , final String version , final String classifier ) { this . group Id = group Id ; this . artifact Id = artifact Id ; this . version = version ; this . classifier = classifier ; }
private Carbon Iterator < Batch Result > execute Block List ( List < Table Block Info > block List ) throws Query Execution Exception { query Model . set Table Block Infos ( block List ) ; this . query Executor = Query Executor Factory . get Query Executor ( ) ; Carbon Iterator < Batch Result > iter = null ; try { iter = query Executor . execute ( query Model ) ; } catch ( Query Execution Exception e ) { LOGGER . error ( e . get Message ( ) ) ; throw e ; } return iter ; }
public static boolean is Java Script Enabled ( Http Servlet Request request ) { Http Session session = request . get Session ( ) ; Boolean java Script Enabled = ( Boolean ) session . get Attribute ( STRING ) ; if ( java Script Enabled != null ) { return java Script Enabled . boolean Value ( ) ; } return BOOL ; }
protected Link create Link ( final String relation , final URI href ) { return new Link ( relation , href ) ; }
public void test Flip Bit Positive Inside 2 ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = NUM ; int number = NUM ; byte r Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . flip Bit ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public static Spannable create Spannable From Text With Template ( String text , Char Sequence inner Template ) { Spannable String result = new Spannable String ( text ) ; if ( inner Template instanceof Spanned ) { int index = text . index Of ( inner Template . to String ( ) ) ; if ( index >= NUM ) { copy Spans ( result , ( Spanned ) inner Template , index ) ; } } return result ; }
@ Override public String to String ( ) { return xml File . get Name ( ) ; }
public String to String ( ) { return String . value Of ( stop Time Millis - start Time Millis ) + STRING ; }
public Object Graph plus Graph ( List < Object > activity Scope Modules ) { if ( activity Scope Modules == null ) { throw new Illegal Argument Exception ( STRING ) ; } return graph . plus ( activity Scope Modules . to Array ( ) ) ; }
public Group Category Set ( Group Category [ ] categories ) { Assert . is Not Null ( categories ) ; f Content = new Array List ( categories . length ) ; for ( int i = NUM ; i < categories . length ; i ++ ) { if ( ! f Content . contains ( categories [ i ] ) ) f Content . add ( categories [ i ] ) ; } }
private boolean in Same Package ( Class < ? > c1 , Class < ? > c2 ) { String name C 1 = c1 . get Name ( ) ; String name C 2 = c2 . get Name ( ) ; int index Dot C 1 = name C 1 . last Index Of ( STRING ) ; int index Dot C 2 = name C 2 . last Index Of ( STRING ) ; if ( index Dot C 1 != index Dot C 2 ) { return BOOL ; } if ( index Dot C 1 == - NUM ) { return BOOL ; } return name C 1 . region Matches ( NUM , name C 2 , NUM , index Dot C 1 ) ; }
private void write Constraints To Xml ( Xml Serializer out , Job Status job Status ) throws IO Exception { out . start Tag ( null , XML TAG PARAMS CONSTRAINTS ) ; if ( job Status . has Unmetered Constraint ( ) ) { out . attribute ( null , STRING , Boolean . to String ( BOOL ) ) ; } if ( job Status . has Connectivity Constraint ( ) ) { out . attribute ( null , STRING , Boolean . to String ( BOOL ) ) ; } if ( job Status . has Idle Constraint ( ) ) { out . attribute ( null , STRING , Boolean . to String ( BOOL ) ) ; } if ( job Status . has Charging Constraint ( ) ) { out . attribute ( null , STRING , Boolean . to String ( BOOL ) ) ; } out . end Tag ( null , XML TAG PARAMS CONSTRAINTS ) ; }
public void fill Conditional Holes ( ) { Value Range possible Cond Pairs = new Value Range ( table . key Set ( ) ) ; if ( possible Cond Pairs . get Nb Combinations ( ) < NUM ) { Set < Assignment > possible Cond Assignments = possible Cond Pairs . linearise ( ) ; possible Cond Assignments . remove ( new Assignment ( ) ) ; for ( Assignment possible Cond : possible Cond Assignments ) { if ( ! table . contains Key ( possible Cond ) ) { add Row ( possible Cond , Value Factory . none ( ) , NUM ) ; } } } }
private boolean show App Menu ( View view , boolean start Dragging ) { if ( ! m Menu Handler . is App Menu Showing ( ) && m Menu Handler . show App Menu ( view , start Dragging ) ) { if ( ! start Dragging ) Record User Action . record ( STRING ) ; if ( m On App Menu Shown Listener != null ) { m On App Menu Shown Listener . run ( ) ; } return BOOL ; } return BOOL ; }
protected void write Node Text ( Node node ) throws IO Exception { String text = node . get Text ( ) ; if ( ( text != null ) && ( text . length ( ) > NUM ) ) { if ( escape Text ) { text = escape Element Entities ( text ) ; } last Output Node Type = Node . TEXT NODE ; writer . write ( text ) ; } }
public void insert Radians ( double [ ] latlons , int coord Pair Index , boolean replace Ends Of Inserted At Join ) { int min Pnts Needed For Insertion = NUM ; boolean at End = BOOL ; boolean is Closed = is Geometry Closed ( ) ; int insertion Point = coord Pair Index * NUM ; if ( insertion Point >= rawllpts . length ) { if ( is Closed ) { insertion Point = rawllpts . length - NUM ; } else { insertion Point = rawllpts . length ; at End = BOOL ; } } else if ( insertion Point <= NUM ) { if ( is Closed ) { insertion Point = NUM ; } else { insertion Point = NUM ; at End = BOOL ; } } int new Coord Start = NUM ; int new Coord Length = latlons . length ; if ( replace Ends Of Inserted At Join ) { new Coord Start = NUM ; min Pnts Needed For Insertion = NUM ; if ( at End ) { min Pnts Needed For Insertion -= NUM ; new Coord Length -= NUM ; if ( insertion Point == NUM ) { new Coord Start = NUM ; } } else { new Coord Length -= NUM ; } } if ( render Type == OM Graphic . RENDERTYPE LATLON && latlons . length >= min Pnts Needed For Insertion && latlons . length % NUM == NUM ) { double [ ] oldrawllpnts = rawllpts ; int old Coords Remaining = oldrawllpnts . length - insertion Point ; rawllpts = new double [ oldrawllpnts . length + new Coord Length ] ; System . arraycopy ( oldrawllpnts , NUM , rawllpts , NUM , insertion Point ) ; System . arraycopy ( latlons , new Coord Start , rawllpts , insertion Point , new Coord Length ) ; System . arraycopy ( oldrawllpnts , insertion Point , rawllpts , insertion Point + new Coord Length , old Coords Remaining ) ; set Need To Regenerate ( BOOL ) ; } }
public static boolean cancel Potential Work ( Object data , Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . data ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( BOOL ) ; if ( Build Config . DEBUG ) { Log . d ( TAG , STRING + data ) ; } } else { return BOOL ; } } return BOOL ; }
protected Map < String , Object > convert Named List To Map ( Named List < ? > args ) { Map < String , Object > args Map = new Linked Hash Map < > ( ) ; if ( args != null ) { for ( Map . Entry < String , ? > entry : args ) { args Map . put ( entry . get Key ( ) , entry . get Value ( ) ) ; } } return args Map ; }
private T3 < Integer , Integer , byte [ ] > random Key ( Random rnd ) { return keys [ rnd . next Int ( keys . length ) ] ; }
public String to String ( ) { String Buffer buffer = new String Buffer ( ) ; if ( override > NUM ) { buffer . append ( STRING + override + STRING ) ; if ( lineno > NUM ) buffer . append ( STRING + lineno + STRING ) ; } else { if ( location Name == null && lineno > NUM ) { buffer . append ( STRING + lineno + STRING ) ; } else if ( location Name != null ) { buffer . append ( location Name + STRING ) ; if ( lineno > NUM ) buffer . append ( lineno + STRING ) ; } } buffer . append ( description ) ; return buffer . to String ( ) ; }
public void test Searchables List Real ( ) { My Mock Package Manager mock PM = new My Mock Package Manager ( m Context . get Package Manager ( ) ) ; My Mock Context mock Context = new My Mock Context ( m Context , mock PM ) ; mock PM . set Searchables Mode ( My Mock Package Manager . SEARCHABLES PASSTHROUGH ) ; Searchables searchables = new Searchables ( mock Context , NUM ) ; searchables . build Searchable List ( ) ; Array List < Searchable Info > searchables List = searchables . get Searchables List ( ) ; int count = searchables List . size ( ) ; assert True ( count >= NUM ) ; check Searchables ( searchables List ) ; Array List < Searchable Info > global = searchables . get Searchables In Global Search List ( ) ; check Searchables ( global ) ; }
private void fill Example Table ( Data Set data Set , Progress Listener listener , int [ ] attribute Columns , Memory Example Table example Table ) throws Data Set Exception , Process Stopped Exception , Parse Exception { Attribute [ ] attributes = example Table . get Attributes ( ) ; data Set . reset ( ) ; int number Of Rows = data Set . get Number Of Rows ( ) ; Data Row Factory factory = new Data Row Factory ( data Management Type , Data Row Factory . POINT AS DECIMAL CHARACTER ) ; boolean is Running In Process = is Operator Running ( ) ; while ( data Set . has Next ( ) ) { if ( is Running In Process ) { operator . check For Stop ( ) ; } if ( should Stop ) { throw new Process Stopped Exception ( ) ; } Data Set Row current Row = data Set . next Row ( ) ; if ( listener != null ) { update Process ( listener , data Set . get Current Row Index ( ) , number Of Rows ) ; } Data Row row = factory . create ( attributes . length ) ; example Table . add Data Row ( row ) ; int attribute Index = NUM ; for ( Attribute attribute : attributes ) { if ( current Row . is Missing ( attribute Columns [ attribute Index ] ) ) { row . set ( attribute , Double . Na N ) ; } else { switch ( attribute . get Value Type ( ) ) { case Ontology . INTEGER : case Ontology . NUMERICAL : case Ontology . REAL : row . set ( attribute , get Number ( current Row , attribute Columns [ attribute Index ] ) ) ; break ; case Ontology . DATE TIME : case Ontology . TIME : case Ontology . DATE : row . set ( attribute , get Date ( current Row , attribute Columns [ attribute Index ] ) ) ; break ; default : row . set ( attribute , get String Index ( attribute , current Row , attribute Columns [ attribute Index ] ) ) ; } } attribute Index ++ ; } } }
public boolean is Spurious ( int min Cl Size ) { return children . is Empty ( ) && members . size ( ) < min Cl Size ; }
public Aes Decryptor ( byte [ ] key , int off , int len ) { this . key = new byte [ len ] ; System . arraycopy ( key , off , this . key , NUM , len ) ; }
static String extract Number From Uri Without Formatting ( String uri ) { if ( uri == null ) { return null ; } int index 0 = uri . index Of ( URI START DELIMITER ) ; if ( index 0 != - NUM ) { uri = uri . substring ( index 0 + URI START DELIMITER . length ( ) , uri . index Of ( URI END DELIMITER , index 0 ) ) ; } int index 1 = uri . index Of ( TEL URI HEADER ) ; if ( index 1 != - NUM ) { uri = uri . substring ( index 1 + TEL URI HEADER . length ( ) ) ; } index 1 = uri . index Of ( SIP URI HEADER ) ; if ( index 1 != - NUM ) { int index 2 = uri . index Of ( STRING , index 1 ) ; uri = uri . substring ( index 1 + SIP URI HEADER . length ( ) , index 2 ) ; } int index 2 = uri . index Of ( STRING ) ; if ( index 2 != - NUM ) { uri = uri . substring ( NUM , index 2 ) ; } index 2 = uri . index Of ( STRING ) ; if ( index 2 != - NUM ) { uri = uri . substring ( NUM , index 2 ) ; } return uri ; }
public Remote Method Call Results invoke And Wait ( final String end Point Name , final Remote Method Call remote Call ) { End Point local ; synchronized ( m end Point Mutex ) { local = m local End Points . get ( end Point Name ) ; } if ( local == null ) { return invoke And Wait Remote ( remote Call ) ; } else { final long number = local . take A Number ( ) ; final List < Remote Method Call Results > results = local . invoke Local ( remote Call , number , get Local Node ( ) ) ; if ( results . size ( ) == NUM ) { throw new Remote Not Found Exception ( STRING + end Point Name ) ; } if ( results . size ( ) > NUM ) { throw new Illegal State Exception ( STRING + results ) ; } return results . get ( NUM ) ; } }
private void restore From Keypress ( final Key Event key Event , final int key Number ) { if ( key Event . is Alt Down ( ) ) { final int array Index = ( key Number > NUM ? key Number : MAX RECENT MESSAGES ) - NUM ; if ( array Index < recent Messages . size ( ) ) { display Message ( recent Messages . get ( array Index ) ) ; } key Event . consume ( ) ; } }
private void create Element ( Document doc , Element parent Element , String element Name , boolean value ) { Element element = doc . create Element ( element Name ) ; element . append Child ( doc . create Text Node ( Boolean . to String ( value ) ) ) ; parent Element . append Child ( element ) ; }
protected void annotation Value To String ( final String Builder sb , final B Op val , final int indent ) { sb . append ( val . to String ( ) ) ; }
public void run Test ( ) throws Throwable { Document doc ; Node List em List ; Node em Node ; Character Data em Text ; Node null Child ; doc = ( Document ) load ( STRING , BOOL ) ; em List = doc . get Elements By Tag Name ( STRING ) ; em Node = em List . item ( NUM ) ; em Text = ( Character Data ) em Node . get First Child ( ) ; null Child = em Text . get Last Child ( ) ; assert Null ( STRING , null Child ) ; }
public Enumeration oids ( ) { return ordering . elements ( ) ; }
@ Override Map < String , Object > extract Fields ( String line ) { if ( ! initialized ) { init ( ) ; initialized = BOOL ; } String [ ] values = fixed Width Parser . parse Line ( line ) ; if ( has Header && Arrays . deep Equals ( values , header ) ) { return null ; } Map < String , Object > map = Maps . new Hash Map ( ) ; int i = NUM ; for ( Fixed Width Field field : fields ) { map . put ( field . get Name ( ) , get Value ( field , values [ i ++ ] ) ) ; } return map ; }
protected double Scaling Function ( int i Distance ) { return Math . exp ( - Math . pow ( ( i Distance ) , NUM ) / ( NUM * Math . pow ( Correlation Window , NUM ) ) ) ; }
protected void update Ideal Point ( ) { for ( Solution solution : this ) { if ( solution . get Number Of Objectives ( ) != number Of Objectives ) { throw new Framework Exception ( STRING ) ; } for ( int i = NUM ; i < number Of Objectives ; i ++ ) { ideal Point [ i ] = Math . min ( ideal Point [ i ] , solution . get Objective ( i ) ) ; } } }
public Search Builder sort ( Sort Field Builder ... builders ) { sort . add All ( Arrays . as List ( builders ) ) ; return this ; }
@ Override public final Buffered Image data To RGB ( byte [ ] data , final int width , final int height ) { Buffered Image image ; data = data To RGB Byte Array ( data , width , height ) ; final Data Buffer db = new Data Buffer Byte ( data , data . length ) ; final int [ ] bands = { NUM , NUM , NUM } ; image = new Buffered Image ( width , height , Buffered Image . TYPE INT RGB ) ; final Raster raster = Raster . create Interleaved Raster ( db , width , height , width * NUM , NUM , bands , null ) ; image . set Data ( raster ) ; return image ; }
protected void create File Chooser ( ) { m File Chooser = new J File Chooser ( new File ( System . get Property ( STRING ) ) ) ; m File Chooser . set File Selection Mode ( J File Chooser . FILES ONLY ) ; }
private boolean is Noun ( String word ) { if ( nouns == null ) return BOOL ; return nouns . contains ( word . to Lower Case ( ) ) ; }
public static void write Document ( Document document , String encoding , Output Stream out , Writer writer , boolean omit XML Declaration ) throws IO Exception , XML Exception { if ( writer == null ) { writer = new Output Stream Writer ( out , encoding ) ; } transformer . set Output Property ( Output Keys . ENCODING , encoding ) ; transformer . set Output Property ( Output Keys . OMIT XML DECLARATION , omit XML Declaration ? STRING : STRING ) ; Source source = new DOM Source ( document ) ; Result result = new Stream Result ( writer ) ; try { transformer . transform ( source , result ) ; } catch ( Transformer Exception e ) { e . print Stack Trace ( ) ; throw new XML Exception ( STRING , e ) ; } writer . flush ( ) ; }
public static String int To String ( int value , int n Chars ) { String str Value = Integer . to String ( value ) ; String Builder str Buf = new String Builder ( n Chars ) ; for ( int i = str Value . length ( ) ; i < n Chars ; i ++ ) { str Buf . append ( STRING ) ; } str Buf . append ( str Value ) ; return str Buf . to String ( ) ; }
public boolean is Quest Completed ( final String name ) { return quests . is Quest Completed ( name ) ; }
private void update Button State ( boolean data Changed ) { btn Apply . set Enabled ( data Changed ) ; btn Revert . set Enabled ( data Changed ) ; }
private void build Menu ( ) { set Visible ( BOOL ) ; remove All ( ) ; if ( recent Searches . get Length ( ) == NUM ) { J Menu Item no Recent = new J Menu Item ( UI Manager . get String ( STRING ) ) ; no Recent . set Enabled ( BOOL ) ; add ( no Recent ) ; } else { J Menu Item recent = new J Menu Item ( UI Manager . get String ( STRING ) ) ; recent . set Enabled ( BOOL ) ; add ( recent ) ; for ( String search String : recent Searches . get Recent Searches ( ) ) { J Menu Item mi = new J Menu Item ( search String ) ; mi . add Action Listener ( this ) ; add ( mi ) ; } add Separator ( ) ; clear = new J Menu Item ( UI Manager . get String ( STRING ) ) ; clear . add Action Listener ( this ) ; add ( clear ) ; } }
public static String convert U 8 To Hex String ( char u8 ) { return Integer . to Hex String ( u8 ) ; }
protected void Predicate ( ) throws javax . xml . transform . Transformer Exception { if ( token Is ( STRING ) ) { next Token ( ) ; Predicate Expr ( ) ; consume Expected ( STRING ) ; } }
public static byte [ ] join ( byte [ ] array A , byte ... array B ) { if ( ( array B == null ) || ( array B . length == NUM ) ) { return array A ; } if ( ( array A == null ) || ( array A . length == NUM ) ) { return array B ; } byte [ ] array = new byte [ array A . length + array B . length ] ; System . arraycopy ( array A , NUM , array , NUM , array A . length ) ; System . arraycopy ( array B , NUM , array , array A . length , array B . length ) ; return array ; }
public void remove Listener ( Listener listener ) { m Listeners . remove ( listener ) ; }
protected double constriction Coefficient ( double c1 , double c2 ) { double rho = c1 + c2 ; if ( rho <= NUM ) { return NUM ; } else { return NUM / ( NUM - rho - Math . sqrt ( Math . pow ( rho , NUM ) - NUM * rho ) ) ; } }
public Replicator Capabilities ( Tungsten Properties props ) throws Exception { Set < String > keys = props . key Names ( ) ; for ( String key : keys ) { if ( key . equals ( ROLES ) ) { List < String > tags = props . get String List ( key ) ; for ( String tag : tags ) { if ( tag . equals Ignore Case ( ROLE MASTER ) ) { add Role ( Replicator Capabilities . ROLE MASTER ) ; } else if ( tag . equals Ignore Case ( ROLE SLAVE ) ) { add Role ( Replicator Capabilities . ROLE SLAVE ) ; } else if ( tag . equals Ignore Case ( ROLE RELAY ) ) { add Role ( Replicator Capabilities . ROLE RELAY ) ; } else { throw new Exception ( STRING + tag ) ; } } } else if ( key . equals ( MODEL ) ) { String tag = props . get String ( key ) ; if ( tag . equals Ignore Case ( MODEL PUSH ) ) { set Model ( MODEL PUSH ) ; } else if ( tag . equals Ignore Case ( MODEL PULL ) ) { set Model ( MODEL PULL ) ; } else if ( tag . equals Ignore Case ( MODEL PEER ) ) { set Model ( MODEL PEER ) ; } else if ( tag . equals Ignore Case ( UNKNOWN ) ) { set Model ( UNKNOWN ) ; } else { throw new Exception ( STRING + tag ) ; } } else if ( key . equals ( CAP CONSISTENCY ) ) { set Consistency Check ( props . get Boolean ( CAP CONSISTENCY ) ) ; } else if ( key . equals ( CAP HEARTBEAT ) ) { set Heartbeat ( props . get Boolean ( CAP HEARTBEAT ) ) ; } else if ( key . equals ( CAP FLUSH ) ) { set Flush ( props . get Boolean ( CAP FLUSH ) ) ; } else if ( key . equals ( PROVISION ) ) { String tag = props . get String ( key ) ; if ( tag . equals Ignore Case ( PROVISION DONOR ) ) { set Provision Driver ( PROVISION DONOR ) ; } else if ( tag . equals Ignore Case ( PROVISION JOINER ) ) { set Provision Driver ( PROVISION JOINER ) ; } else if ( tag . equals Ignore Case ( UNKNOWN ) ) { set Provision Driver ( UNKNOWN ) ; } else { throw new Exception ( STRING + tag ) ; } } else { throw new Exception ( STRING + key ) ; } } }
private void fit Image To View ( ) { Drawable drawable = get Drawable ( ) ; if ( drawable == null || drawable . get Intrinsic Width ( ) == NUM || drawable . get Intrinsic Height ( ) == NUM ) { return ; } if ( matrix == null || prev Matrix == null ) { return ; } int drawable Width = drawable . get Intrinsic Width ( ) ; int drawable Height = drawable . get Intrinsic Height ( ) ; float scale X = ( float ) view Width / drawable Width ; float scale Y = ( float ) view Height / drawable Height ; switch ( m Scale Type ) { case CENTER : scale X = scale Y = NUM ; break ; case CENTER CROP : scale X = scale Y = Math . max ( scale X , scale Y ) ; break ; case CENTER INSIDE : scale X = scale Y = Math . min ( NUM , Math . min ( scale X , scale Y ) ) ; case FIT CENTER : scale X = scale Y = Math . min ( scale X , scale Y ) ; break ; case FIT XY : break ; default : throw new Unsupported Operation Exception ( STRING ) ; } float redundant X Space = view Width - ( scale X * drawable Width ) ; float redundant Y Space = view Height - ( scale Y * drawable Height ) ; match View Width = view Width - redundant X Space ; match View Height = view Height - redundant Y Space ; if ( ! is Zoomed ( ) ) { matrix . set Scale ( scale X , scale Y ) ; matrix . post Translate ( redundant X Space / NUM , redundant Y Space / NUM ) ; normalized Scale = NUM ; } else { prev Matrix . get Values ( m ) ; m [ Matrix . MSCALE X ] = match View Width / drawable Width * normalized Scale ; m [ Matrix . MSCALE Y ] = match View Height / drawable Height * normalized Scale ; float trans X = m [ Matrix . MTRANS X ] ; float trans Y = m [ Matrix . MTRANS Y ] ; float prev Actual Width = prev Match View Width * normalized Scale ; float actual Width = get Image Width ( ) ; translate Matrix After Rotate ( Matrix . MTRANS X , trans X , prev Actual Width , actual Width , prev View Width , view Width , drawable Width ) ; float prev Actual Height = prev Match View Height * normalized Scale ; float actual Height = get Image Height ( ) ; translate Matrix After Rotate ( Matrix . MTRANS Y , trans Y , prev Actual Height , actual Height , prev View Height , view Height , drawable Height ) ; matrix . set Values ( m ) ; } fix Trans ( ) ; set Image Matrix ( matrix ) ; }
public synchronized void close ( ) { if ( is Alive ) { is Alive = BOOL ; task Queue . clear ( ) ; interrupt ( ) ; } }
public String remove After ( String original , String marker ) { int index = original . index Of ( marker ) ; if ( index != - NUM ) { return original . substring ( NUM , index ) ; } return original ; }
public Address sub ( final Object rhs ) { return new Address ( m value . subtract ( get Big Integer ( rhs ) ) ) ; }
public static Test Configuration build Default Configuration ( String test Source Path , File test File , String checker Name , List < String > options , boolean should Emit Debug Info ) { List < File > java Files = Arrays . as List ( test File ) ; List < String > processors = Arrays . as List ( checker Name ) ; return build Default Configuration ( test Source Path , java Files , processors , options , should Emit Debug Info ) ; }
private static boolean eq ( Object o1 , Object o2 ) { return ( o1 == null ? o2 == null : o1 . equals ( o2 ) ) ; }
public void roll ( int field , int value ) { boolean increment = value >= NUM ; int count = increment ? value : - value ; for ( int i = NUM ; i < count ; i ++ ) { roll ( field , increment ) ; } }
public String cluster Results To String ( ) { return m clustering Results . to String ( ) ; }
private void generate Get Module Method ( New Binding Key key , New Dependency Info dependency Info ) { Type Element scope = scope Calculator . calculate ( key ) ; generate Get Module Method ( scope , dependency Info ) ; }
private void add Calendar Event ( String summary , Date start , boolean all Day , Date end , String location , String description , String [ ] attendees ) { Intent intent = new Intent ( Intent . ACTION INSERT ) ; intent . set Type ( STRING ) ; long start Milliseconds = start . get Time ( ) ; intent . put Extra ( STRING , start Milliseconds ) ; if ( all Day ) { intent . put Extra ( STRING , BOOL ) ; } long end Milliseconds ; if ( end == null ) { if ( all Day ) { end Milliseconds = start Milliseconds + NUM * NUM * NUM * NUM ; } else { end Milliseconds = start Milliseconds ; } } else { end Milliseconds = end . get Time ( ) ; } intent . put Extra ( STRING , end Milliseconds ) ; intent . put Extra ( STRING , summary ) ; intent . put Extra ( STRING , location ) ; intent . put Extra ( STRING , description ) ; if ( attendees != null ) { intent . put Extra ( Intent . EXTRA EMAIL , attendees ) ; } try { raw Launch Intent ( intent ) ; } catch ( Activity Not Found Exception anfe ) { Log . w ( TAG , STRING + Intent . ACTION INSERT ) ; intent . set Action ( Intent . ACTION EDIT ) ; launch Intent ( intent ) ; } }
private String [ ] separator And Enclosures To Array ( ) { String [ ] parts = m Enclosures . split ( STRING ) ; String [ ] result = new String [ parts . length + NUM ] ; result [ NUM ] = m Field Separator ; int index = NUM ; for ( String e : parts ) { if ( e . length ( ) > NUM || e . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } result [ index ++ ] = e ; } return result ; }
private static void Release String Chars ( JNI Environment env , int obj JREF , Address buf Address ) { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { sys Call . sys Free ( buf Address ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; } }
private Business Object Data Notification Registration Entity create Business Object Data Notification Entity ( Namespace Entity namespace Entity , Notification Event Type Entity notification Event Type Entity , Business Object Definition Entity business Object Definition Entity , File Type Entity file Type Entity , Storage Entity storage Entity , Business Object Data Status Entity new Business Object Data Status Entity , Business Object Data Status Entity old Business Object Data Status Entity , Notification Registration Key key , Business Object Data Notification Filter business Object Data Notification Filter , List < Job Action > job Actions , Notification Registration Status Entity notification Registration Status Entity ) { Business Object Data Notification Registration Entity business Object Data Notification Registration Entity = new Business Object Data Notification Registration Entity ( ) ; business Object Data Notification Registration Entity . set Namespace ( namespace Entity ) ; business Object Data Notification Registration Entity . set Name ( key . get Notification Name ( ) ) ; business Object Data Notification Registration Entity . set Notification Event Type ( notification Event Type Entity ) ; business Object Data Notification Registration Entity . set Business Object Definition ( business Object Definition Entity ) ; if ( String Utils . is Not Blank ( business Object Data Notification Filter . get Business Object Format Usage ( ) ) ) { business Object Data Notification Registration Entity . set Usage ( business Object Data Notification Filter . get Business Object Format Usage ( ) ) ; } business Object Data Notification Registration Entity . set File Type ( file Type Entity ) ; business Object Data Notification Registration Entity . set Business Object Format Version ( business Object Data Notification Filter . get Business Object Format Version ( ) ) ; business Object Data Notification Registration Entity . set Storage ( storage Entity ) ; business Object Data Notification Registration Entity . set New Business Object Data Status ( new Business Object Data Status Entity ) ; business Object Data Notification Registration Entity . set Old Business Object Data Status ( old Business Object Data Status Entity ) ; business Object Data Notification Registration Entity . set Notification Registration Status ( notification Registration Status Entity ) ; List < Notification Action Entity > notification Action Entities = new Array List < > ( ) ; business Object Data Notification Registration Entity . set Notification Actions ( notification Action Entities ) ; for ( Job Action job Action : job Actions ) { Job Definition Entity job Definition Entity = job Definition Dao Helper . get Job Definition Entity ( job Action . get Namespace ( ) , job Action . get Job Name ( ) ) ; Notification Job Action Entity notification Job Action Entity = new Notification Job Action Entity ( ) ; notification Action Entities . add ( notification Job Action Entity ) ; notification Job Action Entity . set Job Definition ( job Definition Entity ) ; notification Job Action Entity . set Correlation Data ( job Action . get Correlation Data ( ) ) ; notification Job Action Entity . set Notification Registration ( business Object Data Notification Registration Entity ) ; } return business Object Data Notification Registration Entity ; }
void bind ( String jndi Url , Hashtable < ? , ? > attributes , RMI Server rmi Server , boolean rebind ) throws Naming Exception , Malformed URL Exception { Initial Context ctx = new Initial Context ( attributes ) ; if ( rebind ) ctx . rebind ( jndi Url , rmi Server ) ; else ctx . bind ( jndi Url , rmi Server ) ; ctx . close ( ) ; }
public String to String ( ) { if ( info == null || alg Id == null || signature == null ) return STRING ; String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; sb . append ( info . to String ( ) + STRING ) ; sb . append ( STRING + alg Id . to String ( ) + STRING ) ; Hex Dump Encoder encoder = new Hex Dump Encoder ( ) ; sb . append ( STRING + encoder . encode Buffer ( signature ) ) ; sb . append ( STRING ) ; return sb . to String ( ) ; }
public void test Obsolete Dst Zone Name ( ) throws Exception { Simple Date Format format = new Simple Date Format ( STRING , Locale . US ) ; Date normal = format . parse ( STRING ) ; Date dst = format . parse ( STRING ) ; assert Equals ( NUM * NUM * NUM , normal . get Time ( ) - dst . get Time ( ) ) ; }
public final void Xprint Latin 1 No Lf ( String string ) throws IO Exception { if ( source == null ) { return ; } if ( string == null ) { string = STRING ; } byte [ ] write Buffer = write Buffer ; int write Length = write Length ; int length = string . length ( ) ; int offset = NUM ; int chars Length = CHARS LENGTH ; char [ ] chars = chars ; while ( length > NUM ) { int sublen = Math . min ( chars Length , write Buffer . length - write Length ) ; if ( sublen <= NUM ) { source . write ( write Buffer , NUM , write Length , BOOL ) ; position += write Length ; is Flush Required = BOOL ; write Length = NUM ; sublen = Math . min ( chars Length , write Buffer . length - write Length ) ; } sublen = Math . min ( length , sublen ) ; string . get Chars ( offset , sublen , chars , NUM ) ; for ( int i = NUM ; i < sublen ; i ++ ) { byte value = ( byte ) chars [ i ] ; if ( value == STRING || value == STRING ) { length = NUM ; break ; } write Buffer [ write Length ++ ] = value ; } offset += sublen ; length -= sublen ; } write Length = write Length ; }
private int calculate Stroke Weight ( ) { int stroke Weight = ( int ) ( get Stroke Width ( ) * NUM ) ; LOGGER . trace ( STRING , stroke Width ) ; return stroke Weight ; }
private static List < Match Result > flatten Results ( List < List < Match Result > > all Results ) { List < Match Result > results = new Array List < Match Result > ( ) ; results . add All ( all Results . remove ( NUM ) ) ; for ( List < Match Result > rel Results : all Results ) { List < Match Result > new Results = new Array List < Match Result > ( ) ; for ( Match Result cur Result : results ) { for ( Match Result rel Result : rel Results ) { Match Result new Result = cur Result . copy ( ) ; new Result . add Assignment ( rel Result ) ; new Results . add ( new Result ) ; } } results = new Results ; } return results ; }
@ Override public void visit ( Mapping m , int line , int col , int next Line , int next Col ) throws IO Exception { if ( previous Line != line ) { previous Column = NUM ; } if ( line != next Line || col != next Col ) { if ( line < max Line ) { if ( previous Line == line ) { out . append ( STRING ) ; } write Entry ( m , col ) ; previous Line = line ; previous Column = col ; } else { Preconditions . check State ( m == null ) ; } } for ( int i = line ; i <= next Line && i < max Line ; i ++ ) { if ( i == next Line ) { break ; } close Line ( BOOL ) ; open Line ( BOOL ) ; } }
public boolean on Click ( int position ) { if ( m Mode == MODE MULTIPLE SELECT ) { if ( m Selected Items . contains ( position ) ) { m Selected Items . remove ( position ) ; if ( m Selected Items . is Empty ( ) ) { set Mode ( MODE SINGLE SELECT ) ; } } else { m Selected Items . add ( position ) ; } notify Selection Changed ( position ) ; return BOOL ; } return BOOL ; }
public void add Session Event URL ( String url , Session ID sid ) { Set < Session ID > sids = session Event UR Ls . get ( url ) ; if ( sids == null ) { sids = Collections . new Set From Map ( new Concurrent Hash Map < Session ID , Boolean > ( ) ) ; Set < Session ID > previous Value = session Event UR Ls . put If Absent ( url , sids ) ; if ( previous Value != null ) { sids = previous Value ; } } if ( sids . add ( sid ) ) { notify Persistence Manager ( ) ; } }
abstract public long range Count ( ) ;
public final void add Inst With Unknown ( Instances source , int att Index ) throws Exception { double [ ] probs ; double weight , new Weight ; int class Index ; Instance instance ; int j ; probs = new double [ m per Bag . length ] ; for ( j = NUM ; j < m per Bag . length ; j ++ ) { if ( Utils . eq ( tota L , NUM ) ) { probs [ j ] = NUM / probs . length ; } else { probs [ j ] = m per Bag [ j ] / tota L ; } } Enumeration < Instance > enu = source . enumerate Instances ( ) ; while ( enu . has More Elements ( ) ) { instance = enu . next Element ( ) ; if ( instance . is Missing ( att Index ) ) { class Index = ( int ) instance . class Value ( ) ; weight = instance . weight ( ) ; m per Class [ class Index ] = m per Class [ class Index ] + weight ; tota L = tota L + weight ; for ( j = NUM ; j < m per Bag . length ; j ++ ) { new Weight = probs [ j ] * weight ; m per Class Per Bag [ j ] [ class Index ] = m per Class Per Bag [ j ] [ class Index ] + new Weight ; m per Bag [ j ] = m per Bag [ j ] + new Weight ; } } } }
@ Override public void on Item Click ( Adapter View < ? > parent , View view , int position , long id ) { set Selection ( position ) ; }
public void traverse Fragment ( Node pos ) throws org . xml . sax . SAX Exception { Node top = pos ; while ( null != pos ) { start Node ( pos ) ; Node next Node = pos . get First Child ( ) ; while ( null == next Node ) { end Node ( pos ) ; if ( top . equals ( pos ) ) break ; next Node = pos . get Next Sibling ( ) ; if ( null == next Node ) { pos = pos . get Parent Node ( ) ; if ( ( null == pos ) || ( top . equals ( pos ) ) ) { if ( null != pos ) end Node ( pos ) ; next Node = null ; break ; } } } pos = next Node ; } }
public void update Processor Duration ( Duration duration ) { processor duration = Optional . of ( duration ) ; }
static Object invoke Or Die ( Method method , Object object , Object ... params ) { try { return method . invoke ( object , params ) ; } catch ( Illegal Access Exception e ) { throw new Runtime Exception ( STRING + STRING , e ) ; } catch ( Invocation Target Exception e ) { final Throwable cause = e . get Cause ( ) ; if ( cause instanceof Runtime Exception ) { throw ( Runtime Exception ) cause ; } else if ( cause instanceof Error ) { throw ( Error ) cause ; } else { throw new Runtime Exception ( STRING , cause ) ; } } }
public void start Element ( String uri , String local Name , String q Name , Attributes atts ) throws SAX Exception { element Level ++ ; ns Support . push Context ( ) ; if ( force DTD && ! has Output DTD ) start DTD ( local Name == null ? q Name : local Name , STRING , STRING ) ; write ( STRING ) ; write Name ( uri , local Name , q Name , BOOL ) ; write Attributes ( atts ) ; if ( element Level == NUM ) { force NS Decls ( ) ; } write NS Decls ( ) ; write ( STRING ) ; if ( html Mode && ( q Name . equals ( STRING ) || q Name . equals ( STRING ) ) ) { cdata Element = BOOL ; } super . start Element ( uri , local Name , q Name , atts ) ; }
void init Program ( ) { gl Use Program ( this . program ) ; view Matrix Uniform = gl Get Uniform Location ( this . program , STRING ) ; proj Matrix Uniform = gl Get Uniform Location ( this . program , STRING ) ; viewport Size Uniform = gl Get Uniform Location ( this . program , STRING ) ; gl Use Program ( NUM ) ; }
public static String [ ] sort Copy ( String [ ] objects ) { int len = objects . length ; String [ ] copy = new String [ len ] ; System . arraycopy ( objects , NUM , copy , NUM , len ) ; sort ( copy ) ; return copy ; }
public Iterator < Sim Event > iterator ( ) { return list . iterator ( ) ; }
private static boolean accepts ( String accept header , String to accept ) { String [ ] accept Values = accept header . split ( STRING ) ; Arrays . sort ( accept Values ) ; return Arrays . binary Search ( accept Values , to accept ) > - NUM || Arrays . binary Search ( accept Values , to accept . replace All ( STRING , STRING ) ) > - NUM || Arrays . binary Search ( accept Values , STRING ) > - NUM ; }
public String [ ] tokenize ( String raw String ) { Vector < String > result = new Vector < String > ( ) ; String Tokenizer tk = new String Tokenizer ( raw String , m Seperator ) ; while ( tk . has More Tokens ( ) ) { result . add Element ( tk . next Token ( ) ) ; } String [ ] new Strings = new String [ result . size ( ) ] ; for ( int i = NUM ; i < result . size ( ) ; i ++ ) { new Strings [ i ] = result . element At ( i ) ; } return new Strings ; }
public synchronized void return Log Cursor ( Log Cursor log Cursor ) { log Cursor . set Loaned ( BOOL ) ; }
void unassign Policies ( String service Name , Set policy D Ns , boolean to Verify ) throws AM Exception , SSO Exception { if ( ( policy D Ns == null ) || ( policy D Ns . is Empty ( ) ) ) { return ; } AM Template template = get Template ( service Name , AM Template . POLICY TEMPLATE ) ; unassign Policies ( template , policy D Ns , to Verify ) ; }
public boolean release Lock ( String lock Name ) { if ( lock Name == null || lock Name . is Empty ( ) ) { s logger . info ( STRING ) ; return BOOL ; } try { Inter Process Lock lock = s acquired Locks . get ( lock Name ) ; if ( lock != null ) { s acquired Locks . remove ( lock Name ) ; lock . release ( ) ; s logger . info ( STRING + lock Name ) ; } else { return BOOL ; } return BOOL ; } catch ( Exception e ) { s logger . error ( STRING , lock Name , e ) ; return BOOL ; } }
@ Parameterized . Parameters ( name = STRING ) public static Collection < Payment Channel Client . Version Selector > data ( ) { return Arrays . as List ( Payment Channel Client . Version Selector . VERSION 1 , Payment Channel Client . Version Selector . VERSION 2 ALLOW 1 ) ; }
private View find Intercepting View ( float pos , View v ) { for ( Key Button View other View : m Button Views ) { if ( other View == v ) { continue ; } if ( Array Utils . contains ( SMALL BUTTON IDS , other View . get Id ( ) ) ) { continue ; } other View . get Location On Screen ( s Location ) ; float other Pos = s Location [ m Vertical ? NUM : NUM ] ; float other Dimension = m Vertical ? v . get Height ( ) : v . get Width ( ) ; if ( pos > ( other Pos + other Dimension / NUM ) && pos < ( other Pos + other Dimension ) ) { return other View ; } } return null ; }
public void detach Disk Async ( final String vm Id , Vm Disk Operation vm Disk Operation , final Future Callback < Task > response Callback ) throws IO Exception { String path = String . format ( STRING , get Base Path ( ) , vm Id ) ; create Object Async ( path , serialize Object As Json ( vm Disk Operation ) , response Callback ) ; }
public static void main ( String [ ] args ) { Log . print Line ( STRING ) ; try { int num user = NUM ; Calendar calendar = Calendar . get Instance ( ) ; boolean trace flag = BOOL ; Cloud Sim . init ( num user , calendar , trace flag ) ; @ Suppress Warnings ( STRING ) Datacenter datacenter 0 = create Datacenter ( STRING ) ; @ Suppress Warnings ( STRING ) Datacenter datacenter 1 = create Datacenter ( STRING ) ; Datacenter Broker broker 1 = create Broker ( NUM ) ; int broker Id 1 = broker 1 . get Id ( ) ; Datacenter Broker broker 2 = create Broker ( NUM ) ; int broker Id 2 = broker 2 . get Id ( ) ; vmlist 1 = new Array List < Vm > ( ) ; vmlist 2 = new Array List < Vm > ( ) ; int vmid = NUM ; int mips = NUM ; long size = NUM ; int ram = NUM ; long bw = NUM ; int pes Number = NUM ; String vmm = STRING ; Vm vm 1 = new Vm ( vmid , broker Id 1 , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; Vm vm 2 = new Vm ( vmid , broker Id 2 , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; vmlist 1 . add ( vm 1 ) ; vmlist 2 . add ( vm 2 ) ; broker 1 . submit Vm List ( vmlist 1 ) ; broker 2 . submit Vm List ( vmlist 2 ) ; cloudlet List 1 = new Array List < Cloudlet > ( ) ; cloudlet List 2 = new Array List < Cloudlet > ( ) ; int id = NUM ; long length = NUM ; long file Size = NUM ; long output Size = NUM ; Utilization Model utilization Model = new Utilization Model Full ( ) ; Cloudlet cloudlet 1 = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 1 . set User Id ( broker Id 1 ) ; Cloudlet cloudlet 2 = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 2 . set User Id ( broker Id 2 ) ; cloudlet List 1 . add ( cloudlet 1 ) ; cloudlet List 2 . add ( cloudlet 2 ) ; broker 1 . submit Cloudlet List ( cloudlet List 1 ) ; broker 2 . submit Cloudlet List ( cloudlet List 2 ) ; Cloud Sim . start Simulation ( ) ; List < Cloudlet > new List 1 = broker 1 . get Cloudlet Received List ( ) ; List < Cloudlet > new List 2 = broker 2 . get Cloudlet Received List ( ) ; Cloud Sim . stop Simulation ( ) ; Log . print ( STRING + broker Id 1 + STRING ) ; print Cloudlet List ( new List 1 ) ; Log . print ( STRING + broker Id 2 + STRING ) ; print Cloudlet List ( new List 2 ) ; Log . print Line ( STRING ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; Log . print Line ( STRING ) ; } }
public static boolean is FP Zero ( @ Not Null final String text ) { for ( int i = NUM ; i < text . length ( ) ; i ++ ) { final char c = text . char At ( i ) ; if ( Character . is Digit ( c ) && c != STRING ) return BOOL ; final char d = Character . to Upper Case ( c ) ; if ( d == STRING || d == STRING ) break ; } return BOOL ; }
public Concurrent Hash Map Pro ( Map < ? extends K , ? extends V > m ) { this ( Math . max ( ( int ) ( m . size ( ) / DEFAULT LOAD FACTOR ) + NUM , DEFAULT INITIAL CAPACITY ) , DEFAULT LOAD FACTOR , DEFAULT CONCURRENCY LEVEL ) ; put All ( m ) ; }
static < K > void generate ( Array List < K > list , Universal Hash < K > hash , int level , int seed , Byte Array Output Stream out ) { int size = list . size ( ) ; if ( size <= NUM ) { out . write ( size ) ; return ; } if ( level > NUM ) { throw new Illegal State Exception ( STRING + STRING ) ; } if ( size <= MAX SIZE ) { int max Offset = MAX OFFSETS [ size ] ; int [ ] hashes = new int [ size ] ; for ( int i = NUM ; i < size ; i ++ ) { hashes [ i ] = hash . hash Code ( list . get ( i ) , level , seed ) ; } int test Size = size ; if ( size >= SPEEDUP ) { test Size ++ ; max Offset /= test Size ; } next Offset : for ( int offset = NUM ; offset < max Offset ; offset ++ ) { int bits = NUM ; for ( int i = NUM ; i < size ; i ++ ) { int x = hashes [ i ] ; int h = hash ( x , level , offset , test Size ) ; if ( ( bits & ( NUM << h ) ) != NUM ) { continue next Offset ; } bits |= NUM << h ; } if ( size >= SPEEDUP ) { int pos = Integer . number Of Trailing Zeros ( ~ bits ) ; write Size Offset ( out , size , offset * ( size + NUM ) + pos ) ; } else { write Size Offset ( out , size , offset ) ; } return ; } } int split ; if ( size > NUM * DIVIDE ) { split = size / ( NUM * DIVIDE ) ; } else { split = ( size - NUM ) / DIVIDE ; } split = Math . max ( NUM , split ) ; boolean is Root = level == NUM ; Array List < Array List < K > > lists ; do { lists = new Array List < Array List < K > > ( split ) ; for ( int i = NUM ; i < split ; i ++ ) { lists . add ( new Array List < K > ( size / split ) ) ; } for ( int i = NUM ; i < size ; i ++ ) { K x = list . get ( i ) ; Array List < K > l = lists . get ( hash ( x , hash , level , seed , NUM , split ) ) ; l . add ( x ) ; if ( is Root && split >= SPLIT MANY && l . size ( ) > NUM * DIVIDE * NUM ) { level ++ ; lists = null ; break ; } } } while ( lists == null ) ; if ( split >= SPLIT MANY ) { out . write ( SPLIT MANY ) ; } write Var Int ( out , split ) ; boolean multi Threaded = is Root && list . size ( ) > NUM ; list . clear ( ) ; list . trim To Size ( ) ; if ( multi Threaded ) { generate Multi Threaded ( lists , hash , level , seed , out ) ; } else { for ( Array List < K > s2 : lists ) { generate ( s2 , hash , level + NUM , seed , out ) ; } } if ( is Root && split >= SPLIT MANY ) { out . write ( level ) ; } }
private void initialise Commands ( ) { reward = new Achievement Rewards ( this ) ; achievement Display = new Achievement Display ( this ) ; give Command = new Give Command ( this ) ; book Command = new Book Command ( this ) ; top Command = new Top Command ( this ) ; stats Command = new Stats Command ( this ) ; info Command = new Info Command ( this ) ; list Command = new List Command ( this ) ; help Command = new Help Command ( this ) ; check Command = new Check Command ( this ) ; delete Command = new Delete Command ( this ) ; }
public Create Custom Metric ( Monitoring monitoring Service , String project Resource ) { this . monitoring Service = monitoring Service ; this . project Resource = project Resource ; this . metric Type = CUSTOM METRIC DOMAIN + STRING + DEFAULT METRIC TYPE ; this . metric Name = project Resource + STRING + metric Type ; }
private boolean journal Rebuild Required ( ) { final int REDUNDANT OP COMPACT THRESHOLD = NUM ; return redundant Op Count >= REDUNDANT OP COMPACT THRESHOLD && redundant Op Count >= lru Entries . size ( ) ; }
public static boolean delete Files In A Directory ( String directory Path ) { if ( ( directory Path == null ) || directory Path . is Empty ( ) ) { return BOOL ; } boolean is Successful Delete = BOOL ; List < File > files = get List Of Files In A Directory ( directory Path ) ; if ( files == null ) { return BOOL ; } try { for ( File file : files ) { boolean file Delete Success = delete File ( directory Path , file . get Name ( ) ) ; if ( ! file Delete Success ) { is Successful Delete = BOOL ; } } } catch ( Exception e ) { logger . debug ( e . to String ( ) + System . line Separator ( ) + Stack Trace . get String From Stack Trace ( e ) ) ; is Successful Delete = BOOL ; } return is Successful Delete ; }
public Annotation FS add ( Annotation FS a Origin Fs , Annotation FS a Target Fs , J Cas aJ Cas , int a Start , int a End , Annotation Feature a Feature , Object a Label Value ) throws Brat Annotation Exception { if ( cross Multiple Sentence || is Same Sentence ( aJ Cas , a Origin Fs . get Begin ( ) , a Target Fs . get End ( ) ) ) { return interal Add To Cas ( aJ Cas , a Start , a End , a Origin Fs , a Target Fs , a Label Value , a Feature ) ; } else { throw new Arc Crossed Multiple Sentence Exception ( STRING ) ; } }
public void test Equals Null ( ) { String a = STRING ; int a Scale = - NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; assert False ( a Number . equals ( null ) ) ; }
private String read Line ( ) { String Buffer sb = new String Buffer ( ) ; while ( buf . remaining ( ) > NUM ) { char c = ( char ) buf . get ( ) ; if ( c == STRING ) { if ( buf . remaining ( ) > NUM ) { char n = ( char ) buf . get ( buf . position ( ) ) ; if ( n == STRING ) { buf . get ( ) ; } } break ; } else if ( c == STRING ) { break ; } sb . append ( c ) ; } return sb . to String ( ) ; }
protected void write ( Data Output Stream stream ) throws Exception { stream . write Int ( value ) ; }
@ Override public int show Open Dialog ( Component parent ) { File sel File ; int result ; m Dialog Type = OPEN DIALOG ; init GUI ( OPEN DIALOG ) ; result = super . show Open Dialog ( parent ) ; m Dialog Type = UNHANDLED DIALOG ; remove Property Change Listener ( m Listener ) ; sel File = get Selected File ( ) ; if ( ( result == APPROVE OPTION ) && ( get File Must Exist ( ) ) && ( sel File == null ) ) { result = show Open Dialog ( parent ) ; } else if ( ( result == APPROVE OPTION ) && ( get File Must Exist ( ) ) && ( sel File != null ) && ( sel File . is File ( ) ) && ( ! sel File . exists ( ) ) ) { int ret Val = J Option Pane . show Confirm Dialog ( parent , STRING + sel File + STRING ) ; if ( ret Val == J Option Pane . OK OPTION ) result = show Open Dialog ( parent ) ; else result = CANCEL OPTION ; } if ( result == APPROVE OPTION ) { if ( get File Filter ( ) instanceof Extension File Filter ) m Last Filter = ( Extension File Filter ) get File Filter ( ) ; else m Last Filter = null ; if ( get Selected File ( ) != null ) configure Current Handler Hook ( OPEN DIALOG ) ; } return result ; }
public boolean is Nearly Equal To ( Double Vector v , double tolerance ) { return Math . abs ( v . x - x ) < tolerance && Math . abs ( v . y - y ) < tolerance && Math . abs ( v . z - z ) < tolerance ; }
private float color To Angle ( int color ) { float [ ] colors = new float [ NUM ] ; Color . color To HSV ( color , colors ) ; return ( float ) Math . to Radians ( - colors [ NUM ] ) ; }
void create Vertical Snap Animation ( boolean visible ) { float translation Y = visible ? NUM : m Total Height ; float y Difference = Math . abs ( translation Y - get Translation Y ( ) ) / m Total Height ; long duration = ( long ) ( MS ANIMATION DURATION * y Difference ) ; create Animation ( NUM , NUM , translation Y , duration ) ; }
@ Override public int update ( byte [ ] input , int input Offset , int input Len , byte [ ] output , int output Offset ) throws Short Buffer Exception { return cipher . update ( input , input Offset , input Len , output , output Offset ) ; }
private String validate Inputs ( ) { if ( jar Radio . get Selection ( ) ) { File f = new File ( jar Path . get Text ( ) ) ; if ( ! f . exists ( ) ) { return STRING ; } if ( ! f . can Read ( ) ) { return STRING ; } } else { File f = new File ( dir Path . get Text ( ) ) ; if ( ! f . exists ( ) ) { return STRING ; } if ( ! f . can Read ( ) ) { return STRING ; } } return null ; }
public static double parse Double String ( String st , T Execution Context context ) { double ret = NUM ; Matcher m = DOUBLE PATTERN . matcher ( st ) ; if ( m . looking At ( ) ) { String truncated = st . substring ( NUM , m . end ( ) ) ; if ( ! truncated . equals ( st ) ) { context . report Truncate ( st , truncated ) ; } try { ret = Double . parse Double ( truncated ) ; } catch ( Number Format Exception e ) { context . report Bad Value ( e . get Message ( ) ) ; } } else context . report Bad Value ( st ) ; return ret ; }
public Class Path ( Dex File ... class Path ) throws IO Exception { this ( Lists . new Array List ( class Path ) , NUM ) ; }
public double great Circle Azimuth ( Location location ) { if ( location == null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STRING , STRING , STRING ) ) ; } double lat 1 = Math . to Radians ( this . latitude ) ; double lon 1 = Math . to Radians ( this . longitude ) ; double lat 2 = Math . to Radians ( location . latitude ) ; double lon 2 = Math . to Radians ( location . longitude ) ; if ( lat 1 == lat 2 && lon 1 == lon 2 ) { return NUM ; } if ( lon 1 == lon 2 ) { return lat 1 > lat 2 ? NUM : NUM ; } double y = Math . cos ( lat 2 ) * Math . sin ( lon 2 - lon 1 ) ; double x = Math . cos ( lat 1 ) * Math . sin ( lat 2 ) - Math . sin ( lat 1 ) * Math . cos ( lat 2 ) * Math . cos ( lon 2 - lon 1 ) ; double azimuth Radians = Math . atan 2 ( y , x ) ; return Double . is Na N ( azimuth Radians ) ? NUM : Math . to Degrees ( azimuth Radians ) ; }
private boolean [ ] define Irrelevant ( Random random ) { boolean [ ] irr = new boolean [ get Num Attributes ( ) ] ; for ( int i = NUM ; i < irr . length ; i ++ ) { irr [ i ] = BOOL ; } int num Irr = NUM ; for ( int i = NUM ; ( num Irr < get Num Irrelevant ( ) ) && ( i < get Num Attributes ( ) * NUM ) ; i ++ ) { int maybe Next = ( int ) ( random . next Double ( ) * irr . length ) ; if ( irr [ maybe Next ] == BOOL ) { irr [ maybe Next ] = BOOL ; num Irr ++ ; } } return irr ; }
public void add Drop Item ( final String name , final double probability , final int amount ) { drops Items . add ( new Drop Item ( name , probability , amount ) ) ; }
protected void unparsed Ent Decl ( String name , String pubid , String sysid , String notation ) throws SAX Exception { m Hand Dtd . unparsed Entity Decl ( name , pubid , sysid , notation ) ; }
public Enumeration < Permission > elements ( ) { synchronized ( this ) { return Collections . enumeration ( perms Map . values ( ) ) ; } }
private static String format List ( String [ ] string List , String list Pattern , String list Composition Pattern ) { if ( list Pattern == null || list Composition Pattern == null ) { String Builder result = new String Builder ( ) ; for ( int i = NUM ; i < string List . length ; ++ i ) { if ( i > NUM ) { result . append ( STRING ) ; } result . append ( string List [ i ] ) ; } return result . to String ( ) ; } if ( string List . length > NUM ) { Message Format format = new Message Format ( list Composition Pattern ) ; string List = compose List ( format , string List ) ; } Object [ ] args = new Object [ string List . length + NUM ] ; System . arraycopy ( string List , NUM , args , NUM , string List . length ) ; args [ NUM ] = new Integer ( string List . length ) ; Message Format format = new Message Format ( list Pattern ) ; return format . format ( args ) ; }
public Json Array add ( Object value ) { list . add ( value ) ; return this ; }
public String comment ( ) throws Parse Exception { String Buffer retval = new String Buffer ( ) ; if ( look Ahead ( NUM ) != STRING ) return null ; consume ( NUM ) ; while ( BOOL ) { char next = get Next Char ( ) ; if ( next == STRING ) { break ; } else if ( next == STRING ) { throw new Parse Exception ( this . buffer + STRING , this . ptr ) ; } else if ( next == STRING ) { retval . append ( next ) ; next = get Next Char ( ) ; if ( next == STRING ) throw new Parse Exception ( this . buffer + STRING , this . ptr ) ; retval . append ( next ) ; } else { retval . append ( next ) ; } } return retval . to String ( ) ; }
public static boolean ignorable Whitespace ( String value ) { Matcher m ; m = whitespace Pattern . matcher ( value ) ; if ( m . matches ( ) ) return BOOL ; else return BOOL ; }
public Delphi Workgroup ( File xml File ) throws IO Exception { if ( xml File == null ) { throw new Illegal Argument Exception ( STRING ) ; } else if ( ! xml File . exists ( ) ) { throw new IO Exception ( STRING + xml File . get Absolute Path ( ) ) ; } parse File ( xml File ) ; }
public Buffered Block Cipher ( Block Cipher cipher ) { this . cipher = cipher ; buf = new byte [ cipher . get Block Size ( ) ] ; buf Off = NUM ; String name = cipher . get Algorithm Name ( ) ; int idx = name . index Of ( STRING ) + NUM ; pgp CFB = ( idx > NUM && name . starts With ( STRING , idx ) ) ; if ( pgp CFB || cipher instanceof Stream Cipher ) { partial Block Okay = BOOL ; } else { partial Block Okay = ( idx > NUM && ( name . starts With ( STRING , idx ) ) ) ; } }
public static int read Ints ( final File f , final Long Index a , final long offset , final long addend ) throws IO Exception { return read Ints ( f , NUM , ( int ) f . length ( ) / NUM , a , offset , addend ) ; }
public void wait All Sites Db Stable ( ) { String prefix = STRING ; log . info ( prefix ) ; Db Jmx Client geo Instance = get Jmx Client ( LOCALHOST ) ; List < URI > vdc Id Iter = query By Type ( Virtual Data Center . class , BOOL ) ; for ( URI vdc Id : vdc Id Iter ) { log . info ( STRING , vdc Id . to String ( ) ) ; Virtual Data Center vdc = query Object ( Virtual Data Center . class , vdc Id ) ; if ( ! should Check Db Status ( vdc ) ) { log . error ( STRING , vdc Id ) ; continue ; } if ( vdc . get Connection Status ( ) != Connection Status . DISCONNECTED ) { Site active Site = dr Util . get Active Site ( vdc . get Short Id ( ) ) ; wait Db Nodes Stable ( geo Instance , vdc . get Short Id ( ) , active Site . get Node Count ( ) ) ; } } }
public void save Hierarchy State ( Bundle container ) { dispatch Save Instance State ( container ) ; }
private static void pipe ( Input Stream source , Output Stream dest ) throws IO Exception { byte [ ] buf = new byte [ NUM ] ; int read = NUM ; while ( ( read = source . read ( buf ) ) >= NUM ) { if ( null != dest ) dest . write ( buf , NUM , read ) ; } if ( null != dest ) dest . flush ( ) ; }
@ Override public void init ( Filter Config config ) throws Servlet Exception { try { expiry = Math . min ( Math . max ( MIN EXPIRY , Long . parse Long ( config . get Init Parameter ( CACHE CONTROL ) ) ) , MAX EXPIRY ) ; } catch ( Number Format Exception nfe ) { LOGGER . warn ( STRING + CACHE CONTROL + STRING , nfe ) ; expiry = null ; } }
@ Override public int hash Code ( ) { int code = NUM ; if ( name != null ) { code += name . hash Code ( ) ; } if ( application Name != null ) { code += application Name . hash Code ( ) ; } if ( resource Names != null ) { code += resource Names . hash Code ( ) ; } if ( action Values != null ) { code += action Values . hash Code ( ) ; } if ( advices != null ) { code += advices . hash Code ( ) ; } if ( attributes != null ) { code += attributes . hash Code ( ) ; } return code ; }
public static boolean substract Trading Fee ( Player player , int price ) { Big Decimal fee = calculate Fee ( player , price ) ; return player . drop ( STRING , fee . int Value ( ) ) ; }
public Complex Parameter ( Math Expression expression ) { this . expression = expression ; }
@ Override public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( NUM ) ; new Vector . add Element ( STRING ) ; return new Vector . elements ( ) ; }
public Sample Driver ( ) { handlers = new Array List < Sample Handler > ( ) ; handlers . add ( new Certificate Sample Handler ( ) ) ; handlers . add ( new Group Sample Handler ( ) ) ; handlers . add ( new Solution User Sample Handler ( ) ) ; handlers . add ( new User Sample Handler ( ) ) ; }
public long [ ] read Long Array ( final int items , final JBBP Byte Order byte Order ) throws IO Exception { int pos = NUM ; if ( items < NUM ) { long [ ] buffer = new long [ INITIAL ARRAY BUFFER SIZE ] ; while ( has Available Data ( ) ) { final long next = read Long ( byte Order ) ; if ( buffer . length == pos ) { final long [ ] newbuffer = new long [ buffer . length << NUM ] ; System . arraycopy ( buffer , NUM , newbuffer , NUM , buffer . length ) ; buffer = newbuffer ; } buffer [ pos ++ ] = next ; } if ( buffer . length == pos ) { return buffer ; } final long [ ] result = new long [ pos ] ; System . arraycopy ( buffer , NUM , result , NUM , pos ) ; return result ; } else { final long [ ] buffer = new long [ items ] ; for ( int i = NUM ; i < items ; i ++ ) { buffer [ i ] = read Long ( byte Order ) ; } return buffer ; } }
private void log Graphical Buffer Occupancy ( float buffer Occupancy ) { String title = STRING ; int used = ( int ) ( buffer Occupancy * WIDTH ) ; String Builder sb = new String Builder ( ) ; sb . append ( START END CHAR ) ; sb . append ( STRING ) ; sb . append ( title ) ; for ( int i = title . length ( ) + NUM ; i < WIDTH ; i ++ ) { sb . append ( STRING ) ; } sb . append ( START END CHAR ) ; log . info ( sb . to String ( ) ) ; sb = new String Builder ( ) ; sb . append ( START END CHAR ) ; for ( int i = NUM ; i < used ; i ++ ) { sb . append ( STRING ) ; } for ( int j = used ; j < WIDTH ; j ++ ) { sb . append ( STRING ) ; } sb . append ( START END CHAR ) ; log . info ( sb . to String ( ) ) ; sb = new String Builder ( ) ; sb . append ( START END CHAR ) ; for ( int i = NUM ; i < WIDTH ; i ++ ) { sb . append ( STRING ) ; } sb . append ( START END CHAR ) ; log . info ( sb . to String ( ) ) ; }
public boolean is Terminated ( ) { return thread Pool . is Terminated ( ) ; }
public boolean is Match ( String domain , List < User Mapping Attribute > attributes , List < String > groups ) { return domain . equals Ignore Case ( domain ) && attributes Match ( attributes ) && groups Match ( groups ) ; }
public static void write Spatial Grid Table ( Spatial Grid grid , String file Name ) { log . info ( STRING + file Name + STRING ) ; Spatial Grid Table Writer sg Table Writer = new Spatial Grid Table Writer ( ) ; try { sg Table Writer . write ( grid , file Name ) ; log . info ( STRING ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
@ Suppress Warnings ( STRING ) public Output Socket linked Output Socket ( String hint Identifier ) { final Output Socket out Socket = output Socket Factory . create ( new Identifer Overriding Socket Hint Decorator ( this , hint Identifier ) ) ; controlled Output Sockets . add ( out Socket ) ; return out Socket ; }
public void cancel ( ) { cancelled = BOOL ; Thread thread = this . thread ; if ( thread != null ) { thread . interrupt ( ) ; } }
void set Text ( byte [ ] text ) { this . text = text ; this . props = null ; }
private String prepare URL ( ) { String str = STRING ; str += STRING ; for ( int i = NUM ; i < symbol List . size ( ) ; i ++ ) { if ( i != NUM ) { str += STRING ; } str += symbol List . get ( i ) ; } str += STRING ; for ( String format : parameter List ) { str += format ; } str += STRING ; return str ; }
public void initialize ( ) { Texture State ts = new Texture State ( ) ; ts . set Enabled ( BOOL ) ; set Render State ( ts ) ; for ( int i = NUM ; i < tool List . size ( ) ; ++ i ) { Tool State state = tool List . get ( i ) ; add Tool ( state , BOOL ) ; } z Buffer State = new Z Buffer State ( ) ; z Buffer State . set Function ( Z Buffer State . Test Function . Less Than Or Equal To ) ; z Buffer State . set Enabled ( BOOL ) ; set Render State ( z Buffer State ) ; }
private static void init ( ) { encoders = new Hash Map ( ) ; encoders . put ( STRING , STRING ) ; encoders . put ( STRING , STRING ) ; }
public static boolean check Image Size ( final Input Stream stream , final I Configuration conf ) throws IO Exception { Buffered Image bi = Image IO . read ( stream ) ; stream . close ( ) ; if ( bi == null ) { return BOOL ; } if ( bi . get Height ( ) > conf . get Img Height ( ) || bi . get Width ( ) > conf . get Img Width ( ) ) { return BOOL ; } return BOOL ; }
private static boolean compare Array Case ( final String value , final int comparator , final Object [ ] array ) { for ( int i = NUM ; i < array . length ; i ++ ) { final Object obj = array [ i ] ; if ( obj instanceof String ) { if ( compare String Case ( value , comparator , ( String ) obj ) ) { return BOOL ; } } else if ( obj instanceof Number ) { if ( compare Number ( value . trim ( ) , comparator , ( Number ) obj ) ) { return BOOL ; } } else { if ( compare Reflective ( value , comparator , obj ) ) { return BOOL ; } } } return BOOL ; }
public double value At ( double x ) { return constant * Math . pow ( NUM - x * x , outside Exp ) ; }
protected double generate Wait Time ( ) { if ( state == STATE WALKING ELSEWHERE ) { if ( location . equals ( latest Bus Stop ) ) { state = STATE WAITING FOR BUS ; } } if ( state == STATE TRAVELLING ON BUS ) { state = STATE WAITING FOR BUS ; } return NUM ; }
@ Override public Enumeration < URL > find Resources ( final String name ) throws IO Exception { if ( name == null ) { return null ; } Array List < URL > result = new Array List < URL > ( ) ; int n = NUM ; while ( BOOL ) { URL Handler handler = get Handler ( n ++ ) ; if ( handler == null ) { break ; } handler . find Resources ( name , result ) ; } return Collections . enumeration ( result ) ; }
protected void write Graphic Ctrl Ext ( ) throws IO Exception { out . write ( NUM ) ; out . write ( NUM ) ; out . write ( NUM ) ; int transp , disp ; if ( transparent == null ) { transp = NUM ; disp = NUM ; } else { transp = NUM ; disp = NUM ; } if ( dispose >= NUM ) { disp = dispose & NUM ; } disp <<= NUM ; out . write ( NUM | disp | NUM | transp ) ; write Short ( delay ) ; out . write ( trans Index ) ; out . write ( NUM ) ; }
public static void write Element List ( XML Output xml Output , String tag Name , Iterable < String > list Values ) throws IO Exception { write Element List ( xml Output , tag Name , list Values . iterator ( ) ) ; }
public static Date string To Date ( String date As String ) { try { Date Format df = new Simple Date Format ( date Format ) ; df . set Time Zone ( utc ) ; return df . parse ( date As String ) ; } catch ( Parse Exception e ) { return null ; } catch ( Null Pointer Exception e ) { return null ; } }
public Simple Http Request Builder content ( String chars , Charset charset ) { return content ( chars . get Bytes ( charset ) ) ; }
private double adjust Transform ( ) { double x Min = Double . POSITIVE INFINITY ; double x Max = Double . NEGATIVE INFINITY ; double y Min = Double . POSITIVE INFINITY ; double y Max = Double . NEGATIVE INFINITY ; for ( Variable var : csp . get Variables ( ) ) { Point 2 D point = get Position ( var ) ; x Min = Math . min ( x Min , point . get X ( ) ) ; x Max = Math . max ( x Max , point . get X ( ) ) ; y Min = Math . min ( y Min , point . get Y ( ) ) ; y Max = Math . max ( y Max , point . get Y ( ) ) ; } double scale = Math . min ( pane . get Width ( ) / ( x Max - x Min + NUM ) , pane . get Height ( ) / ( y Max - y Min + NUM ) ) ; pane . set Translate X ( ( scale * ( pane . get Width ( ) - x Min - x Max ) / NUM ) ) ; pane . set Translate Y ( ( scale * ( pane . get Height ( ) - y Min - y Max ) / NUM ) ) ; pane . set Scale X ( scale ) ; pane . set Scale Y ( scale ) ; return scale ; }
public void add Table Model Listener ( W Table Model Listener listener ) { if ( listener == null ) { return ; } if ( ! m listeners . contains ( listener ) ) { m listeners . add ( listener ) ; } return ; }
public boolean can Traverse Outside Subtree ( ) { if ( null != m parts ) { int n = m parts . size ( ) ; for ( int i = NUM ; i < n ; i ++ ) { AVT Part part = ( AVT Part ) m parts . element At ( i ) ; if ( part . can Traverse Outside Subtree ( ) ) return BOOL ; } } return BOOL ; }
public static Cipher Parameters make PBE Parameters ( PBE Key Spec key Spec , int type , int hash , int key Size , int iv Size ) { PBE Parameters Generator generator = make PBE Generator ( type , hash ) ; byte [ ] key ; Cipher Parameters param ; key = convert Password ( type , key Spec ) ; generator . init ( key , key Spec . get Salt ( ) , key Spec . get Iteration Count ( ) ) ; if ( iv Size != NUM ) { param = generator . generate Derived Parameters ( key Size , iv Size ) ; } else { param = generator . generate Derived Parameters ( key Size ) ; } for ( int i = NUM ; i != key . length ; i ++ ) { key [ i ] = NUM ; } return param ; }
private int [ ] parse YMD ( String string ) { string = string . trim ( ) ; try { if ( string . char At ( NUM ) != STRING || string . char At ( NUM ) != STRING ) { throw new Illegal Argument Exception ( STRING ) ; } int [ ] ymd = new int [ NUM ] ; ymd [ NUM ] = Integer . value Of ( string . substring ( NUM , NUM ) ) ; ymd [ NUM ] = Integer . value Of ( string . substring ( NUM , NUM ) ) ; ymd [ NUM ] = Integer . value Of ( string . substring ( NUM , NUM ) ) ; return ymd ; } catch ( Number Format Exception ex ) { throw new Illegal Argument Exception ( STRING , ex ) ; } }
public Abstract Point Renderer ( ) { shape = new Rectangle 2 D . Double ( - NUM , - NUM , NUM , NUM ) ; color = new Single Color ( Color . BLACK ) ; value Visible = BOOL ; value Column = NUM ; value Location = Location . CENTER ; value Alignment X = NUM ; value Alignment Y = NUM ; value Rotation = NUM ; value Distance = NUM ; value Color = new Single Color ( Color . BLACK ) ; value Font = Font . decode ( null ) ; error Visible = BOOL ; error Column Top = NUM ; error Column Bottom = NUM ; error Color = new Single Color ( Color . BLACK ) ; error Shape = new Line 2 D . Double ( - NUM , NUM , NUM , NUM ) ; error Stroke = new Basic Stroke ( NUM ) ; }
public Object put ( String key , Object value ) { Object old Value = context . get Attribute ( key , ENGINE SCOPE ) ; context . set Attribute ( key , value , ENGINE SCOPE ) ; return old Value ; }
public void test get Lowest Set Bit Pos ( ) { byte a Bytes [ ] = { - NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = NUM ; int i Number = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; int result = a Number . get Lowest Set Bit ( ) ; assert True ( STRING , result == i Number ) ; byte [ ] a Bytes = { NUM , NUM , NUM } ; i Number = NUM ; a Number = new Big Integer ( a Sign , a Bytes ) ; result = a Number . get Lowest Set Bit ( ) ; assert True ( STRING , result == i Number ) ; byte [ ] a Bytes = { - NUM , NUM , NUM } ; i Number = NUM ; a Number = new Big Integer ( a Sign , a Bytes ) ; result = a Number . get Lowest Set Bit ( ) ; assert True ( STRING , result == i Number ) ; }
private void execute Another Request ( ) throws SQL Exception { Random random = new Random ( ) ; int value = random . next Int ( ) ; Prepared Statement prepared Statement = shared Connection . prepare Statement ( STRING + value ) ; Result Set rs = prepared Statement . execute Query ( ) ; rs . next ( ) ; assert Equals ( value , rs . get Int ( NUM ) ) ; }
private void stat Init ( ) { label Value . set Text ( Msg . get Msg ( Env . get Ctx ( ) , STRING ) ) ; field Value . set Background ( Adempiere PLAF . get Info Background ( ) ) ; field Value . add Action Listener ( this ) ; label Name . set Text ( Msg . get Msg ( Env . get Ctx ( ) , STRING ) ) ; field Name . set Background ( Adempiere PLAF . get Info Background ( ) ) ; field Name . add Action Listener ( this ) ; fB Partner ID = new V Lookup ( STRING , BOOL , BOOL , BOOL , M Lookup Factory . get ( Env . get Ctx ( ) , p Window No , NUM , M Column . get Column ID ( I A Asset . Table Name , I A Asset . COLUMNNAME C B Partner ID ) , Display Type . Search ) ) ; lB Partner ID . set Label For ( fB Partner ID ) ; fB Partner ID . set Background ( Adempiere PLAF . get Info Background ( ) ) ; fB Partner ID . add Action Listener ( this ) ; f Product ID = new V Lookup ( STRING , BOOL , BOOL , BOOL , M Lookup Factory . get ( Env . get Ctx ( ) , p Window No , NUM , M Column . get Column ID ( I A Asset . Table Name , I A Asset . COLUMNNAME M Product ID ) , Display Type . Search ) ) ; l Product ID . set Label For ( f Product ID ) ; f Product ID . set Background ( Adempiere PLAF . get Info Background ( ) ) ; f Product ID . add Action Listener ( this ) ; p criteria Grid . add ( label Value , new A Layout Constraint ( NUM , NUM ) ) ; p criteria Grid . add ( field Value , null ) ; p criteria Grid . add ( lB Partner ID , null ) ; p criteria Grid . add ( fB Partner ID , null ) ; p criteria Grid . add ( label Name , new A Layout Constraint ( NUM , NUM ) ) ; p criteria Grid . add ( field Name , null ) ; p criteria Grid . add ( l Product ID , null ) ; p criteria Grid . add ( f Product ID , null ) ; }
public static int hash ( byte [ ] data , int seed ) { return hash ( Byte Buffer . wrap ( data ) , seed ) ; }
public int parse ( char c , char [ ] ia , int ip , int il ) { assert ( ia [ ip ] == c ) ; if ( Surrogate . is High ( c ) ) { if ( il - ip < NUM ) { error = Coder Result . UNDERFLOW ; return - NUM ; } char d = ia [ ip + NUM ] ; if ( Surrogate . is Low ( d ) ) { character = to UCS 4 ( c , d ) ; is Pair = BOOL ; error = null ; return character ; } error = Coder Result . malformed For Length ( NUM ) ; return - NUM ; } if ( Surrogate . is Low ( c ) ) { error = Coder Result . malformed For Length ( NUM ) ; return - NUM ; } character = c ; is Pair = BOOL ; error = null ; return character ; }
public void perform Start Operation Async ( final String vm Id , final Future Callback < Task > response Callback ) throws IO Exception { String path = String . format ( STRING , get Base Path ( ) , vm Id ) ; create Object Async ( path , null , response Callback ) ; }
private Rtp Packet parse Rtp Packet ( byte [ ] data ) { Rtp Packet packet = new Rtp Packet ( ) ; packet . m Length = data . length ; packet . m Received At = System . current Time Millis ( ) ; packet . extension = ( data [ NUM ] & NUM ) > NUM ; if ( ( byte ) ( ( data [ NUM ] & NUM ) & NUM ) == ( byte ) NUM ) { packet . marker = NUM ; } else { packet . marker = NUM ; } packet . payload Type = ( byte ) ( ( data [ NUM ] & NUM ) & NUM ) ; packet . seqnum = ( char ) ( ( data [ NUM ] << NUM ) | ( data [ NUM ] & NUM ) ) ; packet . timestamp = ( ( ( data [ NUM ] & NUM ) << NUM ) | ( ( data [ NUM ] & NUM ) << NUM ) | ( ( data [ NUM ] & NUM ) << NUM ) | ( data [ NUM ] & NUM ) ) ; packet . ssrc = ( ( ( data [ NUM ] & NUM ) << NUM ) | ( ( data [ NUM ] & NUM ) << NUM ) | ( ( data [ NUM ] & NUM ) << NUM ) | ( data [ NUM ] & NUM ) ) ; if ( packet . extension ) { int data Id = NUM ; int extension Header Id = ( ( data [ ++ data Id ] & NUM ) << NUM ) | ( data [ ++ data Id ] & NUM ) ; int length = ( ( data [ ++ data Id ] & NUM ) << NUM ) | ( data [ ++ data Id ] & NUM ) ; if ( extension Header Id == Rtp Extension Header . RTP EXTENSION HEADER ID ) { extract Extension Header ( data , length , data Id , packet ) ; } packet . payloadoffset = NUM + length * NUM ; } else { packet . payloadoffset = NUM ; } packet . payloadlength = packet . m Length - packet . payloadoffset ; packet . m Data = new byte [ packet . payloadlength ] ; System . arraycopy ( data , packet . payloadoffset , packet . m Data , NUM , packet . payloadlength ) ; return packet ; }
public String product ( Properties ctx , int Window No , Grid Tab m Tab , Grid Field m Field , Object value ) { Integer M Product ID = ( Integer ) value ; if ( M Product ID == null || M Product ID . int Value ( ) == NUM ) return STRING ; Big Decimal price Actual = null ; Timestamp Date Expense = Env . get Context As Date ( ctx , Window No , STRING ) ; if ( Date Expense == null ) Date Expense = new Timestamp ( System . current Time Millis ( ) ) ; String sql = null ; Prepared Statement pstmt = null ; Result Set rs = null ; try { boolean no Price = BOOL ; sql = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM , M Product ID . int Value ( ) ) ; pstmt . set Int ( NUM , Env . get Context As Int ( ctx , Window No , STRING ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) && no Price ) { java . sql . Date pl Date = rs . get Date ( STRING ) ; if ( pl Date == null || ! Date Expense . before ( pl Date ) ) { no Price = BOOL ; price Actual = rs . get Big Decimal ( STRING ) ; if ( price Actual == null ) price Actual = rs . get Big Decimal ( STRING ) ; if ( price Actual == null ) price Actual = rs . get Big Decimal ( STRING ) ; Integer ii = new Integer ( rs . get Int ( STRING ) ) ; if ( ! rs . was Null ( ) ) m Tab . set Value ( STRING , ii ) ; } } if ( no Price ) { sql = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; DB . close ( rs , pstmt ) ; pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM , M Product ID . int Value ( ) ) ; pstmt . set Int ( NUM , Env . get Context As Int ( ctx , Window No , STRING ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) && no Price ) { java . sql . Date pl Date = rs . get Date ( STRING ) ; if ( pl Date == null || ! Date Expense . before ( pl Date ) ) { no Price = BOOL ; price Actual = rs . get Big Decimal ( STRING ) ; if ( price Actual == null ) price Actual = rs . get Big Decimal ( STRING ) ; if ( price Actual == null ) price Actual = rs . get Big Decimal ( STRING ) ; Integer ii = new Integer ( rs . get Int ( STRING ) ) ; if ( ! rs . was Null ( ) ) m Tab . set Value ( STRING , ii ) ; } } } } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; return e . get Localized Message ( ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( price Actual == null ) price Actual = Env . ZERO ; m Tab . set Value ( STRING , price Actual ) ; return STRING ; }
public boolean this Device Speaks To ( Bluetooth Device other ) throws No Such Algorithm Exception , Unsupported Encoding Exception { if ( Murmur Service . USE BACKOFF ) return BOOL ; if ( other == null ) { log . info ( STRING ) ; return BOOL ; } String other Addr = other . get Address ( ) ; if ( other Addr == null ) { log . info ( STRING + other + STRING ) ; return BOOL ; } String my Addr = m Bluetooth Speaker . get Address ( ) ; if ( my Addr . equals ( which Initiates ( my Addr , other Addr ) ) ) { return BOOL ; } else { return BOOL ; } }
public static < K , V > List < Key Value < K , V > > wait Until Min Key Value Records Received ( Properties consumer Config , String topic , int expected Num Records , long wait Time ) throws Interrupted Exception { List < Key Value < K , V > > accum Data = new Array List < > ( ) ; long start Time = System . current Time Millis ( ) ; while ( BOOL ) { List < Key Value < K , V > > read Data = read Key Values ( topic , consumer Config ) ; accum Data . add All ( read Data ) ; if ( accum Data . size ( ) >= expected Num Records ) return accum Data ; if ( System . current Time Millis ( ) > start Time + wait Time ) throw new Assertion Error ( STRING + expected Num Records + STRING + accum Data . size ( ) + STRING + wait Time + STRING ) ; Thread . sleep ( Math . min ( wait Time , NUM ) ) ; } }
public static < T > Combined Download Task < T > single ( Download Task < T > task ) { Objects . require Non Null ( task ) ; return new Single Combined Task < T > ( task ) ; }
public void add Hex Listener ( final I Hex Panel Listener listener ) { Preconditions . check Not Null ( listener , STRING ) ; if ( ! m listeners . contains ( listener ) ) { m listeners . add ( listener ) ; } }
public static < T extends Serializable Entity > Deserializer roundtrip Serializable Entity With Binary Serializer ( final T original Entity , final Account Lookup account Lookup ) { final Binary Serializer binary Serializer = new Binary Serializer ( ) ; original Entity . serialize ( binary Serializer ) ; return new Binary Deserializer ( binary Serializer . get Bytes ( ) , new Deserialization Context ( account Lookup ) ) ; }
@ Deprecated public static String encode ( final String s , final String encoding , Bit Set safe Octets , boolean plus For Space ) throws Unsupported Encoding Exception { String Builder out = new String Builder ( s . length ( ) * NUM ) ; boolean needs Encoding ; try { needs Encoding = encode ( s , encoding , safe Octets , plus For Space , out ) ; } catch ( Unsupported Encoding Exception e ) { throw e ; } catch ( IO Exception e ) { throw new Assertion Error ( e ) ; } if ( needs Encoding ) { return out . to String ( ) ; } else { return s ; } }
public static void fire Clipboard Changed ( ) { for ( Iterator i = listener List . iterator ( ) ; i . has Next ( ) ; ) { Clipboard Listener listener = ( Clipboard Listener ) i . next ( ) ; listener . clipboard Changed ( ) ; } }
public boolean is Empty ( ) { return window . is Empty ( ) ; }
public boolean contains ( T listener ) { if ( m Listeners != null ) { return m Listeners . contains ( listener ) ; } else { return BOOL ; } }
public Simple Dictionary ( String ... a Words ) { words = new Hash Set < String > ( ) ; for ( String word : a Words ) { words . add ( word . to Lower Case ( ) ) ; } }
public long read Long LE ( ) throws IO Exception { input Stream . read Fully ( work Space , NUM , NUM ) ; return ( ( long ) ( work Space [ NUM ] & NUM ) << NUM ) | ( ( long ) ( work Space [ NUM ] & NUM ) << NUM ) | ( ( long ) ( work Space [ NUM ] & NUM ) << NUM ) | ( ( long ) ( work Space [ NUM ] & NUM ) << NUM ) | ( ( long ) ( work Space [ NUM ] & NUM ) << NUM ) | ( ( long ) ( work Space [ NUM ] & NUM ) << NUM ) | ( ( long ) ( work Space [ NUM ] & NUM ) << NUM ) | ( ( long ) ( work Space [ NUM ] & NUM ) ) ; }
public void test Set Public Key 2 ( ) throws Exception { Identity i2 = new Identity Stub ( STRING , Identity Scope . get System Scope ( ) ) ; new Public Key Stub ( STRING , STRING , new byte [ ] { NUM , NUM , NUM , NUM , NUM } ) ; try { i2 . set Public Key ( null ) ; } catch ( Key Management Exception ok ) { } }
@ Layoutlib Delegate static long elapsed Realtime ( ) { return System . current Time Millis ( ) - s Boot Time ; }
@ Override public void fill Assigned Keys ( Set < String > keys ) { keys . add ( key Column . name ( ) ) ; }
@ Override public void remove Instance Listener ( Instance Listener dsl ) { m instance Listeners . remove ( dsl ) ; }
public double eccentricity ( ) { return Math . sqrt ( NUM - ( semi Minor Axis ( ) * semi Minor Axis ( ) ) / ( semi Major Axis ( ) * semi Major Axis ( ) ) ) ; }
private void simple Apply ( I Document document , String string , Configurable Completion Proposal proposal ) throws Bad Location Exception { proposal . set Cursor Position ( string . length ( ) ) ; document . replace ( proposal . get Replacement Offset ( ) , proposal . get Replacement Length ( ) , string ) ; }
public String pull Dump 2 PC ( ) { String serial = device . get Serial Number ( ) ; File dest = new File ( File Utils . get Temp Directory ( ) , serial + STRING ) ; String path = dest . get Path ( ) ; log . debug ( STRING , path ) ; Command Line commandpull = adb Command ( STRING , STRING , path ) ; String out = execute Command Quietly ( commandpull ) ; log . debug ( STRING , out ) ; return path ; }
@ After public void execute Test ( ) throws Throwable { try { test Env . execute Test ( ) ; } catch ( Assertion Error assertion Error ) { if ( test Env . has Been Stopped ( ) ) { throw new Assertion Error ( STRING + assertion Error . get Message ( ) ) ; } throw assertion Error ; } }
public void init ( ) { pub Panel . set Layout ( new Border Layout ( ) ) ; topic = new J Combo Box ( ) ; topic . set Editable ( BOOL ) ; topic . set Maximum Size ( MQTT Frame . TEXT FIELD DIMENSION ) ; topic . set Maximum Row Count ( NUM ) ; qos List = new J Combo Box ( qos ) ; qos List . set Selected Index ( NUM ) ; qos List . set Maximum Size ( MQTT Frame . DROP DOWN DIMENSION ) ; pub Data = new J Text Area ( NUM , NUM ) ; pub Data . set Border ( new Bevel Border ( Bevel Border . LOWERED ) ) ; pub Data . set Margin ( MQTT Frame . TEXT MARGINS ) ; retained = new J Check Box ( ) ; retained . set Selected ( BOOL ) ; pub Label = new J Label ( PANEL TITLE + STRING ) ; Font f = pub Label . get Font ( ) ; pub Label . set Font ( new Font ( f . get Name ( ) , Font . BOLD , f . get Size ( ) + NUM ) ) ; J Panel topic Box = new J Panel ( ) ; topic Box . set Layout ( new Box Layout ( topic Box , Box Layout . X AXIS ) ) ; topic Box . add ( new J Label ( STRING ) ) ; topic Box . add ( topic ) ; topic Box . add ( new J Label ( STRING ) ) ; topic Box . add ( qos List ) ; topic Box . add ( new J Label ( STRING ) ) ; topic Box . add ( retained ) ; J Panel title And Topic = new J Panel ( ) ; title And Topic . set Layout ( new Grid Layout ( NUM , NUM ) ) ; title And Topic . add ( pub Label ) ; title And Topic . add ( topic Box ) ; hex Display = BOOL ; hex Button = new J Button ( STRING ) ; hex Button . add Action Listener ( this ) ; file Button = new J Button ( STRING ) ; file Button . set Enabled ( BOOL ) ; file Button . add Action Listener ( this ) ; pub Button = new J Button ( STRING ) ; pub Button . set Enabled ( BOOL ) ; pub Button . add Action Listener ( this ) ; J Panel buttons = new J Panel ( ) ; buttons . set Layout ( new Grid Layout ( NUM , NUM ) ) ; buttons . add ( pub Button ) ; buttons . add ( file Button ) ; buttons . add ( hex Button ) ; J Panel button Layout = new J Panel ( ) ; button Layout . add ( buttons ) ; pub Panel . add ( title And Topic , Border Layout . NORTH ) ; pub Panel . add ( new J Scroll Pane ( pub Data ) , Border Layout . CENTER ) ; pub Panel . add ( button Layout , Border Layout . EAST ) ; }
public void validate Emr Cluster Definition Key ( Emr Cluster Definition Key key ) throws Illegal Argument Exception { Assert . not Null ( key , STRING ) ; key . set Namespace ( alternate Key Helper . validate String Parameter ( STRING , key . get Namespace ( ) ) ) ; key . set Emr Cluster Definition Name ( alternate Key Helper . validate String Parameter ( STRING , STRING , key . get Emr Cluster Definition Name ( ) ) ) ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
@ Target Api ( VERSION CODES . KITKAT ) private void handle Sms Received ( Intent intent ) { if ( Build Config . DEBUG ) Log . v ( STRING ) ; Bundle bundle = intent . get Extras ( ) ; if ( bundle != null ) { Sms Message [ ] messages = null ; if ( Sms Popup Utils . has Kit Kat ( ) ) { messages = Intents . get Messages From Intent ( intent ) ; } else { messages = Sms Popup Utils . get Messages From Intent ( intent ) ; } if ( messages != null ) { notify Message Received ( new Sms Mms Message ( context , messages , System . current Time Millis ( ) ) ) ; } } }
public static long install Age ( long current Timestamp , long install Timestamp , boolean send Install Event ) { if ( send Install Event ) { return INSTALL AGE IMMEDIATELY AFTER INSTALLING ; } else { return Math . max ( NUM , ( current Timestamp - install Timestamp ) / MS PER DAY ) ; } }
public boolean is Distributed ( ) { return ! is Local ( ) ; }
public void test Value Of Long Negative 1 ( ) { long long Val = - NUM ; Big Integer a Number = Big Integer . value Of ( long Val ) ; byte r Bytes [ ] = { - NUM , NUM , NUM , - NUM , NUM , NUM , - NUM , - NUM } ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , - NUM , a Number . signum ( ) ) ; }
private boolean zz Refill ( ) throws java . io . IO Exception { if ( zz Start Read > NUM ) { System . arraycopy ( zz Buffer , zz Start Read , zz Buffer , NUM , zz End Read - zz Start Read ) ; zz End Read -= zz Start Read ; zz Current Pos -= zz Start Read ; zz Marked Pos -= zz Start Read ; zz Start Read = NUM ; } if ( zz Current Pos >= zz Buffer . length ) { char new Buffer [ ] = new char [ zz Current Pos * NUM ] ; System . arraycopy ( zz Buffer , NUM , new Buffer , NUM , zz Buffer . length ) ; zz Buffer = new Buffer ; } int num Read = zz Reader . read ( zz Buffer , zz End Read , zz Buffer . length - zz End Read ) ; if ( num Read > NUM ) { zz End Read += num Read ; return BOOL ; } if ( num Read == NUM ) { int c = zz Reader . read ( ) ; if ( c == - NUM ) { return BOOL ; } else { zz Buffer [ zz End Read ++ ] = ( char ) c ; return BOOL ; } } return BOOL ; }
public synchronized boolean is Consumer ( Image Consumer ic ) { return the Consumers . contains ( ic ) ; }
public static boolean verify Signature ( Signature initialized Signature Engine , byte [ ] message , byte [ ] signature ) throws Signature Exception { initialized Signature Engine . update ( message ) ; return initialized Signature Engine . verify ( signature ) ; }
public static void write Var Int ( Output Stream out , int x ) throws IO Exception { while ( ( x & ~ NUM ) != NUM ) { out . write ( ( byte ) ( NUM | ( x & NUM ) ) ) ; x >>>= NUM ; } out . write ( ( byte ) x ) ; }
protected static final String add Escapes ( String str ) { String Buffer retval = new String Buffer ( ) ; char ch ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) { switch ( str . char At ( i ) ) { case NUM : continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; case STRING : retval . append ( STRING ) ; continue ; default : if ( ( ch = str . char At ( i ) ) < NUM || ch > NUM ) { String s = STRING + Integer . to String ( ch , NUM ) ; retval . append ( STRING + s . substring ( s . length ( ) - NUM , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . to String ( ) ; }
public Segment Path complete ( End Type etype ) { Segment Path result ; if ( data == null || w < NUM ) { return null ; } if ( w == data . length ) { result = new Segment Path ( data , etype ) ; reset ( NUM ) ; } else { double [ ] data To Adopt = new double [ w ] ; System . arraycopy ( data , NUM , data To Adopt , NUM , w ) ; result = new Segment Path ( data To Adopt , etype ) ; reset ( NUM ) ; } return result ; }
public boolean add Gps Date Time Stamp Tag ( long timestamp ) { Exif Tag t = build Tag ( TAG GPS DATE STAMP , mGPS Date Stamp Format . format ( timestamp ) ) ; if ( t == null ) { return BOOL ; } set Tag ( t ) ; mGPS Time Stamp Calendar . set Time In Millis ( timestamp ) ; t = build Tag ( TAG GPS TIME STAMP , new Rational [ ] { new Rational ( mGPS Time Stamp Calendar . get ( Calendar . HOUR OF DAY ) , NUM ) , new Rational ( mGPS Time Stamp Calendar . get ( Calendar . MINUTE ) , NUM ) , new Rational ( mGPS Time Stamp Calendar . get ( Calendar . SECOND ) , NUM ) } ) ; if ( t == null ) { return BOOL ; } set Tag ( t ) ; return BOOL ; }
@ Nullable public Bitmap crop Image ( ) { Bitmap view Bitmap = get View Bitmap ( ) ; if ( view Bitmap == null || view Bitmap . is Recycled ( ) ) { return null ; } cancel All Animations ( ) ; set Image To Wrap Crop Bounds ( BOOL ) ; Rect F current Image Rect = Rect Utils . trap To Rect ( m Current Image Corners ) ; if ( current Image Rect . is Empty ( ) ) { return null ; } float current Scale = get Current Scale ( ) ; float current Angle = get Current Angle ( ) ; if ( m Max Result Image Size X > NUM && m Max Result Image Size Y > NUM ) { float crop Width = m Crop Rect . width ( ) / current Scale ; float crop Height = m Crop Rect . height ( ) / current Scale ; if ( crop Width > m Max Result Image Size X || crop Height > m Max Result Image Size Y ) { float scale X = m Max Result Image Size X / crop Width ; float scale Y = m Max Result Image Size Y / crop Height ; float resize Scale = Math . min ( scale X , scale Y ) ; Bitmap resized Bitmap = Bitmap . create Scaled Bitmap ( view Bitmap , ( int ) ( view Bitmap . get Width ( ) * resize Scale ) , ( int ) ( view Bitmap . get Height ( ) * resize Scale ) , BOOL ) ; if ( view Bitmap != resized Bitmap ) { view Bitmap . recycle ( ) ; } view Bitmap = resized Bitmap ; current Scale /= resize Scale ; } } if ( current Angle != NUM ) { m Temp Matrix . reset ( ) ; m Temp Matrix . set Rotate ( current Angle , view Bitmap . get Width ( ) / NUM , view Bitmap . get Height ( ) / NUM ) ; Bitmap rotated Bitmap = Bitmap . create Bitmap ( view Bitmap , NUM , NUM , view Bitmap . get Width ( ) , view Bitmap . get Height ( ) , m Temp Matrix , BOOL ) ; if ( view Bitmap != rotated Bitmap ) { view Bitmap . recycle ( ) ; } view Bitmap = rotated Bitmap ; } int top = ( int ) ( ( m Crop Rect . top - current Image Rect . top ) / current Scale ) ; int left = ( int ) ( ( m Crop Rect . left - current Image Rect . left ) / current Scale ) ; int width = ( int ) ( m Crop Rect . width ( ) / current Scale ) ; int height = ( int ) ( m Crop Rect . height ( ) / current Scale ) ; return Bitmap . create Bitmap ( view Bitmap , left , top , width , height ) ; }
@ Deprecated public static Bundle parse Url ( String url ) { url = url . replace ( STRING , STRING ) ; try { URL u = new URL ( url ) ; Bundle b = decode Url ( u . get Query ( ) ) ; b . put All ( decode Url ( u . get Ref ( ) ) ) ; return b ; } catch ( Malformed URL Exception e ) { return new Bundle ( ) ; } }
private static void create Tmp File ( Completable Future < New File > file Creation , Path dest Dir , List < TS Data > files ) { LOG . log ( Level . FINE , STRING ) ; try { Collections . sort ( files , Comparator . comparing ( null ) ) ; final File Channel fd = File Util . create Temp File ( dest Dir , STRING , STRING ) ; try { final Date Time begin ; try ( To Xdr Tables output = new To Xdr Tables ( fd , Compression . DEFAULT OPTIMIZED ) ) { while ( ! files . is Empty ( ) ) { TS Data tsdata = files . remove ( NUM ) ; if ( file Creation . is Cancelled ( ) ) throw new IO Exception ( STRING ) ; output . add All ( tsdata ) ; } begin = new Date Time ( output . get Hdr Begin ( ) , Date Time Zone . UTC ) ; if ( file Creation . is Cancelled ( ) ) throw new IO Exception ( STRING ) ; } if ( file Creation . is Cancelled ( ) ) throw new IO Exception ( STRING ) ; INSTALL POOL . execute ( null ) ; } catch ( Error | Runtime Exception | IO Exception ex ) { try { fd . close ( ) ; } catch ( Error | Runtime Exception | IO Exception ex 1 ) { ex . add Suppressed ( ex 1 ) ; } throw ex ; } } catch ( Error | Runtime Exception | IO Exception ex ) { LOG . log ( Level . WARNING , STRING , ex ) ; synchronized ( OUTSTANDING ) { OUTSTANDING . remove ( file Creation ) ; } file Creation . complete Exceptionally ( ex ) ; } }
public void content Tag ( String tag , String name , String value , String content ) { spacing ( ) ; m out . print ( STRING ) ; m out . print ( tag ) ; m out . print ( STRING ) ; m out . print ( name ) ; m out . print ( STRING ) ; m out . print ( STRING ) ; escape String ( value ) ; m out . print ( STRING ) ; m out . print ( STRING ) ; escape String ( content ) ; m out . print ( STRING ) ; m out . print ( STRING ) ; m out . print ( tag ) ; m out . print ( STRING ) ; println ( ) ; }
public static void close Output Stream ( Output Stream stream , String tag ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( IO Exception e ) { Log . e ( tag , STRING + e ) ; } } }
public void add Child ( Component child ) { components . add ( child ) ; child . set Parent ( this ) ; }
public boolean open ( int max Rows ) { log . info ( STRING + max Rows ) ; m max Rows = max Rows ; if ( m open ) { log . fine ( STRING ) ; data Refresh All ( ) ; return BOOL ; } if ( m virtual ) { verify Virtual ( ) ; } create Select Sql ( ) ; if ( m SQL == null || m SQL . equals ( STRING ) ) { log . log ( Level . SEVERE , STRING ) ; return BOOL ; } m loader = new Loader ( ) ; m row Count = m loader . open ( max Rows ) ; if ( m virtual ) { m buffer = null ; m virtual Buffer = new Hash Map < Integer , Object [ ] > ( NUM ) ; } else { m buffer = new Array List < Object [ ] > ( m row Count + NUM ) ; } m sort = new Array List < M Sort > ( m row Count + NUM ) ; if ( m row Count > NUM ) { if ( m row Count < NUM ) m loader . run ( ) ; else { m loader Thread = new Thread ( m loader , STRING ) ; m loader Thread . start ( ) ; } } else m loader . close ( ) ; m open = BOOL ; m changed = BOOL ; m row Changed = - NUM ; m inserting = BOOL ; return BOOL ; }
public void add Message Listener ( I Message Listener listener ) { listeners . add ( listener ) ; }
protected void sync Flush Vdc Config To Local ( ) throws Exception { if ( vdc Prop Barrier == null ) { vdc Prop Barrier = new Vdc Property Barrier ( target Site Info , VDC OP BARRIER TIMEOUT ) ; } vdc Prop Barrier . enter ( ) ; try { flush Vdc Config To Local ( ) ; } finally { boolean all Left = vdc Prop Barrier . leave ( ) ; if ( ! all Left ) { log . info ( STRING ) ; Thread . sleep ( IPSEC RESTART DELAY ) ; } } vdc Prop Barrier = null ; }
public Corrupt Index Exception ( String message , Data Input input , Throwable cause ) { this ( message , Objects . to String ( input ) , cause ) ; }
protected void remove From Quarantine Queue ( Node Port Tuple npt ) { while ( quarantine Queue . remove ( npt ) ) ; }
public boolean has Expired ( ) { if ( max Age == NUM ) return BOOL ; if ( max Age == MAX AGE UNSPECIFIED ) return BOOL ; long delta Second = ( System . current Time Millis ( ) - when Created ) / NUM ; if ( delta Second > max Age ) return BOOL ; else return BOOL ; }
public static String repeat Character ( char c , int repetitions ) { String Builder s = new String Builder ( repetitions ) ; for ( int i = NUM ; i < repetitions ; i ++ ) { s . append ( c ) ; } return s . to String ( ) ; }
public static String check And Replace Literals ( String inst Str ) { String tmp = inst Str ; if ( tmp . contains ( COMPONENTS DELIM ) ) { tmp = tmp . replace All ( COMPONENTS DELIM , STRING ) ; LOG . warn ( STRING + COMPONENTS DELIM + STRING ) ; } if ( tmp . contains ( ELEMENT DELIM ) ) { tmp = tmp . replace All ( ELEMENT DELIM , STRING ) ; LOG . warn ( STRING + ELEMENT DELIM + STRING ) ; } if ( tmp . contains ( LEVELIN ) ) { tmp = tmp . replace All ( LEVELIN , STRING ) ; LOG . warn ( STRING + LEVELIN + STRING ) ; } if ( tmp . contains ( LEVELOUT ) ) { tmp = tmp . replace All ( LEVELOUT , STRING ) ; LOG . warn ( STRING + LEVELOUT + STRING ) ; } if ( tmp . contains ( PARFOR CDATA END ) ) { tmp = tmp . replace All ( PARFOR CDATA END , STRING ) ; LOG . warn ( STRING + PARFOR CDATA END + STRING ) ; } return tmp ; }
protected void notify History Changed Listeners ( ) { Iterator < History Changed Listener > iter ; History Changed Listener l ; iter = m History Changed Listeners . iterator ( ) ; while ( iter . has Next ( ) ) { l = iter . next ( ) ; l . history Changed ( new History Changed Event ( this , HISTORY NAME , get History ( ) ) ) ; } }
public final static char [ ] [ ] split Type Levels Signature ( String type Signature ) { char [ ] source = Signature . remove Capture ( type Signature . to Char Array ( ) ) ; Char Operation . replace ( source , STRING , STRING ) ; char [ ] [ ] signatures = new char [ NUM ] [ ] ; int signatures Count = NUM ; int param Opening = NUM ; for ( int idx = NUM , ln = source . length ; idx < ln ; idx ++ ) { switch ( source [ idx ] ) { case STRING : param Opening -- ; if ( param Opening == NUM ) { if ( signatures Count == signatures . length ) { System . arraycopy ( signatures , NUM , signatures = new char [ signatures Count + NUM ] [ ] , NUM , signatures Count ) ; } } break ; case STRING : param Opening ++ ; break ; case STRING : if ( param Opening == NUM ) { if ( signatures Count == signatures . length ) { System . arraycopy ( signatures , NUM , signatures = new char [ signatures Count + NUM ] [ ] , NUM , signatures Count ) ; } signatures [ signatures Count ] = new char [ idx + NUM ] ; System . arraycopy ( source , NUM , signatures [ signatures Count ] , NUM , idx ) ; signatures [ signatures Count ] [ idx ] = Signature . C SEMICOLON ; signatures Count ++ ; } break ; case STRING : source [ idx ] = STRING ; break ; } } char [ ] [ ] type Signatures = new char [ signatures Count + NUM ] [ ] ; type Signatures [ NUM ] = source ; for ( int i = NUM , j = signatures Count - NUM ; i <= signatures Count ; i ++ , j -- ) { type Signatures [ i ] = signatures [ j ] ; } return type Signatures ; }
public static < T > T with Writer ( Writer writer , @ Closure Params ( First Param . class ) Closure < T > closure ) throws IO Exception { try { T result = closure . call ( writer ) ; try { writer . flush ( ) ; } catch ( IO Exception e ) { } Writer temp = writer ; writer = null ; temp . close ( ) ; return result ; } finally { close With Warning ( writer ) ; } }
public static int round ( double value ) { int rounded Value = value > NUM ? ( int ) ( value + NUM ) : - ( int ) ( Math . abs ( value ) + NUM ) ; return rounded Value ; }
private Service Registrar [ ] build Service Registrar ( ) { int k = NUM ; Service Registrar [ ] proxys = new Service Registrar [ discovered Locators . size ( ) ] ; Iterator iter = discovered Locators . iterator ( ) ; while ( iter . has Next ( ) ) { Locator Reg reg = ( Locator Reg ) iter . next ( ) ; proxys [ k ++ ] = reg . proxy ; } return proxys ; }
private static char [ ] zz Unpack C Map ( String packed ) { char [ ] map = new char [ NUM ] ; int i = NUM ; int j = NUM ; while ( i < NUM ) { int count = packed . char At ( i ++ ) ; char value = packed . char At ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM ) ; } return map ; }
public void rewind To WS ( ) { if ( next Offset == NUM ) { return ; } next Offset -- ; while ( next Offset > NUM && ! Character . is Whitespace ( s . char At ( next Offset ) ) ) { next Offset -- ; } this . offset = next Offset - NUM ; }
private static Permission [ ] flatten ( Permission [ ] pa ) { List l = new Array List ( pa . length ) ; for ( int i = NUM ; i < pa . length ; i ++ ) { Permission p = pa [ i ] ; if ( p instanceof Grant Permission ) { l . add All ( Arrays . as List ( ( ( Grant Permission ) p ) . grants ) ) ; } else { l . add ( p ) ; } } return ( Permission [ ] ) l . to Array ( new Permission [ l . size ( ) ] ) ; }
public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
protected void start Document Internal ( ) throws SAX Exception { if ( m need To Call Start Document ) { super . start Document Internal ( ) ; m sax Handler . start Document ( ) ; m need To Call Start Document = BOOL ; } }
public static boolean is Anonymous ( String class Name ) { int i = class Name . last Index Of ( STRING ) ; if ( i >= NUM && ++ i < class Name . length ( ) ) { while ( i < class Name . length ( ) ) { if ( ! Character . is Digit ( class Name . char At ( i ) ) ) { return BOOL ; } i ++ ; } return BOOL ; } return BOOL ; }
String descriptor ( boolean include This ) { String Builder result = new String Builder ( ) ; result . append ( STRING ) ; if ( include This ) { result . append ( declaring Type . name ) ; } for ( Type Id t : parameters . types ) { result . append ( t . name ) ; } result . append ( STRING ) ; result . append ( return Type . name ) ; return result . to String ( ) ; }
public void test Single File ( ) throws Exception { J Flex Mojo mojo = new Mojo ( STRING ) ; mojo . execute ( ) ; File produced = get Expected Output File ( mojo ) ; assert True ( STRING + produced , produced . is File ( ) ) ; long size = produced . length ( ) ; boolean correct Size = ( size > NUM ) && ( size < NUM ) ; assert True ( STRING + size , correct Size ) ; }
public final static boolean is Potential Zip Archive ( String name ) { int last Dot = name . last Index Of ( STRING ) ; if ( last Dot == - NUM ) { return BOOL ; } if ( name . last Index Of ( File . separator Char ) > last Dot ) { return BOOL ; } int length = name . length ( ) ; int extension Length = length - last Dot - NUM ; if ( extension Length == EXTENSION java . length ( ) ) { for ( int i = extension Length - NUM ; i >= NUM ; i -- ) { if ( Character . to Lower Case ( name . char At ( length - extension Length + i ) ) != EXTENSION java . char At ( i ) ) { break ; } if ( i == NUM ) { return BOOL ; } } } if ( extension Length == EXTENSION class . length ( ) ) { for ( int i = extension Length - NUM ; i >= NUM ; i -- ) { if ( Character . to Lower Case ( name . char At ( length - extension Length + i ) ) != EXTENSION class . char At ( i ) ) { return BOOL ; } } return BOOL ; } return BOOL ; }
void add Term ( Map Builder Term Type type , J Class jclass , String alias ) { Map Builder Term new Term = new Map Builder Term ( ) ; new Term . type = type ; new Term . jclass = jclass ; new Term . alias = alias ; terms . add ( new Term ) ; }
public Collection engine Generate Certificates ( Input Stream in Stream ) throws Certificate Exception { java . security . cert . Certificate cert ; List certs = new Array List ( ) ; while ( ( cert = engine Generate Certificate ( in Stream ) ) != null ) { certs . add ( cert ) ; } return certs ; }
@ Suppress Warnings ( STRING ) protected void write Path ( Shape s ) { Path Iterator segments = s . get Path Iterator ( null ) ; double [ ] coords = new double [ NUM ] ; for ( int i = NUM ; ! segments . is Done ( ) ; i ++ , segments . next ( ) ) { if ( i > NUM ) { write ( STRING ) ; } int segment Type = segments . current Segment ( coords ) ; switch ( segment Type ) { case Path Iterator . SEG MOVETO : write ( STRING , coords [ NUM ] , STRING , coords [ NUM ] ) ; break ; case Path Iterator . SEG LINETO : write ( STRING , coords [ NUM ] , STRING , coords [ NUM ] ) ; break ; case Path Iterator . SEG CUBICTO : write ( STRING , coords [ NUM ] , STRING , coords [ NUM ] , STRING , coords [ NUM ] , STRING , coords [ NUM ] , STRING , coords [ NUM ] , STRING , coords [ NUM ] ) ; break ; case Path Iterator . SEG QUADTO : write ( STRING , coords [ NUM ] , STRING , coords [ NUM ] , STRING , coords [ NUM ] , STRING , coords [ NUM ] ) ; break ; case Path Iterator . SEG CLOSE : write ( STRING ) ; break ; default : throw new Illegal State Exception ( STRING ) ; } } }
public static void check Argument ( boolean expression , Object error Message ) { if ( ! expression ) { throw new Illegal Argument Exception ( String . value Of ( error Message ) ) ; } }
private final boolean park And Check Interrupt ( ) { Lock Support . park ( this ) ; return Thread . interrupted ( ) ; }
@ Override public int port Remote ( ) { if ( channel != null ) { try { Socket Address addr = channel . get Remote Address ( ) ; return NUM ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return NUM ; } } else return NUM ; }
public void add Drop Target ( Drop Target target ) { m Drop Targets . add ( target ) ; }
@ Override public void start Element ( final String namespace URI , final String local Name , final String q Name , final Attributes atts ) throws SAX Exception { Object object To Load = null ; if ( open Nodes . size ( ) == NUM ) object To Load = root Object ; else object To Load = create Child ( q Name , atts ) ; if ( object To Load != null ) { if ( atts . get Index ( STRING ) < NUM ) Object Get Setter . set ( object To Load , STRING , q Name ) ; Object Get Setter . set All ( object To Load , atts ) ; } open Nodes . push ( new Stacked Object ( object To Load ) ) ; }
public final int put ( Object key , int value , boolean is Replace ) { int prime = prime ; int hash = Math . abs ( System . identity Hash Code ( key ) % prime ) ; Object [ ] keys = keys ; while ( BOOL ) { Object test Key = keys [ hash ] ; if ( test Key == null ) { keys [ hash ] = key ; values [ hash ] = value ; size ++ ; if ( keys . length <= NUM * size ) resize ( NUM * keys . length ) ; return value ; } else if ( key != test Key ) { hash = ( hash + NUM ) % prime ; continue ; } else if ( is Replace ) { int old = values [ hash ] ; values [ hash ] = value ; return old ; } else { return values [ hash ] ; } } }
public int add All Absent ( Collection c ) { int num New = c . size ( ) ; if ( num New == NUM ) return NUM ; synchronized ( this ) { Object [ ] elements = get Array ( ) ; int len = elements . length ; Object [ ] temp = new Object [ num New ] ; int added = NUM ; for ( Iterator itr = c . iterator ( ) ; itr . has Next ( ) ; ) { Object e = itr . next ( ) ; if ( index Of ( e , elements , NUM , len ) < NUM && index Of ( e , temp , NUM , added ) < NUM ) temp [ added ++ ] = e ; } if ( added != NUM ) { Object [ ] new Elements = new Object [ len + added ] ; System . arraycopy ( elements , NUM , new Elements , NUM , len ) ; System . arraycopy ( temp , NUM , new Elements , len , added ) ; set Array ( new Elements ) ; } return added ; } }
private static final synchronized int next Pool Id ( ) { return ++ pool Number Sequence ; }
@ Override public void close ( ) throws IO Exception { if ( logger != null ) { logger . println ( STRING + socket was closed ) ; } if ( ! socket was closed ) { if ( handshake started ) { alert Protocol . alert ( Alert Protocol . WARNING , Alert Protocol . CLOSE NOTIFY ) ; try { output . write ( alert Protocol . wrap ( ) ) ; } catch ( IO Exception ex ) { } alert Protocol . set Processed ( ) ; } shutdown ( ) ; close Transport Layer ( ) ; socket was closed = BOOL ; } }
protected static void register Library ( I Library Manager external Library Manager , String dataverse , String library Name ) throws Exception { Class Loader class Loader = get Library Class Loader ( dataverse , library Name ) ; external Library Manager . register Library Class Loader ( dataverse , library Name , class Loader ) ; }
public void auto Size ( ) { if ( ! auto Resize ) return ; }
public void test Case 9 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = Big Integer . ONE ; Big Integer result = a Number . multiply ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public static String raw MD 5 ( String s ) { return binl 2 rstr ( binl 2 md 5 ( rstr 2 binl ( s ) , s . length ( ) * NUM ) ) ; }
public boolean is Quest Completed ( final String name ) { final String info = get Quest ( name , NUM ) ; if ( info == null ) { return BOOL ; } return info . equals ( STRING ) ; }
private static char [ ] zz Unpack C Map ( String packed ) { char [ ] map = new char [ NUM ] ; int i = NUM ; int j = NUM ; while ( i < NUM ) { int count = packed . char At ( i ++ ) ; char value = packed . char At ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > NUM ) ; } return map ; }
public void test Zero Zero ( ) { String num A = STRING ; String num B = STRING ; String res = STRING ; Big Integer a Number = new Big Integer ( num A ) ; Big Integer b Number = new Big Integer ( num B ) ; Big Integer result = a Number . xor ( b Number ) ; assert True ( res . equals ( result . to String ( ) ) ) ; }
@ Layoutlib Delegate static float ceil ( float value ) { return ( float ) Math . ceil ( value ) ; }
private final User remove User ( String channel , String nick ) { channel = channel . to Lower Case ( ) ; User user = new User ( STRING , nick ) ; synchronized ( channels ) { Hashtable < User , User > users = channels . get ( channel ) ; if ( users != null ) { return users . remove ( user ) ; } } return null ; }
public static void translate Pos ( Collection < Graph Node > move Nodes , Map < Graph Node , Point 2 D > positions , Translater into Region ) { for ( Graph Node node : move Nodes ) { Point 2 D location = translate Node ( node , positions , into Region ) ; if ( null == location ) { continue ; } positions . put ( node , location ) ; } }
public void if Present Or Else ( Long Consumer action , Runnable empty Action ) { if ( is Present ) { action . accept ( value ) ; } else { empty Action . run ( ) ; } }
public void test To Big Integer Pos 2 ( ) { String a = STRING ; Big Integer b Number = new Big Integer ( STRING ) ; Big Decimal a Number = new Big Decimal ( a ) ; Big Integer result = a Number . to Big Integer ( ) ; assert True ( STRING , result . equals ( b Number ) ) ; }
private String cleanup Path ( String file Name ) { if ( file Name == null ) { return null ; } file Name = file Name . replace ( STRING , STRING ) ; file Name = file Name . replace ( STRING , STRING ) ; if ( file Name . starts With ( STRING ) ) { return file Name ; } if ( file Name . starts With ( STRING ) ) { return STRING + file Name ; } return STRING + file Name ; }
public static Class < ? > invocation Handler Return Type ( Class < ? > type ) { if ( type == byte . class ) return Byte . class ; if ( type == char . class ) return Character . class ; if ( type == double . class ) return Double . class ; if ( type == float . class ) return Float . class ; if ( type == int . class ) return Integer . class ; if ( type == long . class ) return Long . class ; if ( type == short . class ) return Short . class ; if ( type == boolean . class ) return Boolean . class ; return type ; }
private Node < K , V > find Node ( Comparable < ? super K > key ) { for ( ; ; ) { Node < K , V > b = find Predecessor ( key ) ; Node < K , V > n = b . next ; for ( ; ; ) { if ( n == null ) return null ; Node < K , V > f = n . next ; if ( n != b . next ) break ; Object v = n . value ; if ( v == null ) { n . help Delete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; int c = key . compare To ( n . key ) ; if ( c == NUM ) return n ; if ( c < NUM ) return null ; b = n ; n = f ; } } }
private static Script script From String ( String script String , Script Type script Type ) { return new Script ( script String , script Type ) ; }
private void finish Nested Mode ( ) throws SAX Exception { md = ( Mode Data ) mode Data Stack . pop ( ) ; }
public void add Property Change Listener ( final Property Change Listener listener ) { property Change Support . add Property Change Listener ( listener ) ; }
protected int skip Whitespace ( int c ) throws IO Exception { while ( c == STRING || c == STRING ) { c = reader . read ( ) ; } return c ; }
public Builder no Cache ( ) { this . no Cache = BOOL ; return this ; }
@ Suppress Warnings ( STRING ) public void compute Closest Points ( ) { float center X = content Rect . center X ( ) ; float closest Distance = Float . MAX VALUE ; for ( int i = NUM ; i < points Count Within X Range * NUM ; i += NUM ) { float x = get Draw X ( x Range Points [ i ] ) ; float distance = Math . abs ( x - center X ) ; if ( distance <= closest Distance ) { if ( distance == closest Distance ) { closest Points Count ++ ; } else { closest Points Count = NUM ; } closest Distance = distance ; if ( closest Points Buffer . length < ( closest Points Count * NUM + NUM ) ) { closest Points Buffer = new float [ closest Points Buffer . length * NUM ] ; } closest Points Buffer [ closest Points Count * NUM + NUM ] = x Range Points [ i ] ; closest Points Buffer [ closest Points Count * NUM + NUM ] = x Range Points [ i + NUM ] ; } } if ( points Count Within X Range > NUM ) { closest Points Count ++ ; } }
protected Transformed String stem ( String words ) { String Builder builder = new String Builder ( ) ; Map < Integer , Integer > index Map = new Hash Map < > ( ) ; Integer index = NUM ; String content = words . to Lower Case ( ) ; while ( ! content . is Empty ( ) ) { index Map . put ( builder . length ( ) , index ) ; if ( Character . is Alphabetic ( content . char At ( NUM ) ) ) { Matcher m = WORD PATTERN . matcher ( content ) ; m . find ( ) ; String match = m . group ( ) ; Char Sequence stemmed Match = stemmer . stem ( match ) ; builder . append ( stemmed Match ) ; index += match . length ( ) ; content = content . substring ( match . length ( ) ) ; } else { builder . append ( content . substring ( NUM , NUM ) ) ; content = content . substring ( NUM ) ; index ++ ; } } index Map . put ( builder . length ( ) , index ) ; return new Transformed String ( words , builder . to String ( ) , index Map ) ; }
@ Override public void on Layout Children ( Recycler View . Recycler recycler , Recycler View . State state ) { if ( state . get Item Count ( ) == NUM ) { detach And Scrap Attached Views ( recycler ) ; return ; } if ( state . is Pre Layout ( ) ) { if ( get Child Count ( ) == NUM ) return ; final int child Count = get Child Count ( ) ; for ( int i = NUM ; i < child Count ; i ++ ) { View child = get Child At ( i ) ; Recycler View . Layout Params lp = ( Recycler View . Layout Params ) child . get Layout Params ( ) ; if ( lp . is Item Removed ( ) ) { removed Top And Bound Position Count ++ ; if ( first Changed Position == - NUM || first Attached Item Position + i < first Changed Position ) { first Changed Position = first Attached Item Position + i ; } } } if ( removed Top And Bound Position Count != NUM ) { layout Attached And Appearing Views ( recycler , state ) ; } is Before Pre Layout = BOOL ; return ; } if ( get Child Count ( ) == NUM ) { initialize Layout Parameters ( ) ; fill Grid ( recycler , state , BOOL ) ; return ; } if ( is Notify Data Set Changed ) { detach And Scrap Attached Views ( recycler ) ; initialize Layout Parameters ( ) ; fill Grid ( recycler , state , BOOL ) ; is Notify Data Set Changed = BOOL ; return ; } if ( first Changed Position == - NUM ) { m Current Position = first Attached Item Position ; last Attached Item Position = first Attached Item Position ; top Border = get Padding Top ( ) ; bottom Border = get Height ( ) - get Padding Bottom ( ) ; span Bottom = Arrays . copy Of ( span Top , m Span Count ) ; update Span Bottom Parameters ( ) ; detach And Scrap Attached Views ( recycler ) ; fill Grid ( recycler , state , BOOL ) ; is Before Pre Layout = BOOL ; return ; } for ( int i = first Changed Position ; i < state . get Item Count ( ) ; i ++ ) { if ( item Layout Width Cache . get ( i , NUM ) != NUM ) { item Layout Width Cache . delete ( i ) ; item Layout Height Cache . delete ( i ) ; item Occupied Start Span . delete ( i ) ; } if ( fake Item Layout Width Cache . get ( i , NUM ) != NUM ) { item Layout Width Cache . put ( i , fake Item Layout Width Cache . get ( i ) ) ; item Layout Height Cache . put ( i , fake Item Layout Height Cache . get ( i ) ) ; item Occupied Start Span . put ( i , fake Item Occupied Start Span . get ( i ) ) ; } } fake Item Layout Width Cache . clear ( ) ; fake Item Layout Height Cache . clear ( ) ; fake Item Occupied Start Span . clear ( ) ; detach And Scrap Attached Views ( recycler ) ; if ( first Changed Position < first Attached Item Position ) { m Current Position = first Attached Item Position ; last Attached Item Position = first Attached Item Position ; top Border = get Padding Top ( ) ; bottom Border = get Height ( ) - get Padding Bottom ( ) ; span Bottom = Arrays . copy Of ( span Top , m Span Count ) ; update Span Bottom Parameters ( ) ; fill Grid ( recycler , state , BOOL ) ; if ( span Bottom Max < bottom Border ) { scroll By ( span Bottom Max - bottom Border , recycler , state ) ; } layout Disappearing Views ( recycler , state ) ; } else { m Current Position = first Attached Item Position ; last Attached Item Position = first Attached Item Position ; top Border = get Padding Top ( ) ; bottom Border = get Height ( ) - get Padding Bottom ( ) ; span Bottom = Arrays . copy Of ( span Top , m Span Count ) ; update Span Bottom Parameters ( ) ; fill Grid ( recycler , state , BOOL ) ; if ( span Bottom Max - bottom Border < NUM ) { scroll By ( span Bottom Max - bottom Border , recycler , state ) ; } } is Before Pre Layout = BOOL ; first Changed Position = - NUM ; removed Top And Bound Position Count = NUM ; disappearing View Cache . clear ( ) ; }
void clear ( ) { value Numbers Unconditionally Dereferenced . clear ( ) ; deref Location Set Map . clear ( ) ; }
private static String url Encode ( final String text ) throws Unsupported Encoding Exception { return URL Encoder . encode ( text , STRING ) ; }
public String [ ] list ( ) throws Remote Exception { String [ ] names ; synchronized ( bindings ) { int i = bindings . size ( ) ; names = new String [ i ] ; Enumeration < String > enum = bindings . keys ( ) ; while ( ( -- i ) >= NUM ) names [ i ] = enum . next Element ( ) ; } return names ; }
public static void assert Q Ex ( String message , Solr Query Request req , int code ) { try { ignore Exception ( STRING ) ; h . query ( req ) ; fail ( message ) ; } catch ( Solr Exception sex ) { assert Equals ( code , sex . code ( ) ) ; } catch ( Exception e2 ) { throw new Runtime Exception ( STRING , e2 ) ; } finally { un Ignore Exception ( STRING ) ; } }
public static void copy File ( String from File , String to File ) throws IO Exception { copy File ( new File ( from File ) , new File ( to File ) ) ; }
protected synchronized void read And Verify ( ) throws Invalid Key Exception , IO Exception , File Encryption Exception , Illegal Block Size Exception , Bad Padding Exception , File Integrity Exception { if ( backing Random Access File . length ( ) < header Size ( ) ) { throw new File Encryption Exception ( STRING ) ; } if ( share Key == null || share Key . get Encoded ( ) . length == NUM ) { throw new File Encryption Exception ( STRING ) ; } else { header Auth H Mac . reset ( ) ; Key Parameter key Parameter = new Key Parameter ( share Key . get Encoded ( ) ) ; header Auth H Mac . init ( key Parameter ) ; } long oldpos = backing Random Access File . get File Pointer ( ) ; backing Random Access File . seek ( NUM ) ; byte [ ] header data = new byte [ header Size ( ) - File Header . AUTH TAG SIZE ] ; backing Random Access File . read ( header data ) ; backing Random Access File . read ( header Auth Tag ) ; backing Random Access File . seek ( oldpos ) ; header Auth H Mac . update ( header data , NUM , header data . length ) ; byte [ ] hmac Ref = new byte [ AUTH TAG SIZE ] ; header Auth H Mac . do Final ( hmac Ref , NUM ) ; if ( ! Arrays . equals ( hmac Ref , header Auth Tag ) ) { throw new File Integrity Exception ( STRING ) ; } else { Data Input Stream istream = new Data Input Stream ( new Byte Array Input Stream ( header data ) ) ; byte [ ] tmpmagic = new byte [ PANBOX FILE MAGIC . length ] ; istream . read ( tmpmagic ) ; if ( ! Arrays . equals ( tmpmagic , PANBOX FILE MAGIC ) ) { throw new File Encryption Exception ( STRING ) ; } byte [ ] tmpversion = new byte [ PANBOX FILE VERSION . length ] ; istream . read ( tmpversion ) ; if ( ! Arrays . equals ( tmpversion , PANBOX FILE VERSION ) ) { throw new File Encryption Exception ( STRING + PANBOX FILE VERSION . to String ( ) ) ; } this . share Key Version = istream . read Int ( ) ; byte [ ] tmpencrypted File Key = new byte [ Key Constants . SYMMETRIC FILE KEY SIZE BYTES ] ; istream . read ( tmpencrypted File Key ) ; filekey Cipher . init ( Cipher . DECRYPT MODE , share Key ) ; this . decrypted File Key = new Secret Key Spec ( filekey Cipher . do Final ( tmpencrypted File Key ) , get Algorithm Identifier ( ) ) ; if ( implements Authentication ( ) ) { byte [ ] tmp File Auth Buf = new byte [ Auth Tag Verifier . AUTH TAG SIZE ] ; istream . read ( tmp File Auth Buf ) ; byte [ ] zero Buf = new byte [ Auth Tag Verifier . AUTH TAG SIZE ] ; Arrays . fill ( zero Buf , ( byte ) NUM ) ; if ( Arrays . equals ( zero Buf , tmp File Auth Buf ) ) { set File Auth Tag ( null ) ; } else { set File Auth Tag ( tmp File Auth Buf ) ; } } istream . close ( ) ; } }
public void mouse Released ( Mouse Event e ) { Visualization Viewer < ? , ? > vv = ( Visualization Viewer < ? , ? > ) e . get Source ( ) ; down = null ; vv . set Cursor ( Cursor . get Predefined Cursor ( Cursor . DEFAULT CURSOR ) ) ; }
public void clear ( ) { ored Criteria . clear ( ) ; order By Clause = null ; distinct = BOOL ; }
@ edu . umd . cs . findbugs . annotations . Suppress FB Warnings ( value = STRING , justification = STRING ) public void change Loco Speed ( Dcc Throttle t , Section sec , float speed ) { if ( sec == referenced && speed == desired Speed Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; } return ; } float section Length = sec . get Actual Length ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + sec . get Display Name ( ) ) ; } if ( sec == referenced ) { distance Remaining = distance Remaining - get Distance Travelled ( throttle . get Is Forward ( ) , throttle . get Speed Setting ( ) , ( ( float ) ( System . nano Time ( ) - last Time Timer Started ) / NUM ) ) ; section Length = distance Remaining ; } else { referenced = sec ; } change Loco Speed ( t , section Length , speed ) ; }
private void draw Offsets ( final Graphics g ) { final int lines To Draw = get Number Of Visible Rows ( ) ; final String format String = m address Mode == Address Mode . BIT 32 ? STRING : STRING ; final long element Size = get Element Size ( ) ; final long base Address = m model . get Start Address ( ) == - NUM ? NUM : m model . get Start Address ( ) ; for ( int i = NUM ; i < lines To Draw ; i ++ ) { final int element Index = m first Row + i ; final long element Address = base Address + ( element Index * element Size ) ; final String offset String = String . format ( format String , element Address ) ; if ( element Address == m model . get Stack Pointer ( ) ) { highlight Stack Pointer ( g , i ) ; } if ( is Enabled ( ) ) { g . set Color ( m font Color Offsets ) ; } else { g . set Color ( m disabled Color != m bg Color Offset ? m disabled Color : Color . WHITE ) ; } g . draw String ( offset String , PADDING LEFT - ( m char Width * m first Column ) , m padding Top + ( i * m row Height ) ) ; } }
public static final String crypt ( String salt , String original ) { while ( salt . length ( ) < NUM ) salt += STRING ; String Builder buffer = new String Builder ( STRING ) ; char char Zero = salt . char At ( NUM ) ; char char One = salt . char At ( NUM ) ; buffer . set Char At ( NUM , char Zero ) ; buffer . set Char At ( NUM , char One ) ; int Eswap 0 = con salt [ char Zero ] ; int Eswap 1 = con salt [ char One ] << NUM ; byte key [ ] = new byte [ NUM ] ; for ( int i = NUM ; i < key . length ; i ++ ) key [ i ] = ( byte ) NUM ; for ( int i = NUM ; i < key . length && i < original . length ( ) ; i ++ ) { int i Char = original . char At ( i ) ; key [ i ] = ( byte ) ( i Char << NUM ) ; } int schedule [ ] = des set key ( key ) ; int out [ ] = body ( schedule , Eswap 0 , Eswap 1 ) ; byte b [ ] = new byte [ NUM ] ; int To Four Bytes ( out [ NUM ] , b , NUM ) ; int To Four Bytes ( out [ NUM ] , b , NUM ) ; b [ NUM ] = NUM ; for ( int i = NUM , y = NUM , u = NUM ; i < NUM ; i ++ ) { for ( int j = NUM , c = NUM ; j < NUM ; j ++ ) { c <<= NUM ; if ( ( b [ y ] & u ) != NUM ) c |= NUM ; u >>>= NUM ; if ( u == NUM ) { y ++ ; u = NUM ; } buffer . set Char At ( i , ( char ) cov 2char [ c ] ) ; } } return ( buffer . to String ( ) ) ; }
public static boolean prefixed With ( String a , String b ) { if ( a . equals ( b ) ) { return BOOL ; } return a . starts With ( b ) ; }
public static String read Stream ( Input Stream input Stream ) throws IO Exception { if ( input Stream == null ) { return null ; } Byte Array Output Stream bout = new Byte Array Output Stream ( ) ; byte [ ] buf = new byte [ NUM ] ; int r ; while ( ( r = input Stream . read ( buf ) ) != - NUM ) { bout . write ( buf , NUM , r ) ; } return bout . to String ( STRING ) ; }
private Instances make Header ( ) { Array List < Attribute > fv = new Array List < Attribute > ( ) ; fv . add ( new Attribute ( STRING ) ) ; fv . add ( new Attribute ( STRING ) ) ; fv . add ( new Attribute ( STRING ) ) ; return new Instances ( STRING , fv , NUM ) ; }
private static I Closeable Iterator < I Binding Set > iterator ( final I Running Query running Query ) { final I Closeable Iterator < I Binding Set [ ] > it 1 = running Query . iterator ( ) ; final I Closeable Iterator < I Binding Set > it 2 = new Dechunkerator < I Binding Set > ( it 1 ) ; final I Closeable Iterator < I Binding Set > it 3 = new Running Query Closeable Iterator < I Binding Set > ( running Query , it 2 ) ; return it 3 ; }
public void make Immutable ( ) { if ( is Mutable ) { is Mutable = BOOL ; } }
public final double do Operation ( ) throws Operator Failed Exception { final int dim = parameter . get Dimension ( ) ; final int dim 1 = Math Utils . next Int ( dim ) ; int dim 2 = dim 1 ; while ( dim 1 == dim 2 ) { dim 2 = Math Utils . next Int ( dim ) ; } double scalar 1 = parameter . get Parameter Value ( dim 1 ) ; double scalar 2 = parameter . get Parameter Value ( dim 2 ) ; final double d = Math Utils . next Double ( ) * delta * scalar 1 ; scalar 1 -= d ; if ( parameter Weights [ dim 1 ] != parameter Weights [ dim 2 ] ) { scalar 2 += d * ( double ) parameter Weights [ dim 1 ] / ( double ) parameter Weights [ dim 2 ] ; } else { scalar 2 += d ; } parameter . set Parameter Value ( dim 1 , scalar 1 ) ; parameter . set Parameter Value ( dim 2 , scalar 2 ) ; return Math . log ( scalar 2 / ( scalar 1 + d ) ) ; }
@ Override public final boolean is Open ( ) { return is Open . get ( ) ; }
private static Stream Tokenizer create Tokenizer ( String s ) { Stream Tokenizer st = new Stream Tokenizer ( new String Reader ( s ) ) ; st . reset Syntax ( ) ; st . word Chars ( STRING , STRING ) ; st . word Chars ( STRING , STRING ) ; st . word Chars ( STRING , STRING ) ; st . word Chars ( STRING , STRING ) ; st . word Chars ( STRING , STRING ) ; st . word Chars ( STRING , STRING ) ; st . word Chars ( NUM + NUM , NUM ) ; st . whitespace Chars ( NUM , STRING ) ; st . lower Case Mode ( BOOL ) ; st . ordinary Char ( STRING ) ; st . slash Slash Comments ( BOOL ) ; st . slash Star Comments ( BOOL ) ; return st ; }
public static String remove Chars ( String str , String oldchars ) { int pos = index Of Chars ( str , oldchars ) ; if ( pos == - NUM ) { return str ; } String Builder buf = new String Builder ( ) ; int start = NUM ; do { buf . append ( str . substring ( start , pos ) ) ; start = pos + NUM ; pos = index Of Chars ( str , oldchars , start ) ; } while ( pos != - NUM ) ; if ( start < str . length ( ) ) { buf . append ( str . substring ( start ) ) ; } return buf . to String ( ) ; }
private void sort Units To Move ( final List < Unit > units , final Route route ) { if ( units == null || units . is Empty ( ) ) { return ; } else if ( route == null ) { final Exception null Route Error = ( new Illegal Argument Exception ( STRING ) ) ; Client Logger . log Quietly ( STRING , null Route Error ) ; } final Comparator < Unit > unit Comparator ; if ( route . is Unload ( ) && Match . some Match ( units , Matches . Unit Is Land ) ) { unit Comparator = Unit Comparator . get Unloadable Units Comparator ( units , route , get Unit Owner ( units ) ) ; } else { unit Comparator = Unit Comparator . get Movable Units Comparator ( units , route ) ; } Collections . sort ( units , unit Comparator ) ; }
public boolean implements Interface ( Reference Binding an Interface , boolean search Hierarchy ) { if ( this == an Interface ) return BOOL ; Reference Binding [ ] interfaces To Visit = null ; int next Position = NUM ; Reference Binding current Type = this ; do { Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces != Binding . NO SUPERINTERFACES ) { if ( interfaces To Visit == null ) { interfaces To Visit = its Interfaces ; next Position = interfaces To Visit . length ; } else { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length ) System . arraycopy ( interfaces To Visit , NUM , interfaces To Visit = new Reference Binding [ next Position + its Length + NUM ] , NUM , next Position ) ; next Interface : for ( int a = NUM ; a < its Length ; a ++ ) { Reference Binding next = its Interfaces [ a ] ; for ( int b = NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } } while ( search Hierarchy && ( current Type = current Type . superclass ( ) ) != null ) ; for ( int i = NUM ; i < next Position ; i ++ ) { current Type = interfaces To Visit [ i ] ; if ( current Type . is Equivalent To ( an Interface ) ) return BOOL ; Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces != Binding . NO SUPERINTERFACES ) { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length ) System . arraycopy ( interfaces To Visit , NUM , interfaces To Visit = new Reference Binding [ next Position + its Length + NUM ] , NUM , next Position ) ; next Interface : for ( int a = NUM ; a < its Length ; a ++ ) { Reference Binding next = its Interfaces [ a ] ; for ( int b = NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } return BOOL ; }
public Road ( int id , String name , Intersection from , Intersection to , Road Class road Class , Road Layer road Layer ) { this . id = id ; this . name = name ; this . road Layer = road Layer ; points = new Waypoint [ NUM ] ; set Intersections ( from , to ) ; this . road Class = road Class ; create Lines ( ) ; modified = BOOL ; }
@ Override public void process ( Watched Event event ) { Keeper State event State = event . get State ( ) ; Event Type event Type = event . get Type ( ) ; log . info ( STRING , event State , event Type ) ; if ( event State == Keeper State . Sync Connected ) { connected Signal . count Down ( ) ; log . info ( STRING , connection String ) ; } }
private void init Properties ( String file Properties Name ) { read From Class Path ( file Properties Name ) ; Path cur Dir Path = get File In Current Dir ( file Properties Name ) ; if ( Files . exists ( cur Dir Path ) ) { try ( Input Stream cur Folder = Files . new Input Stream ( cur Dir Path ) ) { if ( cur Folder != null ) { load ( cur Folder ) ; } } catch ( Exception e ) { throw new Runtime Exception ( STRING + file Properties Name , e ) ; } } }
private void reset Bounds ( ) { bottom Protein Id = null ; top Protein Id = null ; }
private String property ( String class Id , String key , String instance Id ) { return PREFIX OVF PROP + make Property Key ( class Id , key , instance Id ) ; }
public String list ( String dir ) throws IO Exception { passive ( ) ; send ( STRING + dir ) ; read Code ( NUM ) ; Byte Array Output Stream out = new Byte Array Output Stream ( ) ; IO Utils . copy And Close ( in Data , out ) ; read Code ( NUM ) ; byte [ ] data = out . to Byte Array ( ) ; return new String ( data ) ; }
public static int convert Px To Sp ( int px Size ) { return Math . round ( ( float ) px Size * get Display Density 4 Fonts ( ) ) ; }
private void persist Consistency Groups ( Collection < Block Consistency Group > cgs To Persist ) { if ( null != cgs To Persist && ! cgs To Persist . is Empty ( ) ) { List < Block Consistency Group > cgs To Create = new Array List < Block Consistency Group > ( ) ; List < Block Consistency Group > cgs To Update = new Array List < Block Consistency Group > ( ) ; for ( Block Consistency Group cg : cgs To Persist ) { if ( null == cg . get Creation Time ( ) ) { cgs To Create . add ( cg ) ; } else { cgs To Update . add ( cg ) ; } } if ( ! cgs To Create . is Empty ( ) ) { db Client . create Object ( cgs To Create ) ; } if ( ! cgs To Update . is Empty ( ) ) { db Client . update Object ( cgs To Update ) ; } } }
public void request Password Changed Time ( ) { operations . add ( Password Policy State Operation Type . GET PASSWORD CHANGED TIME ) ; }
public static byte [ ] encode Region Name ( String region Name ) { byte [ ] metadata ; try { JSON Object json Object = new JSON Object ( ) ; json Object . put ( JSON FIELD TAG , region Name ) ; String json = json Object . to String ( ) ; metadata = json . get Bytes ( JSON CHARSET ) ; } catch ( Exception e ) { Log . e ( TAG , STRING + e . get Message ( ) ) ; metadata = null ; } return metadata ; }
public boolean is Valid ( ) { boolean valid = BOOL ; if ( endtime . get Time ( ) < System . current Time Millis ( ) ) { valid = BOOL ; } else if ( starttime != null ) { if ( starttime . get Time ( ) > System . current Time Millis ( ) ) { valid = BOOL ; } } else { if ( authtime . get Time ( ) > System . current Time Millis ( ) ) { valid = BOOL ; } } return valid ; }
public void test Get Elements By Tag Name NS 1 ( ) throws Throwable { Document doc ; Document new Doc ; Document Type doc Type = null ; DOM Implementation dom Impl ; Node List child List ; String null NS = null ; doc = ( Document ) load ( STRING , builder ) ; dom Impl = doc . get Implementation ( ) ; new Doc = dom Impl . create Document ( null NS , STRING , doc Type ) ; child List = new Doc . get Elements By Tag Name NS ( STRING , STRING ) ; assert Equals ( STRING , NUM , child List . get Length ( ) ) ; }
public static boolean add Separator If Needed ( J Popup Menu popup Menu ) { final int menu Component Count = popup Menu . get Component Count ( ) ; if ( menu Component Count == NUM ) { return BOOL ; } final Component last Menu Component = popup Menu . get Component ( menu Component Count - NUM ) ; if ( is Popup Menu Separator ( last Menu Component ) ) { return BOOL ; } popup Menu . add Separator ( ) ; return BOOL ; }
public int group Size ( String grp Name ) { int res = NUM ; for ( Hadoop Counter counter : cntrs . values ( ) ) { if ( grp Name . equals ( counter . group ( ) ) ) res ++ ; } return res ; }
public Resource Bundle Enumeration ( Set < String > set , Enumeration < String > enumeration ) { this . set = set ; this . iterator = set . iterator ( ) ; this . enumeration = enumeration ; }
public static int to RGB ( Color Space color Space , float ... components ) { float [ ] rgb = color Space . to RGB ( components ) ; if ( rgb [ NUM ] < NUM || rgb [ NUM ] < NUM || rgb [ NUM ] < NUM || rgb [ NUM ] > NUM || rgb [ NUM ] > NUM || rgb [ NUM ] > NUM ) { return NUM ; } return NUM | ( ( int ) ( rgb [ NUM ] * NUM ) << NUM ) | ( ( int ) ( rgb [ NUM ] * NUM ) << NUM ) | ( int ) ( rgb [ NUM ] * NUM ) ; }
private static void skip Names ( Byte Buffer table Buffer , int count ) { for ( int i = NUM ; i < count ; ++ i ) { Byte Util . forward ( table Buffer , table Buffer . get Short ( ) ) ; } }
private Log Source ( ) { }
public Object 2 Int Open Hash Map < int [ ] > support Map ( ) { List < Item Set > item Sets = learn ( ) ; Object 2 Int Open Hash Map < int [ ] > confidence Map = new Object 2 Int Open Hash Map < > ( item Sets . size ( ) ) ; for ( Item Set item Set : item Sets ) { confidence Map . put ( item Set . items , item Set . support ) ; } return confidence Map ; }
public static List < String > make Feature Id List From Prefixed ( Map < String , Object > parameters ) { List < String > feature Id List = Fast List . new Instance ( ) ; if ( parameters == null ) return feature Id List ; for ( Map . Entry < String , Object > entry : parameters . entry Set ( ) ) { String parameter Name = entry . get Key ( ) ; if ( parameter Name . starts With ( STRING ) ) { String product Feature Id = ( String ) entry . get Value ( ) ; if ( Util Validate . is Not Empty ( product Feature Id ) ) { feature Id List . add ( product Feature Id ) ; } } } return feature Id List ; }
private void update Overscroll Animation ( final int scrolled Offset ) { if ( m Edge Glow Left == null || m Edge Glow Right == null ) return ; int next Scroll Position = m Current X + scrolled Offset ; if ( m Fling Tracker == null || m Fling Tracker . is Finished ( ) ) { if ( next Scroll Position < NUM ) { int overscroll = Math . abs ( scrolled Offset ) ; m Edge Glow Left . on Pull ( ( float ) overscroll / get Render Width ( ) ) ; if ( ! m Edge Glow Right . is Finished ( ) ) { m Edge Glow Right . on Release ( ) ; } } else if ( next Scroll Position > m Max X ) { int overscroll = Math . abs ( scrolled Offset ) ; m Edge Glow Right . on Pull ( ( float ) overscroll / get Render Width ( ) ) ; if ( ! m Edge Glow Left . is Finished ( ) ) { m Edge Glow Left . on Release ( ) ; } } } }
public void add Long Selection Listener ( Selection Listener listener ) { if ( listener == null ) throw new Illegal Argument Exception ( ) ; if ( ! long Selection Listeners . contains ( listener ) ) long Selection Listeners . add ( listener ) ; }
public void validate ( ) { final List < Validation Exception > exception List = new Array List < Validation Exception > ( ) ; validate ( exception List ) ; if ( ! exception List . is Empty ( ) ) throw exception List . get ( NUM ) ; }
protected void install Components ( ) { if ( ( renderer Pane = create Cell Renderer Pane ( ) ) != null ) { tree . add ( renderer Pane ) ; } }
private void run Pending Requests ( ) { int max Start Id = - NUM ; Billing Request request ; while ( ( request = m Pending Requests . peek ( ) ) != null ) { if ( request . run If Connected ( ) ) { m Pending Requests . remove ( ) ; if ( max Start Id < request . get Start Id ( ) ) { max Start Id = request . get Start Id ( ) ; } } else { bind To Market Billing Service ( ) ; return ; } } if ( max Start Id >= NUM ) { if ( Consts . DEBUG ) { Log . i ( TAG , STRING + max Start Id ) ; } stop Self ( max Start Id ) ; } }
public C Action Difference Traces ( final J Frame parent , final I Trace List Provider trace Provider , final Trace List trace 1 , final Trace List trace 2 ) { super ( String . format ( STRING , trace 1 . get Name ( ) , trace 2 . get Name ( ) ) ) ; m parent = parent ; m trace Provider = trace Provider ; m trace 1 = trace 1 ; m trace 2 = trace 2 ; }
public static void copy File ( File from File , File to File ) throws IO Exception { File Input Stream file Input Stream = new File Input Stream ( from File ) ; File Output Stream file Output Stream = new File Output Stream ( to File ) ; int i ; byte bytes [ ] = new byte [ NUM ] ; while ( ( i = file Input Stream . read ( bytes ) ) != - NUM ) { file Output Stream . write ( bytes , NUM , i ) ; } file Input Stream . close ( ) ; file Output Stream . close ( ) ; }
public final void update Time Control Title ( ) { int [ ] tmp Info = ctrl . get Time Limit ( ) ; String Builder sb = new String Builder ( ) ; int tc = tmp Info [ NUM ] ; int mps = tmp Info [ NUM ] ; int inc = tmp Info [ NUM ] ; if ( mps > NUM ) { sb . append ( mps ) ; sb . append ( STRING ) ; } sb . append ( time To String ( tc ) ) ; if ( ( inc > NUM ) || ( mps <= NUM ) ) { sb . append ( STRING ) ; sb . append ( tmp Info [ NUM ] / NUM ) ; } summary Title Text . set Text ( sb . to String ( ) ) ; }
public static boolean is Installed ( Package Manager package Manager , String package Name ) { List < Package Info > packs = package Manager . get Installed Packages ( NUM ) ; for ( int i = NUM ; i < packs . size ( ) ; i ++ ) { if ( Text Utils . equals ( packs . get ( i ) . package Name , package Name ) ) return BOOL ; } return BOOL ; }
@ After public void after ( ) throws SQL Exception { Connection connection = null ; Statement statement = null ; try { connection = get New Connection ( BOOL ) ; statement = connection . create Statement ( ) ; statement . execute Query ( STRING ) ; } finally { if ( statement != null ) { statement . close ( ) ; } if ( connection != null ) { connection . close ( ) ; } } }
private void attach Header ( SIP Header h ) { if ( h == null ) throw new Illegal Argument Exception ( STRING ) ; try { if ( h instanceof SIP Header List ) { SIP Header List < ? > hl = ( SIP Header List < ? > ) h ; if ( hl . is Empty ( ) ) { return ; } } attach Header ( h , BOOL , BOOL ) ; } catch ( SIP Duplicate Header Exception ex ) { } }
@ Action ( value = STRING ) public String list Workflow ( ) { if ( wf Action != null && wf Action . equals ( Collection Constants . WF ACTION APPROVE ) ) fetch Receipts ( Collection Constants . WF ACTION APPROVE ) ; else fetch Receipts ( Collection Constants . WF ACTION SUBMIT ) ; return INDEX ; }
public static final List < Geo > poly Near Poly ( Geo Array s , Geo Array r , double near ) { int rlen = r . get Size ( ) ; int slen = s . get Size ( ) ; Geo pl 0 = r . get ( rlen - NUM ) ; Geo pl 1 = new Geo ( ) ; Geo sl 0 = s . get ( slen - NUM ) ; Geo sl 1 = new Geo ( ) ; List < Geo > list = null ; for ( int j = NUM ; j < rlen ; j ++ ) { pl 1 = r . get ( j , pl 1 ) ; for ( int i = NUM ; i < slen ; i ++ ) { sl 1 = s . get ( i , sl 1 ) ; Geo ret = segments Intersect Or Near ( sl 0 , sl 1 , pl 0 , pl 1 , near ) ; if ( ret != null ) { if ( list == null ) { list = new Linked List < Geo > ( ) ; } list . add ( ret ) ; } sl 0 = sl 1 ; } pl 0 = pl 1 ; } return list ; }
public void init Param ( Object obj ) { param Object = obj ; Enumeration < Abstract Param Panel > en = table Panel . elements ( ) ; Abstract Param Panel panel = null ; while ( en . has More Elements ( ) ) { panel = en . next Element ( ) ; panel . init Param ( obj ) ; } }
public void update Topic ( String topic , Db Context Rule rule ) { topic = String Utils . to Lower English ( topic ) ; Rule Head head = rule Map . get ( topic ) ; if ( head == null ) { head = new Rule Head ( STRING , topic , rule ) ; rule Map . put ( topic , head ) ; statements . add ( head ) ; } else { head . set Rule ( rule ) ; } }
public static double log 10 ( double x ) { return Math . log ( x ) / LOG 10 ; }
public static int is Button On Screen ( final String button Key ) { Component on Screen ; try { on Screen = Bubble Window . find Button ( button Key , Rapid Miner GUI . get Main Frame ( ) ) ; } catch ( Null Pointer Exception e ) { return OBJECT NOT ON SCREEN ; } if ( on Screen == null ) { return OBJECT NOT ON SCREEN ; } int xposition = on Screen . get Location On Screen ( ) . x ; int yposition = on Screen . get Location On Screen ( ) . y ; int other Xposition = xposition + on Screen . get Width ( ) ; int other Yposition = yposition + on Screen . get Height ( ) ; Window frame = Rapid Miner GUI . get Main Frame ( ) ; if ( other Xposition <= frame . get Width ( ) && other Yposition <= frame . get Height ( ) && xposition > NUM && yposition > NUM ) { return OBJECT SHOWING ON SCREEN ; } else { return OBJECT NOT SHOWING ; } }
@ Override public void add Focusables ( Array List < View > views , int direction , int focusable Mode ) { final int focusable Count = views . size ( ) ; final int descendant Focusability = get Descendant Focusability ( ) ; if ( descendant Focusability != FOCUS BLOCK DESCENDANTS ) { for ( int i = NUM ; i < get Child Count ( ) ; i ++ ) { final View child = get Child At ( i ) ; if ( child . get Visibility ( ) == VISIBLE ) { Item Info ii = info For Child ( child ) ; if ( ii != null && ii . position == m Cur Item ) { child . add Focusables ( views , direction , focusable Mode ) ; } } } } if ( descendant Focusability != FOCUS AFTER DESCENDANTS || ( focusable Count == views . size ( ) ) ) { if ( ! is Focusable ( ) ) { return ; } if ( ( focusable Mode & FOCUSABLES TOUCH MODE ) == FOCUSABLES TOUCH MODE && is In Touch Mode ( ) && ! is Focusable In Touch Mode ( ) ) { return ; } if ( views != null ) { views . add ( this ) ; } } }
public static boolean reachable ( Inet Address addr , int reach Timeout ) { try { return addr . is Reachable ( reach Timeout ) ; } catch ( IO Exception ignore ) { return BOOL ; } }
protected static String timestr ( long time val , long total time ) { boolean neg ; long ms = NUM ; long sec = NUM ; long percent 10 ; String pad ; neg = time val < NUM ; if ( neg ) time val = - time val ; ms = time val % NUM ; sec = time val / NUM ; if ( sec < NUM ) pad = STRING ; else if ( sec < NUM ) pad = STRING ; else if ( sec < NUM ) pad = STRING ; else pad = STRING ; percent 10 = ( time val * NUM ) / total time ; return ( neg ? STRING : STRING ) + pad + sec + STRING + ( ( ms % NUM ) / NUM ) + ( ( ms % NUM ) / NUM ) + ( ms % NUM ) + STRING + STRING + percent 10 / NUM + STRING + percent 10 % NUM + STRING ; }
public static Tree rotate By Name ( Tree tree ) { return new Simple Tree ( rotate Node By Name ( tree , tree . get Root ( ) ) ) ; }
@ Subscribe public void on Event ( Search In Position event ) { List < Lat Lng > list = Map Helper . get Search Area ( event . get Steps ( ) , new Lat Lng ( event . get Position ( ) . latitude , event . get Position ( ) . longitude ) ) ; snack Me ( get String ( R . string . toast searching ) ) ; niantic Manager . get Gyms ( event . get Position ( ) . latitude , event . get Position ( ) . longitude , NUM ) ; niantic Manager . get Poke Stops ( event . get Position ( ) . latitude , event . get Position ( ) . longitude , NUM ) ; niantic Manager . get Lured Pokemon ( event . get Position ( ) . latitude , event . get Position ( ) . longitude , NUM ) ; for ( Lat Lng p : list ) { niantic Manager . get Catchable Pokemon ( p . latitude , p . longitude , NUM ) ; } }
public void save ( On Save Log Listener listener ) { File dir = get Log Dir ( ) ; if ( dir == null ) { listener . on Error ( STRING + STRING ) ; return ; } File Writer file Writer = null ; try { File output = new File ( dir , get Log File Name ( ) ) ; file Writer = new File Writer ( output , BOOL ) ; List < Log Entry > entries = buffered Logs ( ) ; for ( Log Entry entry : entries ) { file Writer . write ( entry . pretty Print ( ) + STRING ) ; } listener . on Save ( output ) ; } catch ( IO Exception e ) { listener . on Error ( e . get Message ( ) ) ; e . print Stack Trace ( ) ; } finally { if ( file Writer != null ) { try { file Writer . close ( ) ; } catch ( IO Exception e ) { listener . on Error ( e . get Message ( ) ) ; e . print Stack Trace ( ) ; } } } }
protected Storage HA Domain check Adapter Exists In DB ( String native Guid ) throws IO Exception { Storage HA Domain adapter = null ; List < Storage HA Domain > adapter In DB = Custom Query Utility . get Active Storage HA Domain By Native Guid ( db Client , native Guid ) ; if ( adapter In DB != null && ! adapter In DB . is Empty ( ) ) { adapter = adapter In DB . get ( NUM ) ; } return adapter ; }
public static Executor create Task Distributor ( ) { return Executors . new Cached Thread Pool ( create Thread Factory ( Thread . NORM PRIORITY , STRING ) ) ; }
protected Coordinate [ ] to Coordinate Array ( Stack stack ) { Coordinate [ ] coordinates = new Coordinate [ stack . size ( ) ] ; for ( int i = NUM ; i < stack . size ( ) ; i ++ ) { Coordinate coordinate = ( Coordinate ) stack . get ( i ) ; coordinates [ i ] = coordinate ; } return coordinates ; }
private static void on Entity Opened ( Key Event event ) throws Bad Location Exception { J Editor Pane editor = ( J Editor Pane ) event . get Source ( ) ; Document doc = editor . get Document ( ) ; int pos = editor . get Caret Position ( ) ; String tag = get Current Tag ( doc . get Text ( NUM , pos ) ) ; if ( tag . equals ( STRING ) ) { return ; } String remainder = doc . get Text ( pos , doc . get Length ( ) - pos ) ; for ( int i = NUM ; i < remainder . length ( ) ; i ++ ) { char c = remainder . char At ( i ) ; if ( c == STRING ) { break ; } else if ( ! Character . is Whitespace ( c ) ) { return ; } } String Buffer buffer = new String Buffer ( ) ; int new Position = pos ; String indent = get Indent ( doc , pos ) ; if ( tag . equals ( STRING ) ) { buffer . append ( STRING ) ; new Position += NUM ; } else if ( tag . equals ( STRING ) ) { buffer . append ( STRING ) ; new Position += NUM ; } else if ( tag . equals ( STRING ) ) { buffer . append ( STRING ) ; new Position += NUM ; } else if ( tag . equals ( STRING ) ) { buffer . append ( STRING ) ; buffer . append ( indent + STRING ) ; buffer . append ( indent + STRING ) ; new Position += NUM ; } else if ( tag . equals ( STRING ) ) { buffer . append ( STRING ) ; buffer . append ( indent + STRING ) ; new Position += NUM ; } else if ( tag . equals ( STRING ) ) { buffer . append ( STRING ) ; buffer . append ( indent + STRING ) ; buffer . append ( indent + STRING ) ; new Position += NUM + indent . length ( ) ; } else { return ; } doc . insert String ( pos , buffer . to String ( ) , null ) ; editor . set Caret Position ( new Position ) ; event . consume ( ) ; }
@ Suppress Warnings ( STRING ) private String check For Well Known Namespace Prefix ( final String prefix ) { final String namespace ; if ( prefix . equals ( STRING ) ) { prefix Map . put ( STRING , namespace = BD . NAMESPACE ) ; } else if ( prefix . equals ( STRING ) ) { prefix Map . put ( STRING , namespace = BDS . NAMESPACE ) ; } else if ( prefix . equals ( STRING ) ) { prefix Map . put ( STRING , namespace = Query Hints . NAMESPACE ) ; } else if ( prefix . equals ( STRING ) ) { prefix Map . put ( STRING , namespace = RDF . NAMESPACE ) ; } else if ( prefix . equals ( STRING ) ) { prefix Map . put ( STRING , namespace = RDFS . NAMESPACE ) ; } else if ( prefix . equals ( STRING ) ) { prefix Map . put ( STRING , namespace = XSD . NAMESPACE ) ; } else if ( prefix . equals ( STRING ) ) { prefix Map . put ( STRING , namespace = FOAF Vocabulary Decl . NAMESPACE ) ; } else if ( prefix . equals ( STRING ) ) { prefix Map . put ( STRING , namespace = FN . NAMESPACE ) ; } else if ( prefix . equals ( STRING ) ) { prefix Map . put ( STRING , namespace = OWL . NAMESPACE ) ; } else if ( prefix . equals ( STRING ) ) { prefix Map . put ( STRING , namespace = SESAME . NAMESPACE ) ; } else if ( prefix . equals ( STRING ) ) { prefix Map . put ( STRING , namespace = GAS Service . Options . NAMESPACE ) ; } else { namespace = null ; } return namespace ; }
private void prepare User For Ranking ( User user ) { User updated User = user Repository . find One ( user . get Id ( ) , NUM ) ; if ( updated User . get Imported ( ) == null || ! updated User . get Imported ( ) ) { updated User . set Imported ( BOOL ) ; updated User . set Pagerank ( null ) ; updated User . set Last Page Rank ( null ) ; updated User . set Current Rank ( null ) ; updated User . set Previous Rank ( null ) ; user Repository . save ( updated User , NUM ) ; } }
private static List < Comment > order Comments ( List < Comment > comments ) { Map < String , List < Comment > > parent Map = new Hash Map < > ( ) ; List < Comment > root Comments = new Array List < > ( ) ; for ( Comment c : comments ) { String parent Uuid = c . parent Uuid ; List < Comment > l = parent Map . get ( parent Uuid ) ; if ( l == null ) { l = new Array List < > ( ) ; parent Map . put ( parent Uuid , l ) ; } l . add ( c ) ; if ( parent Uuid == null ) { root Comments . add ( c ) ; } } List < Comment > result = new Array List < > ( ) ; add Children ( parent Map , root Comments , result ) ; return result ; }
protected static final void log Raw Diagnostic ( String msg ) { if ( diagnostics Stream != null ) { diagnostics Stream . println ( msg ) ; diagnostics Stream . flush ( ) ; } }
public void initialize ( Subject subject , Callback Handler callback Handler , Map < String , ? > shared State , Map < String , ? > options ) { unauthenticated Identity = ( String ) options . get ( STRING ) ; handler = callback Handler ; this . subject = subject ; }
public Macro ( File file ) throws EOF Exception , File Not Found Exception , IO Exception { Document Builder Factory dbf = Document Builder Factory . new Instance ( ) ; Document Builder db = null ; Document doc = null ; try { db = dbf . new Document Builder ( ) ; Input Source is = new Input Source ( new Unicode Reader ( new File Input Stream ( file ) , FILE ENCODING ) ) ; is . set Encoding ( FILE ENCODING ) ; doc = db . parse ( is ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; String desc = e . get Message ( ) ; if ( desc == null ) { desc = e . to String ( ) ; } throw new IO Exception ( STRING + desc ) ; } macro Records = new Array List ( ) ; boolean parsed OK = initialize From XML File ( doc . get Document Element ( ) ) ; if ( parsed OK == BOOL ) { name = null ; macro Records . clear ( ) ; macro Records = null ; throw new IO Exception ( STRING ) ; } }
public boolean contains ( symbol sym ) { return all . contains Key ( sym . name ( ) ) ; }
private Pie Data generate Data Pie ( int cnt ) { Array List < Entry > entries = new Array List < Entry > ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { entries . add ( new Entry ( ( int ) ( Math . random ( ) * NUM ) + NUM , i ) ) ; } Pie Data Set d = new Pie Data Set ( entries , STRING ) ; d . set Slice Space ( NUM ) ; d . set Colors ( Color Template . VORDIPLOM COLORS ) ; Pie Data cd = new Pie Data ( get Quarters ( ) , d ) ; return cd ; }
public void send User Delete Notification ( Map attributes ) { try { if ( delete Notify List != null && ! delete Notify List . is Empty ( ) ) { send Email ( delete Notify List , attributes , STRING , STRING , STRING ) ; } } catch ( Messaging Exception e ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STRING + STRING + STRING + entry DN , e ) ; } } }
public void add Maps Id Mapping ( Database Mapping mapping ) { maps Id Mappings . add ( mapping ) ; }
@ Override public final char read Char ( ) throws IO Exception { dis . read Fully ( work , NUM , NUM ) ; return ( char ) ( ( work [ NUM ] & NUM ) << NUM | ( work [ NUM ] & NUM ) ) ; }
public int task Size ( ) { return tasks . size ( ) ; }
public void add Muted Ip ( final String ip , final Date mute Till ) { if ( is Ip Muted ( ip ) ) { remove Muted Ip ( ip ) ; } Timestamp mute Till Ts = null ; if ( mute Till != null ) { mute Till Ts = new Timestamp ( mute Till . get Time ( ) ) ; } s logger . fine ( STRING + ip ) ; final Connection con = Database . get Connection ( ) ; try { final Prepared Statement ps = con . prepare Statement ( STRING ) ; ps . set String ( NUM , ip ) ; ps . set Timestamp ( NUM , mute Till Ts ) ; ps . execute ( ) ; ps . close ( ) ; con . commit ( ) ; } catch ( final SQL Exception sqle ) { if ( sqle . get Error Code ( ) == NUM ) { s logger . info ( STRING + ip + STRING + sqle . get Message ( ) ) ; return ; } s logger . log ( Level . SEVERE , STRING + ip , sqle ) ; throw new Illegal State Exception ( sqle . get Message ( ) ) ; } finally { Db Util . close Connection ( con ) ; } }
public boolean is Rsl Url Signed ( String url ) { if ( url == null ) { return BOOL ; } return url . ends With ( SIGNED RSL URL DOT EXTENSION ) ; }
public void remove User Lockout Entry ( String user DN ) { pw Reset Fail Hash . remove ( user DN ) ; user Warning Count = NUM ; }
public void create Database Entities For Business Object Data Search Testing ( ) { business Object Data Dao Test Helper . create Business Object Data Entity ( Abstract Service Test . NAMESPACE , Abstract Service Test . BDEF NAME , Abstract Service Test . FORMAT USAGE CODE , Abstract Service Test . FORMAT FILE TYPE CODE , Abstract Service Test . FORMAT VERSION , Abstract Service Test . PARTITION VALUE , Abstract Service Test . NO SUBPARTITION VALUES , Abstract Service Test . DATA VERSION , Abstract Service Test . LATEST VERSION FLAG SET , Business Object Data Status Entity . VALID ) ; business Object Data Dao Test Helper . create Business Object Data Entity ( Abstract Service Test . NAMESPACE , Abstract Service Test . BDEF NAME , Abstract Service Test . FORMAT USAGE CODE 2 , Abstract Service Test . FORMAT FILE TYPE CODE , Abstract Service Test . FORMAT VERSION , Abstract Service Test . PARTITION VALUE , Abstract Service Test . NO SUBPARTITION VALUES , Abstract Service Test . DATA VERSION , Abstract Service Test . LATEST VERSION FLAG SET , Business Object Data Status Entity . INVALID ) ; business Object Data Dao Test Helper . create Business Object Data Entity ( Abstract Service Test . NAMESPACE 2 , Abstract Service Test . BDEF NAME 2 , Abstract Service Test . FORMAT USAGE CODE 2 , Abstract Service Test . FORMAT FILE TYPE CODE , Abstract Service Test . FORMAT VERSION 2 , Abstract Service Test . PARTITION VALUE , Abstract Service Test . NO SUBPARTITION VALUES , Abstract Service Test . DATA VERSION , Abstract Service Test . LATEST VERSION FLAG SET , Business Object Data Status Entity . INVALID ) ; business Object Data Dao Test Helper . create Business Object Data Entity ( Abstract Service Test . NAMESPACE 2 , Abstract Service Test . BDEF NAME 2 , Abstract Service Test . FORMAT USAGE CODE 2 , Abstract Service Test . FORMAT FILE TYPE CODE 2 , Abstract Service Test . FORMAT VERSION 2 , Abstract Service Test . PARTITION VALUE , Abstract Service Test . NO SUBPARTITION VALUES , Abstract Service Test . DATA VERSION , Abstract Service Test . LATEST VERSION FLAG SET , Business Object Data Status Entity . VALID ) ; }
@ Skip Validation @ Action ( value = STRING ) public String reset ( ) { if ( LOGGER . is Debug Enabled ( ) ) LOGGER . debug ( STRING + owner Name + STRING + zone Id + STRING + ward Id + STRING + property Type + STRING + notice Type + STRING + notice Number + STRING + notice From Date + STRING + notice To Date + STRING + index Number + STRING + house Number ) ; owner Name = STRING ; zone Id = - NUM ; ward Id = - NUM ; property Type = STRING ; notice Type = STRING ; notice Number = STRING ; notice From Date = null ; notice To Date = null ; index Number = STRING ; house Number = STRING ; if ( LOGGER . is Debug Enabled ( ) ) LOGGER . debug ( STRING ) ; return INDEX ; }
public void check Options Valid ( ) { if ( alias ratio < NUM || alias ratio > NUM ) { throw new Runtime Exception ( STRING ) ; } if ( null ratio < NUM || null ratio > NUM ) { throw new Runtime Exception ( STRING ) ; } if ( maxsize <= NUM ) { throw new Runtime Exception ( STRING + maxsize ) ; } if ( ! literals file . is Empty ( ) && literals level == Class Literals Mode . NONE ) { throw new Runtime Exception ( STRING ) ; } }
@ Override public UUID session Id ( ) { if ( session Id == null ) session Id = UUID . random UUID ( ) ; return session Id ; }
private void read Object ( final Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; final Calendar defining Calendar = Calendar . get Instance ( time Zone , locale ) ; init ( defining Calendar ) ; }
@ Override public Mem Chunk Holder < Big Data P Mem Allocator > create Chunk ( long size , boolean autoreclaim ) { Mem Chunk Holder < Big Data P Mem Allocator > ret = null ; Long addr = m nvmasvc . allocate ( m nid , size , BOOL ) ; if ( ( null == addr || NUM == addr ) && m activegc ) { force GC ( ) ; addr = m nvmasvc . allocate ( m nid , size , BOOL ) ; } if ( null != addr && NUM != addr ) { ret = new Mem Chunk Holder < Big Data P Mem Allocator > ( this , addr , size ) ; ret . set Collector ( m chunkcollector ) ; if ( autoreclaim ) { m chunkcollector . register ( ret ) ; } } return ret ; }
public int hash Code ( ) { int result = NUM ; if ( table Name != null ) { result = NUM * table Name . hash Code ( ) ; } if ( repository Name != null ) { result = NUM * repository Name . hash Code ( ) ; } return result ; }
public synchronized void add ( String name , long thread Id ) { if ( m Finished ) { throw new Illegal State Exception ( STRING ) ; } m Markers . add ( new Marker ( name , thread Id , System Clock . elapsed Realtime ( ) ) ) ; }
private void to String ( String Builder acc , int prec , boolean expand ) { if ( this . meta != null && ! expand ) { acc . append ( this . meta ) ; return ; } boolean paren = op . get Prec ( ) < prec ; if ( paren ) acc . append ( STRING ) ; to String ( acc , expand ) ; if ( paren ) acc . append ( STRING ) ; }
public static boolean is Not Null Value ( String s ) { return ( ( s != null ) && ! s . is Empty ( ) && ! s . equals ( Null Column Value Getter . get Null Str ( ) ) ) ; }
private E unlink First ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; not Full . signal ( ) ; return item ; }
public static String remove All ( String source , char to Remove ) { int to Remove Index = source . index Of ( to Remove ) ; if ( to Remove Index != - NUM ) { String Builder result = new String Builder ( source . length ( ) ) ; int source Index = NUM ; while ( to Remove Index != - NUM ) { result . append ( source . substring ( source Index , to Remove Index ) ) ; source Index = to Remove Index + NUM ; to Remove Index = source . index Of ( to Remove , source Index ) ; if ( to Remove Index == - NUM ) { result . append ( source . substring ( source Index , source . length ( ) ) ) ; } } return result . to String ( ) ; } else { return source ; } }
public List < Entry < E > > as List ( ) { if ( non Null List == null ) { if ( array == null || array . length ( ) == NUM ) { non Null List = Collections . empty List ( ) ; } else { List < Entry < E > > list = new Array List < > ( array . length ( ) ) ; for ( int i = NUM ; i < array . length ( ) ; i ++ ) { E e = array . get ( i ) ; if ( e != null ) { list . add ( new Entry < > ( i , e ) ) ; } } non Null List = list ; } } return non Null List ; }
public static Range find Cumulative Range Bounds ( Category Dataset dataset ) { Param Checks . null Not Permitted ( dataset , STRING ) ; boolean all Items Null = BOOL ; double minimum = NUM ; double maximum = NUM ; for ( int row = NUM ; row < dataset . get Row Count ( ) ; row ++ ) { double running Total = NUM ; for ( int column = NUM ; column <= dataset . get Column Count ( ) - NUM ; column ++ ) { Number n = dataset . get Value ( row , column ) ; if ( n != null ) { all Items Null = BOOL ; double value = n . double Value ( ) ; if ( ! Double . is Na N ( value ) ) { running Total = running Total + value ; minimum = Math . min ( minimum , running Total ) ; maximum = Math . max ( maximum , running Total ) ; } } } } if ( ! all Items Null ) { return new Range ( minimum , maximum ) ; } else { return null ; } }
private void add Hotkeys ( J Root Pane pane ) { for ( Hotkey hotkey : hotkeys ) { if ( does Hotkey Have Action ( hotkey ) && hotkey . type == Type . REGULAR ) { if ( pane == null ) { add Hotkey ( hotkey , main . get Root Pane ( ) ) ; for ( J Dialog popout : popouts . key Set ( ) ) { add Hotkey ( hotkey , popout . get Root Pane ( ) ) ; } } else { add Hotkey ( hotkey , pane ) ; } } } }
static < T > Replay Promise < Void > all Replay ( final Duration timeout , final List < Promise < T > > promises ) { return all Replay ( timeout , System . current Time Millis ( ) , promises . to Array ( new Promise [ promises . size ( ) ] ) ) ; }
public void check And Setup Boot Strap Info ( Db Client db Client ) { if ( on Standby ) { log . info ( STRING ) ; return ; } if ( vdc List != null && vdc List . size ( ) > NUM ) { log . info ( STRING , vdc List . size ( ) ) ; return ; } int retry Interval Secs = DBINIT RETRY INTERVAL ; boolean done = BOOL ; boolean wait ; while ( ! done ) { wait = BOOL ; Inter Process Lock lock = null ; try { lock = coordinator . get Lock ( get Bootstrap Lock Name ( ) ) ; log . info ( STRING ) ; lock . acquire ( ) ; if ( is Geo Dbsvc ( ) ) { insert Default Root Tenant ( db Client ) ; } else { insert My Vdc Info ( db Client ) ; insert Vdc Version ( db Client ) ; insert Password History ( db Client ) ; } done = BOOL ; } catch ( Exception e ) { if ( e instanceof Illegal State Exception ) { throw ( Illegal State Exception ) e ; } else { log . warn ( STRING , retry Interval Secs , e ) ; wait = BOOL ; } } finally { if ( lock != null ) { try { lock . release ( ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; } } } if ( wait ) { try { Thread . sleep ( retry Interval Secs * NUM ) ; } catch ( Interrupted Exception ex ) { log . warn ( STRING , ex ) ; } } } }
Object process EXPR ( Stylesheet Handler handler , String uri , String name , String raw Name , String value , Elem Template Element owner ) throws org . xml . sax . SAX Exception { try { X Path expr = handler . create X Path ( value , owner ) ; return expr ; } catch ( Transformer Exception te ) { throw new org . xml . sax . SAX Exception ( te ) ; } }
private void check Access ( Unix Path file , boolean check Read , boolean check Write ) { Security Manager sm = System . get Security Manager ( ) ; if ( sm != null ) { if ( check Read ) file . check Read ( ) ; if ( check Write ) file . check Write ( ) ; sm . check Permission ( new Runtime Permission ( STRING ) ) ; } }
private static Spanned remove Image Span Objects ( Spanned spanned ) { Spannable String Builder builder = ( Spannable String Builder ) spanned ; Object [ ] spanned Objects = builder . get Spans ( NUM , builder . length ( ) , Object . class ) ; for ( int i = NUM ; i < spanned Objects . length ; i ++ ) { if ( spanned Objects [ i ] instanceof Image Span ) { Image Span image Span = ( Image Span ) spanned Objects [ i ] ; builder . replace ( spanned . get Span Start ( image Span ) , builder . get Span End ( image Span ) , STRING ) ; } } return spanned ; }
public Future < String > classify ( String snippet ) { final Executor Service service = Executors . new Single Thread Executor ( ) ; return service . submit ( new Classifying Task ( snippet ) ) ; }
public abstract byte [ ] embed Data ( byte [ ] msg , String msg File Name , byte [ ] cover , String cover File Name , String stego File Name ) throws Open Stego Exception ;
public void add Setter ( int i ) { for ( Scatter Plot Setter setter : setter List ) { if ( setter . get Index ( ) == i ) { return ; } } setter List . add ( new Scatter Plot Setter ( i ) ) ; }
@ Override public synchronized void initialize ( ) { if ( ! m Root Directory . exists ( ) ) { if ( ! m Root Directory . mkdirs ( ) ) { Loger . debug ( String . format ( STRING , m Root Directory . get Absolute Path ( ) ) ) ; } return ; } File [ ] files = m Root Directory . list Files ( ) ; if ( files == null ) { return ; } for ( File file : files ) { Buffered Input Stream fis = null ; try { fis = new Buffered Input Stream ( new File Input Stream ( file ) ) ; Cache Header entry = Cache Header . read Header ( fis ) ; entry . size = file . length ( ) ; put Entry ( entry . key , entry ) ; } catch ( IO Exception e ) { file . delete ( ) ; } finally { File Utils . close IO ( fis ) ; } } }
public Client ( final Server Socket Channel server ) throws IO Exception { try { client = server . accept ( ) ; client . configure Blocking ( BOOL ) ; if ( ! client . finish Connect ( ) ) throw new IO Exception ( STRING ) ; client Selector = Selector . open ( ) ; client Key = client . register ( client Selector , Selection Key . OP READ ) ; if ( log . is Info Enabled ( ) ) log . info ( STRING ) ; } catch ( IO Exception ex ) { close ( ) ; throw ex ; } }
public Transfer write Bytes ( byte [ ] data ) throws IO Exception { if ( data == null ) { write Int ( - NUM ) ; } else { write Int ( data . length ) ; out . write ( data ) ; } return this ; }
public static void stop ( String [ ] args ) { LOG . info ( STRING ) ; System . exit ( NUM ) ; }
public boolean add ( Object o ) { if ( ! list . contains ( o ) ) { list . add ( o ) ; return BOOL ; } return BOOL ; }
private XY Plot initialize Lower Plot ( ) { non Heap Memory = new Y Interval Series Improved ( STRING ) ; Y Interval Series Collection y Interval Series Collection = new Y Interval Series Collection ( ) ; y Interval Series Collection . add Series ( non Heap Memory ) ; Deviation Renderer renderer = new Deviation Renderer ( BOOL , BOOL ) ; renderer . set Base Shapes Visible ( BOOL ) ; renderer . set Series Stroke ( NUM , new Basic Stroke ( NUM ) ) ; renderer . set Series Outline Stroke ( NUM , new Basic Stroke ( NUM ) ) ; renderer . set Series Shape ( NUM , new Ellipse 2 D . Double ( - NUM , - NUM , NUM , NUM ) ) ; renderer . set Base Tool Tip Generator ( new Standard XY Tool Tip Generator ( Standard XY Tool Tip Generator . DEFAULT TOOL TIP FORMAT , Date Format . get Date Time Instance ( ) , Number Format . get Number Instance ( ) ) ) ; final Number Axis range Axis = new Number Axis ( STRING ) ; range Axis . set Range Type ( Range Type . POSITIVE ) ; System Information Data system Data = ( System Information Data ) data Access Service . get Last Data Object ( system Template ) ; if ( system Data != null ) { double max Non Heap Upper Range ; if ( system Data . get Max Non Heap Memory Size ( ) != - NUM ) { max Non Heap Upper Range = system Data . get Max Non Heap Memory Size ( ) / NUM ; } else if ( system Data . get Init Non Heap Memory Size ( ) != - NUM ) { max Non Heap Upper Range = ( system Data . get Init Non Heap Memory Size ( ) * NUM ) / NUM ; } else { max Non Heap Upper Range = NUM * NUM * NUM ; } if ( max Non Heap Upper Range > NUM ) { range Axis . set Range ( NUM , max Non Heap Upper Range ) ; range Axis . set Auto Range Minimum Size ( max Non Heap Upper Range ) ; } } final XY Plot subplot = new XY Plot ( y Interval Series Collection , null , range Axis , renderer ) ; subplot . set Axis Offset ( new Rectangle Insets ( NUM , NUM , NUM , NUM ) ) ; subplot . set Range Axis Location ( Axis Location . TOP OR LEFT ) ; subplot . set Range Crosshair Visible ( BOOL ) ; return subplot ; }
public static void log Error ( Throwable exception , String message , Object ... args ) { message = Message Format . format ( message , args ) ; log ( I Status . ERROR , I Status . OK , message , exception ) ; }
public void add ( Row r ) { list . add ( r ) ; memory += r . get Memory ( ) + Constants . MEMORY POINTER ; if ( max Memory > NUM && memory > max Memory ) { write All Rows ( ) ; } size ++ ; }
private Message List View render Conversation ( Conversation Info conv Info , View parent ) { Message List View list = new Message List View ( parent . get Context ( ) ) ; conv Info . view = list ; list . set On Item Click Listener ( Message Click Listener . get Instance ( ) ) ; Message List Adapter adapter = conv Info . adapter ; if ( adapter == null ) { adapter = new Message List Adapter ( conv Info . conv , parent . get Context ( ) ) ; conv Info . adapter = adapter ; } list . set Adapter ( adapter ) ; list . set Selection ( adapter . get Count ( ) - NUM ) ; return list ; }
public static int define Tag ( int ifd Id , short tag Id ) { return ( tag Id & NUM ) | ( ifd Id << NUM ) ; }
public Application Id Verifier ( Set < String > supported Application Ids ) { this . supported Application Ids = Collections . unmodifiable Set ( new Hash Set < String > ( supported Application Ids ) ) ; }
public Query Response search ( Resource resource , Solr Query query ) throws Solr Server Exception , IO Exception { String id Query = term Query ( Search Fields . URI FIELD NAME , Search Fields . get Resource ID ( resource ) ) ; query . set Query ( query . get Query ( ) + STRING + id Query ) ; return search ( query ) ; }
public static Local Date to Date ( String data , String modelo ) { return Local Date . parse ( data , formatter ( modelo ) ) ; }
public boolean is Mutable ( ) { return mutable ; }
public static final Criterion all ( ) { return All Criterion . all ( ) ; }
public static void transform ( Input Stream src Stream , Output Stream dest Stream , Input Stream stylesheet Stream , String output Format ) throws FOP Exception { Stream Source src = new Stream Source ( src Stream ) ; Stream Source stylesheet = stylesheet Stream == null ? null : new Stream Source ( stylesheet Stream ) ; Fop fop = create Fop Instance ( dest Stream , output Format ) ; transform ( src , stylesheet , fop ) ; }
public boolean Insert Sym ( int type , String id , String context , String c Type , int line , int col ) { int i ; if ( type == PROCEDUREVAR || type == PROCESSVAR || type == PARAMETER ) { i = Find Sym ( GLOBAL , id , STRING ) ; if ( i < symtab . size ( ) ) return BOOL ; i = Find Sym ( id , context ) ; if ( i < symtab . size ( ) ) return BOOL ; } else { i = Find Sym ( type , id , context ) ; if ( i < symtab . size ( ) ) return BOOL ; } Sym Tab Entry se = new Sym Tab Entry ( type , id , context , c Type , line , col ) ; symtab . add Element ( se ) ; return BOOL ; }
public static Schema schema For Struct Type ( Struct Type struct Type ) { List < String > field Names = Lists . new Array List ( ) ; List < String > field Types = Lists . new Array List ( ) ; for ( Struct Field field : struct Type . fields ( ) ) { field Names . add ( field . name ( ) ) ; Data Type field Type = field . data Type ( ) ; if ( field Type . equals ( Data Types . String Type ) ) { field Types . add ( STRING ) ; } else if ( field Type . equals ( Data Types . Float Type ) ) { field Types . add ( STRING ) ; } else if ( field Type . equals ( Data Types . Double Type ) ) { field Types . add ( STRING ) ; } else if ( field Type . equals ( Data Types . Integer Type ) ) { field Types . add ( STRING ) ; } else if ( field Type . equals ( Data Types . Long Type ) ) { field Types . add ( STRING ) ; } else if ( field Type . equals ( Data Types . Boolean Type ) ) { field Types . add ( STRING ) ; } else { throw new Runtime Exception ( STRING + field Type ) ; } } return Record Utils . schema For ( field Names , field Types ) ; }
public Jetty Solr Runner start Jetty Solr Runner ( Jetty Solr Runner jetty ) throws Exception { jetty . start ( BOOL ) ; jettys . add ( jetty ) ; return jetty ; }
public Map < CIM Object Path , Set < String > > find Any SLO Storage Groups Can Be Re Used ( Storage System for Provider , Storage System storage , String policy Name , boolean associated To View ) throws WBEM Exception { Closeable Iterator < CIM Instance > group Instance Itr = null ; Closeable Iterator < CIM Object Path > volume Path Itr = null ; Map < CIM Object Path , Set < String > > group Paths = new Concurrent Hash Map < CIM Object Path , Set < String > > ( ) ; try { CIM Object Path controller Config Svc Path = cim Path . get Controller Config Svc Path ( storage ) ; log . info ( STRING ) ; group Instance Itr = get Associator Instances ( for Provider , controller Config Svc Path , null , SE DEVICE MASKING GROUP , null , null , PS V3 STORAGE GROUP PROPERTIES ) ; while ( group Instance Itr . has Next ( ) ) { CIM Instance group Instance = group Instance Itr . next ( ) ; CIM Object Path group Path = group Instance . get Object Path ( ) ; String group Name = CIM Property Factory . get Property Value ( group Instance , CP ELEMENT NAME ) ; String fast Setting = CIM Property Factory . get Property Value ( group Instance , CP FAST SETTING ) ; String group Associated To View = CIM Property Factory . get Property Value ( group Instance , CP ASSOCIATED TO VIEW ) ; Set < String > returned Native Guids = new Hash Set < String > ( ) ; if ( fast Setting . equals ( policy Name ) && associated To View == Boolean . parse Boolean ( group Associated To View ) && group Name . starts With ( Constants . STORAGE GROUP PREFIX ) ) { log . debug ( STRING , group Name ) ; volume Path Itr = get Associator Names ( for Provider , group Path , null , CIM STORAGE VOLUME , null , null ) ; while ( volume Path Itr . has Next ( ) ) { returned Native Guids . add ( get Volume Native Guid ( volume Path Itr . next ( ) ) ) ; } group Paths . put ( group Path , returned Native Guids ) ; } } } finally { close CIM Iterator ( group Instance Itr ) ; close CIM Iterator ( volume Path Itr ) ; } return group Paths ; }
Remover add ( T listener ) ;
protected void update Damage ( Document Event changes , Shape a , View Factory f ) { check Metrics ( ) ; Component host = get Container ( ) ; Element elem = get Element ( ) ; Document Event . Element Change ec = changes . get Change ( elem ) ; Element [ ] added = ( ec != null ) ? ec . get Children Added ( ) : null ; Element [ ] removed = ( ec != null ) ? ec . get Children Removed ( ) : null ; if ( ( ( added != null ) && ( added . length > NUM ) ) || ( ( removed != null ) && ( removed . length > NUM ) ) ) { if ( added != null && longest Line != null ) { int current Max Width = get Line Width ( longest Line ) ; for ( int i = NUM ; i < added . length ; i ++ ) { int width = get Line Width ( added [ i ] ) ; if ( width > current Max Width ) { current Max Width = width ; longest Line = added [ i ] ; } } } if ( removed != null ) { for ( int i = NUM ; i < removed . length ; i ++ ) { if ( removed [ i ] == longest Line ) { longest Line = null ; break ; } } } preference Changed ( null , BOOL , BOOL ) ; host . repaint ( ) ; } else { Element map = get Element ( ) ; int line = map . get Element Index ( changes . get Offset ( ) ) ; int end Line = map . get Element Index ( changes . get Offset ( ) + changes . get Length ( ) ) ; damage Line Range ( line , end Line , a , host ) ; get Longest Line ( ) ; if ( changes . get Type ( ) == Document Event . Event Type . INSERT ) { int w = get Line Width ( longest Line ) ; Element e = map . get Element ( line ) ; if ( e == longest Line ) { preference Changed ( null , BOOL , BOOL ) ; } else if ( get Line Width ( e ) > w ) { longest Line = e ; preference Changed ( null , BOOL , BOOL ) ; } } else if ( changes . get Type ( ) == Document Event . Event Type . REMOVE ) { if ( map . get Element ( line ) == longest Line ) { determine Longest Line ( ) ; preference Changed ( null , BOOL , BOOL ) ; } } } }
public J Class Dependency ( J Class cl , String digest ) { class Name = cl . get Name ( ) ; String new Digest = get Digest ( ) ; if ( ! new Digest . equals ( digest ) ) { if ( log . is Loggable ( Level . FINE ) ) log . fine ( class Name + STRING ) ; is Digest Modified = BOOL ; } }
public void dump ( Object data , Writer output ) { List < Object > list = new Array List < Object > ( NUM ) ; list . add ( data ) ; dump All ( list . iterator ( ) , output , null ) ; }
public void clear ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] array = queue ; int n = size ; size = NUM ; for ( int i = NUM ; i < n ; i ++ ) array [ i ] = null ; } finally { lock . unlock ( ) ; } }
public void reset ( ) { System . arraycopy ( IV , NUM , cbc V , NUM , IV . length ) ; Arrays . fill ( cbc Next V , ( byte ) NUM ) ; cipher . reset ( ) ; }
public void add Insn To Head ( Insn insn ) { Ssa Insn new Insn = Ssa Insn . make From Rop ( insn , this ) ; insns . add ( get Count Phi Insns ( ) , new Insn ) ; parent . on Insn Added ( new Insn ) ; }
public static String encode For URL ( String str ) { String Buffer result = new String Buffer ( ) ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) { char ch = str . char At ( i ) ; if ( ch >= STRING && ch <= STRING || ch >= STRING && ch <= STRING || ch >= STRING && ch <= STRING ) result . append ( ch ) ; else { switch ( ch ) { case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : result . append ( ch ) ; break ; default : result . append ( STRING ) ; result . append ( hexchars [ ( ch & NUM ) > > NUM ] ) ; result . append ( hexchars [ ch & NUM ] ) ; break ; } } } return result . to String ( ) ; }
public void select Object ( Multi Touch Object multi Touch Object , Point Info touch Point ) { curr Touch Point . set ( touch Point ) ; if ( multi Touch Object != null ) { m Images . remove ( multi Touch Object ) ; m Images . add ( multi Touch Object ) ; if ( listener != null ) { listener . on Image Object Selected ( multi Touch Object ) ; } } else { if ( listener != null ) { listener . on Image Object Dropped ( ) ; } } invalidate ( ) ; }
void verify ( ) { byte [ ] d = digest . digest ( ) ; if ( ! Message Digest . is Equal ( d , Base 64 . decode ( hash , Base 64 . DEFAULT ) ) ) { throw invalid Digest ( Jar File . MANIFEST NAME , name , jar Name ) ; } verified Entries . put ( name , certificates ) ; }
public void randomize Incoming Weights ( ) { for ( Neuron n : get Neuron List ( ) ) { for ( Synapse s : n . get Fan In ( ) ) { s . set Lower Bound ( NUM ) ; s . set Strength ( s . get Upper Bound ( ) * Math . random ( ) ) ; } } }
public void remove ( Queue Event event ) throws Keeper Exception , Interrupted Exception { Timer Context time = stats . time ( dir + STRING ) ; try { String path = event . get Id ( ) ; String response Path = dir + STRING + response prefix + path . substring ( path . last Index Of ( STRING ) + NUM ) ; if ( zookeeper . exists ( response Path , BOOL ) ) { zookeeper . set Data ( response Path , event . get Bytes ( ) , BOOL ) ; } else { LOG . info ( STRING + response Path + STRING + STRING ) ; } try { zookeeper . delete ( path , - NUM , BOOL ) ; } catch ( Keeper Exception . No Node Exception ignored ) { } } finally { time . stop ( ) ; } }
public List < Point > read Points ( String shapefile ) { List < Point > list = new Array List < Point > ( ) ; for ( Simple Feature feature : Shape File Reader . get All Features ( shapefile ) ) { Geometry geo = ( Geometry ) feature . get Default Geometry ( ) ; if ( geo instanceof Point ) { Point ps = ( Point ) geo ; for ( int i = NUM ; i < ps . get Num Geometries ( ) ; i ++ ) { Point p = ( Point ) ps . get Geometry N ( i ) ; list . add ( p ) ; } } else { throw new Runtime Exception ( STRING ) ; } } return list ; }
public String rate ( Properties ctx , int Window No , Grid Tab m Tab , Grid Field m Field , Object value ) { if ( value == null ) return STRING ; Integer Currency ID = ( Integer ) m Tab . get Value ( STRING ) ; int C Currency ID = Currency ID . int Value ( ) ; Integer Conversion Type ID = ( Integer ) m Tab . get Value ( STRING ) ; int C Conversion Type ID = Conversion Type ID . int Value ( ) ; Timestamp Date Acct = ( Timestamp ) m Tab . get Value ( STRING ) ; if ( Date Acct == null ) Date Acct = new Timestamp ( System . current Time Millis ( ) ) ; int C Acct Schema ID = Env . get Context As Int ( ctx , Window No , STRING ) ; M Acct Schema as = M Acct Schema . get ( ctx , C Acct Schema ID ) ; int AD Client ID = Env . get Context As Int ( ctx , Window No , STRING ) ; int AD Org ID = Env . get Context As Int ( ctx , Window No , STRING ) ; Big Decimal Currency Rate = M Conversion Rate . get Rate ( C Currency ID , as . get C Currency ID ( ) , Date Acct , C Conversion Type ID , AD Client ID , AD Org ID ) ; log . fine ( STRING + Currency Rate ) ; if ( Currency Rate == null ) Currency Rate = Env . ZERO ; m Tab . set Value ( STRING , Currency Rate ) ; return STRING ; }
public boolean has Alpha Changed From ( float v ) { return ( Float . compare ( alpha , v ) != NUM ) ; }
public Completable Future < Void > destroy ( ) { Completable Future < Void > ret ; if ( controller Proxy != null ) { ret = controller Proxy . destroy ( ) ; controller Proxy = null ; } else { ret = new Completable Future < > ( ) ; ret . complete ( null ) ; } return ret ; }
@ Override public Request < String > logs ( Project Reference project Reference , long task Id ) { List < Dummy Runner Status > statuses = available Runner Statuses . get ( project Reference . name ( ) ) ; if ( statuses != null && ! statuses . is Empty ( ) ) { for ( Dummy Runner Status runner Status : statuses ) { if ( task Id == runner Status . process Id ( ) ) { return new Dummy Request < > ( runner Status . get Log ( ) ) ; } } } return new Dummy Request < > ( null ) ; }
protected static Action Result Info perform Action ( Generic Value product Promo Action , Shopping Cart cart , Delegator delegator , Local Dispatcher dispatcher , Timestamp now Timestamp ) throws Generic Entity Exception , Cart Item Modify Exception { Action Result Info action Result Info = new Action Result Info ( ) ; perform Action ( action Result Info , product Promo Action , cart , delegator , dispatcher , now Timestamp ) ; return action Result Info ; }
private boolean contains Expression ( String to Search , String expression ) { if ( to Search == null ) { return BOOL ; } return to Search . equals ( expression ) || to Search . index Of ( expression ) >= NUM ; }
public void clear Listeners ( ) { listeners . clear ( ) ; }
private Var add Property ( Var Property property ) { if ( property . is Unique ( ) ) { test Unique Property ( ( Unique Var Property ) property ) ; } properties . add ( property ) ; return this ; }
public boolean is Open ( ) { return open . get ( ) ; }
public void free ( long pos , int length ) { int start = get Block ( pos ) ; int blocks = get Block Count ( length ) ; set . clear ( start , start + blocks ) ; }
private void on Connection Status Changed ( int old Status , int status ) { if ( s Settings Mgr . show Status Icon ) { Notification Compat . Builder builder = new Notification Compat . Builder ( this ) ; builder . set When ( System . current Time Millis ( ) ) ; switch ( status ) { case Xmpp Manager . CONNECTED : builder . set Content Text ( get String ( R . string . main service connected , get Connection Status Action ( ) ) ) ; builder . set Small Icon ( get Image Status ( STATUS ICON GREEN ) ) ; break ; case Xmpp Manager . CONNECTING : builder . set Content Text ( get String ( R . string . main service connecting ) ) ; builder . set Small Icon ( get Image Status ( STATUS ICON ORANGE ) ) ; break ; case Xmpp Manager . DISCONNECTED : builder . set Content Text ( get String ( R . string . main service disconnected ) ) ; builder . set Small Icon ( get Image Status ( STATUS ICON RED ) ) ; break ; case Xmpp Manager . DISCONNECTING : builder . set Content Text ( get String ( R . string . main service disconnecting ) ) ; builder . set Small Icon ( get Image Status ( STATUS ICON ORANGE ) ) ; break ; case Xmpp Manager . WAITING TO CONNECT : case Xmpp Manager . WAITING FOR NETWORK : builder . set Content Text ( get String ( R . string . main service waiting to connect ) + STRING + get Connection Status Action ( ) ) ; builder . set Small Icon ( get Image Status ( STATUS ICON BLUE ) ) ; break ; default : return ; } builder . set Content Intent ( s Pending Intent Launch Application ) ; builder . set Content Title ( Tools . APP NAME ) ; start Foreground ( NOTIFICATION CONNECTION , builder . get Notification ( ) ) ; } }
private static File find Guacamole Home ( ) { File guac Home ; String desired Dir = System . get Property ( STRING ) ; if ( desired Dir == null ) desired Dir = System . getenv ( STRING ) ; if ( desired Dir != null ) guac Home = new File ( desired Dir ) ; else guac Home = new File ( System . get Property ( STRING ) , STRING ) ; return guac Home ; }
void wait For Server Start ( ) throws Interrupted Exception { started . await ( get Test Timeout ( ) , Time Unit . MILLISECONDS ) ; }
private static void draw Left Tab ( int x , int y , int w , int h , Graphics 2 D g2 , Color UI Resource color ) { double r Top = Rapid Look And Feel . CORNER TAB RADIUS * NUM ; g2 . set Color ( color ) ; g2 . fill ( create Left Tab Shape ( x + NUM , y + NUM , w - NUM , h , r Top , BOOL ) ) ; g2 . set Color ( Colors . TAB BORDER ) ; g2 . draw ( create Left Tab Shape ( x , y , w - NUM , h , r Top , BOOL ) ) ; }
private List < int [ ] > prepare Expected Data ( ) { List < int [ ] > index List = new Array List < > ( NUM ) ; int [ ] sort Index = { NUM , NUM , NUM , NUM , NUM } ; int [ ] sort Index Inverted = { NUM , NUM , NUM , NUM , NUM } ; index List . add ( NUM , sort Index ) ; index List . add ( NUM , sort Index Inverted ) ; return index List ; }
public byte [ ] read Bytes ( final int count ) { int bytes To Read = count ; if ( bytes To Read < NUM ) bytes To Read = byte Stream . available ( ) ; byte [ ] bytes = new byte [ bytes To Read ] ; if ( current Bit Index >= NUM ) { for ( int i = NUM ; i < bytes To Read ; i ++ ) { bytes [ i ] = ( byte ) read ( Byte . SIZE ) ; } } else { byte Stream . read ( bytes , NUM , bytes . length ) ; } return bytes ; }
public SSL Test Config ( ) { this ( BOOL , BOOL ) ; }
@ Override public int hash Code ( ) { return NUM + Arrays . hash Code ( fields ) ; }
public static String format Path ( List < Child Number > path ) { return PATH JOINER . join ( Iterables . concat ( Collections . singleton ( STRING ) , path ) ) ; }
private void write Attribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( xml Writer . get Prefix ( namespace ) == null ) { xml Writer . write Namespace ( prefix , namespace ) ; xml Writer . set Prefix ( prefix , namespace ) ; } xml Writer . write Attribute ( namespace , att Name , att Value ) ; }
public static Object read Invocation Result ( Platform Context ctx , Binary Raw Reader Ex reader ) throws Ignite Checked Exception { boolean success = reader . read Boolean ( ) ; if ( success ) return reader . read Object Detached ( ) ; else { boolean has Exception = reader . read Boolean ( ) ; if ( has Exception ) { Object native Err = reader . read Object Detached ( ) ; assert native Err != null ; throw ctx . create Native Exception ( native Err ) ; } else { String err Msg = reader . read String ( ) ; assert err Msg != null ; throw new Ignite Checked Exception ( err Msg ) ; } } }
public final void test Generate Seedint 02 ( ) { for ( int i = NUM ; i < LENGTH ; i ++ ) { byte [ ] my Bytes = sr . generate Seed ( i ) ; assert False ( STRING + i + STRING + my Bytes . length , my Bytes . length != i ) ; } }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return STRING THING ; case NUM : return BYTE THING ; case NUM : return I32 THING ; case NUM : return I64 THING ; default : return null ; } }
private List < String > replace Dot In Mustache Keys ( final List < String > mustache Keys ) { final List < String > fixed Mustache Keys = new Array List < > ( ) ; for ( String mustache Key : mustache Keys ) { fixed Mustache Keys . add ( mustache Key . replace ( STRING , STRING ) ) ; } return fixed Mustache Keys ; }
public static I Fits Header create ( String key ) { I Fits Header result = STANDARD KEYS . get ( key ) ; if ( result == null ) { result = new Fits Header Impl ( key , SOURCE . UNKNOWN , HDU . ANY , VALUE . ANY , STRING ) ; } return result ; }
protected String parse Payload ( String payload ) { String json = null ; if ( payload != null ) { try { json = ( payload . index Of ( STRING ) == - NUM ) ? new String ( Files . read All Bytes ( Paths . get ( payload ) ) ) : payload ; } catch ( IO Exception e ) { log . fatal ( STRING + payload , e ) ; System . exit ( NUM ) ; } } return json ; }
boolean add Entry ( Policy Entry pe , int index ) { if ( index < NUM ) { policy Entries . add Element ( pe ) ; parser . add ( pe . get Grant Entry ( ) ) ; } else { Policy Entry orig Pe = policy Entries . element At ( index ) ; parser . replace ( orig Pe . get Grant Entry ( ) , pe . get Grant Entry ( ) ) ; policy Entries . set Element At ( pe , index ) ; } return BOOL ; }
public Writable Raster create Compatible Writable Raster ( int w , int h ) { if ( w <= NUM || h <= NUM ) { throw new Raster Format Exception ( STRING + ( ( w <= NUM ) ? STRING : STRING ) ) ; } Sample Model sm = sample Model . create Compatible Sample Model ( w , h ) ; return new Integer Component Raster ( sm , new Point ( NUM , NUM ) ) ; }
public void test Case 1 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( NUM , result . signum ( ) ) ; }
public static void create Or Clear Destination Folder ( String path ) { File fpath = new File ( path ) ; fpath . mkdirs ( ) ; delete Directory Contents ( path , BOOL ) ; }
static synchronized Jmri User Interface Configuration Provider find Provider ( Profile project ) { if ( providers . get ( project ) == null ) { providers . put ( project , new Jmri User Interface Configuration Provider ( project ) ) ; } return providers . get ( project ) ; }
protected static long [ ] insert ( long [ ] old , int old Size , int pos , long x ) { long [ ] result ; if ( old != null && old . length > old Size ) { result = old ; } else { result = new long [ old Size + NUM + COPY THRESHOLD ] ; if ( pos > NUM ) { System . arraycopy ( old , NUM , result , NUM , pos ) ; } } if ( old != null && old Size - pos > NUM ) { System . arraycopy ( old , pos , result , pos + NUM , old Size - pos ) ; } result [ pos ] = x ; return result ; }
private void register Object Read ( Object obj , int handle , boolean unshared ) throws IO Exception { if ( unshared ) { obj = UNSHARED OBJ ; } int index = handle - Object Stream Constants . base Wire Handle ; int size = objects Read . size ( ) ; while ( index > size ) { objects Read . add ( null ) ; ++ size ; } if ( index == size ) { objects Read . add ( obj ) ; } else { objects Read . set ( index , obj ) ; } }
private boolean discard Upstream Media Chunks ( int queue Length ) { if ( media Chunks . size ( ) <= queue Length ) { return BOOL ; } long start Time Us = NUM ; long end Time Us = media Chunks . get Last ( ) . end Time Us ; Base Media Chunk removed = null ; while ( media Chunks . size ( ) > queue Length ) { removed = media Chunks . remove Last ( ) ; start Time Us = removed . start Time Us ; loading Finished = BOOL ; } sample Queue . discard Upstream Samples ( removed . get First Sample Index ( ) ) ; notify Upstream Discarded ( start Time Us , end Time Us ) ; return BOOL ; }
public void close ( ) { animation . set Rate ( - NUM ) ; animation . play ( ) ; animation . set On Finished ( null ) ; }
Map < String , Set < Call Location Model > > compute Filtered Taint Sources Map ( Set < Call Location Model > sources ) { if ( ! sources . is Empty ( ) ) { if ( f Filtered Taint Sources Map != null && ! f Filtered Taint Sources Map . is Empty ( ) ) { Map < String , Set < Call Location Model > > result = new Tree Map < String , Set < Call Location Model > > ( ) ; for ( Entry < String , Set < Call Location Model > > entry : f Filtered Taint Sources Map . entry Set ( ) ) { Set < Call Location Model > filtered Sources = new Tree Set < Call Location Model > ( ) ; for ( Call Location Model source : entry . get Value ( ) ) { if ( sources . contains ( source ) ) { filtered Sources . add ( source ) ; } } if ( ! filtered Sources . is Empty ( ) ) { String taint Kind = entry . get Key ( ) ; result . put ( taint Kind , filtered Sources ) ; } } return result ; } } return Collections . EMPTY MAP ; }
public static boolean contains ( String s , Property expected ) { if ( s == null || s . length ( ) == NUM ) { return BOOL ; } int i = NUM ; while ( i < s . length ( ) ) { int codepoint = Character . code Point At ( s , i ) ; Emoji e = map . get ( codepoint ) ; if ( e == null ) { return BOOL ; } if ( ! e . is ( expected ) ) { return BOOL ; } i += codepoint >= NUM ? NUM : NUM ; } return BOOL ; }
public Class to Class ( String codebase ) throws IO Exception , Class Not Found Exception { if ( name . char At ( NUM ) != STRING ) { return Class Loading . load Class ( codebase , name , null , integrity , null ) ; } String Tokenizer st = new String Tokenizer ( name , STRING ) ; String [ ] ifs = new String [ st . count Tokens ( ) ] ; for ( int i = NUM ; i < ifs . length ; i ++ ) { ifs [ i ] = st . next Token ( ) ; } return Class Loading . load Proxy Class ( codebase , ifs , null , integrity , null ) ; }
private synchronized I Mqtt Token remove Mqtt Token ( Bundle data ) { String activity Token = data . get String ( Mqtt Service Constants . CALLBACK ACTIVITY TOKEN ) ; if ( activity Token != null ) { int token Number = Integer . parse Int ( activity Token ) ; I Mqtt Token token = token Map . get ( token Number ) ; token Map . delete ( token Number ) ; return token ; } return null ; }
public static < T > Optional < T > lowest Common Ancestor ( Tree Def . Parented < T > tree Def , List < T > nodes ) { if ( nodes . size ( ) == NUM ) { return Optional . empty ( ) ; } else { Optional < T > so Far = Optional . of ( nodes . get ( NUM ) ) ; for ( int i = NUM ; i < nodes . size ( ) && so Far . is Present ( ) ; ++ i ) { so Far = lowest Common Ancestor ( tree Def , so Far . get ( ) , nodes . get ( i ) ) ; } return so Far ; } }
public void copy Value Nodes To Me ( Entity from ) { for ( Value Node from Child : from . get Children ( Value Node . class ) ) { Value Node to Child = get Child ( from Child . get Name ( ) , Value Node . class ) ; to Child . set Value ( from Child . get Value ( ) ) ; } }
public static World Icon Image from Pixel Transparency ( Buffered Image image ) { int image Margin Top = find First Solid Pixel From Top ( image ) ; int image Margin Bottom = find First Solid Pixel From Bottom ( image ) ; int frame Height = Math . max ( NUM , image . get Height ( ) - image Margin Top - image Margin Bottom ) ; return new World Icon Image ( image , NUM , image Margin Top , image . get Width ( ) , frame Height ) ; }
private Map < String , String > check Vip Diff ( Property Info Ext local Props , Property Info Rest Rep rep ) { String vip Addr V 4 = rep . get Property ( STRING ) ; String vip Addr V 6 = rep . get Property ( STRING ) ; Map < String , String > diff Props = new Hash Map < String , String > ( ) ; if ( ! vip Addr V 4 . equals ( local Props . get Property ( STRING ) ) ) { diff Props . put ( STRING , vip Addr V 4 ) ; log . warn ( STRING , vip Addr V 4 , local Props . get Property ( STRING ) ) ; } if ( ! vip Addr V 6 . equals ( local Props . get Property ( STRING ) ) ) { diff Props . put ( STRING , vip Addr V 6 ) ; log . warn ( STRING , vip Addr V 6 , local Props . get Property ( STRING ) ) ; } return diff Props ; }
private static double distance Sq ( Color a , Color b ) { double r Mean = ( a . get Red ( ) + b . get Red ( ) ) / NUM / NUM ; double dr = ( a . get Red ( ) - b . get Red ( ) ) / NUM ; double dg = ( a . get Green ( ) - b . get Green ( ) ) / NUM ; double db = ( a . get Blue ( ) - b . get Blue ( ) ) / NUM ; double d = ( NUM + r Mean ) * dr * dr + NUM * dg * dg + ( NUM + NUM - r Mean ) * db * db ; return d / NUM ; }
@ Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case S Graph Package . SPECIFICATION ELEMENT SPECIFICATION : return SPECIFICATION EDEFAULT == null ? specification != null : ! SPECIFICATION EDEFAULT . equals ( specification ) ; } return super . e Is Set ( feature ID ) ; }
private static Application Type new Type ( final String name ) throws Illegal Access Exception , Instantiation Exception { return new Application Type ( name , new Hash Map < String , Boolean > ( TYPE ACTIONS ) , Dumb Search Index . class , Dumb Save Index . class , Dumb Resource Name . class ) ; }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; if ( bayes Im == null ) { throw new Null Pointer Exception ( ) ; } }
public int compare ( Source File o1 , Source File o2 ) { String n1 = o1 . get Name ( ) ; String n2 = o2 . get Name ( ) ; return n1 . compare To ( n2 ) ; }
protected boolean process Dynamic Property Nodes ( Node parent , Dynamic Property property , Model model ) { Collection nodes = parent . get Children ( ) ; String name = property . get Name ( ) ; String state = property . get State Name ( ) ; CDATA Node cdata = get Text Content ( nodes , BOOL ) ; if ( cdata != null ) { return process Dynamic Property Text ( name , cdata . image , Text Origin . from Child ( cdata . in CDATA ) , cdata . begin Line , model , state ) ; } else { if ( ( state == null ) && model . has Property ( name ) ) { log ( parent , new Multiple Property Initializer Error ( name ) ) ; } Object rvalue = process R Value Nodes ( property , nodes , model ) ; if ( rvalue != null ) { model . set Dynamic Property ( type Table . object Type , name , rvalue , state , parent . begin Line ) ; return BOOL ; } else { return BOOL ; } } }
private static < T extends Psi Element > boolean process Children Of Type ( Psi Element element , Processor < T > processor , Class < T > psi Class , boolean reverse Order ) { Psi Element child = reverse Order ? element . get Last Child ( ) : element . get First Child ( ) ; while ( child != null ) { if ( psi Class . is Instance ( child ) ) { if ( ! processor . process ( ( T ) child ) ) { return BOOL ; } } if ( process Children Of Type ( child , processor , psi Class , reverse Order ) ) { return BOOL ; } child = reverse Order ? child . get Prev Sibling ( ) : child . get Next Sibling ( ) ; } return BOOL ; }
public Instances generate ( ) throws Exception { return generate ( STRING ) ; }
protected void load Chars ( Abstract MR Reply msg , Data Input Stream istream ) throws IO Exception { int i ; for ( i = NUM ; i < msg . max Size ( ) ; i ++ ) { byte char 1 = read Byte Protected ( istream ) ; if ( flush Receive Chars ) { log . warn ( STRING , msg . to String ( ) ) ; msg . flush ( ) ; i = NUM ; flush Receive Chars = BOOL ; } if ( can Receive ( ) ) { msg . set Element ( i , char 1 ) ; if ( end Of Message ( msg ) ) { break ; } } else { i -- ; log . error ( STRING , Integer . to Hex String ( char 1 ) ) ; } } }
public String evaluate ( Associator associator , Instances data ) throws Exception { long start Time ; long end Time ; start Time = System . current Time Millis ( ) ; associator . build Associations ( data ) ; end Time = System . current Time Millis ( ) ; m Result = new String Buffer ( associator . to String ( ) ) ; m Result . append ( STRING ) ; m Result . append ( STRING + ( ( ( double ) ( end Time - start Time ) ) / NUM ) + STRING ) ; m Result . append ( STRING ) ; return m Result . to String ( ) ; }
public static Integer int Value ( String prop Name , Integer dflt ) { String sys Prop = get Property ( prop Name ) ; return ( sys Prop != null && ! sys Prop . is Empty ( ) ) ? Integer . get Integer ( sys Prop ) : dflt ; }
public NS Number ( int i ) { double Value = long Value = i ; type = INTEGER ; }
private int clamp Mag ( int value , int abs Min , int abs Max ) { final int abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }
private int compare Version Parts ( String version 1 , String version 2 ) { int compare = NUM ; Integer v1 ; Integer v2 ; try { v1 = version 1 != null ? Integer . parse Int ( version 1 ) : NUM ; } catch ( Number Format Exception e ) { v1 = NUM ; } try { v2 = version 2 != null ? Integer . parse Int ( version 2 ) : NUM ; } catch ( Number Format Exception e ) { v2 = NUM ; } if ( v1 > v2 ) { compare = NUM ; } else if ( v1 < v2 ) { compare = - NUM ; } else { compare = NUM ; } return compare ; }
public void pre Save Init ( ) { persistent Data . clear ( ) ; for ( int i = NUM ; i < get Num Points ( ) ; i ++ ) { persistent Data . add ( get Point ( i ) ) ; } }
public void essential ( final Consumer < On Complete > fn ) { this . essential = fn ; if ( done ) { fn . accept ( build On Complete ( ) ) ; } }
public void add Listener ( I Message Listener new Listener ) { synchronized ( listeners ) { listeners . add ( new Listener ) ; } }
public void test Get Type ( ) { assert Equals ( STRING , tbt crl . get Type ( ) , STRING ) ; }
public void add Words ( String phrase ) { if ( phrase . equals ( STRING ) || phrase . equals ( STRING ) ) return ; String [ ] words = spliterator ( phrase ) ; if ( words . length < NUM ) return ; for ( int i = NUM ; i < words . length ; i ++ ) { if ( i == NUM ) { Vector < String > start Words = chain . get ( STRING ) ; start Words . add ( words [ i ] ) ; Vector < String > suffix = chain . get ( words [ i ] ) ; if ( suffix == null ) { suffix = new Vector < > ( ) ; suffix . add ( words [ i + NUM ] ) ; chain . put ( words [ i ] , suffix ) ; } } else if ( i == words . length - NUM ) { Vector < String > end Words = chain . get ( STRING ) ; end Words . add ( words [ i ] ) ; } else { Vector < String > suffix = chain . get ( words [ i ] ) ; if ( suffix == null ) { suffix = new Vector < > ( ) ; suffix . add ( words [ i + NUM ] ) ; chain . put ( words [ i ] , suffix ) ; } else { suffix . add ( words [ i + NUM ] ) ; chain . put ( words [ i ] , suffix ) ; } } } }
@ HLE Unimplemented @ HLE Function ( nid = NUM , version = NUM ) public int sce Net Adhoc Matching Abort Send Data ( @ Check Argument ( STRING ) int matching Id , psp Net Mac Address mac Address ) { return NUM ; }
public Short Buffer put ( short [ ] src , int src Offset , int short Count ) { Arrays . check Offset And Count ( src . length , src Offset , short Count ) ; if ( short Count > remaining ( ) ) { throw new Buffer Overflow Exception ( ) ; } for ( int i = src Offset ; i < src Offset + short Count ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public boolean handle Directory ( File directory ) { if ( DEBUG ) { logger . fine ( STRING + directory . get Absolute Path ( ) ) ; } return BOOL ; }
public static void choose ( int n , int [ ] results ) { int k = results . length ; for ( int i = NUM ; i < k ; i ++ ) { boolean done = BOOL ; while ( ! done ) { results [ i ] = RANDOM . next Int ( n ) ; done = BOOL ; for ( int j = NUM ; j < i ; j ++ ) { if ( results [ j ] == results [ i ] ) { done = BOOL ; } } } } }
public String print Leaf Models Tip Text ( ) { return STRING ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String child Value ; int child Length ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; child Value = child . get Data ( ) ; child Length = child Value . length ( ) ; assert Equals ( STRING , NUM , child Length ) ; }
public Set register Client Interest List ( Object input Client ID , List keys , boolean updates As Invalidates ) { Long client ID = get Client ID For Maps ( input Client ID ) ; Set keys Registered = new Hash Set ( keys ) ; synchronized ( interest List Lock ) { Map < Object , Set > koi = updates As Invalidates ? get Keys Of Interest Inv ( ) : get Keys Of Interest ( ) ; Copy On Write Hash Set interest List = ( Copy On Write Hash Set ) koi . get ( client ID ) ; if ( interest List == null ) { interest List = new Copy On Write Hash Set ( ) ; koi . put ( client ID , interest List ) ; } else { keys Registered . remove All ( interest List . get Snapshot ( ) ) ; } interest List . add All ( keys ) ; if ( this . region != null && this . is Local Profile ) { send Profile Operation ( client ID , operation Type . REGISTER KEYS , keys , updates As Invalidates ) ; } } return keys Registered ; }
public static String replace ( String in String , String old Pattern , String new Pattern ) { if ( ! has Length ( in String ) || ! has Length ( old Pattern ) || new Pattern == null ) { return in String ; } String Builder sb = new String Builder ( ) ; int pos = NUM ; int index = in String . index Of ( old Pattern ) ; int pat Len = old Pattern . length ( ) ; while ( index >= NUM ) { sb . append ( in String . substring ( pos , index ) ) ; sb . append ( new Pattern ) ; pos = index + pat Len ; index = in String . index Of ( old Pattern , pos ) ; } sb . append ( in String . substring ( pos ) ) ; return sb . to String ( ) ; }
public static List < String > to Path Parts ( String encoded Path ) { if ( encoded Path == null || encoded Path . length ( ) == NUM ) { return null ; } List < String > result = new Array List < String > ( ) ; int cur = NUM ; boolean not Done = BOOL ; while ( not Done ) { int slash = encoded Path . index Of ( STRING , cur ) ; not Done = slash != - NUM ; String sub ; if ( not Done ) { sub = encoded Path . substring ( cur , slash ) ; } else { sub = encoded Path . substring ( cur ) ; } result . add ( Char Escapers . decode Uri ( sub ) ) ; cur = slash + NUM ; } return result ; }
@ Suppress Warnings ( STRING ) public < T extends Point 2 D > T inverse ( double x , double y , T ret val ) { if ( ret val == null ) { ret val = ( T ) new Lat Lon Point . Double ( ) ; } double px = x + ul . x ; double py = - y + ul . y + oy ; if ( px > Proj Math . round Adjust ( world . x / NUM ) ) { px = Proj Math . round Adjust ( world . x / NUM ) ; } else if ( px < Proj Math . round Adjust ( - world . x / NUM ) ) { px = Proj Math . round Adjust ( - world . x / NUM ) ; } if ( py > Proj Math . round Adjust ( world . y / NUM ) ) { py = Proj Math . round Adjust ( world . y / NUM ) ; } else if ( py < Proj Math . round Adjust ( - world . y / NUM ) ) { py = Proj Math . round Adjust ( - world . y / NUM ) ; } double lat = normalize Latitude ( py / spps y ) ; double lon = wrap Longitude ( ( px / spps x ) + center X ) ; ret val . set Location ( Math . to Degrees ( lon ) , Math . to Degrees ( lat ) ) ; return ret val ; }
public void install ( J Editor Pane c ) { c . add Caret Listener ( input Attribute Updater ) ; c . add Property Change Listener ( input Attribute Updater ) ; Caret caret = c . get Caret ( ) ; if ( caret != null ) { input Attribute Updater . update Input Attributes ( caret . get Dot ( ) , caret . get Mark ( ) , c ) ; } }
static public M Print Format create From Report View ( Properties ctx , int AD Report View ID , String Report Name ) { int AD Client ID = Env . get AD Client ID ( ctx ) ; s log . info ( STRING + AD Report View ID + STRING + AD Client ID + STRING + Report Name ) ; M Print Format pf = new M Print Format ( ctx , NUM , null ) ; pf . set AD Report View ID ( AD Report View ID ) ; String sql = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; boolean error = BOOL ; try { pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM , AD Report View ID ) ; pstmt . set Int ( NUM , AD Client ID ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { String name = Report Name ; if ( name == null || name . length ( ) == NUM ) name = rs . get String ( NUM ) ; int count = rs . get Int ( NUM ) ; if ( count > NUM ) name += STRING + count ; pf . set Name ( name ) ; pf . set AD Print Color ID ( rs . get Int ( NUM ) ) ; pf . set AD Print Font ID ( rs . get Int ( NUM ) ) ; pf . set AD Print Paper ID ( rs . get Int ( NUM ) ) ; pf . set AD Table ID ( rs . get Int ( NUM ) ) ; error = BOOL ; } else s log . log ( Level . SEVERE , STRING + AD Report View ID ) ; } catch ( SQL Exception e ) { s log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( error ) return null ; if ( ! pf . save ( ) ) return null ; pf . set Items ( create Items ( ctx , pf ) ) ; return pf ; }
private boolean compare And Increment Worker Count ( int expect ) { return ctl . compare And Set ( expect , expect + NUM ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; Enumeration < Option > enm = super . list Options ( ) ; while ( enm . has More Elements ( ) ) result . add ( enm . next Element ( ) ) ; result . add Element ( new Option ( STRING + stopwords Tip Text ( ) + STRING + STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
private void enable Operation Buttons ( ) { btn Or . set Enabled ( BOOL ) ; btn And . set Enabled ( BOOL ) ; btn Right Paren . set Enabled ( BOOL ) ; }
private double compute Modifier Unbounded ( final double x ) { return exp Multiplier * Math . exp ( - x * x / exp Member ) ; }
@ Override public boolean on Unit ( Graphics g , int x , int y , int w , int h ) { Font Metrics fm = g . get Font Metrics ( ) ; int l = ( int ) ( m x * w ) - fm . string Width ( m id ) / NUM ; int t = ( int ) ( m y * h ) - fm . get Height ( ) / NUM ; if ( x < l || x > l + fm . string Width ( m id ) + NUM || y < t || y > t + fm . get Height ( ) + fm . get Descent ( ) + NUM ) { return BOOL ; } return BOOL ; }
public static Integer to Integer ( String str ) { try { return Integer . value Of ( str ) ; } catch ( Exception ex ) { return null ; } }
private static void fill With Empty Rows ( Data Table data , int count ) { while ( data . get Row Count ( ) < count ) { Double [ ] empty Row = new Double [ data . get Column Count ( ) ] ; Arrays . fill ( empty Row , NUM ) ; data . add ( empty Row ) ; } }
public void test Division Knuth 1 ( ) { byte a Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { - NUM , - NUM , - NUM , - NUM } ; int a Sign = NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , - NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . divide ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public Fragmented Handshake Message ( byte [ ] fragmented Bytes , Handshake Type type , int fragment Offset , int message Length , Inet Socket Address peer Address ) { super ( peer Address ) ; this . type = type ; this . message Length = message Length ; this . fragmented Bytes = Arrays . copy Of ( fragmented Bytes , fragmented Bytes . length ) ; set Fragment Offset ( fragment Offset ) ; set Fragment Length ( fragmented Bytes . length ) ; }
private static void delete Retry Counter ( Weak Reference < Context > weak Context , String filename , int max Retry Attempts ) { Context context = null ; if ( weak Context != null ) { context = weak Context . get ( ) ; if ( context != null ) { Shared Preferences preferences = context . get Shared Preferences ( ARTISAN SDK , Context . MODE PRIVATE ) ; Shared Preferences . Editor editor = preferences . edit ( ) ; editor . remove ( STRING + filename ) ; editor . apply ( ) ; } } }
private void initialize Sparse Slider ( ) { connection Density Slider . set Major Tick Spacing ( NUM ) ; connection Density Slider . set Minor Tick Spacing ( NUM ) ; connection Density Slider . set Paint Ticks ( BOOL ) ; Hashtable < Integer , J Label > label Table 2 = new Hashtable < Integer , J Label > ( ) ; label Table 2 . put ( new Integer ( NUM ) , new J Label ( STRING ) ) ; label Table 2 . put ( new Integer ( NUM ) , new J Label ( STRING ) ) ; connection Density Slider . set Label Table ( label Table 2 ) ; connection Density Slider . set Paint Labels ( BOOL ) ; }
protected void update Tree ( Document Event event ) { updating Selection = BOOL ; try { Tree Model model = get Tree Model ( ) ; Object root = model . get Root ( ) ; for ( int counter = model . get Child Count ( root ) - NUM ; counter >= NUM ; counter -- ) { update Tree ( event , ( Element ) model . get Child ( root , counter ) ) ; } } finally { updating Selection = BOOL ; } }
private static Shape bottom Edge ( Buffered Image image , General Path path , int start ) { int lastj = NUM ; Point 2 D p1 = path . get Current Point ( ) ; Point 2 D p2 = null ; Line 2 D line = new Line 2 D . Float ( ) ; for ( int i = start ; i < image . get Width ( ) ; i += sample ) { boolean a Point Exists On This Line = BOOL ; for ( int j = image . get Height ( ) - NUM ; j >= NUM ; j -= sample ) { if ( ( image . get RGB ( i , j ) & NUM ) != NUM ) { Point 2 D p = new Point 2 D . Float ( i , j ) ; a Point Exists On This Line = BOOL ; p2 = detect Line ( p1 , p2 , p , line , path ) ; lastj = j ; break ; } } if ( a Point Exists On This Line == BOOL ) { break ; } } return right Edge ( image , path , lastj ) ; }
@ Override public void close ( ) throws IO Exception { if ( logger != null ) { logger . println ( STRING + socket was closed ) ; } if ( ! socket was closed ) { if ( handshake started ) { alert Protocol . alert ( Alert Protocol . WARNING , Alert Protocol . CLOSE NOTIFY ) ; try { output . write ( alert Protocol . wrap ( ) ) ; } catch ( IO Exception ex ) { } alert Protocol . set Processed ( ) ; } shutdown ( ) ; close Transport Layer ( ) ; socket was closed = BOOL ; } }
@ Form Url Encoded @ POST ( STRING ) Call < Authentication Response > authorize ( @ Field Map Map < String , String > auth Map ) ;
private boolean repeating Preview ( Object tag ) { try { Capture Request . Builder builder = m Device . create Capture Request ( Camera Device . TEMPLATE PREVIEW ) ; builder . add Target ( m Preview Surface ) ; builder . set ( Capture Request . CONTROL MODE , Camera Metadata . CONTROL MODE AUTO ) ; add Baseline Capture Keys To Request ( builder ) ; m Capture Session . set Repeating Request ( builder . build ( ) , m Capture Callback , m Camera Handler ) ; Log . v ( TAG , String . format ( STRING , m Zoom Value ) ) ; return BOOL ; } catch ( Camera Access Exception ex ) { Log . e ( TAG , STRING , ex ) ; return BOOL ; } }
private XML Element new Element ( String name , String value , Array List attributes ) throws Exception { return new Element ( name , value , attributes , BOOL ) ; }
public void mouse Pressed ( Mouse Event e ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + ( e . get Modifiers ( ) & Mouse Event . BUTTON 1 MASK ) + STRING + e . is Popup Trigger ( ) + STRING + ( e . get Modifiers ( ) & ( Mouse Event . ALT MASK + Mouse Event . META MASK + Mouse Event . CTRL MASK ) ) + ( STRING + Mouse Event . ALT MASK + STRING + Mouse Event . META MASK + STRING + Mouse Event . CTRL MASK ) ) ; } if ( e . is Popup Trigger ( ) && parent Frame . is Selected ( ) ) { try { menu . show ( e . get Component ( ) , e . get X ( ) , e . get Y ( ) ) ; } catch ( java . awt . Illegal Component State Exception cs ) { } e . consume ( ) ; } }
public void define Fill Style ( Color [ ] colors , int [ ] ratios , Transform matrix , boolean radial ) { Gradient Fill fill = new Gradient Fill ( colors , ratios , matrix , radial ) ; elements . add ( fill ) ; for ( int i = NUM ; i < colors . length ; i ++ ) { if ( colors [ i ] == null ) { continue ; } if ( colors [ i ] instanceof Alpha Color ) { has Alpha = BOOL ; } } }
public boolean is Orphan ( Sha 256 Hash block ) { lock . lock ( ) ; try { return orphan Blocks . contains Key ( block ) ; } finally { lock . unlock ( ) ; } }
protected Boolean Val ( boolean b ) { this . b = b ; }
private void relocate From Headers ( Byte Buffer f , Sce Module module , int base Address , Elf 32 elf , int elf Offset ) throws IO Exception { int i = NUM ; for ( Elf 32 Program Header phdr : elf . get Program Header List ( ) ) { if ( phdr . get P type ( ) == NUM ) { int Rel Count = phdr . get P filesz ( ) / Elf 32 Relocate . sizeof ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( String . format ( STRING , i , Rel Count ) ) ; } f . position ( elf Offset + phdr . get P offset ( ) ) ; relocate From Buffer ( f , module , base Address , elf , Rel Count , BOOL ) ; return ; } else if ( phdr . get P type ( ) == NUM ) { if ( log . is Debug Enabled ( ) ) { log . debug ( String . format ( STRING , i , phdr . get P filesz ( ) ) ) ; } f . position ( elf Offset + phdr . get P offset ( ) ) ; relocate From Buffer A 1 ( f , elf , base Address , i , phdr . get P filesz ( ) ) ; return ; } i ++ ; } for ( Elf 32 Section Header shdr : elf . get Section Header List ( ) ) { if ( must Relocate ( elf , shdr ) ) { int Rel Count = shdr . get Sh size ( ) / Elf 32 Relocate . sizeof ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( shdr . get Sh namez ( ) + STRING + Rel Count + STRING ) ; } f . position ( elf Offset + shdr . get Sh offset ( ) ) ; relocate From Buffer ( f , module , base Address , elf , Rel Count , shdr . get Sh type ( ) != Elf 32 Section Header . SHT REL ) ; } } }
public List < Volume > validate Volumes ( Storage System storage System , List < Volume > volumes , boolean delete , boolean remediate , Val Ck ... checks ) { try { client = V Plex Controller Utils . get V Plex API Client ( V Plex Api Factory . get Instance ( ) , storage System , get Db Client ( ) ) ; for ( Volume volume : volumes ) { try { log . info ( String . format ( STRING , volume . get Label ( ) , volume . get Native Id ( ) , volume . get Id ( ) , checks . to String ( ) ) ) ; validate Volume ( volume , delete , remediate , checks ) ; } catch ( Exception ex ) { log . error ( STRING + volume . get Id ( ) , ex ) ; } } } catch ( Exception ex ) { log . error ( STRING + storage System . get Id ( ) , ex ) ; } return remediated Volumes ; }
private void draw X Axis Marker ( Canvas canvas , double value , Number Format number Format , int spacing ) { String marker = chart By Distance ? number Format . format ( value ) : String Utils . format Elapsed Time ( ( long ) value ) ; Rect rect = get Rect ( x Axis Marker Paint , marker ) ; canvas . draw Text ( marker , get X ( value ) , top Border + effective Height + spacing + rect . height ( ) , x Axis Marker Paint ) ; }
public static < E > Array List < E > list ( E ... elements ) { Array List < E > list = new Array List < E > ( ) ; for ( E element : elements ) list . add ( element ) ; return list ; }
public static String encode ( Array List < Geo Point > polyline , int precision ) { String Builder encoded Points = new String Builder ( ) ; int prev lat = NUM , prev lng = NUM ; for ( Geo Point trackpoint : polyline ) { int lat = trackpoint . get Latitude E 6 ( ) / precision ; int lng = trackpoint . get Longitude E 6 ( ) / precision ; encoded Points . append ( encode Signed Number ( lat - prev lat ) ) ; encoded Points . append ( encode Signed Number ( lng - prev lng ) ) ; prev lat = lat ; prev lng = lng ; } return encoded Points . to String ( ) ; }
private static boolean is Text Obscured ( J Component c , String s ) { Graphics g = c . get Graphics ( ) ; Font Metrics fm = g . get Font Metrics ( c . get Font ( ) ) ; int sw = fm . string Width ( s ) ; return ( sw > c . get Width ( ) ) ; }
public void add ( Permission permission ) { perms . put ( permission , permission ) ; }
@ Override public Set < Statement > sum ( final IGAS State < Set < Statement > , Set < Statement > , Set < Statement > > state , final Set < Statement > left , final Set < Statement > right ) { final Set < Statement > tmp = new Linked Hash Set < Statement > ( left ) ; tmp . add All ( right ) ; return tmp ; }
public static int prefix Length ( char [ ] s1 , char [ ] s2 ) { int len = NUM ; int max = Math . min ( s1 . length , s2 . length ) ; for ( int i = NUM ; i < max && s1 [ i ] == s2 [ i ] ; ++ i ) ++ len ; return len ; }
public void test All Connected Broker Network ( ) throws Exception { bridge Brokers ( STRING , STRING ) ; bridge Brokers ( STRING , STRING ) ; bridge Brokers ( STRING , STRING ) ; bridge Brokers ( STRING , STRING ) ; bridge Brokers ( STRING , STRING ) ; bridge Brokers ( STRING , STRING ) ; start All Brokers ( ) ; Destination dest = create Destination ( STRING , BOOL ) ; Message Consumer client A = create Consumer ( STRING , dest ) ; Message Consumer client B = create Consumer ( STRING , dest ) ; Message Consumer client C = create Consumer ( STRING , dest ) ; Thread . sleep ( NUM ) ; send Messages ( STRING , dest , MESSAGE COUNT ) ; send Messages ( STRING , dest , MESSAGE COUNT ) ; send Messages ( STRING , dest , MESSAGE COUNT ) ; Message Id List msgs A = get Consumer Messages ( STRING , client A ) ; Message Id List msgs B = get Consumer Messages ( STRING , client B ) ; Message Id List msgs C = get Consumer Messages ( STRING , client C ) ; msgs A . wait For Messages To Arrive ( MESSAGE COUNT * NUM ) ; msgs B . wait For Messages To Arrive ( MESSAGE COUNT * NUM ) ; msgs C . wait For Messages To Arrive ( MESSAGE COUNT * NUM ) ; assert Equals ( MESSAGE COUNT * NUM , msgs A . get Message Count ( ) ) ; assert Equals ( MESSAGE COUNT * NUM , msgs B . get Message Count ( ) ) ; assert Equals ( MESSAGE COUNT * NUM , msgs C . get Message Count ( ) ) ; }
private int encrypted Column Length ( int col Length ) { String str = STRING ; for ( int i = NUM ; i < col Length ; i ++ ) { str += STRING ; } str = Secure Engine . encrypt ( str ) ; return str . length ( ) ; }
private Cn A Tree Element unify Links ( Cn A Tree Element source Element , Cn A Tree Element destination Element ) throws Command Exception { for ( Cn A Link link Down : source Element . get Links Down ( ) ) { create Link ( destination Element , link Down . get Dependency ( ) , link Down . get Relation Id ( ) ) ; } for ( Cn A Link link Up : source Element . get Links Up ( ) ) { create Link ( link Up . get Dependant ( ) , destination Element , link Up . get Relation Id ( ) ) ; } return destination Element ; }
private boolean flush Accumulated Region ( ) { boolean success = BOOL ; if ( accumulated X != Integer . MAX VALUE ) { Sub Region Showable bs Sub Region = ( Sub Region Showable ) buffer Strategy ; boolean contents Lost = buffer Strategy . contents Lost ( ) ; if ( ! contents Lost ) { bs Sub Region . show ( accumulated X , accumulated Y , accumulated Max X , accumulated Max Y ) ; contents Lost = buffer Strategy . contents Lost ( ) ; } if ( contents Lost ) { if ( LOGGER . is Loggable ( Platform Logger . Level . FINER ) ) { LOGGER . finer ( STRING ) ; } buffer Info . set In Sync ( BOOL ) ; success = BOOL ; } } reset Accumulated ( ) ; return success ; }
public void test Bit Length Positive 1 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; assert Equals ( NUM , a Number . bit Length ( ) ) ; }
public void clear Pie Segments ( ) { m Pie Segment List . clear ( ) ; }
@ Override public Patch Result apply Patch ( Patch Data patch Data ) { String type Name = patch Data . get Type Name ( ) ; String apply Version = patch Data . get Apply To Version ( ) ; Types Def updated Type Def ; Patch Result result ; try { if ( check If Type Exists ( type Name , metadata Service ) ) { Types Def types Def = get Type Def ( type Name ) ; String current Version = get Type Version ( type Name ) ; if ( current Version == null || current Version . equals Ignore Case ( apply Version ) || current Version . starts With ( apply Version + STRING ) ) { updated Type Def = update Types Def ( types Def , patch Data ) ; if ( updated Type Def != null ) { metadata Service . update Type ( Types Serialization . to Json ( updated Type Def ) ) ; LOG . info ( STRING + patch Data . get Type Name ( ) + STRING + patch Data . get Apply To Version ( ) + STRING + patch Data . get Update To Version ( ) ) ; result = new Patch Result ( STRING , Patch Status . SUCCESS ) ; } else { LOG . error ( STRING + type Name + STRING + apply Version + STRING + patch Data . get Update To Version ( ) ) ; result = new Patch Result ( STRING , Patch Status . FAILED ) ; } } else { LOG . info ( STRING + patch Data . get Type Name ( ) ) ; result = new Patch Result ( STRING , Patch Status . SKIPPED ) ; } } else { LOG . error ( STRING + type Name + STRING + apply Version + STRING + patch Data . get Update To Version ( ) + STRING ) ; result = new Patch Result ( STRING , Patch Status . FAILED ) ; } } catch ( Atlas Exception e ) { LOG . error ( STRING + patch Data . get Type Name ( ) ) ; result = new Patch Result ( STRING , Patch Status . FAILED ) ; } catch ( JSON Exception e ) { LOG . error ( STRING + patch Data . get Type Name ( ) ) ; result = new Patch Result ( STRING , Patch Status . FAILED ) ; } return result ; }
public static String random Alphanumerical ( final int len ) { final String Builder sb = new String Builder ( len ) ; for ( int i = NUM ; i < len ; i ++ ) { sb . append ( AB . char At ( random . next Int ( AB . length ( ) ) ) ) ; } return sb . to String ( ) ; }
static int svd imax ( int a , int b ) { return Math . max ( a , b ) ; }
public void action Performed ( Action Event e ) { Caret c = text Area . get Caret ( ) ; if ( c . get Dot ( ) != c . get Mark ( ) ) { return ; } R Syntax Document doc = ( R Syntax Document ) text Area . get Document ( ) ; doc . read Lock ( ) ; try { remove Highlights ( ) ; int line = text Area . get Caret Line Number ( ) ; Token token List = text Area . get Token List For Line ( line ) ; int dot = c . get Dot ( ) ; Token t = R Syntax Utilities . get Token At Offset ( token List , dot ) ; if ( t == null || ! is Valid Type ( t ) || is Non Word Char ( t ) ) { dot -- ; try { if ( dot >= text Area . get Line Start Offset ( line ) ) { t = R Syntax Utilities . get Token At Offset ( token List , dot ) ; } } catch ( Bad Location Exception ble ) { ble . print Stack Trace ( ) ; } } if ( t != null && is Valid Type ( t ) && ! is Non Word Char ( t ) ) { R Syntax Text Area Highlighter h = ( R Syntax Text Area Highlighter ) text Area . get Highlighter ( ) ; String lexeme = t . get Lexeme ( ) ; int type = t . type ; for ( int i = NUM ; i < text Area . get Line Count ( ) ; i ++ ) { Token temp = text Area . get Token List For Line ( i ) ; while ( temp != null && temp . is Paintable ( ) ) { if ( temp . is ( type , lexeme ) ) { try { int end = temp . offset + temp . text Count ; Object tag = h . add Marked Occurrence Highlight ( temp . offset , end , p ) ; tags . add ( tag ) ; } catch ( Bad Location Exception ble ) { ble . print Stack Trace ( ) ; } } temp = temp . get Next Token ( ) ; } } } } finally { doc . read Unlock ( ) ; } text Area . fire Marked Occurrences Changed ( ) ; }
public boolean restore Accessibility Focus ( Calendar Day day ) { if ( ( day . year != m Year ) || ( day . month != m Month ) || ( day . day > m Num Cells ) ) { return BOOL ; } m Touch Helper . set Focused Virtual View ( day . day ) ; return BOOL ; }
private boolean is Mime Format ( long format , String primary Type ) { String nat = get Native For Format ( format ) ; if ( nat == null ) { return BOOL ; } try { Data Flavor df = new Data Flavor ( nat ) ; if ( primary Type . equals ( df . get Primary Type ( ) ) ) { return BOOL ; } } catch ( Exception e ) { } return BOOL ; }
private static String convert Relevance ( int relevance ) { String Builder sb = new String Builder ( ) ; while ( relevance > NUM ) { sb . insert ( NUM , REVERSE CHAR MAP [ relevance % NUM ] ) ; relevance = relevance / NUM ; } return sb . to String ( ) ; }
public synchronized Alphabetic Index add Labels ( Locale locale ) { add Labels ( peer , locale . to String ( ) ) ; return this ; }
public void sort ( ) { Collections . sort ( individuals , PERFORMANCE COMPARATOR ) ; }
int extract Version From Filename ( final File file ) { final Matcher matcher = versioned Pattern . matcher ( file . get Absolute Path ( ) ) ; matcher . find ( ) ; return Integer . parse Int ( matcher . group ( NUM ) ) ; }
static int measure Child For Cells ( View child , int cell Size , int cells Remaining , int parent Height Measure Spec , int parent Height Padding ) { final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; final int child Height Size = Measure Spec . get Size ( parent Height Measure Spec ) - parent Height Padding ; final int child Height Mode = Measure Spec . get Mode ( parent Height Measure Spec ) ; final int child Height Spec = Measure Spec . make Measure Spec ( child Height Size , child Height Mode ) ; int cells Used = NUM ; if ( cells Remaining > NUM ) { final int child Width Spec = Measure Spec . make Measure Spec ( cell Size * cells Remaining , Measure Spec . AT MOST ) ; child . measure ( child Width Spec , child Height Spec ) ; final int measured Width = child . get Measured Width ( ) ; cells Used = measured Width / cell Size ; if ( measured Width % cell Size != NUM ) cells Used ++ ; } final Action Menu Item View item View = child instanceof Action Menu Item View ? ( Action Menu Item View ) child : null ; final boolean expandable = ! lp . is Overflow Button && item View != null && item View . has Text ( ) ; lp . expandable = expandable ; lp . cells Used = cells Used ; final int target Width = cells Used * cell Size ; child . measure ( Measure Spec . make Measure Spec ( target Width , Measure Spec . EXACTLY ) , child Height Spec ) ; return cells Used ; }
public void run Test ( ) throws Throwable { Document doc ; Node List element List ; Node name Node ; Character Data child ; String bad String ; doc = ( Document ) load ( STRING , BOOL ) ; element List = doc . get Elements By Tag Name ( STRING ) ; name Node = element List . item ( NUM ) ; child = ( Character Data ) name Node . get First Child ( ) ; { boolean success = BOOL ; try { bad String = child . substring Data ( - NUM , NUM ) ; } catch ( DOM Exception ex ) { success = ( ex . code == DOM Exception . INDEX SIZE ERR ) ; } assert True ( STRING , success ) ; } }
private boolean is Specialized Handler Available ( Intent intent ) { Package Manager pm = m Activity . get Package Manager ( ) ; List < Resolve Info > handlers = pm . query Intent Activities ( intent , Package Manager . GET RESOLVED FILTER ) ; if ( handlers == null || handlers . size ( ) == NUM ) { return BOOL ; } for ( Resolve Info resolve Info : handlers ) { Intent Filter filter = resolve Info . filter ; if ( filter == null ) { continue ; } if ( filter . count Data Authorities ( ) == NUM && filter . count Data Paths ( ) == NUM ) { continue ; } return BOOL ; } return BOOL ; }
private void convert Error ( Char Buffer buf , int line ) { String src Filename = null ; int dest Line = NUM ; int src Line = NUM ; int src Tail Line = Integer . MAX VALUE ; for ( int i = NUM ; i < lines . size ( ) ; i ++ ) { Line map = ( Line ) lines . get ( i ) ; if ( map . dst Line <= line && line <= map . get Last Destination Line ( ) ) { src Filename = map . src Filename ; dest Line = map . dst Line ; src Line = map . get Source Line ( line ) ; break ; } } if ( src Filename != null ) { } else if ( lines . size ( ) > NUM ) src Filename = ( ( Line ) lines . get ( NUM ) ) . src Filename ; else src Filename = STRING ; buf . append ( src Filename ) ; if ( line >= NUM ) { buf . append ( STRING ) ; buf . append ( src Line + ( line - dest Line ) ) ; } }
public static String slurp GBURL No Exceptions ( URL u ) { try { return slurp GBURL ( u ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return null ; } }
public void undo ( ) { if ( ! undo Stack . is Empty ( ) ) { Undoable Action last Event = undo Stack . pop ( ) ; last Event . undo ( ) ; redo Stack . push ( last Event ) ; } }
private void emit List Add ( Method method , String field Name , String Builder builder ) { builder . append ( STRING ) ; builder . append ( get List Adder Name ( field Name ) ) ; builder . append ( STRING ) ; builder . append ( get Type Argument Impl Name ( ( Parameterized Type ) method . get Generic Return Type ( ) , NUM ) ) ; builder . append ( STRING ) ; builder . append ( get Ensure Name ( field Name ) ) ; builder . append ( STRING ) ; builder . append ( field Name ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; }
public Pair < Solr Core , Solr Core > replicate To Destination ( Solr Core bestsrc Core , Solr Core destination Core ) throws Exception { Pair < Solr Core , Solr Core > replication Request Pair = null ; try { Solr Interaction Utils . replicate Index ( destination Core . host , destination Core . name , bestsrc Core . host , bestsrc Core . name ) ; String full Replication = STRING ; String replicator = String . format ( full Replication , destination Core . host , Solr Interaction Utils . DEFAULT SOLR PORT , destination Core . name , bestsrc Core . host , Solr Interaction Utils . DEFAULT SOLR PORT , bestsrc Core . name ) ; logger . info ( STRING + replicator ) ; replication Request Pair = new Pair < Solr Core , Solr Core > ( destination Core , bestsrc Core ) ; logger . info ( STRING + destination Core . host + STRING + destination Core . name + STRING + bestsrc Core . host + STRING + bestsrc Core . name ) ; } catch ( Exception e ) { logger . info ( STRING + destination Core . host + STRING + bestsrc Core . host ) ; if ( ! replicator Config . should Skip Replication Failures ( ) ) { throw new Replication Failure Exception ( STRING + destination Core . host + STRING + bestsrc Core . host ) ; } } return replication Request Pair ; }
public static OS Type calculate OS ( ) { String os Name = System . get Property ( STRING ) ; os Name = os Name . to Lower Case ( Locale . ENGLISH ) ; if ( os Name . starts With ( STRING ) ) { return OS Type . APPLE ; } if ( os Name . starts With ( STRING ) ) { return OS Type . WINDOWS ; } if ( os Name . starts With ( STRING ) ) { return OS Type . LINUX ; } if ( os Name . starts With ( STRING ) ) { return OS Type . SUN ; } return OS Type . UNKNOWN ; }
private static int count Duplicates ( Stack Trace Element [ ] current Stack , Stack Trace Element [ ] parent Stack ) { int duplicates = NUM ; int parent Index = parent Stack . length ; for ( int i = current Stack . length ; -- i >= NUM && -- parent Index >= NUM ; ) { Stack Trace Element parent Frame = parent Stack [ parent Index ] ; if ( parent Frame . equals ( current Stack [ i ] ) ) { duplicates ++ ; } else { break ; } } return duplicates ; }
public void recycle ( ) { synchronized ( s Pool ) { if ( s Pool . size ( ) < MAX POOL SIZE ) { s Pool . add ( this ) ; } } }
private String build Insert ( boolean disable Returning ) { sb . set Length ( NUM ) ; sb . append ( STRING ) ; append Table ( sb ) ; sb . append ( STRING ) ; sb . append ( options . key Column Name ) ; sb . append ( STRING ) ; if ( options . doctype Column Name != null ) { sb . append ( options . doctype Column Name ) ; sb . append ( STRING ) ; } sb . append ( options . content Column Name ) ; sb . append ( STRING ) ; if ( options . timestamp Column Name != null ) { sb . append ( STRING ) ; sb . append ( options . timestamp Column Name ) ; sb . append ( STRING ) ; } if ( options . creation Column Name != null ) { sb . append ( STRING ) ; sb . append ( options . creation Column Name ) ; sb . append ( STRING ) ; } if ( ( options . version Column Name != null ) && ( options . versioning Method ) != Collection Descriptor . VERSION NONE ) { sb . append ( STRING ) ; sb . append ( options . version Column Name ) ; sb . append ( STRING ) ; } sb . append ( STRING ) ; if ( ( options . key Sequence Name != null ) && ( ! disable Returning ) ) { switch ( options . key Data Type ) { case Collection Descriptor . INTEGER KEY : sb . append ( STRING ) ; sb . append ( options . key Sequence Name ) ; sb . append ( STRING ) ; break ; case Collection Descriptor . RAW KEY : sb . append ( STRING ) ; sb . append ( options . key Sequence Name ) ; sb . append ( STRING ) ; break ; case Collection Descriptor . STRING KEY : case Collection Descriptor . NCHAR KEY : default : sb . append ( STRING ) ; sb . append ( options . key Sequence Name ) ; sb . append ( STRING ) ; break ; } } else if ( ( options . key Assignment Method == Collection Descriptor . KEY ASSIGN GUID ) && ( ! disable Returning ) ) { switch ( options . key Data Type ) { case Collection Descriptor . INTEGER KEY : sb . append ( STRING ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; break ; case Collection Descriptor . RAW KEY : sb . append ( STRING ) ; break ; case Collection Descriptor . STRING KEY : case Collection Descriptor . NCHAR KEY : default : sb . append ( STRING ) ; break ; } } else { add Key ( sb ) ; } if ( options . doctype Column Name != null ) { sb . append ( STRING ) ; } sb . append ( STRING ) ; if ( options . timestamp Column Name != null ) { if ( disable Returning ) Oracle Database Impl . add To Timestamp ( STRING , sb ) ; else sb . append ( STRING ) ; } if ( options . creation Column Name != null ) { if ( disable Returning ) Oracle Database Impl . add To Timestamp ( STRING , sb ) ; else sb . append ( STRING ) ; } if ( ( options . version Column Name != null ) && ( options . versioning Method ) != Collection Descriptor . VERSION NONE ) sb . append ( STRING ) ; sb . append ( STRING ) ; if ( insert Has Return Clause ( disable Returning ) ) { sb . append ( STRING ) ; int count = NUM ; if ( return Inserted Key ( ) ) { sb . append ( STRING ) ; sb . append ( options . key Column Name ) ; sb . append ( STRING ) ; count ++ ; } if ( return Inserted Time ( ) ) { add Comma ( sb , count ) ; sb . append ( STRING ) ; if ( options . timestamp Column Name != null ) sb . append ( options . timestamp Column Name ) ; else sb . append ( options . creation Column Name ) ; sb . append ( STRING ) ; Oracle Database Impl . add Timestamp Returning Format ( sb ) ; count ++ ; } if ( return Inserted Version ( ) ) { add Comma ( sb , count ) ; sb . append ( STRING ) ; sb . append ( options . version Column Name ) ; sb . append ( STRING ) ; count ++ ; } add Into ( sb , count ) ; } return ( sb . to String ( ) ) ; }
public final boolean exists ( ) { return config != null ; }
@ Override public synchronized void remove Test Set Listener ( Test Set Listener tsl ) { m test Listeners . remove Element ( tsl ) ; }
private boolean has colinear ( Array List < Pla Point Int > corners list , Pla Point Int a point ) { int count = corners list . size ( ) ; if ( count < NUM ) return BOOL ; for ( int index = NUM ; index < count - NUM ; index ++ ) { Pla Point Int start = corners list . get ( index ) ; Pla Point Int end = corners list . get ( index + NUM ) ; if ( a point . side of ( start , end ) != Pla Side . COLLINEAR ) continue ; double d start p = start . distance square ( a point ) ; double d p end = a point . distance square ( end ) ; double d start end = start . distance square ( end ) ; if ( d start end >= d start p ) { if ( d start end >= d p end ) { return BOOL ; } else { corners list . set ( index , a point ) ; return BOOL ; } } else { if ( d start end >= d p end ) { corners list . set ( index + NUM , a point ) ; return BOOL ; } else { corners list . set ( index , a point ) ; return BOOL ; } } } return BOOL ; }
public boolean contains ( String key ) { return my Properties . contains Key ( key ) ; }
protected Snmp Cached Data update Cached Datas ( Object user Data ) { final String [ ] path = Jvm Runtime Impl . get Library Path ( user Data ) ; final long time = System . current Time Millis ( ) ; final int len = path . length ; Snmp Oid indexes [ ] = new Snmp Oid [ len ] ; for ( int i = NUM ; i < len ; i ++ ) { indexes [ i ] = new Snmp Oid ( i + NUM ) ; } return new Snmp Cached Data ( time , indexes , path ) ; }
public static byte [ ] decode Hex ( String hex String ) { int length = hex String . length ( ) ; if ( ( length & NUM ) != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } boolean bad Hex = BOOL ; byte [ ] out = new byte [ length > > NUM ] ; for ( int i = NUM , j = NUM ; j < length ; i ++ ) { int c1 = hex String . char At ( j ++ ) ; if ( c1 > STRING ) { bad Hex = BOOL ; break ; } final byte d1 = DIGITS [ c1 ] ; if ( d1 == - NUM ) { bad Hex = BOOL ; break ; } int c2 = hex String . char At ( j ++ ) ; if ( c2 > STRING ) { bad Hex = BOOL ; break ; } final byte d2 = DIGITS [ c2 ] ; if ( d2 == - NUM ) { bad Hex = BOOL ; break ; } out [ i ] = ( byte ) ( d1 << NUM | d2 ) ; } if ( bad Hex ) { throw new Illegal Argument Exception ( STRING + hex String ) ; } return out ; }
public static void delete Player ( Player Account Data acc Data ) { if ( acc Data . get Deletion Date ( ) != null ) { return ; } acc Data . set Deletion Date ( new Timestamp ( System . current Time Millis ( ) + NUM * NUM * NUM ) ) ; store Deletion Time ( acc Data ) ; }
public int eval ( I Node state ) { Eight Puzzle Node node = ( Eight Puzzle Node ) state ; int Pn = NUM ; for ( int r = NUM ; r <= Eight Puzzle Node . Max R ; r ++ ) { for ( int c = NUM ; c <= Eight Puzzle Node . Max C ; c ++ ) { if ( node . is Empty ( r , c ) ) { continue ; } int digit = node . cell ( r , c ) ; Pn += Math . abs ( diffs [ digit ] [ NUM ] - r ) ; Pn += Math . abs ( diffs [ digit ] [ NUM ] - c ) ; } } int Sn = NUM ; if ( ! node . is Empty ( NUM , NUM ) ) { Sn = NUM ; } for ( int r = NUM ; r <= Eight Puzzle Node . Max R ; r ++ ) { for ( int c = NUM ; c <= Eight Puzzle Node . Max C ; c ++ ) { int idx = r * NUM + c ; if ( r == NUM && c == NUM ) { continue ; } if ( node . cell ( r , c ) == Eight Puzzle Node . Empty Mark ) { continue ; } if ( succ [ node . cell ( r , c ) ] != node . cell ( succs [ idx ] [ NUM ] , succs [ idx ] [ NUM ] ) ) { Sn += NUM ; } } } int gn = NUM ; Depth Transition t = ( Depth Transition ) state . stored Data ( ) ; if ( t != null ) { gn = t . depth ; } return gn + Pn + NUM * Sn ; }
public void test Buffered ( ) { Instances icopy = new Instances ( m Instances ) ; Instances result = null ; try { m Filter . set Input Format ( icopy ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; fail ( STRING + ex . get Message ( ) ) ; } try { result = Filter . use Filter ( icopy , m Filter ) ; assert Not Null ( result ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; fail ( STRING + ex . get Message ( ) ) ; } String Writer sw = new String Writer ( NUM ) ; sw . write ( result . to String ( ) ) ; assert True ( icopy . equal Headers ( m Instances ) ) ; assert Equals ( icopy . num Instances ( ) , m Instances . num Instances ( ) ) ; Instances result 2 = null ; try { m Filter . set Input Format ( icopy ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; fail ( STRING + ex . get Message ( ) ) ; } try { result 2 = Filter . use Filter ( icopy , m Filter ) ; assert Not Null ( result 2 ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; fail ( STRING + ex . get Message ( ) ) ; } assert True ( icopy . equal Headers ( m Instances ) ) ; assert Equals ( icopy . num Instances ( ) , m Instances . num Instances ( ) ) ; assert True ( result . equal Headers ( result 2 ) ) ; assert Equals ( result . num Instances ( ) , result 2 . num Instances ( ) ) ; }
private String parse Css ( final String css ) { final Map < String , String > map = new Hash Map < String , String > ( ) ; final String Buffer sb = new String Buffer ( ) ; final Matcher m = PATTERN VARIABLES DEFINITION . matcher ( css ) ; while ( m . find ( ) ) { final String variables Body = m . group ( NUM ) ; map . put All ( extract Variables ( variables Body ) ) ; m . append Replacement ( sb , STRING ) ; } m . append Tail ( sb ) ; return replace Variables ( sb . to String ( ) , map ) ; }
private void shutdown ( ) { if ( exec Svc != null ) exec Svc . shutdown ( NUM ) ; if ( msg Exec Svc != null ) msg Exec Svc . shutdown Now ( ) ; try { job . dispose ( BOOL ) ; } catch ( Ignite Checked Exception e ) { U . error ( log , STRING , e ) ; } }
public void start CDATA ( ) throws org . xml . sax . SAX Exception { m in C Data = BOOL ; append ( m doc . create CDATA Section ( STRING ) ) ; }
public void add All ( List < Fragment > a Splits ) { splits . add All ( a Splits ) ; }
protected synchronized int currentchunkoffset ( ) throws IO Exception { long fp = backing Random Access File . get File Pointer ( ) ; if ( fp < f Header . header Size ( ) ) { return - NUM ; } else { fp -= f Header . header Size ( ) ; if ( fp == NUM ) { return NUM ; } else { return ( int ) ( ( fp % CHUNK ENC SIZE ) - CHUNK IV SIZE ) ; } } }
private int parse Int Value ( String input ) throws Number Format Exception { int value = NUM ; if ( input . starts With ( STRING ) ) { String temp = input . substring ( NUM ) ; return Integer . parse Int ( temp ) ; } else if ( input . starts With ( STRING ) ) { String temp = input . substring ( NUM ) ; char [ ] chars = temp . to Char Array ( ) ; if ( chars . length > NUM ) { throw new Number Format Exception ( ) ; } else { for ( int i = NUM ; i < chars . length ; i ++ ) { int index = chars . length - i - NUM ; switch ( chars [ i ] ) { case STRING : value += NUM ; break ; case STRING : value += NUM * get Base ( index ) ; break ; case STRING : value += NUM * get Base ( index ) ; break ; case STRING : value += NUM * get Base ( index ) ; break ; case STRING : value += NUM * get Base ( index ) ; break ; case STRING : value += NUM * get Base ( index ) ; break ; case STRING : value += NUM * get Base ( index ) ; break ; case STRING : value += NUM * get Base ( index ) ; break ; case STRING : value += NUM * get Base ( index ) ; break ; case STRING : value += NUM * get Base ( index ) ; break ; case STRING : case STRING : value += NUM * get Base ( index ) ; break ; case STRING : case STRING : value += NUM * get Base ( index ) ; break ; case STRING : case STRING : value += NUM * get Base ( index ) ; break ; case STRING : case STRING : value += NUM * get Base ( index ) ; break ; case STRING : case STRING : value += NUM * get Base ( index ) ; break ; case STRING : case STRING : value += NUM * get Base ( index ) ; break ; default : throw new Number Format Exception ( STRING ) ; } } } if ( value < NUM ) { throw new Number Format Exception ( STRING ) ; } } else { value = Integer . parse Int ( input ) ; } return value ; }
protected int decode Line Prefix ( Pushback Input Stream a Stream , Output Stream b Stream ) throws IO Exception { return ( bytes Per Line ( ) ) ; }
private static Lookup Locator [ ] unmarshal Locators ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { List l = new Array List ( ) ; Marshalled Instance mi ; while ( ( mi = ( Marshalled Instance ) in . read Object ( ) ) != null ) { try { l . add ( ( Lookup Locator ) mi . get ( BOOL ) ) ; } catch ( Throwable e ) { if ( e instanceof Error && Throwable Constants . retryable ( e ) == Throwable Constants . BAD OBJECT ) { throw ( Error ) e ; } logger . log ( Level . WARNING , STRING , e ) ; } } return ( Lookup Locator [ ] ) l . to Array ( new Lookup Locator [ l . size ( ) ] ) ; }
public void accept ( final Annotation Visitor av ) { if ( av != null ) { if ( values != null ) { for ( int i = NUM ; i < values . size ( ) ; i += NUM ) { String name = ( String ) values . get ( i ) ; Object value = values . get ( i + NUM ) ; accept ( av , name , value ) ; } } av . visit End ( ) ; } }
static public String number To String ( Number n ) throws JSON Exception { if ( n == null ) { throw new JSON Exception ( STRING ) ; } test Validity ( n ) ; String s = n . to String ( ) ; if ( s . index Of ( STRING ) > NUM && s . index Of ( STRING ) < NUM && s . index Of ( STRING ) < NUM ) { while ( s . ends With ( STRING ) ) { s = s . substring ( NUM , s . length ( ) - NUM ) ; } if ( s . ends With ( STRING ) ) { s = s . substring ( NUM , s . length ( ) - NUM ) ; } } return s ; }
public int children ( ) { return children . size ( ) ; }
public void create V Vset ( String display Name ) throws Exception { log . info ( STRING ) ; Client Response client Resp = null ; String payload = STRING + display Name + STRING ; log . info ( STRING , URI CREATE CG . to String ( ) , payload ) ; try { client Resp = post ( URI CREATE CG , payload ) ; if ( client Resp == null ) { log . error ( STRING ) ; throw new HP 3 PAR Exception ( STRING ) ; } else if ( client Resp . get Status ( ) != NUM ) { String err Resp = get Response Details ( client Resp ) ; log . error ( STRING , err Resp ) ; throw new HP 3 PAR Exception ( err Resp ) ; } else { log . info ( STRING ) ; } } catch ( Exception e ) { throw e ; } finally { if ( client Resp != null ) { client Resp . close ( ) ; } log . info ( STRING ) ; } }
protected void connection Failed ( Channel failed Channel , IO Exception cause ) { failure Cause = IO Exception Support . create ( cause ) ; channel = failed Channel ; connected . set ( BOOL ) ; handshake Future . set Failure ( cause ) ; }
public static byte [ ] split Uint 8 To 2 bytes ( char uint 8 ) { if ( uint 8 < NUM || uint 8 > NUM ) { throw new Runtime Exception ( STRING ) ; } String hex String = Integer . to Hex String ( uint 8 ) ; byte low ; byte high ; if ( hex String . length ( ) > NUM ) { high = ( byte ) Integer . parse Int ( hex String . substring ( NUM , NUM ) , NUM ) ; low = ( byte ) Integer . parse Int ( hex String . substring ( NUM , NUM ) , NUM ) ; } else { high = NUM ; low = ( byte ) Integer . parse Int ( hex String . substring ( NUM , NUM ) , NUM ) ; } byte [ ] result = new byte [ ] { high , low } ; return result ; }
public void write ( int c ) throws IO Exception { internal Out . write ( c ) ; }
public static void init ( Context context ) { if ( camera Manager == null ) { camera Manager = new Camera Manager ( context ) ; } }
public void add Attribute ( String uri , String local Name , String raw Name , String type , String value , boolean XSL Attribute ) throws SAX Exception { if ( m elem Context . m start Tag Open ) { ensure Prefix Is Declared ( uri , raw Name ) ; add Attribute Always ( uri , local Name , raw Name , type , value , BOOL ) ; } }
private String markdown Blockquote ( String value ) { return STRING + value . replace ( STRING , STRING ) ; }
protected String hash ( String key ) { try { Message Digest gen = HASH GENERATOR . get ( ) ; byte [ ] key Bytes = key . get Bytes ( STRING ) ; gen . update ( key Bytes , NUM , key Bytes . length ) ; byte [ ] binaryhash = gen . digest ( ) ; return ENCODER . encode To String ( binaryhash ) ; } catch ( Exception e ) { LOG . warn ( STRING , key , e ) ; } return null ; }
public static boolean is Input Type ( String type String ) { return INPUT TYPES . contains ( type String ) ; }
public static Point destination ( Point point 1 , double distance , double bearing , String units ) throws Turf Exception { double degrees 2 radians = Math . PI / NUM ; double radians 2 degrees = NUM / Math . PI ; Position coordinates 1 = point 1 . get Coordinates ( ) ; double longitude 1 = degrees 2 radians * coordinates 1 . get Longitude ( ) ; double latitude 1 = degrees 2 radians * coordinates 1 . get Latitude ( ) ; double bearing Rad = degrees 2 radians * bearing ; double radians = Turf Helpers . distance To Radians ( distance , units ) ; double latitude 2 = Math . asin ( Math . sin ( latitude 1 ) * Math . cos ( radians ) + Math . cos ( latitude 1 ) * Math . sin ( radians ) * Math . cos ( bearing Rad ) ) ; double longitude 2 = longitude 1 + Math . atan 2 ( Math . sin ( bearing Rad ) * Math . sin ( radians ) * Math . cos ( latitude 1 ) , Math . cos ( radians ) - Math . sin ( latitude 1 ) * Math . sin ( latitude 2 ) ) ; return Point . from Coordinates ( Position . from Coordinates ( radians 2 degrees * longitude 2 , radians 2 degrees * latitude 2 ) ) ; }
public void clear ( ) { synchronized ( m Lock ) { m Graphics . clear ( ) ; m First Graphic = null ; } post Invalidate ( ) ; }
@ Suppress Warnings ( STRING ) public Node Panel ( Shader Node Variable single Out , Node Panel . Node Type type ) { super ( ) ; List < Shader Node Variable > outputs = new Array List < Shader Node Variable > ( ) ; outputs . add ( single Out ) ; this . type = type ; init ( new Array List < Shader Node Variable > ( ) , outputs ) ; add Key Listener ( this ) ; tool Bar = new Node Tool Bar ( this ) ; }
public static String stringify Exception ( Throwable e ) { String Writer stm = new String Writer ( ) ; Print Writer wrt = new Print Writer ( stm ) ; e . print Stack Trace ( wrt ) ; wrt . close ( ) ; return stm . to String ( ) ; }
private Heron Reef Utils ( ) { }
public static boolean is Solaris ( ) { return ( OS . index Of ( STRING ) >= NUM ) ; }
public double Sum Inlink Hub Score ( Page page ) { List < String > in Links = page . get Inlinks ( ) ; double hub Score = NUM ; for ( int i = NUM ; i < in Links . size ( ) ; i ++ ) { Page in Link = p Table . get ( in Links . get ( i ) ) ; if ( in Link != null ) { hub Score += in Link . hub ; } else { continue ; } } return hub Score ; }
@ Override public void add Undo Point ( ) { File temp File ; Object Output Stream oos ; if ( ! is Undo Enabled ( ) ) { return ; } if ( get Instances ( ) != null ) { try { temp File = File . create Temp File ( STRING , null ) ; temp File . delete On Exit ( ) ; oos = new Object Output Stream ( new Buffered Output Stream ( new File Output Stream ( temp File ) ) ) ; oos . write Object ( get Instances ( ) ) ; oos . flush ( ) ; oos . close ( ) ; m Undo List . add ( temp File ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } }
private void clip View On The Right ( Rect cur View Bound , float cur View Width , int right ) { cur View Bound . right = ( int ) ( right - m Clip Padding ) ; cur View Bound . left = ( int ) ( cur View Bound . right - cur View Width ) ; }
private void preserve Parent Link ( String broken Table Name , String broken Column Name , String broken Default Value , Array List < String > broken Compare Columns , String hint Table Name , String hint Column Name , Array List < String > hint Compare Columns ) { String vendor Name = m target . get Vendor ( ) ; String catalog Name = m target . get Catalog ( ) ; String schema Name = m target . get Schema ( ) ; if ( m source . is Object Exists ( broken Table Name , m source . get Tables ( ) ) ) { boolean column To Preserve Link Exists = BOOL ; DB Object table To Preserve Link = m source . get Object By Name ( broken Table Name , m source . get Tables ( ) ) ; Hash Map < Integer , DB Object Definition > columns = table To Preserve Link . get Contents ( ) ; Vector < Integer > vc = new Vector < Integer > ( columns . key Set ( ) ) ; for ( Iterator < Integer > ic = vc . iterator ( ) ; ic . has Next ( ) ; ) { int kc = ic . next ( ) ; DB Object Table Column column Detail = ( DB Object Table Column ) columns . get ( kc ) ; String column Name = column Detail . get Name ( ) ; if ( column Name . equals Ignore Case ( broken Column Name ) ) column To Preserve Link Exists = BOOL ; } if ( column To Preserve Link Exists ) { s logger . log ( Level . FINE , STRING , new Object [ ] { m object Type , broken Table Name , m direction } ) ; String sql Command = s db Engine . sql Action preserve Parent Links ( vendor Name , catalog Name , schema Name , broken Table Name , broken Column Name , broken Default Value , broken Compare Columns , hint Table Name , hint Column Name , hint Compare Columns ) ; if ( sql Command != null ) { Savepoint sp = m target . set Savepoint ( STRING ) ; Statement stmt = m target . set Statement ( ) ; Integer sql Result = m target . execute Update ( stmt , sql Command , BOOL , BOOL ) ; if ( sql Result != null ) { log Update Detail ( sql Result , null ) ; m counter Upd = new Integer ( m counter Upd . int Value ( ) + NUM ) ; } m target . release Statement ( stmt ) ; m total Upd = new Integer ( m total Upd . int Value ( ) + NUM ) ; m target . release Savepoint ( sp ) ; } } } }
public Short Banded Raster ( Sample Model sample Model , Data Buffer data Buffer , Point origin ) { this ( sample Model , data Buffer , new Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
public void remap Mapped Types ( ) { clear Mapped Types ( ) ; map Possible Types ( m Items ) ; }
public void initialize ( ) throws Execution Exception { }
public int num Children ( int row ) { int count = NUM ; next Valid Row Positions . clear ( ) ; for ( int i = NUM ; i < n ; i ++ ) { board [ row ] [ i ] = BOOL ; if ( valid ( row , i ) ) { count ++ ; next Valid Row Positions . add ( i ) ; } board [ row ] [ i ] = BOOL ; } return count ; }
public void test Neg Neg Same Length ( ) { String num A = STRING ; String num B = STRING ; String res = STRING ; Big Integer a Number = new Big Integer ( num A ) ; Big Integer b Number = new Big Integer ( num B ) ; Big Integer result = a Number . xor ( b Number ) ; assert True ( res . equals ( result . to String ( ) ) ) ; }
public static I Java Search Scope create Related Projects Scope ( I Java Project project , int include Mask ) throws Core Exception { I Java Project [ ] projects = get Related Projects ( project ) ; return Search Engine . create Java Search Scope ( projects , include Mask ) ; }
public Confirmation ( ) { this ( null , null ) ; }
public Vcs Revision Number original Revision ( int line Number ) { return get Line Revision Number ( line Number ) ; }
private void check Paused Or Canceled ( State state ) throws Stop Request { if ( m Service . get Control ( ) == Downloader Service . CONTROL PAUSED ) { int status = m Service . get Status ( ) ; switch ( status ) { case Downloader Service . STATUS PAUSED BY APP : throw new Stop Request ( m Service . get Status ( ) , STRING ) ; } } }
void trace ( ) { gl Use Program ( compute Program ) ; inv Proj Matrix . transform Project ( tmp Vector . set ( - NUM , - NUM , NUM ) ) ; gl Uniform 3 f ( ray 00 Uniform , tmp Vector . x , tmp Vector . y , tmp Vector . z ) ; inv Proj Matrix . transform Project ( tmp Vector . set ( - NUM , NUM , NUM ) ) ; gl Uniform 3 f ( ray 01 Uniform , tmp Vector . x , tmp Vector . y , tmp Vector . z ) ; inv Proj Matrix . transform Project ( tmp Vector . set ( NUM , - NUM , NUM ) ) ; gl Uniform 3 f ( ray 10 Uniform , tmp Vector . x , tmp Vector . y , tmp Vector . z ) ; inv Proj Matrix . transform Project ( tmp Vector . set ( NUM , NUM , NUM ) ) ; gl Uniform 3 f ( ray 11 Uniform , tmp Vector . x , tmp Vector . y , tmp Vector . z ) ; gl Bind Buffer Base ( GL SHADER STORAGE BUFFER , triangles Ssbo Binding , ssbo ) ; gl Bind Image Texture ( framebuffer Image Binding , raytrace Texture , NUM , BOOL , NUM , GL WRITE ONLY , GL RGBA 8 ) ; int worksize X = math Round Po T ( width ) ; int worksize Y = math Round Po T ( height ) ; gl Dispatch Compute ( worksize X / work Group Size X , worksize Y / work Group Size Y , NUM ) ; gl Memory Barrier ( GL SHADER IMAGE ACCESS BARRIER BIT ) ; gl Bind Image Texture ( framebuffer Image Binding , NUM , NUM , BOOL , NUM , GL WRITE ONLY , GL RGBA 8 ) ; gl Bind Buffer Base ( GL SHADER STORAGE BUFFER , triangles Ssbo Binding , NUM ) ; gl Use Program ( NUM ) ; }
public void remove All Action Fire Listeners ( ) { m Action Fired Listeners . clear ( ) ; }
public static String millis To String ( long millis ) { boolean negative = millis < NUM ; millis = Math . abs ( millis ) ; millis /= NUM ; int sec = ( int ) ( millis % NUM ) ; millis /= NUM ; int min = ( int ) ( millis % NUM ) ; millis /= NUM ; int hours = ( int ) millis ; String time ; Decimal Format format = ( Decimal Format ) Number Format . get Instance ( Locale . US ) ; format . apply Pattern ( STRING ) ; if ( millis > NUM ) { time = ( negative ? STRING : STRING ) + hours + STRING + format . format ( min ) + STRING + format . format ( sec ) ; } else { time = ( negative ? STRING : STRING ) + min + STRING + format . format ( sec ) ; } return time ; }
@ Inline public static void to UTF 8 ( String s , Byte Buffer b ) { int result index = NUM ; for ( int i = NUM , n = s . length ( ) ; i < n ; ++ i ) { char c = s . char At ( i ) ; if ( ( ( ! WRITE PSEUDO UTF 8 ) || ( c >= NUM ) ) && ( c <= NUM ) ) { b . put ( ( byte ) c ) ; } else if ( c > NUM ) { b . put ( ( byte ) ( NUM | ( byte ) ( c > > NUM ) ) ) ; b . put ( ( byte ) ( NUM | ( ( c & NUM ) > > NUM ) ) ) ; b . put ( ( byte ) ( NUM | ( c & NUM ) ) ) ; } else { b . put ( ( byte ) ( NUM | ( byte ) ( c > > NUM ) ) ) ; b . put ( ( byte ) ( NUM | ( c & NUM ) ) ) ; } } }
public Copy On Write Array List ( E [ ] to Copy In ) { set Array ( Arrays . copy Of ( to Copy In , to Copy In . length , Object [ ] . class ) ) ; }
@ Override public String Buffer format ( long number , String Buffer to Append To , Field Position pos ) { return to Append To . append ( get Direction Code ( number ) ) ; }
public static void main ( String [ ] args ) throws Exception { digest Command Line Arguments ( args ) ; boolean in Headless Mode = Graphics Environment . is Headless ( ) ; boolean in Convert Mode = isin Convert Mode ( ) ; SCXML Graph Editor editor = start Editor ( in Convert Mode || in Headless Mode ) ; if ( isin Convert Mode ( ) ) { SCXML Editor Actions . convert No GUI ( editor ) ; } else if ( ! in Headless Mode ) { String input = get Preset Input ( ) ; if ( ! String Utils . is Empty String ( input ) ) { Open Action open = new Open Action ( new File ( input ) ) ; open . action Performed ( new Action Event ( editor , NUM , STRING ) ) ; } } }
public void test Equals Unequal 2 ( ) { String a = STRING ; int a Scale = - NUM ; String b = STRING ; int b Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; assert False ( a Number . equals ( b Number ) ) ; }
protected void enable Retransmission Timer ( int tick Count ) { if ( is Invite Transaction ( ) && ( this instanceof SIP Client Transaction ) ) { retransmission Timer Ticks Left = tick Count ; } else { retransmission Timer Ticks Left = Math . min ( tick Count , get Timer T 2 ( ) ) ; } retransmission Timer Last Tick Count = retransmission Timer Ticks Left ; }
private void schedule Msg For All Consumers ( Jetstream Message msg ) { if ( LOGGER . is Debug Enabled ( ) ) LOGGER . debug ( STRING + msg . to String ( ) ) ; Event Consumer Info info = null ; Array List < Linked List < Selection > > weighted List = m event Topic Registry . get ( msg . get Topic ( ) ) ; if ( weighted List != null ) { Iterator < Linked List < Selection > > weighted Itr = weighted List . iterator ( ) ; while ( weighted Itr . has Next ( ) ) { Linked List < Selection > consumer List = weighted Itr . next ( ) ; Iterator < Selection > itr = consumer List . iterator ( ) ; while ( itr . has Next ( ) ) { info = ( Event Consumer Info ) itr . next ( ) ; if ( info == null ) continue ; dispatch ( info , msg ) ; } } } else { if ( m advisory Listener != null ) { post Resend Advisory ( msg ) ; m no Consumer Advisories . increment ( ) ; } else { m total Msgs Dropped . increment ( ) ; m drops For No Consumer . increment ( ) ; } } }
@ Override public Void visit Declared ( Annotated Declared Type declared Type , Void a Void ) { if ( pause ) { return null ; } parents . push ( declared Type ) ; super . visit Declared ( declared Type , a Void ) ; parents . pop ( ) ; return null ; }
public Class create ( ) { set Use Cache ( BOOL ) ; return ( Class ) super . create ( this ) ; }
public static < T > List < T > tuple ( T ... objects ) { return Collections . unmodifiable List ( list ( objects ) ) ; }
protected static Set string Array To Set ( String [ ] strs ) { int count = strs . length ; Set set = ( ( count > NUM ) ? new Hash Set ( count ) : new Hash Set ( ) ) ; for ( int i = NUM ; i < count ; i ++ ) { set . add ( strs [ i ] ) ; } return set ; }
public boolean authenticate ( final Odd Callback < Auth Token > callback ) { synchronized ( sync Lock ) { if ( is Expired ( ) ) { return BOOL ; } if ( ! authenticating ) { authenticating = BOOL ; timer = new Timer ( ) ; Timer Task task = get Poll Task ( callback ) ; timer . schedule ( task , new Date ( ) , interval ) ; Timer Task expired Task = get Expired Task ( callback ) ; timer . schedule ( expired Task , expiration Date ) ; } return BOOL ; } }
public static void cancel Notifications For Room Id ( String account Id , String room Id ) { Log . d ( LOG TAG , STRING + account Id + STRING + room Id ) ; if ( null != m Active Event Stream Service ) { m Active Event Stream Service . cancel Notifications ( account Id , room Id ) ; } }
public static Optional < Player Profile > lookup ( UUID id ) { if ( Bukkit . get Player ( id ) != null ) { return Optional . of ( from Player ( Bukkit . get Player ( id ) ) ) ; } return lookup Properties ( id ) ; }
static double svd dmin ( double a , double b ) { return Math . min ( a , b ) ; }
private Storage Port select Storage Port ( List < Storage Port > sp List ) { Collections . shuffle ( sp List ) ; return sp List . get ( NUM ) ; }
private void assimilate Context ( Nesting Exception nesting Exception ) { Enumeration < Exception Context > enum Exeptions = nesting Exception . get Exception Contexts ( ) ; if ( enum Exeptions . has More Elements ( ) ) { while ( enum Exeptions . has More Elements ( ) ) { add Exception Context ( enum Exeptions . next Element ( ) ) ; } nesting Exception . clear Contexts ( ) ; } }
public boolean equals ( Object o ) { if ( o instanceof AM Identity Subject ) { AM Identity Subject subject = ( AM Identity Subject ) o ; return ( subject Values . equals ( subject . subject Values ) ) ; } return ( BOOL ) ; }
public void update Keyinfo ( String realm , String entity Name , Map < String , Set < String > > ext Values , Map < String , Set < String > > std Values , boolean is IDP ) throws AM Console Exception { String keysize = get Result ( std Values , TF KEY NAME ) ; String algorithm = get Result ( std Values , TF ALGORITHM ) ; Set < String > signing Cert Aliases ; Set < String > encryption Cert Aliases ; if ( is IDP ) { encryption Cert Aliases = ext Values . get ( IDP ENCRYPT CERT ALIAS ) ; signing Cert Aliases = ext Values . get ( IDP SIGN CERT ALIAS ) ; } else { encryption Cert Aliases = ext Values . get ( SP ENCRYPT CERT ALIAS ) ; signing Cert Aliases = ext Values . get ( SP SIGN CERT ALIAS ) ; } int keysi = ! String Utils . is Empty ( keysize ) ? Integer . parse Int ( keysize ) : NUM ; String alg = String Utils . is Empty ( algorithm ) ? XML Cipher . AES 128 : algorithm ; try { SAML 2 Meta Security Utils . update Provider Key Info ( realm , entity Name , signing Cert Aliases , BOOL , is IDP , alg , keysi ) ; SAML 2 Meta Security Utils . update Provider Key Info ( realm , entity Name , encryption Cert Aliases , BOOL , is IDP , alg , keysi ) ; } catch ( SAML 2 Meta Exception e ) { debug . warning ( STRING , e ) ; throw new AM Console Exception ( get Error String ( e ) ) ; } }
public void update Slider ( final double p , final boolean n ) { check Widget ( ) ; double percentage = p ; if ( step != null ) { percentage = Math . round ( percentage / step ) * step ; } this . notify = n ; if ( percentage < NUM ) { percentage = NUM ; } else if ( percentage > NUM ) { percentage = NUM ; } final int useful Width = get Client Area ( ) . width - thumb Width ; final int width = ( int ) Math . round ( useful Width * percentage ) ; move Thumb Horizontally ( width ) ; previous Position = percentage ; this . notify = BOOL ; }
@ Override public boolean contains ( String identifier ) { return whitelist . contains ( identifier ) ; }
public static final Action [ ] augment List ( Action [ ] list 1 , Action [ ] list 2 ) { Hashtable < String , Action > h = new Hashtable < String , Action > ( ) ; for ( Action a : list 1 ) { String value = ( String ) a . get Value ( Action . NAME ) ; h . put ( ( value != null ? value : STRING ) , a ) ; } for ( Action a : list 2 ) { String value = ( String ) a . get Value ( Action . NAME ) ; h . put ( ( value != null ? value : STRING ) , a ) ; } Action [ ] actions = new Action [ h . size ( ) ] ; int index = NUM ; for ( Enumeration e = h . elements ( ) ; e . has More Elements ( ) ; ) { actions [ index ++ ] = ( Action ) e . next Element ( ) ; } return actions ; }
public MV Map < K , V > open Version ( long version ) { if ( read Only ) { throw Data Utils . new Unsupported Operation Exception ( STRING + STRING ) ; } Data Utils . check Argument ( version >= create Version , STRING , version , create Version ) ; Page newest = null ; Page r = root ; if ( version >= r . get Version ( ) && ( version == write Version || r . get Version ( ) >= NUM || version <= create Version || store . get File Store ( ) == null ) ) { newest = r ; } else { Page last = old Roots . peek First ( ) ; if ( last == null || version < last . get Version ( ) ) { return store . open Map Version ( version , id , this ) ; } Iterator < Page > it = old Roots . iterator ( ) ; while ( it . has Next ( ) ) { Page p = it . next ( ) ; if ( p . get Version ( ) > version ) { break ; } last = p ; } newest = last ; } MV Map < K , V > m = open Read Only ( ) ; m . root = newest ; return m ; }
public DTM Default Base ( DTM Manager mgr , Source source , int dtm Identity , DTMWS Filter white Space Filter , XML String Factory xstringfactory , boolean do Indexing , int blocksize , boolean use Prevsib , boolean new Name Table ) { int numblocks ; if ( blocksize <= NUM ) { numblocks = DEFAULT NUMBLOCKS SMALL ; m dtm Ident = new Suballocated Int Vector ( NUM , NUM ) ; } else { numblocks = DEFAULT NUMBLOCKS ; m dtm Ident = new Suballocated Int Vector ( NUM ) ; } m exptype = new Suballocated Int Vector ( blocksize , numblocks ) ; m firstch = new Suballocated Int Vector ( blocksize , numblocks ) ; m nextsib = new Suballocated Int Vector ( blocksize , numblocks ) ; m parent = new Suballocated Int Vector ( blocksize , numblocks ) ; if ( use Prevsib ) m prevsib = new Suballocated Int Vector ( blocksize , numblocks ) ; m mgr = mgr ; if ( mgr instanceof DTM Manager Default ) m mgr Default = ( DTM Manager Default ) mgr ; m document Base URI = ( null != source ) ? source . get System Id ( ) : null ; m dtm Ident . set Element At ( dtm Identity , NUM ) ; m wsfilter = white Space Filter ; m xstrf = xstringfactory ; m indexing = do Indexing ; if ( do Indexing ) { m expanded Name Table = new Expanded Name Table ( ) ; } else { m expanded Name Table = m mgr Default . get Expanded Name Table ( this ) ; } if ( null != white Space Filter ) { m should Strip Whitespace Stack = new Bool Stack ( ) ; push Should Strip Whitespace ( BOOL ) ; } }
private boolean less Than Or Equal ( byte [ ] a , byte [ ] b ) { int len = Math . min ( a . length , b . length ) ; for ( int i = NUM ; i != len ; ++ i ) { if ( a [ i ] != b [ i ] ) { return ( a [ i ] & NUM ) < ( b [ i ] & NUM ) ; } } return len == a . length ; }
protected void clear ( ) { parts . clear ( ) ; }
public static boolean is Number ( String s ) { try { Integer . value Of ( s ) ; return BOOL ; } catch ( Exception e ) { return BOOL ; } }
private boolean is Outer G State ( ) { return mG State Stack . size ( ) == NUM ; }
public void test Case 24 ( ) { byte r Bytes [ ] = { NUM } ; Big Integer a Number = Big Integer . ONE ; Big Integer b Number = Big Integer . ONE ; Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( NUM , result . signum ( ) ) ; }
void add ( Super Card Toast super Card Toast ) { m List . add ( super Card Toast ) ; }
static public Tasker create ( ) { return new Tasker ( ) ; }
public static String concern Stack String ( Block Info block Info ) { String result = STRING ; for ( String stack Entry : block Info . thread Stack Entries ) { if ( Character . is Letter ( stack Entry . char At ( NUM ) ) ) { String [ ] lines = stack Entry . split ( Block Info . SEPARATOR ) ; for ( String line : lines ) { String key Stack String = concern Stack String ( line ) ; if ( key Stack String != null ) { return key Stack String ; } } return class Simple Name ( lines [ NUM ] ) ; } } return result ; }
static String gravity To String ( @ Edge Gravity int gravity ) { if ( ( gravity & Gravity . LEFT ) == Gravity . LEFT ) { return STRING ; } if ( ( gravity & Gravity . RIGHT ) == Gravity . RIGHT ) { return STRING ; } if ( ( gravity & Gravity . BOTTOM ) == Gravity . BOTTOM ) { return STRING ; } return Integer . to Hex String ( gravity ) ; }
public void remove All Renderers ( ) { m Renderers . clear ( ) ; }
public static int write Speex Header ( byte [ ] buf , int offset , int sample Rate , int mode , int channels , boolean vbr , int nframes , int packetlength ) { write String ( buf , offset , STRING ) ; write String ( buf , offset + NUM , STRING ) ; System . arraycopy ( new byte [ NUM ] , NUM , buf , offset + NUM , NUM ) ; write Int ( buf , offset + NUM , NUM ) ; write Int ( buf , offset + NUM , NUM ) ; write Int ( buf , offset + NUM , sample Rate ) ; write Int ( buf , offset + NUM , mode ) ; write Int ( buf , offset + NUM , NUM ) ; write Int ( buf , offset + NUM , channels ) ; write Int ( buf , offset + NUM , - NUM ) ; write Int ( buf , offset + NUM , NUM << mode ) ; write Int ( buf , offset + NUM , vbr ? NUM : NUM ) ; write Int ( buf , offset + NUM , nframes ) ; write Int ( buf , offset + NUM , NUM ) ; write Int ( buf , offset + NUM , packetlength ) ; write Int ( buf , offset + NUM , NUM ) ; return NUM ; }
private static File ignite Hadoop Config ( String ignite Home ) { Path path = Paths . get ( ignite Home , STRING , STRING , STRING ) ; if ( ! Files . exists ( path ) ) path = Paths . get ( ignite Home , STRING , STRING ) ; if ( Files . exists ( path ) ) return path . to File ( ) ; else return new File ( ignite Home , STRING ) ; }
private static void attempt Retry On Exception ( String log Prefix , Request < ? > request , Volley Error exception ) throws Volley Error { Retry Policy retry Policy = request . get Retry Policy ( ) ; int old Timeout = request . get Timeout Ms ( ) ; try { retry Policy . retry ( exception ) ; } catch ( Volley Error e ) { request . add Marker ( String . format ( STRING , log Prefix , old Timeout ) ) ; throw e ; } request . add Marker ( String . format ( STRING , log Prefix , old Timeout ) ) ; }
protected Approximation Line conservative Knn Distance Approximation ( int k max ) { int k 0 = k max ; double y 1 = Double . NEGATIVE INFINITY ; double y kmax = Double . NEGATIVE INFINITY ; for ( int i = NUM ; i < get Num Entries ( ) ; i ++ ) { Mk Co P Entry entry = get Entry ( i ) ; Approximation Line approx = entry . get Conservative Knn Distance Approximation ( ) ; k 0 = Math . min ( approx . get K 0 ( ) , k 0 ) ; } for ( int i = NUM ; i < get Num Entries ( ) ; i ++ ) { Mk Co P Entry entry = get Entry ( i ) ; Approximation Line approx = entry . get Conservative Knn Distance Approximation ( ) ; double entry y 1 = approx . get Value At ( k 0 ) ; double entry y kmax = approx . get Value At ( k max ) ; if ( ! Double . is Infinite ( entry y 1 ) ) { y 1 = Math . max ( entry y 1 , y 1 ) ; } if ( ! Double . is Infinite ( entry y kmax ) ) { y kmax = Math . max ( entry y kmax , y kmax ) ; } } double m = ( y kmax - y 1 ) / ( Math . log ( k max ) - Math . log ( k 0 ) ) ; double t = y 1 - m * Math . log ( k 0 ) ; return new Approximation Line ( k 0 , m , t ) ; }
public final boolean shares layer ( Brd Item p other ) { int max first layer = Math . max ( first layer ( ) , p other . first layer ( ) ) ; int min last layer = Math . min ( last layer ( ) , p other . last layer ( ) ) ; return max first layer <= min last layer ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
@ Override public String to String ( ) { return buf . to String ( ) ; }
public Coap Client ( URI uri ) { this ( uri . to String ( ) ) ; }
private void zero ( ) throws JSON Exception { if ( probe ) { log ( NUM ) ; } write ( NUM , NUM ) ; }
public static boolean been Done ( Time Unit time Unit , long amount , String tag , Count Checker number Of Times ) { long time In Millis = time Unit . to Millis ( amount ) ; return been Done ( time In Millis , tag , number Of Times ) ; }
public static String normalize ( String oid ) { return oid . starts With ( STRING ) ? oid . substring ( NUM ) : oid ; }
public Rtcp Packet parse Rtcp Packet ( Packet packet ) { Rtcp Compound Packet compound Packet = new Rtcp Compound Packet ( packet ) ; Vector < Rtcp Packet > subpackets = new Vector < Rtcp Packet > ( ) ; Data Input Stream in = new Data Input Stream ( new Byte Array Input Stream ( compound Packet . data , compound Packet . offset , compound Packet . length ) ) ; try { rtcp Session . updateavgrtcpsize ( compound Packet . length ) ; int length = NUM ; for ( int offset = NUM ; offset < compound Packet . length ; offset += length ) { int firstbyte = in . read Unsigned Byte ( ) ; if ( ( firstbyte & NUM ) != NUM ) { return null ; } int type = in . read Unsigned Byte ( ) ; length = in . read Unsigned Short ( ) ; length = length + NUM << NUM ; int padlen = NUM ; if ( offset + length > compound Packet . length ) { return null ; } if ( offset + length == compound Packet . length ) { if ( ( firstbyte & NUM ) != NUM ) { padlen = compound Packet . data [ compound Packet . offset + compound Packet . length - NUM ] & NUM ; if ( padlen == NUM ) { return null ; } } } else if ( ( firstbyte & NUM ) != NUM ) { return null ; } int inlength = length - padlen ; firstbyte &= NUM ; Rtcp Packet subpacket ; switch ( type ) { case Rtcp Packet . RTCP SR : stats . num Sr Pkts ++ ; if ( inlength != NUM + NUM * firstbyte ) { stats . num Malformed Rtcp Pkts ++ ; return null ; } Rtcp Sender Report Packet srp = new Rtcp Sender Report Packet ( compound Packet ) ; subpacket = srp ; srp . ssrc = in . read Int ( ) ; srp . ntptimestampmsw = ( long ) in . read Int ( ) & NUM ; srp . ntptimestamplsw = ( long ) in . read Int ( ) & NUM ; srp . rtptimestamp = ( long ) in . read Int ( ) & NUM ; srp . packetcount = ( long ) in . read Int ( ) & NUM ; srp . octetcount = ( long ) in . read Int ( ) & NUM ; srp . reports = new Rtcp Report [ firstbyte ] ; Rtp Source source SR = rtcp Session . get My Source ( ) ; if ( source SR != null ) { source SR . received Sender Report ( srp ) ; } for ( int i = NUM ; i < srp . reports . length ; i ++ ) { Rtcp Report report = new Rtcp Report ( ) ; srp . reports [ i ] = report ; report . ssrc = in . read Int ( ) ; long val = in . read Int ( ) ; val &= NUM ; report . fractionlost = ( int ) ( val > > NUM ) ; report . packetslost = ( int ) ( val & NUM ) ; report . lastseq = ( long ) in . read Int ( ) & NUM ; report . jitter = in . read Int ( ) ; report . lsr = ( long ) in . read Int ( ) & NUM ; report . dlsr = ( long ) in . read Int ( ) & NUM ; } notify Rtcp Listeners ( new Rtcp Sender Report Event ( srp ) ) ; break ; case Rtcp Packet . RTCP RR : if ( inlength != NUM + NUM * firstbyte ) { stats . num Malformed Rtcp Pkts ++ ; return null ; } Rtcp Receiver Report Packet rrp = new Rtcp Receiver Report Packet ( compound Packet ) ; subpacket = rrp ; rrp . ssrc = in . read Int ( ) ; rrp . reports = new Rtcp Report [ firstbyte ] ; for ( int i = NUM ; i < rrp . reports . length ; i ++ ) { Rtcp Report report = new Rtcp Report ( ) ; rrp . reports [ i ] = report ; report . ssrc = in . read Int ( ) ; long val = in . read Int ( ) ; val &= NUM ; report . fractionlost = ( int ) ( val > > NUM ) ; report . packetslost = ( int ) ( val & NUM ) ; report . lastseq = ( long ) in . read Int ( ) & NUM ; report . jitter = in . read Int ( ) ; report . lsr = ( long ) in . read Int ( ) & NUM ; report . dlsr = ( long ) in . read Int ( ) & NUM ; } notify Rtcp Listeners ( new Rtcp Receiver Report Event ( rrp ) ) ; break ; case Rtcp Packet . RTCP SDES : Rtcp Sdes Packet sdesp = new Rtcp Sdes Packet ( compound Packet ) ; subpacket = sdesp ; sdesp . sdes = new Rtcp Sdes Block [ firstbyte ] ; int sdesoff = NUM ; for ( int i = NUM ; i < sdesp . sdes . length ; i ++ ) { Rtcp Sdes Block chunk = new Rtcp Sdes Block ( ) ; sdesp . sdes [ i ] = chunk ; chunk . ssrc = in . read Int ( ) ; sdesoff += NUM ; Vector < Rtcp Sdes Item > items = new Vector < Rtcp Sdes Item > ( ) ; boolean gotcname = BOOL ; int j ; while ( ( j = in . read Unsigned Byte ( ) ) != NUM ) { if ( j < NUM || j > NUM ) { stats . num Malformed Rtcp Pkts ++ ; return null ; } if ( j == NUM ) { gotcname = BOOL ; } Rtcp Sdes Item item = new Rtcp Sdes Item ( ) ; items . add Element ( item ) ; item . type = j ; int sdeslen = in . read Unsigned Byte ( ) ; item . data = new byte [ sdeslen ] ; in . read Fully ( item . data ) ; sdesoff += NUM + sdeslen ; } if ( ! gotcname ) { stats . num Malformed Rtcp Pkts ++ ; return null ; } chunk . items = new Rtcp Sdes Item [ items . size ( ) ] ; items . copy Into ( chunk . items ) ; if ( ( sdesoff & NUM ) != NUM ) { if ( in . skip ( NUM - ( sdesoff & NUM ) ) != NUM - ( sdesoff & NUM ) ) { return null ; } sdesoff = sdesoff + NUM & - NUM ; } } if ( inlength != sdesoff ) { stats . num Malformed Rtcp Pkts ++ ; return null ; } notify Rtcp Listeners ( new Rtcp Sdes Event ( sdesp ) ) ; break ; case Rtcp Packet . RTCP BYE : Rtcp Bye Packet byep = new Rtcp Bye Packet ( compound Packet ) ; subpacket = byep ; byep . ssrc = new int [ firstbyte ] ; for ( int i = NUM ; i < byep . ssrc . length ; i ++ ) { byep . ssrc [ i ] = in . read Int ( ) ; } int reasonlen ; if ( inlength > NUM + NUM * firstbyte ) { reasonlen = in . read Unsigned Byte ( ) ; byep . reason = new byte [ reasonlen ] ; reasonlen ++ ; } else { reasonlen = NUM ; byep . reason = new byte [ NUM ] ; } reasonlen = reasonlen + NUM & - NUM ; if ( inlength != NUM + NUM * firstbyte + reasonlen ) { stats . num Malformed Rtcp Pkts ++ ; return null ; } in . read Fully ( byep . reason ) ; int skip Bye = reasonlen - byep . reason . length ; if ( in . skip ( skip Bye ) != skip Bye ) { return null ; } notify Rtcp Listeners ( new Rtcp Bye Event ( byep ) ) ; break ; case Rtcp Packet . RTCP APP : if ( inlength < NUM ) { return null ; } Rtcp App Packet appp = new Rtcp App Packet ( compound Packet ) ; subpacket = appp ; appp . ssrc = in . read Int ( ) ; appp . name = in . read Int ( ) ; appp . subtype = firstbyte ; appp . data = new byte [ inlength - NUM ] ; in . read Fully ( appp . data ) ; int skip App = inlength - NUM - appp . data . length ; if ( in . skip ( skip App ) != skip App ) { return null ; } notify Rtcp Listeners ( new Rtcp Application Event ( appp ) ) ; break ; default : stats . num Unknown Types ++ ; return null ; } subpacket . offset = offset ; subpacket . length = length ; subpackets . add Element ( subpacket ) ; if ( in . skip Bytes ( padlen ) != padlen ) { return null ; } } } catch ( Exception e ) { return null ; } compound Packet . packets = new Rtcp Packet [ subpackets . size ( ) ] ; subpackets . copy Into ( compound Packet . packets ) ; return compound Packet ; }
public void reset ( ) { initialize ( ) ; }
private static void add Listeners For Real ( final Service service , final Set < Listener > existing Listeners , final Listener listener , final Executor executor ) { if ( ! existing Listeners . contains ( listener ) ) { existing Listeners . add ( listener ) ; service . add Listener ( listener , executor ) ; } }
public void prepend ( Char Sequence s ) { text . insert ( NUM , s ) ; }
public static void send Response With Status ( Http Servlet Request request , Http Servlet Response response , Print Writer out , String idp Meta Alias , String idp Entity ID , String realm , Authn Request authn Req , String relay State , String sp Entity ID , String firstlevel Status Code Value , String secondlevel Status Code Value ) throws SAML 2 Exception { Response res = SAML 2 Utils . get Error Response ( authn Req , firstlevel Status Code Value , secondlevel Status Code Value , null , idp Entity ID ) ; String Buffer returned Binding = new String Buffer ( ) ; String acs URL = IDPSSO Util . get AC Surl ( sp Entity ID , realm , authn Req , request , returned Binding ) ; String acs Binding = returned Binding . to String ( ) ; send Response ( request , response , out , acs Binding , sp Entity ID , idp Entity ID , idp Meta Alias , realm , relay State , acs URL , res , null ) ; }
protected void validate DT Dattribute ( Q Name element , String att Value , XML Attribute Decl attribute Decl ) throws XNI Exception { switch ( attribute Decl . simple Type . type ) { case XML Simple Type . TYPE ENTITY : { boolean is Alist Attribute = attribute Decl . simple Type . list ; try { if ( is Alist Attribute ) { f Val ENTITIES . validate ( att Value , f Validation State ) ; } else { f Val ENTITY . validate ( att Value , f Validation State ) ; } } catch ( Invalid Datatype Value Exception ex ) { f Error Reporter . report Error ( XML Message Formatter . XML DOMAIN , ex . get Key ( ) , ex . get Args ( ) , XML Error Reporter . SEVERITY ERROR ) ; } break ; } case XML Simple Type . TYPE NOTATION : case XML Simple Type . TYPE ENUMERATION : { boolean found = BOOL ; String [ ] enum Vals = attribute Decl . simple Type . enumeration ; if ( enum Vals == null ) { found = BOOL ; } else for ( int i = NUM ; i < enum Vals . length ; i ++ ) { if ( att Value == enum Vals [ i ] || att Value . equals ( enum Vals [ i ] ) ) { found = BOOL ; break ; } } if ( ! found ) { String Buffer enum Value String = new String Buffer ( ) ; if ( enum Vals != null ) for ( int i = NUM ; i < enum Vals . length ; i ++ ) { enum Value String . append ( enum Vals [ i ] + STRING ) ; } f Error Reporter . report Error ( XML Message Formatter . XML DOMAIN , STRING , new Object [ ] { attribute Decl . name . rawname , att Value , enum Value String } , XML Error Reporter . SEVERITY ERROR ) ; } break ; } case XML Simple Type . TYPE ID : { try { f Val ID . validate ( att Value , f Validation State ) ; } catch ( Invalid Datatype Value Exception ex ) { f Error Reporter . report Error ( XML Message Formatter . XML DOMAIN , ex . get Key ( ) , ex . get Args ( ) , XML Error Reporter . SEVERITY ERROR ) ; } break ; } case XML Simple Type . TYPE IDREF : { boolean is Alist Attribute = attribute Decl . simple Type . list ; try { if ( is Alist Attribute ) { f Val ID Refs . validate ( att Value , f Validation State ) ; } else { f Val ID Ref . validate ( att Value , f Validation State ) ; } } catch ( Invalid Datatype Value Exception ex ) { if ( is Alist Attribute ) { f Error Reporter . report Error ( XML Message Formatter . XML DOMAIN , STRING , new Object [ ] { att Value } , XML Error Reporter . SEVERITY ERROR ) ; } else { f Error Reporter . report Error ( XML Message Formatter . XML DOMAIN , ex . get Key ( ) , ex . get Args ( ) , XML Error Reporter . SEVERITY ERROR ) ; } } break ; } case XML Simple Type . TYPE NMTOKEN : { boolean is Alist Attribute = attribute Decl . simple Type . list ; try { if ( is Alist Attribute ) { f Val NMTOKENS . validate ( att Value , f Validation State ) ; } else { f Val NMTOKEN . validate ( att Value , f Validation State ) ; } } catch ( Invalid Datatype Value Exception ex ) { if ( is Alist Attribute ) { f Error Reporter . report Error ( XML Message Formatter . XML DOMAIN , STRING , new Object [ ] { att Value } , XML Error Reporter . SEVERITY ERROR ) ; } else { f Error Reporter . report Error ( XML Message Formatter . XML DOMAIN , STRING , new Object [ ] { att Value } , XML Error Reporter . SEVERITY ERROR ) ; } } break ; } } }
public static double mean 2 ( Connection conn , double ... values ) { conn . get Class ( ) ; double sum = NUM ; for ( double x : values ) { sum += x ; } return sum / values . length ; }
public boolean has Long Column Info ( ) { return this . has Long Column Info ; }
public static String dom To String ( Document dom Doc ) { return dom To String ( dom Doc . get Document Element ( ) , BOOL ) ; }
public static < T > T assert And Cast ( Class < ? extends T > clazz , Object o ) { assert Not Null ( clazz ) ; assert Not Null ( o ) ; assert True ( clazz . is Instance ( o ) ) ; return clazz . cast ( o ) ; }
private String create Mismatch Message ( String mismatch , Migration Version version , Object applied , Object resolved ) { return String . format ( STRING + mismatch + STRING + STRING + STRING , version , applied , resolved ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return IDS ; default : return null ; } }
public int compare To ( Object o ) { Split split = ( Split ) o ; Bit Set P = get First Part ( ) ; Bit Set Q = split . get First Part ( ) ; int a = P . next Set Bit ( NUM ) ; int b = Q . next Set Bit ( NUM ) ; while ( a > - NUM && b > - NUM ) { if ( a < b ) return - NUM ; else if ( a > b ) return NUM ; a = P . next Set Bit ( a + NUM ) ; b = Q . next Set Bit ( b + NUM ) ; } if ( a < b ) return - NUM ; else if ( a > b ) return NUM ; P = get Second Part ( ) ; Q = split . get Second Part ( ) ; a = P . next Set Bit ( NUM ) ; b = Q . next Set Bit ( NUM ) ; while ( a > - NUM && b > - NUM ) { if ( a < b ) return - NUM ; else if ( a > b ) return NUM ; a = P . next Set Bit ( a + NUM ) ; b = Q . next Set Bit ( b + NUM ) ; } if ( a < b ) return - NUM ; else if ( a > b ) return NUM ; else return NUM ; }
public boolean is Matching Talkgroup ( LTR Net Message message ) { String talkgroup = message . get Talkgroup ID ( ) ; if ( talkgroup != null && get To ID ( ) != null && talkgroup . content Equals ( get To ID ( ) ) ) { return BOOL ; } return is Matching Talkgroup ( message . get Talkgroup ID ( ) ) ; }
public void put ( byte [ ] source , int index , int length ) { if ( m Buffer . capacity ( ) < ( m Length + length ) ) { expand Buffer ( m Length + length + ADDITIONAL BUFFER SIZE ) ; } m Buffer . put ( source , index , length ) ; m Length += length ; }
public void test Set Bit Negative Inside 4 ( ) { String as = STRING ; int number = NUM ; Big Integer a Number = new Big Integer ( as ) ; Big Integer result = a Number . set Bit ( number ) ; assert Equals ( as , result . to String ( ) ) ; }
public Shape model To View ( int pos , Shape a , Position . Bias b ) throws Bad Location Exception { return m view . model To View ( pos , a , b ) ; }
private static int apply Precision ( int dec Exp , char [ ] digits , int n Digits , int prec ) { if ( prec >= n Digits || prec < NUM ) { return dec Exp ; } if ( prec == NUM ) { if ( digits [ NUM ] >= STRING ) { digits [ NUM ] = STRING ; Arrays . fill ( digits , NUM , n Digits , STRING ) ; return dec Exp + NUM ; } else { Arrays . fill ( digits , NUM , n Digits , STRING ) ; return dec Exp ; } } int q = digits [ prec ] ; if ( q >= STRING ) { int i = prec ; q = digits [ -- i ] ; if ( q == STRING ) { while ( q == STRING && i > NUM ) { q = digits [ -- i ] ; } if ( q == STRING ) { digits [ NUM ] = STRING ; Arrays . fill ( digits , NUM , n Digits , STRING ) ; return dec Exp + NUM ; } } digits [ i ] = ( char ) ( q + NUM ) ; Arrays . fill ( digits , i + NUM , n Digits , STRING ) ; } else { Arrays . fill ( digits , prec , n Digits , STRING ) ; } return dec Exp ; }
protected void draw Cubic ( Canvas c , Line Data Set data Set , List < Entry > entries ) { Transformer trans = m Chart . get Transformer ( data Set . get Axis Dependency ( ) ) ; Entry entry From = data Set . get Entry For X Index ( m Min X ) ; Entry entry To = data Set . get Entry For X Index ( m Max X ) ; int diff = ( entry From == entry To ) ? NUM : NUM ; int minx = Math . max ( data Set . get Entry Position ( entry From ) - diff , NUM ) ; int maxx = Math . min ( Math . max ( minx + NUM , data Set . get Entry Position ( entry To ) + NUM ) , entries . size ( ) ) ; float phase X = m Animator . get Phase X ( ) ; float phase Y = m Animator . get Phase Y ( ) ; float intensity = data Set . get Cubic Intensity ( ) ; cubic Path . reset ( ) ; int size = ( int ) Math . ceil ( ( maxx - minx ) * phase X + minx ) ; if ( size - minx >= NUM ) { float prev Dx = NUM ; float prev Dy = NUM ; float cur Dx = NUM ; float cur Dy = NUM ; Entry prev Prev = entries . get ( minx ) ; Entry prev = entries . get ( minx ) ; Entry cur = entries . get ( minx ) ; Entry next = entries . get ( minx + NUM ) ; cubic Path . move To ( cur . get X Index ( ) , cur . get Val ( ) * phase Y ) ; prev Dx = ( cur . get X Index ( ) - prev . get X Index ( ) ) * intensity ; prev Dy = ( cur . get Val ( ) - prev . get Val ( ) ) * intensity ; cur Dx = ( next . get X Index ( ) - cur . get X Index ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - cur . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get X Index ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get X Index ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get X Index ( ) , cur . get Val ( ) * phase Y ) ; for ( int j = minx + NUM , count = Math . min ( size , entries . size ( ) - NUM ) ; j < count ; j ++ ) { prev Prev = entries . get ( j == NUM ? NUM : j - NUM ) ; prev = entries . get ( j - NUM ) ; cur = entries . get ( j ) ; next = entries . get ( j + NUM ) ; prev Dx = ( cur . get X Index ( ) - prev Prev . get X Index ( ) ) * intensity ; prev Dy = ( cur . get Val ( ) - prev Prev . get Val ( ) ) * intensity ; cur Dx = ( next . get X Index ( ) - prev . get X Index ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - prev . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get X Index ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get X Index ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get X Index ( ) , cur . get Val ( ) * phase Y ) ; } if ( size > entries . size ( ) - NUM ) { prev Prev = entries . get ( ( entries . size ( ) >= NUM ) ? entries . size ( ) - NUM : entries . size ( ) - NUM ) ; prev = entries . get ( entries . size ( ) - NUM ) ; cur = entries . get ( entries . size ( ) - NUM ) ; next = cur ; prev Dx = ( cur . get X Index ( ) - prev Prev . get X Index ( ) ) * intensity ; prev Dy = ( cur . get Val ( ) - prev Prev . get Val ( ) ) * intensity ; cur Dx = ( next . get X Index ( ) - prev . get X Index ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - prev . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get X Index ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get X Index ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get X Index ( ) , cur . get Val ( ) * phase Y ) ; } } if ( data Set . is Draw Filled Enabled ( ) ) { cubic Fill Path . reset ( ) ; cubic Fill Path . add Path ( cubic Path ) ; draw Cubic Fill ( m Bitmap Canvas , data Set , cubic Fill Path , trans , entry From . get X Index ( ) , entry From . get X Index ( ) + size ) ; } m Render Paint . set Color ( data Set . get Color ( ) ) ; m Render Paint . set Style ( Paint . Style . STROKE ) ; trans . path Value To Pixel ( cubic Path ) ; m Bitmap Canvas . draw Path ( cubic Path , m Render Paint ) ; m Render Paint . set Path Effect ( null ) ; }
public void delete ( @ Non Null Key key ) { final Reentrant Read Write Lock . Write Lock lock = guard . write Lock ( ) ; lock . lock ( ) ; try { if ( ! read Keys . remove ( key ) ) throw new Illegal Argument Exception ( STRING ) ; Files . delete ( key . get File ( ) ) ; } catch ( IO Exception ex ) { LOG . log ( Level . WARNING , STRING + key . get File ( ) , ex ) ; } finally { lock . unlock ( ) ; } }
protected Object to Type ( Calendar value ) { return value . get Time ( ) ; }
public boolean on Touch Event ( Motion Event event ) { try { int pointer Count = multi Touch Supported ? ( Integer ) m get Pointer Count . invoke ( event ) : NUM ; if ( DEBUG ) Log . i ( STRING , STRING + multi Touch Supported + STRING + m Mode + STRING + handle Single Touch Events + STRING + pointer Count ) ; if ( m Mode == MODE NOTHING && ! handle Single Touch Events && pointer Count == NUM ) return BOOL ; if ( DEBUG ) Log . i ( STRING , STRING ) ; int action = event . get Action ( ) ; int hist Len = event . get History Size ( ) / pointer Count ; for ( int hist Idx = NUM ; hist Idx <= hist Len ; hist Idx ++ ) { boolean processing Hist = hist Idx < hist Len ; if ( ! multi Touch Supported || pointer Count == NUM ) { if ( DEBUG ) Log . i ( STRING , STRING ) ; x Vals [ NUM ] = processing Hist ? event . get Historical X ( hist Idx ) : event . get X ( ) ; y Vals [ NUM ] = processing Hist ? event . get Historical Y ( hist Idx ) : event . get Y ( ) ; pressure Vals [ NUM ] = processing Hist ? event . get Historical Pressure ( hist Idx ) : event . get Pressure ( ) ; } else { if ( DEBUG ) Log . i ( STRING , STRING ) ; int num Pointers = Math . min ( pointer Count , MAX TOUCH POINTS ) ; if ( DEBUG && pointer Count > MAX TOUCH POINTS ) Log . i ( STRING , STRING ) ; for ( int ptr Idx = NUM ; ptr Idx < num Pointers ; ptr Idx ++ ) { int ptr Id = ( Integer ) m get Pointer Id . invoke ( event , ptr Idx ) ; pointer Ids [ ptr Idx ] = ptr Id ; x Vals [ ptr Idx ] = ( Float ) ( processing Hist ? m get Historical X . invoke ( event , ptr Idx , hist Idx ) : m get X . invoke ( event , ptr Idx ) ) ; y Vals [ ptr Idx ] = ( Float ) ( processing Hist ? m get Historical Y . invoke ( event , ptr Idx , hist Idx ) : m get Y . invoke ( event , ptr Idx ) ) ; pressure Vals [ ptr Idx ] = ( Float ) ( processing Hist ? m get Historical Pressure . invoke ( event , ptr Idx , hist Idx ) : m get Pressure . invoke ( event , ptr Idx ) ) ; } } decode Touch Event ( pointer Count , x Vals , y Vals , pressure Vals , pointer Ids , processing Hist ? Motion Event . ACTION MOVE : action , processing Hist ? BOOL : action != Motion Event . ACTION UP && ( action & ( ( NUM << ACTION POINTER INDEX SHIFT ) - NUM ) ) != ACTION POINTER UP && action != Motion Event . ACTION CANCEL , processing Hist ? event . get Historical Event Time ( hist Idx ) : event . get Event Time ( ) ) ; } return BOOL ; } catch ( Exception e ) { Log . e ( STRING , STRING , e ) ; return BOOL ; } }
public static void store Location ( Context context , Lat Lng location ) { Shared Preferences prefs = Preference Manager . get Default Shared Preferences ( context ) ; Shared Preferences . Editor editor = prefs . edit ( ) ; editor . put Long ( PREFERENCES LAT , Double . double To Raw Long Bits ( location . latitude ) ) ; editor . put Long ( PREFERENCES LNG , Double . double To Raw Long Bits ( location . longitude ) ) ; editor . apply ( ) ; }
public void write To File ( String file Name ) throws IO Exception { Print Writer outfile = new Print Writer ( new File Output Stream ( file Name ) ) ; outfile . println ( STRING ) ; outfile . println ( STRING ) ; outfile . println ( STRING + m nbins ) ; outfile . println ( STRING + m min ) ; outfile . println ( STRING + m max ) ; outfile . println ( STRING + m entries ) ; outfile . println ( STRING + m underflow ) ; outfile . println ( STRING + m overflow ) ; outfile . println ( STRING ) ; for ( int i = NUM ; i < m nbins ; i ++ ) { outfile . println ( i + STRING + m bin Centers [ i ] + STRING + m hist [ i ] ) ; } outfile . println ( STRING ) ; outfile . close ( ) ; }
public void outdent ( ) { final int length = indent . length ( ) ; if ( length == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } indent . delete ( length - NUM , length ) ; }
public static String extract From Data Matrix ( String code ) { if ( code . length ( ) < NUM ) { return null ; } if ( code . starts With ( STRING ) ) { return code . substring ( NUM , NUM ) ; } return null ; }
public void paint Current Value ( Graphics g , Rectangle bounds , boolean has Focus ) { XP Style xp = XP Style . get XP ( ) ; if ( xp != null ) { bounds . x += NUM ; bounds . y += NUM ; bounds . width -= NUM ; bounds . height -= NUM ; } else { bounds . x += NUM ; bounds . y += NUM ; bounds . width -= NUM ; bounds . height -= NUM ; } if ( ! combo Box . is Editable ( ) && xp != null && xp . is Skin Defined ( combo Box , Part . CP READONLY ) ) { List Cell Renderer renderer = combo Box . get Renderer ( ) ; Component c ; if ( has Focus && ! is Popup Visible ( combo Box ) ) { c = renderer . get List Cell Renderer Component ( list Box , combo Box . get Selected Item ( ) , - NUM , BOOL , BOOL ) ; } else { c = renderer . get List Cell Renderer Component ( list Box , combo Box . get Selected Item ( ) , - NUM , BOOL , BOOL ) ; } c . set Font ( combo Box . get Font ( ) ) ; if ( combo Box . is Enabled ( ) ) { c . set Foreground ( combo Box . get Foreground ( ) ) ; c . set Background ( combo Box . get Background ( ) ) ; } else { c . set Foreground ( Default Lookup . get Color ( combo Box , this , STRING , null ) ) ; c . set Background ( Default Lookup . get Color ( combo Box , this , STRING , null ) ) ; } boolean should Validate = BOOL ; if ( c instanceof J Panel ) { should Validate = BOOL ; } current Value Pane . paint Component ( g , c , combo Box , bounds . x , bounds . y , bounds . width , bounds . height , should Validate ) ; } else { super . paint Current Value ( g , bounds , has Focus ) ; } }
@ Override public Audio Input Stream synthesise One Section ( String festival Utt , Voice voice ) throws IO Exception { write Relation Files ( festival Utt ) ; File audio File = new File ( festival Dir . get Path ( ) + File . separator + STRING ) ; String festival Voice Cmd = STRING + voice . get Name ( ) + STRING ; Audio Input Stream sound = festival Synthesise ( audio File , festival Voice Cmd ) ; return sound ; }
JSON Stringer close ( Scope empty , Scope nonempty , String close Bracket ) throws JSON Exception { Scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new JSON Exception ( STRING ) ; } stack . remove ( stack . size ( ) - NUM ) ; if ( context == nonempty ) { newline ( ) ; } out . append ( close Bracket ) ; return this ; }
public int read ( byte [ ] buffer , int offset , int length ) throws IO Exception { log . finest ( STRING + Long . to Hex String ( get File Pointer ( ) ) + STRING + length + STRING ) ; return file . read ( buffer , offset , length ) ; }
public static Pattern create Pattern ( String [ ] patterns , boolean is Case Sensitive , boolean is Regex Search ) throws Pattern Syntax Exception { String Buffer pattern = new String Buffer ( ) ; for ( int i = NUM ; i < patterns . length ; i ++ ) { if ( i > NUM ) { pattern . append ( STRING ) ; } if ( is Regex Search ) { pattern . append ( patterns [ i ] ) ; } else { as Reg Ex ( patterns [ i ] , pattern ) ; } } return create Pattern ( pattern . to String ( ) , is Case Sensitive , BOOL ) ; }
public void add Arc ( float lat Point , float lon Point , int w , int h , float s , float e , Link Properties properties ) throws IO Exception { Link Arc . write ( lat Point , lon Point , NUM , NUM , w , h , s , e , properties , link . dos ) ; }
public void on Undeploy ( Class Loader ldr ) { for ( Class < ? > cls : desc By Cls . key Set ( ) ) { if ( ldr . equals ( cls . get Class Loader ( ) ) ) desc By Cls . remove ( cls ) ; } U . clear Class Cache ( ldr ) ; }
@ Override public boolean contains Class ( String class Name ) throws IO Exception { boolean contains Class = BOOL ; String resource Name = STRING + class Name . replace ( STRING , STRING ) + STRING ; if ( get Resource ( resource Name ) != null ) { contains Class = BOOL ; } for ( String resource : get Resources ( STRING ) ) { Jar Archive jar = new Default Jar Archive ( get Resource ( resource ) ) ; if ( jar . contains Class ( class Name ) ) { contains Class = BOOL ; } } return contains Class ; }
public Tuple [ ] clear Internal ( ) { Tuple [ ] t = new Tuple [ get Tuple Count ( ) ] ; Iterator iter = tuples ( ) ; for ( int i = NUM ; iter . has Next ( ) ; ++ i ) { t [ i ] = ( Tuple ) iter . next ( ) ; } m tuples . clear ( ) ; return t ; }
public synchronized void remove Text Listener ( Text Listener cl ) { m text Listeners . remove ( cl ) ; }
private void ensure Capacity ( int desired Long Count ) { if ( desired Long Count <= bits . length ) { return ; } int new Length = Math . max ( desired Long Count , bits . length * NUM ) ; long [ ] new Bits = new long [ new Length ] ; System . arraycopy ( bits , NUM , new Bits , NUM , long Count ) ; this . bits = new Bits ; }
public boolean matches ( String query , String text ) { return text . contains ( query ) ; }
private void find Collapses From Existing Vertices ( List collapsed Vertex Indexes ) { for ( int i = NUM ; i < edge . size ( ) - NUM ; i ++ ) { Coordinate p0 = edge . get Coordinate ( i ) ; Coordinate p1 = edge . get Coordinate ( i + NUM ) ; Coordinate p2 = edge . get Coordinate ( i + NUM ) ; if ( p0 . equals 2 D ( p2 ) ) { collapsed Vertex Indexes . add ( new Integer ( i + NUM ) ) ; } } }
public void close ( ) throws IO Exception { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING ) ; } try { if ( input File != null ) input File . close ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } input File = null ; }
public static boolean check Pool Properties Changed ( Set < String > existing Value , Set < String > new Value ) { boolean property Changed = BOOL ; if ( existing Value == null && ( new Value != null && ! new Value . is Empty ( ) ) ) { property Changed = BOOL ; } else if ( new Value == null && ( existing Value != null && ! existing Value . is Empty ( ) ) ) { property Changed = BOOL ; } else if ( existing Value != null && new Value != null ) { if ( existing Value . size ( ) != new Value . size ( ) || ! ( existing Value . contains All ( new Value ) ) ) { property Changed = BOOL ; } } return property Changed ; }
public static Output Stream left Shift ( Output Stream self , Input Stream in ) throws IO Exception { byte [ ] buf = new byte [ NUM ] ; while ( BOOL ) { int count = in . read ( buf , NUM , buf . length ) ; if ( count == - NUM ) break ; if ( count == NUM ) { Thread . yield ( ) ; continue ; } self . write ( buf , NUM , count ) ; } self . flush ( ) ; return self ; }
public static boolean git Local Config ( final Atomic Reference < String > path ) throws IO Exception { return git Local Config ( Environment . get Current Directory ( ) , path ) ; }
public void verify ( ) { super . verify ( ) ; assert Equals ( STRING , confirmed , collection ) ; assert Equals ( STRING , confirmed . hash Code ( ) , collection . hash Code ( ) ) ; Collection set = make Confirmed Collection ( ) ; Iterator iterator = collection . iterator ( ) ; while ( iterator . has Next ( ) ) { assert True ( STRING , set . add ( iterator . next ( ) ) ) ; } }
public static CG Point ccp Rotate By Angle ( CG Point v , CG Point pivot , float angle ) { CG Point r = ccp Sub ( v , pivot ) ; float t = r . x ; float cosa = ( float ) Math . cos ( angle ) ; float sina = ( float ) Math . sin ( angle ) ; r . x = t * cosa - r . y * sina ; r . y = t * sina + r . y * cosa ; r = ccp Add ( r , pivot ) ; return r ; }
private void open Context Menu ( Mouse Event e ) { if ( e . is Popup Trigger ( ) ) { Collection < String > streams = new Hash Set < > ( ) ; int [ ] selected Rows = table . get Selected Rows ( ) ; for ( int selected Row : selected Rows ) { Follower selected = followers . get ( selected Row ) ; streams . add ( String Util . to Lower Case ( selected . name ) ) ; } if ( ! streams . is Empty ( ) ) { Streams Context Menu m = new Streams Context Menu ( streams , context Menu Listener ) ; m . show ( table , e . get X ( ) , e . get Y ( ) ) ; } } }
public static Workflow . Method expand Volumes Method ( URI storage , URI pool , URI volume , Long size ) { return new Workflow . Method ( STRING , storage , pool , volume , size ) ; }
void close Silently ( Socket socket ) { try { socket . close ( ) ; } catch ( Exception e ) { } }
public static boolean equals ( byte [ ] array 1 , byte [ ] array 2 ) { if ( array 1 == array 2 ) return BOOL ; if ( array 1 == null || array 2 == null || array 1 . length != array 2 . length ) return BOOL ; for ( int i = NUM ; i < array 1 . length ; i ++ ) { if ( array 1 [ i ] != array 2 [ i ] ) return BOOL ; } return BOOL ; }
private static String create Id From Jndi Location If Not Null ( String jndi Location ) { String id = null ; if ( jndi Location != null ) { id = create Id From Jndi Location ( jndi Location ) ; } return id ; }
protected Set < Node > closure ( Dependency Kind ... dep Kinds ) { boolean progress = BOOL ; Set < Node > closure = new Hash Set < Node > ( ) ; closure . add ( this ) ; while ( progress ) { progress = BOOL ; for ( Node n1 : new Hash Set < Node > ( closure ) ) { progress = closure . add All ( n1 . get Dependencies ( dep Kinds ) ) ; } } return closure ; }
public Vector ( Collection c ) { element Count = c . size ( ) ; element Data = new Object [ ( int ) Math . min ( ( element Count * NUM ) / NUM , Integer . MAX VALUE ) ] ; c . to Array ( element Data ) ; }
private void expand ( int i ) { if ( count + i <= buf . length ) { return ; } byte [ ] newbuf = m Pool . get Buf ( ( count + i ) * NUM ) ; System . arraycopy ( buf , NUM , newbuf , NUM , count ) ; m Pool . return Buf ( buf ) ; buf = newbuf ; }
public static < A extends Annotation > A create Annotation ( Class < ? extends Annotation > annotation Type , Annotation Member [ ] elements ) { Annotation Factory factory = new Annotation Factory ( annotation Type , elements ) ; return ( A ) Proxy . new Proxy Instance ( annotation Type . get Class Loader ( ) , new Class [ ] { annotation Type } , factory ) ; }
public Linking Morphemes ( String ... a Morphemes ) { morphemes = new Array List < String > ( ) ; for ( String string : a Morphemes ) { morphemes . add ( string ) ; } }
@ Override public void execute ( Metric Time Series time Series , Function Value Map function Value Map ) { if ( time Series . size ( ) <= NUM ) { function Value Map . add ( this , Double . Na N ) ; return ; } time Series . sort ( ) ; double first Value = time Series . get Value ( NUM ) ; double last Value = time Series . get Value ( time Series . size ( ) - NUM ) ; function Value Map . add ( this , Math . abs ( first Value - last Value ) ) ; }
public static URL [ ] find Resource Bases ( String base Resource , Class Loader loader ) { Array List < URL > list = new Array List < URL > ( ) ; try { Enumeration < URL > urls = loader . get Resources ( base Resource ) ; while ( urls . has More Elements ( ) ) { URL url = urls . next Element ( ) ; list . add ( find Resource Base ( url , base Resource ) ) ; } } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } return list . to Array ( new URL [ list . size ( ) ] ) ; }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int band List [ ] ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . min X ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . min Y ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Byte Banded Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
protected void move Up Item ( ) { if ( selection Table . get Selection Count ( ) == NUM ) { return ; } for ( final int index : selection Table . get Selection Indices ( ) ) { if ( index == NUM ) { selection Table . force Focus ( ) ; return ; } } final int [ ] new Selection = new int [ selection Table . get Selection Count ( ) ] ; int new Selection Index = NUM ; for ( final Table Item table Item : selection Table . get Selection ( ) ) { final int position = selection . index Of ( table Item . get Data ( ) ) ; swap ( position , position - NUM ) ; new Selection [ new Selection Index ++ ] = position - NUM ; } redraw Tables ( ) ; selection Table . select ( new Selection ) ; selection Table . force Focus ( ) ; }
protected void maybe Fire Bounds Invalidated ( Rectangle invalidated Area ) { Drawing d = get Drawing ( ) ; Rectangle 2 D . Double canvas Bounds = new Rectangle 2 D . Double ( NUM , NUM , NUM , NUM ) ; if ( d . get ( CANVAS WIDTH ) != null ) { canvas Bounds . width += d . get ( CANVAS WIDTH ) ; } if ( d . get ( CANVAS HEIGHT ) != null ) { canvas Bounds . height += d . get ( CANVAS HEIGHT ) ; } if ( ! canvas Bounds . contains ( invalidated Area ) ) { fire Bounds Invalidated ( invalidated Area ) ; } }
public Datagram Packet response Receive ( ) throws IO Exception { byte [ ] buf = new byte [ NUM ] ; Datagram Packet dp = new Datagram Packet ( buf , buf . length ) ; datagram Socket . receive ( dp ) ; return dp ; }
public void suspend ( String id ) { Trace State ts = trace State . get ( ) ; if ( log . is Loggable ( Level . FINEST ) ) { log . finest ( STRING + ts + STRING + id ) ; } if ( ts != null ) { set Expire ( ts ) ; try { suspended State Lock . lock ( ) ; if ( suspended State . contains Key ( id ) && log . is Loggable ( Level . FINEST ) ) { log . finest ( STRING + suspended State . get ( id ) + STRING + id ) ; } suspended State . put ( id , ts ) ; trace State . remove ( ) ; } finally { suspended State Lock . unlock ( ) ; } } }
public static int hash Code ( final Object obj ) { return ( obj == null ? NUM : obj . hash Code ( ) ) ; }
public static int max Level ( ) { return LEVELS - NUM ; }
public void property Change ( Property Change Event evt ) { repaint ( ) ; }
public static boolean remove Bean Or Folder ( String path ) { return remove Path ( path . split ( PATH SEPARATOR ) , s directory , NUM ) > NUM ; }
private void update Selection ( Mode mode , Projection 2 D proj , SVG Point p1 , SVG Point p2 ) { DBID Selection sel Context = context . get Selection ( ) ; Hash Set Modifiable DBI Ds selection ; if ( sel Context == null || mode == Mode . REPLACE ) { selection = DBID Util . new Hash Set ( ) ; } else { selection = DBID Util . new Hash Set ( sel Context . get Selected Ids ( ) ) ; } for ( DBID Iter iditer = rel . iter DBI Ds ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { double [ ] vec = proj . fast Project Data To Render Space ( rel . get ( iditer ) ) ; if ( vec [ NUM ] >= Math . min ( p1 . get X ( ) , p2 . get X ( ) ) && vec [ NUM ] <= Math . max ( p1 . get X ( ) , p2 . get X ( ) ) && vec [ NUM ] >= Math . min ( p1 . get Y ( ) , p2 . get Y ( ) ) && vec [ NUM ] <= Math . max ( p1 . get Y ( ) , p2 . get Y ( ) ) ) { if ( mode == Mode . INVERT ) { if ( ! selection . contains ( iditer ) ) { selection . add ( iditer ) ; } else { selection . remove ( iditer ) ; } } else { selection . add ( iditer ) ; } } } context . set Selection ( new DBID Selection ( selection ) ) ; }
public Eclipse Ini Launcher ( File installation Root ) throws File Not Found Exception , IO Exception { File Misc . assert Mac App ( installation Root ) ; Objects . require Non Null ( installation Root ) ; eclipse Ini = Eclipse Ini . parse From ( new File ( installation Root , File Misc . mac Contents Eclipse ( ) + STRING ) ) ; }
public boolean can Add Member ( String realm Name , String id Type , String container ID Type ) throws AM Console Exception { boolean can = BOOL ; try { Id Type type = Id Utils . get Type ( id Type ) ; Set can Add = type . can Add Members ( ) ; Id Type ctype = Id Utils . get Type ( container ID Type ) ; can = can Add . contains ( ctype ) ; } catch ( Id Repo Exception e ) { debug . warning ( STRING , e ) ; throw new AM Console Exception ( get Error String ( e ) ) ; } return can ; }
private static Node locate Attr Parent ( Element elem , Node attr ) { Node parent = null ; Attr check = elem . get Attribute Node ( attr . get Node Name ( ) ) ; if ( check == attr ) parent = elem ; if ( null == parent ) { for ( Node node = elem . get First Child ( ) ; null != node ; node = node . get Next Sibling ( ) ) { if ( Node . ELEMENT NODE == node . get Node Type ( ) ) { parent = locate Attr Parent ( ( Element ) node , attr ) ; if ( null != parent ) break ; } } } return parent ; }
private void define Internal Frames ( UI Defaults d ) { d . put ( STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( STRING , new Dimension UI Resource ( NUM , NUM ) ) ; d . put ( STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( STRING , STRING ) ; d . put ( STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; if ( Platform Utils . is Mac ( ) ) { d . put ( STRING , new Color ( NUM ) ) ; } else { d . put ( STRING , new Color ( NUM ) ) ; } d . put ( STRING , new Color ( NUM ) ) ; d . put ( STRING , new Color ( NUM ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM , BOOL ) ) ; d . put ( STRING , new Color ( NUM ) ) ; String p = STRING ; String c = PAINTER PREFIX + STRING ; d . put ( p + STRING , new Derived Font ( STRING , NUM , BOOL , null ) ) ; d . put ( p + STRING , STRING ) ; d . put ( p + STRING , new Title Pane Window Focused State ( ) ) ; d . put ( p + STRING , new Internal Frame Window Focused State ( ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Frame And Root Painter . Which . BACKGROUND ENABLED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Frame And Root Painter . Which . BACKGROUND ENABLED WINDOWFOCUSED ) ) ; p = STRING ; d . put ( p + STRING , NUM ) ; p = STRING ; d . put ( p + STRING , d . get ( STRING ) ) ; d . put ( p + STRING , Color . BLACK ) ; }
public static double cos Quick ( double angle ) { if ( USE JDK MATH ) { return STRICT MATH ? Strict Math . cos ( angle ) : Math . cos ( angle ) ; } return cos Tab [ ( ( int ) ( Math . abs ( angle ) * SIN COS INDEXER + NUM ) ) & ( SIN COS TABS SIZE - NUM ) ] ; }
public static void w ( String tag , String msg , Object ... args ) { if ( s Level > LEVEL WARNING ) { return ; } if ( args . length > NUM ) { msg = String . format ( msg , args ) ; } Log . w ( tag , msg ) ; }
public void read Security Header ( Sip Response response ) throws Payload Exception { WWW Authenticate Header www Header = ( WWW Authenticate Header ) response . get Header ( WWW Authenticate Header . NAME ) ; Authentication Info Header info Header = ( Authentication Info Header ) response . get Header ( Authentication Info Header . NAME ) ; if ( www Header != null ) { m Digest . set Realm ( www Header . get Realm ( ) ) ; m Digest . set Opaque ( www Header . get Opaque ( ) ) ; m Digest . set Qop ( www Header . get Qop ( ) ) ; m Digest . set Nextnonce ( www Header . get Nonce ( ) ) ; } else if ( info Header != null ) { if ( info Header . get Next Nonce ( ) != null ) { m Digest . set Nextnonce ( info Header . get Next Nonce ( ) ) ; } } }
private void layout Panel ( ) { set Border ( Border Factory . create Empty Border ( NUM , NUM , NUM , NUM ) ) ; set Layout ( new Border Layout ( ) ) ; add ( new Labelled Item ( STRING , cb Distribution ) , Border Layout . NORTH ) ; add ( card Panel , Border Layout . CENTER ) ; cb Item Listener . item State Changed ( new Item Event ( cb Distribution , Item Event . SELECTED , card Panel , Item Event . ITEM STATE CHANGED ) ) ; repaint ( ) ; revalidate ( ) ; }
@ Override public int compare To ( Double Double Pair other ) { int fdiff = Double . compare ( this . first , other . first ) ; if ( fdiff != NUM ) { return fdiff ; } return Double . compare ( this . second , other . second ) ; }
private static boolean file Exists ( String file Path ) { File file = new File ( file Path ) ; return file . exists ( ) ; }
public static String class Version To Jdk ( int version ) { return STRING + Integer . to String ( version - NUM ) ; }
private Bit Set create Bit Set ( final String binary String ) { final Bit Set bset = new Bit Set ( binary String . length ( ) ) ; boolean bit True = BOOL ; for ( int i = NUM ; i < binary String . length ( ) ; i ++ ) { if ( binary String . char At ( i ) == STRING ) { bit True = BOOL ; } else { bit True = BOOL ; } bset . set ( i , bit True ) ; } return bset ; }
public void flush ( ) { buffer . force ( ) ; }
public void remove ( Product product ) { try { solr Dao . remove ( product . get Id ( ) ) ; } catch ( IO Exception | Solr Server Exception ex ) { LOGGER . error ( STRING + product . get Identifier ( ) + STRING , ex ) ; } }
public void start Background Fetch Service ( ) { Local Notification n = new Local Notification ( ) ; n . set Id ( BACKGROUND FETCH NOTIFICATION ID ) ; cancel Local Notification ( BACKGROUND FETCH NOTIFICATION ID ) ; schedule Local Notification ( n , System . current Time Millis ( ) + get Preferred Background Fetch Interval ( ) * NUM , NUM ) ; }
protected void show Models ( boolean show , Epoxy Model < ? > ... models ) { show Models ( Arrays . as List ( models ) , show ) ; }
static void check ( Public Key key , X509 CRL crl ) throws Cert Path Validator Exception { X509 CRL Impl x509 CRL Impl = null ; try { x509 CRL Impl = X509 CRL Impl . to Impl ( crl ) ; } catch ( CRL Exception ce ) { throw new Cert Path Validator Exception ( ce ) ; } Algorithm Id algorithm Id = x509 CRL Impl . get Sig Alg Id ( ) ; check ( key , algorithm Id ) ; }
public void test User Data Handler Notified Of Only Shallow Adoptions ( ) throws Exception { dom To String ( document ) ; Recording Handler handler = new Recording Handler ( ) ; name . set User Data ( STRING , STRING , handler ) ; name . set User Data ( STRING , STRING , handler ) ; standard . set User Data ( STRING , STRING , handler ) ; waffles . set User Data ( STRING , STRING , handler ) ; Document new Document = builder . new Document ( ) ; assert Same ( name , new Document . adopt Node ( name ) ) ; assert Same ( new Document , name . get Owner Document ( ) ) ; assert Same ( new Document , standard . get Owner Document ( ) ) ; assert Same ( new Document , waffles . get Owner Document ( ) ) ; Set < String > expected = new Hash Set < String > ( ) ; expected . add ( notification ( NODE ADOPTED , STRING , STRING , name , null ) ) ; expected . add ( notification ( NODE ADOPTED , STRING , STRING , name , null ) ) ; assert Equals ( expected , handler . calls ) ; }
public void reset ( ) { node list . clear ( ) ; }
public String name List ( String dir ) throws IO Exception { passive ( ) ; send ( STRING + dir ) ; read Code ( NUM ) ; Byte Array Output Stream out = new Byte Array Output Stream ( ) ; IO Utils . copy And Close ( in Data , out ) ; read Code ( NUM ) ; byte [ ] data = out . to Byte Array ( ) ; return new String ( data ) ; }
public VN Xe Command Result add Luns To Lun Group ( String lun Group Id , List < String > luns ) { Lun Group Modify Param param = new Lun Group Modify Param ( ) ; List < Lun Add Param > lun Adds = new Array List < Lun Add Param > ( ) ; for ( String lun Id : luns ) { VN Xe Base lun = new VN Xe Base ( lun Id ) ; Lun Add Param lun Add = new Lun Add Param ( ) ; lun Add . set Lun ( lun ) ; lun Adds . add ( lun Add ) ; } param . set Lun Add ( lun Adds ) ; Lun Group Requests req = new Lun Group Requests ( kh Client ) ; return req . modify Lun Group Sync ( lun Group Id , param ) ; }
public static Input Stream to Input Stream ( Char Sequence input , Charset encoding ) { return to Input Stream ( input . to String ( ) , encoding ) ; }
public static Constant Expression constant ( Object value , Class constant Type ) { return new Constant Expression ( value , constant Type . get Name ( ) ) ; }
public static final String to FEN ( Position pos ) { String Builder ret = new String Builder ( ) ; for ( int r = NUM ; r >= NUM ; r -- ) { int num Empty = NUM ; for ( int c = NUM ; c < NUM ; c ++ ) { int p = pos . get Piece ( Position . get Square ( c , r ) ) ; if ( p == Piece . EMPTY ) { num Empty ++ ; } else { if ( num Empty > NUM ) { ret . append ( num Empty ) ; num Empty = NUM ; } switch ( p ) { case Piece . WKING : ret . append ( STRING ) ; break ; case Piece . WQUEEN : ret . append ( STRING ) ; break ; case Piece . WROOK : ret . append ( STRING ) ; break ; case Piece . WBISHOP : ret . append ( STRING ) ; break ; case Piece . WKNIGHT : ret . append ( STRING ) ; break ; case Piece . WPAWN : ret . append ( STRING ) ; break ; case Piece . BKING : ret . append ( STRING ) ; break ; case Piece . BQUEEN : ret . append ( STRING ) ; break ; case Piece . BROOK : ret . append ( STRING ) ; break ; case Piece . BBISHOP : ret . append ( STRING ) ; break ; case Piece . BKNIGHT : ret . append ( STRING ) ; break ; case Piece . BPAWN : ret . append ( STRING ) ; break ; default : throw new Runtime Exception ( ) ; } } } if ( num Empty > NUM ) { ret . append ( num Empty ) ; } if ( r > NUM ) { ret . append ( STRING ) ; } } ret . append ( pos . white Move ? STRING : STRING ) ; boolean any Castle = BOOL ; if ( pos . h1 Castle ( ) ) { ret . append ( STRING ) ; any Castle = BOOL ; } if ( pos . a1 Castle ( ) ) { ret . append ( STRING ) ; any Castle = BOOL ; } if ( pos . h8 Castle ( ) ) { ret . append ( STRING ) ; any Castle = BOOL ; } if ( pos . a8 Castle ( ) ) { ret . append ( STRING ) ; any Castle = BOOL ; } if ( ! any Castle ) { ret . append ( STRING ) ; } { ret . append ( STRING ) ; if ( pos . get Ep Square ( ) >= NUM ) { int x = Position . get X ( pos . get Ep Square ( ) ) ; int y = Position . get Y ( pos . get Ep Square ( ) ) ; ret . append ( ( char ) ( x + STRING ) ) ; ret . append ( ( char ) ( y + STRING ) ) ; } else { ret . append ( STRING ) ; } } ret . append ( STRING ) ; ret . append ( pos . half Move Clock ) ; ret . append ( STRING ) ; ret . append ( pos . full Move Counter ) ; return ret . to String ( ) ; }
public void end Element ( String uri , String local Name , String q Name ) throws SAX Exception { if ( ! ( html Mode && ( uri . equals ( STRING ) || uri . equals ( STRING ) ) && ( q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) || q Name . equals ( STRING ) ) ) ) { write ( STRING ) ; write Name ( uri , local Name , q Name , BOOL ) ; write ( STRING ) ; } if ( element Level == NUM ) { write ( STRING ) ; } cdata Element = BOOL ; super . end Element ( uri , local Name , q Name ) ; ns Support . pop Context ( ) ; element Level -- ; }
static void find All Visible Childs ( final View Group view Group , final List < View > ordored Childs ) { for ( int child View Index = NUM ; child View Index < view Group . get Child Count ( ) ; child View Index ++ ) { final View child View = view Group . get Child At ( child View Index ) ; if ( child View instanceof View Group ) { find All Visible Childs ( ( View Group ) child View , ordored Childs ) ; continue ; } if ( child View . get Visibility ( ) == View . VISIBLE ) { ordored Childs . add ( child View ) ; } } }
public boolean log Modified ( Logger log ) { if ( is Modified ( ) ) { log . info ( class Name + STRING ) ; return BOOL ; } else return BOOL ; }
public final void push ( Node value ) { int ff = m first Free ; if ( ( ff + NUM ) >= m map Size ) { if ( null == m map ) { m map = new Node [ m blocksize ] ; m map Size = m blocksize ; } else { m map Size += m blocksize ; Node new Map [ ] = new Node [ m map Size ] ; System . arraycopy ( m map , NUM , new Map , NUM , ff + NUM ) ; m map = new Map ; } } m map [ ff ] = value ; ff ++ ; m first Free = ff ; }
public String serialize ( Object obj ) throws Api Exception { try { if ( obj != null ) return mapper . write Value As String ( obj ) ; else return null ; } catch ( Exception e ) { throw new Api Exception ( NUM , e . get Message ( ) ) ; } }
private void initialize Sparse Slider ( ) { sparsity Slider . set Major Tick Spacing ( NUM ) ; sparsity Slider . set Minor Tick Spacing ( NUM ) ; sparsity Slider . set Paint Ticks ( BOOL ) ; Hashtable < Integer , J Label > label Table 2 = new Hashtable < Integer , J Label > ( ) ; label Table 2 . put ( new Integer ( NUM ) , new J Label ( STRING ) ) ; label Table 2 . put ( new Integer ( NUM ) , new J Label ( STRING ) ) ; sparsity Slider . set Label Table ( label Table 2 ) ; sparsity Slider . set Paint Labels ( BOOL ) ; }
@ Override protected void auto Adjust Range ( ) { Plot plot = get Plot ( ) ; if ( plot == null ) { return ; } if ( plot instanceof Value Axis Plot ) { Value Axis Plot vap = ( Value Axis Plot ) plot ; Range r = vap . get Data Range ( this ) ; if ( r == null ) { r = get Default Auto Range ( ) ; } double upper = r . get Upper Bound ( ) ; double lower = Math . max ( r . get Lower Bound ( ) , this . smallest Value ) ; double range = upper - lower ; double fixed Auto Range = get Fixed Auto Range ( ) ; if ( fixed Auto Range > NUM ) { lower = Math . max ( upper - fixed Auto Range , this . smallest Value ) ; } else { double min Range = get Auto Range Minimum Size ( ) ; if ( range < min Range ) { double expand = ( min Range - range ) / NUM ; upper = upper + expand ; lower = lower - expand ; } double log Upper = calculate Log ( upper ) ; double log Lower = calculate Log ( lower ) ; double log Range = log Upper - log Lower ; log Upper = log Upper + get Upper Margin ( ) * log Range ; log Lower = log Lower - get Lower Margin ( ) * log Range ; upper = calculate Value No INF ( log Upper ) ; lower = calculate Value No INF ( log Lower ) ; } set Range ( new Range ( lower , upper ) , BOOL , BOOL ) ; } }
public synchronized void add ( long value ) { long res = get ( ) + value ; lb . put ( NUM , res ) ; }
public void add IV Combination ( int attack IV , int defense IV , int stamina IV ) { int sum IV = attack IV + defense IV + stamina IV ; int percent Perfect = Math . round ( sum IV / NUM * NUM ) ; if ( ( percent Perfect < low Percent ) || ( percent Perfect == low Percent ) && ( attack IV < low Attack ) ) { low Percent = percent Perfect ; low Attack = attack IV ; low Defense = defense IV ; low Stamina = stamina IV ; } if ( ( percent Perfect > high Percent ) || ( percent Perfect == high Percent ) && ( attack IV > high Attack ) ) { high Percent = percent Perfect ; high Attack = attack IV ; high Defense = defense IV ; high Stamina = stamina IV ; } iV Combinations . add ( new IV Combination ( attack IV , defense IV , stamina IV ) ) ; }
String [ ] qualify ( String cpp Name ) { if ( cpp Name == null || cpp Name . length ( ) == NUM ) { return new String [ NUM ] ; } Array List < String > names = new Array List < String > ( ) ; String ns = namespace != null ? namespace : STRING ; while ( ns != null ) { String name = ns . length ( ) > NUM ? ns + STRING + cpp Name : cpp Name ; Template Map map = template Map ; while ( map != null ) { if ( name . equals ( map . get Name ( ) ) ) { String args = STRING , separator = STRING ; for ( String s : map . values ( ) ) { args += separator + s ; separator = STRING ; } names . add ( name + args + ( args . ends With ( STRING ) ? STRING : STRING ) ) ; break ; } map = map . parent ; } names . add ( name ) ; ns = Info Map . normalize ( ns , BOOL , BOOL ) ; int i = ns . last Index Of ( STRING ) ; ns = i >= NUM ? ns . substring ( NUM , i ) : ns . length ( ) > NUM ? STRING : null ; } for ( String s : using List ) { String prefix = Info Map . normalize ( cpp Name , BOOL , BOOL ) ; int i = s . last Index Of ( STRING ) + NUM ; ns = s . substring ( NUM , i ) ; String suffix = s . substring ( i ) ; if ( suffix . length ( ) == NUM || prefix . equals ( suffix ) ) { names . add ( ns + cpp Name ) ; } } return names . to Array ( new String [ names . size ( ) ] ) ; }
@ Nullable public Bitmap generate Icon For Url ( String url , boolean include Private Registries ) { if ( Text Utils . is Empty ( url ) ) return null ; String text = get Icon Text For Url ( url , include Private Registries ) ; if ( Text Utils . is Empty ( text ) ) return null ; return generate Icon For Text ( text ) ; }
public boolean contains Prefix ( final Char Sequence prefix ) { return contains Prefix ( prefix , NUM , prefix . length ( ) ) ; }
public int compare To ( Object p other ) { if ( p other == null ) return NUM ; if ( p other instanceof Brd Component ) { return name . compare To Ignore Case ( ( ( Brd Component ) p other ) . name ) ; } return NUM ; }
public void fatal ( String message ) throws SAX Exception { SAX Parse Exception spe = new SAX Parse Exception ( message , this ) ; if ( error Handler != null ) { error Handler . fatal Error ( spe ) ; } throw spe ; }
@ Override public void close ( ) throws IO Exception { closed = BOOL ; def . end ( ) ; in . close ( ) ; }
protected final void fire Property Change ( String property Name , boolean old Value , boolean new Value ) { Property Change Support a Change Support = this . change Support ; if ( a Change Support == null ) { return ; } a Change Support . fire Property Change ( property Name , old Value , new Value ) ; }
public void remove Scrolling Listener ( On Wheel Scroll Listener listener ) { scrolling Listeners . remove ( listener ) ; }
private Iterator < Binding Set > join Binding Set Entry ( Map . Entry < String , Binding Set > entry ) { List < Collection < Binding Set > > matches = new Array List < > ( ) ; if ( type == Hash Join Type . CONSTANT JOIN VAR ) { if ( binding Join Var Hash . contains Key ( entry . get Key ( ) ) ) { matches . add ( binding Join Var Hash . get ( entry . get Key ( ) ) ) ; } } else { List < String > val Orders = get Value Orders ( entry . get Key ( ) ) ; for ( String s : val Orders ) { if ( binding Join Var Hash . contains Key ( s ) ) { matches . add ( binding Join Var Hash . get ( s ) ) ; } } } if ( matches . size ( ) == NUM ) { return Collections . empty Iterator ( ) ; } else { return new Binding Set Collections Join Iterator ( entry . get Value ( ) , matches ) ; } }
@ Override public void test ( Number t ) throws Parameter Exception { if ( t . double Value ( ) >= constraint Value . double Value ( ) ) { throw new Wrong Parameter Value Exception ( STRING + STRING + constraint Value . to String ( ) + STRING + t . double Value ( ) + STRING ) ; } }
public void test Find Users Active Directory ( ) throws Exception { Ldap Manager mgr = get Ldap AD ( ) ; List ret = null ; And Filter filter = new And Filter ( ) ; filter . and ( new Like Filter ( mgr . get Users Returning Attribute ( Ldap User Attribute Constants . LDAP USER ATTRIBUTE GIVEN NAME ) , STRING ) ) ; try { Ldap Search Manager VO search Mgr VO = new Ldap Search Manager VO ( ) ; search Mgr VO . set Filter ( filter ) ; search Mgr VO . set Add User Classes ( BOOL ) ; ret = mgr . find Users ( search Mgr VO ) ; } catch ( Exception e ) { } assert Equals ( NUM , ret . size ( ) ) ; }
public boolean reserve ( Object object ) { reserved Ids Lock . lock ( ) ; if ( reserved Objects . contains ( object ) ) { reserved Ids Lock . unlock ( ) ; return BOOL ; } reserved Objects . add ( object ) ; reserved Ids Lock . unlock ( ) ; return BOOL ; }
private boolean save Stored JPEG Image ( String file name , final Buffered Image image , final boolean file name is path ) { if ( ! file name is path ) { file name = temp dir + key + file name ; } final String s = file name . to Lower Case ( ) ; if ( ! s . ends With ( STRING ) && ! s . ends With ( STRING ) ) { file name += STRING ; } try { Default Image Helper . write ( image , STRING , file name ) ; temp File Names . put ( file name , STRING ) ; } catch ( final Exception e ) { Log Writer . write Log ( STRING + e + STRING + image + STRING + file name ) ; } return BOOL ; }
public static Scheduled Executor Service create Scheduler ( ) { final Scheduled Executor Service scheduler = Executors . new Scheduled Thread Pool ( NUM , new Daemon Thread Factory ( DEFAULT SCHEDULER NAME ) ) ; SCHEDULERS . add ( scheduler ) ; return scheduler ; }
public Linked List < Patch > patch make ( String text 1 , String text 2 ) { if ( text 1 == null || text 2 == null ) { throw new Illegal Argument Exception ( STRING ) ; } Linked List < Diff > diffs = diff main ( text 1 , text 2 , BOOL ) ; if ( diffs . size ( ) > NUM ) { diff cleanup Semantic ( diffs ) ; diff cleanup Efficiency ( diffs ) ; } return patch make ( text 1 , diffs ) ; }
protected static void fail ( ) { System . exit ( NUM ) ; }
private Rect calc Bounds ( int index , Paint paint ) { Rect bounds = new Rect ( ) ; Char Sequence title = get Title ( index ) ; bounds . right = ( int ) paint . measure Text ( title , NUM , title . length ( ) ) ; bounds . bottom = ( int ) ( paint . descent ( ) - paint . ascent ( ) ) ; return bounds ; }
private void print Arguments ( List < Expression > args , Object arg ) { printer . print ( STRING ) ; if ( args != null ) { for ( Iterator < Expression > i = args . iterator ( ) ; i . has Next ( ) ; ) { Expression e = i . next ( ) ; e . accept ( this , arg ) ; if ( i . has Next ( ) ) { printer . print ( STRING ) ; } } } printer . print ( STRING ) ; }
private void calculate Delta ( double [ ] b ) { double numerator = NUM ; double denominator = NUM ; double sign = NUM ; for ( int k = NUM ; k < b . length ; k ++ ) { if ( k < m Extremal Indices . size ( ) ) { int extremal Index = m Extremal Indices . get ( k ) ; numerator += ( b [ k ] * m Grid . get Desired Response ( ) [ extremal Index ] ) ; denominator += b [ k ] * sign / m Grid . get Weight ( ) [ extremal Index ] ; sign = - sign ; } else { m Log . error ( STRING ) ; } } m Delta = numerator / denominator ; }
public static float build Float ( int mant , int exp ) { if ( exp < - NUM || mant == NUM ) { return NUM ; } if ( exp >= NUM ) { return ( mant > NUM ) ? Float . POSITIVE INFINITY : Float . NEGATIVE INFINITY ; } if ( exp == NUM ) { return mant ; } if ( mant >= ( NUM << NUM ) ) { mant ++ ; } return ( float ) ( ( exp > NUM ) ? mant * pow 10 [ exp ] : mant / pow 10 [ - exp ] ) ; }
private void add Fallback Selector ( Properties settings , Protocol Dispatch Selector ps ) { String proxy = settings . get Property ( STRING ) ; if ( proxy != null ) { ps . set Fallback Selector ( Proxy Util . parse Proxy Settings ( proxy ) ) ; } }
private void read Data ( ) throws IO Exception { while ( ! is Closed ) { int code = is . read ( ) ; switch ( code ) { case STRING : case STRING : case STRING : case STRING : break ; case STRING : { int channel = ( is . read ( ) << NUM ) + is . read ( ) ; input Ready [ channel ] = BOOL ; return ; } case STRING : { int channel = ( is . read ( ) << NUM ) + is . read ( ) ; int status = ( is . read ( ) << NUM ) + is . read ( ) ; input Ready [ channel ] = BOOL ; return ; } case - NUM : close ( ) ; return ; default : close ( ) ; return ; } } return ; }
@ Override protected boolean validate Connection ( Connection conn ) { try { return ( ! conn . is Closed ( ) ) ; } catch ( SQL Exception e ) { return BOOL ; } }
public static byte [ ] decode ( String s ) { return decode ( s . to Char Array ( ) ) ; }
public Pac Proxy Selector ( String pac Url ) { if ( pac Url == null ) { throw new Null Pointer Exception ( ) ; } this . pac Url = pac Url ; }
public void delete Alerting Definition ( Alerting Definition alerting Definition ) throws IO Exception { String id = alerting Definition . get Id ( ) ; Alerting Definition local = existing Alerting Definitions . remove ( id ) ; if ( local != null ) { Files . delete If Exists ( path Resolver . get Alerting Definition File Path ( local ) ) ; event Publisher . publish Event ( new Abstract Alerting Definition Event . Alerting Definition Deleted Event ( this , local ) ) ; } }
public void add File ( File file ) { file List . add First ( file ) ; }
private void pull Event ( ) { final int new Scroll Value ; final int item Dimension ; final float initial Motion Value , last Motion Value ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : initial Motion Value = m Initial Motion X ; last Motion Value = m Last Motion X ; break ; case VERTICAL : default : initial Motion Value = m Initial Motion Y ; last Motion Value = m Last Motion Y ; break ; } switch ( m Current Mode ) { case PULL FROM END : new Scroll Value = Math . round ( Math . max ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Footer Size ( ) ; break ; case PULL FROM START : default : new Scroll Value = Math . round ( Math . min ( initial Motion Value - last Motion Value , NUM ) / FRICTION ) ; item Dimension = get Header Size ( ) ; break ; } set Header Scroll ( new Scroll Value ) ; if ( new Scroll Value != NUM && ! is Refreshing ( ) ) { float scale = Math . abs ( new Scroll Value ) / ( float ) item Dimension ; switch ( m Current Mode ) { case PULL FROM END : m Footer Layout . on Pull ( scale ) ; break ; case PULL FROM START : default : m Header Layout . on Pull ( scale ) ; break ; } if ( m State != State . PULL TO REFRESH && item Dimension >= Math . abs ( new Scroll Value ) ) { set State ( State . PULL TO REFRESH ) ; } else if ( m State != State . RELEASE TO REFRESH && item Dimension < Math . abs ( new Scroll Value ) ) { set State ( State . RELEASE TO REFRESH ) ; } } }
public boolean requires Connection ( ) { return BOOL ; }
public static double tile 2 lat ( int y , int z ) { double n = Math . PI - ( NUM * Math . PI * y ) / Math . pow ( NUM , z ) ; return Math . to Degrees ( Math . atan ( Math . sinh ( n ) ) ) ; }
@ Override public synchronized Time Series Collection update Collection ( ) { return super . update Collection ( ) ; }
public char skip ( int n ) { pos += n ; if ( length <= pos ) { pos = string . length ( ) ; return DONE ; } else return string . char At ( pos ) ; }
public void write To Object ( Object object ) { try { Method method = Bean Utils . get Write Method ( object . get Class ( ) , get Name ( ) , get Type ( ) ) ; if ( method != null ) { method . invoke ( object , new Object [ ] { get Value ( ) } ) ; } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
private boolean should Inform ( Local Client Info info ) { long now = System . current Time Millis ( ) ; if ( now < next Allowed Time ) return BOOL ; Long allowed = BUG TIMES . get ( info . get Parsed Bug ( ) ) ; return allowed == null || now >= allowed . long Value ( ) ; }
public void post ( Runnable runnable ) { synchronized ( m Queue ) { m Queue . add ( runnable ) ; if ( m Queue . size ( ) == NUM ) { schedule Next Locked ( ) ; } } }
public static void clear ( ) { clear Count ++ ; state Count = NUM ; state = STRING ; feature Map . clear ( ) ; }
public static String to String Pretty ( Json Object json Obj , int level ) { String Buffer buf = new String Buffer ( ) ; buf . append ( STRING ) ; buf . append ( fields To String Pretty ( json Obj , level + NUM ) ) ; buf . append ( STRING ) ; return buf . to String ( ) ; }
public boolean is Launched From Jar ( ) { return ( lst Jar File . size ( ) > NUM ) ; }
protected void save Pass Code And Exit ( ) { Intent result Intent = new Intent ( ) ; result Intent . put Extra ( KEY PASSCODE , m Pass Code Digits [ NUM ] + m Pass Code Digits [ NUM ] + m Pass Code Digits [ NUM ] + m Pass Code Digits [ NUM ] ) ; set Result ( RESULT OK , result Intent ) ; finish ( ) ; }
public Log Stream print ( double d ) { if ( ps != null ) { indent ( ) ; line Buffer . append ( d ) ; } return this ; }
public static void delete Directory Recursively ( Context context , File f , Boolean only Content ) throws IO Exception { if ( f . is Directory ( ) ) { for ( File c : f . list Files ( ) ) { delete Directory Recursively ( context , c , BOOL ) ; } } if ( ! only Content ) { if ( ! f . delete ( ) ) { throw new IO Exception ( STRING + f ) ; } context . send Broadcast ( new Intent ( Intent . ACTION MEDIA SCANNER SCAN FILE , Uri . parse ( STRING + f . get Absolute Path ( ) ) ) ) ; } }
public static String node Sub Type To String ( int sub Type ) { String val = STRING ; switch ( sub Type ) { case Node Representation . AND TYPE : val = STRING ; break ; case Node Representation . OR TYPE : val = STRING ; break ; case Node Representation . IMPLIES TYPE : val = STRING ; break ; case Node Representation . FORALL TYPE : val = STRING ; break ; case Node Representation . EXISTS TYPE : val = STRING ; break ; case Node Representation . SQSUB TYPE : val = STRING ; break ; case Node Representation . OTHER TYPE : val = STRING ; break ; } return val ; }
public static void dispose Graphics Config ( long p Config Info ) { OGL Render Queue rq = get Instance ( ) ; rq . lock ( ) ; try { OGL Context . set Scratch Surface ( p Config Info ) ; Render Buffer buf = rq . get Buffer ( ) ; rq . ensure Capacity And Alignment ( NUM , NUM ) ; buf . put Int ( DISPOSE CONFIG ) ; buf . put Long ( p Config Info ) ; rq . flush Now ( ) ; } finally { rq . unlock ( ) ; } }
private void add Term ( String term ) { Integer index = term To Index . get ( term ) ; if ( index == null ) { synchronized ( this ) { index = term To Index . get ( term ) ; if ( index == null ) { index = Integer . value Of ( term Index Counter . get And Increment ( ) ) ; term To Index . put ( term , index ) ; } } } }
private void safe Bottom View ( ) { Status status = get Open Status ( ) ; View Group bottom = get Bottom View ( ) ; if ( status == Status . Close ) { if ( bottom . get Visibility ( ) != INVISIBLE ) bottom . set Visibility ( INVISIBLE ) ; } else { if ( bottom . get Visibility ( ) != VISIBLE ) bottom . set Visibility ( VISIBLE ) ; } }
public static String revert New Lines ( String string ) { int index ; String Buffer new String Buffer = new String Buffer ( ) ; while ( ( index = string . index Of ( STRING ) ) != - NUM ) { if ( index > NUM ) { new String Buffer . append ( string . substring ( NUM , index ) ) ; } new String Buffer . append ( STRING ) ; if ( ( index + NUM ) < string . length ( ) ) { string = string . substring ( index + NUM ) ; } else { string = STRING ; } } new String Buffer . append ( string ) ; string = new String Buffer . to String ( ) ; new String Buffer = new String Buffer ( ) ; while ( ( index = string . index Of ( STRING ) ) != - NUM ) { if ( index > NUM ) { new String Buffer . append ( string . substring ( NUM , index ) ) ; } new String Buffer . append ( STRING ) ; if ( ( index + NUM ) < string . length ( ) ) { string = string . substring ( index + NUM ) ; } else { string = STRING ; } } new String Buffer . append ( string ) ; return new String Buffer . to String ( ) ; }
@ Override public List < Period > generate Periods ( Date Time Unit date Time Unit ) { Calendar cal = get Calendar ( ) ; boolean past = date Time Unit . get Month ( ) >= ( get Base Month ( ) + NUM ) ; List < Period > periods = Lists . new Array List ( ) ; date Time Unit = cal . minus Years ( date Time Unit , past ? NUM : NUM ) ; date Time Unit . set Month ( get Base Month ( ) + NUM ) ; date Time Unit . set Day ( NUM ) ; Calendar calendar = get Calendar ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { periods . add ( create Period ( date Time Unit , cal ) ) ; date Time Unit = calendar . plus Years ( date Time Unit , NUM ) ; } return periods ; }
public final boolean is Dragging ( ) { return dragging ; }
@ Override public void escape ( char [ ] buffer , int start , int length , boolean is Attribute Value , Writer output Writer ) throws IO Exception { for ( int i = start ; i < start + length ; i ++ ) { char ch = buffer [ i ] ; if ( ch == STRING ) { output Writer . write ( STRING ) ; continue ; } if ( ch == STRING ) { output Writer . write ( STRING ) ; continue ; } if ( ch == STRING ) { output Writer . write ( STRING ) ; continue ; } if ( ch == STRING && is Attribute Value ) { output Writer . write ( STRING ) ; continue ; } if ( ch == STRING && is Attribute Value ) { output Writer . write ( STRING ) ; continue ; } if ( is Xml 11 Restricted Character ( ch ) ) { output Writer . write ( STRING ) ; output Writer . write ( Integer . to Hex String ( ch ) ) ; output Writer . write ( STRING ) ; continue ; } output Writer . write ( ch ) ; } }
void encrypt ( Byte Buffer src ) throws SSL Exception { if ( ! handshake Complete ) { throw new Illegal State Exception ( ) ; } if ( ! src . has Remaining ( ) ) { if ( out Net Buffer == null ) { out Net Buffer = empty Buffer ; } return ; } create Out Net Buffer ( src . remaining ( ) ) ; while ( src . has Remaining ( ) ) { SSL Engine Result result = ssl Engine . wrap ( src , out Net Buffer . buf ( ) ) ; if ( result . get Status ( ) == SSL Engine Result . Status . OK ) { if ( result . get Handshake Status ( ) == SSL Engine Result . Handshake Status . NEED TASK ) { do Tasks ( ) ; } } else if ( result . get Status ( ) == SSL Engine Result . Status . BUFFER OVERFLOW ) { out Net Buffer . capacity ( out Net Buffer . capacity ( ) << NUM ) ; out Net Buffer . limit ( out Net Buffer . capacity ( ) ) ; } else { throw new SSL Exception ( STRING + result . get Status ( ) + STRING + src + STRING + out Net Buffer ) ; } } out Net Buffer . flip ( ) ; }
public boolean code Matches ( String query Code ) { int length = id . length ( ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + query Code + STRING + id + STRING + start Index + STRING + length ) ; } return query Code . region Matches ( BOOL , start Index , id , NUM , length ) ; }
private static int parse Notification Id ( String id ) { try { return Integer . parse Int ( id ) ; } catch ( Number Format Exception nfe ) { Log . w ( TAG , STRING + id ) ; return - NUM ; } }
private < T > Property < T > prepare ( String key , Property < T > property , T initial Value ) { final Change Listener < T > change = null ; property . set Value ( initial Value ) ; property . add Listener ( change ) ; change . changed ( property , null , initial Value ) ; return property ; }
protected void read Till EOL ( ) throws IO Exception { while ( m Tokenizer . next Token ( ) != Stream Tokenizer . TT EOL ) { } m Tokenizer . push Back ( ) ; }
@ Override public void clear Answer ( ) { Date Time ldt = new Date Time ( ) ; m Time Picker . set Current Hour ( ldt . get Hour Of Day ( ) ) ; m Time Picker . set Current Minute ( ldt . get Minute Of Hour ( ) ) ; }
public String read Line ( ) throws IO Exception { return keep Carriage Returns ? read Until Newline ( ) : reader . read Line ( ) ; }
@ Override public void do Work ( ) throws Operator Exception { super . do Work ( ) ; run Vector Output . deliver ( run Vector ) ; }
public Shape create Arrow Up ( final double x , final double y , final double w , final double h ) { path . reset ( ) ; path . move To ( x , y + h ) ; path . line To ( x + w / NUM , y ) ; path . line To ( x + w , y + h ) ; path . close Path ( ) ; return path ; }
protected int generate Binomial ( int n , double p ) { final double C1 3 = NUM ; final double C5 8 = NUM ; final double C1 6 = NUM ; final int DMAX KM = NUM ; int bh , i , K , Km , nK ; double f , rm , U , V , X , T , E ; if ( n != n last || p != p last ) { n last = n ; p last = p ; par = Math . min ( p , NUM - p ) ; q = NUM - par ; np = n * par ; if ( np <= NUM ) return - NUM ; rm = np + par ; m = ( int ) rm ; if ( np < NUM ) { p0 = Math . exp ( n * Math . log ( q ) ) ; bh = ( int ) ( np + NUM * Math . sqrt ( np * q ) ) ; b = Math . min ( n , bh ) ; } else { rc = ( n + NUM ) * ( pq = par / q ) ; ss = np * q ; i = ( int ) ( NUM * Math . sqrt ( ss ) - NUM * q ) ; xm = m + NUM ; xl = ( double ) ( m - i ) ; xr = ( double ) ( m + i + NUM ) ; f = ( rm - xl ) / ( rm - xl * par ) ; ll = f * ( NUM + NUM * f ) ; f = ( xr - rm ) / ( xr * q ) ; lr = f * ( NUM + NUM * f ) ; c = NUM + NUM / ( NUM + ( double ) m ) ; p1 = i + NUM ; p2 = p1 * ( NUM + c + c ) ; p3 = p2 + c / ll ; p4 = p3 + c / lr ; } } if ( np < NUM ) { double pk ; K = NUM ; pk = p0 ; U = random Generator . raw ( ) ; while ( U > pk ) { ++ K ; if ( K > b ) { U = random Generator . raw ( ) ; K = NUM ; pk = p0 ; } else { U -= pk ; pk = ( double ) ( ( ( n - K + NUM ) * par * pk ) / ( K * q ) ) ; } } return ( ( p > NUM ) ? ( n - K ) : K ) ; } for ( ; ; ) { V = random Generator . raw ( ) ; if ( ( U = random Generator . raw ( ) * p4 ) <= p1 ) { K = ( int ) ( xm - U + p1 * V ) ; return ( p > NUM ) ? ( n - K ) : K ; } if ( U <= p2 ) { X = xl + ( U - p1 ) / c ; if ( ( V = V * c + NUM - Math . abs ( xm - X ) / p1 ) >= NUM ) continue ; K = ( int ) X ; } else if ( U <= p3 ) { if ( ( X = xl + Math . log ( V ) / ll ) < NUM ) continue ; K = ( int ) X ; V *= ( U - p2 ) * ll ; } else { if ( ( K = ( int ) ( xr - Math . log ( V ) / lr ) ) > n ) continue ; V *= ( U - p3 ) * lr ; } if ( ( Km = Math . abs ( K - m ) ) <= DMAX KM || Km + Km + NUM >= ss ) { f = NUM ; if ( m < K ) { for ( i = m ; i < K ; ) { if ( ( f *= ( rc / ++ i - pq ) ) < V ) break ; } } else { for ( i = K ; i < m ; ) { if ( ( V *= ( rc / ++ i - pq ) ) > f ) break ; } } if ( V <= f ) break ; } else { V = Math . log ( V ) ; T = - Km * Km / ( ss + ss ) ; E = ( Km / ss ) * ( ( Km * ( Km * C1 3 + C5 8 ) + C1 6 ) / ss + NUM ) ; if ( V <= T - E ) break ; if ( V <= T + E ) { if ( n != n prev || par != p prev ) { n prev = n ; p prev = par ; nm = n - m + NUM ; ch = xm * Math . log ( ( m + NUM ) / ( pq * nm ) ) + Arithmetic . stirling Correction ( m + NUM ) + Arithmetic . stirling Correction ( nm ) ; } nK = n - K + NUM ; if ( V <= ch + ( n + NUM ) * Math . log ( ( double ) nm / ( double ) nK ) + ( K + NUM ) * Math . log ( nK * pq / ( K + NUM ) ) - Arithmetic . stirling Correction ( K + NUM ) - Arithmetic . stirling Correction ( nK ) ) break ; } } } return ( p > NUM ) ? ( n - K ) : K ; }
public Simple User Context ( Authentication Provider auth Provider , String username , Map < String , Guacamole Configuration > configs ) { Collection < String > connection Identifiers = new Array List < String > ( configs . size ( ) ) ; Collection < String > connection Group Identifiers = Collections . singleton ( ROOT IDENTIFIER ) ; Collection < Connection > connections = new Array List < Connection > ( configs . size ( ) ) ; for ( Map . Entry < String , Guacamole Configuration > config Entry : configs . entry Set ( ) ) { String identifier = config Entry . get Key ( ) ; Guacamole Configuration config = config Entry . get Value ( ) ; Connection connection = new Simple Connection ( identifier , identifier , config ) ; connection . set Parent Identifier ( ROOT IDENTIFIER ) ; connections . add ( connection ) ; connection Identifiers . add ( identifier ) ; } this . root Group = new Simple Connection Group ( ROOT IDENTIFIER , ROOT IDENTIFIER , connection Identifiers , Collections . < String > empty List ( ) ) ; this . self = new Simple User ( username , connection Identifiers , connection Group Identifiers ) ; this . user Directory = new Simple User Directory ( self ) ; this . connection Directory = new Simple Connection Directory ( connections ) ; this . connection Group Directory = new Simple Connection Group Directory ( Collections . singleton ( this . root Group ) ) ; this . auth Provider = auth Provider ; }
public void reset ( ) { visited Get . clear ( ) ; visited Post . clear ( ) ; for ( Spider Parser parser : parsers ) { parser . remove Spider Parser Listener ( this ) ; } }
private static float Call Static Float Method V ( JNI Environment env , int class JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object return Obj = JNI Helpers . invoke With Var Arg ( method ID , arg Address , Type Reference . Float ) ; return Reflection . unwrap Float ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
public Named List < Object > to Named List ( ) { final Simple Ordered Map < Object > result = new Simple Ordered Map < > ( ) ; for ( Iterator < String > it = get Parameter Names Iterator ( ) ; it . has Next ( ) ; ) { final String name = it . next ( ) ; final String [ ] values = get Params ( name ) ; if ( values . length == NUM ) { result . add ( name , values [ NUM ] ) ; } else { result . add ( name , values ) ; } } return result ; }
private boolean is Representing Tab ( String text ) { if ( text == null ) return BOOL ; if ( is Inserting Spaces For Tab ( ) ) { if ( text . length ( ) == NUM || text . length ( ) > get Visual Tab Length Preference ( ) ) return BOOL ; for ( int i = NUM ; i < text . length ( ) ; i ++ ) { if ( text . char At ( i ) != STRING ) return BOOL ; } return BOOL ; } else return text . length ( ) == NUM && text . char At ( NUM ) == STRING ; }
public Monitor Thread ( String name ) { super ( name ) ; }
public void remove Drag Listener ( Drag Listener l ) { m Listeners . remove ( l ) ; }
@ Override public Units Relations init ( Processing Environment env ) { elements = env . get Element Utils ( ) ; m = Units Relations Tools . build Anno Mirror With Default Prefix ( env , m . class ) ; km = Units Relations Tools . build Anno Mirror With Specific Prefix ( env , m . class , Prefix . kilo ) ; mm = Units Relations Tools . build Anno Mirror With Specific Prefix ( env , m . class , Prefix . milli ) ; m2 = Units Relations Tools . build Anno Mirror With No Prefix ( env , m2 . class ) ; km 2 = Units Relations Tools . build Anno Mirror With No Prefix ( env , km 2 . class ) ; mm 2 = Units Relations Tools . build Anno Mirror With No Prefix ( env , mm 2 . class ) ; s = Units Relations Tools . build Anno Mirror With Default Prefix ( env , s . class ) ; h = Units Relations Tools . build Anno Mirror With No Prefix ( env , h . class ) ; mPE Rs = Units Relations Tools . build Anno Mirror With No Prefix ( env , mPE Rs . class ) ; km PE Rh = Units Relations Tools . build Anno Mirror With No Prefix ( env , km PE Rh . class ) ; mPE Rs 2 = Units Relations Tools . build Anno Mirror With No Prefix ( env , mPE Rs 2 . class ) ; return this ; }
public static String [ ] to String Array ( Collection < String > collection ) { if ( collection == null ) { return null ; } return collection . to Array ( new String [ collection . size ( ) ] ) ; }
public void persist ( Repository Proxy Cache proxy Cache ) { persist ( proxy Cache , proxy Cache . get File Name ( ) ) ; }
public Array List < Chart Set > prepare Animation ( Chart View chart View , Array List < float [ ] [ ] > start , Array List < float [ ] [ ] > end ) { final int n Sets = start . size ( ) ; final int n Entries = start . get ( NUM ) . length ; m Chart View = chart View ; m Current Duration = new long [ n Entries ] ; if ( m Order == null ) { m Order = new int [ n Entries ] ; for ( int i = NUM ; i < m Order . length ; i ++ ) m Order [ i ] = i ; } float no Overlap Duration = m Global Duration / n Entries ; m Duration = ( int ) ( no Overlap Duration + ( m Global Duration - no Overlap Duration ) * m Overlaping Factor ) ; Path path ; m Path Measures = new Path Measure [ n Sets ] [ n Entries ] ; for ( int i = NUM ; i < n Sets ; i ++ ) { for ( int j = NUM ; j < n Entries ; j ++ ) { path = new Path ( ) ; path . move To ( start . get ( i ) [ j ] [ NUM ] , start . get ( i ) [ j ] [ NUM ] ) ; path . line To ( end . get ( i ) [ j ] [ NUM ] , end . get ( i ) [ j ] [ NUM ] ) ; m Path Measures [ i ] [ j ] = new Path Measure ( path , BOOL ) ; } } m Init Time = new long [ n Entries ] ; m Global Init Time = System . current Time Millis ( ) ; long no Overlap Init Time ; for ( int i = NUM ; i < n Entries ; i ++ ) { no Overlap Init Time = m Global Init Time + ( i * ( m Global Duration / n Entries ) ) ; m Init Time [ m Order [ i ] ] = ( no Overlap Init Time - ( ( long ) ( m Overlaping Factor * ( no Overlap Init Time - m Global Init Time ) ) ) ) ; } m Playing = BOOL ; return get Update ( m Chart View . get Data ( ) ) ; }
public IO Utils ( ) { super ( ) ; }
public String format Delete Nfs Export Cmd ( String data Mover , String path ) { String Builder cmd = new String Builder ( ) ; cmd . append ( STRING ) ; cmd . append ( data Mover ) ; cmd . append ( STRING ) ; cmd . append ( STRING ) ; cmd . append ( path ) ; return cmd . to String ( ) ; }
public final String match Categories ( Set < String > categories ) { if ( categories == null ) { return null ; } Iterator < String > it = categories . iterator ( ) ; if ( m Categories == null ) { return it . has Next ( ) ? it . next ( ) : null ; } while ( it . has Next ( ) ) { final String category = it . next ( ) ; if ( ! m Categories . contains ( category ) ) { return category ; } } return null ; }
@ Override public void run ( ) { try { Class Reader reader = new Class Reader ( new File Input Stream ( this . class File ) ) ; Asm Class Visitor visitor = new Asm Class Visitor ( this . data Provider , this . config ) ; reader . accept ( visitor , Class Reader . SKIP DEBUG ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . get Message ( ) , e ) ; } }
private void add Location And Track Property Change ( ) { for ( Location loc : location Manager . get List ( ) ) { loc . add Property Change Listener ( this ) ; for ( Track track : loc . get Track List ( ) ) { track . add Property Change Listener ( this ) ; Schedule schedule = track . get Schedule ( ) ; if ( schedule != null ) { schedule . add Property Change Listener ( this ) ; } } } }
private void handle Json Sign In ( Request And Response request And Response ) throws IO Exception , Servlet Exception { request And Response . set Response Content Type Json ( ) ; String user Name ; String password ; String csrft ; try { final Json Node Helper json = get Json Node ( request And Response ) ; user Name = json . get String ( STRING ) ; password = json . get String ( STRING ) ; csrft = json . get String ( STRING ) ; } catch ( final IO Exception e ) { return Json 400 ( request And Response , servlet Text . error Json ( ) ) ; return ; } if ( user Name != null ) { user Name = user Name . to Lower Case ( ) ; } if ( is The Csrft Wrong ( request And Response , csrft ) ) { return Json 400 ( request And Response , servlet Text . error Wrong Csrft ( ) ) ; return ; } if ( user Name == null || user Name . is Empty ( ) ) { return Json 400 ( request And Response , servlet Text . error Username Must Not Be Blank ( ) ) ; return ; } if ( password == null || password . is Empty ( ) ) { return Json 400 ( request And Response , servlet Text . error Password Must Not Be Blank ( ) ) ; return ; } if ( ! Account Attribute Validator . is User Name Valid ( user Name ) ) { return Json 400 ( request And Response , servlet Text . error User Name Is Not Valid ( ) ) ; return ; } if ( ! Account Attribute Validator . is Password Valid ( password ) ) { return Json 400 ( request And Response , servlet Text . error Password Is Not Valid ( ) ) ; return ; } try { final User user = db Logic . get User By User Name ( user Name ) ; if ( user == null ) { return Json 400 ( request And Response , servlet Text . error No Account Found ( ) ) ; return ; } if ( user . get Is Account Closed ( ) ) { return Json 400 ( request And Response , servlet Text . error Account Is Closed ( ) ) ; return ; } final String real Password = user . get Password ( ) ; if ( real Password == null || ! real Password . equals ( Digest Utils . sha 1 Hex ( password ) ) ) { return Json 400 ( request And Response , servlet Text . error Password Is Incorrect ( ) ) ; return ; } map Session To User ( request And Response , user . get Id ( ) ) ; db Logic . commit ( ) ; return Json 200 ( request And Response ) ; } catch ( final Persistence Exception e ) { logger . log ( Level . INFO , STRING , e ) ; return Json 500 ( request And Response , servlet Text . error Internal Database ( ) ) ; } }
private void schedule ( Activity a , long start Time ) { if ( a . is Scheduled ( ) ) { try { notify All ( ) ; } catch ( Exception e ) { } return ; } a . set Start Time ( start Time ) ; synchronized ( this ) { m activities . add ( a ) ; a . set Scheduled ( BOOL ) ; if ( start Time < m next Time ) { m next Time = start Time ; notify ( ) ; } } }
void unregister Callback ( Bluetooth Callback callback ) { synchronized ( m Callbacks ) { m Callbacks . remove ( callback ) ; } }
public void test Hash Code Unequal ( ) { String a = STRING ; int a Scale = NUM ; String b = STRING ; int b Scale = - NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; assert True ( STRING , a Number . hash Code ( ) != b Number . hash Code ( ) ) ; }
protected final void refresh Loading Views Size ( ) { final int maximum Pull Scroll = ( int ) ( get Maximum Pull Scroll ( ) * NUM ) ; int p Left = get Padding Left ( ) ; int p Top = get Padding Top ( ) ; int p Right = get Padding Right ( ) ; int p Bottom = get Padding Bottom ( ) ; switch ( get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Width ( maximum Pull Scroll ) ; p Left = - maximum Pull Scroll ; } else { p Left = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Width ( maximum Pull Scroll ) ; p Right = - maximum Pull Scroll ; } else { p Right = NUM ; } break ; case VERTICAL : if ( m Mode . show Header Loading Layout ( ) ) { m Header Layout . set Height ( maximum Pull Scroll ) ; p Top = - maximum Pull Scroll ; } else { p Top = NUM ; } if ( m Mode . show Footer Loading Layout ( ) ) { m Footer Layout . set Height ( maximum Pull Scroll ) ; p Bottom = - maximum Pull Scroll ; } else { p Bottom = NUM ; } break ; } if ( DEBUG ) { Log . d ( LOG TAG , String . format ( STRING , p Left , p Top , p Right , p Bottom ) ) ; } set Padding ( p Left , p Top , p Right , p Bottom ) ; }
@ Visible For Testing static String escape Sql String ( String string ) { return string . replace All ( STRING , STRING ) ; }
public static String [ ] to Array ( String arg ) { if ( arg == null ) { return new String [ NUM ] ; } String Tokenizer tok = new String Tokenizer ( arg , STRING ) ; String [ ] array = new String [ tok . count Tokens ( ) ] ; int i = NUM ; while ( tok . has More Tokens ( ) ) { array [ i ] = tok . next Token ( ) ; i ++ ; } return ( array ) ; }
private void append Uploaded Entry To Log ( String id ) throws IO Exception { File Writer writer = new File Writer ( m Logfile , BOOL ) ; String Builder sb = new String Builder ( ) ; sb . append ( System . current Time Millis ( ) / NUM ) ; sb . append ( STRING ) ; sb . append ( id ) ; sb . append ( STRING ) ; try { writer . write ( sb . to String ( ) ) ; } finally { writer . close ( ) ; } }
private void render Leaf Node ( final C Node Node tree Node ) { final Navi Node graph Node = tree Node . get Node ( ) ; if ( graph Node . is Selected ( ) && graph Node . is Visible ( ) ) { set Foreground ( SELECTED FONT COLOR ) ; } else if ( ! graph Node . is Visible ( ) ) { set Foreground ( INVISIBLE FONT COLOR ) ; } set Tool Tip Text ( build Tool Tip ( graph Node ) ) ; }
public static final void write Value Xml ( Object v , String name , Xml Serializer out ) throws Xml Pull Parser Exception , IO Exception { String type Str ; if ( v == null ) { out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } out . end Tag ( null , STRING ) ; return ; } else if ( v instanceof String ) { out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } out . text ( v . to String ( ) ) ; out . end Tag ( null , STRING ) ; return ; } else if ( v instanceof Integer ) { type Str = STRING ; } else if ( v instanceof Long ) { type Str = STRING ; } else if ( v instanceof Float ) { type Str = STRING ; } else if ( v instanceof Double ) { type Str = STRING ; } else if ( v instanceof Boolean ) { type Str = STRING ; } else if ( v instanceof byte [ ] ) { write Byte Array Xml ( ( byte [ ] ) v , name , out ) ; return ; } else if ( v instanceof int [ ] ) { write Int Array Xml ( ( int [ ] ) v , name , out ) ; return ; } else if ( v instanceof Map ) { write Map Xml ( ( Map ) v , name , out ) ; return ; } else if ( v instanceof List ) { write List Xml ( ( List ) v , name , out ) ; return ; } else if ( v instanceof Set ) { write Set Xml ( ( Set ) v , name , out ) ; return ; } else if ( v instanceof Char Sequence ) { out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } out . text ( v . to String ( ) ) ; out . end Tag ( null , STRING ) ; return ; } else { throw new Runtime Exception ( STRING + v ) ; } out . start Tag ( null , type Str ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } out . attribute ( null , STRING , v . to String ( ) ) ; out . end Tag ( null , type Str ) ; }
public Sector union ( double latitude , double longitude ) { if ( this . min Latitude < this . max Latitude && this . min Longitude < this . max Longitude ) { this . max Latitude = Math . max ( this . max Latitude , latitude ) ; this . min Latitude = Math . min ( this . min Latitude , latitude ) ; this . max Longitude = Math . max ( this . max Longitude , longitude ) ; this . min Longitude = Math . min ( this . min Longitude , longitude ) ; } else if ( ! Double . is Na N ( this . min Latitude ) && ! Double . is Na N ( this . min Longitude ) ) { this . max Latitude = Math . max ( this . min Latitude , latitude ) ; this . max Longitude = Math . max ( this . min Longitude , longitude ) ; this . min Latitude = Math . min ( this . min Latitude , latitude ) ; this . min Longitude = Math . min ( this . min Longitude , longitude ) ; } else { this . min Latitude = latitude ; this . min Longitude = longitude ; this . max Latitude = Double . Na N ; this . max Longitude = Double . Na N ; } return this ; }
public D Authority Key Identifier ( J Dialog parent , Public Key authority Public Key , X500 Name authority Cert Name , Big Integer authority Cert Serial Number ) { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; this . authority Public Key = authority Public Key ; init Components ( ) ; prepopulate With Authority Cert Details ( authority Cert Name , authority Cert Serial Number ) ; }
static void write UTF ( Output Stream out , String str ) throws IO Exception { for ( int i = NUM , len = str . length ( ) ; i < len ; i ++ ) { int c = str . char At ( i ) ; if ( ( c >= NUM ) && ( c <= NUM ) ) { out . write ( c ) ; } else { if ( c > NUM ) { out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; } else { out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; } } } }
public void test get Iterator ( ) { String test = STRING ; try { Attributed String attr String = new Attributed String ( test ) ; Attributed Character Iterator it = attr String . get Iterator ( ) ; assert Equals ( STRING , it . first ( ) , test . char At ( NUM ) ) ; } catch ( Exception e ) { fail ( STRING + e . to String ( ) ) ; } }
private void handle Normal Unassociated ( ) { int sz Ssa Regs = ssa Meth . get Reg Count ( ) ; for ( int ssa Reg = NUM ; ssa Reg < sz Ssa Regs ; ssa Reg ++ ) { if ( ssa Regs Mapped . get ( ssa Reg ) ) { continue ; } Register Spec ssa Spec = get Definition Spec For Ssa Reg ( ssa Reg ) ; if ( ssa Spec == null ) continue ; int category = ssa Spec . get Category ( ) ; int rop Reg = find Next Unreserved Rop Reg ( param Range End , category ) ; while ( ! can Map Reg ( ssa Spec , rop Reg ) ) { rop Reg = find Next Unreserved Rop Reg ( rop Reg + NUM , category ) ; } add Mapping ( ssa Spec , rop Reg ) ; } }
public void add Series Renderer ( int index , Simple Series Renderer renderer ) { m Renderers . add ( index , renderer ) ; }
private E unlink First ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; not Full . signal ( ) ; return item ; }
public void create Underlying ( ) { if ( Platform . is Fx Application Thread ( ) ) { options . create Underlying ( ) ; this . marker = new com . lynden . gmapsfx . javascript . object . Marker ( options . convert ( ) ) ; } }
private void on Action Up ( Motion Event event ) { if ( is Down ) { this . start X = NUM ; this . start Y = NUM ; this . is Down = BOOL ; } }
private Rectangle 2 D create Aligned Rectangle 2 D ( Size 2 D dimensions , Rectangle 2 D frame , Horizontal Alignment h Align , Vertical Alignment v Align ) { double x = Double . Na N ; double y = Double . Na N ; if ( h Align == Horizontal Alignment . LEFT ) { x = frame . get X ( ) ; } else if ( h Align == Horizontal Alignment . CENTER ) { x = frame . get Center X ( ) - ( dimensions . width / NUM ) ; } else if ( h Align == Horizontal Alignment . RIGHT ) { x = frame . get Max X ( ) - dimensions . width ; } if ( v Align == Vertical Alignment . TOP ) { y = frame . get Y ( ) ; } else if ( v Align == Vertical Alignment . CENTER ) { y = frame . get Center Y ( ) - ( dimensions . height / NUM ) ; } else if ( v Align == Vertical Alignment . BOTTOM ) { y = frame . get Max Y ( ) - dimensions . height ; } return new Rectangle 2 D . Double ( x , y , dimensions . width , dimensions . height ) ; }
public Mail Address ( Internet Address address ) throws Address Exception { this ( address . get Address ( ) ) ; }
public double [ ] [ ] confusion Matrix ( ) { double [ ] [ ] new Matrix = new double [ m Confusion Matrix . length ] [ NUM ] ; for ( int i = NUM ; i < m Confusion Matrix . length ; i ++ ) { new Matrix [ i ] = new double [ m Confusion Matrix [ i ] . length ] ; System . arraycopy ( m Confusion Matrix [ i ] , NUM , new Matrix [ i ] , NUM , m Confusion Matrix [ i ] . length ) ; } return new Matrix ; }
public void print ( int x ) { out . print ( x ) ; out . flush ( ) ; }
public static void begin Starting Service ( Context context , Intent intent ) { synchronized ( m Starting Service Sync ) { if ( m Starting Service == null ) { Power Manager pm = ( Power Manager ) context . get System Service ( Context . POWER SERVICE ) ; m Starting Service = pm . new Wake Lock ( Power Manager . PARTIAL WAKE LOCK , STRING ) ; m Starting Service . set Reference Counted ( BOOL ) ; } m Starting Service . acquire ( ) ; context . start Service ( intent ) ; } }
public Scanner Exception ( Error Messages message , int line ) { this ( null , Error Messages . get ( message ) , message , line , - NUM ) ; }
private static void attempt Retry On Exception ( String log Prefix , Request < ? > request , Volley Error exception ) throws Volley Error { Retry Policy retry Policy = request . get Retry Policy ( ) ; int old Timeout = request . get Timeout Ms ( ) ; try { retry Policy . retry ( exception ) ; } catch ( Volley Error e ) { request . add Marker ( String . format ( STRING , log Prefix , old Timeout ) ) ; throw e ; } request . add Marker ( String . format ( STRING , log Prefix , old Timeout ) ) ; }
private void inform Upon Similar Name ( final String Buffer message Buffer , final String name , final String candidate ) { if ( name . equals ( candidate ) ) { return ; } if ( name . region Matches ( BOOL , NUM , candidate , NUM , PKG LEN + NUM ) ) { message Buffer . append ( STRING ) ; message Buffer . append ( candidate ) ; message Buffer . append ( STRING ) ; } }
public synchronized void co exit ( int this Coroutine ) { m active I Ds . clear ( this Coroutine ) ; m next Coroutine = NOBODY ; notify ( ) ; }
private int find Scheme Separator ( ) { return cached Ssi == NOT CALCULATED ? cached Ssi = uri String . index Of ( STRING ) : cached Ssi ; }
@ Override public boolean test ( Object receiver , String property , Object [ ] args , Object expected Value ) { if ( IS ANGULAR CLI PROJECT PROPERTY . equals ( property ) ) { return test Is Angular CLI Project ( receiver ) ; } return BOOL ; }
public void refresh ( ) { label . set Text ( String . value Of ( Math Helper . round ( val , NUM ) ) ) ; if ( val == min ) minus . set Enabled ( BOOL ) ; else minus . set Enabled ( BOOL ) ; if ( val == max ) plus . set Enabled ( BOOL ) ; else plus . set Enabled ( BOOL ) ; if ( cb != null ) cb . callback ( val ) ; plus . repaint ( ) ; minus . repaint ( ) ; if ( progress != null ) { progress . set Value ( val / max ) ; } }
public String [ ] read All Lines ( ) { Array List < String > lines = new Array List < String > ( ) ; while ( has Next Line ( ) ) { lines . add ( read Line ( ) ) ; } return lines . to Array ( new String [ NUM ] ) ; }
public void remove Callback ( Callback callback ) { m Callbacks . remove ( callback ) ; }
public void error ( Source Locator src Lctr , String msg ) throws Transformer Exception { error ( src Lctr , null , null , msg , null ) ; }
private boolean expect Vlv Response ( ) { Boolean expected = Boolean . FALSE ; try { expected = ( Boolean ) get ( EXPECT VLV RESPONSE ) ; } catch ( Exception e ) { } return expected == null ? BOOL : expected . boolean Value ( ) ; }
public void layout Container ( final Container parent ) { check Layout ( get Model ( ) ) ; final Insets insets = parent . get Insets ( ) ; final Dimension size = parent . get Size ( ) ; final int width = size . width - ( insets . left + insets . right ) ; final int height = size . height - ( insets . top + insets . bottom ) ; final Rectangle bounds = new Rectangle ( insets . left , insets . top , width , height ) ; layout 1 ( get Model ( ) , bounds ) ; layout 2 ( get Model ( ) , bounds ) ; }
private String read Until ( char [ ] delimiter , boolean return Text ) throws IO Exception , Xml Pull Parser Exception { int start = position ; String Builder result = null ; if ( return Text && text != null ) { result = new String Builder ( ) ; result . append ( text ) ; } search : while ( BOOL ) { if ( position + delimiter . length > limit ) { if ( start < position && return Text ) { if ( result == null ) { result = new String Builder ( ) ; } result . append ( buffer , start , position - start ) ; } if ( ! fill Buffer ( delimiter . length ) ) { check Relaxed ( UNEXPECTED EOF ) ; type = COMMENT ; return null ; } start = position ; } for ( int i = NUM ; i < delimiter . length ; i ++ ) { if ( buffer [ position + i ] != delimiter [ i ] ) { position ++ ; continue search ; } } break ; } int end = position ; position += delimiter . length ; if ( ! return Text ) { return null ; } else if ( result == null ) { return string Pool . get ( buffer , start , end - start ) ; } else { result . append ( buffer , start , end - start ) ; return result . to String ( ) ; } }
@ Override public Invocation . Builder accept ( String ... media Types ) { client Request Context . set Accept Response Types Str ( Arrays . as List ( media Types ) ) ; return this ; }
public Stream Consumer ( Input Stream stream ) { in = new Buffered Input Stream ( stream ) ; thread . start ( ) ; }
public static String sub String ( String string , int begin Index , int length ) { if ( string == null ) { return null ; } final int end Index = begin Index + length ; if ( begin Index >= string . length ( ) ) { return EMPTY ; } if ( end Index > string . length ( ) ) { return string . substring ( begin Index , string . length ( ) ) ; } return string . substring ( begin Index , end Index ) ; }
private static Socket Impl create Socket Impl ( ) { try { return socket Impl Ctor . new Instance ( ) ; } catch ( Instantiation Exception x ) { throw new Assertion Error ( x ) ; } catch ( Illegal Access Exception x ) { throw new Assertion Error ( x ) ; } catch ( Invocation Target Exception x ) { throw new Assertion Error ( x ) ; } }
@ Override public String encode ( ) { return name . substring ( NUM , NUM ) ; }
private void update Base Matrix ( Drawable d ) { Image View image View = get Image View ( ) ; if ( null == image View || null == d ) { return ; } final float view Width = get Image View Width ( image View ) ; final float view Height = get Image View Height ( image View ) ; final int drawable Width = d . get Intrinsic Width ( ) ; final int drawable Height = d . get Intrinsic Height ( ) ; m Base Matrix . reset ( ) ; final float width Scale = view Width / drawable Width ; final float height Scale = view Height / drawable Height ; if ( m Scale Type == Scale Type . CENTER ) { m Base Matrix . post Translate ( ( view Width - drawable Width ) / NUM , ( view Height - drawable Height ) / NUM ) ; } else if ( m Scale Type == Scale Type . CENTER CROP ) { float scale = Math . max ( width Scale , height Scale ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM , ( view Height - drawable Height * scale ) / NUM ) ; } else if ( m Scale Type == Scale Type . CENTER INSIDE ) { float scale = Math . min ( NUM , Math . min ( width Scale , height Scale ) ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM , ( view Height - drawable Height * scale ) / NUM ) ; } else { Rect F m Temp Src = new Rect F ( NUM , NUM , drawable Width , drawable Height ) ; Rect F m Temp Dst = new Rect F ( NUM , NUM , view Width , view Height ) ; if ( ( int ) m Base Rotation % NUM != NUM ) { m Temp Src = new Rect F ( NUM , NUM , drawable Height , drawable Width ) ; } switch ( m Scale Type ) { case FIT CENTER : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . CENTER ) ; break ; case FIT START : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . START ) ; break ; case FIT END : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . END ) ; break ; case FIT XY : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . FILL ) ; break ; default : break ; } } reset Matrix ( ) ; }
void cancel All ( ) { synchronized ( current Requests ) { for ( Download Request request : current Requests ) { request . cancel ( ) ; } } current Requests . clear ( ) ; }
protected void add Docs ( String index , String type , int number ) throws Json Processing Exception { Object Mapper mapper = new Object Mapper ( ) ; for ( int i = NUM ; i < number ; i ++ ) { index ( index , type , STRING + i , mapper . write Value As String ( Test Document . create Simple Doc ( i ) ) ) ; } flush ( ) ; }
public void test Pow Negative Num To Zero Exp ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , NUM , NUM , NUM , - NUM , - NUM , NUM } ; int a Sign = - NUM ; int exp = NUM ; byte r Bytes [ ] = { NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . pow ( exp ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public final Parallel Flux < T > do On Error ( Consumer < ? super Throwable > on Error ) { Objects . require Non Null ( on Error , STRING ) ; return do On Signal ( this , null , null , on Error , null , null , null , null , null ) ; }
public void simulate Method ( Soot Method method , Reference Variable this Var , Reference Variable return Var , Reference Variable params [ ] ) { String sub Signature = method . get Sub Signature ( ) ; if ( sub Signature . equals ( STRING ) ) { java lang System arraycopy ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java lang System set In 0 ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java lang System set Out 0 ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java lang System set Err 0 ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java lang System init Properties ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java lang System map Library Name ( method , this Var , return Var , params ) ; return ; } else if ( sub Signature . equals ( STRING ) ) { java lang System get Caller Class ( method , this Var , return Var , params ) ; return ; } else { default Method ( method , this Var , return Var , params ) ; return ; } }
protected void load Value ( String s Value ) { try { value = Long . parse Long ( s Value . trim ( ) ) ; } catch ( Number Format Exception nfe ) { revert To Default ( ) ; } }
public void check Bounds ( ) { tf Low Bound . set Enabled ( ts Clipping . is Selected ( ) ) ; tf Up Bound . set Enabled ( ts Clipping . is Selected ( ) ) ; }
public void remove ( int index ) { m Categories . remove ( index ) ; m Titles . remove ( index ) ; m Values . remove ( index ) ; }
public static boolean delete Files And Dirs Recursive ( final File directory ) { if ( directory == null || ! directory . is Directory ( ) ) { Log . e ( File Utils . class , STRING ) ; return BOOL ; } return delete Files And Dirs ( directory ) ; }
void render ( Graphics Context g , Point 2 D viewport Origin ) { g . set Global Alpha ( life ) ; g . set Global Blend Mode ( blend Mode ) ; if ( image != null ) { g . save ( ) ; g . translate ( x - viewport Origin . get X ( ) , y - viewport Origin . get Y ( ) ) ; g . scale ( radius X * NUM / image . get Width ( ) , radius Y * NUM / image . get Height ( ) ) ; g . draw Image ( image , NUM , NUM ) ; g . restore ( ) ; } else { g . set Fill ( color ) ; g . fill Oval ( x - viewport Origin . get X ( ) , y - viewport Origin . get Y ( ) , radius X * NUM , radius Y * NUM ) ; } }
public int position ( ) { return buff . position ( ) ; }
@ Override public void write ( String str , int off , int len ) throws IO Exception { final int off plus len = off + len ; for ( int i = off ; i < off plus len ; ) { char c = str . char At ( i ++ ) ; if ( c < NUM ) { bytes [ index ] = ( byte ) c ; if ( ++ index >= bytes . length ) { flush Buffer ( ) ; } } else { write ( c ) ; } } }
public void write To NBT ( final NBT Tag Compound nbt ) { final NBT Tag List modules Nbt = new NBT Tag List ( ) ; for ( final Module module : modules ) { final NBT Tag Compound module Nbt = new NBT Tag Compound ( ) ; if ( module != null ) { module . write To NBT ( module Nbt ) ; } modules Nbt . append Tag ( module Nbt ) ; } nbt . set Tag ( TAG MODULES , modules Nbt ) ; lock . if Present ( null ) ; lock . if Present ( null ) ; }
void send Buffer If Not Empty ( ) throws IO Exception { if ( buf != null && buf . position ( ) > NUM ) send Buffer ( ) ; }
public void on Shared Preference Changed ( Shared Preferences shared Preferences , String key ) { if ( key . equals ( get String ( R . string . pref key notification ) ) ) { set Notification ( shared Preferences . get Boolean ( key , BOOL ) ) ; } else if ( key . equals ( get String ( R . string . pref key gmail signature ) ) ) { set Gmail Signature Pref Description ( shared Preferences . get Boolean ( key , BOOL ) ) ; } else if ( key . equals ( get String ( R . string . pref key sms signature ) ) ) { set Sms Signature Pref Description ( shared Preferences . get Boolean ( key , BOOL ) ) ; } }
public void init Port Parameters ( Serial Port port ) { initialized = BOOL ; if ( port != null ) { cb Port . set Selected Item ( port . get Name ( ) ) ; cb Baudrate . set Selected Item ( String . value Of ( port . get Baud Rate ( ) ) ) ; cb Parity . set Selected Index ( port . get Parity ( ) ) ; cb Data Bits . set Selected Index ( port . get Data Bits ( ) - NUM ) ; cb Stop Bits . set Selected Index ( port . get Stop Bits ( ) - NUM ) ; int prt = port . get Flow Control Mode ( ) ; cb Protocol Rx . set Selected Index ( ( prt & Serial Port . FLOWCONTROL RTSCTS IN ) != NUM ? NUM : ( prt & Serial Port . FLOWCONTROL XONXOFF IN ) != NUM ? NUM : NUM ) ; cb Protocol Tx . set Selected Index ( ( prt & Serial Port . FLOWCONTROL RTSCTS OUT ) != NUM ? NUM : ( prt & Serial Port . FLOWCONTROL XONXOFF OUT ) != NUM ? NUM : NUM ) ; btn DSR . set Selected ( port . is DSR ( ) ) ; btn CTS . set Selected ( port . is CTS ( ) ) ; btn CD . set Selected ( port . is CD ( ) ) ; btn DTR . set Selected ( port . is DTR ( ) ) ; btn RTS . set Selected ( port . is RTS ( ) ) ; } initialized = BOOL ; }
public void add Preload Entry ( Grid Cache Entry Info info ) { if ( preload Entries == null ) preload Entries = new Array List < > ( ) ; preload Entries . add ( info ) ; }
private void put Off Uniform ( final Player player ) { if ( UNIFORM . is Part Of ( player . get Outfit ( ) ) ) { player . return To Original Outfit ( ) ; } }
public static void move File ( final File src File , final File dest File ) throws IO Exception { if ( src File == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( dest File == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ! src File . exists ( ) ) { throw new File Not Found Exception ( STRING + src File + STRING ) ; } if ( src File . is Directory ( ) ) { throw new IO Exception ( STRING + src File + STRING ) ; } if ( dest File . exists ( ) ) { throw new IO Exception ( STRING + dest File + STRING ) ; } if ( dest File . is Directory ( ) ) { throw new IO Exception ( STRING + dest File + STRING ) ; } final boolean rename = src File . rename To ( dest File ) ; if ( ! rename ) { copy File ( src File , dest File ) ; if ( ! src File . delete ( ) ) { Parse File Utils . delete Quietly ( dest File ) ; throw new IO Exception ( STRING + src File + STRING + dest File + STRING ) ; } } }
public synchronized Scan Manager Config read From File ( ) throws IO Exception { final File f = new File ( file ) ; if ( ! f . exists ( ) ) throw new IO Exception ( STRING + file ) ; if ( ! f . can Read ( ) ) throw new IO Exception ( STRING + file ) ; try { return read ( f ) ; } catch ( JAXB Exception x ) { final IO Exception io = new IO Exception ( STRING + file + STRING + x , x ) ; throw io ; } }
public void delete ( String name ) throws IO Exception { if ( name . equals Ignore Case ( ISSUER ) ) { names = null ; } else { throw new IO Exception ( STRING + STRING ) ; } encode This ( ) ; }
private float clamp Mag ( float value , float abs Min , float abs Max ) { final float abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }
public Compile Class Not Found ( Exception cause ) { super ( cause . get Message ( ) ) ; cause = cause ; }
public Sym Graph ( Motif motif ) { this . motif = motif ; colors To Recheck = new Hash Set < Integer > ( ) ; top Motifnode To Color = new int [ motif . get Nr Motif Nodes ( ) ] ; color To Bottom Motifnode = new Hash Map < Integer , List < Integer > > ( ) ; color To Top Motifnode = new Hash Map < Integer , List < Integer > > ( ) ; Array List < Integer > list 1 = new Array List < Integer > ( ) ; Array List < Integer > list 2 = new Array List < Integer > ( ) ; for ( int i = NUM ; i < top Motifnode To Color . length ; i ++ ) { list 1 . add ( i ) ; list 2 . add ( i ) ; } color To Bottom Motifnode . put ( NUM , list 2 ) ; color To Top Motifnode . put ( NUM , list 1 ) ; }
public static boolean any Dimension Has Items ( Collection < Dimensional Object > dimensions ) { if ( dimensions == null || dimensions . is Empty ( ) ) { return BOOL ; } for ( Dimensional Object dim : dimensions ) { if ( dim . has Items ( ) ) { return BOOL ; } } return BOOL ; }
private void open Current And Maybe Next ( final boolean open Next ) { LOG . info ( STRING ) ; synchronized ( this ) { LOG . info ( STRING ) ; close Cursor ( ) ; if ( m Play List Len == NUM || m Play List == null ) { return ; } stop ( BOOL ) ; m Play Pos = Math . min ( m Play Pos , m Play List . length - NUM ) ; update Cursor ( m Play List [ m Play Pos ] ) ; while ( BOOL ) { if ( m Cursor != null && ! m Cursor . is Closed ( ) && open File ( Media Store . Audio . Media . EXTERNAL CONTENT URI + STRING + m Cursor . get Long ( IDCOLIDX ) ) ) { break ; } close Cursor ( ) ; if ( m Open Failed Counter ++ < NUM && m Play List Len > NUM ) { final int pos = get Next Position ( BOOL ) ; if ( schedule Shutdown And Notify Play State Change ( pos ) ) return ; m Play Pos = pos ; stop ( BOOL ) ; m Play Pos = pos ; update Cursor ( m Play List [ m Play Pos ] ) ; } else { m Open Failed Counter = NUM ; LOG . warn ( STRING ) ; schedule Delayed Shutdown ( ) ; if ( m Is Supposed To Be Playing ) { m Is Supposed To Be Playing = BOOL ; notify Change ( PLAYSTATE CHANGED ) ; } return ; } } if ( open Next ) { set Next Track ( ) ; } } }
protected OM Node create DTD ( ) throws OM Exception { throw new OM Exception ( STRING ) ; }
private IV Generator ( ) { }
private void create Overview Page ( ) { Remap Overview overview = new Remap Overview ( migration Task , get Container ( ) ) ; int index = add Page ( overview . get Control ( ) ) ; set Page Text ( index , STRING ) ; task Listeners . add ( overview ) ; }
public void warning 2 ( final String filename , int ln , int col , Object msg , String source ) { warning ( filename , ln , col , msg . to String ( ) , source ) ; }
public SOAP Connection open SOAP Connection ( ) throws SOAP Exception { return soap Connection Factory . create Connection ( ) ; }
public static < U , V > String print Map ( final Map < U , V > map , final Converter < U > key Converter , final Converter < V > value Converter ) { final String Builder sb = new String Builder ( STRING ) ; String separator = STRING ; for ( final Entry < U , V > entry : map . entry Set ( ) ) { sb . append ( separator ) ; sb . append ( key Converter . convert ( entry . get Key ( ) ) ) ; sb . append ( STRING ) ; sb . append ( value Converter . convert ( entry . get Value ( ) ) ) ; separator = STRING ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public void find And Init ( Object some Obj ) { if ( some Obj instanceof com . bbn . openmap . Map Bean ) { Debug . message ( STRING , STRING ) ; set Source Map ( ( Map Bean ) some Obj ) ; } }
public static double cdf ( double x , double mu , double shape ) { if ( ! ( x > NUM ) ) { return NUM ; } final double v0 = x / mu ; final double v1 = Math . sqrt ( shape / x ) ; if ( v1 == NUM ) { return v0 > NUM ? NUM : NUM ; } double c1 = Normal Distribution . standard Normal CDF ( v1 * ( v0 - NUM ) ) ; double c2 = Normal Distribution . standard Normal CDF ( - v1 * ( v0 + NUM ) ) ; return ( c2 > NUM ) ? c1 + Math . exp ( NUM * shape / mu ) * c2 : c1 ; }
public void handle Request ( Request Context rc ) throws CLI Exception { super . handle Request ( rc ) ; ldap Login ( ) ; SSO Token admin SSO Token = get Admin SSO Token ( ) ; String service Name = get String Option Value ( I Argument . SERVICE NAME ) ; String interface Name = get String Option Value ( ARGUMENT INTERFACE NAME ) ; String plugin Name = get String Option Value ( ARGUMENT PLUGIN NAME ) ; String i18 n Key = get String Option Value ( ARGUMENT I18 N KEY ) ; String i18 n Name = get String Option Value ( ARGUMENT I18 N NAME ) ; String class Name = get String Option Value ( ARGUMENT CLASS NAME ) ; Service Manager sm = null ; try { sm = new Service Manager ( admin SSO Token ) ; } catch ( SMS Exception smse ) { throw new CLI Exception ( smse , Exit Codes . REQUEST CANNOT BE PROCESSED ) ; } catch ( SSO Exception ssoe ) { throw new CLI Exception ( ssoe , Exit Codes . REQUEST CANNOT BE PROCESSED ) ; } I Output output Writer = get Output Writer ( ) ; try { String [ ] params = { service Name , interface Name , plugin Name , i18 n Key , i18 n Name , class Name } ; write Log ( Log Writer . LOG ACCESS , Level . INFO , STRING , params ) ; Document plugin Doc = create Plugin Schema XML ( service Name , interface Name , plugin Name , i18 n Key , i18 n Name , class Name ) ; if ( plugin Doc != null ) { sm . add Plugin Schema ( plugin Doc ) ; String [ ] params 2 = { service Name , plugin Name } ; write Log ( Log Writer . LOG ACCESS , Level . INFO , STRING , params 2 ) ; output Writer . println Message ( Message Format . format ( get Resource String ( STRING ) , ( Object [ ] ) params ) ) ; } else { String [ ] args = { service Name , plugin Name , STRING } ; debug Error ( STRING ) ; write Log ( Log Writer . LOG ERROR , Level . INFO , STRING , args ) ; throw new CLI Exception ( STRING , Exit Codes . REQUEST CANNOT BE PROCESSED ) ; } } catch ( SSO Exception ssoe ) { String [ ] args = { service Name , plugin Name , ssoe . get Message ( ) } ; debug Error ( STRING , ssoe ) ; write Log ( Log Writer . LOG ERROR , Level . INFO , STRING , args ) ; output Writer . println Message ( Message Format . format ( get Resource String ( STRING ) , ( Object [ ] ) args ) ) ; throw new CLI Exception ( ssoe , Exit Codes . REQUEST CANNOT BE PROCESSED ) ; } catch ( SMS Exception smse ) { String [ ] args = { service Name , plugin Name , smse . get Message ( ) } ; debug Error ( STRING , smse ) ; write Log ( Log Writer . LOG ERROR , Level . INFO , STRING , args ) ; output Writer . println Message ( Message Format . format ( get Resource String ( STRING ) , ( Object [ ] ) args ) ) ; throw new CLI Exception ( smse , Exit Codes . REQUEST CANNOT BE PROCESSED ) ; } }
protected void bflash ( ) throws SAX Exception { if ( m Buff Idx >= NUM ) { m Hand Cont . characters ( m Buff , NUM , ( m Buff Idx + NUM ) ) ; m Buff Idx = - NUM ; } }
protected Mac ( Mac Spi mac Spi , Provider provider , String algorithm ) { this . spi = mac Spi ; this . provider = provider ; this . algorithm = algorithm ; service Iterator = null ; lock = null ; }
public static String path To String ( String dim , String [ ] path ) { String [ ] full Path = new String [ NUM + path . length ] ; full Path [ NUM ] = dim ; System . arraycopy ( path , NUM , full Path , NUM , path . length ) ; return path To String ( full Path , full Path . length ) ; }
public static boolean is Valid Ifd ( int ifd Id ) { return ifd Id == Ifd Id . TYPE IFD 0 || ifd Id == Ifd Id . TYPE IFD 1 || ifd Id == Ifd Id . TYPE IFD EXIF || ifd Id == Ifd Id . TYPE IFD INTEROPERABILITY || ifd Id == Ifd Id . TYPE IFD GPS ; }
public static Cdc Session create Cdc Session Via Domain Auth ( String server Name , String user Name , String user Password ) { if ( server Name == null || server Name . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( user Name == null || user Name . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } return new Cdc Session ( server Name , user Name , user Password ) ; }
protected static Dfp exp Internal ( final Dfp a ) { Dfp y = a . get One ( ) ; Dfp x = a . get One ( ) ; Dfp fact = a . get One ( ) ; Dfp py = new Dfp ( y ) ; for ( int i = NUM ; i < NUM ; i ++ ) { x = x . multiply ( a ) ; fact = fact . divide ( i ) ; y = y . add ( x . multiply ( fact ) ) ; if ( y . equals ( py ) ) { break ; } py = new Dfp ( y ) ; } return y ; }
public URL Connection open Connection ( ) throws IO Exception { return stream Handler . open Connection ( this ) ; }
public static Array List < String [ ] > lines To Array ( Array List < String > in Line ) { Array List < String [ ] > frames En Tab = new Array List < > ( ) ; for ( int i = NUM ; i < in Line . size ( ) ; i ++ ) { frames En Tab . add ( line To Array ( in Line . get ( i ) ) ) ; } return frames En Tab ; }
@ Override public int LA ( int i ) { int la = super . LA ( i ) ; return Character . to Lower Case ( la ) ; }
public void deselect all ( ) { Arrays . fill ( sel array , BOOL ) ; }
@ Override public boolean can Transfer Criticals ( int loc ) { return BOOL ; }
private void calculate Sizes ( final Graphics g ) { m row Height = get Row Height ( g ) ; m char Height = get Char Height ( g ) ; m char Width = get Character Width ( g ) ; }
public static Iterable < Gateway Meta State . Index Meta Write Info > resolve States To Be Written ( Immutable Set < String > previously Written Indices , Set < String > potentially Unwritten Indices , Meta Data previous Meta Data , Meta Data new Meta Data ) { List < Gateway Meta State . Index Meta Write Info > indices To Write = new Array List < > ( ) ; for ( String index : potentially Unwritten Indices ) { Index Meta Data new Index Meta Data = new Meta Data . index ( index ) ; Index Meta Data previous Index Meta Data = previous Meta Data == null ? null : previous Meta Data . index ( index ) ; String write Reason = null ; if ( previously Written Indices . contains ( index ) == BOOL || previous Index Meta Data == null ) { write Reason = STRING ; } else if ( previous Index Meta Data . get Version ( ) != new Index Meta Data . get Version ( ) ) { write Reason = STRING + previous Index Meta Data . get Version ( ) + STRING + new Index Meta Data . get Version ( ) + STRING ; } if ( write Reason != null ) { indices To Write . add ( new Gateway Meta State . Index Meta Write Info ( new Index Meta Data , previous Index Meta Data , write Reason ) ) ; } } return indices To Write ; }
protected double apply Function ( double value ) { switch ( m operator ) { case STRING : return Math . log ( value ) ; case STRING : return Math . abs ( value ) ; case STRING : return Math . cos ( value ) ; case STRING : return Math . exp ( value ) ; case STRING : return Math . sqrt ( value ) ; case STRING : return Math . floor ( value ) ; case STRING : return Math . ceil ( value ) ; case STRING : return Math . rint ( value ) ; case STRING : return Math . tan ( value ) ; case STRING : return Math . sin ( value ) ; } return Double . Na N ; }
private Object deserialize Struct ( Element el Struct ) throws Converter Exception { String type = el Struct . get Attribute ( STRING ) ; Struct struct = new Struct Impl ( ) ; Node List list = el Struct . get Child Nodes ( ) ; int len = list . get Length ( ) ; for ( int i = NUM ; i < len ; i ++ ) { Node node = list . item ( i ) ; if ( node instanceof Element ) { Element var = ( Element ) node ; Element value = get Child Element ( ( Element ) node ) ; if ( value != null ) { struct . set EL ( var . get Attribute ( STRING ) , deserialize ( value ) ) ; } } } if ( struct . size ( ) == NUM && type != null && type . length ( ) > NUM ) { return STRING ; } return struct ; }
public Remote Event dequeue ( ) { Uuid uuid = ready Events . poll ( ) ; if ( uuid == null ) return null ; Single Producer producer = get Producer ( uuid ) ; return producer . pop Next Ready Event ( ) ; }
public Tcp Discovery Vm Ip Finder ( ) { }
public Invalid Properties Format Exception ( String message ) { super ( message ) ; }
public Sub Command ( I Definition definition , Resource Bundle rb , String name , List mandatory Options , List optional Options , List option Aliases , String impl Class Name , boolean web Support , String deprecation Warning ) throws CLI Exception { this . definition = definition ; this . name = name ; this . rb = rb ; this . impl Class Name = impl Class Name ; this . web Support = web Support ; this . deprecation Warning = deprecation Warning ; Set short Options = new Hash Set ( ) ; parse Options ( mandatory Options , this . mandatory Options , short Options ) ; parse Options ( optional Options , this . optional Options , short Options ) ; parse Aliases ( option Aliases ) ; }
public static boolean can Add Class In Package Of ( Class < ? > cls ) { final Package bean Package = cls . get Package ( ) ; if ( bean Package != null ) { if ( bean Package . is Sealed ( ) ) { return BOOL ; } String pname = bean Package . get Name ( ) ; if ( pname . starts With ( STRING ) || pname . starts With ( STRING ) ) { return BOOL ; } } return BOOL ; }
public static Json Token deserialize ( final String jwt ) throws Exception { Json Token Parser parser = new Json Token Parser ( verifier Providers , new Abelana Token Audience Checker ( Backend Constants . TOKEN ISSUER ) ) ; return parser . deserialize ( jwt ) ; }
public void swap Suggestions ( final List < ? extends Search Suggestion > new Search Suggestions ) { Collections . reverse ( new Search Suggestions ) ; swap Suggestions ( new Search Suggestions , BOOL ) ; }
boolean should Animate Search Provider Icon ( Selection Type selection Type , boolean is Showing ) { if ( is Showing || Contextual Search Field Trial . are Extra Search Bar Animations Disabled ( ) ) { return BOOL ; } if ( selection Type == Selection Type . TAP ) { long current Time Millis = System . current Time Millis ( ) ; long last Animated Time Millis = m Preference Manager . get Contextual Search Last Animation Time ( ) ; if ( Math . abs ( current Time Millis - last Animated Time Millis ) > ONE DAY IN MILLIS ) { m Preference Manager . set Contextual Search Last Animation Time ( current Time Millis ) ; return BOOL ; } else { return BOOL ; } } else if ( selection Type == Selection Type . LONG PRESS ) { return get Promo Open Count ( ) == NUM ; } return BOOL ; }
public void wait For ( ) { check Started ( ) ; try { if ( my Input Processor != null && my Process != null ) { my Input Processor . process ( my Process . get Output Stream ( ) ) ; } } finally { wait For Process ( ) ; } }
public static String extract Uri From Address ( String addr ) { String uri = addr ; int index = addr . index Of ( STRING ) ; if ( index != - NUM ) { uri = addr . substring ( index + NUM , addr . index Of ( STRING , index ) ) ; } return uri ; }
PBKDF 2 Key Impl ( PBE Key Spec key Spec , String prf Algo ) throws Invalid Key Spec Exception { char [ ] passwd = key Spec . get Password ( ) ; if ( passwd == null ) { this . passwd = new char [ NUM ] ; } else { this . passwd = passwd . clone ( ) ; } byte [ ] passwd Bytes = get Password Bytes ( this . passwd ) ; this . salt = key Spec . get Salt ( ) ; if ( salt == null ) { throw new Invalid Key Spec Exception ( STRING ) ; } this . iter Count = key Spec . get Iteration Count ( ) ; if ( iter Count == NUM ) { throw new Invalid Key Spec Exception ( STRING ) ; } else if ( iter Count < NUM ) { throw new Invalid Key Spec Exception ( STRING ) ; } int key Length = key Spec . get Key Length ( ) ; if ( key Length == NUM ) { throw new Invalid Key Spec Exception ( STRING ) ; } else if ( key Length < NUM ) { throw new Invalid Key Spec Exception ( STRING ) ; } try { this . prf = Mac . get Instance ( prf Algo , Sun JCE . get Instance ( ) ) ; } catch ( No Such Algorithm Exception nsae ) { Invalid Key Spec Exception ike = new Invalid Key Spec Exception ( ) ; ike . init Cause ( nsae ) ; throw ike ; } this . key = derive Key ( prf , passwd Bytes , salt , iter Count , key Length ) ; }
private static void show Directory Creation Error ( final String directory ) { final String message = STRING + STRING ; final String description = C Utility Functions . create Description ( String . format ( STRING , directory ) , new String [ ] { STRING } , new String [ ] { STRING , STRING } ) ; Navi Error Dialog . show ( null , message , description ) ; }
static byte [ ] pad ( byte [ ] data ) { int len ; if ( data . length < NUM ) len = data . length ; else len = data . length % NUM ; if ( len == NUM ) return data ; else { byte [ ] padding = new byte [ NUM - len + data . length ] ; for ( int i = padding . length - NUM ; i > data . length - NUM ; i -- ) { padding [ i ] = NUM ; } System . arraycopy ( data , NUM , padding , NUM , data . length ) ; return padding ; } }
public void serialize ( Data Output out ) throws IO Exception { out . write UTF ( id ) ; out . write UTF ( version ) ; out . write Int ( source Files . size ( ) ) ; for ( Entry < String , List < Revision File > > e : source Files . entry Set ( ) ) { out . write UTF ( e . get Key ( ) ) ; List < Revision File > files = e . get Value ( ) ; out . write Int ( files . size ( ) ) ; for ( Revision File file : files ) { out . write UTF ( file . file Name ) ; out . write Long ( file . size ) ; } } }
public Named Column Projection ( String [ ] names , boolean include ) { m names = new Hash Set ( ) ; for ( int i = NUM ; i < names . length ; ++ i ) m names . add ( names [ i ] ) ; m include = include ; }
public static Time Series Data serializable Instance ( ) { List < String > var Names = new Array List < > ( ) ; var Names . add ( STRING ) ; var Names . add ( STRING ) ; return new Time Series Data ( new Tetrad Matrix ( NUM , NUM ) , var Names ) ; }
@ Override public void write Vertices ( final Output Stream output Stream , final Iterator < Vertex > vertex Iterator , final Direction direction ) throws IO Exception { final Buffered Writer writer = new Buffered Writer ( new Output Stream Writer ( output Stream ) ) ; try ( final Byte Array Output Stream baos = new Byte Array Output Stream ( ) ) { if ( wrap Adjacency List ) writer . write ( STRING + Graph SON Tokens . VERTICES + STRING ) ; while ( vertex Iterator . has Next ( ) ) { write Vertex ( baos , vertex Iterator . next ( ) , direction ) ; writer . write ( new String ( baos . to Byte Array ( ) ) ) ; if ( wrap Adjacency List ) { if ( vertex Iterator . has Next ( ) ) writer . write ( STRING ) ; } else { writer . new Line ( ) ; } baos . reset ( ) ; } if ( wrap Adjacency List ) writer . write ( STRING ) ; } writer . flush ( ) ; }
Collection < ? extends Client Request Result > handle Retrieve Configurations Request ( final Client Request configuration Request , final Session session , final Destination reply Destination ) { if ( configuration Request . get Request Parameter ( ) != null ) { return configuration Loader . get Configuration Reports ( configuration Request . get Request Parameter ( ) ) ; } else { return configuration Loader . get Configuration Reports ( ) ; } }
public static boolean contains Class ( @ Not Null File file , String class Name ) { String entry Path = class Name . replace ( STRING , STRING ) + STRING ; return contains Entry ( file , entry Path ) ; }
private double sin ( double angle ) { while ( angle >= NUM ) { angle -= NUM ; } double value = angle / NUM * Math . PI ; return Math . sin ( value ) ; }
public void remove ( T graphic ) { synchronized ( m Lock ) { m Graphics . remove ( graphic ) ; } post Invalidate ( ) ; }
private static void launch Debugger ( String dml Script Str , String fname Opt Config , Map < String , String > arg Vals , boolean parse Py DML ) throws Parse Exception , IO Exception , DML Runtime Exception , DML Debugger Exception , Language Exception , Hops Exception , Lops Exception { DML Debugger Program Info dbprog = new DML Debugger Program Info ( ) ; DML Config conf = DML Config . read Configuration File ( fname Opt Config ) ; Configuration Manager . set Global Config ( conf ) ; A Parser Wrapper parser = A Parser Wrapper . create Parser ( parse Py DML ) ; DML Program prog = parser . parse ( DML FILE PATH ANTLR PARSER , dml Script Str , arg Vals ) ; DML Translator dmlt = new DML Translator ( prog ) ; dmlt . live Variable Analysis ( prog ) ; dmlt . validate Parse Tree ( prog ) ; dmlt . construct Hops ( prog ) ; dmlt . rewrite Hops DAG ( prog ) ; dmlt . construct Lops ( prog ) ; dbprog . rtprog = prog . get Runtime Program ( conf ) ; try { init Hadoop Execution ( conf ) ; DML Debugger System M Ldb = new DML Debugger ( dbprog , dml Script Str ) ; System M Ldb . run System ML Debugger ( ) ; } finally { cleanup Hadoop Execution ( conf ) ; } }
public static final Index create Test Bank Index Approved On ( ) { Index lastname = new Index ( STRING ) ; lastname . is Unique ( BOOL ) ; Array List < Index Field > fields = new Array List < > ( NUM ) ; fields . add ( new Index Field ( STRING , Field Data Type . DATE TIME ) ) ; lastname . set Fields ( fields ) ; lastname . set Table ( Fixtures . create Test World Bank Table ( ) ) ; return lastname ; }
public static byte [ ] decode ( String encoded ) { if ( encoded == null ) { return null ; } char [ ] base 64 Data = encoded . to Char Array ( ) ; int len = remove White Space ( base 64 Data ) ; if ( len % FOURBYTE != NUM ) { return null ; } int number Quadruple = ( len / FOURBYTE ) ; if ( number Quadruple == NUM ) { return new byte [ NUM ] ; } byte decoded Data [ ] = null ; byte b1 = NUM , b2 = NUM , b3 = NUM , b4 = NUM ; char d1 = NUM , d2 = NUM , d3 = NUM , d4 = NUM ; int i = NUM ; int encoded Index = NUM ; int data Index = NUM ; decoded Data = new byte [ ( number Quadruple ) * NUM ] ; for ( ; i < number Quadruple - NUM ; i ++ ) { if ( ! is Data ( ( d1 = base 64 Data [ data Index ++ ] ) ) || ! is Data ( ( d2 = base 64 Data [ data Index ++ ] ) ) || ! is Data ( ( d3 = base 64 Data [ data Index ++ ] ) ) || ! is Data ( ( d4 = base 64 Data [ data Index ++ ] ) ) ) { return null ; } b1 = base 64 Alphabet [ d1 ] ; b2 = base 64 Alphabet [ d2 ] ; b3 = base 64 Alphabet [ d3 ] ; b4 = base 64 Alphabet [ d4 ] ; decoded Data [ encoded Index ++ ] = ( byte ) ( b1 << NUM | b2 > > NUM ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( b3 << NUM | b4 ) ; } if ( ! is Data ( ( d1 = base 64 Data [ data Index ++ ] ) ) || ! is Data ( ( d2 = base 64 Data [ data Index ++ ] ) ) ) { return null ; } b1 = base 64 Alphabet [ d1 ] ; b2 = base 64 Alphabet [ d2 ] ; d3 = base 64 Data [ data Index ++ ] ; d4 = base 64 Data [ data Index ++ ] ; if ( ! is Data ( ( d3 ) ) || ! is Data ( ( d4 ) ) ) { if ( is Pad ( d3 ) && is Pad ( d4 ) ) { if ( ( b2 & NUM ) != NUM ) { return null ; } byte [ ] tmp = new byte [ i * NUM + NUM ] ; System . arraycopy ( decoded Data , NUM , tmp , NUM , i * NUM ) ; tmp [ encoded Index ] = ( byte ) ( b1 << NUM | b2 > > NUM ) ; return tmp ; } else if ( ! is Pad ( d3 ) && is Pad ( d4 ) ) { b3 = base 64 Alphabet [ d3 ] ; if ( ( b3 & NUM ) != NUM ) { return null ; } byte [ ] tmp = new byte [ i * NUM + NUM ] ; System . arraycopy ( decoded Data , NUM , tmp , NUM , i * NUM ) ; tmp [ encoded Index ++ ] = ( byte ) ( b1 << NUM | b2 > > NUM ) ; tmp [ encoded Index ] = ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ; return tmp ; } else { return null ; } } else { b3 = base 64 Alphabet [ d3 ] ; b4 = base 64 Alphabet [ d4 ] ; decoded Data [ encoded Index ++ ] = ( byte ) ( b1 << NUM | b2 > > NUM ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( b3 << NUM | b4 ) ; } return decoded Data ; }
public synchronized void accessed ( Object object ) { history List . remove ( object ) ; history List . add ( object ) ; }
public static boolean is Empty ( String string ) { return string == null || string . length ( ) <= NUM ; }
@ Override @ Suppress Warnings ( STRING ) protected void heapify Up Comparable ( int pos , Object elem ) { final Comparable < Object > cur = ( Comparable < Object > ) elem ; while ( pos > NUM ) { final int parent = ( pos - NUM ) > > > NUM ; Object par = queue [ parent ] ; if ( cur . compare To ( par ) >= NUM ) { break ; } queue [ pos ] = par ; index . put ( par , pos ) ; pos = parent ; } queue [ pos ] = cur ; index . put ( cur , pos ) ; }
private void update Release Locks ( ) throws Cache Exception { if ( num Locks . add And Get ( - NUM ) < NUM ) { throw new Cache Exception ( STRING ) ; } if ( eviction Policy == Eviction Policy . LRU ) { timestamp . set ( System . nano Time ( ) ) ; } else if ( eviction Policy == Eviction Policy . LFU ) { timestamp . add And Get ( NUM ) ; } else if ( eviction Policy == Eviction Policy . MIN EVICT ) { } else { throw new Cache Exception ( STRING + eviction Policy . name ( ) ) ; } }
public static Short to Short ( char c ) { return Short . value Of ( to Short Value ( c ) ) ; }
protected Geo Point [ ] find Crossings ( final Planet Model planet Model , final Plane q , final Membership [ ] bounds , final Membership [ ] more Bounds ) { final double line Vector X = y * q . z - z * q . y ; final double line Vector Y = z * q . x - x * q . z ; final double line Vector Z = x * q . y - y * q . x ; if ( Math . abs ( line Vector X ) < MINIMUM RESOLUTION && Math . abs ( line Vector Y ) < MINIMUM RESOLUTION && Math . abs ( line Vector Z ) < MINIMUM RESOLUTION ) { return NO POINTS ; } double x0 ; double y0 ; double z0 ; final double denom YZ = this . y * q . z - this . z * q . y ; final double denom XZ = this . x * q . z - this . z * q . x ; final double denom XY = this . x * q . y - this . y * q . x ; if ( Math . abs ( denom YZ ) >= Math . abs ( denom XZ ) && Math . abs ( denom YZ ) >= Math . abs ( denom XY ) ) { if ( Math . abs ( denom YZ ) < MINIMUM RESOLUTION SQUARED ) { return NO POINTS ; } final double denom = NUM / denom YZ ; x0 = NUM ; y0 = ( - this . D * q . z - this . z * - q . D ) * denom ; z0 = ( this . y * - q . D + this . D * q . y ) * denom ; } else if ( Math . abs ( denom XZ ) >= Math . abs ( denom XY ) && Math . abs ( denom XZ ) >= Math . abs ( denom YZ ) ) { if ( Math . abs ( denom XZ ) < MINIMUM RESOLUTION SQUARED ) { return NO POINTS ; } final double denom = NUM / denom XZ ; x0 = ( - this . D * q . z - this . z * - q . D ) * denom ; y0 = NUM ; z0 = ( this . x * - q . D + this . D * q . x ) * denom ; } else { if ( Math . abs ( denom XY ) < MINIMUM RESOLUTION SQUARED ) { return NO POINTS ; } final double denom = NUM / denom XY ; x0 = ( - this . D * q . y - this . y * - q . D ) * denom ; y0 = ( this . x * - q . D + this . D * q . x ) * denom ; z0 = NUM ; } final double A = line Vector X * line Vector X * planet Model . inverse Ab Squared + line Vector Y * line Vector Y * planet Model . inverse Ab Squared + line Vector Z * line Vector Z * planet Model . inverse C Squared ; final double B = NUM * ( line Vector X * x0 * planet Model . inverse Ab Squared + line Vector Y * y0 * planet Model . inverse Ab Squared + line Vector Z * z0 * planet Model . inverse C Squared ) ; final double C = x0 * x0 * planet Model . inverse Ab Squared + y0 * y0 * planet Model . inverse Ab Squared + z0 * z0 * planet Model . inverse C Squared - NUM ; final double Bsquared Minus = B * B - NUM * A * C ; if ( Math . abs ( Bsquared Minus ) < MINIMUM RESOLUTION SQUARED ) { return NO POINTS ; } else if ( Bsquared Minus > NUM ) { final double inverse 2 A = NUM / ( NUM * A ) ; final double sqrt Term = Math . sqrt ( Bsquared Minus ) ; final double t1 = ( - B + sqrt Term ) * inverse 2 A ; final double t2 = ( - B - sqrt Term ) * inverse 2 A ; final double point 1 X = line Vector X * t1 + x0 ; final double point 1 Y = line Vector Y * t1 + y0 ; final double point 1 Z = line Vector Z * t1 + z0 ; final double point 2 X = line Vector X * t2 + x0 ; final double point 2 Y = line Vector Y * t2 + y0 ; final double point 2 Z = line Vector Z * t2 + z0 ; boolean point 1 Valid = BOOL ; boolean point 2 Valid = BOOL ; for ( final Membership bound : bounds ) { if ( ! bound . is Within ( point 1 X , point 1 Y , point 1 Z ) ) { point 1 Valid = BOOL ; break ; } } if ( point 1 Valid ) { for ( final Membership bound : more Bounds ) { if ( ! bound . is Within ( point 1 X , point 1 Y , point 1 Z ) ) { point 1 Valid = BOOL ; break ; } } } for ( final Membership bound : bounds ) { if ( ! bound . is Within ( point 2 X , point 2 Y , point 2 Z ) ) { point 2 Valid = BOOL ; break ; } } if ( point 2 Valid ) { for ( final Membership bound : more Bounds ) { if ( ! bound . is Within ( point 2 X , point 2 Y , point 2 Z ) ) { point 2 Valid = BOOL ; break ; } } } if ( point 1 Valid && point 2 Valid ) { return new Geo Point [ ] { new Geo Point ( point 1 X , point 1 Y , point 1 Z ) , new Geo Point ( point 2 X , point 2 Y , point 2 Z ) } ; } if ( point 1 Valid ) { return new Geo Point [ ] { new Geo Point ( point 1 X , point 1 Y , point 1 Z ) } ; } if ( point 2 Valid ) { return new Geo Point [ ] { new Geo Point ( point 2 X , point 2 Y , point 2 Z ) } ; } return NO POINTS ; } else { return NO POINTS ; } }
public static void encode Dimension ( float value , byte dest [ ] , int offset ) { Numeric Utils . int To Sortable Bytes ( Numeric Utils . float To Sortable Int ( value ) , dest , offset ) ; }
public long minflt ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
public static String to String ( final float value ) { return Float . to String ( value ) ; }
public void end Filter Interval ( ) { end Millis = System . current Time Millis ( ) ; total Filter Millis += ( end Millis - interval Start Millis ) ; state = Task State . other ; }
public String process ( String to process ) { if ( to process == null || to process . length ( ) == NUM ) return STRING ; String tmp = STRING ; String Tokenizer st = new String Tokenizer ( to process , STRING , BOOL ) ; String Buffer new Value = new String Buffer ( to process . length ( ) + NUM ) ; while ( st . has More Tokens ( ) ) { tmp = st . next Token ( ) ; if ( has Attribute ( tmp ) ) new Value . append ( ( String ) get ( tmp ) ) ; else new Value . append ( tmp ) ; } return new Value . to String ( ) ; }
@ Benchmark public long test 2 Using For Each And Map Entry ( ) throws IO Exception { long i = NUM ; for ( Map . Entry < Integer , Integer > pair : map . entry Set ( ) ) { i += pair . get Key ( ) + pair . get Value ( ) ; } return i ; }
public static final void write List Xml ( List val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int n = val . size ( ) ; int i = NUM ; while ( i < n ) { write Value Xml ( val . get ( i ) , null , out ) ; i ++ ; } out . end Tag ( null , STRING ) ; }
public static String convert To RGB ( int color ) { String red = Integer . to Hex String ( Color . red ( color ) ) ; String green = Integer . to Hex String ( Color . green ( color ) ) ; String blue = Integer . to Hex String ( Color . blue ( color ) ) ; if ( red . length ( ) == NUM ) { red = STRING + red ; } if ( green . length ( ) == NUM ) { green = STRING + green ; } if ( blue . length ( ) == NUM ) { blue = STRING + blue ; } return STRING + red + green + blue ; }
public static String hash Key For Disk ( String key ) { String cache Key ; try { final Message Digest m Digest = Message Digest . get Instance ( STRING ) ; m Digest . update ( key . get Bytes ( ) ) ; cache Key = bytes To Hex String ( m Digest . digest ( ) ) ; } catch ( No Such Algorithm Exception e ) { cache Key = String . value Of ( key . hash Code ( ) ) ; } return cache Key ; }
private void change Password ( String user Type , String old Password , String new Password ) throws Exception { String file Enc Password = get User Password ( user Type ) ; String user DN = get User DN ( user Type ) ; if ( ( file Enc Password == null ) || ( file Enc Password . length ( ) == NUM ) || ( user DN == null ) || ( user DN . length ( ) == NUM ) ) { debug . error ( STRING + user Type + STRING + config File ) ; throw new XML Exception ( i18 n . get String ( STRING ) ) ; } if ( ! old Password . equals ( Access Controller . do Privileged ( new Decode Action ( file Enc Password ) ) ) ) { throw new Exception ( i18 n . get String ( STRING ) ) ; } if ( is AMSDK Configured ) { try { new Auth Context ( new Auth Principal ( user DN ) , new Password . to Char Array ( ) ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + user DN + STRING ) ; } } catch ( Login Exception lee ) { try { Auth Context ac = new Auth Context ( new Auth Principal ( user DN ) , old Password . to Char Array ( ) ) ; Persistent Object user = UMS Object . get Object ( ac . get SSO Token ( ) , new Guid ( user DN ) ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + user DN + STRING ) ; } user . set Attribute ( new Attr ( STRING , new Password ) ) ; user . save ( ) ; } catch ( Login Exception le ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STRING + user DN + STRING ) ; } throw new Exception ( i18 n . get String ( STRING ) + STRING + le . get Message ( ) ) ; } } } set User Password ( user Type , new Password ) ; }
public int hash Code ( Object key ) { return ( key . hash Code ( ) & NUM ) % this . key Table . length ; }
public Atomic Array Base ( E [ ] array ) { this . array = Arrays . copy Of ( array , array . length , Object [ ] . class ) ; }
public void apply ( ) { set Speed Map ( ) ; set N Xdata ( ) ; }
private E unlink First ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; not Full . signal ( ) ; return item ; }
public void push ( final String value ) { if ( value == null ) { mv . visit Insn ( Opcodes . ACONST NULL ) ; } else { mv . visit Ldc Insn ( value ) ; } }
public void init ( ) { m project Tree . set Selection Path ( new Tree Path ( m project Tree . get Root Node ( ) ) ) ; }
public int read ( ) throws IO Exception { return is . read ( ) ; }
private void display Calendar ( ) { Key Name Pair pp = ( Key Name Pair ) field Resource . get Selected Item ( ) ; if ( pp == null ) return ; int S Resource ID = pp . get Key ( ) ; m m Assignment . set S Resource ID ( S Resource ID ) ; Timestamp date = field Date . get Timestamp ( ) ; int index = time Pane . get Selected Index ( ) ; log . config ( STRING + index + STRING + S Resource ID + STRING + date ) ; m loading = BOOL ; if ( index == NUM ) day Schedule . recreate ( S Resource ID , date ) ; else if ( index == NUM ) week Schedule . recreate ( S Resource ID , date ) ; else month Schedule . recreate ( S Resource ID , date ) ; m loading = BOOL ; repaint ( ) ; }
public static void assert Exception ( Runtime Exception exception , Runnable expression , String error Message ) { if ( verbose ) { log ( STRING + exception + STRING + expression + STRING + error Message + STRING ) ; } try { expression . run ( ) ; } catch ( Runtime Exception failure ) { if ( exception . get Class ( ) != failure . get Class ( ) ) { Test Utils . fail ( error Message ) ; } return ; } Test Utils . fail ( error Message ) ; }
public boolean is Parity Correct ( byte [ ] [ ] shards , int first Byte , int byte Count ) { check Buffers And Sizes ( shards , first Byte , byte Count ) ; byte [ ] [ ] to Check = new byte [ parity Shard Count ] [ ] ; System . arraycopy ( shards , data Shard Count , to Check , NUM , parity Shard Count ) ; return coding Loop . check Some Shards ( parity Rows , shards , data Shard Count , to Check , parity Shard Count , first Byte , byte Count , null ) ; }
protected void on Send Success ( Record Buffer < R > buffer ) { send Success . increment And Get ( ) ; logger . trace ( STRING , name ( ) , buffer ) ; try { checkpointer . save Checkpoint ( buffer ) ; } catch ( Exception e ) { logger . error ( STRING , name ( ) , buffer , e ) ; } }
public synchronized void write To ( Output Stream out ) throws IO Exception { int remaining = count ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; out . write ( buf , NUM , c ) ; remaining -= c ; if ( remaining == NUM ) { break ; } } }
public void test service 004 ( ) throws Exception { final Bigdata URI service URI = value Factory . create URI ( STRING ) ; final Graph Pattern Group < I Group Member Node > group Node = new Join Group Node ( ) ; { group Node . add Child ( new Statement Pattern Node ( new Var Node ( STRING ) , new Var Node ( STRING ) , new Var Node ( STRING ) ) ) ; } final String expr Image = STRING + service URI + STRING ; final Map < String , String > prefix Decls = new Linked Hash Map < String , String > ( Prefix Decl Processor . default Decls ) ; final Service Node service Node = new Service Node ( new Constant Node ( make IV ( service URI ) ) , group Node ) ; { final Set < I Variable < ? > > projected Vars = new Linked Hash Set < I Variable < ? > > ( ) ; { projected Vars . add ( Var . var ( STRING ) ) ; projected Vars . add ( Var . var ( STRING ) ) ; projected Vars . add ( Var . var ( STRING ) ) ; } service Node . set Expr Image ( expr Image ) ; service Node . set Prefix Decls ( prefix Decls ) ; service Node . set Projected Vars ( projected Vars ) ; } final List < Binding Set > binding Sets = new Linked List < Binding Set > ( ) ; { final Map Binding Set bset = new Map Binding Set ( ) ; bset . add Binding ( STRING , new B Node Impl ( STRING ) ) ; binding Sets . add ( bset ) ; } final Binding Set [ ] a = binding Sets . to Array ( new Binding Set [ binding Sets . size ( ) ] ) ; final I Remote Sparql Query Builder fixture = new Fixture ( service Node , a ) ; final String query Str = fixture . get Sparql Query ( a ) ; final Query Root expected = new Query Root ( Query Type . SELECT ) ; { expected . set Prefix Decls ( prefix Decls ) ; final Projection Node projection = new Projection Node ( ) ; projection . add Projection Var ( new Var Node ( STRING ) ) ; projection . add Projection Var ( new Var Node ( STRING ) ) ; projection . add Projection Var ( new Var Node ( STRING ) ) ; expected . set Projection ( projection ) ; final Join Group Node where Clause = new Join Group Node ( ) ; where Clause . add Child ( new Statement Pattern Node ( new Var Node ( STRING ) , new Var Node ( STRING ) , new Var Node ( STRING ) , null , Scope . DEFAULT CONTEXTS ) ) ; expected . set Where Clause ( where Clause ) ; { final Linked Hash Set < I Variable < ? > > vars = new Linked Hash Set < I Variable < ? > > ( ) ; final List < I Binding Set > solutions In = new Linked List < I Binding Set > ( ) ; final Bindings Clause bindings Clause = new Bindings Clause ( vars , solutions In ) ; expected . set Bindings Clause ( bindings Clause ) ; { vars . add ( Var . var ( STRING ) ) ; } { final List Binding Set bset = new List Binding Set ( ) ; solutions In . add ( bset ) ; } } } final Query Root actual = parse ( query Str , base URI ) ; assert Same AST ( query Str , expected , actual ) ; }
private boolean is Dirty ( ) { return ! Objects . equals ( input List . key Set ( ) , cmr Repository Manager . get Cmr Repository Definitions ( ) ) ; }
public void write ( String s , int off , int len ) { if ( text != null ) { text . append ( s . substring ( off , off + len ) ) ; if ( ( col += len ) > wrap ) println ( ) ; } else { super . write ( s , off , len ) ; flush ( ) ; } }
public Zoneset show Active Zoneset ( Integer vsan Id ) throws Network Device Controller Exception { List < Zoneset > zonesets = show Zoneset ( vsan Id , BOOL , null , BOOL , BOOL ) ; return zonesets . is Empty ( ) ? null : zonesets . get ( NUM ) ; }
private final short validate Perm Split Factor ( String split Factor ) throws Ade Flow Exception { short perm Split Factor = Short . parse Short ( split Factor ) ; if ( perm Split Factor <= NUM || ( ( m outer Framing Flow . get Duration ( ) / perm Split Factor ) < MILLISECONDS IN ONE MINUTE ) ) { throw new Ade Flow Exception ( STRING ) ; } return perm Split Factor ; }
public static Calendar to Calendar ( String datestring , String format ) { Date d = parse ( datestring , format ) ; Calendar cal = Calendar . get Instance ( ) ; cal . set Time In Millis ( d . get Time ( ) ) ; return cal ; }
public void test Compare To Diff Signs 2 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; assert Equals ( - NUM , a Number . compare To ( b Number ) ) ; }
private static void translate Compatibility To Paths ( RP Action action ) { if ( action . has ( Equip Action Consts . BASE OBJECT ) ) { List < String > path = Arrays . as List ( action . get ( Equip Action Consts . BASE OBJECT ) , action . get ( Equip Action Consts . BASE SLOT ) , action . get ( Equip Action Consts . BASE ITEM ) ) ; action . put ( Equip Action Consts . SOURCE PATH , path ) ; } else { List < String > path = Arrays . as List ( action . get ( Equip Action Consts . BASE ITEM ) ) ; action . put ( Equip Action Consts . SOURCE PATH , path ) ; } }
public Builder add Menu Item ( @ Non Null String label , @ Non Null Pending Intent pending Intent ) { if ( m Menu Items == null ) m Menu Items = new Array List < > ( ) ; Bundle bundle = new Bundle ( ) ; bundle . put String ( KEY MENU ITEM TITLE , label ) ; bundle . put Parcelable ( KEY PENDING INTENT , pending Intent ) ; m Menu Items . add ( bundle ) ; return this ; }
public Sparse Float Vector ( T Int Float Map values , int dimensionality ) throws Illegal Argument Exception { if ( values . size ( ) > dimensionality ) { throw new Illegal Argument Exception ( STRING ) ; } this . indexes = new int [ values . size ( ) ] ; this . values = new float [ values . size ( ) ] ; { T Int Float Iterator iter = values . iterator ( ) ; for ( int i = NUM ; iter . has Next ( ) ; i ++ ) { iter . advance ( ) ; this . indexes [ i ] = iter . key ( ) ; } Arrays . sort ( this . indexes ) ; } { for ( int i = NUM ; i < values . size ( ) ; i ++ ) { this . values [ i ] = values . get ( this . indexes [ i ] ) ; } } this . dimensionality = dimensionality ; final int maxdim = get Max Dim ( ) ; if ( maxdim > dimensionality ) { throw new Illegal Argument Exception ( STRING + dimensionality + STRING + maxdim + STRING ) ; } }
public byte [ ] canon Serialize To Byte Array ( Node node ) throws Exception { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; canon . set Writer ( baos ) ; canon . not Reset ( ) ; canon . canonicalize Subtree ( node ) ; return baos . to Byte Array ( ) ; }
public Defined Method add Description ( String description ) { this . description = Optional . of ( description ) ; return this ; }
public int add Flattened Column ( Object o , int [ ] dims ) throws Fits Exception { return add Flattened Column ( o , dims , BOOL ) ; }
public final void write To Stream ( Data Output Stream dos ) throws IO Exception { dos . write UTF ( event ) ; dos . write UTF ( site ) ; dos . write UTF ( date ) ; dos . write UTF ( round ) ; dos . write UTF ( white ) ; dos . write UTF ( black ) ; dos . write UTF ( Text IO . to FEN ( start Pos ) ) ; dos . write UTF ( time Control ) ; dos . write UTF ( white Time Control ) ; dos . write UTF ( black Time Control ) ; int n Tags = tag Pairs . size ( ) ; dos . write Int ( n Tags ) ; for ( int i = NUM ; i < n Tags ; i ++ ) { dos . write UTF ( tag Pairs . get ( i ) . tag Name ) ; dos . write UTF ( tag Pairs . get ( i ) . tag Value ) ; } Node . write To Stream ( dos , root Node ) ; Array List < Integer > path From Root = current Node . get Path From Root ( ) ; int path Len = path From Root . size ( ) ; dos . write Int ( path Len ) ; for ( int i = NUM ; i < path Len ; i ++ ) dos . write Int ( path From Root . get ( i ) ) ; }
public void register Source ( Progress Source pi ) { synchronized ( progress Source List ) { if ( progress Source List . contains ( pi ) ) return ; progress Source List . add ( pi ) ; } if ( progress Listener List . size ( ) > NUM ) { Array List < Progress Listener > listeners = new Array List < Progress Listener > ( ) ; synchronized ( progress Listener List ) { for ( Iterator < Progress Listener > iter = progress Listener List . iterator ( ) ; iter . has Next ( ) ; ) { listeners . add ( iter . next ( ) ) ; } } for ( Iterator < Progress Listener > iter = listeners . iterator ( ) ; iter . has Next ( ) ; ) { Progress Listener pl = iter . next ( ) ; Progress Event pe = new Progress Event ( pi , pi . get URL ( ) , pi . get Method ( ) , pi . get Content Type ( ) , pi . get State ( ) , pi . get Progress ( ) , pi . get Expected ( ) ) ; pl . progress Start ( pe ) ; } } }
private static Map < String , String > extract Key Value Pairs ( String props , Object Name mbean ) { Map < String , String > map = new Linked Hash Map < String , String > ( ) ; int eq = props . index Of ( STRING ) ; while ( eq != - NUM ) { String key = props . substring ( NUM , eq ) ; String value = mbean . get Key Property ( key ) ; map . put ( key , value ) ; props = props . substring ( key . length ( ) + NUM + value . length ( ) ) ; if ( props . starts With ( STRING ) ) { props = props . substring ( NUM ) ; } eq = props . index Of ( STRING ) ; } return map ; }
protected void paint Content Border Left Edge ( Graphics g , int tab Placement , int selected Index , int x , int y , int w , int h ) { Rectangle sel Rect = selected Index < NUM ? null : get Tab Bounds ( selected Index , calc Rect ) ; g . set Color ( select Highlight ) ; if ( tab Placement != LEFT || selected Index < NUM || ( sel Rect . x + sel Rect . width + NUM < x ) || ( sel Rect . y < y || sel Rect . y > y + h ) ) { g . draw Line ( x , y , x , y + h - NUM ) ; } else { g . draw Line ( x , y , x , sel Rect . y + NUM ) ; if ( sel Rect . y + sel Rect . height < y + h - NUM ) g . draw Line ( x , sel Rect . y + sel Rect . height + NUM , x , y + h - NUM ) ; } }
public final Flux < T > sample ( Duration timespan ) { return sample Millis ( timespan . to Millis ( ) ) ; }
@ Override public boolean has Values Description ( ) { return restriction Class != null && restriction Class != Object . class ; }
public Smb File ( String url ) throws Malformed URL Exception { this ( new URL ( null , url , Handler . SMB HANDLER ) ) ; }
public static boolean is Audio ( String mime Type ) { if ( mime Type != null ) { if ( mime Type . starts With ( STRING ) ) return BOOL ; else return BOOL ; } else return BOOL ; }
private void restore Widget ( Key key , byte [ ] buffer , int data Size ) throws IO Exception { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base 64 . encode To String ( buffer , NUM , data Size , Base 64 . NO WRAP ) ) ; Widget widget = unpack Proto ( new Widget ( ) , buffer , data Size ) ; if ( DEBUG ) Log . d ( TAG , STRING + widget . provider ) ; if ( widget . icon . data != null ) { Bitmap icon = Bitmap Factory . decode Byte Array ( widget . icon . data , NUM , widget . icon . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } else { Icon Cache . preload Icon ( m Context , Component Name . unflatten From String ( widget . provider ) , icon , widget . icon . dpi ) ; } } }
protected int assert Line Terminates ( int c ) throws IO Exception , RDF Parse Exception { c = reader . read ( ) ; c = skip Whitespace ( c ) ; if ( c != - NUM && c != STRING && c != STRING ) { report Fatal Error ( STRING ) ; } return c ; }
static private XML Event construct Event ( int event Type , Wb Xml Stream Reader stream ) throws XML Stream Exception { log . log ( Level . FINE , STRING ) ; XML Event event ; switch ( event Type ) { case XML Stream Constants . START DOCUMENT : event = new Wb Xml Start Document Event ( stream ) ; break ; case XML Stream Constants . END DOCUMENT : event = new Wb Xml End Document Event ( stream ) ; break ; case XML Stream Constants . START ELEMENT : event = new Wb Xml Start Element Event ( stream ) ; break ; case XML Stream Constants . END ELEMENT : event = new Wb Xml End Element Event ( stream ) ; break ; case XML Stream Constants . CHARACTERS : case XML Stream Constants . CDATA : event = new Wb Xml Characters Event ( stream ) ; break ; default : throw new Unsupported Operation Exception ( String . format ( STRING , event Type ) ) ; } log . log ( Level . FINE , STRING , event ) ; return event ; }
private void verify Grid State ( ) { Integer row Length = null ; int row Pos = NUM ; for ( List < Object > row : grid ) { if ( row Length != null && row Length != row . size ( ) ) { throw new Illegal State Exception ( STRING + row Length + STRING + row . size ( ) + STRING + row Pos ) ; } row Pos ++ ; row Length = row . size ( ) ; } }
public static String read String And Close ( Reader in , int length ) throws IO Exception { try { if ( length <= NUM ) { length = Integer . MAX VALUE ; } int block = Math . min ( Constants . IO BUFFER SIZE , length ) ; String Writer out = new String Writer ( block ) ; copy And Close Input ( in , out , length ) ; return out . to String ( ) ; } finally { in . close ( ) ; } }
protected void begin Path ( ) { prep Drawing ( ) ; mPS Stream . println ( NEWPATH STR ) ; m Pen X = NUM ; m Pen Y = NUM ; }
private boolean in Same Package ( Class < ? > c1 , Class < ? > c2 ) { String name C 1 = c1 . get Name ( ) ; String name C 2 = c2 . get Name ( ) ; int index Dot C 1 = name C 1 . last Index Of ( STRING ) ; int index Dot C 2 = name C 2 . last Index Of ( STRING ) ; if ( index Dot C 1 != index Dot C 2 ) { return BOOL ; } if ( index Dot C 1 == - NUM ) { return BOOL ; } return name C 1 . region Matches ( NUM , name C 2 , NUM , index Dot C 1 ) ; }
private void send Tcp Request ( Socket socket , String request ) throws Api Exception { try { Log Utils . LOGD ( TAG , STRING + request ) ; Buffered Writer writer = new Buffered Writer ( new Output Stream Writer ( socket . get Output Stream ( ) ) ) ; writer . write ( request ) ; writer . flush ( ) ; } catch ( Exception e ) { Log Utils . LOGW ( TAG , STRING , e ) ; disconnect ( ) ; throw new Api Exception ( Api Exception . IO EXCEPTION WHILE SENDING REQUEST , e ) ; } }
public static String clean String ( String src ) { if ( src == null ) { return null ; } boolean found Bad = BOOL ; final Character Iterator it = new String Character Iterator ( src ) ; for ( char c = it . first ( ) ; c != Character Iterator . DONE ; c = it . next ( ) ) { if ( c < ASCII PRINTABLE LOW || c >= ASCII PRINTABLE HI ) { found Bad = BOOL ; break ; } } if ( ! found Bad ) { return src ; } final String Builder res = new String Builder ( ) ; for ( char c = it . first ( ) ; c != Character Iterator . DONE ; c = it . next ( ) ) { if ( c < ASCII PRINTABLE LOW || c >= ASCII PRINTABLE HI ) { res . append ( ASCII SPACE ) ; } else { res . append ( c ) ; } } return res . to String ( ) ; }
public static Manual Lag Graph serializable Instance ( ) { return new Manual Lag Graph ( Manual Lag Graph Params . serializable Instance ( ) ) ; }
public void update Actions ( ) { String text ; Action a = R Text Area . get Action ( R Text Area . UNDO ACTION ) ; if ( can Undo ( ) ) { a . set Enabled ( BOOL ) ; text = get Undo Presentation Name ( ) ; a . put Value ( Action . NAME , text ) ; a . put Value ( Action . SHORT DESCRIPTION , text ) ; } else { if ( a . is Enabled ( ) ) { a . set Enabled ( BOOL ) ; text = cant Undo Text ; a . put Value ( Action . NAME , text ) ; a . put Value ( Action . SHORT DESCRIPTION , text ) ; } } a = R Text Area . get Action ( R Text Area . REDO ACTION ) ; if ( can Redo ( ) ) { a . set Enabled ( BOOL ) ; text = get Redo Presentation Name ( ) ; a . put Value ( Action . NAME , text ) ; a . put Value ( Action . SHORT DESCRIPTION , text ) ; } else { if ( a . is Enabled ( ) ) { a . set Enabled ( BOOL ) ; text = cant Redo Text ; a . put Value ( Action . NAME , text ) ; a . put Value ( Action . SHORT DESCRIPTION , text ) ; } } }
public void element Type ( String name , int model , int member Of , int flags ) { Element Type e = new Element Type ( name , model , member Of , flags , this ) ; the Element Types . put ( name . to Lower Case ( ) , e ) ; if ( member Of == M ROOT ) the Root = e ; }
private static List < Size Pair > generate Valid Preview Size List ( Camera camera ) { Camera . Parameters parameters = camera . get Parameters ( ) ; List < android . hardware . Camera . Size > supported Preview Sizes = parameters . get Supported Preview Sizes ( ) ; List < android . hardware . Camera . Size > supported Picture Sizes = parameters . get Supported Picture Sizes ( ) ; List < Size Pair > valid Preview Sizes = new Array List < > ( ) ; for ( android . hardware . Camera . Size preview Size : supported Preview Sizes ) { float preview Aspect Ratio = ( float ) preview Size . width / ( float ) preview Size . height ; for ( android . hardware . Camera . Size picture Size : supported Picture Sizes ) { float picture Aspect Ratio = ( float ) picture Size . width / ( float ) picture Size . height ; if ( Math . abs ( preview Aspect Ratio - picture Aspect Ratio ) < ASPECT RATIO TOLERANCE ) { valid Preview Sizes . add ( new Size Pair ( preview Size , picture Size ) ) ; break ; } } } if ( valid Preview Sizes . size ( ) == NUM ) { Log . w ( TAG , STRING ) ; for ( android . hardware . Camera . Size preview Size : supported Preview Sizes ) { valid Preview Sizes . add ( new Size Pair ( preview Size , null ) ) ; } } return valid Preview Sizes ; }
public void add Scrolling Listener ( On Wheel Scroll Listener listener ) { scrolling Listeners . add ( listener ) ; }
public static boolean has Dependency ( Maven Project project , String group Id ) { Set < Artifact > artifacts = project . get Artifacts ( ) ; if ( artifacts != null ) { for ( Artifact artifact : artifacts ) { String scope = artifact . get Scope ( ) ; if ( Objects . equal ( STRING , scope ) ) { continue ; } if ( Objects . equal ( group Id , artifact . get Group Id ( ) ) ) { return BOOL ; } } } return BOOL ; }
public Contour Generator ( URL url , float model Mean , float model Stddev ) throws IO Exception { this . model Mean = model Mean ; this . model Stddev = model Stddev ; List terms List = new Array List ( ) ; String line ; Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( url . open Stream ( ) ) ) ; line = reader . read Line ( ) ; while ( line != null ) { if ( ! line . starts With ( STRING ) ) { parse And Add ( terms List , line ) ; } line = reader . read Line ( ) ; } terms = ( F0 Model Term [ ] ) terms List . to Array ( terms ) ; reader . close ( ) ; }
public void add Comment ( String comment ) { if ( frame != null ) { chat Tab . add Comment ( comment ) ; } if ( tabbed Pane . get Selected Index ( ) == NUM ) { editor Tab . display Comment ( comment ) ; } }
public static byte [ ] hex String To Bytes ( String hex String ) { if ( hex String == null || hex String . equals ( STRING ) ) { return null ; } hex String = hex String . to Upper Case ( ) ; int length = hex String . length ( ) / NUM ; char [ ] hex Chars = hex String . to Char Array ( ) ; byte [ ] d = new byte [ length ] ; for ( int i = NUM ; i < length ; i ++ ) { int pos = i * NUM ; d [ i ] = ( byte ) ( char To Byte ( hex Chars [ pos ] ) << NUM | char To Byte ( hex Chars [ pos + NUM ] ) ) ; } return d ; }
private void decompose ( List < Object > element Pairs , List < Object > printer List , List < Object > parser List ) { int size = element Pairs . size ( ) ; for ( int i = NUM ; i < size ; i += NUM ) { Object element = element Pairs . get ( i ) ; if ( element instanceof Date Time Printer ) { if ( element instanceof Composite ) { add Array To List ( printer List , ( ( Composite ) element ) . i Printers ) ; } else { printer List . add ( element ) ; } } element = element Pairs . get ( i + NUM ) ; if ( element instanceof Date Time Parser ) { if ( element instanceof Composite ) { add Array To List ( parser List , ( ( Composite ) element ) . i Parsers ) ; } else { parser List . add ( element ) ; } } } }
private String process Integer Token ( String token ) { String result = token . replace All ( STRING + group Separator , STRING ) ; boolean is Negative = BOOL ; int pre Len = negative Prefix . length ( ) ; if ( ( pre Len > NUM ) && result . starts With ( negative Prefix ) ) { is Negative = BOOL ; result = result . substring ( pre Len ) ; } int suf Len = negative Suffix . length ( ) ; if ( ( suf Len > NUM ) && result . ends With ( negative Suffix ) ) { is Negative = BOOL ; result = result . substring ( result . length ( ) - suf Len , result . length ( ) ) ; } if ( is Negative ) result = STRING + result ; return result ; }
public void write Graphics ( String graphics Save File ) throws IO Exception { File Output Stream ostream = new File Output Stream ( graphics Save File ) ; Object Output Stream objectstream = new Object Output Stream ( ostream ) ; write Graphics ( objectstream ) ; objectstream . close ( ) ; }
@ Override public void add Input Node ( B Node input Node ) { super . add Input Node ( input Node ) ; }
public void remove Dependency ( Task Dependency dep ) { Node src Node = my Node Map . get ( dep . get Dependee ( ) ) ; Node dst Node = my Node Map . get ( dep . get Dependant ( ) ) ; if ( src Node == null && dst Node == null ) { return ; } assert ( src Node != null && dst Node != null ) : STRING + dep + STRING ; Dependency Edge died Edge = find Explicit Dependency ( dep , src Node , dst Node ) ; if ( died Edge == null ) { return ; } remove Edge ( died Edge ) ; for ( Dependency Edge edge : Lists . new Array List ( src Node . get Outgoing ( ) ) ) { if ( edge instanceof Implicit Inherited Dependency ) { if ( ( ( Implicit Inherited Dependency ) edge ) . my Explicit Dep == died Edge ) { remove Edge ( edge ) ; } } } fire Graph Changed ( ) ; }
public Criteria or ( ) { Criteria criteria = create Criteria Internal ( ) ; ored Criteria . add ( criteria ) ; return criteria ; }
public static boolean is Extension ( String filename , Collection < String > extensions ) { if ( filename == null ) { return BOOL ; } if ( extensions == null || extensions . is Empty ( ) ) { return index Of Extension ( filename ) == - NUM ; } String file Ext = get Extension ( filename ) ; for ( String extension : extensions ) { if ( file Ext . equals ( extension ) ) { return BOOL ; } } return BOOL ; }
public VN Xe Command Job modify Consistency Group Async ( String id , Lun Group Modify Param param ) { String Builder url Bld = new String Builder ( URL MODIFY 1 ) ; url Bld . append ( id ) ; url Bld . append ( URL MODIFY 2 ) ; url = url Bld . to String ( ) ; return post Request Async ( param ) ; }
public Object read Remote ( ) throws IO Exception { String type = read Type ( ) ; String url = read String ( ) ; return resolve Remote ( type , url ) ; }
private static J Free Chart create Chart ( ) { XY Series series 1 = new XY Series ( STRING ) ; series 1 . add ( NUM , NUM ) ; series 1 . add ( NUM , NUM ) ; series 1 . add ( NUM , NUM ) ; XY Dataset dataset = new XY Series Collection ( series 1 ) ; return Chart Factory . create Time Series Chart ( STRING , STRING , STRING , dataset , BOOL , BOOL , BOOL ) ; }
private void DT Dprolog ( ) throws SAX Exception , IO Exception { final java . io . Writer writer = m writer ; if ( m need To Output Doc Type Decl ) { output Doc Type Decl ( m elem Context . m element Name , BOOL ) ; m need To Output Doc Type Decl = BOOL ; } if ( m in Doctype ) { writer . write ( STRING ) ; writer . write ( m line Sep , NUM , m line Sep Len ) ; m in Doctype = BOOL ; } }
public Cache Set query Sequential ( Predicate ... selectors ) { check Not Null ( selectors ) ; Collection < Object > result Collection = new Array List < > ( items ) ; Collection < Object > filter Collection = new Linked List < > ( ) ; Collection < Object > temp Collection ; int i = NUM ; while ( ( i < selectors . length ) && ( result Collection . size ( ) > NUM ) ) { Collection Utils . select ( result Collection , selectors [ i ] , filter Collection ) ; temp Collection = result Collection ; result Collection = filter Collection ; filter Collection = temp Collection ; filter Collection . clear ( ) ; i ++ ; } return new Cache Set ( result Collection ) ; }
@ Override public boolean is Error Enabled ( ) { return logger . is Loggable ( Level . SEVERE ) ; }
public static < A > Set T Value < A > from Stream ( final Any M Value < Stream < A > > monads ) { return of ( monads . map ( null ) ) ; }
public static CC Bitmap Font Configuration FNT Config Load File ( String fnt File ) { CC Bitmap Font Configuration ret = null ; if ( configurations == null ) configurations = new Hash Map < String , CC Bitmap Font Configuration > ( ) ; ret = configurations . get ( fnt File ) ; if ( ret == null ) { ret = CC Bitmap Font Configuration . configuration ( fnt File ) ; configurations . put ( fnt File , ret ) ; } return ret ; }
public void add Criteria ( Criteria other Criteria ) { if ( other Criteria instanceof Advanced Criteria || other Criteria instanceof Criterion ) { throw new Illegal Argument Exception ( STRING + STRING ) ; } Map other Map = other Criteria . get Values ( ) ; Set other Keys = other Map . key Set ( ) ; for ( Iterator i = other Keys . iterator ( ) ; i . has Next ( ) ; ) { String field = ( String ) i . next ( ) ; Object value = other Map . get ( field ) ; JSO Helper . set Attribute ( js Obj , field , value ) ; } }
public D Netscape Ssl Server Name ( J Dialog parent , byte [ ] value ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public static Event Bean [ ] resize Array ( Event Bean [ ] old Array , int new Size ) { if ( old Array == null ) { return null ; } if ( old Array . length == new Size ) { return old Array ; } Event Bean [ ] new Array = new Event Bean [ new Size ] ; int preserve Length = Math . min ( old Array . length , new Size ) ; if ( preserve Length > NUM ) { System . arraycopy ( old Array , NUM , new Array , NUM , preserve Length ) ; } return new Array ; }
public static Spannable String span Text ( Char Sequence text , Object ... spans ) { Spannable String spannable String = new Spannable String ( text ) ; for ( Object span : spans ) { spannable String . set Span ( span , NUM , text . length ( ) , Spanned . SPAN EXCLUSIVE EXCLUSIVE ) ; } return spannable String ; }
@ Suppress Warnings ( STRING ) protected < T > List < T > query ( Class < T > model Class , String [ ] columns , String selection , String [ ] selection Args , String group By , String having , String order By , String limit , List < Associations Info > foreign Key Associations ) { List < T > data List = new Array List < T > ( ) ; Cursor cursor = null ; try { List < Field > supported Fields = get Supported Fields ( model Class . get Name ( ) ) ; String table Name = get Table Name ( model Class ) ; String [ ] customized Columns = get Customized Columns ( columns , foreign Key Associations ) ; cursor = m Database . query ( table Name , customized Columns , selection , selection Args , group By , having , order By , limit ) ; if ( cursor . move To First ( ) ) { Sparse Array < Query Info Cache > query Info Cache Sparse Array = new Sparse Array < Query Info Cache > ( ) ; do { T model Instance = ( T ) create Instance From Class ( model Class ) ; give Base Obj Id Value ( ( Data Support ) model Instance , cursor . get Long ( cursor . get Column Index Or Throw ( STRING ) ) ) ; set Value To Model ( model Instance , supported Fields , foreign Key Associations , cursor , query Info Cache Sparse Array ) ; if ( foreign Key Associations != null ) { set Associated Model ( ( Data Support ) model Instance ) ; } data List . add ( model Instance ) ; } while ( cursor . move To Next ( ) ) ; query Info Cache Sparse Array . clear ( ) ; } return data List ; } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new Data Support Exception ( e . get Message ( ) ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } }
private MLT Result build Query For Field ( String field Name , Priority Queue < MLT Term > q , Boolean Query query , boolean content Stream Query ) { List < MLT Term > interesting Terms = new Array List < MLT Term > ( ) ; int qterms = NUM ; int max Terms = max Query Terms Per Field ; if ( max Terms <= NUM ) { max Terms = Integer . MAX VALUE ; } Boolean Query tmp Query = new Boolean Query ( ) ; double sum Quared Boost = NUM ; MLT Term cur ; while ( ( cur = q . pop ( ) ) != null ) { Query tq = null ; final Term term = new Term ( cur . get Field Name ( ) , cur . get Word ( ) ) ; if ( is Payload Field ( cur . get Field Name ( ) ) ) { tq = new Payload Term Query ( term , new Average Payload Function ( ) , BOOL ) ; } else { tq = new Term Query ( term ) ; } if ( boost ) { float boost = cur . get Score ( ) ; tq . set Boost ( boost ) ; sum Quared Boost += boost * boost ; } else { sum Quared Boost += NUM ; } try { tmp Query . add ( tq , Boolean Clause . Occur . SHOULD ) ; interesting Terms . add ( cur ) ; qterms ++ ; } catch ( Boolean Query . Too Many Clauses ignore ) { break ; } if ( qterms >= max Terms ) { break ; } } double vector Length = Math . sqrt ( sum Quared Boost ) ; if ( vector Length <= NUM ) { return new MLT Result ( interesting Terms , query ) ; } build Boosted Normalized Query ( field Name , tmp Query , query , vector Length , content Stream Query ) ; return new MLT Result ( interesting Terms , query ) ; }
@ Suppress Warnings ( STRING ) protected void sequentially ( Consumer < Marker > ... functions ) { if ( functions == null || functions . length == NUM ) return ; Collection < Parsing Exception > errors = new Array List < > ( ) ; Marker marker = tokens . mark ( ) ; for ( Consumer < Marker > function : functions ) { try { function . accept ( marker ) ; return ; } catch ( Parsing Exception e ) { errors . add ( e ) ; tokens . rewind ( marker ) ; } } parsing Failed ( marker . position ( ) , errors , STRING ) ; }
public Pid File ( final File file ) throws File Not Found Exception { if ( ! file . exists ( ) || ! file . is File ( ) ) { throw new File Not Found Exception ( STRING + file + STRING ) ; } this . pid File = file ; }
public void add Child Node ( Exec Node child Node ) { child Nodes . add ( child Node ) ; }
static private double quick Select ( I Double Vector x , int k , int start , int end ) { if ( k < start || k > end ) { throw new Ade Core Illegal Argument Exception ( STRING ) ; } final int pivot Index = ( ( int ) Math . random ( ) * ( end - start + NUM ) ) + start ; final int pivot Position = partition ( x , start , end , pivot Index ) ; if ( pivot Position == k ) { return x . get ( k ) ; } else if ( pivot Position < k ) { return quick Select ( x , k , pivot Position + NUM , end ) ; } else { return quick Select ( x , k , start , pivot Position - NUM ) ; } }
public Bayes Im Editor Obs ( Bayes Im Wrapper Obs bayes Im Wrapper Obs ) { this ( bayes Im Wrapper Obs , bayes Im Wrapper Obs . get Bayes Im ( ) ) ; }
private List < String > convert Byte Array List To String Value List ( List < byte [ ] > dictionary Byte Array List ) { List < String > value List = new Array List < > ( dictionary Byte Array List . size ( ) ) ; for ( byte [ ] value : dictionary Byte Array List ) { value List . add ( new String ( value , Charset . for Name ( Carbon Common Constants . DEFAULT CHARSET ) ) ) ; } return value List ; }
public File Tree Node ( File parent , String name ) throws Security Exception , File Not Found Exception { this ( parent . to Path ( ) , name ) ; }
private List < Node > possible Parents ( Node x , List < Node > adjx , I Knowledge knowledge ) { List < Node > possible Parents = new Linked List < > ( ) ; String x = x . get Name ( ) ; for ( Node z : adjx ) { String z = z . get Name ( ) ; if ( possible Parent Of ( z , x , knowledge ) ) { possible Parents . add ( z ) ; } } return possible Parents ; }
public synchronized void remove ( Abstract Option option ) { if ( options . contains ( option ) ) { int position = index Of ( option ) ; List < Abstract Option > old Options = new Array List < Abstract Option > ( options ) ; options . remove ( option ) ; List < Abstract Option > new Options = get Options ( ) ; option . set Collection ( null ) ; fire Indexed Property Change ( PROP OPTIONS , position , old Options , new Options ) ; } }
private float [ ] calculate Pointer Position ( float angle ) { float x = ( float ) ( m Color Wheel Radius * Math . cos ( angle ) ) ; float y = ( float ) ( m Color Wheel Radius * Math . sin ( angle ) ) ; return new float [ ] { x , y } ; }
public Resource Node locate ( String session ID , String path , Resource Node start Node ) throws Directory Not Found Exception { if ( path == null ) { return get Current Node ( session ID ) ; } else if ( path . starts With ( PROTOCOL ) ) { path = path . substring ( PROTOCOL . length ( ) ) ; } else if ( path . starts With ( ROOT ELEMENT ) && path . length ( ) > ROOT ELEMENT . length ( ) ) { start Node = get Root Node ( ) ; path = path . substring ( ROOT ELEMENT . length ( ) ) ; } if ( path . equals ( CURRENT ELEMENT ) ) return get Current Node ( session ID ) ; else if ( path . equals ( ROOT ELEMENT ) ) return get Root Node ( ) ; Resource Node found Node = null ; Resource Node node To Search = start Node ; String path Elements [ ] = path . split ( PATH SEPARATOR ) ; if ( path Elements . length == NUM ) { return get Root Node ( ) ; } for ( String element : path Elements ) { if ( element . length ( ) == NUM ) continue ; if ( element . equals ( PARENT ELEMENT ) ) { if ( ( found Node = node To Search . get Parent ( ) ) != null ) { node To Search = node To Search . get Parent ( ) ; } else { throw new Directory Not Found Exception ( String . format ( STRING , path ) ) ; } } else { Map < String , Resource Node > children = node To Search . get Children ( ) ; if ( element . equals ( ANY ELEMENT ) ) { if ( node To Search . get Type ( ) == Resource Type . CLUSTER ) { found Node = children . get ( member Name ) ; } else if ( children . size ( ) > NUM ) { found Node = get First ( children ) ; } else { throw new Directory Not Found Exception ( String . format ( STRING , element , path ) ) ; } } else { found Node = children . get ( element ) ; } if ( found Node == null ) { throw new Directory Not Found Exception ( String . format ( STRING , element , format Path ( get Absolute Path ( get Root Node ( ) , node To Search , BOOL ) , BOOL ) , path ) ) ; } node To Search = found Node ; } } return found Node ; }
private void handle Process Error ( Job Definition job , Process process ) throws IO Exception { String Buffer sb = new String Buffer ( ) ; Buffered Reader in = new Buffered Reader ( new Input Stream Reader ( process . get Input Stream ( ) ) ) ; int data = NUM ; while ( data != - NUM && ! is Interrupted ( ) ) { data = in . read ( ) ; if ( data != - NUM ) { sb . append ( ( char ) data ) ; } } logger . warn ( STRING + job . cut + STRING + sb . to String ( ) ) ; }
private void check Class And Sync ( Class < ? extends I Packet > clazz ) { if ( ! registered Classes . contains ( clazz ) ) { throw new Runtime Exception ( STRING + clazz + STRING ) ; } while ( is Currently Sending Semaphor ) { Thread . yield ( ) ; } is Currently Sending Semaphor = BOOL ; }
private void write Attribute ( java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( namespace . equals ( STRING ) ) { xml Writer . write Attribute ( att Name , att Value ) ; } else { register Prefix ( xml Writer , namespace ) ; xml Writer . write Attribute ( namespace , att Name , att Value ) ; } }
private static int calculate Displayed Width ( String string ) { final int tab Width = DEFAULT TAB WIDTH ; int column = NUM ; for ( int i = NUM ; i < string . length ( ) ; i ++ ) { if ( STRING == string . char At ( i ) ) { column += tab Width - ( column % tab Width ) ; } else { column ++ ; } } return column ; }
private static Generalized Time finish Decoding Fraction ( final String value , final int start Pos , final int year , final int month , final int day , final int hour , final int minute , final int second , final int multiplier ) { final int length = value . length ( ) ; final String Builder fraction Buffer = new String Builder ( ( NUM + length ) - start Pos ) ; fraction Buffer . append ( STRING ) ; Time Zone time Zone = null ; outer Loop : for ( int i = start Pos ; i < length ; i ++ ) { final char c = value . char At ( i ) ; switch ( c ) { case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : fraction Buffer . append ( c ) ; break ; case STRING : case STRING : if ( i != ( value . length ( ) - NUM ) ) { final Localizable Message message = WARN ATTR SYNTAX GENERALIZED TIME ILLEGAL FRACTION CHAR . get ( value , String . value Of ( c ) ) ; throw new Localized Illegal Argument Exception ( message ) ; } time Zone = TIME ZONE UTC OBJ ; break outer Loop ; case STRING : case STRING : time Zone = get Time Zone For Offset ( value , i ) ; break outer Loop ; default : final Localizable Message message = WARN ATTR SYNTAX GENERALIZED TIME ILLEGAL FRACTION CHAR . get ( value , String . value Of ( c ) ) ; throw new Localized Illegal Argument Exception ( message ) ; } } if ( fraction Buffer . length ( ) == NUM ) { final Localizable Message message = WARN ATTR SYNTAX GENERALIZED TIME EMPTY FRACTION . get ( value ) ; throw new Localized Illegal Argument Exception ( message ) ; } if ( time Zone == null ) { final Localizable Message message = WARN ATTR SYNTAX GENERALIZED TIME NO TIME ZONE INFO . get ( value ) ; throw new Localized Illegal Argument Exception ( message ) ; } final Double fraction Value = Double . parse Double ( fraction Buffer . to String ( ) ) ; final int additional Milliseconds = ( int ) Math . round ( fraction Value * multiplier ) ; try { final Gregorian Calendar calendar = new Gregorian Calendar ( ) ; calendar . set Lenient ( BOOL ) ; calendar . set Time Zone ( time Zone ) ; calendar . set ( year , month , day , hour , minute , second ) ; calendar . set ( Calendar . MILLISECOND , additional Milliseconds ) ; return new Generalized Time ( calendar , null , Long . MIN VALUE , value ) ; } catch ( final Exception e ) { final Localizable Message message = WARN ATTR SYNTAX GENERALIZED TIME ILLEGAL TIME . get ( value , String . value Of ( e ) ) ; throw new Localized Illegal Argument Exception ( message , e ) ; } }
@ Override public int read ( ) { if ( idx >= char Sequence . length ( ) ) { return - NUM ; } else { return char Sequence . char At ( idx ++ ) ; } }
public void test get Client Aliases ( ) { init ( CLIENT ) ; assert Null ( manager . get Client Aliases ( null , null ) ) ; assert Null ( manager . get Client Aliases ( STRING , null ) ) ; String [ ] res Array = manager . get Client Aliases ( TYPE RSA , null ) ; assert Not Null ( res Array ) ; assert Equals ( NUM , res Array . length ) ; assert Known Aliases ( res Array ) ; }
public void remove All Update Listeners ( ) { if ( m Update Listeners == null ) { return ; } m Update Listeners . clear ( ) ; m Update Listeners = null ; }
@ Suppress Warnings ( STRING ) E transfer ( E e , boolean timed , long nanos ) { Q Node s = null ; boolean is Data = ( e != null ) ; for ( ; ; ) { Q Node t = tail ; Q Node h = head ; if ( t == null || h == null ) continue ; if ( h == t || t . is Data == is Data ) { Q Node tn = t . next ; if ( t != tail ) continue ; if ( tn != null ) { advance Tail ( t , tn ) ; continue ; } if ( timed && nanos <= NUM ) return null ; if ( s == null ) s = new Q Node ( e , is Data ) ; if ( ! t . cas Next ( null , s ) ) continue ; advance Tail ( t , s ) ; Object x = await Fulfill ( s , e , timed , nanos ) ; if ( x == s ) { clean ( t , s ) ; return null ; } if ( ! s . is Off List ( ) ) { advance Head ( t , s ) ; if ( x != null ) s . item = s ; s . waiter = null ; } return ( x != null ) ? ( E ) x : e ; } else { Q Node m = h . next ; if ( t != tail || m == null || h != head ) continue ; Object x = m . item ; if ( is Data == ( x != null ) || x == m || ! m . cas Item ( x , e ) ) { advance Head ( h , m ) ; continue ; } advance Head ( h , m ) ; Lock Support . unpark ( m . waiter ) ; return ( x != null ) ? ( E ) x : e ; } } }
public static void println ( char x ) { out . println ( x ) ; }
private boolean should Position Avatar On Right ( ) { final boolean is Rtl = Build . VERSION . SDK INT >= Build . VERSION CODES . JELLY BEAN MR 1 ? get Layout Direction ( ) == LAYOUT DIRECTION RTL : BOOL ; final boolean assigned Position = m Avatar Position == AVATAR POSITION END ; return is Rtl ? ! assigned Position : assigned Position ; }
public static Charset to Charset ( Charset charset ) { return charset == null ? Charset . default Charset ( ) : charset ; }
public static void fail ( String message ) { throw new Illegal State Exception ( message == null ? STRING : message ) ; }
public void memset Buffer ( Byte Buffer buffer ) { memset Buffer ( buffer , buffer . limit ( ) ) ; }
static double fabs ( double a ) { return Math . abs ( a ) ; }
protected List < ITEM TYPE > select Fold Test Items ( List < ITEM TYPE > items , int n Folds , int fold ) { List < ITEM TYPE > test Items = new Array List < ITEM TYPE > ( ) ; for ( int i = NUM ; i < items . size ( ) ; ++ i ) { if ( i % n Folds == fold ) { test Items . add ( items . get ( i ) ) ; } } return test Items ; }
private void end Formals ( ) { if ( has Formals ) { has Formals = BOOL ; buf . append ( STRING ) ; } }
public final Char Sequence Translator with ( final Char Sequence Translator ... translators ) { final Char Sequence Translator [ ] new Array = new Char Sequence Translator [ translators . length + NUM ] ; new Array [ NUM ] = this ; System . arraycopy ( translators , NUM , new Array , NUM , translators . length ) ; return new Aggregate Translator ( new Array ) ; }
@ Override public boolean equals ( Object other ) { if ( ! ( other instanceof Sha 256 Hash ) ) return BOOL ; return Arrays . equals ( bytes , ( ( Sha 256 Hash ) other ) . bytes ) ; }
private void translate Matrix After Rotate ( int axis , float trans , float prev Image Size , float image Size , int prev View Size , int view Size , int drawable Size ) { if ( image Size < view Size ) { m [ axis ] = ( view Size - ( drawable Size * m [ Matrix . MSCALE X ] ) ) * NUM ; } else if ( trans > NUM ) { m [ axis ] = - ( ( image Size - view Size ) * NUM ) ; } else { float percentage = ( Math . abs ( trans ) + ( NUM * prev View Size ) ) / prev Image Size ; m [ axis ] = - ( ( percentage * image Size ) - ( view Size * NUM ) ) ; } }
public Config ( Solr Resource Loader loader , String name ) throws Parser Configuration Exception , IO Exception , SAX Exception { this ( loader , name , null , null ) ; }
private static Hash Map < String , Field > build Field Cache ( Class < ? > cls ) { final Hash Map < String , Field > cache = new Hash Map < > ( ) ; final List < Field > fields = get All Fields ( cls ) ; for ( Field fld : fields ) { String name = null ; final Reference ref Ann = fld . get Annotation ( Reference . class ) ; if ( ref Ann != null ) name = select Column Name ( ref Ann , fld ) ; if ( name == null ) { final Column col Ann = fld . get Annotation ( Column . class ) ; if ( col Ann != null ) name = select Column Name ( col Ann , fld ) ; } if ( name == null ) continue ; cache . put ( name , fld ) ; } return cache ; }
public static long convert Duration ( final String from Unit , final String to Unit , long value ) { Time Unit from Time Unit = to Time Unit ( from Unit ) ; Time Unit to Time Unit = to Time Unit ( to Unit ) ; if ( from Time Unit != null && to Time Unit != null ) { return to Time Unit . convert ( value , from Time Unit ) ; } else { throw new DSS Exception ( STRING + from Unit + STRING + to Unit + STRING + value + STRING ) ; } }
public static File search For Groovy Script File ( String input ) { String script File Name = input . trim ( ) ; File script File = new File ( script File Name ) ; String [ ] standard Extensions = { STRING , STRING , STRING , STRING } ; int i = NUM ; while ( i < standard Extensions . length && ! script File . exists ( ) ) { script File = new File ( script File Name + standard Extensions [ i ] ) ; i ++ ; } if ( ! script File . exists ( ) ) { script File = new File ( script File Name ) ; } return script File ; }
public X Object execute ( X Path Context xctxt ) throws javax . xml . transform . Transformer Exception { if ( xctxt . is Secure Processing ( ) ) throw new javax . xml . transform . Transformer Exception ( XPATH Messages . create XPATH Message ( XPATH Error Resources . ER EXTENSION FUNCTION CANNOT BE INVOKED , new Object [ ] { to String ( ) } ) ) ; X Object result ; Vector arg Vec = new Vector ( ) ; int n Args = m arg Vec . size ( ) ; for ( int i = NUM ; i < n Args ; i ++ ) { Expression arg = ( Expression ) m arg Vec . element At ( i ) ; X Object xobj = arg . execute ( xctxt ) ; xobj . allow Detach To Release ( BOOL ) ; arg Vec . add Element ( xobj ) ; } Extensions Provider ext Provider = ( Extensions Provider ) xctxt . get Owner Object ( ) ; Object val = ext Provider . ext Function ( this , arg Vec ) ; if ( null != val ) { result = X Object . create ( val , xctxt ) ; } else { result = new X Null ( ) ; } return result ; }
private Header create Security Header ( ) { return new Basic Header ( STRING , STRING + create Auth ( ) ) ; }
public Picture ( File file ) { try { image = Image IO . read ( file ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; throw new Runtime Exception ( STRING + file ) ; } if ( image == null ) { throw new Runtime Exception ( STRING + file ) ; } width = image . get Width ( null ) ; height = image . get Height ( null ) ; filename = file . get Name ( ) ; }
static Annotation Strategy strategy For ( Annotation annotation ) { check Not Null ( annotation , STRING ) ; Class < ? extends Annotation > annotation Type = annotation . annotation Type ( ) ; ensure Retained At Runtime ( annotation Type ) ; ensure Is Binding Annotation ( annotation Type ) ; if ( annotation Type . get Declared Methods ( ) . length == NUM ) { return new Annotation Type Strategy ( annotation Type , annotation ) ; } return new Annotation Instance Strategy ( annotation ) ; }
public static String encode ( byte [ ] input ) { if ( input . length == NUM ) { return STRING ; } int zeros = NUM ; while ( zeros < input . length && input [ zeros ] == NUM ) { ++ zeros ; } input = Arrays . copy Of ( input , input . length ) ; char [ ] encoded = new char [ input . length * NUM ] ; int output Start = encoded . length ; for ( int input Start = zeros ; input Start < input . length ; ) { encoded [ -- output Start ] = ALPHABET [ divmod ( input , input Start , NUM , NUM ) ] ; if ( input [ input Start ] == NUM ) { ++ input Start ; } } while ( output Start < encoded . length && encoded [ output Start ] == ENCODED ZERO ) { ++ output Start ; } while ( -- zeros >= NUM ) { encoded [ -- output Start ] = ENCODED ZERO ; } return new String ( encoded , output Start , encoded . length - output Start ) ; }
private void add Volume To Block Consistency Group ( URI cg Uri , Volume volume ) { volume . add Consistency Group ( cg Uri . to String ( ) ) ; db Client . persist Object ( volume ) ; }
public static boolean lazy Gaussian Elimination ( final int var 2 Eq [ ] [ ] , final long [ ] c , final int [ ] variable , final long [ ] solution ) { return lazy Gaussian Elimination ( null , var 2 Eq , c , variable , solution ) ; }
private static int analyze ( Compiler compiler , int step Op Code Pos , int step Index ) throws javax . xml . transform . Transformer Exception { int step Type ; int step Count = NUM ; int analysis Result = NUM ; while ( Op Codes . ENDOP != ( step Type = compiler . get Op ( step Op Code Pos ) ) ) { step Count ++ ; boolean pred Analysis = analyze Predicate ( compiler , step Op Code Pos , step Type ) ; if ( pred Analysis ) analysis Result |= BIT PREDICATE ; switch ( step Type ) { case Op Codes . OP VARIABLE : case Op Codes . OP EXTFUNCTION : case Op Codes . OP FUNCTION : case Op Codes . OP GROUP : analysis Result |= BIT FILTER ; break ; case Op Codes . FROM ROOT : analysis Result |= BIT ROOT ; break ; case Op Codes . FROM ANCESTORS : analysis Result |= BIT ANCESTOR ; break ; case Op Codes . FROM ANCESTORS OR SELF : analysis Result |= BIT ANCESTOR OR SELF ; break ; case Op Codes . FROM ATTRIBUTES : analysis Result |= BIT ATTRIBUTE ; break ; case Op Codes . FROM NAMESPACE : analysis Result |= BIT NAMESPACE ; break ; case Op Codes . FROM CHILDREN : analysis Result |= BIT CHILD ; break ; case Op Codes . FROM DESCENDANTS : analysis Result |= BIT DESCENDANT ; break ; case Op Codes . FROM DESCENDANTS OR SELF : if ( NUM == step Count && BIT ROOT == analysis Result ) { analysis Result |= BIT ANY DESCENDANT FROM ROOT ; } analysis Result |= BIT DESCENDANT OR SELF ; break ; case Op Codes . FROM FOLLOWING : analysis Result |= BIT FOLLOWING ; break ; case Op Codes . FROM FOLLOWING SIBLINGS : analysis Result |= BIT FOLLOWING SIBLING ; break ; case Op Codes . FROM PRECEDING : analysis Result |= BIT PRECEDING ; break ; case Op Codes . FROM PRECEDING SIBLINGS : analysis Result |= BIT PRECEDING SIBLING ; break ; case Op Codes . FROM PARENT : analysis Result |= BIT PARENT ; break ; case Op Codes . FROM SELF : analysis Result |= BIT SELF ; break ; case Op Codes . MATCH ATTRIBUTE : analysis Result |= ( BIT MATCH PATTERN | BIT ATTRIBUTE ) ; break ; case Op Codes . MATCH ANY ANCESTOR : analysis Result |= ( BIT MATCH PATTERN | BIT ANCESTOR ) ; break ; case Op Codes . MATCH IMMEDIATE ANCESTOR : analysis Result |= ( BIT MATCH PATTERN | BIT PARENT ) ; break ; default : throw new Runtime Exception ( XSL Messages . create XPATH Message ( XPATH Error Resources . ER NULL ERROR HANDLER , new Object [ ] { Integer . to String ( step Type ) } ) ) ; } if ( Op Codes . NODETYPE NODE == compiler . get Op ( step Op Code Pos + NUM ) ) { analysis Result |= BIT NODETEST ANY ; } step Op Code Pos = compiler . get Next Step Pos ( step Op Code Pos ) ; if ( step Op Code Pos < NUM ) break ; } analysis Result |= ( step Count & BITS COUNT ) ; return analysis Result ; }
public void compress My Own Way ( int [ ] indexes ) { List < Integer > list = new Array List < Integer > ( Carbon Common Constants . CONSTANT SIZE TEN ) ; List < Integer > map = new Array List < Integer > ( Carbon Common Constants . CONSTANT SIZE TEN ) ; int k = NUM ; int i = NUM ; for ( ; i < indexes . length ; i ++ ) { if ( indexes [ i ] - indexes [ i - NUM ] == NUM ) { k ++ ; } else { if ( k > NUM ) { map . add ( ( list . size ( ) ) ) ; list . add ( indexes [ i - k - NUM ] ) ; list . add ( indexes [ i - NUM ] ) ; } else { list . add ( indexes [ i - NUM ] ) ; } k = NUM ; } } if ( k > NUM ) { map . add ( ( list . size ( ) ) ) ; list . add ( indexes [ i - k - NUM ] ) ; list . add ( indexes [ i - NUM ] ) ; } else { list . add ( indexes [ i - NUM ] ) ; } data After Comp = convert To Array ( list ) ; if ( indexes . length == data After Comp . length ) { index Map = new int [ NUM ] ; } else { index Map = convert To Array ( map ) ; } if ( data After Comp . length == NUM && index Map . length == NUM ) { already Sorted = BOOL ; } }
private void prepend Decrement ( Basic Block bb , IR ir ) { if ( DEBUG ) VM . sys Write ( STRING + bb + STRING ) ; Register Operand use = cbs Reg . copy RO ( ) ; Register Operand def = use . copy U 2 D ( ) ; Instruction inc = Binary . create ( INT ADD , def , use , IR Tools . IC ( - NUM ) ) ; bb . prepend Instruction ( inc ) ; }
public void add Listener ( Connectable Device Listener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }
private static final String to Hex String ( final byte [ ] bs ) { String hex = STRING ; String Builder res = new String Builder ( ) ; for ( byte b : bs ) { res . append ( hex . char At ( ( ( b > > > NUM ) & NUM ) ) ) ; res . append ( hex . char At ( ( b & NUM ) ) ) ; } return res . to String ( ) ; }
public synchronized void flush ( ) throws IO Exception { check Not Closed ( ) ; trim To Size ( ) ; journal Writer . flush ( ) ; }
public double distance to the left ( Pla Line Int p line ) { double result = Integer . MAX VALUE ; for ( int index = NUM ; index < border line count ( ) ; ++ index ) { Pla Point Float curr corner = corner approx ( index ) ; Pla Side line side = p line . side of ( curr corner , NUM ) ; if ( line side == Pla Side . COLLINEAR ) { line side = p line . side of ( corner ( index ) ) ; } if ( line side == Pla Side . ON THE RIGHT ) return - NUM ; result = Math . min ( result , p line . distance signed ( curr corner ) ) ; } return result ; }
private static byte [ ] read Class ( final Input Stream is , boolean close ) throws IO Exception { if ( is == null ) { throw new IO Exception ( STRING ) ; } try { byte [ ] b = new byte [ is . available ( ) ] ; int len = NUM ; while ( BOOL ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - NUM ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; System . arraycopy ( b , NUM , c , NUM , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < NUM ) { return b ; } byte [ ] c = new byte [ b . length + NUM ] ; System . arraycopy ( b , NUM , c , NUM , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } } finally { if ( close ) { is . close ( ) ; } } }
public boolean display Topic From Names ( String [ ] names ) { if ( names . length == NUM ) return display Topic ( DEFAULT ) ; else { String Buffer help Name = new String Buffer ( ) ; for ( String name : names ) { if ( help Name . length ( ) > NUM ) help Name . append ( STRING ) ; help Name . append ( name ) ; } return display Topic ( help Name . to String ( ) ) ; } }
public boolean accept Identical ( String file Path , String file Name ) { if ( file Name Glob == null ) return BOOL ; if ( file Name != null && file Name . equals Ignore Case ( file Name Glob ) ) return BOOL ; if ( file Path != null ) { int last Unix Pos = file Path . last Index Of ( STRING ) ; int last Windows Pos = file Path . last Index Of ( STRING ) ; int index = Math . max ( last Unix Pos , last Windows Pos ) ; String filename = file Path . substring ( index + NUM ) ; return filename != null && filename . equals Ignore Case ( file Name Glob ) ; } return BOOL ; }
private void validate Num Cores Block Sort ( ) { String num Cores Str = carbon Properties . get Property ( Carbon Common Constants . NUM CORES BLOCK SORT , Carbon Common Constants . NUM CORES BLOCK SORT DEFAULT VAL ) ; try { int num Cores = Integer . parse Int ( num Cores Str ) ; if ( num Cores < Carbon Common Constants . NUM CORES BLOCK SORT MIN VAL || num Cores > Carbon Common Constants . NUM CORES BLOCK SORT MAX VAL ) { LOGGER . info ( STRING + num Cores Str + STRING + Carbon Common Constants . NUM CORES BLOCK SORT DEFAULT VAL ) ; carbon Properties . set Property ( Carbon Common Constants . NUM CORES BLOCK SORT , Carbon Common Constants . NUM CORES BLOCK SORT DEFAULT VAL ) ; } } catch ( Number Format Exception e ) { LOGGER . info ( STRING + num Cores Str + STRING + Carbon Common Constants . NUM CORES BLOCK SORT DEFAULT VAL ) ; carbon Properties . set Property ( Carbon Common Constants . NUM CORES BLOCK SORT , Carbon Common Constants . NUM CORES BLOCK SORT DEFAULT VAL ) ; } }
public static Memory Match Fragment new Instance ( ) { return new Memory Match Fragment ( ) ; }
static void create File From Resource ( String resource , Resource file ) throws IO Exception { create File From Resource ( resource , file , null ) ; }
public int end Object ( ) { if ( vtable == null || ! nested ) throw new Assertion Error ( STRING ) ; add Int ( NUM ) ; int vtableloc = offset ( ) ; for ( int i = vtable in use - NUM ; i >= NUM ; i -- ) { short off = ( short ) ( vtable [ i ] != NUM ? vtableloc - vtable [ i ] : NUM ) ; add Short ( off ) ; } final int standard fields = NUM ; add Short ( ( short ) ( vtableloc - object start ) ) ; add Short ( ( short ) ( ( vtable in use + standard fields ) * SIZEOF SHORT ) ) ; int existing vtable = NUM ; outer loop : for ( int i = NUM ; i < num vtables ; i ++ ) { int vt 1 = bb . capacity ( ) - vtables [ i ] ; int vt 2 = space ; short len = bb . get Short ( vt 1 ) ; if ( len == bb . get Short ( vt 2 ) ) { for ( int j = SIZEOF SHORT ; j < len ; j += SIZEOF SHORT ) { if ( bb . get Short ( vt 1 + j ) != bb . get Short ( vt 2 + j ) ) { continue outer loop ; } } existing vtable = vtables [ i ] ; break outer loop ; } } if ( existing vtable != NUM ) { space = bb . capacity ( ) - vtableloc ; bb . put Int ( space , existing vtable - vtableloc ) ; } else { if ( num vtables == vtables . length ) vtables = Arrays . copy Of ( vtables , num vtables * NUM ) ; vtables [ num vtables ++ ] = offset ( ) ; bb . put Int ( bb . capacity ( ) - vtableloc , offset ( ) - vtableloc ) ; } nested = BOOL ; return vtableloc ; }
private void end List ( boolean ordered List ) { if ( ! m Paragraph Styles . is Empty ( ) ) { Accumulated Paragraph Style style = m Paragraph Styles . peek ( ) ; Paragraph Type type = style . get Type ( ) ; if ( ( ordered List && ( type . is Numbering ( ) || type == Paragraph Type . INDENTATION OL ) ) || ( ! ordered List && ( type . is Bullet ( ) || type == Paragraph Type . INDENTATION UL ) ) ) { int indent = style . get Relative Indent ( ) ; if ( indent > NUM ) { style . set Relative Indent ( indent - NUM ) ; style . set Absolute Indent ( style . get Absolute Indent ( ) - NUM ) ; } else { m Paragraph Styles . pop ( ) ; } } else { m Paragraph Styles . pop ( ) ; end List ( ordered List ) ; } } }
public static void perspective M ( double [ ] m , int offset , double fovy , double aspect , double z Near , double z Far ) { double f = NUM / Math . tan ( fovy * ( Math . PI / NUM ) ) ; double range Reciprocal = NUM / ( z Near - z Far ) ; m [ offset + NUM ] = f / aspect ; m [ offset + NUM ] = NUM ; m [ offset + NUM ] = NUM ; m [ offset + NUM ] = NUM ; m [ offset + NUM ] = NUM ; m [ offset + NUM ] = f ; m [ offset + NUM ] = NUM ; m [ offset + NUM ] = NUM ; m [ offset + NUM ] = NUM ; m [ offset + NUM ] = NUM ; m [ offset + NUM ] = ( z Far + z Near ) * range Reciprocal ; m [ offset + NUM ] = - NUM ; m [ offset + NUM ] = NUM ; m [ offset + NUM ] = NUM ; m [ offset + NUM ] = NUM * z Far * z Near * range Reciprocal ; m [ offset + NUM ] = NUM ; }
protected double compute ( String value ) { if ( value != null ) { try { return Double . parse Double ( value ) ; } catch ( Number Format Exception e ) { if ( POSITIVE INFINITY STRING . equals ( value ) ) { return Double . POSITIVE INFINITY ; } else if ( NEGATIVE INFINITY STRING . equals ( value ) ) { return Double . NEGATIVE INFINITY ; } return Double . Na N ; } } return Double . Na N ; }
protected int read Block ( ) { block Size = read ( ) ; int n = NUM ; if ( block Size > NUM ) { try { int count = NUM ; while ( n < block Size ) { count = in . read ( block , n , block Size - n ) ; if ( count == - NUM ) break ; n += count ; } } catch ( IO Exception e ) { } if ( n < block Size ) { status = STATUS FORMAT ERROR ; } } return n ; }
boolean is Duplicate Role Column ( int column ) { return duplicate Role Column . contains ( column ) ; }
public Timestamp Speechlet Request Verifier ( long tolerance , Time Unit unit ) { if ( tolerance < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } tolerance In Milliseconds = unit . to Millis ( tolerance ) ; }
private boolean is Outside Doc Elem ( ) { return ( null == m doc Frag ) && m elem Stack . size ( ) == NUM && ( null == m current Node || m current Node . get Node Type ( ) == Node . DOCUMENT NODE ) ; }
public void shutdown ( ) { Count Down Latch wait l ; synchronized ( this ) { wait l = wait Shutdown ; } Shutdown ind = BOOL ; try { if ( wait l != null ) { if ( wait l . await ( NUM , Time Unit . MILLISECONDS ) ) LOG . info ( STRING ) ; else LOG . warn ( STRING ) ; } else { LOG . info ( STRING ) ; } } catch ( Interrupted Exception int exc ) { LOG . warn ( STRING ) ; } }
void paint Strokes ( Rectangle r , Graphics g , int axis , int [ ] length Pattern , Color [ ] color Pattern ) { boolean x Axis = ( axis == View . X AXIS ) ; int start = NUM ; int end = ( x Axis ? r . width : r . height ) ; while ( start < end ) { for ( int i = NUM ; i < length Pattern . length ; i ++ ) { if ( start >= end ) { break ; } int length = length Pattern [ i ] ; Color c = color Pattern [ i ] ; if ( c != null ) { int x = r . x + ( x Axis ? start : NUM ) ; int y = r . y + ( x Axis ? NUM : start ) ; int width = x Axis ? length : r . width ; int height = x Axis ? r . height : length ; g . set Color ( c ) ; g . fill Rect ( x , y , width , height ) ; } start += length ; } } }
private void delete Children ( Element container ) { while ( container . has Child Nodes ( ) ) { container . remove Child ( container . get Last Child ( ) ) ; } }
public String fill Param With Event Attrib ( String param Data , Event event ) { if ( ! database . is Open ( ) ) { throw new Illegal State Exception ( TAG + STRING ) ; } String Builder ret Val = new String Builder ( ) ; int cursor = NUM ; while ( cursor < param Data . length ( ) ) { int open Bracket Idx = param Data . index Of ( STRING , cursor ) ; int close Bracket Idx = param Data . index Of ( STRING , cursor ) ; if ( open Bracket Idx == - NUM || close Bracket Idx == - NUM || open Bracket Idx + NUM >= close Bracket Idx ) { ret Val . append ( param Data . substring ( cursor ) ) ; break ; } String attr = param Data . substring ( open Bracket Idx + NUM , close Bracket Idx ) ; String param = param Data . substring ( open Bracket Idx , close Bracket Idx + NUM ) ; String param Attr ; try { param Attr = event . get Attribute ( attr ) ; } catch ( Illegal Argument Exception e ) { param Attr = param ; } ret Val . append ( param Data . substring ( cursor , open Bracket Idx ) ) ; ret Val . append ( param Attr ) ; cursor = close Bracket Idx + NUM ; } Log . d ( STRING , param Data + STRING + ret Val . to String ( ) ) ; return ret Val . to String ( ) ; }
public static double two Pow ( int power ) { if ( power <= - MAX DOUBLE EXPONENT ) { if ( power >= MIN DOUBLE EXPONENT ) { return Double . long Bits To Double ( NUM > > ( - ( power + MAX DOUBLE EXPONENT ) ) ) ; } else { return NUM ; } } else if ( power > MAX DOUBLE EXPONENT ) { return Double . POSITIVE INFINITY ; } else { return Double . long Bits To Double ( ( ( long ) ( power + MAX DOUBLE EXPONENT ) ) << NUM ) ; } }
@ Suppress Warnings ( STRING ) public static Type resolve Type Variable ( Type Variable name , Class declaring Class , Class top Class ) { Type type = resolve Type Variable ( name , declaring Class , new Hash Map < > ( ) , top Class ) ; if ( type == null ) { type = Object . class ; } return type ; }
private Resource Impl aggregate ( Resource Impl resource A , Resource Impl resource B ) throws Not Found Exception { final String type Id = resource A . get Type ( ) ; final Resource Type resource Type = get Resource Type ( type Id ) ; return resource Type . aggregate ( resource A , resource B ) ; }
public static boolean rename File ( String file Path , String old Filename , String new Filename ) { if ( ( file Path == null ) || file Path . is Empty ( ) || ( old Filename == null ) || old Filename . is Empty ( ) || ( new Filename == null ) || new Filename . is Empty ( ) ) { return BOOL ; } File old File = new File ( file Path + File . separator + old Filename ) ; File new File = new File ( file Path + File . separator + new Filename ) ; boolean is Successful Rename ; try { is Successful Rename = old File . rename To ( new File ) ; } catch ( Exception e ) { logger . debug ( e . to String ( ) + System . line Separator ( ) + Stack Trace . get String From Stack Trace ( e ) ) ; is Successful Rename = BOOL ; } return is Successful Rename ; }
@ Rpc Method public void start Image Scan ( String data Store , Long scan Rate , Long timeout , Async Method Callback < Host . Async Client . start image scan call > handler ) throws Rpc Exception { ensure Client ( ) ; Start Image Scan Request request = new Start Image Scan Request ( data Store ) ; if ( null != scan Rate ) { request . set Scan rate ( scan Rate ) ; } if ( null != timeout ) { request . set Timeout ( timeout ) ; } try { logger . info ( STRING , get Host Ip ( ) , request ) ; client Proxy . set Timeout ( START IMAGE SCAN TIMEOUT MS ) ; client Proxy . start image scan ( request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
public static String format ( int n , String col ) { String res = padd + n ; return res . substring ( res . length ( ) - col . length ( ) ) ; }
public Git Conflict Exception ( String message ) { super ( message ) ; }
private void trace ( ) { gl Use Program ( photon Trace Program ) ; long this Time = System . nano Time ( ) ; float elapsed Seconds = ( this Time - first Time ) / NUM ; gl Uniform 1 f ( time Uniform , elapsed Seconds ) ; gl Bind Buffer Base ( GL SHADER STORAGE BUFFER , boxes Ssbo Binding , ssbo ) ; gl Bind Buffer Base ( GL UNIFORM BUFFER , images Ubo Binding , image Handles Ubo ) ; int invocations Per Dimension = photons Per Frame ; int worksize X = math Round Po T ( invocations Per Dimension ) ; int worksize Y = math Round Po T ( invocations Per Dimension ) ; if ( variable Group Size ) { ARB Compute Variable Group Size . gl Dispatch Compute Group Size ARB ( worksize X / work Group Size X , worksize Y / work Group Size Y , NUM , work Group Size X , work Group Size Y , NUM ) ; } else { gl Dispatch Compute ( worksize X / work Group Size X , worksize Y / work Group Size Y , NUM ) ; } gl Memory Barrier ( GL SHADER IMAGE ACCESS BARRIER BIT ) ; gl Bind Buffer Base ( GL SHADER STORAGE BUFFER , boxes Ssbo Binding , NUM ) ; gl Bind Buffer Base ( GL UNIFORM BUFFER , images Ubo Binding , NUM ) ; gl Use Program ( NUM ) ; }
public caption add Element ( String element ) { add Element To Registry ( Integer . to String ( element . hash Code ( ) ) , element ) ; return ( this ) ; }
protected void do Reset Current Position ( ) { this . current Position = this . position ; }
public Float Buffer put ( float [ ] src , int src Offset , int float Count ) { J Transc Arrays . check Offset And Count ( src . length , src Offset , float Count ) ; if ( float Count > remaining ( ) ) { throw new Buffer Overflow Exception ( ) ; } for ( int i = src Offset ; i < src Offset + float Count ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public String read Line ( ) { String line ; try { line = scanner . next Line ( ) ; } catch ( No Such Element Exception e ) { line = null ; } return line ; }
private boolean message Changed ( String old Message , String new Message ) { return ( ( new Message == null ) && ( old Message != null ) ) || ( ( new Message != null ) && ! new Message . equals ( old Message ) ) ; }
public static int copy ( Input Stream in , Output Stream out ) throws IO Exception { Assert . not Null ( in , STRING ) ; Assert . not Null ( out , STRING ) ; try { return Stream Utils . copy ( in , out ) ; } finally { try { in . close ( ) ; } catch ( IO Exception ex ) { } try { out . close ( ) ; } catch ( IO Exception ex ) { } } }
private Multi Line String read Multi Line ( Ora Geom ora Geom ) { int n Elem = ora Geom . num Elements ( ) ; List geoms = new Array List ( ) ; for ( int i = NUM ; i < n Elem ; i ++ ) { int etype = ora Geom . e Type ( i ) ; if ( etype != Ora Geom . ETYPE . LINE ) break ; geoms . add ( read Line ( ora Geom , i ) ) ; } Multi Line String lines = geometry Factory . create Multi Line String ( Geometry Factory . to Line String Array ( geoms ) ) ; return lines ; }
public boolean is Called Method ( String class Name , String method Name ) { if ( to Test Methods . is Empty ( ) ) compute Interesting Classes ( graph ) ; if ( to Test Methods . contains ( class Name + method Name ) ) { return BOOL ; } return BOOL ; }
public Explanation idf Explain ( Collection Statistics collection Stats , Term Statistics term Stats [ ] ) { final long doc Count = collection Stats . doc Count ( ) == - NUM ? collection Stats . max Doc ( ) : collection Stats . doc Count ( ) ; float idf = NUM ; List < Explanation > details = new Array List < > ( ) ; for ( final Term Statistics stat : term Stats ) { final long df = stat . doc Freq ( ) ; final float term Idf = idf ( df , doc Count ) ; details . add ( Explanation . match ( term Idf , STRING + df + STRING + doc Count + STRING ) ) ; idf += term Idf ; } return Explanation . match ( idf , STRING , details ) ; }
public void remove Area ( final Section AREA ) { if ( null == AREA ) return ; areas . remove ( AREA ) ; Collections . sort ( areas , new Section Comparator ( ) ) ; fire Update Event ( SECTION EVENT ) ; }
public void test Empty Run Index ( ) { String rs = STRING ; Settings s = new Settings ( STRING ) ; s . set Secondary Namespace ( STRING ) ; assert Equals ( s . get Int ( rs ) , NUM ) ; Settings . set Run Index ( NUM ) ; assert Equals ( s . get Int ( rs ) , NUM ) ; Settings . set Run Index ( NUM ) ; assert Equals ( s . get Int ( rs ) , NUM ) ; Settings . set Run Index ( NUM ) ; assert Equals ( s . get Int ( rs ) , NUM ) ; }
public void clear ( ) { synchronized ( m Lock ) { m Graphics . clear ( ) ; } post Invalidate ( ) ; }
@ Suppress Warnings ( STRING ) public void connect ( final Bluetooth Device device , final I Log Session session ) { if ( m Managed Devices . contains ( device ) ) return ; m Managed Devices . add ( device ) ; Ble Manager < Ble Manager Callbacks > manager = m Ble Managers . get ( device ) ; if ( manager != null ) { if ( session != null ) manager . set Logger ( session ) ; manager . connect ( device ) ; } else { m Ble Managers . put ( device , manager = initialize Manager ( ) ) ; manager . set Gatt Callbacks ( Ble Multiconnect Profile Service . this ) ; manager . set Logger ( session ) ; manager . connect ( device ) ; } }
public void test Case 19 ( ) { byte a Bytes [ ] = { - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , - NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , - NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { NUM , - NUM , NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . remainder ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public Scanner Exception ( Error Messages message ) { this ( null , Error Messages . get ( message ) , message , - NUM , - NUM ) ; }
public boolean is Navigation At Bottom ( ) { return ( m Smallest Width Dp >= NUM || m In Portrait ) ; }
private int clamp Mag ( int value , int abs Min , int abs Max ) { final int abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }
private static void format Time Zone ( Calendar cal , String Builder buf ) { Time Zone tz = cal . get Time Zone ( ) ; if ( tz == null ) return ; int offset ; if ( tz . in Daylight Time ( cal . get Time ( ) ) ) { offset = tz . get Raw Offset ( ) + ( tz . use Daylight Time ( ) ? NUM : NUM ) ; } else { offset = tz . get Raw Offset ( ) ; } if ( offset == NUM ) { buf . append ( STRING ) ; return ; } if ( offset >= NUM ) buf . append ( STRING ) ; else { buf . append ( STRING ) ; offset *= - NUM ; } offset /= NUM * NUM ; format Two Digits ( offset / NUM , buf ) ; buf . append ( STRING ) ; format Two Digits ( offset % NUM , buf ) ; }
private E unlink Last ( ) { Node < E > l = last ; if ( l == null ) return null ; Node < E > p = l . prev ; E item = l . item ; l . item = null ; l . prev = l ; last = p ; if ( p == null ) first = null ; else p . next = null ; -- count ; not Full . signal ( ) ; return item ; }
public Mutable String ( final Mutable String s ) { make Compact Mutable String ( s . length ( ) ) ; System . arraycopy ( s . array , NUM , array , NUM , array . length ) ; }
private void request ( ) { if ( is Visible ( ) && stream != null && ! stream . is Empty ( ) ) { loading = BOOL ; if ( type == Type . FOLLOWERS ) { api . get Followers ( stream ) ; } else if ( type == Type . SUBSCRIBERS ) { api . get Subscribers ( stream ) ; } } }
public List < Statement > munged Style ( ) { List < Statement > st = built ( ) ; if ( include Basic Entity For Subject ) { st . remove ( entity Data About Decl ) ; st . remove ( entity Data Version Decl ) ; st . remove ( entity Data Date Modified Decl ) ; statement ( st , uris . entity ( ) + entity , Schema Dot Org . VERSION , version ) ; statement ( st , uris . entity ( ) + entity , Schema Dot Org . DATE MODIFIED , date Modified ) ; } st . remove ( statement Type Decl ) ; for ( Extra Info e : extra Info ) { e . munge ( st ) ; } return st ; }
private void write Request ( final Next Filter next Filter , final Socks Proxy Request request , int step ) { try { Io Buffer buf = null ; if ( step == Socks Proxy Constants . SOCKS 5 GREETING STEP ) { buf = encode Initial Greeting Packet ( request ) ; } else if ( step == Socks Proxy Constants . SOCKS 5 AUTH STEP ) { buf = encode Authentication Packet ( request ) ; if ( buf == null ) { step = Socks Proxy Constants . SOCKS 5 REQUEST STEP ; } } if ( step == Socks Proxy Constants . SOCKS 5 REQUEST STEP ) { buf = encode Proxy Request Packet ( request ) ; } buf . flip ( ) ; write Data ( next Filter , buf ) ; } catch ( Exception ex ) { close Session ( STRING , ex ) ; } }
public synchronized void put As Int ( Object key , int value ) { put ( key , new Integer ( value ) ) ; }
public void close ( ) throws IO Exception { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = BOOL ; } }
private Cert Path build Cert Path ( X509 Certificate end Cert ) throws Certificate Path Building Exception { Cert Path Builder cpb = null ; try { cpb = Cert Path Builder . get Instance ( STRING ) ; } catch ( No Such Algorithm Exception e ) { throw new Certificate Path Building Exception ( STRING + e . get Message ( ) , e ) ; } PKIX Builder Parameters params = Create PKIX Builder Parameters ( end Cert ) ; Cert Path Builder Result cpb Result ; try { cpb Result = cpb . build ( params ) ; } catch ( Cert Path Builder Exception e ) { throw new Certificate Path Building Exception ( e . get Message ( ) , e . get Cause ( ) ) ; } catch ( Invalid Algorithm Parameter Exception e ) { throw new Certificate Path Building Exception ( e . get Message ( ) , e ) ; } Cert Path cp = cpb Result . get Cert Path ( ) ; return cp ; }
public void add Configuration ( Input Stream in ) throws SMS Exception , SSO Exception { Service Manager sm = new Service Manager ( token ) ; Document doc = SMS Schema . get XML Document ( in ) ; Node List nodes = doc . get Elements By Tag Name ( SMS Utils . SERVICE ) ; for ( int i = NUM ; ( nodes != null ) && ( i < nodes . get Length ( ) ) ; i ++ ) { Node service Node = nodes . item ( i ) ; String s Name = XML Utils . get Node Attribute Value ( service Node , SMS Utils . NAME ) ; String s Version = XML Utils . get Node Attribute Value ( service Node , SMS Utils . VERSION ) ; Node config Node ; if ( s Name . equals ( service Name ) && ( s Version . equals ( version ) ) && ( ( config Node = XML Utils . get Child Node ( service Node , SMS Utils . CONFIGURATION ) ) != null ) ) { Create Service Config . create Service ( sm , s Name , s Version , config Node , null ) ; } } }
public static int string To Dict Id ( String str ) { try { byte [ ] bytes = str . get Bytes ( STRING ) ; return Bytes Util . read Unsigned ( bytes , NUM , bytes . length ) ; } catch ( Unsupported Encoding Exception e ) { return NUM ; } }
public void start ( ) throws IO Exception , Mqtt Exception { final String method Name = STRING ; try { log . fine ( CLASS NAME , method Name , STRING , new Object [ ] { host , new Integer ( port ) , new Long ( con Timeout * NUM ) } ) ; Socket Address sockaddr = new Inet Socket Address ( host , port ) ; socket = factory . create Socket ( ) ; socket . connect ( sockaddr , con Timeout * NUM ) ; } catch ( Connect Exception ex ) { log . fine ( CLASS NAME , method Name , STRING , null , ex ) ; throw new Mqtt Exception ( Mqtt Exception . REASON CODE SERVER CONNECT ERROR , ex ) ; } }
public void call Serially And Wait ( Runnable r ) { if ( is Edt ( ) ) { throw new Runtime Exception ( STRING ) ; } Runnable Wrapper c = new Runnable Wrapper ( r , NUM ) ; call Serially ( c ) ; flush Edt ( ) ; synchronized ( lock ) { while ( ! c . is Done ( ) ) { try { lock . wait ( NUM ) ; } catch ( Interrupted Exception err ) { } } } }
public List < Contact > find ( ) { List < Long > ids = new Array List < > ( ) ; if ( inner Queries != null ) { for ( Query query : inner Queries ) { ids . add All ( query . find Inner ( ) ) ; } } else { if ( mime Where . is Empty ( ) ) { return find ( null ) ; } for ( Map . Entry < String , Where > entry : mime Where . entry Set ( ) ) { ids = find Ids ( ids , entry . get Key ( ) , entry . get Value ( ) ) ; } } return find ( ids ) ; }
public void persist Bean Data ( Object bean , boolean print Only ) { persist Bean Try Catch ( bean ) ; call Persist Emitted Key Value ( print Only ) ; }
private void refill ( ) throws IO Exception { offset += usable Length ; int leftover = length - usable Length ; System . arraycopy ( buffer , usable Length , buffer , NUM , leftover ) ; int requested = buffer . length - leftover ; int returned = read ( input , buffer , leftover , requested ) ; length = returned < NUM ? leftover : returned + leftover ; if ( returned < requested ) usable Length = length ; else { usable Length = find Safe End ( ) ; if ( usable Length < NUM ) usable Length = length ; } wrapper . set Text ( buffer , NUM , Math . max ( NUM , usable Length ) ) ; iterator . set Text ( wrapper ) ; }
protected void fire Insert Update ( Document Event evt ) { if ( token Marker != null ) { Document Event . Element Change ch = evt . get Change ( get Default Root Element ( ) ) ; if ( ch != null ) { token Marker . insert Lines ( ch . get Index ( ) + NUM , ch . get Children Added ( ) . length - ch . get Children Removed ( ) . length ) ; } } super . fire Insert Update ( evt ) ; }
final void push ( final Object object ) { stack . add ( object ) ; }
int pending ( ) { return pending . get ( ) ; }
private boolean is Included ( final Http Servlet Request request ) { String uri = ( String ) request . get Attribute ( STRING ) ; boolean include Request = ! ( uri == null ) ; if ( include Request && log . is Debug Enabled ( ) ) { log . debug ( STRING + STRING , request . get Request URL ( ) ) ; } return include Request ; }
public void draw Domain Marker ( Graphics 2 D g2 , Contour Plot plot , Value Axis domain Axis , Marker marker , Rectangle 2 D data Area ) { if ( marker instanceof Value Marker ) { Value Marker vm = ( Value Marker ) marker ; double value = vm . get Value ( ) ; Range range = domain Axis . get Range ( ) ; if ( ! range . contains ( value ) ) { return ; } double x = domain Axis . value To Java 2 D ( value , data Area , Rectangle Edge . BOTTOM ) ; Line 2 D line = new Line 2 D . Double ( x , data Area . get Min Y ( ) , x , data Area . get Max Y ( ) ) ; Paint paint = marker . get Outline Paint ( ) ; Stroke stroke = marker . get Outline Stroke ( ) ; g2 . set Paint ( paint != null ? paint : Plot . DEFAULT OUTLINE PAINT ) ; g2 . set Stroke ( stroke != null ? stroke : Plot . DEFAULT OUTLINE STROKE ) ; g2 . draw ( line ) ; } }
private static int encode Text ( Char Sequence msg , int startpos , int count , String Builder sb , int initial Submode ) { String Builder tmp = new String Builder ( count ) ; int submode = initial Submode ; int idx = NUM ; while ( BOOL ) { char ch = msg . char At ( startpos + idx ) ; switch ( submode ) { case SUBMODE ALPHA : if ( is Alpha Upper ( ch ) ) { if ( ch == STRING ) { tmp . append ( ( char ) NUM ) ; } else { tmp . append ( ( char ) ( ch - NUM ) ) ; } } else { if ( is Alpha Lower ( ch ) ) { submode = SUBMODE LOWER ; tmp . append ( ( char ) NUM ) ; continue ; } else if ( is Mixed ( ch ) ) { submode = SUBMODE MIXED ; tmp . append ( ( char ) NUM ) ; continue ; } else { tmp . append ( ( char ) NUM ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; break ; } } break ; case SUBMODE LOWER : if ( is Alpha Lower ( ch ) ) { if ( ch == STRING ) { tmp . append ( ( char ) NUM ) ; } else { tmp . append ( ( char ) ( ch - NUM ) ) ; } } else { if ( is Alpha Upper ( ch ) ) { tmp . append ( ( char ) NUM ) ; tmp . append ( ( char ) ( ch - NUM ) ) ; break ; } else if ( is Mixed ( ch ) ) { submode = SUBMODE MIXED ; tmp . append ( ( char ) NUM ) ; continue ; } else { tmp . append ( ( char ) NUM ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; break ; } } break ; case SUBMODE MIXED : if ( is Mixed ( ch ) ) { tmp . append ( ( char ) MIXED [ ch ] ) ; } else { if ( is Alpha Upper ( ch ) ) { submode = SUBMODE ALPHA ; tmp . append ( ( char ) NUM ) ; continue ; } else if ( is Alpha Lower ( ch ) ) { submode = SUBMODE LOWER ; tmp . append ( ( char ) NUM ) ; continue ; } else { if ( startpos + idx + NUM < count ) { char next = msg . char At ( startpos + idx + NUM ) ; if ( is Punctuation ( next ) ) { submode = SUBMODE PUNCTUATION ; tmp . append ( ( char ) NUM ) ; continue ; } } tmp . append ( ( char ) NUM ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; } } break ; default : if ( is Punctuation ( ch ) ) { tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; } else { submode = SUBMODE ALPHA ; tmp . append ( ( char ) NUM ) ; continue ; } } idx ++ ; if ( idx >= count ) { break ; } } char h = NUM ; int len = tmp . length ( ) ; for ( int i = NUM ; i < len ; i ++ ) { boolean odd = ( i % NUM ) != NUM ; if ( odd ) { h = ( char ) ( ( h * NUM ) + tmp . char At ( i ) ) ; sb . append ( h ) ; } else { h = tmp . char At ( i ) ; } } if ( ( len % NUM ) != NUM ) { sb . append ( ( char ) ( ( h * NUM ) + NUM ) ) ; } return submode ; }
public void remove ( String attr Name , String del Value ) { int index = index Of ( attr Name ) ; if ( index != - NUM ) { Attr attr = ( Attr ) attrs . get ( index ) ; attr . remove Value ( del Value ) ; if ( attr . size ( ) == NUM ) { attrs . remove ( index ) ; } } }
private Applied Migration create Applied Schema Migration ( ) { return new Applied Migration ( NUM , NUM , Migration Version . from Version ( Integer . to String ( NUM ) ) , STRING , Migration Type . SCHEMA , STRING , null , new Date ( ) , STRING , NUM , BOOL ) ; }
public static String make Sig Alg ( String dig Alg , String enc Alg ) { dig Alg = dig Alg . replace ( STRING , STRING ) ; if ( enc Alg . equals Ignore Case ( STRING ) ) enc Alg = STRING ; return dig Alg + STRING + enc Alg ; }
public Table sample ( double proportion ) { int table Count = ( int ) Math . round ( row Count ( ) * proportion ) ; Selection table 1 Selection = new Bitmap Backed Selection ( ) ; int [ ] selected Records = generate Uniform Bitmap ( table Count , row Count ( ) ) ; for ( int selected Record : selected Records ) { table 1 Selection . add ( selected Record ) ; } return select Where ( table 1 Selection ) ; }
public static int index Of ( byte [ ] src , byte [ ] target , int from Idx ) { final int to = src . length - target . length + NUM ; for ( int i = from Idx ; i < to ; i ++ ) { if ( src [ i ] == target [ NUM ] ) { boolean equals = BOOL ; for ( int j = NUM , k = i + NUM ; j < target . length && equals ; j ++ , k ++ ) { if ( src [ k ] != target [ j ] ) { equals = BOOL ; } } if ( equals ) { return i ; } } } return - NUM ; }
@ Override public int read ( byte [ ] buf , int offset , int length ) throws IO Exception { try { if ( channel == null ) { return - NUM ; } int remaining = read Buffer . remaining ( ) ; if ( remaining > NUM ) { read Buffer . get ( buf , offset , remaining ) ; return remaining ; } read Buffer . clear ( ) ; int channel Read = channel . read ( read Buffer ) ; read Buffer . flip ( ) ; if ( channel Read < NUM ) return - NUM ; read Buffer . get ( buf , offset , channel Read ) ; return channel Read ; } catch ( Interrupted IO Exception e ) { if ( throw Read Interrupts ) throw e ; log . log ( Level . FINEST , e . to String ( ) , e ) ; } catch ( IO Exception e ) { if ( throw Read Interrupts ) throw e ; log . log ( Level . FINER , e . to String ( ) , e ) ; } return - NUM ; }
String read UTF ( byte data [ ] , int off , int len ) { int offset = off ; String Buffer buf = new String Buffer ( ) ; for ( int end = offset + len ; offset < end ; ) { int ch = data [ offset ++ ] & NUM ; switch ( ch > > NUM ) { case NUM : case NUM : case NUM : case NUM : case NUM : case NUM : case NUM : case NUM : break ; case NUM : case NUM : if ( offset >= len ) { return null ; } ch = ( ( ch & NUM ) << NUM ) | ( data [ offset ++ ] & NUM ) ; break ; case NUM : if ( offset + NUM >= len ) { return null ; } ch = ( ( ch & NUM ) << NUM ) | ( ( data [ offset ++ ] & NUM ) << NUM ) | ( data [ offset ++ ] & NUM ) ; break ; default : if ( offset + NUM >= len ) { return null ; } ch = ( ( ch & NUM ) << NUM ) | ( data [ offset ++ ] & NUM ) ; break ; } buf . append ( ( char ) ch ) ; } return buf . to String ( ) ; }
public Turtle Writer ( Output Stream out ) { this ( new Output Stream Writer ( out , Charset . for Name ( STRING ) ) ) ; }
private char lookahead ( ) { return cur Char Index < pattern . length ( ) - NUM ? pattern . char At ( cur Char Index + NUM ) : EOF ; }
public static boolean is Number ( String s ) { if ( s . length ( ) == NUM ) { return BOOL ; } for ( char c : s . to Char Array ( ) ) { if ( ! Character . is Digit ( c ) ) { return BOOL ; } } return BOOL ; }
private State ( Circuit State circuit State , Duration timeout Duration , Event Counter counter ) { this . circuit State = circuit State ; this . counter = counter ; if ( timeout Duration . is Zero ( ) || timeout Duration . is Negative ( ) ) { timed Out Time Nanos = NUM ; } else { timed Out Time Nanos = ticker . read ( ) + timeout Duration . to Nanos ( ) ; } }
public void cleanup ( Button Group bg ) { if ( bg != null ) { bg . remove ( layer Name ) ; } cleanup ( ) ; }
public static Map < Meta Key , String > union ( final Map < Meta Key , String > provided Meta Data , final Map < Meta Key , String > extracted Meta Data ) { final int size 1 = provided Meta Data != null ? provided Meta Data . size ( ) : NUM ; final int size 2 = extracted Meta Data != null ? extracted Meta Data . size ( ) : NUM ; if ( size 1 + size 2 == NUM ) { return Collections . empty Map ( ) ; } final Map < Meta Key , String > result = new Hash Map < > ( size 1 + size 2 ) ; if ( extracted Meta Data != null ) { result . put All ( extracted Meta Data ) ; } if ( provided Meta Data != null ) { result . put All ( provided Meta Data ) ; } return Collections . unmodifiable Map ( result ) ; }
public static char [ ] fix 83600 ( char [ ] signature ) { if ( signature == null || signature . length < NUM ) return signature ; return Signature . remove Capture ( signature ) ; }
public static void format Double ( double source , int decimals , int precision , String Buffer target ) { int scale = ( Math . abs ( source ) >= NUM ) ? decimals : precision ; if ( too Many Digits Used ( source , scale ) || too Close To Round ( source , scale ) ) { format Double Precise ( source , decimals , precision , target ) ; } else { format Double Fast ( source , decimals , precision , target ) ; } }
public static byte [ ] decode ( byte [ ] input , int offset , int len , int flags ) { Decoder decoder = new Decoder ( flags , new byte [ len * NUM / NUM ] ) ; if ( ! decoder . process ( input , offset , len , BOOL ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( decoder . op == decoder . output . length ) { return decoder . output ; } byte [ ] temp = new byte [ decoder . op ] ; System . arraycopy ( decoder . output , NUM , temp , NUM , decoder . op ) ; return temp ; }
protected View create Child ( String name ) { View view = null ; if ( name . equals ( TF PARENTID ) || name . equals ( TF CLIENT TYPE ) ) { view = new CC Text Field ( this , name , STRING ) ; } else if ( name . equals ( SEC MH COMMON ) ) { view = new CC Secondary Masthead ( this , name ) ; } else if ( name . equals ( PGTITLE ) ) { view = new CC Page Title ( this , pt Model , name ) ; } else if ( pt Model . is Child Supported ( name ) ) { view = pt Model . create Child ( this , name ) ; } else if ( name . equals ( PROPERTY ATTRIBUTE ) ) { view = new AM Property Sheet ( this , property Sheet Model , name ) ; } else if ( property Sheet Model . is Child Supported ( name ) ) { view = property Sheet Model . create Child ( this , name , get Model ( ) ) ; } else { view = super . create Child ( name ) ; } return view ; }
public synchronized void draw ( final Graphics 2 D gfx , final float x , final float y ) { if ( ! is Empty ( ) ) { m text Layout . draw ( gfx , x , y ) ; for ( final C Highlighting highlighting : new Array List < C Highlighting > ( m highlighting ) ) { final double bp X = ( x + highlighting . get Start ( ) ) - NUM ; final double bp Y = ( y - m char Height ) + NUM ; final double bp W = highlighting . get End ( ) + NUM ; final double bp H = m char Height - NUM ; draw Highlighting ( gfx , bp X , bp Y , bp W , bp H , highlighting . get Color ( ) ) ; } } }
public void write Map End ( ) throws IO Exception { os . write ( STRING ) ; }
public boolean is Abstract ( ) { return Modifier . is Abstract ( flags ) ; }
public static File relative File ( File f ) { if ( f . is Absolute ( ) ) { f = relative File ( new File ( STRING ) , f ) ; } return f ; }
public XML Parser ( final String namespace , final String [ ] schemas ) throws XML Exception { try { JAXB Context jc = JAXB Context . new Instance ( namespace ) ; marshaller = jc . create Marshaller ( ) ; marshaller . set Schema ( XML Schema Utils . create Schema ( schemas ) ) ; unmarshaller = jc . create Unmarshaller ( ) ; unmarshaller . set Schema ( XML Schema Utils . create Schema ( schemas ) ) ; } catch ( JAXB Exception e ) { throw new XML Exception ( STRING + namespace , e ) ; } }
private Array List < Spinner Language Element > create Spinner Languages ( int avoid Language ) { Array List < Spinner Language Element > result = new Array List < Spinner Language Element > ( ) ; List < String > languages = m Session Options . all Languages ( ) ; for ( int i = NUM ; i < languages . size ( ) ; ++ i ) { if ( i != avoid Language ) { result . add ( new Spinner Language Element ( languages . get ( i ) , i ) ) ; } } return result ; }
public String [ ] split Resource Name ( String service Type Name , String resource Name ) throws Name Not Found Exception , SSO Exception , Policy Exception { Service Type st = get Service Type ( service Type Name ) ; Set prefixes = get Managed Resource Names ( service Type Name ) ; String [ ] ret Val = new String [ NUM ] ; if ( prefixes . is Empty ( ) ) { ret Val [ NUM ] = STRING ; ret Val [ NUM ] = resource Name ; return ret Val ; } Iterator iter = prefixes . iterator ( ) ; String tmp = null ; Resource Match match Result = null ; boolean found Super Match = BOOL ; boolean found Exact Match = BOOL ; while ( iter . has Next ( ) ) { tmp = ( String ) iter . next ( ) ; match Result = st . compare ( resource Name , tmp ) ; if ( match Result . equals ( Resource Match . SUPER RESOURCE MATCH ) ) { found Super Match = BOOL ; break ; } if ( match Result . equals ( Resource Match . EXACT MATCH ) ) { found Exact Match = BOOL ; break ; } } if ( found Super Match ) { ret Val [ NUM ] = tmp ; ret Val [ NUM ] = st . get Sub Resource ( resource Name , tmp ) ; return ret Val ; } if ( found Exact Match ) { ret Val [ NUM ] = tmp ; ret Val [ NUM ] = STRING ; return ret Val ; } ret Val [ NUM ] = STRING ; ret Val [ NUM ] = resource Name ; return ret Val ; }
void materialize ( ) { if ( cachefill < NUM ) { return ; } double min = Double . MAX VALUE , max = Double . MIN VALUE ; for ( int i = NUM ; i < cachefill ; i ++ ) { min = Math . min ( min , cachec [ i ] ) ; max = Math . max ( max , cachec [ i ] ) ; } Linear Scale scale = new Linear Scale ( min , max ) ; min = scale . get Min ( ) ; max = scale . get Max ( ) ; this . base = min ; this . max = max ; this . binsize = ( max - min ) / this . destsize ; this . data = new long [ this . destsize << NUM ] ; size = destsize ; final int end = cachefill ; cachefill = - NUM ; for ( int i = NUM ; i < end ; i ++ ) { increment ( cachec [ i ] , cachev [ i ] ) ; } cachec = null ; cachev = null ; }
public Criteria create Criteria ( ) { Criteria criteria = create Criteria Internal ( ) ; if ( ored Criteria . size ( ) == NUM ) { ored Criteria . add ( criteria ) ; } return criteria ; }
public Array Field Vector ( Field < T > field , T [ ] v1 , T [ ] v2 ) throws Math Illegal Argument Exception , Null Argument Exception { Math Utils . check Not Null ( v1 ) ; Math Utils . check Not Null ( v2 ) ; if ( v1 . length + v2 . length == NUM ) { throw new Math Illegal Argument Exception ( Localized Core Formats . VECTOR MUST HAVE AT LEAST ONE ELEMENT ) ; } data = Math Arrays . build Array ( field , v1 . length + v2 . length ) ; System . arraycopy ( v1 , NUM , data , NUM , v1 . length ) ; System . arraycopy ( v2 , NUM , data , v1 . length , v2 . length ) ; this . field = field ; }
private void verify Target Session Is Local Or Stateless ( Session Request req , Session ID sid ) throws Session Exception , Session Request Exception , Forward Session Request Exception { if ( stateless Session Manager . contains Jwt ( sid ) ) { return ; } String host Server ID = foreign Session Handler . get Current Host Server ( sid ) ; if ( ! server Config . is Local Server ( host Server ID ) ) { try { throw new Forward Session Request Exception ( forward ( SESSION SERVICE URL SERVICE . get Session Service URL ( host Server ID ) , req ) ) ; } catch ( Session Exception se ) { if ( ! session Service . check Server Up ( host Server ID ) ) { String retry Host Server ID = foreign Session Handler . get Current Host Server ( sid ) ; if ( retry Host Server ID . equals ( host Server ID ) ) { throw se ; } else { if ( ! server Config . is Local Server ( retry Host Server ID ) ) { throw new Forward Session Request Exception ( forward ( SESSION SERVICE URL SERVICE . get Session Service URL ( host Server ID ) , req ) ) ; } } } else { throw se ; } } } if ( ! session Service . check Session Local ( sid ) ) { throw new Session Request Exception ( sid , Session Bundle . get String ( STRING ) ) ; } }
public static boolean is Java Builtin Data Type ( Class clazz ) { if ( clazz == null ) { return BOOL ; } Class clazz Boxed = get Boxed Type ( clazz ) ; if ( is Numeric ( clazz Boxed ) ) { return BOOL ; } if ( is Boolean ( clazz Boxed ) ) { return BOOL ; } if ( clazz Boxed . equals ( String . class ) ) { return BOOL ; } if ( ( clazz Boxed . equals ( char . class ) ) || ( clazz Boxed . equals ( Character . class ) ) ) { return BOOL ; } if ( clazz Boxed . equals ( void . class ) ) { return BOOL ; } return BOOL ; }
protected boolean is Control Char ( char ch ) { return Character . is ISO Control ( ch ) && ! Character . is Whitespace ( ch ) ; }
public void encode ( Output Stream out ) throws IO Exception { Der Output Stream tmp = new Der Output Stream ( ) ; if ( extension Value == null ) { extension Id = PKIX Extensions . Policy Constraints Id ; critical = BOOL ; encode This ( ) ; } super . encode ( tmp ) ; out . write ( tmp . to Byte Array ( ) ) ; }
< T > List < T > on Find All ( Class < T > model Class , boolean is Eager , long ... ids ) { List < T > data List ; if ( is Affect All Lines ( ids ) ) { data List = query ( model Class , null , null , null , null , null , STRING , null , get Foreign Key Associations ( model Class . get Name ( ) , is Eager ) ) ; } else { data List = query ( model Class , null , get Where Of Ids With Or ( ids ) , null , null , null , STRING , null , get Foreign Key Associations ( model Class . get Name ( ) , is Eager ) ) ; } return data List ; }
public boolean is Cached ( String request Url , int max Width , int max Height ) { return is Cached ( request Url , max Width , max Height , Scale Type . CENTER INSIDE ) ; }
public Style add Style ( String nm , Style parent ) { Style Context styles = ( Style Context ) get Attribute Context ( ) ; return styles . add Style ( nm , parent ) ; }
public static Text With Mnemonic parse Text ( final String text With Mnemonic ) { if ( text With Mnemonic == null ) { throw new Illegal Argument Exception ( STRING ) ; } int index = - NUM ; final String Buffer plain Text = new String Buffer ( ) ; for ( int i = NUM ; i < text With Mnemonic . length ( ) ; i ++ ) { char ch = text With Mnemonic . char At ( i ) ; if ( ch == STRING ) { i ++ ; if ( i >= text With Mnemonic . length ( ) ) { break ; } ch = text With Mnemonic . char At ( i ) ; if ( ch != STRING ) { index = plain Text . length ( ) ; } } plain Text . append ( ch ) ; } return new Text With Mnemonic ( plain Text . to String ( ) , index ) ; }
public void check Permissions ( Namespace Entity namespace Entity , String ... requested Iam Role Names ) { check Permissions ( namespace Entity , Arrays . as List ( requested Iam Role Names ) ) ; }
private static Annotated Type Mirror as Outer Super ( Types types , Annotated Type Factory atype Factory , Annotated Type Mirror type , Annotated Type Mirror super Type ) { if ( type . get Kind ( ) == Type Kind . DECLARED ) { Annotated Declared Type dt = ( Annotated Declared Type ) type ; Annotated Declared Type enclosing Type = dt ; Type Mirror super Type Mirror = types . erasure ( super Type . get Underlying Type ( ) ) ; while ( enclosing Type != null ) { Type Mirror enclosing Type Mirror = types . erasure ( enclosing Type . get Underlying Type ( ) ) ; if ( types . is Subtype ( enclosing Type Mirror , super Type Mirror ) ) { dt = enclosing Type ; break ; } enclosing Type = enclosing Type . get Enclosing Type ( ) ; } if ( enclosing Type == null ) { return super Type ; } return as Super ( atype Factory , dt , super Type ) ; } return as Super ( atype Factory , type , super Type ) ; }
public void reload ( Solr Core core , Solr Index Searcher searcher ) throws IO Exception { LOG . info ( STRING ) ; if ( dictionary == null && store Dir != null ) { File Input Stream is = new File Input Stream ( new File ( store Dir , factory . store File Name ( ) ) ) ; try { if ( lookup . load ( is ) ) { return ; } } finally { IO Utils . close While Handling Exception ( is ) ; } LOG . debug ( STRING ) ; } build ( core , searcher ) ; }
public static String as String ( String json Path , Map < String , Object > json ) { return path As ( String . class , json Path , json ) ; }
@ Override public Server Heartbeat server Dyn ( String address , int port , boolean is SSL , String cluster Id , String display Name ) { Objects . require Non Null ( address ) ; Objects . require Non Null ( cluster Id ) ; Cluster Heartbeat cluster = create Cluster ( cluster Id ) ; Server Heartbeat server = cluster . create Server ( address , port , is SSL ) ; if ( display Name != null ) { server . set Display Name ( display Name ) ; } cluster . add Dynamic Server ( server ) ; return server ; }
public void paint Component Background ( Object native Graphics , int x , int y , int width , int height , Style s ) { if ( width <= NUM || height <= NUM ) { return ; } Image bg Image Orig = s . get Bg Image ( ) ; if ( bg Image Orig == null ) { if ( s . get Background Type ( ) >= Style . BACKGROUND GRADIENT LINEAR VERTICAL ) { draw Gradient Background ( s , native Graphics , x , y , width , height ) ; return ; } set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; } else { int iW = bg Image Orig . get Width ( ) ; int iH = bg Image Orig . get Height ( ) ; Object bg Image = bg Image Orig . get Image ( ) ; switch ( s . get Background Type ( ) ) { case Style . BACKGROUND NONE : if ( s . get Bg Transparency ( ) != NUM ) { set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; } return ; case Style . BACKGROUND IMAGE SCALED : if ( is Scaled Image Drawing Supported ( ) ) { draw Image ( native Graphics , bg Image , x , y , width , height ) ; } else { if ( iW != width || iH != height ) { bg Image Orig = bg Image Orig . scaled ( width , height ) ; s . set Bg Image ( bg Image Orig , BOOL ) ; bg Image = bg Image Orig . get Image ( ) ; } draw Image ( native Graphics , bg Image , x , y ) ; } return ; case Style . BACKGROUND IMAGE SCALED FILL : float r = Math . max ( ( ( float ) width ) / ( ( float ) iW ) , ( ( float ) height ) / ( ( float ) iH ) ) ; int bwidth = ( int ) ( ( ( float ) iW ) * r ) ; int bheight = ( int ) ( ( ( float ) iH ) * r ) ; if ( is Scaled Image Drawing Supported ( ) ) { draw Image ( native Graphics , bg Image , x + ( width - bwidth ) / NUM , y + ( height - bheight ) / NUM , bwidth , bheight ) ; } else { if ( iW != bwidth || iH != bheight ) { bg Image Orig = bg Image Orig . scaled ( bwidth , bheight ) ; s . set Bg Image ( bg Image Orig , BOOL ) ; bg Image = bg Image Orig . get Image ( ) ; } draw Image ( native Graphics , bg Image , x + ( width - bwidth ) / NUM , y + ( height - bheight ) / NUM ) ; } return ; case Style . BACKGROUND IMAGE SCALED FIT : if ( s . get Bg Transparency ( ) != NUM ) { set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; } float r2 = Math . min ( ( ( float ) width ) / ( ( float ) iW ) , ( ( float ) height ) / ( ( float ) iH ) ) ; int awidth = ( int ) ( ( ( float ) iW ) * r2 ) ; int aheight = ( int ) ( ( ( float ) iH ) * r2 ) ; if ( is Scaled Image Drawing Supported ( ) ) { draw Image ( native Graphics , bg Image , x + ( width - awidth ) / NUM , y + ( height - aheight ) / NUM , awidth , aheight ) ; } else { if ( iW != awidth || iH != aheight ) { bg Image Orig = bg Image Orig . scaled ( awidth , aheight ) ; s . set Bg Image ( bg Image Orig , BOOL ) ; bg Image = bg Image Orig . get Image ( ) ; } draw Image ( native Graphics , bg Image , x + ( width - awidth ) / NUM , y + ( height - aheight ) / NUM , awidth , aheight ) ; } return ; case Style . BACKGROUND IMAGE TILE BOTH : tile Image ( native Graphics , bg Image , x , y , width , height ) ; return ; case Style . BACKGROUND IMAGE TILE HORIZONTAL ALIGN TOP : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; tile Image ( native Graphics , bg Image , x , y , width , iH ) ; return ; case Style . BACKGROUND IMAGE TILE HORIZONTAL ALIGN CENTER : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; tile Image ( native Graphics , bg Image , x , y + ( height / NUM - iH / NUM ) , width , iH ) ; return ; case Style . BACKGROUND IMAGE TILE HORIZONTAL ALIGN BOTTOM : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; tile Image ( native Graphics , bg Image , x , y + ( height - iH ) , width , iH ) ; return ; case Style . BACKGROUND IMAGE TILE VERTICAL ALIGN LEFT : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; for ( int y Pos = NUM ; y Pos <= height ; y Pos += iH ) { draw Image ( native Graphics , bg Image , x , y + y Pos ) ; } return ; case Style . BACKGROUND IMAGE TILE VERTICAL ALIGN CENTER : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; for ( int y Pos = NUM ; y Pos <= height ; y Pos += iH ) { draw Image ( native Graphics , bg Image , x + ( width / NUM - iW / NUM ) , y + y Pos ) ; } return ; case Style . BACKGROUND IMAGE TILE VERTICAL ALIGN RIGHT : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; for ( int y Pos = NUM ; y Pos <= height ; y Pos += iH ) { draw Image ( native Graphics , bg Image , x + width - iW , y + y Pos ) ; } return ; case Style . BACKGROUND IMAGE ALIGNED TOP : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; draw Image ( native Graphics , bg Image , x + ( width / NUM - iW / NUM ) , y ) ; return ; case Style . BACKGROUND IMAGE ALIGNED BOTTOM : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; draw Image ( native Graphics , bg Image , x + ( width / NUM - iW / NUM ) , y + ( height - iH ) ) ; return ; case Style . BACKGROUND IMAGE ALIGNED LEFT : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; draw Image ( native Graphics , bg Image , x , y + ( height / NUM - iH / NUM ) ) ; return ; case Style . BACKGROUND IMAGE ALIGNED RIGHT : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; draw Image ( native Graphics , bg Image , x + width - iW , y + ( height / NUM - iH / NUM ) ) ; return ; case Style . BACKGROUND IMAGE ALIGNED CENTER : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; draw Image ( native Graphics , bg Image , x + ( width / NUM - iW / NUM ) , y + ( height / NUM - iH / NUM ) ) ; return ; case Style . BACKGROUND IMAGE ALIGNED TOP LEFT : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; draw Image ( native Graphics , bg Image , x , y ) ; return ; case Style . BACKGROUND IMAGE ALIGNED TOP RIGHT : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; draw Image ( native Graphics , bg Image , x + width - iW , y ) ; return ; case Style . BACKGROUND IMAGE ALIGNED BOTTOM LEFT : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; draw Image ( native Graphics , bg Image , x , y + ( height - iH ) ) ; return ; case Style . BACKGROUND IMAGE ALIGNED BOTTOM RIGHT : set Color ( native Graphics , s . get Bg Color ( ) ) ; fill Rect ( native Graphics , x , y , width , height , s . get Bg Transparency ( ) ) ; draw Image ( native Graphics , bg Image , x + width - iW , y + ( height - iH ) ) ; return ; case Style . BACKGROUND GRADIENT LINEAR HORIZONTAL : case Style . BACKGROUND GRADIENT LINEAR VERTICAL : case Style . BACKGROUND GRADIENT RADIAL : draw Gradient Background ( s , native Graphics , x , y , width , height ) ; return ; } } }
public void run Test ( ) throws Throwable { Document doc ; Node List gender List ; Node gender Node ; Character Data ent Text ; Entity Reference ent Reference ; Node appended Node ; doc = ( Document ) load ( STRING , BOOL ) ; gender List = doc . get Elements By Tag Name ( STRING ) ; gender Node = gender List . item ( NUM ) ; ent Reference = doc . create Entity Reference ( STRING ) ; assert Not Null ( STRING , ent Reference ) ; appended Node = gender Node . append Child ( ent Reference ) ; ent Text = ( Character Data ) ent Reference . get First Child ( ) ; assert Not Null ( STRING , ent Text ) ; { boolean success = BOOL ; try { ent Text . replace Data ( NUM , NUM , STRING ) ; } catch ( DOM Exception ex ) { success = ( ex . code == DOM Exception . NO MODIFICATION ALLOWED ERR ) ; } assert True ( STRING , success ) ; } }
public void remove All ( ) { m Parts . clear ( ) ; }
protected abstract void handle Lost Entry ( Http Route route ) ;
private void write Attribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( xml Writer . get Prefix ( namespace ) == null ) { xml Writer . write Namespace ( prefix , namespace ) ; xml Writer . set Prefix ( prefix , namespace ) ; } xml Writer . write Attribute ( namespace , att Name , att Value ) ; }
public static boolean executable Exists ( String executable ) { File direct File = new File ( executable ) ; if ( direct File . exists ( ) && direct File . can Execute ( ) ) { return BOOL ; } for ( String path String : get System Path ( ) ) { Path path = Paths . get ( path String ) ; if ( Files . exists ( path . resolve ( executable ) ) && Files . is Executable ( path . resolve ( executable ) ) ) { return BOOL ; } } return BOOL ; }
@ Override public String to String ( ) { String Builder buf = new String Builder ( ) ; int i = NUM ; for ( Pseudo Op op : contents ) { buf . append ( String . format ( STRING , i ++ , op ) ) ; } return buf . to String ( ) ; }
private List < File > combine ( List < File > list A , List < File > list B ) { Linked Hash Set < File > combined Projects = Sets . new Linked Hash Set ( list A ) ; combined Projects . add All ( list B ) ; return new Array List < > ( combined Projects ) ; }
public long generate New Ping Id ( ) { Preference Store prefs = get Preference Store ( ) ; Random rnd = new Random ( ) ; long id = rnd . next Long ( ) ; synchronized ( Ddms Preference Store . class ) { prefs . set Value ( PING ID , id ) ; try { prefs . save ( ) ; } catch ( IO Exception e ) { } } return id ; }
public boolean is Valid ( ) { return System . current Time Millis ( ) < creation Time + lifetime + ( lifetime / NUM ) ; }
public static Model read From ( Virtual File file ) throws Server Exception , Forbidden Exception , IO Exception { require Non Null ( file , STRING ) ; return fetch Model ( XML Tree . from ( file . get Content ( ) ) ) ; }
public boolean is Value Exist For Key ( String key ) { boolean is Value Exists ; try { String string = get String ( key , STRING ) ; is Value Exists = ! string . equals Ignore Case ( STRING ) ; } catch ( Class Cast Exception e ) { try { int an Int = get Int ( key , NUM ) ; is Value Exists = an Int != NUM ; } catch ( Class Cast Exception e1 ) { try { long a Long = get Long ( key , NUM ) ; is Value Exists = a Long != NUM ; } catch ( Class Cast Exception e2 ) { try { float a Float = get Float ( key , NUM ) ; is Value Exists = a Float != NUM ; } catch ( Class Cast Exception e3 ) { try { boolean a Boolean = get Boolean ( key , BOOL ) ; is Value Exists = ! a Boolean ; } catch ( Exception e4 ) { is Value Exists = BOOL ; e . print Stack Trace ( ) ; } } } } } catch ( Exception e ) { is Value Exists = BOOL ; } return is Value Exists ; }
public void update Viewport ( ) { set To Ortho ( BOOL , virtual Viewport . get Width ( ) , virtual Viewport . get Height ( ) ) ; }
public String to String ( ) { if ( key Usages == null ) return STRING ; String usage = STRING ; boolean first = BOOL ; for ( Object Identifier oid : key Usages ) { if ( ! first ) { usage += STRING ; } String result = map . get ( oid ) ; if ( result != null ) { usage += result ; } else { usage += oid . to String ( ) ; } first = BOOL ; } return super . to String ( ) + STRING + usage + STRING ; }
public static void write Boxplot ( T Double Object Hash Map < double [ ] > table , String file ) throws IO Exception { int max Size = NUM ; T Double Object Iterator < double [ ] > it = table . iterator ( ) ; for ( int i = NUM ; i < table . size ( ) ; i ++ ) { it . advance ( ) ; max Size = Math . max ( max Size , it . value ( ) . length ) ; } double keys [ ] = table . keys ( ) ; Arrays . sort ( keys ) ; Buffered Writer writer = new Buffered Writer ( new File Writer ( file ) ) ; for ( int k = NUM ; k < keys . length ; k ++ ) { writer . write ( String . value Of ( keys [ k ] ) ) ; if ( k + NUM < keys . length ) writer . write ( TAB ) ; } writer . new Line ( ) ; for ( int i = NUM ; i < max Size ; i ++ ) { for ( int k = NUM ; k < keys . length ; k ++ ) { double [ ] list = table . get ( keys [ k ] ) ; if ( i < list . length ) { writer . write ( String . value Of ( list [ i ] ) ) ; } else { writer . write ( NA ) ; } if ( k + NUM < keys . length ) writer . write ( TAB ) ; } writer . new Line ( ) ; } writer . close ( ) ; }
public void test Clear Bit Negative Inside 3 ( ) { String as = STRING ; int number = NUM ; Big Integer a Number = new Big Integer ( as ) ; Big Integer result = a Number . clear Bit ( number ) ; assert Equals ( as , result . to String ( ) ) ; }
@ Theory public void log Entries Have Same Order As Indexes ( Object [ ] data Point ) { int index 1 = ( int ) data Point [ NUM ] ; int index 2 = ( int ) data Point [ NUM ] ; Log Entry first = log Entries [ index 1 ] ; Log Entry second = log Entries [ index 2 ] ; LOG . debug ( STRING , index 1 , index 2 ) ; int result = tested . compare ( first , second ) ; int expected = Integer . compare ( index 1 , index 2 ) ; assert That Have Same Signum ( expected , result ) ; }
public static void copy All ( File root , File dest ) throws IO Exception { if ( root . is Directory ( ) ) { for ( File child : root . list Files ( ) ) { File child Dest = new File ( dest , child . get Name ( ) ) ; if ( child . is Directory ( ) ) { if ( ! child Dest . exists ( ) && ! mkdirs ( child Dest ) ) throw new IO Exception ( STRING + child Dest . get Path ( ) ) ; copy All ( child , child Dest ) ; } else { Files . copy ( child . to Path ( ) , child Dest . to Path ( ) , Standard Copy Option . COPY ATTRIBUTES ) ; } } } else { File child Dest = new File ( dest , root . get Name ( ) ) ; if ( ! dest . exists ( ) && ! mkdirs ( dest ) ) throw new IO Exception ( STRING + dest . get Path ( ) ) ; Files . copy ( root . to Path ( ) , child Dest . to Path ( ) , Standard Copy Option . COPY ATTRIBUTES ) ; } }
public void paint Line ( Point 2 D pt 1 , Point 2 D pt 2 ) { if ( pt 1 != null && pt 2 != null ) { OM Line c Line = new OM Line ( pt 1 . get Y ( ) , pt 1 . get X ( ) , pt 2 . get Y ( ) , pt 2 . get X ( ) , OM Graphic . LINETYPE GREATCIRCLE ) ; Projection proj = the Map . get Projection ( ) ; c Line . generate ( proj ) ; distance List . add ( c Line ) ; } }
public static boolean has Export Mask For Storage And V Array ( Db Client db Client , Export Group export Group , URI storage URI ) { Set < String > storage Port UR Is Associated With V Array And Storage Array = Export Mask Utils . get Storage Port Uris Associated With Varray And Storage Array ( storage URI , export Group . get Virtual Array ( ) , db Client ) ; String Set mask Uri Set = export Group . get Export Masks ( ) ; if ( mask Uri Set != null ) { for ( String mask Uri String : mask Uri Set ) { Export Mask mask = db Client . query Object ( Export Mask . class , URI . create ( mask Uri String ) ) ; URI mask Storage URI = mask . get Storage Device ( ) ; if ( mask Storage URI . equals ( storage URI ) ) { for ( String storage Port : mask . get Storage Ports ( ) ) { if ( storage Port UR Is Associated With V Array And Storage Array . contains ( storage Port ) ) return BOOL ; } } } } return BOOL ; }
private void preload ( int first , boolean increasing ) { final int start ; final int end ; if ( increasing ) { start = Math . max ( first , m Last End ) ; end = Math . min ( first + m Load Ahead Items , m Item Source . get Count ( ) ) ; } else { start = Math . max ( NUM , first - m Load Ahead Items ) ; end = Math . min ( first , m Last Start ) ; } Log . v ( TAG , STRING + first + STRING + increasing + STRING + start + STRING + end ) ; m Last End = end ; m Last Start = start ; if ( start == NUM && end == NUM ) { return ; } final List < T > items = m Item Source . get Items In Range ( start , end ) ; if ( ! increasing ) { Collections . reverse ( items ) ; } register Load Tokens ( m Item Loader . preload Items ( items ) ) ; }
Builder add Lenient ( String line ) { int index = line . index Of ( STRING , NUM ) ; if ( index != - NUM ) { return add Lenient ( line . substring ( NUM , index ) , line . substring ( index + NUM ) ) ; } else if ( line . starts With ( STRING ) ) { return add Lenient ( STRING , line . substring ( NUM ) ) ; } else { return add Lenient ( STRING , line ) ; } }
private void init RMI Parameters ( ) throws Exception { if ( rmi Host Master == null || rmi Port Master == null ) { File conf Dir = Replicator Runtime Conf . locate Replicator Conf Dir ( ) ; File props File = new File ( conf Dir , Replication Service Manager . CONFIG SERVICES ) ; println ( String . format ( STRING , props File ) ) ; Tungsten Properties service Props = Properties Manager . load Properties ( props File ) ; if ( rmi Port Master == null ) rmi Port Master = service Props . get String ( Replicator Conf . RMI PORT , Replicator Conf . RMI DEFAULT PORT , BOOL ) ; if ( rmi Host Master == null ) rmi Host Master = Replication Service Manager . get Host Name ( service Props ) ; } }
public String encode Key ( final String key ) { if ( String Utils . is Empty ( key ) ) { throw new Illegal Argument Exception ( STRING ) ; } try { return Hex . encode Hex String ( key . get Bytes ( STRING ) ) ; } catch ( Unsupported Encoding Exception uee ) { throw new Illegal State Exception ( uee ) ; } }
private static void global Union Test ( final I Schema Version schema Version ) throws IO Exception { final Writer output = open Output ( schema Version , STRING , Test Type . UNION ) ; final HLL hll = new HLL ( HLL Type . EMPTY ) ; final HLL empty HLL = new HLL ( HLL Type . EMPTY ) ; cumulative Union Line ( output , hll , empty HLL , schema Version ) ; for ( int i = NUM ; i < NUM ; i ++ ) { final HLL random HLL = generate Random HLL ( ) ; cumulative Union Line ( output , hll , random HLL , schema Version ) ; } output . flush ( ) ; output . close ( ) ; }
public static boolean restore ( ) { File restore Config = new File ( RESTORATION PROPERTIES ) ; if ( restore Config . exists ( ) && restore Config . is File ( ) ) { logger . info ( STRING ) ; try ( File Input Stream stream = new File Input Stream ( restore Config ) ) { Properties properties = new Properties ( ) ; properties . load ( stream ) ; restore Database ( properties ) ; restore Solr Index ( properties ) ; } catch ( Unsupported Operation Exception e ) { logger . error ( STRING , e ) ; System . set Property ( STRING , STRING ) ; } catch ( Exception e ) { logger . fatal ( STRING , e ) ; return BOOL ; } finally { restore Config . delete ( ) ; } } return BOOL ; }
public void test Set Bit Positive Inside 4 ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; int a Sign = NUM ; int number = NUM ; byte r Bytes [ ] = { NUM , - NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer result = a Number . set Bit ( number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
@ Override public void write Comment ( String data ) throws XML Stream Exception { log . log ( Level . FINE , STRING , data ) ; }
public static File from Data URI ( String data URI , String file Name ) { return File . create If Supported ( from Data URI ( data URI ) , file Name ) ; }
protected List extract Discovery Information ( XRDS xrds , Xri Identifier identifier , Resolver xri Resolver ) throws Discovery Exception { Array List endpoints = new Array List ( ) ; XRD xrd = xrds . get Final XRD ( ) ; extract Discovery Information Open ID ( xri Resolver , endpoints , xrd , identifier , Discovery Information . OPENID 2 OP , BOOL ) ; extract Discovery Information Open ID ( xri Resolver , endpoints , xrd , identifier , Discovery Information . OPENID 2 , BOOL ) ; extract Discovery Information Open ID ( xri Resolver , endpoints , xrd , identifier , Discovery Information . OPENID 11 , BOOL ) ; extract Discovery Information Open ID ( xri Resolver , endpoints , xrd , identifier , Discovery Information . OPENID 10 , BOOL ) ; if ( endpoints . size ( ) == NUM ) log . info ( STRING ) ; return endpoints ; }
public static void clear Recent Files ( ) { String str = Program Properties . get ( RECENTFILES , STRING ) ; if ( str . length ( ) != NUM ) { Program Properties . put ( RECENTFILES , STRING ) ; notify List Change ( RECENTFILES ) ; } }
public static boolean are Equivalent ( final Type Reference a , final Type Reference b ) { return are Equivalent ( a , b , BOOL ) ; }
private static char Call Static Char Method V ( JNI Environment env , int class JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object return Obj = JNI Helpers . invoke With Var Arg ( method ID , arg Address , Type Reference . Char ) ; return Reflection . unwrap Char ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
private boolean init X Settings If Needed ( final String prop Name ) { if ( ! loaded X Settings && ( prop Name . starts With ( STRING ) || prop Name . equals ( Sun Toolkit . DESKTOPFONTHINTS ) || prop Name . starts With ( dnd Prefix ) ) ) { loaded X Settings = BOOL ; if ( ! Graphics Environment . is Headless ( ) ) { load X Settings ( ) ; if ( desktop Properties . get ( Sun Toolkit . DESKTOPFONTHINTS ) == null ) { if ( XWM . is KDE 2 ( ) ) { Object hint = fc Manager . get Font Config AA Hint ( ) ; if ( hint != null ) { desktop Properties . put ( UNIX Toolkit . FONTCONFIGAAHINT , hint ) ; } } desktop Properties . put ( Sun Toolkit . DESKTOPFONTHINTS , Sun Toolkit . get Desktop Font Hints ( ) ) ; } return BOOL ; } } return BOOL ; }
private void update Sorting Icons ( ) { for ( Sorting Type type : Sorting Type . values ( ) ) { Sorting Direction direction = model . get Sorting Direction ( type ) ; Image Icon icon ; switch ( direction ) { case DESCENDING : icon = ICON ARROW DOWN ; break ; case ASCENDING : icon = ICON ARROW UP ; break ; case UNDEFINED : icon = null ; break ; default : icon = null ; } switch ( type ) { case NAME : sorting Label Att Name . set Icon ( icon ) ; break ; case TYPE : sorting Label Att Type . set Icon ( icon ) ; break ; case MISSING : sorting Label Att Missings . set Icon ( icon ) ; break ; default : sorting Label Att Name . set Icon ( null ) ; sorting Label Att Type . set Icon ( null ) ; sorting Label Att Missings . set Icon ( null ) ; } } }
@ Override public synchronized void clear ( ) { File [ ] files = m Root Directory . list Files ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } m Entries . clear ( ) ; m Total Size = NUM ; Volley Log . d ( STRING ) ; }
private void restore Icon ( Key key , byte [ ] buffer , int data Size ) throws IO Exception { if ( VERBOSE ) Log . v ( TAG , STRING + key . id ) ; if ( DEBUG ) Log . d ( TAG , STRING + buffer . length + STRING + Base 64 . encode To String ( buffer , NUM , data Size , Base 64 . NO WRAP ) ) ; Resource res = unpack Proto ( new Resource ( ) , buffer , data Size ) ; if ( DEBUG ) { Log . d ( TAG , STRING + res . dpi + STRING ) ; } Bitmap icon = Bitmap Factory . decode Byte Array ( res . data , NUM , res . data . length ) ; if ( icon == null ) { Log . w ( TAG , STRING + key . name ) ; } if ( VERBOSE ) Log . v ( TAG , STRING + key . name ) ; Icon Cache . preload Icon ( m Context , Component Name . unflatten From String ( key . name ) , icon , res . dpi ) ; }
public boolean is Expired ( ) { return payment Details . has Expires ( ) && System . current Time Millis ( ) / NUM > payment Details . get Expires ( ) ; }
private void end Formals ( ) { if ( has Formals ) { has Formals = BOOL ; buf . append ( STRING ) ; } }
public static void read Bytes ( Input Stream is , byte [ ] b , int offset , int len ) { if ( len == NUM ) return ; try { int read = NUM ; while ( read < len ) { int n = is . read ( b , offset + read , len - read ) ; if ( n < NUM ) throw new Pngj Input Exception ( STRING + n + STRING + len ) ; read += n ; } } catch ( IO Exception e ) { throw new Pngj Input Exception ( STRING , e ) ; } }
public Character Match ( char [ ] chars ) { Assert . is Not Null ( chars ) ; Assert . is True ( chars . length > NUM ) ; f Chars = chars ; Arrays . sort ( chars ) ; }
public void add Action Listener ( Action Listener new A ) { m Listeners . add ( new A ) ; }
public boolean remove Container And Cancel If Necessary ( Image Container container ) { m Containers . remove ( container ) ; if ( m Containers . size ( ) == NUM ) { m Request . cancel ( ) ; return BOOL ; } return BOOL ; }
public static byte [ ] encode ( byte [ ] data , int off , int length ) { Byte Array Output Stream b Out = new Byte Array Output Stream ( ) ; try { encoder . encode ( data , off , length , b Out ) ; } catch ( Exception e ) { throw new Encoder Exception ( STRING + e . get Message ( ) , e ) ; } return b Out . to Byte Array ( ) ; }
public double distance To Line Segment ( Lat Long A , Lat Long B ) { double Ax = ( A . lng - lng ) * Math . cos ( NUM * radians * ( A . lat + lat ) ) ; double Ay = ( A . lat - lat ) ; double Bx = ( B . lng - lng ) * Math . cos ( NUM * radians * ( B . lat + lat ) ) ; double By = ( B . lat - lat ) ; if ( Ay == By ) { if ( ( Ax < NUM && Bx < NUM ) || ( Ax > NUM && Bx > NUM ) ) return Math . sqrt ( Math . min ( Ax * Ax + Ay * Ay , Bx * Bx + By * By ) ) * Earth Radius * radians ; if ( Ax == Bx ) return Math . sqrt ( Ax * Ax + Ay * Ay ) * Earth Radius * radians ; } else { double Ix = ( ( By - Ay ) * ( Ax * By - Ay * Bx ) ) / ( ( Ax - Bx ) * ( Ax - Bx ) + ( Ay - By ) * ( Ay - By ) ) ; if ( ( Ix < Ax && Ix < Bx ) || ( Ix > Ax && Ix > Bx ) ) { return Math . sqrt ( Math . min ( Ax * Ax + Ay * Ay , Bx * Bx + By * By ) ) * Earth Radius * radians ; } } return Math . abs ( ( Bx - Ax ) * Ay - Ax * ( By - Ay ) ) / Math . sqrt ( ( Bx - Ax ) * ( Bx - Ax ) + ( By - Ay ) * ( By - Ay ) ) * Earth Radius * radians ; }
@ Not Null public List < Player Nbt > create Multiplayer Player Nbts ( ) { List < Player Nbt > result = new Array List < Player Nbt > ( ) ; for ( File playerdata File : get Playerdata Files ( ) ) { if ( playerdata File . is File ( ) ) { result . add ( create Playerdata Player Nbt ( get Player UUID From Playerdata File ( playerdata File ) ) ) ; } } if ( ! result . is Empty ( ) ) { Log . i ( STRING ) ; return result ; } for ( File players File : get Players Files ( ) ) { if ( players File . is File ( ) ) { result . add ( create Players Player Nbt ( get Player Name From Players File ( players File ) ) ) ; } } if ( ! result . is Empty ( ) ) { Log . i ( STRING ) ; return result ; } Log . i ( STRING ) ; return result ; }
public boolean remove Container And Cancel If Necessary ( Image Container container ) { m Containers . remove ( container ) ; if ( m Containers . size ( ) == NUM ) { m Request . cancel ( ) ; return BOOL ; } return BOOL ; }
private void show ( Setup Window window ) { window . handle Window Opening Event ( ) ; setup Window Holder . show ( window . get Key ( ) ) ; current Window = window ; }
public java . lang . String Buffer append ( java . lang . String str ) { internal . append ( str ) ; return this ; }
private static String replace Stars ( String init ) { String Builder builder = new String Builder ( ) ; char [ ] chars = init . to Char Array ( ) ; for ( int i = NUM ; i < chars . length ; i ++ ) { if ( chars [ i ] == STRING && i == NUM && chars . length > NUM && chars [ i + NUM ] == STRING ) { builder . append ( STRING ) ; i ++ ; } else if ( chars [ i ] == STRING && i < ( chars . length - NUM ) && i > NUM && chars [ i + NUM ] == STRING && chars [ i - NUM ] == STRING ) { builder . delete Char At ( builder . length ( ) - NUM ) ; builder . append ( STRING ) ; } else if ( chars [ i ] == STRING && i == ( chars . length - NUM ) && i > NUM && chars [ i - NUM ] == STRING ) { builder . delete Char At ( builder . length ( ) - NUM ) ; builder . append ( STRING ) ; } else if ( chars [ i ] == STRING ) { builder . append ( STRING ) ; } else { builder . append ( chars [ i ] ) ; } } return builder . to String ( ) ; }
public void start Option Group ( String description ) { option Groups . put ( option List . size ( ) , description ) ; }
private byte [ ] encrypt ( byte [ ] m , NTRU Encryption Public Key Parameters pub Key ) { Integer Polynomial pub = pub Key . h ; int N = params . N ; int q = params . q ; int max Len Bytes = params . max Msg Len Bytes ; int db = params . db ; int buffer Len Bits = params . buffer Len Bits ; int dm 0 = params . dm 0 ; int pk Len = params . pk Len ; int min Calls Mask = params . min Calls Mask ; boolean hash Seed = params . hash Seed ; byte [ ] oid = params . oid ; int l = m . length ; if ( max Len Bytes > NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( l > max Len Bytes ) { throw new Data Length Exception ( STRING + l + STRING + max Len Bytes ) ; } while ( BOOL ) { byte [ ] b = new byte [ db / NUM ] ; random . next Bytes ( b ) ; byte [ ] p0 = new byte [ max Len Bytes + NUM - l ] ; byte [ ] M = new byte [ buffer Len Bits / NUM ] ; System . arraycopy ( b , NUM , M , NUM , b . length ) ; M [ b . length ] = ( byte ) l ; System . arraycopy ( m , NUM , M , b . length + NUM , m . length ) ; System . arraycopy ( p0 , NUM , M , b . length + NUM + m . length , p0 . length ) ; Integer Polynomial m Trin = Integer Polynomial . from Binary 3 Sves ( M , N ) ; byte [ ] bh = pub . to Binary ( q ) ; byte [ ] h Trunc = copy Of ( bh , pk Len / NUM ) ; byte [ ] s Data = build S Data ( oid , m , l , b , h Trunc ) ; Polynomial r = generate Blinding Poly ( s Data , M ) ; Integer Polynomial R = r . mult ( pub , q ) ; Integer Polynomial R4 = ( Integer Polynomial ) R . clone ( ) ; R4 . mod Positive ( NUM ) ; byte [ ] oR 4 = R4 . to Binary ( NUM ) ; Integer Polynomial mask = MGF ( oR 4 , N , min Calls Mask , hash Seed ) ; m Trin . add ( mask ) ; m Trin . mod 3 ( ) ; if ( m Trin . count ( - NUM ) < dm 0 ) { continue ; } if ( m Trin . count ( NUM ) < dm 0 ) { continue ; } if ( m Trin . count ( NUM ) < dm 0 ) { continue ; } R . add ( m Trin , q ) ; R . ensure Positive ( q ) ; return R . to Binary ( q ) ; } }
public final void expect At Least One Result ( Result Set rs ) throws Ade Internal Exception , SQL Exception { if ( ! rs . next ( ) ) { throw new Ade Internal Exception ( STRING + m sql ) ; } }
public Sequence ( ) { this ( INITIAL VALUE ) ; }
public static Optional < Mongo Credential > create Credentials ( String username , String password , String database ) { if ( ! Strings . is Null Or Empty ( username ) && ! Strings . is Null Or Empty ( password ) && ! Strings . is Null Or Empty ( database ) ) { return Optional . of ( Mongo Credential . create Mongo CR Credential ( username , database , password . to Char Array ( ) ) ) ; } else { return Optional . absent ( ) ; } }
public static String read Ascii Line ( Input Stream in ) throws IO Exception { String Builder result = new String Builder ( NUM ) ; while ( BOOL ) { int c = in . read ( ) ; if ( c == - NUM ) { throw new EOF Exception ( ) ; } else if ( c == STRING ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > NUM && result . char At ( length - NUM ) == STRING ) { result . set Length ( length - NUM ) ; } return result . to String ( ) ; }
@ Override public void stop ( ) { if ( executor Service != null ) { executor Service . shutdown ( ) ; } rest Template = null ; }
public void write Exif ( Input Stream jpeg Stream , String exif Out File Name ) throws File Not Found Exception , IO Exception { if ( jpeg Stream == null || exif Out File Name == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Output Stream s = null ; try { s = get Exif Writer Stream ( exif Out File Name ) ; do Exif Stream IO ( jpeg Stream , s ) ; s . flush ( ) ; } catch ( IO Exception e ) { close Silently ( s ) ; throw e ; } s . close ( ) ; }
public Result Record ( Directory Scanner Config scan , Action [ ] actions , File f ) { directory Scanner = scan . get Name ( ) ; this . actions = actions ; date = new Date ( ) ; filename = f . get Absolute Path ( ) ; }
private Method Doc find Impl Method ( Method Doc interface Method ) { String name = interface Method . name ( ) ; String desc = Util . method Descriptor Of ( interface Method ) ; for ( Method Doc impl Method : impl Class . methods ( ) ) { if ( name . equals ( impl Method . name ( ) ) && desc . equals ( Util . method Descriptor Of ( impl Method ) ) ) { return impl Method ; } } return null ; }
protected static List < String > extract Boot Class Path ( final List < String > args ) { return extract Opt With Pattern ( BOOT CLASS PATH REGEX , BOOL , args ) ; }
public abstract Object from Open Value ( Object open Value ) throws Invalid Object Exception ;
public Contour Path ( Contour Attrib attr , int level Index , double [ ] x , double [ ] y ) { x Arr = x ; y Arr = y ; this . level Index = level Index ; attributes = attr ; int np = x Arr . length ; if ( Math . abs ( x [ NUM ] - x [ np - NUM ] ) < k Small X && Math . abs ( y [ NUM ] - y [ np - NUM ] ) < k Small Y ) { closed = BOOL ; x [ np - NUM ] = x [ NUM ] ; y [ np - NUM ] = y [ NUM ] ; } else closed = BOOL ; }
private int clamp Mag ( int value , int abs Min , int abs Max ) { final int abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM ; if ( abs Value > abs Max ) return value > NUM ? abs Max : - abs Max ; return value ; }
protected void print ( String mnemonic , String [ ] args ) { printer . print ( indent + STRING ) ; write Padded String ( mnemonic + STRING , NUM ) ; if ( args != null ) { for ( int i = NUM ; i < args . length ; i ++ ) { if ( i > NUM ) { printer . print ( STRING ) ; } printer . print ( args [ i ] ) ; } } printer . println ( ) ; }
@ Override public void remove Connection Event Listener ( Connection Event Listener listener ) { debug Code ( STRING ) ; listeners . remove ( listener ) ; }
public boolean is Downloadable ( ) { List < String > topics = get Exact Topics ( ) ; for ( String xt : topics ) if ( xt . starts With ( STRING ) ) return BOOL ; if ( get Default UR Ls ( ) . length > NUM ) { return BOOL ; } return BOOL ; }
public boolean is Satisfied By ( Date date ) { Calendar test Date Cal = Calendar . get Instance ( get Time Zone ( ) ) ; test Date Cal . set Time ( date ) ; test Date Cal . set ( Calendar . MILLISECOND , NUM ) ; Date original Date = test Date Cal . get Time ( ) ; test Date Cal . add ( Calendar . SECOND , - NUM ) ; Date time After = get Time After ( test Date Cal . get Time ( ) ) ; return ( ( time After != null ) && ( time After . equals ( original Date ) ) ) ; }
public static Vector < String > scan For Dir Logs ( final String current Path ) { if ( Cfg . DEBUG ) { Check . requires ( current Path != null , STRING ) ; } File fc ; final Vector < String > vector = new Vector < String > ( ) ; try { fc = new File ( current Path ) ; if ( fc . is Directory ( ) ) { final String [ ] file Logs = fc . list ( ) ; for ( final String dir : file Logs ) { final File fdir = new File ( current Path + dir ) ; if ( fdir . is Directory ( ) ) { vector . add Element ( dir + STRING ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + dir ) ; } } } } } catch ( final Exception e ) { if ( Cfg . EXCEPTION ) { Check . log ( e ) ; } if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + e ) ; } } if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + vector . size ( ) ) ; } return vector ; }
private static Array List < String > flatten Rows ( Cursor cursor , int limit ) { Util . throw If Not ( limit >= NUM ) ; Array List < String > flat List = new Array List < > ( ) ; final int num Columns = cursor . get Column Count ( ) ; for ( int row = NUM ; row < limit && cursor . move To Next ( ) ; row ++ ) { for ( int column = NUM ; column < num Columns ; column ++ ) { switch ( cursor . get Type ( column ) ) { case Cursor . FIELD TYPE NULL : flat List . add ( null ) ; break ; case Cursor . FIELD TYPE INTEGER : flat List . add ( String . value Of ( cursor . get Long ( column ) ) ) ; break ; case Cursor . FIELD TYPE FLOAT : flat List . add ( String . value Of ( cursor . get Double ( column ) ) ) ; break ; case Cursor . FIELD TYPE BLOB : flat List . add ( blob To String ( cursor . get Blob ( column ) ) ) ; break ; case Cursor . FIELD TYPE STRING : default : flat List . add ( cursor . get String ( column ) ) ; break ; } } } if ( ! cursor . is After Last ( ) ) { for ( int column = NUM ; column < num Columns ; column ++ ) { flat List . add ( STRING ) ; } } return flat List ; }
public static void over Scroll By ( final Pull To Refresh Base < ? > view , final int delta X , final int scroll X , final int delta Y , final int scroll Y , final int scroll Range , final int fuzzy Threshold , final float scale Factor , final boolean is Touch Event ) { final int delta Value , current Scroll Value , scroll Value ; switch ( view . get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : delta Value = delta X ; scroll Value = scroll X ; current Scroll Value = view . get Scroll X ( ) ; break ; case VERTICAL : default : delta Value = delta Y ; scroll Value = scroll Y ; current Scroll Value = view . get Scroll Y ( ) ; break ; } if ( view . is Pull To Refresh Over Scroll Enabled ( ) && ! view . is Refreshing ( ) ) { final Mode mode = view . get Mode ( ) ; if ( mode . permits Pull To Refresh ( ) && ! is Touch Event && delta Value != NUM ) { final int new Scroll Value = ( delta Value + scroll Value ) ; if ( Pull To Refresh Base . DEBUG ) { Log . d ( LOG TAG , STRING + delta X + STRING + scroll X + STRING + delta Y + STRING + scroll Y + STRING + new Scroll Value + STRING + scroll Range + STRING + current Scroll Value ) ; } if ( new Scroll Value < ( NUM - fuzzy Threshold ) ) { if ( mode . show Header Loading Layout ( ) ) { if ( current Scroll Value == NUM ) { view . set State ( State . OVERSCROLLING ) ; } view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value ) ) ) ; } } else if ( new Scroll Value > ( scroll Range + fuzzy Threshold ) ) { if ( mode . show Footer Loading Layout ( ) ) { if ( current Scroll Value == NUM ) { view . set State ( State . OVERSCROLLING ) ; } view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value - scroll Range ) ) ) ; } } else if ( Math . abs ( new Scroll Value ) <= fuzzy Threshold || Math . abs ( new Scroll Value - scroll Range ) <= fuzzy Threshold ) { view . set State ( State . RESET ) ; } } else if ( is Touch Event && State . OVERSCROLLING == view . get State ( ) ) { view . set State ( State . RESET ) ; } } }
private Process execute Compiler ( Array List < String > arg List , Array List < String > env List , boolean chdir ) throws IO Exception { String [ ] args ; if ( chdir ) { Char Buffer cb = new Char Buffer ( ) ; cb . append ( STRING ) ; cb . append ( compiler . get Source Dir Name ( ) ) ; cb . append ( STRING ) ; for ( int i = NUM ; i < arg List . size ( ) ; i ++ ) { cb . append ( STRING ) ; cb . append ( arg List . get ( i ) ) ; } args = new String [ NUM ] ; args [ NUM ] = STRING ; args [ NUM ] = STRING ; args [ NUM ] = cb . to String ( ) ; } else { args = new String [ arg List . size ( ) ] ; arg List . to Array ( args ) ; } String [ ] envp = new String [ env List . size ( ) ] ; env List . to Array ( envp ) ; if ( log . is Loggable ( Level . FINE ) ) { Char Buffer cb = Char Buffer . allocate ( ) ; for ( int i = NUM ; i < args . length ; i ++ ) { if ( i != NUM ) cb . append ( STRING ) ; cb . append ( args [ i ] ) ; } log . fine ( cb . close ( ) ) ; } Runtime runtime = Runtime . get Runtime ( ) ; try { return runtime . exec ( args ) ; } catch ( Exception e ) { throw new Java Compile Exception ( L . l ( STRING , args [ NUM ] , String . value Of ( e ) ) ) ; } }
public void collapse All Parents ( ) { if ( m Data List != null && ! m Data List . is Empty ( ) ) { Array List < Object > expandable List Items = get Parents ( BOOL ) ; if ( expandable List Items != null && ! expandable List Items . is Empty ( ) ) { final int expanded Item Size = expandable List Items . size ( ) ; if ( expanded Item Size > NUM ) { for ( int i = NUM ; i < expanded Item Size ; i ++ ) { Object o = expandable List Items . get ( i ) ; int index Of = m Data List . index Of ( o ) ; if ( index Of >= NUM ) collapse List Item ( index Of , ( Base Expandable Observable ) o , BOOL ) ; } } } } }
@ Deprecated protected Pdf Form X Object draw Push Button Appearance ( float width , float height , String text , Pdf Font font , int font Size ) { return draw Push Button Appearance ( width , height , text , font , ( float ) font Size ) ; }
public NBT Tag Compound load File ( File save Directory , String filename ) { return load File ( new File ( save Directory , filename + STRING ) ) ; }
public boolean dns Domain Is ( String host , String domain ) { return host . ends With ( domain ) ; }
@ Suppress Warnings ( STRING ) public Selection Builder reset ( ) { m Table = null ; if ( m Projection Map != null ) { m Projection Map . clear ( ) ; } if ( m Selection != null ) { m Selection . set Length ( NUM ) ; } if ( m Selection Args != null ) { m Selection Args . clear ( ) ; } return this ; }
private final synchronized Enumeration < Policy Entry > elements ( ) { return policy Entries . elements ( ) ; }
public String format ( Calendar calendar , Calendar smsc Calendar ) { if ( calendar == null || smsc Calendar == null ) { return null ; } long diff Time In Millis = calendar . get Time In Millis ( ) - smsc Calendar . get Time In Millis ( ) ; if ( diff Time In Millis < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } Calendar offset Epoch = Calendar . get Instance ( utc Time Zone ) ; offset Epoch . set Time In Millis ( diff Time In Millis ) ; int years = offset Epoch . get ( Calendar . YEAR ) - NUM ; int months = offset Epoch . get ( Calendar . MONTH ) ; int days = offset Epoch . get ( Calendar . DAY OF MONTH ) - NUM ; int hours = offset Epoch . get ( Calendar . HOUR OF DAY ) ; int minutes = offset Epoch . get ( Calendar . MINUTE ) ; int seconds = offset Epoch . get ( Calendar . SECOND ) ; if ( years >= NUM ) { throw new Illegal Argument Exception ( STRING + years + STRING ) ; } return format ( years , months , days , hours , minutes , seconds ) ; }
private void calculate Entropy ( double scale , K Star Wrapper params ) { int i , j , k ; double actent = NUM , randent = NUM ; double pstar , tprob , avgprob = NUM , minprob = NUM ; double act Class Prob , rand Class Prob ; double [ ] [ ] pseudo Class Probs = new double [ NUM RAND COLS + NUM ] [ m Num Classes ] ; for ( j = NUM ; j <= NUM RAND COLS ; j ++ ) { for ( i = NUM ; i < m Num Classes ; i ++ ) { pseudo Class Probs [ j ] [ i ] = NUM ; } } for ( i = NUM ; i < m Num Instances ; i ++ ) { if ( m Distances [ i ] < NUM ) { continue ; } else { pstar = P Star ( m Distances [ i ] , scale ) ; tprob = pstar / m Actual Count ; avgprob += tprob ; if ( pstar < minprob ) { minprob = pstar ; } for ( k = NUM ; k <= NUM RAND COLS ; k ++ ) { pseudo Class Probs [ k ] [ m Rand Class Cols [ k ] [ i ] ] += tprob ; } } } for ( j = m Num Classes - NUM ; j >= NUM ; j -- ) { act Class Prob = pseudo Class Probs [ NUM RAND COLS ] [ j ] / avgprob ; if ( act Class Prob > NUM ) { actent -= act Class Prob * Math . log ( act Class Prob ) / LOG 2 ; } } for ( k = NUM ; k < NUM RAND COLS ; k ++ ) { for ( i = m Num Classes - NUM ; i >= NUM ; i -- ) { rand Class Prob = pseudo Class Probs [ k ] [ i ] / avgprob ; if ( rand Class Prob > NUM ) { randent -= rand Class Prob * Math . log ( rand Class Prob ) / LOG 2 ; } } } randent /= NUM RAND COLS ; params . act Entropy = actent ; params . rand Entropy = randent ; params . avg Prob = avgprob ; params . min Prob = minprob ; }
public static void init Cause ( Throwable throwable , Throwable cause ) { if ( INIT CAUSE METHOD != null ) { try { INIT CAUSE METHOD . invoke ( throwable , new Object [ ] { cause } ) ; } catch ( Exception e ) { } } }
public void test Bug 20685022 ( ) throws Exception { if ( ! is Community Edition ( ) ) { return ; } final Properties props = new Properties ( ) ; props . clear ( ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; get Connection With Props ( props ) ; props . clear ( ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; get Connection With Props ( props ) ; props . clear ( ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; props . set Property ( STRING , STRING ) ; String trust Store Path = STRING ; System . set Property ( STRING , trust Store Path ) ; System . set Property ( STRING , STRING ) ; System . set Property ( STRING , trust Store Path ) ; System . set Property ( STRING , STRING ) ; get Connection With Props ( props ) ; }
public static boolean can Run ( final File file ) { return manager . get Engine By Extension ( File Utils . get File Extension ( file ) ) != null ; }
public void parse Element ( String tag Name , Map < String , Object > attrs ) { if ( canvas == null && tag Name . equals Ignore Case ( STRING ) ) { scale = mx Utils . get Double ( attrs , STRING , NUM ) ; canvas = create Canvas ( attrs ) ; if ( canvas != null ) { canvas . set Scale ( scale ) ; } } else if ( canvas != null ) { boolean draw Label = BOOL ; if ( tag Name . equals Ignore Case ( STRING ) || tag Name . equals Ignore Case ( STRING ) ) { draw Vertex ( attrs ) ; draw Label = BOOL ; } else if ( tag Name . equals Ignore Case ( STRING ) ) { draw Edge ( attrs ) ; draw Label = BOOL ; } if ( draw Label ) { draw Label ( tag Name . equals Ignore Case ( STRING ) , attrs ) ; } } }
private void start Precaching ( ) { Log . v ( TAG , STRING ) ; prepare Native Libraries ( ) ; s Is Precaching = BOOL ; acquire Precaching Wake Lock ( ) ; m Precache Launcher . start ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public Word Alignment State ( final Rule rule , final int start ) { trg Points = new Linked List < > ( ) ; src Length = rule . get French ( ) . length ; num NT = rule . get Arity ( ) ; src Start = start ; final Map < Integer , List < Integer > > alignment Map = rule . get Alignment Map ( ) ; final int [ ] non Terminal Source Positions = rule . get Non Terminal Source Positions ( ) ; final int [ ] trg = rule . get English ( ) ; for ( int trg Index = NUM ; trg Index < trg . length ; trg Index ++ ) { final Aligned Source Tokens trg Point = new Aligned Source Tokens ( ) ; if ( trg [ trg Index ] >= NUM ) { if ( alignment Map . contains Key ( trg Index ) ) { for ( int src Idx : alignment Map . get ( trg Index ) ) { trg Point . add ( src Start + src Idx ) ; } } else { trg Point . set Null ( ) ; } } else { trg Point . set Non Terminal ( ) ; final int absolute Non Terminal Source Position = src Start + non Terminal Source Positions [ Math . abs ( trg [ trg Index ] ) - NUM ] ; trg Point . add ( absolute Non Terminal Source Position ) ; } trg Points . add ( trg Point ) ; } }
protected void configure Image Reader Loaders ( ) { image Reader Loaders = new Vector < Image Reader Loader > ( ) ; Image Reader Loader idl = ( Image Reader Loader ) Component Factory . create ( STRING ) ; if ( idl != null ) { image Reader Loaders . add ( idl ) ; } else { logger . warning ( STRING ) ; } idl = ( Image Reader Loader ) Component Factory . create ( STRING ) ; if ( idl != null ) { image Reader Loaders . add ( idl ) ; } else { logger . warning ( STRING ) ; } }
protected void handle Special Substitution ( String replace , String replace With , int start Pos , String description ) { if ( replace . equals ( STRING ) ) { if ( replace With . char At ( NUM ) == STRING ) { error ( STRING , start Pos , description ) ; } ignore Chars = Char Set . parse String ( replace With ) ; } }
@ Override public void count Example ( Example example ) { double plabel ; double label = example . get Value ( label Attribute ) ; if ( ! predicted Attribute . is Nominal ( ) ) { plabel = example . get Value ( predicted Attribute ) ; } else { String label S = example . get Value As String ( label Attribute ) ; plabel = example . get Confidence ( label S ) ; label = NUM ; } double weight = NUM ; if ( weight Attribute != null ) { weight = example . get Value ( weight Attribute ) ; } double diff = weight * Math . abs ( label - plabel ) ; deviation Sum += diff ; double rel Diff = Math . abs ( weight * label - ( true Label Sum / example Counter ) ) ; relative Sum += rel Diff ; }
public static void unzip ( String zip File , String location ) throws IO Exception { final int BUFFER SIZE = NUM ; int size ; byte [ ] buffer = new byte [ BUFFER SIZE ] ; try { if ( ! location . ends With ( STRING ) ) { location += STRING ; } File f = new File ( location ) ; if ( ! f . is Directory ( ) ) { f . mkdirs ( ) ; } Zip Input Stream zin = new Zip Input Stream ( new Buffered Input Stream ( new File Input Stream ( zip File ) , BUFFER SIZE ) ) ; try { Zip Entry ze = null ; while ( ( ze = zin . get Next Entry ( ) ) != null ) { String path = location + ze . get Name ( ) ; File unzip File = new File ( path ) ; if ( ze . is Directory ( ) ) { if ( ! unzip File . is Directory ( ) ) { unzip File . mkdirs ( ) ; } } else { File parent Dir = unzip File . get Parent File ( ) ; if ( null != parent Dir ) { if ( ! parent Dir . is Directory ( ) ) { parent Dir . mkdirs ( ) ; } } File Output Stream out = new File Output Stream ( unzip File , BOOL ) ; Buffered Output Stream fout = new Buffered Output Stream ( out , BUFFER SIZE ) ; try { while ( ( size = zin . read ( buffer , NUM , BUFFER SIZE ) ) != - NUM ) { fout . write ( buffer , NUM , size ) ; } zin . close Entry ( ) ; } finally { fout . flush ( ) ; fout . close ( ) ; } } } } finally { zin . close ( ) ; } } catch ( Exception e ) { Log . e ( TAG , STRING , e ) ; } }
private void add Decl Annotations ( Map < String , Set < Annotation Mirror > > decl Annos , Element elt ) { if ( from Stub File != null ) { Set < Annotation Mirror > annos = decl Annos . get ( Element Utils . get Verbose Name ( elt ) ) ; if ( annos == null ) { annos = Annotation Utils . create Annotation Set ( ) ; put Or Add To Map ( decl Annos , Element Utils . get Verbose Name ( elt ) , annos ) ; } annos . add ( from Stub File ) ; } }
private void inspect Conditions With Booleans ( Linked List < Psi Element > obj Branch Conditions ) { for ( Psi Element obj Expression : obj Branch Conditions ) { if ( ! ( obj Expression instanceof Constant Reference ) ) { continue ; } if ( Expression Semantic Util . is Boolean ( ( Constant Reference ) obj Expression ) ) { holder . register Problem ( obj Expression , str Problem Description Booleans , Problem Highlight Type . GENERIC ERROR OR WARNING ) ; } } }
public static X Content Type x Content Type ( Char Sequence content ) { int length = content . length ( ) < GUESS HEADER LENGTH ? content . length ( ) : GUESS HEADER LENGTH ; if ( length == NUM ) { return null ; } char first = content . char At ( NUM ) ; if ( first == STRING ) { return X Content Type . JSON ; } if ( length > NUM && first == Smile Constants . HEADER BYTE 1 && content . char At ( NUM ) == Smile Constants . HEADER BYTE 2 && content . char At ( NUM ) == Smile Constants . HEADER BYTE 3 ) { return X Content Type . SMILE ; } if ( length > NUM && first == STRING && content . char At ( NUM ) == STRING && content . char At ( NUM ) == STRING ) { return X Content Type . YAML ; } for ( int i = NUM ; i < length ; i ++ ) { char c = content . char At ( i ) ; if ( c == STRING ) { return X Content Type . JSON ; } if ( Character . is Whitespace ( c ) == BOOL ) { break ; } } return null ; }
@ Request Mapping ( value = STRING , method = Request Method . DELETE ) public Response Entity < Bookmark > delete Bookmark ( @ Path Variable ( value = STRING ) String username , @ Path Variable ( value = STRING ) int bookmark Id ) throws Bookmark Not Found Exception { Optional < Bookmark > optional = bookmarks Repository . find By Id And User Username ( bookmark Id , username ) ; if ( optional . is Present ( ) ) { bookmarks Repository . delete ( optional . get ( ) ) ; return new Response Entity < > ( optional . get ( ) , Http Status . OK ) ; } else { throw new Bookmark Not Found Exception ( STRING + bookmark Id ) ; } }
public static Object load Instance ( Class clazz , Object default Value ) { try { return clazz . new Instance ( ) ; } catch ( Throwable t ) { return default Value ; } }
public static String to JSON String ( Object value ) { final String Writer writer = new String Writer ( ) ; try { write JSON String ( value , writer ) ; return writer . to String ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public static final < A > Collection X < A > to Lazy Collection ( final Stream < A > stream ) { return Seq Utils . to Lazy Collection ( stream . iterator ( ) ) ; }
public JSON Tokener ( Reader reader ) { this . reader = reader . mark Supported ( ) ? reader : new Buffered Reader ( reader ) ; this . eof = BOOL ; this . use Previous = BOOL ; this . previous = NUM ; this . index = NUM ; this . character = NUM ; this . line = NUM ; }
static Unit value Of ( String name , boolean horizontal ) { if ( name . length ( ) == NUM ) { Unit default Unit = Sizes . get Default Unit ( ) ; if ( default Unit != null ) { return default Unit ; } return horizontal ? DIALOG UNITS X : DIALOG UNITS Y ; } else if ( name . equals ( STRING ) ) { return PIXEL ; } else if ( name . equals ( STRING ) ) { return horizontal ? DIALOG UNITS X : DIALOG UNITS Y ; } else if ( name . equals ( STRING ) ) { return POINT ; } else if ( name . equals ( STRING ) ) { return INCH ; } else if ( name . equals ( STRING ) ) { return MILLIMETER ; } else if ( name . equals ( STRING ) ) { return CENTIMETER ; } else { throw new Illegal Argument Exception ( STRING + name + STRING + STRING ) ; } }
public void check Number Args ( int arg Num ) throws Wrong Number Args Exception { if ( ( arg Num < NUM ) || ( arg Num > NUM ) ) report Wrong Number Args ( ) ; }
